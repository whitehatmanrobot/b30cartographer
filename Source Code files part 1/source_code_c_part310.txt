 else {
        //
        // Error condition
        //
        XmlMgrSacPutErrorMessage(L"cmd-channel", L"SAC_CMD_SERVICE_ERROR");

    }

DoCmdCommandCleanup:

    KeReleaseMutex(&SACCmdEventInfoMutex, FALSE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\xmlcmd.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    conmgr.h

Abstract:

    Routines for managing channels.

Author:

    Brian Guarraci (briangu) March, 2001.

Revision History:

--*/

#ifndef XML_CMD_H
#define XML_CMD_H

#include "iomgr.h" 

VOID
XmlCmdDoHelpCommand(
    VOID
    );

VOID
XmlCmdDoKillCommand(
    PUCHAR InputLine
    );

VOID
XmlCmdDoLowerPriorityCommand(
    PUCHAR InputLine
    );

VOID
XmlCmdDoRaisePriorityCommand(
    PUCHAR InputLine
    );

VOID
XmlCmdDoLimitMemoryCommand(
    PUCHAR InputLine
    );

VOID
XmlCmdDoSetTimeCommand(
    PUCHAR InputLine
    );

VOID
XmlCmdDoSetIpAddressCommand(
    PUCHAR InputLine
    );

VOID
XmlCmdDoRebootCommand(
    BOOLEAN Reboot
    );

VOID
XmlCmdDoCrashCommand(
    VOID
    );

VOID
XmlCmdDoFullInfoCommand(
    VOID
    );

VOID
XmlCmdDoPagingCommand(
    VOID
    );

VOID
XmlCmdDoTlistCommand(
    VOID
    );

VOID
XmlCmdSubmitIPIoRequest(
    );

VOID
XmlCmdCancelIPIoRequest(
    );

VOID
XmlCmdDoMachineInformationCommand(
    VOID
    );

VOID
XmlCmdDoChannelCommand(
    IN PUCHAR Name
    );

VOID
XmlCmdDoCmdCommand(
    IN PUCHAR Name
    );

VOID
XmlCmdDoKernelLogCommand(
    VOID
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\xmlmgr.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    XmlMgr.c

Abstract:

    Routines for managing channels in the sac.

Author:

    Brian Guarraci (briangu) March, 2001.

Revision History:

--*/

#include "sac.h"
#include "xmlcmd.h"

//
// Definitions for this file.
//

//
// Spinlock macros
//
#if 0
#define INIT_CURRENT_CHANNEL_LOCK()                     \
    KeInitializeMutex(                                  \
        &XmlMgrCurrentChannelLock,                      \
        0                                               \
        );                                              \
    XmlMgrCurrentChannelRefCount = 0;

#define LOCK_CURRENT_CHANNEL()                          \
    KdPrint((":? cclock: %d\r\n", __LINE__));           \
    {                                                   \
        NTSTATUS    Status;                             \
        Status = KeWaitForMutexObject(                  \
            &XmlMgrCurrentChannelLock,                  \
            Executive,                                  \
            KernelMode,                                 \
            FALSE,                                      \
            NULL                                        \
            );                                          \
        ASSERT(Status == STATUS_SUCCESS);               \
    }                                                   \
    ASSERT(XmlMgrCurrentChannelRefCount == 0);          \
    InterlockedIncrement(&XmlMgrCurrentChannelRefCount);\
    ASSERT(XmlMgrCurrentChannelRefCount == 1);          \
    KdPrint((":) cclock: %d\r\n", __LINE__));

#define UNLOCK_CURRENT_CHANNEL()                        \
    KdPrint((":* cclock: %d\r\n", __LINE__));           \
    ASSERT(XmlMgrCurrentChannelRefCount == 1);                \
    InterlockedDecrement(&XmlMgrCurrentChannelRefCount);      \
    ASSERT(XmlMgrCurrentChannelRefCount == 0);                \
    ASSERT(KeReadStateMutex(&XmlMgrCurrentChannelLock)==0);   \
    ASSERT(KeReleaseMutex(&XmlMgrCurrentChannelLock,FALSE)==0);\
    KdPrint((":( cclock: %d\r\n", __LINE__));

#else                                                   
#define INIT_CURRENT_CHANNEL_LOCK()                     \
    KeInitializeMutex(                                  \
        &XmlMgrCurrentChannelLock,                      \
        0                                               \
        );                                              \
    XmlMgrCurrentChannelRefCount = 0;

#define LOCK_CURRENT_CHANNEL()                          \
    {                                                   \
        NTSTATUS    Status;                             \
        Status = KeWaitForMutexObject(                  \
            &XmlMgrCurrentChannelLock,                  \
            Executive,                                  \
            KernelMode,                                 \
            FALSE,                                      \
            NULL                                        \
            );                                          \
        ASSERT(Status == STATUS_SUCCESS);               \
    }                                                   \
    ASSERT(XmlMgrCurrentChannelRefCount == 0);                \
    InterlockedIncrement(&XmlMgrCurrentChannelRefCount);      \
    ASSERT(XmlMgrCurrentChannelRefCount == 1);                

#define UNLOCK_CURRENT_CHANNEL()                              \
    ASSERT(XmlMgrCurrentChannelRefCount == 1);                \
    InterlockedDecrement(&XmlMgrCurrentChannelRefCount);      \
    ASSERT(XmlMgrCurrentChannelRefCount == 0);                \
    ASSERT(KeReadStateMutex(&XmlMgrCurrentChannelLock)==0);   \
    ASSERT(KeReleaseMutex(&XmlMgrCurrentChannelLock,FALSE)==0);

#endif

//
// lock for r/w access on current channel globals
//
KMUTEX  XmlMgrCurrentChannelLock;
ULONG   XmlMgrCurrentChannelRefCount;

BOOLEAN             XmlMgrInputInEscape = FALSE;
UCHAR               XmlMgrInputBuffer[SAC_VT100_COL_WIDTH];

PSAC_CHANNEL        XmlMgrSacChannel = NULL;

#define SAC_CHANNEL_INDEX   0


//
//
//
SAC_CHANNEL_HANDLE  XmlMgrCurrentChannelHandle;

//
// The index of the current channel in the global channel list
//
ULONG   XmlMgrCurrentChannelIndex = 0;

WCHAR SacOWriteUnicodeValue;
UCHAR SacOWriteUtf8ConversionBuffer[3];

VOID
XmlMgrSerialPortConsumer(
    IN PSAC_DEVICE_CONTEXT DeviceContext
    );

BOOLEAN
XmlMgrProcessInputLine(
    VOID
    );

NTSTATUS
XmlMgrInitialize(
    VOID
    )
/*++

Routine Description:

    Initialize the console manager

Arguments:
    
    none
    
Return Value:

    Status

--*/
{
    NTSTATUS                Status;
    PSAC_CMD_OPEN_CHANNEL   OpenChannelCmd;
    PWSTR                   XMLBuffer;

    //
    // Get the global buffer started so that we have room for error messages.
    //
    if (GlobalBuffer == NULL) {
        
        GlobalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);

        if (GlobalBuffer == NULL) {
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting (1).\n")));
            return STATUS_NO_MEMORY;
        }

        GlobalBufferSize = MEMORY_INCREMENT;
    
    }

    //
    // Initialize the Serial port globals
    //

    INIT_CURRENT_CHANNEL_LOCK();
    
    //
    // Lock down the current channel globals
    //
    // Note: we need to do this here since many of the XmlMgr support
    //       routines do ASSERTs to ensure the current channel lock is held
    //
    LOCK_CURRENT_CHANNEL();

    //
    // Initialize
    //
    do {

        //
        // create the open channel cmd that will open the SAC channel
        //
        Status = ChanMgrCreateOpenChannelCmd(
            &OpenChannelCmd,
            ChannelTypeRaw,
            PRIMARY_SAC_CHANNEL_NAME,
            PRIMARY_SAC_CHANNEL_DESCRIPTION,
            SAC_CHANNEL_FLAG_PRESERVE,
            NULL,
            NULL,
            PRIMARY_SAC_CHANNEL_APPLICATION_GUID
            );

        if (! NT_SUCCESS(Status)) {
            break;        
        }

        //
        // create the SAC channel
        //
        Status = ChanMgrCreateChannel(
            &XmlMgrSacChannel, 
            OpenChannelCmd
            );

        FREE_POOL(&OpenChannelCmd);

        if (! NT_SUCCESS(Status)) {
            break;        
        }

        //
        // Make the SAC channel the current channel
        //
        Status = XmlMgrSetCurrentChannel(
            SAC_CHANNEL_INDEX, 
            XmlMgrSacChannel
            );

        if (! NT_SUCCESS(Status)) {
            break;        
        }
        
        //
        // We are done with the Channel
        //
        Status = ChanMgrReleaseChannel(XmlMgrSacChannel);

        if (! NT_SUCCESS(Status)) {
            break;        
        }

        //
        // Flush the channel data to the screen
        //
        Status = XmlMgrDisplayCurrentChannel();

        if (! NT_SUCCESS(Status)) {
            break;        
        }
        
        //
        // NOTE: this really belongs back in data.c (InitializeDeviceData) since it is
        //       a global behavior
        //
        // Send XML machine information to management application
        //
        // <<<<
        Status = TranslateMachineInformationXML(
            &XMLBuffer, 
            NULL
            );

        if (NT_SUCCESS(Status)) {
            XmlMgrSacPutString(XML_VERSION_HEADER);
            XmlMgrSacPutString(XMLBuffer);
            FREE_POOL(&XMLBuffer);
        }
        // <<<<

        //
        // Display the prompt
        //
        Status = HeadlessDispatch(
            HeadlessCmdClearDisplay, 
            NULL, 
            0,
            NULL,
            NULL
            );

        if (! NT_SUCCESS(Status)) {

            IF_SAC_DEBUG(
                SAC_DEBUG_FAILS, 
                KdPrint(("SAC InitializeDeviceData: Failed dispatch\n")));

        }

        XmlMgrEventMessage(L"SAC_INITIALIZED");
    
    } while (FALSE);
    
    //
    // We are done with the current channel globals
    //
    UNLOCK_CURRENT_CHANNEL();
    
    return STATUS_SUCCESS;
}

NTSTATUS
XmlMgrShutdown(
    VOID
    )
/*++

Routine Description:

    Shutdown the console manager

Arguments:

    none
    
Return Value:

    Status

--*/
{
    if (GlobalBuffer) {
        FREE_POOL(&GlobalBuffer);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
XmlMgrDisplayFastChannelSwitchingInterface(
    PSAC_CHANNEL    Channel
    )
/*++

Routine Description:

    This routine displays the fast-channel-switching interface
    
    Note: caller must hold channel mutex

Arguments:

    Channel - Channel to display
    
Return Value:

    Status

--*/
{
    HEADLESS_CMD_POSITION_CURSOR SetCursor;
    HEADLESS_CMD_SET_COLOR SetColor;
    PCWSTR      Message;
    NTSTATUS    Status;
    BOOLEAN     bStatus;
    ULONG       Length;
    PWSTR       LocalBuffer;

    ASSERT(XmlMgrCurrentChannelRefCount == 1);

    //
    // Display the Fast-Channel-Switching interface
    //

    LocalBuffer = NULL;

    do {

        LocalBuffer = ALLOCATE_POOL(0x100 * sizeof(WCHAR), GENERAL_POOL_TAG);
        ASSERT(LocalBuffer);
        if (!LocalBuffer) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        
        //
        // We cannot use the standard XmlMgrSacPutString() functions, because those write 
        // over the channel screen buffer.  We force directly onto the terminal here.
        //
        ASSERT(Utf8ConversionBuffer);
        if (!Utf8ConversionBuffer) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        swprintf(
            LocalBuffer,
            L"<event type='channel-switch' channel-name='%s'/>\r\n",
            ChannelGetName(Channel)
            );

        //
        //
        //
        ASSERT((wcslen(LocalBuffer) + 1) * sizeof(WCHAR) < Utf8ConversionBufferSize);

        bStatus = SacTranslateUnicodeToUtf8(
            LocalBuffer, 
            (PUCHAR)Utf8ConversionBuffer,
            Utf8ConversionBufferSize
            );
        if (! bStatus) {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        //
        // Ensure that the utf8 buffer contains a non-emtpy string
        //
        Length = strlen(Utf8ConversionBuffer);
        ASSERT(Length > 0);
        if (Length == 0) {
            break;
        }

        Status = HeadlessDispatch(
            HeadlessCmdPutData,
            (PUCHAR)Utf8ConversionBuffer,
            strlen(Utf8ConversionBuffer) * sizeof(UCHAR),
            NULL,
            NULL
            );
        if (! NT_SUCCESS(Status)) {
            ASSERT(strlen(Utf8ConversionBuffer) > 0);
            break;
        }
    
    } while ( FALSE );

    if (LocalBuffer) {
        FREE_POOL(&LocalBuffer);
    }

    return Status;
}

NTSTATUS
XmlMgrResetCurrentChannel(
    VOID
    )
/*++

Routine Description:

    This routine makes the SAC the current channel
    
    Note: caller must hold channel mutex

Arguments:

    ChannelIndex - The new index of the current channel
    NewChannel   - the new current channel
    
Return Value:

    Status

--*/
{
    NTSTATUS    Status;

    ASSERT(XmlMgrCurrentChannelRefCount == 1);
    
    Status = XmlMgrSetCurrentChannel(
        SAC_CHANNEL_INDEX,
        XmlMgrSacChannel
        );
                
    if (! NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Flush the buffered channel data to the screen
    //
    // Note: we don't need to lock down the SAC, since we own it
    //
    Status = XmlMgrDisplayCurrentChannel();

    return Status;

}


NTSTATUS
XmlMgrSetCurrentChannel(
    IN ULONG        ChannelIndex,
    IN PSAC_CHANNEL XmlMgrCurrentChannel
    )
/*++

Routine Description:

    This routine sets the currently active channel to the one given. 
    
    Note: caller must hold channel mutex

Arguments:

    ChannelIndex - The new index of the current channel
    NewChannel   - the new current channel
    
Return Value:

    Status

--*/
{
    NTSTATUS        Status;

    ASSERT(XmlMgrCurrentChannelRefCount == 1);
    
    //
    // Update the current channel 
    // 
    XmlMgrCurrentChannelIndex = ChannelIndex;

    //
    // Keep track of the handle
    //
    XmlMgrCurrentChannelHandle = XmlMgrCurrentChannel->Handle;

    //
    // Update the sent to screen status
    //
    XmlMgrCurrentChannel->SentToScreen = FALSE;

    return STATUS_SUCCESS;

}

NTSTATUS
XmlMgrDisplayCurrentChannel(
    VOID
    )
/*++

Routine Description:

    This routine sets the currently active channel to the one given.  It will transmit
    the channel buffer to the terminal if SendToScreen is TRUE.
    
    Note: caller must hold channel mutex

Arguments:

    None
    
Return Value:

    Status

--*/
{
    NTSTATUS        Status;
    PSAC_CHANNEL    Channel;

    ASSERT(XmlMgrCurrentChannelRefCount == 1);

    //
    // Get the current channel
    //
    Status = ChanMgrGetByHandle(
        XmlMgrCurrentChannelHandle,
        &Channel
        );
    if (! NT_SUCCESS(Status)) {
        return Status;
    }
    
    //
    // The channel buffer has been sent to the screen
    //
    Channel->SentToScreen = TRUE;
    
    //
    // Flush the buffered data to the screen
    //
    Status = Channel->OFlush(Channel);

    //
    // We are done with the current channel
    //
    ChanMgrReleaseChannel(Channel);

    return Status;

}

NTSTATUS
XmlMgrAdvanceXmlMgrCurrentChannel(
    VOID
    )
{
    NTSTATUS            Status;
    ULONG               NewIndex;
    PSAC_CHANNEL        Channel;

    ASSERT(XmlMgrCurrentChannelRefCount == 1);
    
    do {

        //
        // Query the channel manager for an array of currently active channels
        //
        Status = ChanMgrGetNextActiveChannel(
            XmlMgrCurrentChannelIndex,
            &NewIndex,
            &Channel
            );
    
        if (! NT_SUCCESS(Status)) {
            break;
        }
    
        //
        // Change the current channel to the next active channel
        //
        Status = XmlMgrSetCurrentChannel(
            NewIndex, 
            Channel
            );
    
        if (! NT_SUCCESS(Status)) {
            break;
        }
        
        //
        // Let the user know we switched via the Channel switching interface
        //
        Status = XmlMgrDisplayFastChannelSwitchingInterface(Channel);
    
        if (! NT_SUCCESS(Status)) {
            break;
        }
        
        //
        // We are done with the channel
        //
        Status = ChanMgrReleaseChannel(Channel);

    } while ( FALSE );

    return Status;
}

BOOLEAN
XmlMgrIsCurrentChannel(
    IN PSAC_CHANNEL    Channel
    )
/*++

Routine Description:

    Determine if the channel in question is the current channel

Arguments:

    ChannelHandle   - channel handle to compare against

Return Value:

    

--*/
{
    
//    ASSERT(XmlMgrCurrentChannelRefCount == 1);

    //
    // Determine if the channel in question is the current channel
    //
    return ChannelIsEqual(
        Channel,
        &XmlMgrCurrentChannelHandle
        );

}

VOID
XmlMgrWorkerProcessEvents(
    IN PSAC_DEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

        This is the routine for the worker thread.  It blocks on an event, when
    the event is signalled, then that indicates a request is ready to be processed.    

Arguments:

    DeviceContext - A pointer to this device.

Return Value:

    None.

--*/
{
    NTSTATUS    Status;
    KIRQL       OldIrql;
    PLIST_ENTRY ListEntry;
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC WorkerProcessEvents: Entering.\n")));

    //
    // Loop forever.
    //
    while (1) {
        
        //
        // Block until there is work to do.
        //
        Status = KeWaitForSingleObject(
            (PVOID)&(DeviceContext->ProcessEvent), 
            Executive, 
            KernelMode,  
            FALSE, 
            NULL
            );

        if (DeviceContext->ExitThread) {
            
            KdBreakPoint();

            XmlCmdCancelIPIoRequest();
            
            //
            // Make sure the user is looking at the SAC
            //
            XmlMgrResetCurrentChannel();

            //
            // Issue the shutting down message
            //
            XmlMgrEventMessage(L"SAC_UNLOADED");

            KeSetEvent(&(DeviceContext->ThreadExitEvent), DeviceContext->PriorityBoost, FALSE);
            
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC WorkerProcessEvents: Terminating.\n")));
            
            PsTerminateSystemThread(STATUS_SUCCESS);
        
        }

        switch (Status) {
        case STATUS_TIMEOUT:
        
            //
            // Do TIMEOUT work
            //

            break;

        default:
            
            //
            // Do EVENT work
            //

            switch ( ProcessingType ) {

            case SAC_PROCESS_SERIAL_PORT_BUFFER:

                //
                // Process teh serial port buffer and return a processing state
                //
                XmlMgrSerialPortConsumer(DeviceContext);

                break;

            case SAC_SUBMIT_IOCTL:

                if ( !IoctlSubmitted ) {
                    // submit the notify request with the 
                    // IP driver. This procedure will also 
                    // ensure that it is done only once in 
                    // the lifetime of the driver.
                    XmlCmdSubmitIPIoRequest();
                }
                break;

            default:
                break;
            }
            
            break;
        }

        //
        // Reset the process action
        //
        ProcessingType = SAC_NO_OP;

#if 0
        //
        // If there is any stuff that got delayed, process it.
        //
        DoDeferred(DeviceContext);
#endif
    
    }

    ASSERT(0);
}

#if 0

VOID
XmlMgrSerialPortConsumer(
    IN PSAC_DEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

        This is a DPC routine that is queue'd by DriverEntry.  It is used to check for any
    user input and then processes them.

Arguments:

    DeferredContext - A pointer to the device context.
    
    All other parameters are unused.

Return Value:

        None.

--*/
{
    NTSTATUS        Status;
    UCHAR           LocalTmpBuffer[4];
    PSAC_CHANNEL    XmlMgrCurrentChannel;
    ULONG           i;
    UCHAR           ch;

    do {

        //
        // Bail if there are no new characters to read
        //
        if (SerialPortConsumerIndex == SerialPortProducerIndex) {

            break;

        }

        //
        // Get new character
        //
        ch = SerialPortBuffer[SerialPortConsumerIndex];

        //
        // Compute the new producer index and store it atomically
        //
        InterlockedExchange(&SerialPortConsumerIndex, (SerialPortConsumerIndex + 1) % SERIAL_PORT_BUFFER_SIZE);
    
        //
        //
        //
        HeadlessDispatch(
            HeadlessCmdPutData,
            (PUCHAR)&ch,
            sizeof(UCHAR),
            NULL,
            NULL
            );


    } while ( TRUE );

}
#endif


VOID
XmlMgrSerialPortConsumer(
    IN PSAC_DEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

        This is a DPC routine that is queue'd by DriverEntry.  It is used to check for any
    user input and then processes them.

Arguments:

    DeferredContext - A pointer to the device context.
    
    All other parameters are unused.

Return Value:

        None.

--*/
{
    NTSTATUS        Status;
    UCHAR           LocalTmpBuffer[4];
    PSAC_CHANNEL    XmlMgrCurrentChannel;
    ULONG           i;
    UCHAR           ch;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE_LOUD, KdPrint(("SAC TimerDpcRoutine: Entering.\n")));


    //
    // lock down the current channel globals
    //
    LOCK_CURRENT_CHANNEL();

    //
    // Get the current channel
    //
    Status = ChanMgrGetByHandle(
        XmlMgrCurrentChannelHandle,
        &XmlMgrCurrentChannel
        );

    if (! NT_SUCCESS(Status)) {
        
        //
        // the current channel wasn't found, 
        // so reset the current channel to the SAC
        //
        XmlMgrResetCurrentChannel();

        //
        // We are done with current channel globals
        //
        UNLOCK_CURRENT_CHANNEL();
        
        return;
    
    }

    ASSERT(XmlMgrCurrentChannel != NULL);
    
GetNextByte:

    //
    // Bail if there are no new characters to read
    //
    if (SerialPortConsumerIndex == SerialPortProducerIndex) {
    
        goto XmlMgrSerialPortConsumerDone;
    
    }
    
    //
    // Get new character
    //
    ch = SerialPortBuffer[SerialPortConsumerIndex];

    //
    // Compute the new producer index and store it atomically
    //
    InterlockedExchange(&SerialPortConsumerIndex, (SerialPortConsumerIndex + 1) % SERIAL_PORT_BUFFER_SIZE);

    //
    // Check for <ESC><TAB>
    //
    if (ch == 0x1B) {

        XmlMgrInputInEscape = TRUE;

        goto GetNextByte;

    } else if ((ch == '\t') && XmlMgrInputInEscape) {
        
        XmlMgrInputInEscape = FALSE;

        do {

            //
            // We are done with the current channel
            //
            Status = ChanMgrReleaseChannel(XmlMgrCurrentChannel);

            if (!NT_SUCCESS(Status)) {
                break;
            }

            //
            // Find the next active channel and make it the current
            //
            Status = XmlMgrAdvanceXmlMgrCurrentChannel();

            if (!NT_SUCCESS(Status)) {
                break;
            }
            
            //
            // Get the current channel
            //
            Status = ChanMgrGetByHandle(
                XmlMgrCurrentChannelHandle,
                &XmlMgrCurrentChannel
                );
        
        } while ( FALSE );

        if (! NT_SUCCESS(Status)) {

            //
            // We are done with current channel globals
            //
            UNLOCK_CURRENT_CHANNEL();
            
            goto XmlMgrSerialPortConsumerExit;
        
        }

        goto GetNextByte;

    } else {

        //
        // If this screen has not yet been displayed, and the user entered a 0
        // then switch to the SAC Channel
        //
        if (!ChannelSentToScreen(XmlMgrCurrentChannel) && ch == '0') {

            //
            // Notify that we want the current channel to be displayed
            //
            XmlMgrInputInEscape = FALSE;
            
            do {

                //
                // We are done with the current channel
                //
                Status = ChanMgrReleaseChannel(XmlMgrCurrentChannel);

                if (!NT_SUCCESS(Status)) {
                    break;
                }
                
                //
                // Make the current channel the SAC
                //
                // Note: There should not be anything modifying the XmlMgrSacChannel
                //       at this time, so this should be safe
                //
                Status = XmlMgrResetCurrentChannel();

                if (!NT_SUCCESS(Status)) {
                    break;
                }
                
                //
                // Get the current channel
                //
                Status = ChanMgrGetByHandle(
                    XmlMgrCurrentChannelHandle,
                    &XmlMgrCurrentChannel
                    );
            
            } while ( FALSE );

            if (! NT_SUCCESS(Status)) {

                //
                // We are done with current channel globals
                //
                UNLOCK_CURRENT_CHANNEL();

                goto XmlMgrSerialPortConsumerExit;

            }
            
            goto GetNextByte;

        }

        //
        // If this screen has not yet been displayed, and the user entered a keystroke,
        // then display it.
        //
        if (!ChannelSentToScreen(XmlMgrCurrentChannel)) {

            //
            // Notify that we want the current channel to be displayed
            //
            XmlMgrInputInEscape = FALSE;

            do {

                //
                // We are done with the current channel
                //
                Status = ChanMgrReleaseChannel(XmlMgrCurrentChannel);
                
                if (!NT_SUCCESS(Status)) {
                    break;
                }

                //
                // Flush the buffered channel data to the screen
                //
                Status = XmlMgrDisplayCurrentChannel();
                
                if (!NT_SUCCESS(Status)) {
                    break;
                }

                //
                // Get the current channel
                //
                Status = ChanMgrGetByHandle(
                    XmlMgrCurrentChannelHandle,
                    &XmlMgrCurrentChannel
                    );
            
            } while ( FALSE );
            
            if (! NT_SUCCESS(Status)) {

                //
                // We are done with current channel globals
                //
                UNLOCK_CURRENT_CHANNEL();

                goto XmlMgrSerialPortConsumerExit;

            }
            
            goto GetNextByte;

        }

        //
        // If the user was entering ESC-<something>, rebuffer the escape.  Note: <esc><esc>
        // buffers a single <esc>.  This allows sending an real <esc><tab> to the channel.
        //
        if (XmlMgrInputInEscape && (XmlMgrCurrentChannel != XmlMgrSacChannel) && (ch != 0x1B)) {
            LocalTmpBuffer[0] = 0x1B;
            Status = XmlMgrCurrentChannel->IWrite(XmlMgrCurrentChannel, LocalTmpBuffer, sizeof(LocalTmpBuffer[0]));
        }

        XmlMgrInputInEscape = FALSE;
        
        //
        // Buffer this input
        //
        LocalTmpBuffer[0] = ch;
        XmlMgrCurrentChannel->IWrite(XmlMgrCurrentChannel, LocalTmpBuffer, sizeof(LocalTmpBuffer[0]));

    }

    if (XmlMgrCurrentChannel != XmlMgrSacChannel) {
    
        goto GetNextByte;
    
    } else {
        
        //
        // Now do processing if the SAC is the active channel.
        //

        ULONG   ResponseLength;
        WCHAR   wch;

        // 
        // If this is a return, then we are done and need to return the line
        //
        if ((ch == '\n') || (ch == '\r')) {
            XmlMgrSacPutString(L"\r\n");
            XmlMgrCurrentChannel->IReadLast(XmlMgrCurrentChannel);
            LocalTmpBuffer[0] = '\0';
            XmlMgrCurrentChannel->IWrite(XmlMgrCurrentChannel, LocalTmpBuffer, sizeof(LocalTmpBuffer[0]));
            goto StripWhitespaceAndReturnLine;
        }

        //
        // If this is a backspace or delete, then we need to do that.
        //
        if ((ch == 0x8) || (ch == 0x7F)) {  // backspace (^H) or delete

            if (ChannelGetLengthOfBufferedInput(XmlMgrCurrentChannel) > 0) {
                XmlMgrSacPutString(L"\010 \010");
                XmlMgrCurrentChannel->IReadLast(XmlMgrCurrentChannel);
                XmlMgrCurrentChannel->IReadLast(XmlMgrCurrentChannel);
            }

        } else if (ch == 0x3) { // Control-C

            //
            // Terminate the string and return it.
            //
            XmlMgrCurrentChannel->IReadLast(XmlMgrCurrentChannel);
            LocalTmpBuffer[0] = '\0';
            XmlMgrCurrentChannel->IWrite(XmlMgrCurrentChannel, LocalTmpBuffer, sizeof(LocalTmpBuffer[0]));
            goto StripWhitespaceAndReturnLine;

        } else if (ch == 0x9) { // Tab

            //
            // Ignore tabs
            //
            XmlMgrCurrentChannel->IReadLast(XmlMgrCurrentChannel);
            XmlMgrSacPutString(L"\007"); // send a BEL
            goto GetNextByte;

        } else if (ChannelGetLengthOfBufferedInput(XmlMgrCurrentChannel) == SAC_VT100_COL_WIDTH - 2) {

            WCHAR   Buffer[4];

            //
            // We are at the end of the screen - remove the last character from 
            // the terminal screen and replace it with this one.
            //
            swprintf(Buffer, L"\010%c", ch);
            XmlMgrSacPutString(Buffer);
            XmlMgrCurrentChannel->IReadLast(XmlMgrCurrentChannel);
            XmlMgrCurrentChannel->IReadLast(XmlMgrCurrentChannel);
            LocalTmpBuffer[0] = ch;
            XmlMgrCurrentChannel->IWrite(XmlMgrCurrentChannel, LocalTmpBuffer, sizeof(LocalTmpBuffer[0]));

        } else {

            WCHAR   Buffer[4];
            
            //
            // Echo the character to the screen
            //
            swprintf(Buffer, L"%c", ch);
            XmlMgrSacPutString(Buffer);
        }

        goto GetNextByte;

StripWhitespaceAndReturnLine:

        //
        // Before returning the input line, strip off all leading and trailing blanks
        //
        do {
            LocalTmpBuffer[0] = (UCHAR)XmlMgrCurrentChannel->IReadLast(XmlMgrCurrentChannel);
        } while (((LocalTmpBuffer[0] == '\0') ||
                  (LocalTmpBuffer[0] == ' ')  ||
                  (LocalTmpBuffer[0] == '\t')) &&
                 (ChannelGetLengthOfBufferedInput(XmlMgrCurrentChannel) > 0)
                );

        XmlMgrCurrentChannel->IWrite(XmlMgrCurrentChannel, LocalTmpBuffer, sizeof(LocalTmpBuffer[0]));
        LocalTmpBuffer[0] = '\0';
        XmlMgrCurrentChannel->IWrite(XmlMgrCurrentChannel, LocalTmpBuffer, sizeof(LocalTmpBuffer[0]));

        do {

            ResponseLength = XmlMgrCurrentChannel->IRead(
                XmlMgrCurrentChannel, 
                (PUCHAR)&wch, 
                sizeof(UCHAR)
                );

            LocalTmpBuffer[0] = (UCHAR)wch;

        } while ((ResponseLength != 0) &&
                 ((LocalTmpBuffer[0] == ' ')  ||
                  (LocalTmpBuffer[0] == '\t')));

        XmlMgrInputBuffer[0] = LocalTmpBuffer[0];
        i = 1;

        do {
            
            ResponseLength = XmlMgrCurrentChannel->IRead(
                XmlMgrCurrentChannel, 
                (PUCHAR)&wch, 
                sizeof(UCHAR)
                );
            
            XmlMgrInputBuffer[i++] = (UCHAR)wch; 

        } while (ResponseLength != 0);

        //
        // Lower case all the characters.  We do not use strlwr() or the like, so that
        // the SAC (expecting ASCII always) doesn't accidently get DBCS or the like 
        // translation of the UCHAR stream.
        //
        for (i = 0; XmlMgrInputBuffer[i] != '\0'; i++) {
            if ((XmlMgrInputBuffer[i] >= 'A') && (XmlMgrInputBuffer[i] <= 'Z')) {
                XmlMgrInputBuffer[i] = XmlMgrInputBuffer[i] - 'A' + 'a';
            }
        }

        //
        // We are done with the current channel
        //
        Status = ChanMgrReleaseChannel(XmlMgrCurrentChannel);

        //
        // We are done with the current channel globals
        //
        UNLOCK_CURRENT_CHANNEL();
        
        if (!NT_SUCCESS(Status)) {
            goto XmlMgrSerialPortConsumerExit;
        }
        
        //
        // Process the input line.
        //
        if( XmlMgrProcessInputLine() == FALSE ) {
            //
            // We don't know what this is.
            //
            XmlMgrSacPutErrorMessage(L"sac", L"SAC_UNKNOWN_COMMAND");
        }

#if 0
        //
        // Put the next command prompt
        //
        XmlMgrSacPutSimpleMessage(SAC_PROMPT);
#endif
        
        //
        //
        //
        LOCK_CURRENT_CHANNEL();
        
        //
        // Get the current channel
        //
        Status = ChanMgrGetByHandle(
            XmlMgrCurrentChannelHandle,
            &XmlMgrCurrentChannel
            );

        if (! NT_SUCCESS(Status)) {

            //
            // We are done with the current channel globals
            //
            UNLOCK_CURRENT_CHANNEL();
            
            goto XmlMgrSerialPortConsumerExit;

        }
        
        goto GetNextByte;

    }
    
XmlMgrSerialPortConsumerDone:

    //
    // We are done with the current channel
    //
    ChanMgrReleaseChannel(XmlMgrCurrentChannel);
    
    //
    // We are done with current channel globals
    //
    UNLOCK_CURRENT_CHANNEL();
    
XmlMgrSerialPortConsumerExit:
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE_LOUD, KdPrint(("SAC TimerDpcRoutine: Exiting.\n")));

    return;
}


BOOLEAN
XmlMgrProcessInputLine(
    VOID
    )
/*++

Routine Description:

    This routine is called to process an input line.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PUCHAR          InputLine;
    BOOLEAN         CommandFound = FALSE;

    InputLine = &(XmlMgrInputBuffer[0]);

    if (!strcmp((LPSTR)InputLine, TLIST_COMMAND_STRING)) {
        XmlCmdDoTlistCommand();
        CommandFound = TRUE;
    } else if ((!strcmp((LPSTR)InputLine, HELP1_COMMAND_STRING)) ||
               (!strcmp((LPSTR)InputLine, HELP2_COMMAND_STRING))) {
        XmlCmdDoHelpCommand();
        CommandFound = TRUE;
    } else if (!strcmp((LPSTR)InputLine, DUMP_COMMAND_STRING)) {

        XmlCmdDoKernelLogCommand();
        CommandFound = TRUE;
                         
    } else if (!strcmp((LPSTR)InputLine, FULLINFO_COMMAND_STRING)) {
        XmlCmdDoFullInfoCommand();
        CommandFound = TRUE;
    } else if (!strcmp((LPSTR)InputLine, PAGING_COMMAND_STRING)) {
        XmlCmdDoPagingCommand();
        CommandFound = TRUE;
    } else if (!strncmp((LPSTR)InputLine, 
                        CHANNEL_COMMAND_STRING, 
                        strlen(CHANNEL_COMMAND_STRING))) {
        ULONG   Length;

        Length = strlen(CHANNEL_COMMAND_STRING);
        
        if (((strlen((LPSTR)InputLine) > 1) && (InputLine[Length] == ' ')) ||
            (strlen((LPSTR)InputLine) == strlen(CHANNEL_COMMAND_STRING))) {
            XmlCmdDoChannelCommand(InputLine);
            CommandFound = TRUE;
        }
    } else if (!strncmp((LPSTR)InputLine, 
                        CMD_COMMAND_STRING, 
                        strlen(CMD_COMMAND_STRING))) {
        ULONG   Length;

        Length = strlen(CMD_COMMAND_STRING);
        
        if (((strlen((LPSTR)InputLine) > 1) && (InputLine[Length] == ' ')) ||
            (strlen((LPSTR)InputLine) == strlen(CMD_COMMAND_STRING))) {
            XmlCmdDoCmdCommand(InputLine);
            CommandFound = TRUE;
        }
    } else if (!strcmp((LPSTR)InputLine, REBOOT_COMMAND_STRING)) {
        XmlCmdDoRebootCommand(TRUE);
        CommandFound = TRUE;
    } else if (!strcmp((LPSTR)InputLine, SHUTDOWN_COMMAND_STRING)) {
        XmlCmdDoRebootCommand(FALSE);
        CommandFound = TRUE;
    } else if (!strcmp((LPSTR)InputLine, CRASH_COMMAND_STRING)) {
        CommandFound = TRUE;
        XmlCmdDoCrashCommand(); // this call does not return
    } else if (!strncmp((LPSTR)InputLine, 
                        KILL_COMMAND_STRING, 
                        sizeof(KILL_COMMAND_STRING) - sizeof(UCHAR))) {
        if ((strlen((LPSTR)InputLine) > 1) && (InputLine[1] == ' ')) {
            XmlCmdDoKillCommand(InputLine);
            CommandFound = TRUE;
        }
    } else if (!strncmp((LPSTR)InputLine, 
                        LOWER_COMMAND_STRING, 
                        sizeof(LOWER_COMMAND_STRING) - sizeof(UCHAR))) {
        if ((strlen((LPSTR)InputLine) > 1) && (InputLine[1] == ' ')) {
            XmlCmdDoLowerPriorityCommand(InputLine);
            CommandFound = TRUE;
        }
    } else if (!strncmp((LPSTR)InputLine, 
                        RAISE_COMMAND_STRING, 
                        sizeof(RAISE_COMMAND_STRING) - sizeof(UCHAR))) {
        if ((strlen((LPSTR)InputLine) > 1) && (InputLine[1] == ' ')) {
            XmlCmdDoRaisePriorityCommand(InputLine);
            CommandFound = TRUE;
        }
    } else if (!strncmp((LPSTR)InputLine, 
                        LIMIT_COMMAND_STRING, 
                        sizeof(LIMIT_COMMAND_STRING) - sizeof(UCHAR))) {
        if ((strlen((LPSTR)InputLine) > 1) && (InputLine[1] == ' ')) {
            XmlCmdDoLimitMemoryCommand(InputLine);
            CommandFound = TRUE;
        }
    } else if (!strncmp((LPSTR)InputLine, 
                        TIME_COMMAND_STRING, 
                        sizeof(TIME_COMMAND_STRING) - sizeof(UCHAR))) {
        if (((strlen((LPSTR)InputLine) > 1) && (InputLine[1] == ' ')) ||
            (strlen((LPSTR)InputLine) == 1)) {
            XmlCmdDoSetTimeCommand(InputLine);
            CommandFound = TRUE;
        }
    } else if (!strcmp((LPSTR)InputLine, INFORMATION_COMMAND_STRING)) {
        XmlCmdDoMachineInformationCommand();
        CommandFound = TRUE;
    } else if (!strncmp((LPSTR)InputLine, 
                        SETIP_COMMAND_STRING, 
                        sizeof(SETIP_COMMAND_STRING) - sizeof(UCHAR))) {
        if (((strlen((LPSTR)InputLine) > 1) && (InputLine[1] == ' ')) ||
            (strlen((LPSTR)InputLine) == 1)) {
            XmlCmdDoSetIpAddressCommand(InputLine);
            CommandFound = TRUE;
        }
    } else if ((InputLine[0] == '\n') || (InputLine[0] == '\0')) {
        CommandFound = TRUE;
    }
        
    return CommandFound;
}

//
// Utility routines for writing to the SAC
//
BOOLEAN
XmlMgrChannelEventMessage(
    PCWSTR  String,
    PCWSTR  ChannelName
    )
/*++

Routine Description:

    This routine deploys an event message 
    
Arguments:

    String - The string to display.

Return Value:

        None.

--*/
{

    //
    // Currently, event messages are sent to the SAC channel
    //
    XmlMgrSacPutString(L"<event type='channel' name='");
    XmlMgrSacPutString(String);
    XmlMgrSacPutString(L"' channel-name='");
    XmlMgrSacPutString(ChannelName);
    XmlMgrSacPutString(L"'/>\r\n");

    return TRUE;
}

BOOLEAN
XmlMgrEventMessage(
    PCWSTR  String
    )

/*++

Routine Description:

    This routine deploys an event message 
    
Arguments:

    String - The string to display.

Return Value:

        None.

--*/
{

    //
    // Currently, event messages are sent to the SAC channel
    //
    XmlMgrSacPutString(L"<event type='global' name='");
    XmlMgrSacPutString(String);
    XmlMgrSacPutString(L"'/>\r\n");

    return TRUE;
}

VOID
XmlMgrSacPutString(
    PCWSTR  String
    )

/*++

Routine Description:

    This routine takes a string and packages it into a command structure for the
    HeadlessDispatch routine.

Arguments:

    String - The string to display.

Return Value:

        None.

--*/
{
    ULONG   StringLength;
    ULONG   UTF8Length;
    WCHAR   wchBuffer[2];
    BOOLEAN bStatus;
    ULONG   i;
    NTSTATUS    Status;
    PUCHAR  LocalUtf8ConversionBuffer;
    ULONG   LocalUtf8ConversionBufferSize;

    LocalUtf8ConversionBufferSize = 0x4 * sizeof(UCHAR);
    LocalUtf8ConversionBuffer = ALLOCATE_POOL(LocalUtf8ConversionBufferSize, GENERAL_POOL_TAG);
    ASSERT(LocalUtf8ConversionBuffer);
    if (!LocalUtf8ConversionBuffer) {
        IF_SAC_DEBUG(
            SAC_DEBUG_FAILS, 
            KdPrint(("SAC XmlMgrSacPutString: Failed allocating utf8 buffer.\n"))
            );
        return;
    }           

    ASSERT(FIELD_OFFSET(HEADLESS_CMD_PUT_STRING, String) == 0);  // ASSERT if anyone changes this structure.

    StringLength = wcslen(String);

    for (i = 0; i < StringLength; i++) {

        wchBuffer[0] = String[i];
        wchBuffer[1] = UNICODE_NULL;
        
        bStatus = SacTranslateUnicodeToUtf8(
            (PCWSTR)wchBuffer, 
            LocalUtf8ConversionBuffer,
            LocalUtf8ConversionBufferSize
            );
        
        if (! bStatus) {
            Status = STATUS_UNSUCCESSFUL;
            
            IF_SAC_DEBUG(
                SAC_DEBUG_FAILS, 
                KdPrint(("SAC XmlMgrSacPutString: Failed UTF8 encoding\n"))
                );
           
            break;
        }

        //
        // Ensure that the utf8 buffer contains a non-emtpy string
        //
        UTF8Length = strlen(LocalUtf8ConversionBuffer);
        ASSERT(UTF8Length > 0);
        if (UTF8Length == 0) {
            
            IF_SAC_DEBUG(
                SAC_DEBUG_FAILS, 
                KdPrint(("SAC XmlMgrSacPutString: Empty UTF8 buffer\n"))
                );
            
            break;
        }

        //
        // Write the uft8 encoding to the sac channel
        //
        Status = XmlMgrSacChannel->OWrite(
            XmlMgrSacChannel, 
            (PCUCHAR)LocalUtf8ConversionBuffer,
            UTF8Length*sizeof(UCHAR)
            );

        if (! NT_SUCCESS(Status)) {

            IF_SAC_DEBUG(
                SAC_DEBUG_FAILS, 
                KdPrint(("SAC XmlMgrSacPutString: OWrite failed\n"))
                );

            break;
        }

    }

    FREE_POOL(&LocalUtf8ConversionBuffer);

}

#if 0
BOOLEAN
XmlMgrSacPutSimpleMessage(
    ULONG MessageId
    )
/*++

Routine Description:

    This routine retrieves a message resource and sends it to the SAC channel
    
Arguments:

    MessageId   - The message id of the resource to send

Return Value:

    TRUE - the message was found
    otherwise, FALSE

--*/
{
    PCWSTR   p;

    p = GetMessage(MessageId);
       
    if (p) {
        XmlMgrSacPutString(p);        
        return(TRUE);
    }
    
    return(FALSE);

}
#endif

BOOLEAN
XmlMgrSacPutErrorMessage(
    PCWSTR  ActionName,
    PCWSTR  MessageId
    )
/*++

Routine Description:

    This routine retrieves a message resource and sends it to the SAC channel
    
Arguments:

    MessageId   - The message id of the resource to send

Return Value:

    TRUE - the message was found
    otherwise, FALSE

--*/
{
    XmlMgrSacPutString(L"<error ");
    XmlMgrSacPutString(L"action='");
    XmlMgrSacPutString(ActionName);
    XmlMgrSacPutString(L"' message-id='");
    XmlMgrSacPutString(MessageId);
    XmlMgrSacPutString(L"'/>\r\n");
    
    return(TRUE);
}

BOOLEAN
XmlMgrSacPutErrorMessageWithStatus(
    PCWSTR      ActionName,
    PCWSTR      MessageId,
    NTSTATUS    Status
    )
/*++

Routine Description:

    This routine retrieves a message resource and sends it to the SAC channel
    
Arguments:

    MessageId   - The message id of the resource to send

Return Value:

    TRUE - the message was found
    otherwise, FALSE

--*/
{
    PWSTR   Buffer;

    Buffer = ALLOCATE_POOL(0x100, GENERAL_POOL_TAG);
    ASSERT(Buffer);
    if (! Buffer) {
        return FALSE;
    }

    XmlMgrSacPutString(L"<error ");
    XmlMgrSacPutString(L"action='");
    XmlMgrSacPutString(ActionName);
    XmlMgrSacPutString(L"' message-id='");
    XmlMgrSacPutString(MessageId);
    XmlMgrSacPutString(L"' status='");
    
    swprintf(
        Buffer,
        L"%08x",
        Status
        );
    XmlMgrSacPutString(Buffer);
    XmlMgrSacPutString(L"'/>\r\n");
    
    FREE_POOL(&Buffer);

    return(TRUE);
}

NTSTATUS
XmlMgrChannelOWrite(
    PSAC_CMD_WRITE_CHANNEL  ChannelWriteCmd
    )
/*++

Routine Description:

    This routine attempts to write data to a channel

Arguments:

    ChannelWriteCmd - the write IOCTL command structure

Return Value:

    Status

--*/
{
    NTSTATUS        Status;
    PSAC_CHANNEL    Channel;

    //
    //
    //
    LOCK_CURRENT_CHANNEL();

    //
    // Get the referred channel by it's handle
    //
    Status = ChanMgrGetByHandle(ChannelWriteCmd->Handle, &Channel);

    if (NT_SUCCESS(Status)) {

        do {

            //
            // Write the data to the channel's output buffer
            //
            Status = Channel->OWrite(
                Channel, 
                &(ChannelWriteCmd->Buffer[0]),
                ChannelWriteCmd->Size
                );

            if (!NT_SUCCESS(Status)) {
                break;
            }

            //
            // We are done with the channel
            //
            Status = ChanMgrReleaseChannel(Channel);
        
        } while ( FALSE );

    }

    //
    //
    //
    UNLOCK_CURRENT_CHANNEL();

    ASSERT(NT_SUCCESS(Status));

    return Status;

}

NTSTATUS
XmlMgrChannelClose(
    PSAC_CHANNEL    Channel
    )
/*++

Routine Description:

    This routine attempts to close a channel. 
    If we successfully close the channel and this channel was 
    the current channel, we reset the current channel to the SAC channel

Arguments:

    Channel     - the channel to close

Return Value:

    STATUS_SUCCESS              - the channel was closed
    STATUS_ALREADY_DISCONNECTED - the channel was already closed
    otherwise, error status

--*/
{
    NTSTATUS        Status;

    //
    // Attempt to make the specified channel inactive
    //
    do {

        //
        // Make sure the channel is not already inactive
        //
        if (! ChannelIsActive(Channel)) {
            Status = STATUS_ALREADY_DISCONNECTED;
            break;
        }

        //
        // Change the status of the channel to Inactive
        //
        Status = ChannelClose(Channel);
        
        if (! NT_SUCCESS(Status)) {
            break;
        }

        //
        // The current channel is being closed, 
        // so reset the current channel to the SAC
        //
        if (XmlMgrIsCurrentChannel(Channel)) {

            Status = XmlMgrResetCurrentChannel();

        }
    
    } while ( FALSE );
        
    ASSERT(NT_SUCCESS(Status) || Status == STATUS_ALREADY_DISCONNECTED);
    
    return Status;
}

NTSTATUS
XmlMgrHandleEvent(
    IN IO_MGR_EVENT Event,
    IN PVOID        Data
    )
{
    NTSTATUS    Status;

    Status = STATUS_SUCCESS;

    switch(Event) {
    case IO_MGR_EVENT_CHANNEL_CREATE: {

        PWCHAR  OutputBuffer;
        PSAC_CHANNEL    Channel;

        Channel = (PSAC_CHANNEL)Data;
        
        ASSERT_STATUS(Channel, STATUS_INVALID_PARAMETER_2);
        
        OutputBuffer = ALLOCATE_POOL(SAC_VT100_COL_WIDTH*sizeof(WCHAR), GENERAL_POOL_TAG);
        ASSERT_STATUS(OutputBuffer, STATUS_NO_MEMORY);
        
        //
        // Notify the SAC that a channel was created
        // 
        XmlMgrChannelEventMessage(
            L"SAC_NEW_CHANNEL_CREATED", 
            ChannelGetName(Channel)
            );

        FREE_POOL(&OutputBuffer);

        break;
    
    }

    case IO_MGR_EVENT_CHANNEL_CLOSE:
        
        //
        //
        //
        LOCK_CURRENT_CHANNEL();

        do {

            PSAC_CHANNEL    Channel;

            //
            // Get the referred channel by it's handle
            //
            Status = ChanMgrGetByHandle(
                *(PSAC_CHANNEL_HANDLE)Data, 
                &Channel
                );

            if (! NT_SUCCESS(Status)) {
                break;
            }

            //
            // Attempt to close the channel
            //
            Status = XmlMgrChannelClose(Channel);

            //
            // notify the user the status of the operation
            //
            if (NT_SUCCESS(Status)) {

                //
                // report the channel has been closed
                //
                XmlMgrChannelEventMessage(
                    L"SAC_CHANNEL_CLOSED", 
                    ChannelGetName(Channel)
                    );

            } else if (Status == STATUS_ALREADY_DISCONNECTED) {

                //
                // report the channel was already closed
                //
                XmlMgrChannelEventMessage(
                    L"SAC_CHANNEL_ALREADY_CLOSED", 
                    ChannelGetName(Channel)
                    );

            } else {

                //
                // report that we failed to close the channel 
                //
                XmlMgrChannelEventMessage(
                    L"SAC_CHANNEL_FAILED_CLOSE", 
                    ChannelGetName(Channel)
                    );

            }

            //
            // We are done with the channel
            //
            ChanMgrReleaseChannel(Channel);

        } while(FALSE);
        
        //
        //
        //
        UNLOCK_CURRENT_CHANNEL();
        
        break;

    case IO_MGR_EVENT_CHANNEL_WRITE:
        
        Status = XmlMgrChannelOWrite((PSAC_CMD_WRITE_CHANNEL)Data);
        
        break;

    case IO_MGR_EVENT_REGISTER_SAC_CMD_EVENT:
        
        //
        //
        //
        LOCK_CURRENT_CHANNEL();

        Status = XmlMgrEventMessage(L"SAC_CMD_SERVICE_REGISTERED") ?
            STATUS_SUCCESS : 
            STATUS_UNSUCCESSFUL;
        
        //
        //
        //
        UNLOCK_CURRENT_CHANNEL();
        
        break;

    case IO_MGR_EVENT_UNREGISTER_SAC_CMD_EVENT:
        
        //
        //
        //
        LOCK_CURRENT_CHANNEL();
        
        Status = XmlMgrEventMessage(L"SAC_CMD_SERVICE_UNREGISTERED") ?
            STATUS_SUCCESS : 
            STATUS_UNSUCCESSFUL;
        
        //
        //
        //
        UNLOCK_CURRENT_CHANNEL();
        
        break;

    case IO_MGR_EVENT_SHUTDOWN:

        Status = XmlMgrEventMessage(L"SAC_SHUTDOWN") ?
            STATUS_SUCCESS : 
            STATUS_UNSUCCESSFUL;
        
        break;

    default:

        Status = STATUS_INVALID_PARAMETER_1;

        break;
    }

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\uterm\common\sources.inc ===
# We do this so that everything builds with the same
# options, and we don't get mismatches

C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
USE_CRTDLL=1
USE_NATIVE_EH=ASYNC
LINKER_STACKCOMMITSIZE=32768
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\uterm\common\inc\lhc.h ===
#pragma once

typedef PVOID LHCHANDLE;

BOOL lhcInitialize();
void lhcFinalize();
LHCHANDLE lhcOpen(PCWSTR pcszPortSpec);
BOOL lhcRead(
    LHCHANDLE hObject,
    PVOID pBuffer,
    DWORD dwBufferSize,
    PDWORD pdwBytesRead);
BOOL lhcWrite(
    LHCHANDLE hObject,
    PVOID pBuffer,
    DWORD dwBufferSize);
BOOL lhcClose(
    LHCHANDLE hObject);
void lhcUsage();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\uterm\common\lhc\library.c ===
#include "std.h"



PLIBRARY_DESCRIPTOR lhclLoadLibrary(PCWSTR pcszPathName)
{
    PLIBRARY_DESCRIPTOR pResult = malloc(
        sizeof(LIBRARY_DESCRIPTOR));

    if (NULL==pResult)
    {
        goto NoStructure;
    }

    pResult->m_hModule = LoadLibraryW(
        pcszPathName);

    if (NULL==pResult->m_hModule)
    {
        goto NoLibrary;
    }

    pResult->m_fpOpen = (PLHC_OPENPROC)GetProcAddress(
        pResult->m_hModule,
        "lhcOpen");

    if (NULL==pResult->m_fpOpen)
    {
        goto Error;
    }

    pResult->m_fpClose = (PLHC_CLOSEPROC)GetProcAddress(
        pResult->m_hModule,
        "lhcClose");

    if (NULL==pResult->m_fpClose)
    {
        goto Error;
    }

    pResult->m_fpRead = (PLHC_READPROC)GetProcAddress(
        pResult->m_hModule,
        "lhcRead");

    if (NULL==pResult->m_fpRead)
    {
        goto Error;
    }

    pResult->m_fpWrite = (PLHC_WRITEPROC)GetProcAddress(
        pResult->m_hModule,
        "lhcWrite");

    if (NULL==pResult->m_fpWrite)
    {
        goto Error;
    }

    pResult->m_fpGetLibraryName = (PLHC_GETLIBRARYNAMEPROC)GetProcAddress(
        pResult->m_hModule,
        "lhcGetLibraryName");

    if (NULL==pResult->m_fpGetLibraryName)
    {
        goto Error;
    }

    pResult->m_fpUsage = (PLHC_GETLIBRARYNAMEPROC)GetProcAddress(
        pResult->m_hModule,
        "lhcUsage");

    if (NULL==pResult->m_fpUsage)
    {
        goto Error;
    }

    return pResult;

Error:
    FreeLibrary(
        pResult->m_hModule);
NoLibrary:
    free(
        pResult);
NoStructure:
    return FALSE;
}



void lhclFreeLibrary(PLIBRARY_DESCRIPTOR pLibrary)
{
    if (pLibrary!=NULL)
    {
        if (pLibrary->m_hModule!=NULL)
        {
            FreeLibrary(
                pLibrary->m_hModule);
        }
        free(
            pLibrary);
    }
}


PLHCOBJECT_DESCRIPTOR lhclOpen(
    PLIBRARY_DESCRIPTOR pLibrary,
    PCWSTR pcszPortSpec)
{
    return pLibrary->m_fpOpen(
        pcszPortSpec);
}


BOOL lhclRead(
    PLIBRARY_DESCRIPTOR pLibrary,
    PLHCOBJECT_DESCRIPTOR pObject,
    PVOID pBuffer,
    DWORD dwBufferSize,
    PDWORD pdwBytesRead)
{
    return pLibrary->m_fpRead(
        pObject,
        pBuffer,
        dwBufferSize,
        pdwBytesRead);
}


BOOL lhclWrite(
    PLIBRARY_DESCRIPTOR pLibrary,
    PLHCOBJECT_DESCRIPTOR pObject,
    PVOID pBuffer,
    DWORD dwBufferSize)
{
    return pLibrary->m_fpWrite(
        pObject,
        pBuffer,
        dwBufferSize);
}


BOOL lhclClose(
    PLIBRARY_DESCRIPTOR pLibrary,
    PLHCOBJECT_DESCRIPTOR pObject)
{
    return pLibrary->m_fpClose(
        pObject);
}


DWORD lhclGetLibraryName(
    PLIBRARY_DESCRIPTOR pLibrary,
    PWSTR pszBuffer,
    DWORD dwBufferSize)
{
    return pLibrary->m_fpGetLibraryName(
        pszBuffer,
        dwBufferSize);
}


void lhclUsage(
    PLIBRARY_DESCRIPTOR pLibrary)
{
    pLibrary->m_fpUsage();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\uterm\common\lhc\std.h ===
/*****************************************************************************
*
*  Copyright (c) 1998  Microsoft Corporation
*
*  Module Name:
*
*      all.hxx
*
*  Abstract:
*
*      This is the pre-compiled header file containing all of the common
*      SDK and DDK headers.
*
*  Author:
*
*      Steven West [swest]                   1-January-1999
*
*  Revision History:
*
*****************************************************************************/

#pragma once

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <shlwapi.h>

#include <lhc.h>

#include "library.h"
#include "suite.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\driver\xmlmgr.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    conmgr.h

Abstract:

    Routines for managing channels.

Author:

    Brian Guarraci (briangu) March, 2001.

Revision History:

--*/

#ifndef XML_MGR_H
#define XML_MGR_H

NTSTATUS
XmlMgrInitialize(
    VOID
    );

NTSTATUS
XmlMgrShutdown(
    VOID
    );


NTSTATUS
XmlMgrSetCurrentChannel(
    IN ULONG        ChannelIndex,
    IN PSAC_CHANNEL CurrentChannel
    );

NTSTATUS
XmlMgrAdvanceCurrentChannel(
    VOID
    );

NTSTATUS
XmlMgrDisplayCurrentChannel(
    VOID
    );

BOOLEAN
XmlMgrIsCurrentChannel(
    IN PSAC_CHANNEL Channel
    );

#if 0
BOOLEAN
SacPutSimpleMessage(
    ULONG MessageId
    );
#endif

BOOLEAN
XmlMgrChannelEventMessage(
    PCWSTR  String,
    PCWSTR  ChannelName
    );

BOOLEAN
XmlMgrEventMessage(
    PCWSTR  String
    );

BOOLEAN
XmlMgrSacPutErrorMessage(
    PCWSTR      ActionName,
    PCWSTR      MessageId
    );

BOOLEAN
XmlMgrSacPutErrorMessageWithStatus(
    PCWSTR      ActionName,
    PCWSTR      MessageId,
    NTSTATUS    Status
    );

VOID
XmlMgrSacPutString(
    PCWSTR  String
    );

VOID
XmlMgrTimerDpcRoutine(
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
XmlMgrWorkerProcessEvents(
    IN PSAC_DEVICE_CONTEXT DeviceContext
    );

NTSTATUS
XmlMgrHandleEvent(
    IN IO_MGR_EVENT Event,
    PVOID           Data
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\uterm\common\lhc\library.h ===
#pragma once

typedef PVOID PLHCOBJECT_DESCRIPTOR;

typedef PLHCOBJECT_DESCRIPTOR (APIENTRY *PLHC_OPENPROC)(PCWSTR);
typedef BOOL  (APIENTRY *PLHC_READPROC)(PLHCOBJECT_DESCRIPTOR,PVOID,DWORD,PDWORD);
typedef BOOL  (APIENTRY *PLHC_WRITEPROC)(PLHCOBJECT_DESCRIPTOR,PVOID,DWORD);
typedef BOOL  (APIENTRY *PLHC_CLOSEPROC)(PLHCOBJECT_DESCRIPTOR);
typedef DWORD (APIENTRY *PLHC_GETLIBRARYNAMEPROC)(PWSTR, DWORD);
typedef void  (APIENTRY *PLHC_USAGEPROC)();

typedef struct __LIBRARY_DESCRIPTOR
{
    HMODULE       m_hModule;                    // Handle to the loaded DLL
    // Now come the pointers to functions in the DLL
    PLHC_OPENPROC m_fpOpen;                     // lchOpen function
    PLHC_READPROC m_fpRead;                     // lhcRead function
    PLHC_WRITEPROC m_fpWrite;                   // lhcWrite function
    PLHC_CLOSEPROC m_fpClose;                   // lhcClose function
    PLHC_GETLIBRARYNAMEPROC m_fpGetLibraryName; // lhcGetLibraryName function
    PLHC_USAGEPROC m_fpUsage;
} LIBRARY_DESCRIPTOR, *PLIBRARY_DESCRIPTOR;

PLIBRARY_DESCRIPTOR lhclLoadLibrary(
    PCWSTR pcszPathName);

void lhclFreeLibrary(
    PLIBRARY_DESCRIPTOR pLibrary);

PLHCOBJECT_DESCRIPTOR lhclOpen(
    PLIBRARY_DESCRIPTOR pLibrary,
    PCWSTR pcszPortSpec);

BOOL lhclRead(
    PLIBRARY_DESCRIPTOR pLibrary,
    PLHCOBJECT_DESCRIPTOR pObject,
    PVOID pBuffer,
    DWORD dwBufferSize,
    PDWORD pdwBytesRead);

BOOL lhclWrite(
    PLIBRARY_DESCRIPTOR pLibrary,
    PLHCOBJECT_DESCRIPTOR pObject,
    PVOID pBuffer,
    DWORD dwBufferSize);

BOOL lhclClose(
    PLIBRARY_DESCRIPTOR pLibrary,
    PLHCOBJECT_DESCRIPTOR pObject);

DWORD lhclGetLibraryName(
    PLIBRARY_DESCRIPTOR pLibrary,
    PWSTR pszBuffer,
    DWORD dwBufferSize);

void lhclUsage();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\uterm\common\lhc\suite.h ===
#pragma once

#define LHC_MAX_OPEN_OBJECTS 64

typedef struct __LIBRARY_NODE
{
    GUID                   m_Secret;
    PLIBRARY_DESCRIPTOR    m_pLibrary;
    struct __LIBRARY_NODE* m_pNext;
} LIBRARY_NODE, *PLIBRARY_NODE;


typedef struct __LHCSTRUCT
{
    GUID                    m_Secret;
    PLHCOBJECT_DESCRIPTOR   m_pObject;
    PLIBRARY_DESCRIPTOR     m_pLibrary;
    struct __LHCSTRUCT*     m_pNext;
    struct __LHCSTRUCT**    m_ppThis;
} LHCSTRUCT, *PLHCSTRUCT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\uterm\common\lhc\suite.c ===
#include "std.h"



// {6249D949-5263-4d6a-883C-78EFAF85D5E3}
static const GUID g_lhcHandleGUID =
{
    // This guid will be used to identify LCHHANDLE structures to
    // help prevent accessing invalid items
    0x6249d949, 0x5263, 0x4d6a,
    {
        0x88, 0x3c, 0x78, 0xef, 0xaf, 0x85, 0xd5, 0xe3
    }
};

// {40A71300-B2C7-4d4f-808F-52643110B329}
static const GUID g_lhcLibraryGUID =
{
    // This guid will be used to identify LIBRARY_NODE structures to
    // help prevent accessing invalid items
    0x40a71300, 0xb2c7, 0x4d4f,
    {
        0x80, 0x8f, 0x52, 0x64, 0x31, 0x10, 0xb3, 0x29
    }
};

PLIBRARY_NODE     g_pLibraryList = NULL;
PLHCSTRUCT        g_pObjectList = NULL;
CRITICAL_SECTION  g_csTableControl;


BOOL lhcpIsValidHandle(PLHCSTRUCT pObject);
PLIBRARY_NODE lhcpNewLibraryNode();
void lhcpFreeLibraryNode(PLIBRARY_NODE pNode);
PLHCSTRUCT lhcpNewObjectHandle();
void lhcpFreeObjectHandle(PLHCSTRUCT pNode);
BOOL lhcpIsValidHandle(PLHCSTRUCT pObject);
PWSTR lhcpGetExeDirectory();
PLHCSTRUCT lhcpCreateHandle(
    PLIBRARY_DESCRIPTOR   pLibrary,
    PLHCOBJECT_DESCRIPTOR pObject);
void lhcpDestroyHandle(PLHCSTRUCT pNode);


BOOL lhcpIsValidHandle(PLHCSTRUCT pObject)
{
    BOOL bResult;

    __try
    {
        bResult = IsEqualGUID(
            &g_lhcHandleGUID,
            &pObject->m_Secret);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        bResult = FALSE;
        goto Done;
    }

Done:
    return bResult;
}


PLIBRARY_NODE lhcpNewLibraryNode()
{
    //
    // Create the new node, zero out the memory and copy in the secret
    //
    PLIBRARY_NODE pNode = malloc(
        sizeof(LIBRARY_NODE));

    if (pNode!=NULL)
    {
        ZeroMemory(
            pNode,
            sizeof(LIBRARY_NODE));
        CopyMemory(
            &pNode->m_Secret,
            &g_lhcLibraryGUID,
            sizeof(GUID));
    }

    return pNode;
}


void lhcpFreeLibraryNode(PLIBRARY_NODE pNode)
{
    ZeroMemory(
        pNode,
        sizeof(LIBRARY_NODE));
    free(
        pNode);
}


PLHCSTRUCT lhcpNewObjectHandle()
{
    //
    // Create the new node, zero out the memory and copy in the secret
    //

    PLHCSTRUCT pNode = malloc(
        sizeof(LHCSTRUCT));

    if (pNode!=NULL)
    {
        ZeroMemory(
            pNode,
            sizeof(LHCSTRUCT));
        CopyMemory(
            &pNode->m_Secret,
            &g_lhcHandleGUID,
            sizeof(GUID));
    }

    return pNode;
}


void lhcpFreeObjectHandle(PLHCSTRUCT pNode)
{
    ZeroMemory(
        pNode,
        sizeof(LHCSTRUCT));
    free(
        pNode);
}


PWSTR lhcpGetExeDirectory()
{
    DWORD dwSize = 64;
    PWSTR pszBuffer = NULL;
    PWSTR pszReturn;
    DWORD dwResult;
    BOOL bResult;
    PWSTR pszLastBackslash;

    do
    {
        pszBuffer = malloc(
            dwSize * sizeof(WCHAR));

        if (NULL==pszBuffer)
        {
            SetLastError(
                ERROR_NOT_ENOUGH_MEMORY);
            goto Error;
        }

        dwResult = GetModuleFileNameW(
            NULL,
            pszBuffer,
            dwSize);

        if (0==dwResult)
        {
            goto Error;
        }

        if (dwSize==dwResult)  // INSUFFICIENT_BUFFER
        {
            dwSize *= 2;            // Double the buffer length
            free(
                pszBuffer);
            pszBuffer = NULL;
            dwResult = 0;
        }
    } while (0==dwResult && dwSize<=65536);

    if (dwSize>65536)
    {
        SetLastError(
            ERROR_INSUFFICIENT_BUFFER);
        goto Error;
    }

    pszLastBackslash = wcsrchr(
        pszBuffer,
        L'\\');

    if (NULL==pszLastBackslash)
    {
        SetLastError(
            ERROR_GEN_FAILURE);
        goto Error;
    }

    pszLastBackslash++;
    *pszLastBackslash = L'\0';

    pszReturn = malloc(
        (wcslen(pszBuffer)+MAX_PATH+1)*sizeof(WCHAR));

    if (NULL==pszReturn)
    {
        SetLastError(
            ERROR_NOT_ENOUGH_MEMORY);
        goto Error;
    }

    wcscpy(
        pszReturn,
        pszBuffer);

    free(
        pszBuffer);

    return pszReturn;

Error:
    if (pszBuffer!=NULL)
    {
        free(
            pszBuffer);
    }
    return NULL;
}


PLHCSTRUCT lhcpCreateHandle(
    PLIBRARY_DESCRIPTOR   pLibrary,
    PLHCOBJECT_DESCRIPTOR pObject)
{
    PLHCSTRUCT pNode = lhcpNewObjectHandle();

    if (pNode!=NULL)
    {
        EnterCriticalSection(
            &g_csTableControl);

        pNode->m_pObject = pObject;
        pNode->m_pLibrary = pLibrary;
        pNode->m_pNext = g_pObjectList;
        pNode->m_ppThis = &g_pObjectList;

        if (pNode->m_pNext!=NULL)
        {
            pNode->m_pNext->m_ppThis = &pNode->m_pNext;
        }

        g_pObjectList = pNode;

        LeaveCriticalSection(
            &g_csTableControl);
    }
    else
    {
        SetLastError(
            ERROR_NOT_ENOUGH_MEMORY);
    }

    return pNode;
}


void lhcpDestroyHandle(PLHCSTRUCT pNode)
{
    EnterCriticalSection(
        &g_csTableControl);

    // Remove this node from the list of handles.

    *(pNode->m_ppThis) = pNode->m_pNext;
    if (pNode->m_pNext!=NULL)
    {
        pNode->m_pNext->m_ppThis = pNode->m_ppThis;
    }

    lhcpFreeObjectHandle(
        pNode);            // Invalidates the structure and frees the memory

    LeaveCriticalSection(
        &g_csTableControl);

}


BOOL lhcInitialize()
{
    PWSTR pszPath = NULL;
    PWSTR pszFileName;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindData;
    BOOL bResult;
    PLIBRARY_DESCRIPTOR pLibrary = NULL;
    PLIBRARY_NODE pNode = NULL;
    WCHAR pszLibraryName[64];

    InitializeCriticalSection(
        &g_csTableControl);

    pszPath = lhcpGetExeDirectory();

    if (NULL==pszPath)
    {
        goto Error;
    }

    pszFileName = pszPath + wcslen(pszPath);

    wcscat(
        pszFileName,
        L"*.lhc");

    hFind = FindFirstFileW(
        pszPath,
        &FindData);

    bResult = (hFind!=INVALID_HANDLE_VALUE);

    if (!bResult)
    {
        goto Error;
    }

    while (bResult)
    {
        wcscpy(
            pszFileName,
            FindData.cFileName);

        pLibrary = lhclLoadLibrary(
            pszPath);

        if (pLibrary==NULL)
        {
            wprintf(
                L"Unable to load %s (%u).\n",
                pszFileName,
                GetLastError());
        }
        else
        {
            lhclGetLibraryName(
                pLibrary,
                pszLibraryName,
                64);

            wprintf(
                L"Loaded %s library.\n",
                pszLibraryName);

            pNode = lhcpNewLibraryNode();

            if (NULL==pNode)
            {
                SetLastError(
                    ERROR_NOT_ENOUGH_MEMORY);
                goto Error;
                // Out of memory is fatal
            }

            pNode->m_pLibrary = pLibrary;
            pNode->m_pNext = g_pLibraryList;
            g_pLibraryList = pNode;
            pNode = NULL;
            pLibrary = NULL;
        }

        bResult = FindNextFileW(
            hFind,
            &FindData);
    }

    FindClose(hFind);

    free(pszPath);

    return g_pLibraryList!=NULL;

Error:
    if (pLibrary!=NULL)
    {
        lhclFreeLibrary(pLibrary);
    }
    if (pszPath!=NULL)
    {
        free(pszPath);
    }
    if (pNode!=NULL)
    {
        free(pszPath);
    }
    if (hFind!=INVALID_HANDLE_VALUE)
    {
        FindClose(hFind);
    }
    // We need to unload the libraries that successfully loaded.
    lhcFinalize();

    return FALSE;
}



void lhcFinalize()
{
    PLIBRARY_NODE pNode;
    WCHAR pszLibraryName[64];

    while (g_pObjectList!=NULL)
    {
        lhcClose(
            g_pObjectList);
    }

    while (g_pLibraryList!=NULL)
    {
        pNode = g_pLibraryList;
        g_pLibraryList = g_pLibraryList->m_pNext;

        lhclGetLibraryName(
            pNode->m_pLibrary,
            pszLibraryName,
            64);

        lhclFreeLibrary(
            pNode->m_pLibrary);

        wprintf(
            L"Unloaded %s library.\n",
            pszLibraryName);

        lhcpFreeLibraryNode(
            pNode);
    }
}


LHCHANDLE lhcOpen(PCWSTR pcszPortSpec)
{
    PLIBRARY_NODE pLibraryNode = g_pLibraryList;
    PLHCOBJECT_DESCRIPTOR pObject = NULL;
    DWORD dwRetError = ERROR_INVALID_PARAMETER;
    PLHCSTRUCT hObject;
    DWORD dwError;

    while (pLibraryNode!=NULL && pObject==NULL)
    {
        // Try libraries one at a time until one opens successfully
        pObject = lhclOpen(
            pLibraryNode->m_pLibrary,
            pcszPortSpec);

        if (!pObject)
        {
            dwError = GetLastError();
            if (dwError!=ERROR_INVALID_PARAMETER)
            {
                dwRetError = dwError;
            }
            pLibraryNode = pLibraryNode->m_pNext;
        }
    }

    if (!pObject)
    {
        SetLastError(dwRetError);
        goto Error;
    }

    hObject = lhcpCreateHandle(
        pLibraryNode->m_pLibrary,
        pObject);

    if (hObject==NULL)
    {
        SetLastError(
            ERROR_NOT_ENOUGH_MEMORY);
        goto Error;
    }

    return hObject;

Error:
    if (pObject!=NULL && pLibraryNode!=NULL)
    {
        lhclClose(
            pLibraryNode->m_pLibrary,
            pObject);
    }

    return NULL;
}


BOOL lhcRead(
    LHCHANDLE hObject,
    PVOID pBuffer,
    DWORD dwBufferSize,
    PDWORD pdwBytesRead)
{
    PLIBRARY_DESCRIPTOR   pLibrary;
    PLHCOBJECT_DESCRIPTOR pObject;

    if (!lhcpIsValidHandle(hObject))
    {
        goto Error;
    }

    EnterCriticalSection(
        &g_csTableControl);

    // Ensure consistent information
    pLibrary = ((PLHCSTRUCT)hObject)->m_pLibrary;
    pObject = ((PLHCSTRUCT)hObject)->m_pObject;

    LeaveCriticalSection(
        &g_csTableControl);

    return lhclRead(
        pLibrary,
        pObject,
        pBuffer,
        dwBufferSize,
        pdwBytesRead);

Error:
    return FALSE;
}


BOOL lhcWrite(
    LHCHANDLE hObject,
    PVOID pBuffer,
    DWORD dwBufferSize)
{
    PLIBRARY_DESCRIPTOR   pLibrary;
    PLHCOBJECT_DESCRIPTOR pObject;

    if (!lhcpIsValidHandle(hObject))
    {
        goto Error;
    }

    // Ensure consistent information by using the critical section
    EnterCriticalSection(
        &g_csTableControl);

    // Ensure consistent information
    pLibrary = ((PLHCSTRUCT)hObject)->m_pLibrary;
    pObject = ((PLHCSTRUCT)hObject)->m_pObject;

    LeaveCriticalSection(
        &g_csTableControl);

    return lhclWrite(
        pLibrary,
        pObject,
        pBuffer,
        dwBufferSize);

Error:
    return FALSE;
}


BOOL lhcClose(
    LHCHANDLE hObject)
{
    PLIBRARY_DESCRIPTOR   pLibrary;
    PLHCOBJECT_DESCRIPTOR pObject;

    if (!lhcpIsValidHandle(hObject))
    {
        goto Error;
    }

    // Ensure consistent information by using the critical section

    EnterCriticalSection(
        &g_csTableControl);

    // Ensure consistent information
    pLibrary = ((PLHCSTRUCT)hObject)->m_pLibrary;
    pObject = ((PLHCSTRUCT)hObject)->m_pObject;

    lhcpDestroyHandle(
        hObject);

    LeaveCriticalSection(
        &g_csTableControl);

    return lhclClose(
        pLibrary,
        pObject);

Error:
    return FALSE;

}


void lhcUsage()
{
    PLIBRARY_NODE pLibraryNode = g_pLibraryList;

    while (pLibraryNode!=NULL)
    {
        lhclUsage(
            pLibraryNode->m_pLibrary);
        wprintf(L"\n");

        pLibraryNode = pLibraryNode->m_pNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\uterm\common\tcpip\std.h ===
/*****************************************************************************
*
*  Copyright (c) 1998  Microsoft Corporation
*
*  Module Name:
*
*      all.hxx
*
*  Abstract:
*
*      This is the pre-compiled header file containing all of the common
*      SDK and DDK headers.
*
*  Author:
*
*      Steven West [swest]                   1-January-1999
*
*  Revision History:
*
*****************************************************************************/

#pragma once

#include <winsock2.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\uterm\common\serial\serial.c ===
#include "std.h"

// This is the communications mask used by our serial port.  More may be
// necessary, but for right now, this seems to work.
#define EV_SERIAL EV_RXCHAR | EV_ERR | EV_BREAK
#define SERIALPORT_NAME     L"Serial Port"

// This GUID is used to identify objects opened by this library.  It is
// placed in the m_Secret member of the SERIALPORT structure. Any external
// interface accepting a SERIALPORT object as a parameter should check this
// out before using the structure.
static const GUID uuidSerialPortObjectGuid =
{ 0x86ae9c9b, 0x9444, 0x4d00, { 0x84, 0xbb, 0xc1, 0xd9, 0xc2, 0xd9, 0xfb, 0xf3 } };


// Structure defining an open serial port object.  All external users of this
// library will only have a void pointer to one of these, and the structure is
// not published anywhere.  This abstration makes it more difficult for the
// user to mess things up.
typedef struct __SERIALPORT
{
    GUID   m_Secret;                // Identifies this as a serial port
    HANDLE m_hPort;                 // Handle to the opened serial port
    HANDLE m_hAbort;                // Event signalled when port is closing
    HANDLE m_hReadMutex;            // Only one thread allowed to read a port
    HANDLE m_hWriteMutex;           // Only one thread allowed to read a port
    HANDLE m_hCloseMutex;           // Only one thread allowed to close a port
    HANDLE m_hReadComplete;         // Event to signal read completion
    HANDLE m_hWriteComplete;        // Event to signal write completion
} SERIALPORT, *PSERIALPORT;


extern PVOID APIENTRY lhcOpen(
    PCWSTR pcszPortSpec);

extern BOOL APIENTRY lhcRead(
    PVOID pObject,
    PVOID pBuffer,
    DWORD dwSize,
    PDWORD pdwBytesRead);

extern BOOL APIENTRY lhcWrite(
    PVOID pObject,
    PVOID pBuffer,
    DWORD dwSize);

extern BOOL APIENTRY lhcClose(
    PVOID pObject);

extern DWORD APIENTRY lhcGetLibraryName(
    PWSTR pszBuffer,
    DWORD dwSize);

BOOL lhcpAcquireWithAbort(
    HANDLE hMutex,
    HANDLE hAbort);

BOOL lhcpAcquireReadWithAbort(
    PSERIALPORT pObject);

BOOL lhcpAcquireWriteWithAbort(
    PSERIALPORT pObject);

BOOL lhcpAcquireCloseWithAbort(
    PSERIALPORT pObject);

BOOL lhcpAcquireReadAndWrite(
    PSERIALPORT pObject);

BOOL lhcpReleaseRead(
    PSERIALPORT pObject);

BOOL lhcpReleaseWrite(
    PSERIALPORT pObject);

BOOL lhcpReleaseClose(
    PSERIALPORT pObject);

BOOL lhcpIsValidObject(
    PSERIALPORT pObject);

PSERIALPORT lhcpCreateNewObject();

void lhcpDeleteObject(
    PSERIALPORT pObject);

BOOL lhcpParseParameters(
    PCWSTR pcszPortSpec,
    PWSTR* pszPort,
    PDWORD pdwBaudRate);

void lhcpParseParametersFree(
    PWSTR* pszPort,
    PDWORD pdwBaudRate);

BOOL lhcpSetCommState(
    HANDLE hPort,
    DWORD dwBaudRate);

BOOL lhcpWaitForCommEvent(
    PSERIALPORT pObject,
    PDWORD pdwEventMask);

BOOL lhcpReadCommPort(
    PSERIALPORT pObject,
    PVOID pBuffer,
    DWORD dwSize,
    PDWORD pdwBytesRead);

BOOL lhcpWriteCommPort(
    PSERIALPORT pObject,
    PVOID pBuffer,
    DWORD dwSize);






BOOL lhcpAcquireWithAbort(HANDLE hMutex, HANDLE hAbort)
{
    HANDLE hWaiters[2];
    DWORD dwWaitResult;

    hWaiters[0] = hAbort;
    hWaiters[1] = hMutex;

    // We should honour the m_hAbort event, since this is signalled when the
    // port is closed by another thread
    dwWaitResult = WaitForMultipleObjects(
        2,
        hWaiters,
        FALSE,
        INFINITE);

    if (WAIT_OBJECT_0==dwWaitResult)
    {
        goto Error;
    }
    else if ((WAIT_OBJECT_0+1)!=dwWaitResult)
    {
        // This should never, ever happen - so I will put a debug breapoint
        // in here (checked only).
        #ifdef DBG
        DebugBreak();
        #endif
        goto Error;
    }


    return TRUE;    // We have acquired the write mutex

Error:
    return FALSE;   // We have aborted
}


BOOL lhcpAcquireReadWithAbort(PSERIALPORT pObject)
{
    return lhcpAcquireWithAbort(
        pObject->m_hReadMutex,
        pObject->m_hAbort);
}


BOOL lhcpAcquireWriteWithAbort(PSERIALPORT pObject)
{
    return lhcpAcquireWithAbort(
        pObject->m_hWriteMutex,
        pObject->m_hAbort);
}


BOOL lhcpAcquireCloseWithAbort(PSERIALPORT pObject)
{
    return lhcpAcquireWithAbort(
        pObject->m_hCloseMutex,
        pObject->m_hAbort);
}


BOOL lhcpAcquireReadAndWrite(PSERIALPORT pObject)
{
    HANDLE hWaiters[2];
    DWORD dwWaitResult;

    hWaiters[0] = pObject->m_hReadMutex;
    hWaiters[1] = pObject->m_hWriteMutex;

    dwWaitResult = WaitForMultipleObjects(
        2,
        hWaiters,
        TRUE,
        1000);      // Timeout after 1 second

    if (WAIT_OBJECT_0!=dwWaitResult)
    {
        goto Error;
    }

    return TRUE;    // We have acquired the write mutex

Error:
    return FALSE;   // We have aborted
}


BOOL lhcpReleaseRead(PSERIALPORT pObject)
{
    return ReleaseMutex(
        pObject->m_hReadMutex);
}


BOOL lhcpReleaseWrite(PSERIALPORT pObject)
{
    return ReleaseMutex(
        pObject->m_hWriteMutex);
}


BOOL lhcpReleaseClose(PSERIALPORT pObject)
{
    return ReleaseMutex(
        pObject->m_hCloseMutex);
}


BOOL lhcpIsValidObject(PSERIALPORT pObject)
{
    BOOL bResult;

    __try
    {
        bResult = IsEqualGUID(
            &uuidSerialPortObjectGuid,
            &pObject->m_Secret);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        bResult = FALSE;
        goto Done;
    }

Done:
    return bResult;
}


PSERIALPORT lhcpCreateNewObject()
{
    PSERIALPORT pObject = (PSERIALPORT)malloc(
        sizeof(SERIALPORT));
    if (pObject!=NULL)
    {
        pObject->m_Secret = uuidSerialPortObjectGuid;
        pObject->m_hPort = INVALID_HANDLE_VALUE;
        pObject->m_hAbort = NULL;
        pObject->m_hReadMutex = NULL;     // Only one thread allowed to read a port
        pObject->m_hWriteMutex = NULL;    // Only one thread allowed to read a port
        pObject->m_hCloseMutex = NULL;    // Only one thread allowed to read a port
        pObject->m_hReadComplete = NULL;  // Event to signal read completion
        pObject->m_hWriteComplete = NULL; // Event to signal write completion
    }
    else
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    return pObject;
}


void lhcpDeleteObject(PSERIALPORT pObject)
{
    if (pObject==NULL)
    {
        return;
    }
    ZeroMemory(
        &(pObject->m_Secret),
        sizeof(pObject->m_Secret));
    if (pObject->m_hPort!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(
            pObject->m_hPort);
    }
    if (pObject->m_hAbort!=NULL)
    {
        CloseHandle(
            pObject->m_hAbort);
    }
    if (pObject->m_hReadMutex!=NULL)
    {
        CloseHandle(
            pObject->m_hReadMutex);
    }
    if (pObject->m_hWriteMutex!=NULL)
    {
        CloseHandle(
            pObject->m_hWriteMutex);
    }
    if (pObject->m_hCloseMutex!=NULL)
    {
        CloseHandle(
            pObject->m_hCloseMutex);
    }
    if (pObject->m_hReadComplete!=NULL)
    {
        CloseHandle(
            pObject->m_hReadComplete);
    }
    if (pObject->m_hWriteComplete!=NULL)
    {
        CloseHandle(
            pObject->m_hWriteComplete);
    }
    FillMemory(
        pObject,
        sizeof(SERIALPORT),
        0x00);

    free(
        pObject);
}


BOOL lhcpParseParameters(PCWSTR pcszPortSpec, PWSTR* pszPort, PDWORD pdwBaudRate)
{
    PWSTR pszSettings;

    *pszPort = malloc(
        (wcslen(pcszPortSpec) + 5) * sizeof(WCHAR));

    if (NULL==*pszPort)
    {
        SetLastError(
            ERROR_NOT_ENOUGH_MEMORY);
        goto Error;
    }

    wcscpy(
        *pszPort,
        L"\\\\.\\");         // Append the device prefix to the port name

    wcscat(
        *pszPort,
        pcszPortSpec);

    pszSettings = wcschr(       // Find where the settings start
        *pszPort,
        L'@');

    if (NULL==pszSettings)
    {
        SetLastError(
            ERROR_INVALID_PARAMETER);
        goto Error;
    }

    *pszSettings++ = L'\0';  // Separate the strings

    *pdwBaudRate = 0;

    while (*pszSettings!=L'\0' && *pdwBaudRate<115200)
    {
        if (L'0'<=*pszSettings && *pszSettings<=L'9')
        {
            *pdwBaudRate *= 10;
            *pdwBaudRate += *pszSettings - L'0';
            pszSettings++;
        }
        else
        {
            break;
        }
    }

    if (*pszSettings!=L'0' && *pdwBaudRate!=9600 && *pdwBaudRate!=19200 &&
        *pdwBaudRate!=38400 && *pdwBaudRate!=57600 && *pdwBaudRate!=115200)
    {
        SetLastError(
            ERROR_INVALID_PARAMETER);
        goto Error;
    }

    return TRUE;

Error:
    lhcpParseParametersFree(
        pszPort, pdwBaudRate);

    return FALSE;
}



void lhcpParseParametersFree(PWSTR* pszPort, PDWORD pdwBaudRate)
{
    if (*pszPort != NULL)
    {
        free(*pszPort);
        *pszPort = NULL;
    }

    *pdwBaudRate = 0;
}



BOOL lhcpSetCommState(HANDLE hPort, DWORD dwBaudRate)
{
    DCB MyDCB;
    COMMTIMEOUTS CommTimeouts;
    BOOL bResult;

    ZeroMemory(
        &MyDCB,
        sizeof(DCB));

    MyDCB.DCBlength         = sizeof(DCB);
    MyDCB.BaudRate          = dwBaudRate;
    MyDCB.fBinary           = 1;
    MyDCB.fParity           = 1;
    MyDCB.fOutxCtsFlow      = 0;
    MyDCB.fOutxDsrFlow      = 0;
    MyDCB.fDtrControl       = 1;
    MyDCB.fDsrSensitivity   = 0;
    MyDCB.fTXContinueOnXoff = 1;
    MyDCB.fOutX             = 1;
    MyDCB.fInX              = 1;
    MyDCB.fErrorChar        = 0;
    MyDCB.fNull             = 0;
    MyDCB.fRtsControl       = 1;
    MyDCB.fAbortOnError     = 0;
    MyDCB.XonLim            = 0x50;
    MyDCB.XoffLim           = 0xc8;
    MyDCB.ByteSize          = 0x8;
    MyDCB.Parity            = 0;
    MyDCB.StopBits          = 0;
    MyDCB.XonChar           = 17;
    MyDCB.XoffChar          = 19;
    MyDCB.ErrorChar         = 0;
    MyDCB.EofChar           = 0;
    MyDCB.EvtChar           = 0;

    bResult = SetCommState(
        hPort,
        &MyDCB);

    if (!bResult)
    {
        goto Error;
    }

    CommTimeouts.ReadIntervalTimeout = 0xffffffff;  //MAXDWORD
    CommTimeouts.ReadTotalTimeoutMultiplier = 0x0;  //MAXDWORD
    CommTimeouts.ReadTotalTimeoutConstant = 0x0;

    CommTimeouts.WriteTotalTimeoutMultiplier = 0;
    CommTimeouts.WriteTotalTimeoutConstant = 0;

    bResult = SetCommTimeouts(
        hPort,
        &CommTimeouts);

    if (!bResult)
    {
        goto Error;
    }

    bResult = SetCommMask(
        hPort,
        EV_SERIAL);

    if (!bResult)
    {
        goto Error;
    }

    return TRUE;

Error:
    return FALSE;
}



BOOL lhcpWaitForCommEvent(PSERIALPORT pObject, PDWORD pdwEventMask)
{
    OVERLAPPED Overlapped;
    BOOL bResult;
    HANDLE hWaiters[2];
    DWORD dwWaitResult;
    DWORD dwBytesTransferred;

    // I have no idea whether this is necessary, so I will do it just to be
    // on the safe side.
    ZeroMemory(
        &Overlapped,
        sizeof(OVERLAPPED));

    Overlapped.hEvent = pObject->m_hReadComplete;

    // Start waiting for a comm event
    bResult = WaitCommEvent(
        pObject->m_hPort,
        pdwEventMask,
        &Overlapped);

    if (!bResult && GetLastError()!=ERROR_IO_PENDING)
    {
        goto Error;
    }

    hWaiters[0] = pObject->m_hAbort;
    hWaiters[1] = pObject->m_hReadComplete;

    // Let's wait for the operation to complete. This will quit waiting if
    // the m_hAbort event is signalled.
    dwWaitResult = WaitForMultipleObjects(
        2,
        hWaiters,
        FALSE,
        INFINITE);

    if (WAIT_OBJECT_0==dwWaitResult)
    {
        // The m_hAbort event was signalled.  This means that Close was called
        // on this serial port object.  So let's cancel the pending IO.
        CancelIo(
            pObject->m_hPort);
        // The serial port object is being closed, so let's call it invalid.
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto Error;
    }
    else if ((WAIT_OBJECT_0+1)!=dwWaitResult)
    {
        // This should never, ever happen - so I will put a debug breapoint
        // in here (checked only).
        #ifdef DBG
        DebugBreak();
        #endif
        goto Error;
    }

    // Check the success or failure of the operation
    bResult = GetOverlappedResult(
        pObject->m_hPort,
        &Overlapped,
        &dwBytesTransferred,
        TRUE);

    if (!bResult)
    {
        goto Error;
    }

    return TRUE;

Error:
    return FALSE;
}



BOOL lhcpReadCommPort(
    PSERIALPORT pObject,
    PVOID pBuffer,
    DWORD dwSize,
    PDWORD pdwBytesRead)
{
    OVERLAPPED Overlapped;
    BOOL bResult;
    DWORD dwWaitResult;
    HANDLE hWaiters[2];

    // I have no idea whether this is necessary, so I will do it just to be
    // on the safe side.
    ZeroMemory(
        &Overlapped,
        sizeof(OVERLAPPED));

    Overlapped.hEvent = pObject->m_hReadComplete;

    // We can now read the comm port
    bResult = ReadFile(
        pObject->m_hPort,
        pBuffer,
        dwSize,
        pdwBytesRead,
        &Overlapped);

    if (!bResult && GetLastError()!=ERROR_IO_PENDING)
    {
        goto Error;
    }

    hWaiters[0] = pObject->m_hAbort;
    hWaiters[1] = pObject->m_hReadComplete;

    // Let's wait for the operation to complete. This will quit waiting if
    // the m_hAbort event is signalled.
    dwWaitResult = WaitForMultipleObjects(
        2,
        hWaiters,
        FALSE,
        INFINITE);

    if (WAIT_OBJECT_0==dwWaitResult)
    {
        // The m_hAbort event was signalled.  This means that Close was called
        // on this serial port object.  So let's cancel the pending IO.
        CancelIo(
            pObject->m_hPort);
        // The serial port object is being closed, so let's call it invalid.
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto Error;
    }
    else if ((WAIT_OBJECT_0+1)!=dwWaitResult)
    {
        // This should never, ever happen - so I will put a debug breapoint
        // in here (checked only).
        #ifdef DBG
        DebugBreak();
        #endif
        goto Error;
    }

    // Check the success or failure of the read operation
    bResult = GetOverlappedResult(
        pObject->m_hPort,
        &Overlapped,
        pdwBytesRead,
        TRUE);

    if (!bResult)
    {
        goto Error;
    }

    return TRUE;

Error:
    return FALSE;
}



BOOL lhcpWriteCommPort(
    PSERIALPORT pObject,
    PVOID pBuffer,
    DWORD dwSize)
{
    OVERLAPPED Overlapped;
    BOOL bResult;
    DWORD dwBytesWritten;
    DWORD dwWaitResult;
    HANDLE hWaiters[2];

    // I have no idea whether this is necessary, so I will do it just to be
    // on the safe side.
    ZeroMemory(
        &Overlapped,
        sizeof(OVERLAPPED));

    Overlapped.hEvent = pObject->m_hWriteComplete;

    // We can now read the comm port
    bResult = WriteFile(
        pObject->m_hPort,
        pBuffer,
        dwSize,
        &dwBytesWritten,
        &Overlapped);

    if (!bResult && GetLastError()!=ERROR_IO_PENDING)
    {
        goto Error;
    }

    hWaiters[0] = pObject->m_hAbort;
    hWaiters[1] = pObject->m_hWriteComplete;

    // Let's wait for the operation to complete. This will quit waiting if
    // the m_hAbort event is signalled.  If the read operation completed
    // immediately, then this wait will succeed immediately.
    dwWaitResult = WaitForMultipleObjects(
        2,
        hWaiters,
        FALSE,
        INFINITE);

    if (WAIT_OBJECT_0==dwWaitResult)
    {
        // The m_hAbort event was signalled.  This means that Close was called
        // on this serial port object.  So let's cancel the pending IO.
        CancelIo(
            pObject->m_hPort);
        // The serial port object is being closed, so let's call it invalid.
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto Error;
    }
    else if ((WAIT_OBJECT_0+1)!=dwWaitResult)
    {
        // This should never, ever happen - so I will put a debug breapoint
        // in here (checked only).
        #ifdef DBG
        DebugBreak();
        #endif
        goto Error;
    }

    // Check the success or failure of the write operation
    bResult = GetOverlappedResult(
        pObject->m_hPort,
        &Overlapped,
        &dwBytesWritten,
        TRUE);

    if (!bResult)
    {
        goto Error;
    }

    return TRUE;

Error:
    return FALSE;
}



extern PVOID APIENTRY lhcOpen(PCWSTR pcszPortSpec)
{
    BOOL bResult;
    PWSTR pszPort;
    DWORD dwBaudRate;
    PSERIALPORT pObject = NULL;
    DCB MyDCB;

    bResult = lhcpParseParameters(
        pcszPortSpec,
        &pszPort,
        &dwBaudRate);

    if (!bResult)
    {
        goto Error;
    }

    // Allocate space and initialize the serial port object
    pObject = lhcpCreateNewObject();

    if (NULL==pObject)
    {
        goto Error;
    }

    // Open the serial port
    pObject->m_hPort = CreateFileW(
        pszPort,
        GENERIC_ALL,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED,
        NULL);

    if (INVALID_HANDLE_VALUE==pObject->m_hPort)
    {
        goto Error;
    }

    // Set the properties of the serial port
    bResult = lhcpSetCommState(
        pObject->m_hPort,
        dwBaudRate);

    if (!bResult)
    {
        goto Error;
    }

    // This event will be set when we want to close the port
    pObject->m_hAbort = CreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL);

    if (NULL==pObject->m_hAbort)
    {
        goto Error;
    }

    // This event will be used for overlapped reading from the port
    pObject->m_hReadComplete = CreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL);

    if (NULL==pObject->m_hReadComplete)
    {
        goto Error;
    }

    // This event will be used for overlapped writing to the port
    pObject->m_hWriteComplete = CreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL);

    if (NULL==pObject->m_hWriteComplete)
    {
        goto Error;
    }

    // This mutex will ensure that only one thread can read at a time
    pObject->m_hReadMutex = CreateMutex(
        NULL,
        FALSE,
        NULL);

    if (NULL==pObject->m_hReadMutex)
    {
        goto Error;
    }

    // This mutex will ensure that only one thread can write at a time
    pObject->m_hWriteMutex = CreateMutex(
        NULL,
        FALSE,
        NULL);

    if (NULL==pObject->m_hWriteMutex)
    {
        goto Error;
    }

    // This mutex will ensure that only one thread can close the port
    pObject->m_hCloseMutex = CreateMutex(
        NULL,
        FALSE,
        NULL);

    if (NULL==pObject->m_hCloseMutex)
    {
        goto Error;
    }

    // Free up the temporary memory used to parse the parameters
    lhcpParseParametersFree(
        &pszPort, &dwBaudRate);

    // Return a pointer to the new object
    return pObject;

Error:
    lhcpParseParametersFree(
        &pszPort, &dwBaudRate);
    lhcpDeleteObject(
        pObject);

    return NULL;
}


extern BOOL APIENTRY lhcRead(
    PVOID pObject,
    PVOID pBuffer,
    DWORD dwSize,
    PDWORD pdwBytesRead)
{
    OVERLAPPED Overlapped;
    DWORD dwEventMask;
    BOOL bResult;

    // Firstly, we need to check whether the pointer that got passed in
    // points to a valid SERIALPORT object
    if (!lhcpIsValidObject(pObject))
    {
        goto NoMutex;
    }

    bResult = lhcpAcquireReadWithAbort(
        (PSERIALPORT)pObject);

    if (!bResult)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto NoMutex;
    }

    // We need to check whether there are already some characters waiting.
    // WaitCommEvent will never complete if there are characters waiting
    // and no new characters arrive at the serial port.  It's not cool, but
    // that's the way that it is.
    bResult = lhcpReadCommPort(
        (PSERIALPORT)pObject,
        pBuffer,
        dwSize,
        pdwBytesRead);

    if (*pdwBytesRead==0)
    {
        // Wait for something to happen to the serial port
        bResult = lhcpWaitForCommEvent(
            (PSERIALPORT)pObject, &dwEventMask);

        if (!bResult)
        {
            goto Error;
        }

        // We should now have a valid serial port event, so let's read the port.
        bResult = lhcpReadCommPort(
            (PSERIALPORT)pObject,
            pBuffer,
            dwSize,
            pdwBytesRead);

        if (!bResult)
        {
            goto Error;
        }
    }


    lhcpReleaseRead(
        (PSERIALPORT)pObject);
    return TRUE;

Error:
    lhcpReleaseRead(
        (PSERIALPORT)pObject);
NoMutex:
    return FALSE;
}



extern BOOL APIENTRY lhcWrite(
    PVOID pObject,
    PVOID pBuffer,
    DWORD dwSize)
{
    OVERLAPPED Overlapped;
    BOOL bResult;

    // Firstly, we need to check whether the pointer that got passed in
    // points to a valid SERIALPORT object
    if (!lhcpIsValidObject(pObject))
    {
        goto NoMutex;
    }

    // Block until it is your turn
    bResult = lhcpAcquireWriteWithAbort(
        pObject);

    if (!bResult)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto NoMutex;
    }

    // Wait for something to happen to the serial port
    bResult = lhcpWriteCommPort(
        (PSERIALPORT)pObject,
        pBuffer,
        dwSize);

    if (!bResult)
    {
        goto Error;
    }

    lhcpReleaseWrite(
        (PSERIALPORT)pObject);
    return TRUE;

Error:
    lhcpReleaseWrite(
        (PSERIALPORT)pObject);
NoMutex:
    return FALSE;
}



extern BOOL APIENTRY lhcClose(PVOID pObject)
{
    BOOL bResult;

    // Firstly, we need to check whether the pointer that got passed in
    // points to a valid SERIALPORT object
    if (!lhcpIsValidObject(pObject))
    {
        goto NoMutex;
    }

    // We need to ensure that we are the only thread closing this object
    bResult = lhcpAcquireCloseWithAbort(
        pObject);

    if (!bResult)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto NoMutex;
    }

    // Signal everyone to quit doing what they're doing.  Any new threads
    // calling lhcRead and lhcWrite will be immediately sent packing, since
    // the m_hAbort event is waited on along with the relevant mutex.
    bResult = SetEvent(
        ((PSERIALPORT)pObject)->m_hAbort);

    if (!bResult)
    {
        goto Error;
    }

    // Now acquire the read and write mutexes so that no-one else will try to
    // access this object to read or write.  Abort does not apply, since we
    // have already signalled it.  We know that we are closing, and we need
    // the read and write mutexes.
    bResult = lhcpAcquireReadAndWrite(
        (PSERIALPORT)pObject);

    if (!bResult)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto Error;
    }

    // Closes all of the open handles, erases the secret and frees up the
    // memory associated with the object.  We can close the mutex objects,
    // even though we are the owners, since we can guarantee that no-one
    // else is waiting on them.  The m_hAbort event being signalled will
    // ensure this.
    lhcpDeleteObject(
        (PSERIALPORT)pObject);

    return TRUE;

Error:
    lhcpReleaseClose(
        (PSERIALPORT)pObject);
    lhcpDeleteObject(
        (PSERIALPORT)pObject);
NoMutex:
    return FALSE;
}



extern DWORD APIENTRY lhcGetLibraryName(
    PWSTR pszBuffer,
    DWORD dwSize)
{
    DWORD dwNameSize = wcslen(SERIALPORT_NAME)+1;

    // If zero is passed in as the buffer length, we will return the
    // required buffer size in characters, as calulated above.  If the
    // incoming buffer size is not zero, and smaller than the required
    // buffer size, we return 0 (failure) with a valid error code.  Notice
    // that in the case where the incoming size is zero, we don't touch
    // the buffer pointer at all.

    if (dwSize!=0 && dwSize < dwNameSize)
    {
        SetLastError(
            ERROR_INSUFFICIENT_BUFFER);
        dwNameSize = 0;
    }
    else
    {
        wcscpy(
            pszBuffer,
            SERIALPORT_NAME);
    }

    return dwNameSize;
}


extern void APIENTRY lhcUsage()
{
    wprintf(
        L"Serial Port connection string:\n\n"
        L"    <port>@<speed>\n\n"
        L"where <port> is the serial port to use and <speed> is the serial line\n"
        L"speed to use for the connection.  The speed can be one of 9600, 19200,\n"
        L"38400, 57600 or 115200.  for example, com1@115200 would connect using\n"
        L"the serial port com1, and a baud rate of 115.2K bps.\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\uterm\common\win32\except.cxx ===
#include "std.hxx"

void __cdecl StructuredExceptionHandler(unsigned int u, EXCEPTION_POINTERS* pExp)
{
    throw CStructuredExcept(
        u, pExp);
}


int __cdecl MemoryExceptionHandler(size_t size)
{
    throw CMemoryExcept(
        (DWORD)size);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\uterm\common\serial\std.h ===
/*****************************************************************************
*
*  Copyright (c) 1998  Microsoft Corporation
*
*  Module Name:
*
*      all.hxx
*
*  Abstract:
*
*      This is the pre-compiled header file containing all of the common
*      SDK and DDK headers.
*
*  Author:
*
*      Steven West [swest]                   1-January-1999
*
*  Revision History:
*
*****************************************************************************/

#pragma once

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\uterm\common\tcpip\tcpip.c ===
#include "std.h"

// This is the communications mask used by our serial port.  More may be
// necessary, but for right now, this seems to work.
#define TCPIP_NAME     L"TCP/IP"

// This GUID is used to identify objects opened by this library.  It is
// placed in the m_Secret member of the SOCKET structure. Any external
// interface accepting a SOCKET object as a parameter should check this
// out before using the structure.
// {29566A75-BCDE-4bba-BC6A-EA652C0651D9}
static const GUID uuidTCPIPObjectGuid =
{ 0x29566a75, 0xbcde, 0x4bba, { 0xbc, 0x6a, 0xea, 0x65, 0x2c, 0x6, 0x51, 0xd9 } };


// Structure defining an open serial port object.  All external users of this
// library will only have a void pointer to one of these, and the structure is
// not published anywhere.  This abstration makes it more difficult for the
// user to mess things up.
typedef struct __TCPIP
{
    GUID   m_Secret;                // Identifies this as a tcpip socket
    SOCKET m_Socket;                // SOCKET handle
    HANDLE m_hAbort;                // Event signalled when port is closing
    HANDLE m_hReadMutex;            // Only one thread allowed to read a port
    HANDLE m_hWriteMutex;           // Only one thread allowed to read a port
    HANDLE m_hCloseMutex;           // Only one thread allowed to close a port
    HANDLE m_hReadComplete;         // Event to signal read completion
    HANDLE m_hWriteComplete;        // Event to signal write completion
} TCPIP, *PTCPIP;


extern PVOID APIENTRY lhcOpen(
    PCWSTR pcszPortSpec);

extern BOOL APIENTRY lhcRead(
    PVOID pObject,
    PVOID pBuffer,
    DWORD dwSize,
    PDWORD pdwBytesRead);

extern BOOL APIENTRY lhcWrite(
    PVOID pObject,
    PVOID pBuffer,
    DWORD dwSize);

extern BOOL APIENTRY lhcClose(
    PVOID pObject);

extern DWORD APIENTRY lhcGetLibraryName(
    PWSTR pszBuffer,
    DWORD dwSize);

BOOL lhcpAcquireWithAbort(
    HANDLE hMutex,
    HANDLE hAbort);

BOOL lhcpAcquireReadWithAbort(
    PTCPIP pObject);

BOOL lhcpAcquireWriteWithAbort(
    PTCPIP pObject);

BOOL lhcpAcquireCloseWithAbort(
    PTCPIP pObject);

BOOL lhcpAcquireReadAndWrite(
    PTCPIP pObject);

BOOL lhcpReleaseRead(
    PTCPIP pObject);

BOOL lhcpReleaseWrite(
    PTCPIP pObject);

BOOL lhcpReleaseClose(
    PTCPIP pObject);

BOOL lhcpIsValidObject(
    PTCPIP pObject);

PTCPIP lhcpCreateNewObject();

void lhcpDeleteObject(
    PTCPIP pObject);

BOOL lhcpParseParameters(
    PCWSTR        pcszPortSpec,
    PWSTR*        pszHostName,
    PWSTR*        pszInetAddress,
    SOCKADDR_IN** Address);

void lhcpParseParametersFree(
    PWSTR*        pszHostName,
    PWSTR*        pszInetAddress,
    SOCKADDR_IN** Address);

BOOL lhcpSetCommState(
    HANDLE hPort,
    DWORD dwBaudRate);

BOOL lhcpReadTCPIP(
    PTCPIP pObject,
    PVOID pBuffer,
    DWORD dwSize,
    PDWORD pdwBytesRead);

BOOL lhcpWriteTCPIP(
    PTCPIP pObject,
    PVOID pBuffer,
    DWORD dwSize);



BOOL WINAPI DllEntryPoint(
  HINSTANCE hinstDLL,  // handle to the DLL module
  DWORD fdwReason,     // reason for calling function
  LPVOID lpvReserved)  // reserved
{
    WSADATA WsaData;
    int dResult;

    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        dResult = WSAStartup(
            MAKEWORD(2,0),
            &WsaData);
        if (dResult!=ERROR_SUCCESS)
        {
            SetLastError(
                dResult);
            return FALSE;
        }
        break;
    case DLL_PROCESS_DETACH:
        dResult = WSACleanup();
        if (dResult!=ERROR_SUCCESS)
        {
            SetLastError(
                dResult);
            return FALSE;
        }
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    return TRUE;
}



BOOL lhcpAcquireWithAbort(HANDLE hMutex, HANDLE hAbort)
{
    HANDLE hWaiters[2];
    DWORD dwWaitResult;

    hWaiters[0] = hAbort;
    hWaiters[1] = hMutex;

    // We should honour the m_hAbort event, since this is signalled when the
    // port is closed by another thread
    dwWaitResult = WaitForMultipleObjects(
        2,
        hWaiters,
        FALSE,
        INFINITE);

    if (WAIT_OBJECT_0==dwWaitResult)
    {
        goto Error;
    }
    else if ((WAIT_OBJECT_0+1)!=dwWaitResult)
    {
        // This should never, ever happen - so I will put a debug breapoint
        // in here (checked only).
        #ifdef DBG
        DebugBreak();
        #endif
        goto Error;
    }


    return TRUE;    // We have acquired the write mutex

Error:
    return FALSE;   // We have aborted
}


BOOL lhcpAcquireReadWithAbort(PTCPIP pObject)
{
    return lhcpAcquireWithAbort(
        pObject->m_hReadMutex,
        pObject->m_hAbort);
}


BOOL lhcpAcquireWriteWithAbort(PTCPIP pObject)
{
    return lhcpAcquireWithAbort(
        pObject->m_hWriteMutex,
        pObject->m_hAbort);
}


BOOL lhcpAcquireCloseWithAbort(PTCPIP pObject)
{
    return lhcpAcquireWithAbort(
        pObject->m_hCloseMutex,
        pObject->m_hAbort);
}


BOOL lhcpAcquireReadAndWrite(PTCPIP pObject)
{
    HANDLE hWaiters[2];
    DWORD dwWaitResult;

    hWaiters[0] = pObject->m_hReadMutex;
    hWaiters[1] = pObject->m_hWriteMutex;

    dwWaitResult = WaitForMultipleObjects(
        2,
        hWaiters,
        TRUE,
        1000);      // Timeout after 1 second

    if (WAIT_OBJECT_0!=dwWaitResult)
    {
        goto Error;
    }

    return TRUE;    // We have acquired the write mutex

Error:
    return FALSE;   // We have aborted
}


BOOL lhcpReleaseRead(PTCPIP pObject)
{
    return ReleaseMutex(
        pObject->m_hReadMutex);
}


BOOL lhcpReleaseWrite(PTCPIP pObject)
{
    return ReleaseMutex(
        pObject->m_hWriteMutex);
}


BOOL lhcpReleaseClose(PTCPIP pObject)
{
    return ReleaseMutex(
        pObject->m_hCloseMutex);
}


BOOL lhcpIsValidObject(PTCPIP pObject)
{
    BOOL bResult;

    __try
    {
        bResult = IsEqualGUID(
            &uuidTCPIPObjectGuid,
            &pObject->m_Secret);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        bResult = FALSE;
        goto Done;
    }

Done:
    return bResult;
}


PTCPIP lhcpCreateNewObject()
{
    PTCPIP pObject = (PTCPIP)malloc(
        sizeof(TCPIP));
    if (pObject)
    {
        pObject->m_Secret = uuidTCPIPObjectGuid;
        pObject->m_Socket = INVALID_SOCKET;
        pObject->m_hAbort = NULL;
        pObject->m_hReadMutex = NULL;     // Only one thread allowed to read a port
        pObject->m_hWriteMutex = NULL;    // Only one thread allowed to read a port
        pObject->m_hCloseMutex = NULL;    // Only one thread allowed to read a port
        pObject->m_hReadComplete = NULL;  // Event to signal read completion
        pObject->m_hWriteComplete = NULL; // Event to signal write completion
    }
    else
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    return pObject;
}


void lhcpDeleteObject(PTCPIP pObject)
{
    if (pObject==NULL)
    {
        return;
    }
    ZeroMemory(
        &(pObject->m_Secret),
        sizeof(pObject->m_Secret));
    if (pObject->m_Socket!=INVALID_SOCKET)
    {
        closesocket(
            pObject->m_Socket);
    }
    if (pObject->m_hAbort!=NULL)
    {
        CloseHandle(
            pObject->m_hAbort);
    }
    if (pObject->m_hReadMutex!=NULL)
    {
        CloseHandle(
            pObject->m_hReadMutex);
    }
    if (pObject->m_hWriteMutex!=NULL)
    {
        CloseHandle(
            pObject->m_hWriteMutex);
    }
    if (pObject->m_hCloseMutex!=NULL)
    {
        CloseHandle(
            pObject->m_hCloseMutex);
    }
    if (pObject->m_hReadComplete!=NULL)
    {
        CloseHandle(
            pObject->m_hReadComplete);
    }
    if (pObject->m_hWriteComplete!=NULL)
    {
        CloseHandle(
            pObject->m_hWriteComplete);
    }
    FillMemory(
        pObject,
        sizeof(TCPIP),
        0x00);

    free(
        pObject);
}


BOOL lhcpParseParameters(
    PCWSTR        pcszPortSpec,
    PWSTR*        pszHostName,
    PWSTR*        pszInetAddress,
    SOCKADDR_IN** Address)
{
    DWORD dwPort;
    DWORD dwAddress;
    PSTR pszAddress = NULL;
    PSTR pszPort = NULL;
    struct hostent* pHost = NULL;
    int dStringLength = 0;
    PWSTR pszCount = (PWSTR)pcszPortSpec;

    *pszHostName = NULL;
    *pszInetAddress = NULL;
    *Address = NULL;


    // First off, we need to do a quick check for a valid looking target. If
    // we are definitely looking at something invalid, why make the user wait?
    while (*pszCount!='\0')
    {
        if (!(iswalpha(*pszCount) || iswdigit(*pszCount) || (*pszCount==L'_') ||
            (*pszCount==L'.') || (*pszCount==L':') || (*pszCount==L'-')))
        {
            SetLastError(
                ERROR_NOT_ENOUGH_MEMORY);
            goto Error;
        }
        pszCount++;
    }

    dStringLength = WideCharToMultiByte(
        CP_ACP,
        0,
        pcszPortSpec,
        -1,
        NULL,
        0,
        NULL,
        NULL);

    if (0==dStringLength)
    {
        goto Error;
    }

    pszAddress = (PSTR)malloc(
        dStringLength);

    if (NULL==pszAddress)
    {
        SetLastError(
            ERROR_NOT_ENOUGH_MEMORY);
        goto Error;
    }

    dStringLength = WideCharToMultiByte(
        CP_ACP,
        0,
        pcszPortSpec,
        -1,
        pszAddress,
        dStringLength,
        NULL,
        NULL);

    if (0==dStringLength)
    {
        goto Error;
    }

    // Let's see if there is a port specified

    pszPort = strchr(
        pszAddress,
        ':');

    if (NULL==pszPort)
    {
        // No port was specified, so what we have here is an attempt to
        // connect to the default telnet port (23). I will point the port
        // pointer at a null character.
        pszPort = pszAddress + strlen(pszAddress);
        dwPort = 23;
    }
    else
    {
        *pszPort++ = '\0';
        dwPort = 0;
    }

    while ((*pszPort)!='\0')
    {
        if ('0'<=(*pszPort) && (*pszPort)<='9')
        {
            dwPort *= 10;
            dwPort += ((*pszPort) - '0');
            if (dwPort>0xffff) // Check for maximum port number
            {
                dwPort=0;      // The port number is not valid
                break;
            }
            pszPort++;         // Look at the next character
        }
        else
        {
            dwPort = 0;         // The port number is not valid
            break;
        }
    }

    if (dwPort==0)
    {
        SetLastError(
            ERROR_INVALID_PARAMETER);
        goto Error;
    }

    // We have decoded the port, now we need to get the hostentry for
    // the target server.

    // Firstly check whether this is a dotted internet address.
    dwAddress = (DWORD)inet_addr(
        pszAddress);

    dwAddress = (dwAddress==0) ? INADDR_NONE : dwAddress;

    if (dwAddress==INADDR_NONE)
    {
        // This is not a dotted address, or is invalid.
        // Check for a machine name
        pHost = gethostbyname(
            pszAddress);

        if (pHost==NULL)
        {
            // This is not a valid address, so we need to return an error
            SetLastError(WSAGetLastError());
            goto Error;
        }
        else
        {
            dwAddress = *((DWORD*)(pHost->h_addr));
        }
    }
    else
    {
        pHost = NULL;
    }

    // This takes too long.  If the user has used a dotted address, then
    // that is all that he will see.
    /*
    else
    {
        // Attempt to get the host name (for prettyness)
        pHost = gethostbyaddr(
            (char*)&dwAddress,
            sizeof(IN_ADDR),
            AF_INET);
    }
    */

    *Address = malloc(
        sizeof(SOCKADDR_IN));

    if (NULL==*Address)
    {
        SetLastError(
            ERROR_NOT_ENOUGH_MEMORY);
        goto Error;
    }

    ZeroMemory(
        *Address,
        sizeof(SOCKADDR_IN));

    if (pHost==NULL)
    {
        // This address does not resolve to a name, so we must just go
        // the IP number passed to us.
        *pszHostName = NULL;
    }
    else
    {
        // We have a hostent entry to populate this with

        dStringLength = MultiByteToWideChar(
            CP_ACP,
            0,
            pHost->h_name,
            -1,
            NULL,
            0);

        if (dStringLength==0)
        {
            goto Error;
        }

        *pszHostName = malloc(
            (dStringLength + 7) * sizeof(WCHAR));

        if (NULL==*pszHostName)
        {
            SetLastError(
                ERROR_NOT_ENOUGH_MEMORY);
            goto Error;
        }

        dStringLength = MultiByteToWideChar(
            CP_ACP,
            0,
            pHost->h_name,
            -1,
            *pszHostName,
            dStringLength);

        if (dStringLength==0)
        {
            goto Error;
        }

        if (dwPort==23)
        {
            wcscat(
                *pszHostName,
                L":telnet");
        }
        else
        {
            PWSTR pszConnectionPort = *pszHostName + wcslen(*pszHostName);

            swprintf(
                pszConnectionPort,
                L":%u",
                dwPort & 0xFFFF);
        }

    }

    (**Address).sin_family = AF_INET;
    (**Address).sin_port = htons((USHORT)dwPort);
    (**Address).sin_addr.S_un.S_addr = (ULONG)dwAddress;

    *pszInetAddress = malloc(
        22 * sizeof(WCHAR));

    if (*pszInetAddress==NULL)
    {
        goto Error;
    }

    swprintf(
        *pszInetAddress,
        L"%u.%u.%u.%u:%u",
        (DWORD)((**Address).sin_addr.S_un.S_un_b.s_b1),
        (DWORD)((**Address).sin_addr.S_un.S_un_b.s_b2),
        (DWORD)((**Address).sin_addr.S_un.S_un_b.s_b3),
        (DWORD)((**Address).sin_addr.S_un.S_un_b.s_b4),
        (DWORD)ntohs((**Address).sin_port));

    free(pszAddress);

    return TRUE;

Error:
    lhcpParseParametersFree(
        pszHostName,
        pszInetAddress,
        Address);

    if (pszAddress!=NULL)
    {
        free(pszAddress);
    }

    return FALSE;
}



void lhcpParseParametersFree(
    PWSTR*        pszHostName,
    PWSTR*        pszInetAddress,
    SOCKADDR_IN** Address)
{
    if (*pszHostName!=NULL)
    {
        free(*pszHostName);
        *pszHostName = NULL;
    }
    if (*pszInetAddress!=NULL)
    {
        free(*pszInetAddress);
        *pszInetAddress = NULL;
    }
    if (*Address!=NULL)
    {
        free(*Address);
        *Address = NULL;
    }
}



BOOL lhcpReadTCPIP(
    PTCPIP pObject,
    PVOID pBuffer,
    DWORD dwSize,
    PDWORD pdwBytesRead)
{
    int dBytesRead;

    dBytesRead = recv(
        pObject->m_Socket,
        (char*)pBuffer,
        (int)dwSize,
        0);

    if (dBytesRead==SOCKET_ERROR)
    {
        SetLastError(WSAGetLastError());
        return FALSE;
    }
    else if (dBytesRead==0)   // graceful closure has occurred
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        return FALSE;
    }
    else
    {
        *pdwBytesRead = (DWORD)dBytesRead;
        return TRUE;
    }
}



BOOL lhcpWriteTCPIP(
    PTCPIP pObject,
    PVOID pBuffer,
    DWORD dwSize)
{
    int dBytesSent;

    dBytesSent = send(
        pObject->m_Socket,
        (char FAR*)pBuffer,
        (int)dwSize,
        0);

    if (dBytesSent==SOCKET_ERROR)
    {
        SetLastError(WSAGetLastError());
        wprintf(L"SEND error: %u\n", GetLastError());
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}



extern PVOID APIENTRY lhcOpen(PCWSTR pcszPortSpec)
{
    BOOL         bResult;
    int          dResult;
    PWSTR        pszHostName;
    PWSTR        pszInetAddr;
    SOCKADDR_IN* SockAddr;
    SOCKADDR_IN  saLocal;
    PTCPIP       pObject = NULL;
    int          On = 1;

    bResult = lhcpParseParameters(
        pcszPortSpec,
        &pszHostName,
        &pszInetAddr,
        &SockAddr);

    if (!bResult)
    {
        goto Error;
    }

    // Allocate space and initialize the serial port object
    pObject = lhcpCreateNewObject();

    if (NULL==pObject)
    {
        goto Error;
    }

    // Open the serial port
    pObject->m_Socket = socket(
        SockAddr->sin_family,
        SOCK_STREAM,
        0);

    if (INVALID_SOCKET==pObject->m_Socket)
    {
        goto Error;
    }

    ZeroMemory(
        &saLocal,
        sizeof(saLocal));

    saLocal.sin_family = AF_INET;
    saLocal.sin_port = 0;
    saLocal.sin_addr.S_un.S_addr = INADDR_ANY;

    dResult = bind(
        pObject->m_Socket,
        (SOCKADDR*)&saLocal,
        sizeof(SOCKADDR_IN));

    if (dResult==SOCKET_ERROR)
    {
        SetLastError(
            WSAGetLastError());
        wprintf(L"BIND error: %u\n", GetLastError());
        Sleep(1000);
        goto Error;
    }

    dResult = setsockopt(
        pObject->m_Socket,
        IPPROTO_TCP,
        TCP_NODELAY,
        (char *)&On,
        sizeof(On));

    if (dResult==SOCKET_ERROR)
    {
        SetLastError(
            WSAGetLastError());
        wprintf(L"SETSOCKOPT error: %u\n", GetLastError());
        Sleep(1000);
        goto Error;
    }

    dResult = connect(
        pObject->m_Socket,
        (SOCKADDR*)SockAddr,
        sizeof(SOCKADDR_IN));

    if (dResult==SOCKET_ERROR)
    {
        SetLastError(
            WSAGetLastError());
        goto Error;
    }

    // This event will be set when we want to close the port
    pObject->m_hAbort = CreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL);

    if (NULL==pObject->m_hAbort)
    {
        goto Error;
    }

    // This event will be used for overlapped reading from the port
    pObject->m_hReadComplete = CreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL);

    if (NULL==pObject->m_hReadComplete)
    {
        goto Error;
    }

    // This event will be used for overlapped writing to the port
    pObject->m_hWriteComplete = CreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL);

    if (NULL==pObject->m_hWriteComplete)
    {
        goto Error;
    }

    // This mutex will ensure that only one thread can read at a time
    pObject->m_hReadMutex = CreateMutex(
        NULL,
        FALSE,
        NULL);

    if (NULL==pObject->m_hReadMutex)
    {
        goto Error;
    }

    // This mutex will ensure that only one thread can write at a time
    pObject->m_hWriteMutex = CreateMutex(
        NULL,
        FALSE,
        NULL);

    if (NULL==pObject->m_hWriteMutex)
    {
        goto Error;
    }

    // This mutex will ensure that only one thread can close the port
    pObject->m_hCloseMutex = CreateMutex(
        NULL,
        FALSE,
        NULL);

    if (NULL==pObject->m_hCloseMutex)
    {
        goto Error;
    }

    // Free up the temporary memory used to parse the parameters
    lhcpParseParametersFree(
        &pszHostName,
        &pszInetAddr,
        &SockAddr);

    // Return a pointer to the new object
    return pObject;

Error:
    lhcpParseParametersFree(
        &pszHostName,
        &pszInetAddr,
        &SockAddr);
    lhcpDeleteObject(
        pObject);

    return NULL;
}


extern BOOL APIENTRY lhcRead(
    PVOID pObject,
    PVOID pBuffer,
    DWORD dwSize,
    PDWORD pdwBytesRead)
{
    OVERLAPPED Overlapped;
    DWORD dwEventMask;
    BOOL bResult;

    // Firstly, we need to check whether the pointer that got passed in
    // points to a valid TCPIP object
    if (!lhcpIsValidObject(pObject))
    {
        goto NoMutex;
    }

    bResult = lhcpAcquireReadWithAbort(
        (PTCPIP)pObject);

    if (!bResult)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto NoMutex;
    }

    // We should now have a valid serial port event, so let's read the port.
    bResult = lhcpReadTCPIP(
        (PTCPIP)pObject,
        pBuffer,
        dwSize,
        pdwBytesRead);

    if (!bResult)
    {
        goto Error;
    }

    lhcpReleaseRead(
        (PTCPIP)pObject);
    return TRUE;

Error:
    lhcpReleaseRead(
        (PTCPIP)pObject);
NoMutex:
    return FALSE;
}



extern BOOL APIENTRY lhcWrite(
    PVOID pObject,
    PVOID pBuffer,
    DWORD dwSize)
{
    OVERLAPPED Overlapped;
    BOOL bResult;

    // Firstly, we need to check whether the pointer that got passed in
    // points to a valid TCPIP object
    if (!lhcpIsValidObject(pObject))
    {
        goto NoMutex;
    }

    // Block until it is your turn
    bResult = lhcpAcquireWriteWithAbort(
        pObject);

    if (!bResult)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto NoMutex;
    }

    // Wait for something to happen to the serial port
    bResult = lhcpWriteTCPIP(
        (PTCPIP)pObject,
        pBuffer,
        dwSize);

    if (!bResult)
    {
        goto Error;
    }

    lhcpReleaseWrite(
        (PTCPIP)pObject);
    return TRUE;

Error:
    lhcpReleaseWrite(
        (PTCPIP)pObject);
NoMutex:
    return FALSE;
}



extern BOOL APIENTRY lhcClose(PVOID pObject)
{
    BOOL bResult;
    int dSockResult;

    // Firstly, we need to check whether the pointer that got passed in
    // points to a valid TCPIP object
    if (!lhcpIsValidObject(pObject))
    {
        goto NoMutex;
    }

    // We need to ensure that we are the only thread closing this object
    bResult = lhcpAcquireCloseWithAbort(
        pObject);

    if (!bResult)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto NoMutex;
    }

    // Signal everyone to quit doing what they're doing.  Any new threads
    // calling lhcRead and lhcWrite will be immediately sent packing, since
    // the m_hAbort event is waited on along with the relevant mutex.
    bResult = SetEvent(
        ((PTCPIP)pObject)->m_hAbort);

    // This abort flag will not cause blocking socket reads and writes to quit
    // immediately.  The only way to make this happen is to close the socket
    // gracefully.  So here we go...
    dSockResult = closesocket(
        ((PTCPIP)pObject)->m_Socket);

    if (dSockResult==SOCKET_ERROR)
    {
        SetLastError(WSAGetLastError());
        goto Error;
    }
    else
    {
        // This will cause all subsequent attempts to use the socket to fail
        ((PTCPIP)pObject)->m_Socket = INVALID_SOCKET;
    }

    // Now acquire the read and write mutexes so that no-one else will try to
    // access this object to read or write.  Abort does not apply, since we
    // have already signalled it.  We know that we are closing, and we need
    // the read and write mutexes.
    bResult = lhcpAcquireReadAndWrite(
        (PTCPIP)pObject);

    if (!bResult)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto Error;
    }

    // Closes all of the open handles, erases the secret and frees up the
    // memory associated with the object.  We can close the mutex objects,
    // even though we are the owners, since we can guarantee that no-one
    // else is waiting on them.  The m_hAbort event being signalled will
    // ensure this.
    lhcpDeleteObject(
        (PTCPIP)pObject);

    return TRUE;

Error:
    lhcpReleaseClose(
        (PTCPIP)pObject);
    lhcpDeleteObject(
        (PTCPIP)pObject);
NoMutex:
    return FALSE;
}



extern DWORD APIENTRY lhcGetLibraryName(
    PWSTR pszBuffer,
    DWORD dwSize)
{
    DWORD dwNameSize = wcslen(TCPIP_NAME)+1;

    // If zero is passed in as the buffer length, we will return the
    // required buffer size in characters, as calulated above.  If the
    // incoming buffer size is not zero, and smaller than the required
    // buffer size, we return 0 (failure) with a valid error code.  Notice
    // that in the case where the incoming size is zero, we don't touch
    // the buffer pointer at all.

    if (dwSize!=0 && dwSize < dwNameSize)
    {
        SetLastError(
            ERROR_INSUFFICIENT_BUFFER);
        dwNameSize = 0;
    }
    else
    {
        wcscpy(
            pszBuffer,
            TCPIP_NAME);
    }

    return dwNameSize;
}


extern void APIENTRY lhcUsage()
{
    wprintf(
        L"TCP/IP connection string:\n\n"
        L"    <host>[:<port>]\n\n"
        L"where <host> is the host name or IP address to connect to, and <port>\n"
        L"optionally specifies the TCP/IP port to use (Default=23).  For example\n"
        L"172.31.224.64:6002 would connect to a TCP/IP server with an IP address\n"
        L"of 172.31.224.64 on port 6002.\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\uterm\common\win32\program.cxx ===
#include "std.hxx"

DWORD MainProc(DWORD dwArgC, PCWSTR pcszArgV[], PCWSTR pcszEnvV[]);

extern "C" int __cdecl wmain(int argc, PCWSTR argv[], PCWSTR envv[])
{
    ENABLE_MEMORY_EXCEPTIONS;
    ENABLE_STRUCTURED_EXCEPTIONS;

    try
    {
        return (int)MainProc(argc, argv, envv);
    }
    catch (CApiExcept& e)
    {
        wprintf(L"Unhandled API failure: %s failed with GLE=%u.\n",
            e.GetDescription(),
            e.GetError());
    }
    catch (CStructuredExcept& e)
    {
        wprintf(
            L"Unhandled exception (0x%08x) encountered.\n"
            L"Program will now terminate.\n",
            e.GetExceptionCode());
    }
    catch (CMemoryExcept& e)
    {
        wprintf(
            L"Unable to allocate %u bytes of memory.\n"
            L"Program will now terminate.\n",
            e.GetSize());
    }
    catch (...)
    {
        wprintf(
            L"An unhandled typed exception of unknown type has been encountered."
            L"Program will now terminate.\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\uterm\uterm\uterm.cxx ===
#include "std.hxx"


extern "C"
{
#include <locale.h>
}

PTSTR pszConnectTo = NULL;
PTSTR pszLogFile = NULL;


BOOL DecodeParameters(int argc, PTSTR argv[])
{
    BOOL fLookForFilename = FALSE;
    for (int i=1; i<argc; i++)
    {
        if (_tcsicmp(argv[i], _T("-f"))==0)
        {
            fLookForFilename = TRUE;
            continue;
        }
        else
        {
            if (fLookForFilename)
            {
                if (pszLogFile!=NULL)
                {
                    return FALSE;
                }
                pszLogFile = argv[i];
                fLookForFilename = FALSE;
            }
            else
            {
                if (!pszConnectTo)
                {
                    pszConnectTo = argv[i];
                }
                else
                {
                    return FALSE;
                }
            }
        }
    }

    return (!fLookForFilename && pszConnectTo!=NULL);
}



extern "C"
int __cdecl _tmain(int argc, PTSTR argv[], PTSTR envv[])
{
    CUTerminal* MyTerminal;

    BOOL bResult = DecodeParameters(
        argc,
        argv);

    if (!bResult)
    {
        lhcInitialize();
        _tprintf(
            _T("\nUsage:\n\n")
            _T("    uterm <connection string> [-f <logfile>]\n\n")
            _T("where <connection string> is described below, and <logfile>\n")
            _T("will be used to store all incoming data for debugging.\n\n"));
        lhcUsage();
        _tprintf(_T("\n"));
        lhcFinalize();
        return 0;
    }
    try
    {
        MyTerminal = new CUTerminal;

        if (MyTerminal==NULL)
        {
            _tprintf(_T("Out of Memory.\n"));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        MyTerminal->SetConsoleTitle(
            argv[1]);
        MyTerminal->StartLog(
            pszLogFile);
        if (!MyTerminal->RunTerminal(pszConnectTo))
        {
            delete MyTerminal;
        }
        else
        {
            delete MyTerminal;
        }
    }
    catch(CApiExcept& e)
    {
        _tprintf(_T("Unhandled exception in %s (%u).\n"),
            e.GetDescription(),
            e.GetError());
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\common\makefile.inc ===
_LNG=$(LANGUAGE)
_INX=.

$(O)\netctmrk.inf: $(_INX)\netctmrk.inx $(_LNG)\netctmrk.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\uterm\uterm\terminal.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    terminal.cxx

Abstract:

    This module implements a class to provide terminal functionlity within
    a console window.  Note that the constructor of this class resizes the
    window, and the destructor returns the window to its original state.

Author:

    Steven West (swest) 5-26-2001

Revision History:

    5-26-2000   swest
        Initial creation

--*/

#include "std.hxx"


//
//  The following defines are used to determine the shift state for a
//  particular key input event.  This just makes the code look a lot tidier
//
#define SHIFT_KEY_PRESSED(KeyEvent) \
    (((KeyEvent).dwControlKeyState & (SHIFT_PRESSED))!=0)

#define CTRL_KEY_PRESSED(KeyEvent) \
    (((KeyEvent).dwControlKeyState & (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED))!=0)

#define ALT_KEY_PRESSED(KeyEvent) \
    (((KeyEvent).dwControlKeyState & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED))!=0)

#define SHIFT_ACTIVE(KeyEvent)              \
    (SHIFT_KEY_PRESSED(KeyEvent) &&         \
    (!CTRL_KEY_PRESSED(KeyEvent)) &&        \
    (!ALT_KEY_PRESSED(KeyEvent)))

#define CTRL_ACTIVE(KeyEvent)               \
    ((!SHIFT_KEY_PRESSED(KeyEvent)) &&      \
    CTRL_KEY_PRESSED(KeyEvent) &&           \
    (!ALT_KEY_PRESSED(KeyEvent)))

#define ALT_ACTIVE(KeyEvent)                \
    ((!SHIFT_KEY_PRESSED(KeyEvent)) &&      \
    (!CTRL_KEY_PRESSED(KeyEvent)) &&        \
    ALT_KEY_PRESSED(KeyEvent))

#define NONE_ACTIVE(KeyEvent)               \
    ((!SHIFT_KEY_PRESSED(KeyEvent)) &&      \
    (!CTRL_KEY_PRESSED(KeyEvent)) &&        \
    (!ALT_KEY_PRESSED(KeyEvent)))



BOOL CTelnetCommand::Feed(UCHAR ch)
{
/*++

Routine Description:

    This method allows the caller to feed characters into the telnet command
    decoder.  Basically, this is used to respond in the correct manner should
    the telnet server ask it's stupid questions (I wish it didn't).

Arguments:

    ch - The character received from the telnet server

Return Value:

    TRUE if the character was not part of a telnet command.  This means
    that if this method returns true, then the character needs to be
    processed further.

--*/
    if (m_wSequenceCount>=3)
    {
        m_wSequenceCount = 0;
    }

    if (ch==0xff || m_wSequenceCount!=0)
    {
        m_Sequence[m_wSequenceCount++] = ch;
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


void CAnsiSequence::Start()
/*++

Method Description:

    This method is called to initialize the ANSI sequence decoder object.

Arguments:

    None

Return Value:

    None

--*/
{
    m_fValid = FALSE;
    m_fInvalid = FALSE;
    m_fInNumber = FALSE;
    m_bFirstChar = 0;
    m_bCommand = 0;
    m_dwParamCount = 0;
    ZeroMemory(
        m_dwParams,
        sizeof(m_dwParams));
}



void CAnsiSequence::Feed(WCHAR ch)
/*++

Method Description:

    This method allows the caller to feed characters one at a time into the
    decoder, and the decoder will collect the escape sequences in such a
    way as to be usable by the terminal emulator.

Arguments:

    ch - The character received from the server device

Return Value:

    None

--*/
{
    // Is this a valid character for an escape sequence
    if (ch>0x7F)
    {
        m_fInvalid = TRUE;
        return;
    }
    // We haven't received a [ yet, and the current char is a [
    if (0==m_bFirstChar && '['==ch)
    {
        m_bFirstChar = ch;
        return;
    }
    // Is this part of a number?  If so, build up the current parameter.
    else if ('0'<=ch && ch<='9')
    {
        // Maximum number that I am going to allow for a parameter is 1000
        if (m_dwParams[m_dwParamCount] < 1000)
        {
            // Add in the current digit
            m_dwParams[m_dwParamCount] *= 10;
            m_dwParams[m_dwParamCount] += (ch-'0');
            m_fInNumber = TRUE;
        }
        else
        {
            m_fInvalid = TRUE;
        }
    }
    // Parameter separater
    else if (';'==ch)
    {
        // Allow only 32 parameter
        if (m_dwParamCount<32)
        {
            m_dwParamCount++;
            m_fInNumber = TRUE;
        }
        else
        {
            m_fInvalid = TRUE;
        }
    }
    else if (('A'<=ch && ch<='Z') || ('a'<=ch && ch<='z'))
    {
        if (m_fInNumber)
        {
            m_fInNumber = FALSE;
            m_dwParamCount++;
        }
        m_bCommand = ch;
        m_fValid = TRUE;
    }
    else
    {
        m_fInvalid = TRUE;
    }
}


void CUtf8Decoder::Start()
/*++

Method Description:

    This will initialize the UTF8 decoder object.  This should be called once
    when the terminal is initialized.  If an invalid UTF8 character is
    received, the decoder will automatically be reset, and the bogus character
    will be discarded.

Arguments:

    None

Return Value:

    None

--*/
{
    m_dwCharacter = 0;
    m_dwByteCount = 0;
    m_fValid = FALSE;
    m_fInvalid = TRUE;
}


void CUtf8Decoder::Feed(UCHAR ch)
/*++

Method Description:

    This method allows the caller to feed bytes one at a time into the UTF8
    decoder, and the decoder will compose the UNICODE character from the
    individual bytes.  The caller can determine whether there is a valid
    UNICODE character ready for the terminal by checking the IsValid flag.

Arguments:

    ch - The byte received from the server device

Return Value:

    None

--*/
{
    if ((ch & 0x80)==0)   // This is a single byte character
    {
        m_dwCharacter = (WCHAR)ch;
        m_dwByteCount = 0;
        m_fValid = TRUE;
        m_fInvalid = FALSE;
    }
    else if ((ch & 0xe0)==0xc0)    // First of two bytes
    {
        m_dwCharacter = ch & 0x1f; // Get data bits
        m_dwByteCount = 1;         // 1 bytes still to come
        m_fValid = FALSE;
        m_fInvalid = FALSE;
    }
    else if ((ch & 0xf0)==0xe0)    // First of three bytes
    {
        m_dwCharacter = ch & 0xf;  // Get data bits
        m_dwByteCount = 2;         // 2 bytes still to come
        m_fValid = FALSE;
        m_fInvalid = FALSE;
    }
    //
    //  Now we are checking for the trailing bytes.
    //
    else if (((ch & 0xc0)==0x80) && m_dwByteCount>0 && m_dwByteCount<=3)
    {
        m_dwCharacter = ((m_dwCharacter << 6) | (((WORD)ch) & 0x3f));
        m_dwByteCount--;
        if (0==m_dwByteCount)
        {
            m_dwByteCount = 0;
            m_fValid = TRUE;
            m_fInvalid = FALSE;
        }
    }
    else
    {
        m_dwCharacter = 0;
        m_dwByteCount = 0;
        m_fValid = FALSE;
        m_fInvalid = TRUE;
    }
}



CUTerminal::CUTerminal() :
    m_wAttributes(FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE),
    m_fBold(FALSE),
    m_fReverse(FALSE),
    m_fUtf8(TRUE),
    m_fAnsiKeys(FALSE),
    m_hLogFile(INVALID_HANDLE_VALUE)
/*++

Method Description:
    This is the constructor for the CUTerminal object.  This initializes the
    window size, and obtains handles to the input and output console buffers.

--*/
{
/*
    lhcInitialize();                                    // Load comms transport
    m_hConsoleOut = xGetStdHandle(STD_OUTPUT_HANDLE);   // Get console handles
    m_hConsoleIn = xGetStdHandle(STD_INPUT_HANDLE);
    SaveWindow();                       // Save window state
    SizeWindow();                       // Size window to 80x25
    ClearScreen();                      // Clear the screen
*/
}


CUTerminal::~CUTerminal()
/*++

Method Description:
    This is the destructor for the CUTerminal object.  The handles are closed
    for the output log, and the window is resized.  The transport libraries are
    also unloaded.

--*/
{
/*
    if (m_hLogFile!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hLogFile);
        m_hLogFile = INVALID_HANDLE_VALUE;
    }
    RestoreWindow();
    ClearScreen();
    lhcFinalize();
*/
}


void CUTerminal::UTF_8(BOOL utf_8)
/*++

Method Description:

    This method may be used to enable or disable UTF8 decoding withing the
    terminal.  It will also update the title bar to indicate which termcap is
    being used


Arguments:

    utf_8 - Pass in FALSE iff you want to disable the utf8 decoder.  Passing
            ib TRUE will enable the UTF8 decoder.

Return Value:

    None

--*/
{
    m_fUtf8 = utf_8;
    if (utf_8)
    {
        m_Utf8.Start();
    }
    SetConsoleTitle(NULL);
}



void CUTerminal::SaveWindow()
/*++

Method Description:

    This method will save the window size and position, so that it can be
    restored when the terminal emulator is closed.

Arguments:

    utf_8 - Pass in FALSE iff you want to disable the utf8 decoder.  Passing
            ib TRUE will enable the UTF8 decoder.

Return Value:

    None

--*/
{
    xGetConsoleScreenBufferInfo(
        m_hConsoleOut,
        &m_BufferInfo);

    DWORD Result = GetConsoleTitle(
        pszOldTitle,
        1024);

    BOOL bResult = GetConsoleMode(
        m_hConsoleOut,
        &dwOldConsoleOutMode);

    if (!bResult)
    {
        dwOldConsoleOutMode = 0;
    }

    bResult = GetConsoleMode(
        m_hConsoleIn,
        &dwOldConsoleInMode);

    if (!bResult)
    {
        dwOldConsoleInMode = 0;
    }

    if (0==Result)
    {
        *pszOldTitle = _T('\0');
    }
}


void CUTerminal::RestoreWindow()
/*++

Method Description:

    This methood will restore the console window to the state saved by
    SaveWindow().  This should be called at the termination of the terminal
    application, so as to restore the window to it's user state.

Arguments:

    None

Return Value:

    None

--*/
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;

    xGetConsoleScreenBufferInfo(                        // Get current state
        m_hConsoleOut,
        &csbi);

    csbi.srWindow.Left = m_BufferInfo.srWindow.Left;    // Set window position
    csbi.srWindow.Right = m_BufferInfo.srWindow.Right;
    csbi.dwSize.X = m_BufferInfo.dwSize.X;              // Set window width

    BOOL bResult = SetConsoleScreenBufferSize(          // Set buffer size
        m_hConsoleOut,
        csbi.dwSize);

    bResult = SetConsoleMode(       // Restore the input console mode
        m_hConsoleIn,
        dwOldConsoleInMode);
    bResult = SetConsoleMode(       // Restore the output console mode
        m_hConsoleOut,
        dwOldConsoleOutMode);

    xSetConsoleWindowInfo(          // Actually set the window size & position
        m_hConsoleOut,
        TRUE,
        &csbi.srWindow);

    if (!bResult)       // If the last one succeeded, no need to do it again
    {
        xSetConsoleScreenBufferSize(    // If it failed, do over
            m_hConsoleOut,
            csbi.dwSize);
    }

    csbi.srWindow.Top = m_BufferInfo.srWindow.Top;
    csbi.srWindow.Bottom = m_BufferInfo.srWindow.Bottom;
    csbi.dwSize.Y = m_BufferInfo.dwSize.Y;

    bResult = SetConsoleScreenBufferSize(
        m_hConsoleOut,
        csbi.dwSize);

    xSetConsoleWindowInfo(
        m_hConsoleOut,
        TRUE,
        &csbi.srWindow);

    if (!bResult)       // If the last one succeeded, no need to do it again
    {
        xSetConsoleScreenBufferSize(
            m_hConsoleOut,
            csbi.dwSize);
    }

    SetConsoleTextAttribute(
        m_hConsoleOut,
        m_BufferInfo.wAttributes);

    if (_tcslen(pszOldTitle)!=0)
    {
        SetConsoleTitle(
            pszOldTitle);
    }
}


void CUTerminal::SizeWindow()
{
/*++

Method Description:

    This methood will set the window and buffer size to 80x25.  There are no
    scroll bars available to you, but this is not meant to be a complete
    solution. :)

Arguments:

    None

Return Value:

    None

--*/
    CONSOLE_SCREEN_BUFFER_INFO csbi;

    SetConsoleMode(
        m_hConsoleOut,
        ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT);
    SetConsoleMode(
        m_hConsoleIn,
        0);

    xGetConsoleScreenBufferInfo(
        m_hConsoleOut,
        &csbi);

    csbi.srWindow.Left = 0;
    csbi.srWindow.Right = TERM_COLUMN_COUNT-1;
    csbi.dwSize.X = TERM_COLUMN_COUNT;

    // This will fail if the window is larger in to have width than the buffer
    // specified.  We may have a do-over.

    BOOL bResult = SetConsoleScreenBufferSize(
        m_hConsoleOut,
        csbi.dwSize);

    // This will always succeed, since the buffer is already at the requested
    // width, or it's width is already greater
    xSetConsoleWindowInfo(
        m_hConsoleOut,
        TRUE,
        &csbi.srWindow);

    if (!bResult)       // If the last one succeeded, no need to do it again
    {
        xSetConsoleScreenBufferSize(
            m_hConsoleOut,
            csbi.dwSize);
    }

    csbi.srWindow.Top = 0;
    csbi.srWindow.Bottom = TERM_ROW_COUNT-1;
    csbi.dwSize.Y = TERM_ROW_COUNT;

    bResult = SetConsoleScreenBufferSize(
        m_hConsoleOut,
        csbi.dwSize);

    xSetConsoleWindowInfo(
        m_hConsoleOut,
        TRUE,
        &csbi.srWindow);

    if (!bResult)       // If the last one succeeded, no need to do it again
    {                   // Success is guarranteed.
        xSetConsoleScreenBufferSize(
            m_hConsoleOut,
            csbi.dwSize);
    }

    // Set the output attributes
    xSetConsoleTextAttribute(
        m_hConsoleOut,
        m_wAttributes);
}


void CUTerminal::SetConsoleTitle(PCTSTR pcszTitle)
/*++

Method Description:

    This method sets the text in the window title.  It also includes an
    indication whether the terminal is using the VT100+ termcap, or the
    VT-UTF8 termcap.

Arguments:

    None

Return Value:

    None

--*/
{
    if (pcszTitle!=NULL)
    {
        _tcscpy(
            pszNewTitle,
            pcszTitle);
    }
    TCHAR pszTitle[1024];   // Arbitrary, and may come back to bite me
    _tcscpy(
        pszTitle,
        pszNewTitle);
    _tcscat(
        pszTitle,
        m_fUtf8 ? _T(" (VT-UTF8)") : _T(" (VT100+)"));
    ::SetConsoleTitle(
        pszTitle);

}


void CUTerminal::StartLog(PCTSTR pcszLogFile)
/*++

Method Description:

    This will create a file that will be used to write every received
    character into.  This is very useful for debugging purposes.  Note that if
    this fails, no error is reported.  The log file is just not used (that's
    all).

Arguments:

    pcszLogFile - this is the filename to be used for the file

Return Value:

    None

--*/
{
    if (pcszLogFile==NULL)                  // Rudimentary bogus parameter checking
    {
        return;
    }
    if (m_hLogFile!=INVALID_HANDLE_VALUE)   //  If the file is already open
    {
        CloseHandle(m_hLogFile);            // Close it
        m_hLogFile = INVALID_HANDLE_VALUE;
    }
    m_hLogFile = CreateFile(                // Open the new file
        pcszLogFile,
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
}



void CUTerminal::ClearScreen()
/*++

Method Description:

    This method clears the console screen.  Funny thing, that.

Arguments:

    None

Return Value:

    None

--*/
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    DWORD dwResult;

    xGetConsoleScreenBufferInfo(
        m_hConsoleOut,
        &csbi);

    csbi.dwCursorPosition.X = csbi.dwCursorPosition.Y = 0;

    SetConsoleCursorPosition(           // Set cursor position to 0,0
        m_hConsoleOut,
        csbi.dwCursorPosition);

    xFillConsoleOutputCharacter(        // Fill char buffer with spaces
        m_hConsoleOut,
        _T(' '),
        csbi.dwSize.X * csbi.dwSize.Y,
        csbi.dwCursorPosition,
        &dwResult);

    xFillConsoleOutputAttribute(        // Fill attr buffer with white on black
        m_hConsoleOut,
        csbi.wAttributes,
        csbi.dwSize.X * csbi.dwSize.Y,
        csbi.dwCursorPosition,
        &dwResult);
}


BOOL CUTerminal::RunTerminal(PCTSTR pcszPort)
/*++

Method Description:

    This method makes the whole terminal emulator go.

Arguments:

    pcszPort - This is the connection specification to be used to make a
                connection to your DCE

Return Value:

    TRUE if the communication transport is successfully opened, otherwise
    it returns false.  Note that this method only  returns when the terminal
    application is closed.

--*/
{
    m_hClosing = xCreateEvent(  // This event will be used to signal that
        NULL,                   //  uterm is in the process of closing
        TRUE,
        FALSE,
        NULL);

    lhcInitialize();            // Load comms transport

    m_hPortHandle = lhcOpen(    // Open the communication channel.
        pcszPort);

    if (0!=m_hPortHandle)
    {
        m_hConsoleOut = xGetStdHandle(STD_OUTPUT_HANDLE);   // Get console handles
        m_hConsoleIn = xGetStdHandle(STD_INPUT_HANDLE);
        SaveWindow();                       // Save window state
        SizeWindow();                       // Size window to 80x25
        ClearScreen();                      // Clear the screen

        DWORD dwTemp;
        m_hOutputThread = xCreateThread(    // Create the comms read thread
            NULL,
            0,
            StOutputThread,
            this,
            0,
            &dwTemp);

        InputThread();         // Call the keyboard handler "thread"

        lhcClose(
            m_hPortHandle);     // We are done.  Close the channel
        m_hPortHandle = NULL;   // Clear the handle

        // Wait for 5 seconds for the read thread to terminate.  If it doesn't,
        // then that is just tough.  The closing of the port should cause the
        // read to return ERROR_INVALID_HANDLE, and thus terminate the thread.

        dwTemp = WaitForSingleObject(
            m_hOutputThread,
            5000);

        if (m_hLogFile!=INVALID_HANDLE_VALUE)
        {
            CloseHandle(m_hLogFile);
            m_hLogFile = INVALID_HANDLE_VALUE;
        }
        RestoreWindow();
        ClearScreen();

        lhcFinalize();

        CloseHandle(
            m_hOutputThread);   // Close the handles that you have created
        CloseHandle(
            m_hClosing);

        return TRUE;            // Succeed
    }
    else
    {
        _tprintf(_T("Unable to open %s (GLE=%u).\n"), pcszPort, GetLastError());
        lhcFinalize();
        return FALSE;
    }
}



DWORD CUTerminal::StOutputThread(PVOID pParam)
/*++

Method Description:

    This static method just calls the non-static method OutputThread.  This
    is done because the CreateThread API cannot use a non-static method as
    a thread entry point.

Arguments:

    pParam - This will point to the instance of CUTerminal in question.

Return Value:

    Check out ThreadProc in MSDN.

--*/
{
    ((CUTerminal*)pParam)->OutputThread();
    return 0;
}



void CUTerminal::InputThread()
/*++

Method Description:

    InputThread will sit and spin until some input is received from the
    keyboard. It then processes the keyboard input, takes appropriate action
    and then spins again.  The keystroke that causes this loop to terminate
    is Ctrl-].  Same as telnet's default escape sequence.  Funny thing, that.

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL bResult = TRUE;           // Success starts as TRUE

    PCSTR pszKeySequence = NULL;    // Will point at escape sequences

    while (bResult)                 // Go until something doesn't work!
    {
        bResult = Read();           // Read the keyboard input queue

        // If we have a character, and it is a special (extended) key...
        if (bResult && m_Input.uChar.UnicodeChar==0)
        {
            pszKeySequence=NULL;
            if (NONE_ACTIVE(m_Input))
            {
                switch (m_Input.wVirtualKeyCode)
                {
                case VK_F1:                   // F1 = <ESC>1
                    pszKeySequence = "\x1b""1";
                    break;
                case VK_F2:                    // F2 = <ESC>2
                    pszKeySequence = "\x1b""2";
                    break;
                case VK_F3:                    // F3 = <ESC>3
                    pszKeySequence = "\x1b""3";
                    break;
                case VK_F4:                    // F4 = <ESC>4
                    pszKeySequence = "\x1b""4";
                    break;
                case VK_F5:                    // F5 = <ESC>5
                    pszKeySequence = "\x1b""";
                    break;
                case VK_F6:                    // F6 = <ESC>6
                    pszKeySequence = "\x1b""6";
                    break;
                case VK_F7:                    // F7 = <ESC>7
                    pszKeySequence = "\x1b""7";
                    break;
                case VK_F8:                    // F8 = <ESC>8
                    pszKeySequence = "\x1b""8";
                    break;
                case VK_F9:                    // F9 = <ESC>9
                    pszKeySequence = "\x1b""9";
                    break;
                case VK_F10:                    // F10 = <ESC>0
                    pszKeySequence = "\x1b""0";
                    break;
                case VK_F11:                    // F11 = <ESC>!
                    pszKeySequence = "\x1b""!";
                    break;
                case VK_F12:                    // F12 = <ESC>@
                    pszKeySequence = "\x1b""@";
                    break;
                case VK_HOME:                  // <ESC>h
                    pszKeySequence = "\x1b""h";
                    break;
                case VK_UP:                    // UP = <ESC>A
                    pszKeySequence = "\x1b""[A";
                    break;
                case VK_PRIOR:                    // PgUp = <ESC>?
                    pszKeySequence = "\x1b""?";
                    break;
                case VK_LEFT:                    // Left = <ESC>D
                    pszKeySequence = "\x1b""[D";
                    break;
                case VK_RIGHT:                   // Right = <ESC>C
                    pszKeySequence = "\x1b""[C";
                    break;
                case VK_END:                    // END = <ESC>k
                    pszKeySequence = "\x1b""k";
                    break;
                case VK_DOWN:                    // Down = <ESC>[B
                    pszKeySequence = "\x1b""[B";
                    break;
                case VK_NEXT:                    // PgDn = <ESC>/
                    pszKeySequence = "\x1b""/";
                    break;
                case VK_INSERT:                    // Ins = <ESC>+
                    pszKeySequence = "\x1b""+";
                    break;
                case VK_DELETE:                    // Del = <ESC>-
                    pszKeySequence = "\x1b""-";
                    break;
                default:
                    continue;
                }
            }
            // I have used Alt keys to allow the terminal emulator to output
            // proper ansi sequences for certain keystrokes.  While there is no
            // true standard for ANSI, I have tried to do the same as
            // everyone else.
            else if (ALT_ACTIVE(m_Input))
            {
                switch (m_Input.wVirtualKeyCode)
                {
                case VK_F1:
                    pszKeySequence = "\x1b""OP";    // <ESC>OP
                    break;
                case VK_F2:
                    pszKeySequence = "\x1b""OQ";    // <ESC>OQ
                    break;
                case VK_F3:
                    pszKeySequence = "\x1b""OR";    // <ESC>OR
                    break;
                case VK_F4:
                    pszKeySequence = "\x1b""OS";    // <ESC>OS
                    break;
                case VK_F5:
                    pszKeySequence = "\x1b""[15~";  // <ESC>[15~
                    break;
                case VK_F6:
                    pszKeySequence = "\x1b""[17~";  // <ESC>[17~
                    break;
                case VK_F7:
                    pszKeySequence = "\x1b""[18~";  // <ESC>[18~
                    break;
                case VK_F8:
                    pszKeySequence = "\x1b""[19~";  // <ESC>[19~
                    break;
                case VK_F9:
                    pszKeySequence = "\x1b""[20~";  // <ESC>[20~
                    break;
                case VK_F10:
                    pszKeySequence = "\x1b""[21~";  // <ESC>[21~
                    break;
                case VK_F11:
                    pszKeySequence = "\x1b""[23~";  // <ESC>[23~
                    break;
                case VK_F12:
                    pszKeySequence = "\x1b""[24~";  // <ESC>[24~
                    break;
                default:
                    continue;
                }
            }

            if (pszKeySequence!=NULL)           // Do we have a key sequence
            {
                DWORD dwSize = strlen(          // Get its length
                    pszKeySequence);

                bResult = lhcWrite(             // Write the sequence to the
                    m_hPortHandle,              //    transport
                    (PVOID)pszKeySequence,
                    dwSize);
            }

        }
        else                                    // This is not an extended key
        {
            if (ALT_ACTIVE(m_Input))            // If ALT is pressed too
            {
                if (m_Input.wVirtualKeyCode=='U')   // And U is thekey
                {
                    UTF_8(!m_fUtf8);            // Toggle UTF8 status
                }
            }
            else                                // Alt is not pressed
            {
                if (m_Input.uChar.UnicodeChar!=29) // 0x1d is quit button
                {
                    bResult = Write(&(m_Input.uChar.UnicodeChar),1);
                }
                else
                {
                    bResult = FALSE;  // User selected quit
                }
            }
        }
    }
}


BOOL CUTerminal::Write(PCWSTR ch, DWORD dwSize)
/*++

Method Description:

    This will write a number of UNICODE characters to the transport.

Arguments:

    ch - Array of unicode characters
    dwSize - Number of unicode characters

Return Value:

    TRUE if successful.  If failure, then we are going to quit anyway.

--*/
{
    // We need to UTF8 encode this bad boy

    BOOL bResult = TRUE;
    UCHAR pszOutputBuffer[1024];

    // Encode the character
    if (m_fUtf8)
    {
        UCHAR*  out = pszOutputBuffer;
        PCWSTR in = ch;
        int dOutputLength = 0;

        for (DWORD dwCount=0; dwCount<dwSize; dwCount++)
        {
            if (*in<=0x80)
            {
                *out++ = *in;
                dOutputLength++;
            }
            else if (*in<=0x800)
            {
                *out++ = ((((*in) >>  6) & 0x1f) | 0xc0);
                *out++ = ((((*in)      ) & 0x3f) | 0x80);
                dOutputLength+=2;
            }
            else
            {
                *out++ = ((((*in) >> 12) & 0x0f) | 0xe0);
                *out++ = ((((*in) >>  6) & 0x3f) | 0x80);
                *out++ = ((((*in)      ) & 0x3f) | 0x80);
                dOutputLength+=3;
            }
            in++;
        }

        bResult = lhcWrite(
            m_hPortHandle,
            pszOutputBuffer,
            dOutputLength);
    }
    else
    {
        UCHAR*  out = pszOutputBuffer;
        PCWSTR in = ch;
        int dOutputLength = 0;

        for (DWORD dwCount=0; dwCount<dwSize; dwCount++)
        {
            *out++ = UnicodeToAnsi(*in++);
            dOutputLength++;
        }

        bResult = lhcWrite(
            m_hPortHandle,
            pszOutputBuffer,
            dOutputLength);
    }

    return bResult;
}


BOOL CUTerminal::Read()
{
    HANDLE hWaiters[2];
    static WORD wLastKey = 0;
    INPUT_RECORD pEvent;
    BOOL fGotKey = FALSE;

    while (!fGotKey)
    {
        hWaiters[0] = m_hClosing;
        hWaiters[1] = m_hConsoleIn;

        // This will wait on input being ready, whilst honoring the m_hClosing
        // event
        DWORD dwWaitResult = WaitForMultipleObjects(
            2,
            hWaiters,    // Wait on the console and on closing event
            FALSE,       // Wait for only one
            INFINITE);   // Never timeout

        if (dwWaitResult==WAIT_OBJECT_0)   // We are closing now
        {
            return FALSE;
        }

        DWORD dwEventsRead;
        BOOL bResult = ReadConsoleInputW(
            m_hConsoleIn,
            &pEvent,
            1,                                 // Just read one
            &dwEventsRead);

        if (!bResult || dwEventsRead!=1)
        {
            return FALSE;
        }

        if (pEvent.EventType!=KEY_EVENT)
        {
            // This is not a key event.  Wait again.
            continue;
        }

        memcpy(
            &m_Input,
            &pEvent.Event.KeyEvent,
            sizeof(KEY_EVENT_RECORD));

        if (m_Input.bKeyDown)
        {
            if (m_Input.uChar.UnicodeChar>=0x20)
            {
                wLastKey = 0;
                fGotKey = TRUE;
            }
            else
            {
                if (wLastKey==m_Input.wVirtualKeyCode)
                {
                    // We are auto-repeating when we shouldn't be
                    continue;
                }
                else
                {
                    wLastKey = m_Input.wVirtualKeyCode;
                    fGotKey = TRUE;
                }
            }
        }
        else
        {
            wLastKey = 0;
        }
    }

    return TRUE;
}



void CUTerminal::OutputThread()
{
    BOOL bResult;

    do
    {
        UCHAR pBuffer[1024];
        DWORD dwBytesRead;

        bResult = lhcRead(
            m_hPortHandle,
            pBuffer,
            sizeof(pBuffer),
            &dwBytesRead);

        if (bResult)
        {
            if (m_hLogFile!=INVALID_HANDLE_VALUE)
            {
                DWORD dwBytesWritten;
                // If this doesn't work, close the file and don't log any more
                bResult = WriteFile(
                    m_hLogFile,
                    pBuffer,
                    dwBytesRead,
                    &dwBytesWritten,
                    NULL);

                if (!bResult)
                {
                    CloseHandle(m_hLogFile);
                    m_hLogFile = INVALID_HANDLE_VALUE;
                }
            }

            ProcessChars(
                (PCSTR)pBuffer,
                dwBytesRead);
        }
    }
    while (bResult);
    lhcClose(
        m_hPortHandle);
    m_hPortHandle = NULL;

    SetEvent(m_hClosing);
}


void CUTerminal::ProcessChars(PCSTR ch, DWORD dwCount)
{
    PUCHAR ptr = (PUCHAR)ch;
    for (DWORD dwIndex=0; dwIndex<dwCount; dwIndex++, ptr++)
    {
        DecodeChar(*ptr);
    }
}



void CUTerminal::DecodeChar(const UCHAR ch)
{
    BOOL bProcess = m_TelnetCommand.Feed(ch);

    if (m_TelnetCommand.GotCommand())
    {
        ProcessTelnetCommand();
    }

    if (!bProcess || ch==0)  // Must we process the character?
    {
        return;
    }

    if (m_fUtf8)
    {
        m_Utf8.Feed(ch);
        if (ch==0x0e)
        {
        }
        else if (ch==0x0f)
        {
        }
        else
        {
            if (m_Utf8.IsValid())
            {
                WCHAR tc = m_Utf8.Character();
                ProcessChar(tc);
            }
        }
    }
    else
    {
        if (ch==0x0e)  // SO = do UTF8
        {
        }
        else if (ch==0x0f)
        {
        }
        else
        {
            WCHAR tc;
            tc = AnsiToUnicode(ch);
            ProcessChar(tc);
        }
    }
}


void CUTerminal::ProcessChar(WCHAR ch)
{
    if (!(m_Ansi.IsValid() || m_Ansi.IsInvalid())) // Busy with escape
    {
        m_Ansi.Feed(ch);
        if (m_Ansi.IsValid())
        {
            ProcessEscape();
        }
    }
    else
    {
        if (033==ch)    // Is this an escape char (octal value = 033)
        {
            m_Ansi.Start();
        }

        // I will stop filtering out the ^C characters now...
#if 0
        else if (3==ch)   // Write pretty version of ^C to screen
        {
            DWORD dwResult;
            WriteConsoleW(
                m_hConsoleOut,
                L"^C",
                2,
                &dwResult,
                NULL);
        }
#endif
        else
        {
            DWORD dwResult;
            WriteConsoleW(
                m_hConsoleOut,
                &ch,
                1,
                &dwResult,
                NULL);
        }
    }

}


void CUTerminal::ProcessEscape()
{
    // We need to implement the following escape sequences for the
    // headless setup stuff

    // I am going to include a hardcoded breakpoint for any extra escape
    // sequences that may occur later on in the development process

    if (m_Ansi.FirstChar()==L'[')
    {
        CONSOLE_SCREEN_BUFFER_INFO csbi;
        DWORD dwResult;
        COORD TempCoord;
        DWORD dwScratch = 0xFFFFFFFF;;

        switch (m_Ansi.Command())
        {
        case 'f':  // Same as 'H'
        case 'H':
            if (m_Ansi.ParamCount()<=2)
            {
                DWORD dwRow = m_Ansi.Param(1);
                DWORD dwColumn = m_Ansi.Param(2);
                if (dwRow==0) dwRow=1;
                if (dwColumn==0) dwColumn=1;
                COORD cp = {dwColumn-1, dwRow-1};
                SetConsoleCursorPosition(
                    m_hConsoleOut,
                    cp);
            }
            break;
        case 'J':
            if (m_Ansi.ParamCount()<=1)
            {
                xGetConsoleScreenBufferInfo(
                    m_hConsoleOut,
                    &csbi);

                if (m_Ansi.Param(1)==0)
                {
                    dwScratch = csbi.dwSize.X - csbi.dwCursorPosition.X +
                        csbi.dwSize.X * (csbi.dwSize.Y -
                                         csbi.dwCursorPosition.Y - 1);
                    TempCoord = csbi.dwCursorPosition;
                }
                else if (m_Ansi.Param(1)==1)
                {
                    dwScratch = csbi.dwCursorPosition.X + 1 +
                        (csbi.dwSize.X * csbi.dwCursorPosition.Y);
                    TempCoord.X = 0;
                    TempCoord.Y = 0;
                }
                else if (m_Ansi.Param(1)==2)
                {
                    dwScratch = csbi.dwSize.X * csbi.dwSize.Y;
                    TempCoord.X = 0;
                    TempCoord.Y = 0;
                }
                xFillConsoleOutputCharacter(
                    m_hConsoleOut,
                    _T(' '),
                    dwScratch,
                    TempCoord,
                    &dwResult);
                xFillConsoleOutputAttribute(
                    m_hConsoleOut,
                    csbi.wAttributes,
                    dwScratch,
                    TempCoord,
                    &dwResult);
            }
            break;
        case 'K':
            if (m_Ansi.ParamCount()<=1)
            {
                xGetConsoleScreenBufferInfo(
                    m_hConsoleOut,
                    &csbi);

                if (m_Ansi.Param(1)==0)
                {
                    TempCoord = csbi.dwCursorPosition;
                    dwScratch = csbi.dwSize.X - csbi.dwCursorPosition.X;
                }
                else if (m_Ansi.Param(1)==1)
                {
                    TempCoord.Y = csbi.dwCursorPosition.Y;
                    TempCoord.X = 0;
                    dwScratch = csbi.dwCursorPosition.X + 1;
                }
                else if (m_Ansi.Param(1)==2)
                {
                    TempCoord.Y = csbi.dwCursorPosition.Y;
                    TempCoord.X = 0;
                    dwScratch = csbi.dwSize.X;
                }
                xFillConsoleOutputCharacter(
                    m_hConsoleOut,
                    _T(' '),
                    dwScratch,
                    TempCoord,
                    &dwResult);
                xFillConsoleOutputAttribute(
                    m_hConsoleOut,
                    csbi.wAttributes,
                    dwScratch,
                    TempCoord,
                    &dwResult);
            }
            break;
        case 'm':
            // We need to map these attributes to comething that our screens
            // can do.  Flashing, Underscore and Concealed are something that
            // I cannot be bothered with
            if (m_Ansi.ParamCount()==0)
            {
                SetBold(FALSE);
                SetReverse(FALSE);
                ResetColors();
            }
            for (WORD count=1; count<=m_Ansi.ParamCount(); count++)
            {
                switch (m_Ansi.Param(count))
                {
                case 0:
                    SetBold(FALSE);
                    SetReverse(FALSE);
                    ResetColors();
                    break;
                case 1:
                    SetBold(TRUE);
                    break;
                case 7:
                    SetReverse(TRUE);
                    break;
                case 22:
                    SetBold(FALSE);
                    break;
                case 27:
                    SetReverse(FALSE);
                    break;
                case 30:
                    SetForeground(0);
                    break;
                case 31:  // Red
                    SetForeground(FOREGROUND_RED);
                    break;
                case 32:  // Green
                    SetForeground(FOREGROUND_GREEN);
                    break;
                case 33:  // Yellow
                    SetForeground(FOREGROUND_RED | FOREGROUND_GREEN);
                    break;
                case 34:  // Blue
                    SetForeground(FOREGROUND_BLUE);
                    break;
                case 35:  // Magenta
                    SetForeground(FOREGROUND_RED | FOREGROUND_BLUE);
                    break;
                case 36:  // Cyan
                    SetForeground(FOREGROUND_GREEN | FOREGROUND_BLUE);
                    break;
                case 37:  // White
                    SetForeground(FOREGROUND_RED | FOREGROUND_GREEN
                        | FOREGROUND_BLUE);
                    break;
                case 40:
                    SetBackground(0);
                    break;
                case 41:  // Red
                    SetBackground(BACKGROUND_RED);
                    break;
                case 42:  // Green
                    SetBackground(BACKGROUND_GREEN);
                    break;
                case 43:  // Yellow
                    SetBackground(BACKGROUND_RED | BACKGROUND_GREEN);
                    break;
                case 44:  // Blue
                    SetBackground(BACKGROUND_BLUE);
                    break;
                case 45:  // Magenta
                    SetBackground(BACKGROUND_RED | BACKGROUND_BLUE);
                    break;
                case 46:  // Cyan
                    SetBackground(BACKGROUND_GREEN | BACKGROUND_BLUE);
                    break;
                case 47:  // White
                    SetBackground(BACKGROUND_RED | BACKGROUND_GREEN
                        | BACKGROUND_BLUE);
                    break;
                }
            }

            xSetConsoleTextAttribute(
                m_hConsoleOut,
                m_wAttributes);
            break;
        default:
            printf("Unknown Escape Sequence: %c\n", m_Ansi.Command());
            break;
        }
    }
}


void CUTerminal::ProcessTelnetCommand()
{
    // Check that we have a command, and that the command descriptor is
    // correct.
    if (!m_TelnetCommand.GotCommand() || m_TelnetCommand.GetByte(1)!=0xff)
    {
        // This is not a proper command.  It should be by this point, but
        // I will do this sanity check anyhow.
        return;
    }

    UCHAR pszCommand[3];
    DWORD dwCommandSize = 3;

    switch (m_TelnetCommand.GetByte(2))  // Get the command byte
    {
    case 254:
        pszCommand[0] = (UCHAR)255;
        pszCommand[1] = (UCHAR)252;
        pszCommand[2] = m_TelnetCommand.GetByte(3);
        break;
    case 253:
        pszCommand[0] = (UCHAR)255;
        pszCommand[1] = (UCHAR)251;
        pszCommand[2] = m_TelnetCommand.GetByte(3);
        break;
    case 252:
        pszCommand[0] = (UCHAR)255;
        pszCommand[1] = (UCHAR)254;
        pszCommand[2] = m_TelnetCommand.GetByte(3);
        break;
    case 251:
        pszCommand[0] = (UCHAR)255;
        pszCommand[1] = (UCHAR)253;
        pszCommand[2] = m_TelnetCommand.GetByte(3);
        break;
    default:
        dwCommandSize = 0;
    }

    if (dwCommandSize!=0)
    {
        lhcWrite(
            m_hPortHandle,
            pszCommand,
            dwCommandSize);
    }
}



void CUTerminal::SetForeground(WORD wColor)
{
    m_wAttributes = (WORD)( ( m_wAttributes & ~((UCHAR)(FOREGROUND_RED |
        FOREGROUND_GREEN | FOREGROUND_BLUE))) | wColor );
}


void CUTerminal::SetBackground(WORD wColor)
{
    m_wAttributes = (WORD)(( m_wAttributes & ~((UCHAR)(BACKGROUND_RED |
        BACKGROUND_GREEN | BACKGROUND_BLUE))) | wColor);
}


void CUTerminal::SetBold(BOOL fOn)
{
    if (fOn)
    {
        m_wAttributes |= (UCHAR) FOREGROUND_INTENSITY;
        m_fBold = TRUE;
    }
    else
    {
        m_wAttributes &= (UCHAR) ~(FOREGROUND_INTENSITY);
        m_fBold = FALSE;
    }
}


void CUTerminal::ResetColors()
{
    m_wAttributes = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
}


void CUTerminal::SetReverse(BOOL fOn)
{
    if (fOn)
    {
        if (!m_fReverse)
        {
            m_wAttributes = (WORD) (((m_wAttributes &
                (BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE)) >> 4) |
                ((m_wAttributes & (FOREGROUND_RED | FOREGROUND_GREEN |
                FOREGROUND_BLUE)) << 4) | (m_wAttributes &
                FOREGROUND_INTENSITY) | (m_wAttributes &
                BACKGROUND_INTENSITY));
            m_fReverse = TRUE;
        }
    }
    else
    {
        if (m_fReverse)
        {
            m_wAttributes = (WORD) (((m_wAttributes &
                (BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE)) >> 4) |
                ((m_wAttributes & (FOREGROUND_RED | FOREGROUND_GREEN |
                FOREGROUND_BLUE)) << 4) | (m_wAttributes &
                FOREGROUND_INTENSITY) | (m_wAttributes &
                BACKGROUND_INTENSITY));
            m_fReverse = FALSE;
        }
    }
}



WCHAR CUTerminal::AnsiToUnicode(const UCHAR ch)
{
    WCHAR pszOutput[2];

    int i = MultiByteToWideChar(
      GetConsoleOutputCP(),         // code page
      0,                            // character-type options
      (char*)&ch,                   // string to map
      1,                            // number of bytes in string
      pszOutput,                    // wide-character buffer
      2);                           // size of buffer

    if (1==i)
    {
        return (WCHAR)*pszOutput;
    }
    else
    {
        return 0;
    }
}



UCHAR CUTerminal::UnicodeToAnsi(const WCHAR ch)
{
    UCHAR pszOutput[2];

    int i = WideCharToMultiByte(
      GetConsoleCP(),               // code page
      0,                            // character-type options
      (PCWSTR)&ch,                  // string to map
      1,                            // number of bytes in string
      (PSTR)pszOutput,              // wide-character buffer
      2,                            // size of buffer
      NULL,
      NULL);

    if (i!=0)
    {
        return *pszOutput;
    }
    else
    {
        return 0x20;                // If this didn't work, space
    }
}



void CUTerminal::StatusBar()
{
    PCTSTR pcszStatus[] = {
        _T("                                     VT1")
        _T("00+                                     "),
        _T("                                      AN")
        _T("SI                                      ")
    };

    WORD wAttribute = BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE;

    COORD co;
    co.X = 0;
    co.Y = TERM_ROW_COUNT;
    DWORD dwResult;

    xWriteConsoleOutputCharacter(
        m_hConsoleOut,
        pcszStatus[m_fAnsiKeys ? 1 : 0],
        TERM_COLUMN_COUNT,
        co,
        &dwResult);

    xFillConsoleOutputAttribute(
        m_hConsoleOut,
        wAttribute,
        TERM_COLUMN_COUNT,
        co,
        &dwResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\sac\uterm\common\win32\xwindows.cxx ===
#include "std.hxx"

void xGetOverlappedResult(
    HANDLE hFile,
    LPOVERLAPPED lpOverlapped,
    LPDWORD lpNumberOfBytesTransferred,
    BOOL bWait)
{
    BOOL bResult = ::GetOverlappedResult(
        hFile,
        lpOverlapped,
        lpNumberOfBytesTransferred,
        bWait);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("GetOverlappedResult"));
    }
}



HANDLE xCreateFile(
    PCTSTR pcszFileName,                         // file name
    DWORD dwDesiredAccess,                      // access mode
    DWORD dwShareMode,                          // share mode
    PSECURITY_ATTRIBUTES pSecurityAttributes,   // SD
    DWORD dwCreationDisposition,                // how to create
    DWORD dwFlagsAndAttributes,                 // file attributes
    HANDLE hTemplateFile)                       // handle to template file
{
    HANDLE hTemp = ::CreateFile(
        pcszFileName,
        dwDesiredAccess,
        dwShareMode,
        pSecurityAttributes,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        hTemplateFile);

    if (INVALID_HANDLE_VALUE==hTemp)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("CreateFile"));
    }

    return hTemp;
}



void xCloseHandle(
    HANDLE hObject)                     // handle to object
{
    BOOL bResult = ::CloseHandle(
        hObject);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("CloseHandle"));
    }
}



BOOL xReadFile(
    HANDLE hFile,                       // handle to file
    PVOID pBuffer,                      // data buffer
    DWORD dwNumberOfBytesToRead,        // number of bytes to read
    PDWORD pdwNumberOfBytesRead,        // number of bytes read
    LPOVERLAPPED pOverlapped)           // overlapped buffer
{
    BOOL bResult = ::ReadFile(
        hFile,
        pBuffer,
        dwNumberOfBytesToRead,
        pdwNumberOfBytesRead,
        pOverlapped);

    if (!bResult && (GetLastError()!=ERROR_IO_PENDING))
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("ReadFile"));
    }

    return bResult;
}



void xReadFileWithAbort(
    HANDLE hFile,                       // handle to file
    PVOID pBuffer,                      // data buffer
    DWORD dwNumberOfBytesToRead,        // number of bytes to read
    PDWORD pdwNumberOfBytesRead,        // number of bytes read
    LPOVERLAPPED pOverlapped,           // overlapped buffer
    HANDLE hAbort)                      // Handle to manual reset abort event
{
    HANDLE hWait[2];
    hWait[0] = hAbort;
    hWait[1] = pOverlapped->hEvent;

    BOOL bResult = xReadFile(
        hFile,                          // handle to file
        pBuffer,                        // data buffer
        dwNumberOfBytesToRead,          // number of bytes to read
        pdwNumberOfBytesRead,           // number of bytes read
        pOverlapped);                   // overlapped buffer

    if (!bResult)
    {
        DWORD dwResult = xWaitForMultipleObjects(
            2,                              // There are two to wait on
            hWait,                          // Our two event handles
            FALSE,                          // Only one event need to be pinged
            INFINITE);                      // Wait for ever

        switch (dwResult)
        {
        case (WAIT_OBJECT_0):
            CancelIo(
                hFile);
            throw CAbortExcept();
            break;
        case (WAIT_OBJECT_0 + 1):
            xGetOverlappedResult(
                hFile,
                pOverlapped,
                pdwNumberOfBytesRead,
                TRUE);
            break;
        }
    }
}



BOOL xWriteFile(
    HANDLE hFile,                       // handle to file
    LPCVOID pBuffer,                    // data buffer
    DWORD dwNumberOfBytesToWrite,       // number of bytes to write
    PDWORD pdwNumberOfBytesWritten,     // number of bytes written
    LPOVERLAPPED pOverlapped)           // overlapped buffer
{
    BOOL bResult = ::WriteFile(
        hFile,
        pBuffer,
        dwNumberOfBytesToWrite,
        pdwNumberOfBytesWritten,
        pOverlapped);

    if (!bResult && (GetLastError()!=ERROR_IO_PENDING))
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("WriteFile"));
    }

    return bResult;
}



void xWriteFileWithAbort(
    HANDLE hFile,                       // handle to file
    LPCVOID pBuffer,                    // data buffer
    DWORD dwNumberOfBytesToWrite,       // number of bytes to write
    PDWORD pdwNumberOfBytesWritten,     // number of bytes written
    LPOVERLAPPED pOverlapped,           // overlapped buffer
    HANDLE hAbort)                      // Handle to manual reset abort event
{
    HANDLE hWait[2];
    hWait[0] = hAbort;
    hWait[1] = pOverlapped->hEvent;

    BOOL bResult = xWriteFile(
        hFile,                          // handle to file
        pBuffer,                        // data buffer
        dwNumberOfBytesToWrite,         // number of bytes to read
        pdwNumberOfBytesWritten,        // number of bytes read
        pOverlapped);                   // overlapped buffer

    if (!bResult)
    {
        DWORD dwResult = xWaitForMultipleObjects(
            2,                              // There are two to wait on
            hWait,                          // Our two event handles
            FALSE,                          // Only one event need to be pinged
            INFINITE);                      // Wait for ever

        switch (dwResult)
        {
        case (WAIT_OBJECT_0):
            CancelIo(
                hFile);
            throw CAbortExcept();
            break;
        case (WAIT_OBJECT_0 + 1):
            xGetOverlappedResult(
                hFile,
                pOverlapped,
                pdwNumberOfBytesWritten,
                TRUE);
            break;
        }
    }
}



void xGetCommState(
    HANDLE hFile,                       // handle to communications device
    LPDCB pDCB)                         // device-control block
{
    BOOL bResult = ::GetCommState(
        hFile,
        pDCB);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("GetCommState"));
    }
}



void xSetCommState(
    HANDLE hFile,                       // handle to communications device
    LPDCB pDCB)                         // device-control block
{
    BOOL bResult = ::SetCommState(
        hFile,
        pDCB);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("SetCommState"));
    }
}



void xGetCommTimeouts(
    HANDLE hFile,                       // handle to comm device
    LPCOMMTIMEOUTS pCommTimeouts)       // time-out values
{
    BOOL bResult = ::GetCommTimeouts(
        hFile,
        pCommTimeouts);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("GetCommTimeouts"));
    }
}



void xSetCommTimeouts(
    HANDLE hFile,                       // handle to comm device
    LPCOMMTIMEOUTS pCommTimeouts)       // time-out values
{
    BOOL bResult = ::SetCommTimeouts(
        hFile,
        pCommTimeouts);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("SetCommTimeouts"));
    }
}


void xSetCommMask(
    HANDLE hFile,                       // handle to communications device
    DWORD dwEvtMask)                    // mask that identifies enabled events
{
    BOOL bResult = ::SetCommMask(
        hFile,
        dwEvtMask);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("SetCommMask"));
    }
}



void xGetCommMask(
    HANDLE hFile,                       // handle to communications device
    PDWORD pdwEvtMask)                  // mask that identifies enabled events
{
    BOOL bResult = ::GetCommMask(
        hFile,
        pdwEvtMask);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("GetCommMask"));
    }
}



BOOL xWaitCommEvent(
    HANDLE hFile,                       // handle to comm device
    PDWORD pdwEvtMask,                  // event type
    LPOVERLAPPED pOverlapped)           // overlapped structure
{
    BOOL bResult = ::WaitCommEvent(
        hFile,
        pdwEvtMask,
        pOverlapped);

    if (!bResult && (GetLastError()!=ERROR_IO_PENDING))
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("WaitCommEvent"));
    }

    return bResult;
}



void xWaitCommEventWithAbort(
    HANDLE hFile,                       // handle to comm device
    PDWORD pdwEvtMask,                  // event type
    LPOVERLAPPED pOverlapped,           // overlapped structure
    HANDLE hAbort)                      // Manual reset abort event
{
    HANDLE hWait[2];
    hWait[0] = hAbort;
    hWait[1] = pOverlapped->hEvent;
    DWORD dwBytesRead;

    BOOL bResult = xWaitCommEvent(
        hFile,
        pdwEvtMask,
        pOverlapped);

    if (!bResult)
    {
        DWORD dwResult = xWaitForMultipleObjects(
            2,                              // There are two to wait on
            hWait,                          // Our two event handles
            FALSE,                          // Only one event need to be pinged
            INFINITE);                      // Wait for ever

        switch (dwResult)
        {
        case (WAIT_OBJECT_0):
            CancelIo(
                hFile);
            throw CAbortExcept();
            break;
        case (WAIT_OBJECT_0 + 1):
            xGetOverlappedResult(
                hFile,
                pOverlapped,
                &dwBytesRead,
                TRUE);
            break;
        }
    }
}



void xEscapeCommFunction(
    HANDLE hFile,                       // handle to communications device
    DWORD dwFunc)                       // extended function to perform
{
    BOOL bResult = ::EscapeCommFunction(
        hFile,
        dwFunc);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("EscapeCommFunction"));
    }
}



void xClearCommBreak(
    HANDLE hFile)                       // handle to communications device
{
    BOOL bResult = ::ClearCommBreak(
        hFile);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("ClearCommBreak"));
    }
}



void xClearCommError(
    HANDLE hFile,                       // handle to communications device
    PDWORD pdwErrors,                   // error codes
    LPCOMSTAT pStat)                    // communications status
{
    BOOL bResult = ::ClearCommError(
        hFile,
        pdwErrors,
        pStat);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("ClearCommError"));
    }
}



void xBuildCommDCB(
    PCTSTR pcszDef,                      // device-control string
    LPDCB  lpDCB)                       // device-control block
{
    BOOL bResult = ::BuildCommDCB(
        pcszDef,
        lpDCB);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("BuildCommDCB"));
    }
}


void xTransmitCommChar(
  HANDLE hFile,
  char cChar)
{
    BOOL bResult = ::TransmitCommChar(
        hFile,
        cChar);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("TransmitCommChar"));
    }
}


HANDLE xCreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes, // SD
    DWORD dwStackSize,                        // initial stack size
    LPTHREAD_START_ROUTINE lpStartAddress,    // thread function
    LPVOID lpParameter,                       // thread argument
    DWORD dwCreationFlags,                    // creation option
    LPDWORD lpThreadId)                       // thread identifier
{
    HANDLE hResult = ::CreateThread(
        lpThreadAttributes,             // SD
        dwStackSize,                    // initial stack size
        lpStartAddress,                 // thread function
        lpParameter,                    // thread argument
        dwCreationFlags,                // creation option
        lpThreadId);                    // thread identifier

    if (NULL==hResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("CreateThread"));
    }

    return hResult;
}


void xTerminateThread(
    HANDLE hThread,                     // handle to thread
    DWORD dwExitCode)                   // exit code
{
    throw CWin32ApiExcept(
        GetLastError(),
        _T("TerminateThread"));
}


UINT_PTR xSetTimer(
  HWND hWnd,                            // handle to window
  UINT_PTR nIDEvent,                    // timer identifier
  UINT uElapse,                         // time-out value
  TIMERPROC lpTimerFunc)                // timer procedure
{
    UINT_PTR pResult = ::SetTimer(
        hWnd,
        nIDEvent,
        uElapse,
        lpTimerFunc);

    if (0 == pResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("SetTimer"));
    }

    return pResult;
}



void xKillTimer(
  HWND hWnd,                            // handle to window
  UINT_PTR uIDEvent)                    // timer identifier
{
    BOOL bResult = ::KillTimer(
        hWnd,
        uIDEvent);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("KillTimer"));
    }
}


void xFillConsoleOutputAttribute(
  HANDLE hConsoleOutput,
  WORD wAttribute,
  DWORD nLength,
  COORD dwWriteCoord,
  LPDWORD lpNumberOfAttrsWritten)
{
    BOOL bResult = ::FillConsoleOutputAttribute(
        hConsoleOutput,
        wAttribute,
        nLength,
        dwWriteCoord,
        lpNumberOfAttrsWritten);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("FillConsoleOutputAttribute"));
    }
}


void xFillConsoleOutputCharacter(
  HANDLE hConsoleOutput,
  TCHAR cCharacter,
  DWORD nLength,
  COORD dwWriteCoord,
  LPDWORD lpNumberOfCharsWritten)
{
    BOOL bResult = ::FillConsoleOutputCharacter(
        hConsoleOutput,
        cCharacter,
        nLength,
        dwWriteCoord,
        lpNumberOfCharsWritten);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("FillConsoleOutputCharacter"));
    }
}


void xGetConsoleScreenBufferInfo(
  HANDLE hConsoleOutput,
  PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo)
{
    BOOL bResult = ::GetConsoleScreenBufferInfo(
        hConsoleOutput,
        lpConsoleScreenBufferInfo);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("GetConsoleScreenBufferInfo"));
    }
}


DWORD xGetConsoleTitle(
  LPTSTR lpConsoleTitle,
  DWORD nSize)
{
    DWORD dwResult = ::GetConsoleTitle(
        lpConsoleTitle,
        nSize);

    if (!dwResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("GetConsoleTitle"));
    }

    return dwResult;
}


COORD xGetLargestConsoleWindowSize(
  HANDLE hConsoleOutput)
{
    COORD Result = ::GetLargestConsoleWindowSize(
        hConsoleOutput);

    if (0==Result.X && 0==Result.Y)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("GetLargestConsoleWindowSize"));
    }

    return Result;
}


HANDLE xGetStdHandle(
  DWORD nStdHandle)
{
    HANDLE hResult = ::GetStdHandle(
            nStdHandle);

    if (INVALID_HANDLE_VALUE==hResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("GetStdHandle"));
    }

    return hResult;
}


void xReadConsoleOutputAttribute(
  HANDLE hConsoleOutput,
  LPWORD lpAttribute,
  DWORD nLength,
  COORD dwReadCoord,
  LPDWORD lpNumberOfAttrsRead)
{
    BOOL bResult = ::ReadConsoleOutputAttribute(
        hConsoleOutput,
        lpAttribute,
        nLength,
        dwReadCoord,
        lpNumberOfAttrsRead);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("ReadConsoleOutputAttribute"));
    }
}


void xReadConsoleOutputCharacter(
  HANDLE hConsoleOutput,
  LPTSTR lpCharacter,
  DWORD nLength,
  COORD dwReadCoord,
  LPDWORD lpNumberOfCharsRead)
{
    BOOL bResult = ::ReadConsoleOutputCharacter(
        hConsoleOutput,
        lpCharacter,
        nLength,
        dwReadCoord,
        lpNumberOfCharsRead);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("ReadConsoleOutputCharacter"));
    }
}

void xSetConsoleScreenBufferSize(
  HANDLE hConsoleOutput,
  COORD dwSize)
{
    BOOL bResult = ::SetConsoleScreenBufferSize(
        hConsoleOutput,
        dwSize);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("SetConsoleScreenBufferSize"));
    }
}


void xSetConsoleTextAttribute(
  HANDLE hConsoleOutput,
  WORD wAttributes)
{
    BOOL bResult = ::SetConsoleTextAttribute(
        hConsoleOutput,
        wAttributes);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("SetConsoleTextAttribute"));
    }
}


void xSetConsoleTitle(
  LPCTSTR lpConsoleTitle)
{
    BOOL bResult = ::SetConsoleTitle(
        lpConsoleTitle);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("SetConsoleTitle"));
    }
}


void xSetConsoleWindowInfo(
  HANDLE hConsoleOutput,
  BOOL bAbsolute,
  CONST SMALL_RECT *lpConsoleWindow)
{
    BOOL bResult = ::SetConsoleWindowInfo(
        hConsoleOutput,
        bAbsolute,
        lpConsoleWindow);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("SetConsoleWindowInfo"));
    }
}


void xWriteConsole(
  HANDLE hConsoleOutput,
  CONST VOID *lpBuffer,
  DWORD nNumberOfCharsToWrite,
  LPDWORD lpNumberOfCharsWritten,
  LPVOID lpReserved)
{
    BOOL bResult = ::WriteConsole(
        hConsoleOutput,
        lpBuffer,
        nNumberOfCharsToWrite,
        lpNumberOfCharsWritten,
        lpReserved);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("WriteConsole"));
    }
}


void xWriteConsoleOutputAttribute(
  HANDLE hConsoleOutput,
  CONST WORD *lpAttribute,
  DWORD nLength,
  COORD dwWriteCoord,
  LPDWORD lpNumberOfAttrsWritten)
{
    BOOL bResult = ::WriteConsoleOutputAttribute(
        hConsoleOutput,
        lpAttribute,
        nLength,
        dwWriteCoord,
        lpNumberOfAttrsWritten);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("WriteConsoleOutputAttribute"));
    }
}

void xWriteConsoleOutputCharacter(
  HANDLE hConsoleOutput,
  LPCTSTR lpCharacter,
  DWORD nLength,
  COORD dwWriteCoord,
  LPDWORD lpNumberOfCharsWritten)
{
    BOOL bResult = ::WriteConsoleOutputCharacter(
        hConsoleOutput,
        lpCharacter,
        nLength,
        dwWriteCoord,
        lpNumberOfCharsWritten);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("WriteConsoleOutputCharacter"));
    }
}


HANDLE xCreateEvent(
    LPSECURITY_ATTRIBUTES lpEventAttributes, // SD
    BOOL bManualReset,                       // reset type
    BOOL bInitialState,                      // initial state
    LPCTSTR lpName)                          // object name
{
    HANDLE hResult = ::CreateEvent(
        lpEventAttributes,
        bManualReset,
        bInitialState,
        lpName);

    if (INVALID_HANDLE_VALUE==hResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("CreateEvent"));
    }

    return hResult;
}


void xSetEvent(
    HANDLE hEvent)
{
    BOOL bResult = ::SetEvent(
        hEvent);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("SetEvent"));
    }
}



void xResetEvent(
    HANDLE hEvent)
{
    BOOL bResult = ::ResetEvent(
        hEvent);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("ResetEvent"));
    }
}



DWORD xWaitForMultipleObjects(
    DWORD nCount,             // number of handles in array
    CONST HANDLE *lpHandles,  // object-handle array
    BOOL fWaitAll,            // wait option
    DWORD dwMilliseconds)     // time-out interval
{
    DWORD dwResult = ::WaitForMultipleObjects(
        nCount,
        lpHandles,
        fWaitAll,
        dwMilliseconds);

    if (WAIT_FAILED==dwResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("WaitForMultipleObjects"));
    }

    return dwResult;
}



DWORD xWaitForSingleObject(
  HANDLE hHandle,           // handle to object
  DWORD dwMilliseconds)     // time-out interval
{
    DWORD dwResult = ::WaitForSingleObject(
        hHandle,            // handle to object
        dwMilliseconds);    // time-out interval

    if (WAIT_FAILED==dwResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("WaitForSingleObject"));
    }

    return dwResult;
}



PWSTR xMultiByteToWideChar(
    UINT CodePage,            // code page
    DWORD dwFlags,            // performance and mapping flags
    LPCSTR lpMultiByteStr)    // wide-character string
{
    int dResult = ::MultiByteToWideChar(
        CodePage,
        dwFlags,
        lpMultiByteStr,
        -1,
        NULL,
        0);

    if (dResult==0)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("MultiByteToWideChar"));
    }

    auto_ptr<WCHAR> pszOutput(
        new WCHAR[dResult]);

    dResult = ::MultiByteToWideChar(
        CodePage,
        dwFlags,
        lpMultiByteStr,
        -1,
        pszOutput.get(),
        dResult);

    if (dResult==0)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("MultiByteToWideChar"));
    }

    return pszOutput.release();
}


PSTR xWideCharToMultiByte(
    UINT CodePage,            // code page
    DWORD dwFlags,            // performance and mapping flags
    LPCWSTR lpWideCharStr)    // wide-character string
{
    int dResult = ::WideCharToMultiByte(
        CodePage,
        dwFlags,
        lpWideCharStr,
        -1,
        NULL,
        0,
        NULL,
        NULL);

    if (dResult==0)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("WideCharToMultiByte"));
    }

    auto_ptr<CHAR> pszOutput(
        new CHAR[dResult]);

    dResult = ::WideCharToMultiByte(
        CodePage,
        dwFlags,
        lpWideCharStr,
        -1,
        pszOutput.get(),
        dResult,
        NULL,
        NULL);

    if (dResult==0)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("WideCharToMultiByte"));
    }

    return pszOutput.release();
}


PWSTR xMakeWideChar(
    PTSTR pcszInput)
{
    #ifdef _UNICODE
    auto_ptr<WCHAR> pszOutput(
        new WCHAR[wcslen(pcszInput)+1]);
    wcscpy(
        pszOutput.get(),
        pcszInput);
    #else
    auto_ptr<WCHAR> pszOutput(
        xMultiByteToWideChar(
            CP_ACP,
            0,
            pcszInput));
    #endif
    return pszOutput.release();
}


PSTR xMakeMultiByte(
    PTSTR pcszInput)
{
    #ifdef _UNICODE
    auto_ptr<CHAR> pszOutput(
        xWideCharToMultiByte(
            CP_ACP,
            0,
            pcszInput));
    #else
    auto_ptr<CHAR> pszOuptut(
        new CHAR[strlen(pcszInput)+1]);
    strcpy(
        pszOutput.get(),
        pcszInput);
    #endif
    return pszOutput.release();
}


PTSTR xMakeDefaultChar(
    PWSTR pcszInput)
{
    #ifdef _UNICODE
    auto_ptr<WCHAR> pszOutput(
        new WCHAR[wcslen(pcszInput)+1]);
    wcscpy(
        pszOutput.get(),
        pcszInput);
    #else
    auto_ptr<WCHAR> pszOuptut(
        xWideCharToMultiByte(
            CP_ACP,
            0,
            pcszInput));
    #endif
    return pszOutput.release();
}


PTSTR xMakeDefaultChar(
    PSTR pcszInput)
{
    #ifdef _UNICODE
    auto_ptr<WCHAR> pszOutput(
        xMultiByteToWideChar(
            CP_ACP,
            0,
            pcszInput));
    #else
    auto_ptr<CHAR> pszOuptut(
        new CHAR[strlen(pcszInput)+1]);
    strcpy(
        pszOutput.get(),
        pcszInput);
    #endif
    return pszOutput.release();
}


DWORD xGetModuleFileName(
    HMODULE hModule,    // handle to module
    LPTSTR lpFilename,  // file name of module
    DWORD nSize)        // size of buffer
{
    DWORD dwResult = ::GetModuleFileName(
        hModule,
        lpFilename,
        nSize);

    if (0==dwResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("GetModuleFileName"));
    }

    if (dwResult == nSize)  // This will happen if
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return 0;
    }
    else
    {
        return dwResult;
    }
}


HANDLE xFindFirstFile(
    LPCTSTR lpFileName,               // file name
    LPWIN32_FIND_DATA lpFindFileData) // data buffer
{
    HANDLE hResult = ::FindFirstFile(
        lpFileName,
        lpFindFileData);

    if (INVALID_HANDLE_VALUE==hResult && GetLastError()!=ERROR_NO_MORE_FILES)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("FindFirstFile"));
    }

    return hResult;
}

BOOL xFindNextFile(
    HANDLE hFindFile,                 // search handle
    LPWIN32_FIND_DATA lpFindFileData) // data buffer
{
    BOOL fResult = ::FindNextFile(
        hFindFile,
        lpFindFileData);

    if (!fResult && GetLastError()!=ERROR_NO_MORE_FILES)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("FindNextFile"));
    }

    return fResult;
}


HMODULE xLoadLibrary(
    LPCTSTR lpFileName)   // file name of module
{
    HMODULE hResult = ::LoadLibrary(
        lpFileName);

    if (NULL==hResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("LoadLibrary"));
    }

    return hResult;
}


BOOL xFreeLibrary(
    HMODULE hModule)   // handle to DLL module
{
    BOOL bResult = ::FreeLibrary(
        hModule);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("FreeLibrary"));
    }

    return bResult;
}


FARPROC xGetProcAddress(
    HMODULE hModule,
    LPCSTR lpProcName)
{
    FARPROC pResult = ::GetProcAddress(
        hModule,
        lpProcName);

    if (NULL==pResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("GetProcAddress"));
    }

    return pResult;
}







CFindFile::~CFindFile()
{
    if (m_hFind!=INVALID_HANDLE_VALUE)
    {
        FindClose(m_hFind);
    }
}


BOOL CFindFile::First(PCTSTR pcszFileName)
{
    if (m_hFind!=INVALID_HANDLE_VALUE)
    {
        FindClose(m_hFind);
    }

    m_hFind = xFindFirstFile(
        pcszFileName,
        &m_FindData);

    return (m_hFind!=INVALID_HANDLE_VALUE);
}



BOOL CFindFile::Next()
{
    return xFindNextFile(
        m_hFind,
        &m_FindData);
}


PWIN32_FIND_DATA CFindFile::Found()
{
    return &m_FindData;
}



HANDLE xCreateMutex(
  LPSECURITY_ATTRIBUTES lpMutexAttributes,  // SD
  BOOL bInitialOwner,                       // initial owner
  LPCTSTR lpName)                           // object name
{
    HANDLE hResult = ::CreateMutex(
        lpMutexAttributes,                  // SD
        bInitialOwner,                      // initial owner
        lpName);                            // object name

    if (NULL==hResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("CreateMutex"));
    }

    return hResult;
}


void xReleaseMutex(
    HANDLE hMutex)
{
    BOOL bResult = ::ReleaseMutex(
        hMutex);                            // mutex object handle

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("ReleaseMutex"));
    }
}


PTSTR xFormatMessage(
    DWORD dwFlags,          // source and processing options
    LPCVOID lpSource,       // message source
    DWORD dwMessageId,      // message identifier
    DWORD dwLanguageId,     // language identifier
    LPTSTR lpBuffer,        // message buffer
    DWORD nSize,            // maximum size of message buffer
    va_list *Arguments)     // array of message inserts
{
    auto_ptr<TCHAR> pszMessage;
    PTSTR pszTempBuffer;

    DWORD dwResult = ::FormatMessage(
        dwFlags,
        lpSource,
        dwMessageId,
        dwLanguageId,
        (LPTSTR)&pszTempBuffer,
        nSize,
        Arguments);


    if (dwResult==0)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("FormatMessage"));
    }

    try
    {
        auto_ptr<TCHAR> pszMessage(
            new TCHAR[_tcslen(pszTempBuffer)+1]);
        _tcscpy(
            pszMessage.get(),
            pszTempBuffer);

        if (lpBuffer!=NULL)
        {
            *((PTSTR*)lpBuffer) = pszMessage.get();
        }

        LocalFree(
            pszTempBuffer);

        return pszMessage.release();
    }
    catch (...)
    {
        //
        // This needs to be freed regardless.
        //
        LocalFree(
            pszTempBuffer);
        throw;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\admin.h ===
// admin.h
// 6-17-97 - start using index field assigned to box to id rx-messages.

int ioctl_device(int cmd,
                 BYTE *buf,
                 BYTE *pkt,
                 ULONG offset,  // or ioctl-subfunction if cmd=ioctl
                 int size);
int eth_device_data(int message_type,
                unsigned long offset,
                int num_bytes,
                unsigned char *data,
                unsigned char *pkt,
                int *pkt_size);
int eth_device_reply(int message_type,
                unsigned long offset,
                int *num_bytes,
                unsigned char *data,
                unsigned char *pkt);

#define IOCTL_COMMAND    0x5 
#define GET_COMMAND      0x7
#define UPLOAD_COMMAND   0x8
#define DOWNLOAD_COMMAND 0x9

int admin_send_reset(Nic *nic, BYTE *dest_addr);
int admin_send_query_id(Nic *nic, BYTE *dest_addr, int set_us_as_master,
                        BYTE assigned_index);
int admin_send(Nic *nic, BYTE *buf, int len, int admin_type, BYTE *mac_dest);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\admin.c ===
/*--------------------------------------------------------------------------
| admin.c - Ethernet common admin-packet handling.  Includes common
  admin. packet handling code.

6-17-97 - start using index field assigned to box to id rx-messages.

 Copyright 1996,97 Comtrol Corporation.  All rights reserved.  Proprietary
 information not permitted for development or use with non-Comtrol products.
|--------------------------------------------------------------------------*/
#include "precomp.h"

static int eth_command_reset(BYTE *rx, BYTE *pkt_in, int size);
static int eth_loop_back(BYTE *pkt_in, int size);
static int eth_id_reply(BYTE *rx, BYTE *pkt_in);
static int eth_id_req(BYTE *mac_addr);

#define TraceStr(s) GTrace(D_Nic, sz_modid, s)
#define TraceErr(s) GTrace(D_Error, sz_modid_err, s)
static char *sz_modid = {"Admin"};
static char *sz_modid_err = {"Error,Admin"};

#define MAX_SEND_DATA_SIZE 220
#define DEV_OK              0
#define DEV_PORT_TIMEOUT    1
#define DEV_NO_REPLY        2
#define DEV_SHORT_REPLY     3
#define DEV_BAD_RHEADSHORT  4
#define DEV_BAD_RHEAD       5
#define DEV_BAD_CHKSUM      6
#define DEV_OVERRUN         7
#define DEV_RESPOND_ERROR   100

/*----------------------------------------------------------------------------
| admin_send_query_id -
|----------------------------------------------------------------------------*/
int admin_send_query_id(Nic *nic, BYTE *dest_addr, int set_us_as_master,
                        BYTE assigned_index)
{
  BYTE pkt[60];
  int stat;
  TraceStr("SndQuery");

  memset(pkt, 0, 60);

  if (set_us_as_master)
       pkt[26] = 2;  // take over device(makes it save our mac-addr)
                     // 2H = Observe Owner LockOut
  else pkt[26] = 1;  // set 1 bit so device does not save off mac-addr
                     // 1H = Passive Query

  pkt[15] = assigned_index;  // assign the box a index value which we
    // use to "id" the box messages.

  // server query for box-id
  if (dest_addr == NULL)
       stat = admin_send(nic, pkt, 26, ADMIN_ID_QUERY, broadcast_addr);
  else stat = admin_send(nic, pkt, 26, ADMIN_ID_QUERY, dest_addr);
  if (stat != 0)
    TraceErr("txer5A!");

  return stat;
}

/*----------------------------------------------------------------------------
| admin_send_reset -
|----------------------------------------------------------------------------*/
int admin_send_reset(Nic *nic, BYTE *dest_addr)
{
  BYTE pkt[60];
  int stat;
  TraceStr("SndReset");
  memset(pkt, 0, 60);

  *((WORD *)&pkt[20]) = 0x5555;
  if (dest_addr == NULL)
       stat = admin_send(nic, pkt, 26, ADMIN_ID_RESET, broadcast_addr);
  else stat = admin_send(nic, pkt, 26, ADMIN_ID_RESET, dest_addr);
  if (stat != 0)
    TraceErr("txer4A!");

  return stat;
}

/*----------------------------------------------------------------------------
| admin_send - Used to send common admin packets, takes care of
   filling in the header.
|----------------------------------------------------------------------------*/
int admin_send(Nic *nic, BYTE *buf, int len, int admin_type, BYTE *mac_dest)
{
 int stat;

  TraceStr("SndPkt");
  memcpy(&buf[0], mac_dest, 6);
  memcpy(&buf[6], nic->address, 6);  // our addr

  // BYTE 12-13: Comtrol PCI ID  (11H, FEH), Ethernet Len field
  *((WORD *)&buf[12]) = 0xfe11;

  buf[14] = ASYNC_PRODUCT_HEADER_ID;  // comtrol packet type = driver management, any product.
  buf[15] = 0;     // conc. index field
  buf[16] = 1;     // admin
  *((WORD *)&buf[17]) = len;
  buf[19] = admin_type;     // ADMIN packet type, 1=boot-loader, 3=id-reply

  if (admin_type == ADMIN_ID_QUERY)
    memcpy(&buf[20], nic->address, 6);  // our addr

  if (len < 60)
    len = 60;
  stat = nic_send_pkt(nic, buf, len);
  if (stat)
  {
    TraceErr("txer3!");
  }
  return stat;
}

/*---------------------------------------------------------------------------
| ioctl_device - send admin, boot loader packets to the box to
   upload code, do misc ioctl commands, etc.
|---------------------------------------------------------------------------*/
int ioctl_device(int cmd,
                 BYTE *buf,
                 BYTE *pkt,
                 ULONG offset,  // or ioctl-subfunction if cmd=ioctl
                 int size)
{
 int stat;
 int pkt_size;
  TraceStr("Ioctl");

 stat = 1;  // err
 switch(cmd)
 {
   case IOCTL_COMMAND:
     stat = eth_device_data(cmd, offset, size, buf, pkt, &pkt_size);
   break;
   case DOWNLOAD_COMMAND:
     stat = eth_device_data(cmd, offset, size, buf, pkt, &pkt_size);
   break;
   case UPLOAD_COMMAND:
     stat = eth_device_data(cmd, offset, size, buf, pkt, &pkt_size);
   break;
 }
   return stat;
}

/*---------------------------------------------------------------------------
| eth_device_data - talks with the device, either sets device data or gets
|  device data.  Returns 0 if communications ok.
|---------------------------------------------------------------------------*/
int eth_device_data(int message_type,
                unsigned long offset,
                int num_bytes,
                unsigned char *data,
                unsigned char *pkt,
                int *pkt_size)
{
  int i;
  unsigned char chksum, command, dat_in;
  WORD packet_length;
  int pkt_i;
  unsigned char *bf;


  int in_size = num_bytes;




  command = message_type;
  switch (message_type)
  {
    case IOCTL_COMMAND :
      packet_length = in_size + 6; // num bytes after len, no chksum included
    break;

    case UPLOAD_COMMAND :
      //  send: 0=header, 1=addr, 2=len, 3,4=cmd, 5,6,7,8=offset, data, chksum
      // reply: 0=header, 1=addr, 2=len, 3,4=cmd, 5=chksum
      packet_length = in_size + 6;
    break;

    case DOWNLOAD_COMMAND :
      // 0=header, 1=addr, 2=len, 3,4=cmd, 5,6,7,8=offset, 9=len_ret
      // reply: 0=header, 1=addr, 2=len, 3,4=cmd, data, chksum
      packet_length = 8;
    break;
  }

  //-------- flush any ethernet packets in rx buffer
  //eth_flush();

  pkt_i=0;  // start data area in eth. packet
  pkt[pkt_i++] = '~';

  pkt[pkt_i] = (unsigned char) packet_length;
  chksum = pkt[pkt_i++];

  pkt[pkt_i] = (unsigned char) (packet_length >> 8);
  chksum += pkt[pkt_i++];

  chksum += command;
  pkt[pkt_i++] = command;
  pkt[pkt_i++] = 0;   /* hi-byte, command */

  switch (message_type)
  {
    case IOCTL_COMMAND :
      bf = (BYTE *) &offset;
      chksum += bf[0]; pkt[pkt_i++] = bf[0];
      chksum += bf[1]; pkt[pkt_i++] = bf[1];
      chksum += bf[2]; pkt[pkt_i++] = bf[2];
      chksum += bf[3]; pkt[pkt_i++] = bf[3];

      //printf("ioctl-id:%d, size\n", bf[3], in_size);
      for (i=0; i<in_size; i++)
      {
        dat_in = data[i];
        chksum += dat_in;
        pkt[pkt_i++] = dat_in;
      }
    break;

    case UPLOAD_COMMAND :
      bf = (BYTE *) &offset;
      chksum += bf[0]; pkt[pkt_i++] = bf[0];
      chksum += bf[1]; pkt[pkt_i++] = bf[1];
      chksum += bf[2]; pkt[pkt_i++] = bf[2];
      chksum += bf[3]; pkt[pkt_i++] = bf[3];

      for (i=0; i<in_size; i++)
      {
        dat_in = data[i];
        chksum += dat_in;
        pkt[pkt_i++] = dat_in;
      }
    break;

    case DOWNLOAD_COMMAND :
      bf = (BYTE *) &offset;
      chksum += bf[0]; pkt[pkt_i++] = bf[0];
      chksum += bf[1]; pkt[pkt_i++] = bf[1];
      chksum += bf[2]; pkt[pkt_i++] = bf[2];
      chksum += bf[3]; pkt[pkt_i++] = bf[3];

      chksum += (unsigned char) in_size;
      pkt[pkt_i++] = (unsigned char) in_size;

      chksum += (unsigned char) (in_size >> 8);
      pkt[pkt_i++] = (unsigned char) (in_size >> 8);
    break;

    default:
    break;
  }

  pkt[pkt_i++] = ~chksum;

  *pkt_size = pkt_i;

  return 0;
}

/*---------------------------------------------------------------------------
| eth_device_reply - Validate the ACK reply pkt due to a sent
   boot packet.  Ack reply may include data if an IOCTL or
   DOWNLOAD type.  We use UPLOAD command for code uploads.
|    Returns 0 if communications ok.
|---------------------------------------------------------------------------*/
int eth_device_reply(int message_type,
                unsigned long offset,
                int *num_bytes,
                unsigned char *data,
                unsigned char *pkt)
{
  int i;
  unsigned char chksum;
  unsigned char *bf;
  unsigned char uc;
  WORD ret_size;
  BYTE *bptr;

  bptr = pkt;

  if (bptr[0] != '|')  // good reply header
  {
    TraceErr("Err3");
    return DEV_BAD_RHEAD;
  }

  chksum = bptr[1];
  ret_size = bptr[1];  // get len

  chksum += bptr[2];
  ret_size += ((WORD)(bptr[2]) << 8);  // get len
  if (ret_size > 1600)  // limit
    ret_size = 0;

  uc = bptr[3];  // get command return word
  chksum += uc;
  uc = bptr[4];
  chksum += uc;

  i = 0;
  if ((message_type == IOCTL_COMMAND) || (message_type == DOWNLOAD_COMMAND))
  {
    // o_printf("ret size:%d\n", ret_size-2);
    if (data == NULL)
      return 20;  // err out

    bf = data;
    for (i=0; i<ret_size-2; i++)
    {
      bf[i] = bptr[5+i];
      chksum += bf[i];
    }
    i = ret_size-2;
  }

  chksum += bptr[5+i];
  if (chksum != 0xff)
  {
    return DEV_BAD_CHKSUM;  /* bad chksum */
  }

  if ((message_type == IOCTL_COMMAND) || (message_type == DOWNLOAD_COMMAND))
    *num_bytes = ret_size-2;
  else
    *num_bytes = 0;

  return 0;  // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\asic.h ===
/*-------------------------------------------------------------------
  asic.h - Whole slew of literals for talking to RocketPort hardware.
Copyright 1993-96 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/

#define MCODE_SIZE 256          /* maximum microcode array size */
#define MCODE_ADDR 0x900        /* microcode base address within char */

/* Offsets within MCode1Reg[].  Defines ending in _OUT give the MCode1Reg[]
   index used to obtain the DWORD value written to the AIOP Index Register.
   This DWORD contains the SRAM address in the low word, and the SRAM data
   in the high word.  Defines ending in _DATA given the MCode1Reg[]
   index for one of the two bytes of SRAM data withing a DWORD. These
   defines are used to locate various character values that are used by
   the Rx processor. */
#define RXMASK_DATA    0x13     /* Rx Mask FF 913 */
#define RXMASK_OUT     0x10
#define RXCMPVAL0_DATA 0x17     /* Rx Cmp #0 00 915 */
#define RXCMPVAL0_OUT  0x14
#define RXCMPVAL1_DATA 0x1b     /* Rx Cmp #1 7B 917 */
#define RXCMPVAL1_OUT  0x18  
#define RXCMPVAL2_DATA 0x1f     /* Rx Cmp #2 7D 919 */
#define RXCMPVAL2_OUT  0x1c  
#define RXREPL1_DATA   0x27     /* Rx Repl #1 7A 91d */
#define RXREPL1_OUT    0x24
#define RXREPL2_DATA   0x2f     /* Rx Repl #2 7c 921 */
#define RXREPL2_OUT    0x2c  
#define TXXOFFVAL_DATA 0x07     /* Tx XOFF 13 909 */ 
#define TXXOFFVAL_OUT  0x04  
#define TXXONVAL_DATA  0x0b     /* Tx XON 11 90b  */
#define TXXONVAL_OUT   0x08  


/* More offsets with MCode1Reg[].  These are used to enable/disable Rx
   processor features.  Defines ending in _DATA and _OUT are used as
   described above.  The actual values to be saved at the _DATA
   indices end in _EN (to enable the feature) or _DIS (to disable the
   feature). */

/* Ignore # 0 */
#define IGNORE0_DATA  0x16  /* ce/82 914 */
#define IGNORE0_OUT   0x14  
#define IGNORE0_EN    0xce
#define IGNORE0_DIS   0x82

/* Ignore / Replace Byte #1 */
#define IGREP1_DATA  0x26  /* 0a/40/86 91c */
#define IGREP1_OUT   0x24
#define IGNORE1_EN   0x0a
#define REPLACE1_EN  0x40
#define IG_REP1_DIS  0x86

/* Ignore / Replace Byte #2 */
#define IGREP2_DATA  0x2e  /* 0a/40/82 920 */
#define IGREP2_OUT   0x2c
#define IGNORE2_EN   0x0a
#define REPLACE2_EN  0x40
#define IG_REP2_DIS  0x82

/* Interrupt Compare #1 */
#define INTCMP1_DATA 0x23   /* 11/81 91b */
#define INTCMP1_OUT  0x20
#define INTCMP1_EN   0x11
#define INTCMP1_DIS  0x81

/* Interrupt Compare #2 */
#define INTCMP2_DATA 0x2b  /* 10/81 91f */
#define INTCMP2_OUT  0x28
#define INTCMP2_EN   0x10
#define INTCMP2_DIS  0x81

/* Receive Compare #1 */
#define RXCMP1_DATA  0x1a  /* C4/82 916 */
#define RXCMP1_OUT   0x18
#define RXCMP1_EN    0xc4
#define RXCMP1_DIS   0x82

/* Receive Compare #2 */
#define RXCMP2_DATA  0x1e  /* C6/8a 918 */
#define RXCMP2_OUT   0x1c
#define RXCMP2_EN    0xc6
#define RXCMP2_DIS   0x8a

/* Receive FIFO */
#define RXFIFO_DATA  0x32  /* 08/0a 922 */
#define RXFIFO_OUT   0x30
#define RXFIFO_EN    0x08 
#define RXFIFO_DIS   0x0a

/* Transmit S/W Flow Cont */
#define TXSWFC_DATA  0x06  /* C5/8A 908 */
#define TXSWFC_OUT   0x04
#define TXSWFC_EN    0xc5
#define TXSWFC_DIS   0x8a

/* XANY Flow Control */
#define IXANY_DATA   0x0e  /* 21/86 921 */
#define IXANY_OUT    0x0c
#define IXANY_EN     0x21
#define IXANY_DIS    0x86


/************************************************************************
 End of Microcode definitions.
************************************************************************/

/************************************************************************
 Global Register Offsets - Direct Access - Fixed values
************************************************************************/

#define _CMD_REG   0x38   /* Command Register            8    Write */
#define _INT_CHAN  0x39   /* Interrupt Channel Register  8    Read */
#define _INT_MASK  0x3A   /* Interrupt Mask Register     8    Read / Write */
#define _UNUSED    0x3B   /* Unused                      8 */
#define _INDX_ADDR 0x3C   /* Index Register Address      16   Write */
#define _INDX_DATA 0x3E   /* Index Register Data         8/16 Read / Write */

/************************************************************************
 Channel Register Offsets for 1st channel in AIOP - Direct Access
************************************************************************/
#define _TD0       0x00  /* Transmit Data               16   Write */
#define _RD0       0x00  /* Receive Data                16   Read */
#define _CHN_STAT0 0x20  /* Channel Status              8/16 Read / Write */
#define _FIFO_CNT0 0x10  /* Transmit/Receive FIFO Count 16   Read */
#define _INT_ID0   0x30  /* Interrupt Identification    8    Read */

/************************************************************************
 Tx Control Register Offsets - Indexed - External - Fixed
************************************************************************/
#define _TX_ENBLS  0x980    /* Tx Processor Enables Register 8 Read / Write */
#define _TXCMP1    0x988    /* Transmit Compare Value #1     8 Read / Write */
#define _TXCMP2    0x989    /* Transmit Compare Value #2     8 Read / Write */
#define _TXREP1B1  0x98A    /* Tx Replace Value #1 - Byte 1  8 Read / Write */
#define _TXREP1B2  0x98B    /* Tx Replace Value #1 - Byte 2  8 Read / Write */
#define _TXREP2    0x98C    /* Transmit Replace Value #2     8 Read / Write */

/************************************************************************
Memory Controller Register Offsets - Indexed - External - Fixed
************************************************************************/
#define _RX_FIFO    0x000    /* Rx FIFO */
#define _TX_FIFO    0x800    /* Tx FIFO */
#define _RXF_OUTP   0x990    /* Rx FIFO OUT pointer        16 Read / Write */
#define _RXF_INP    0x992    /* Rx FIFO IN pointer         16 Read / Write */
#define _TXF_OUTP   0x994    /* Tx FIFO OUT pointer        8  Read / Write */
#define _TXF_INP    0x995    /* Tx FIFO IN pointer         8  Read / Write */
#define _TXP_CNT    0x996    /* Tx Priority Count          8  Read / Write */
#define _TXP_PNTR   0x997    /* Tx Priority Pointer        8  Read / Write */

#define PRI_PEND    0x80     /* Priority data pending (bit7, Tx pri cnt) */
#define TXFIFO_SIZE 255      /* size of Tx FIFO */
#define RXFIFO_SIZE 1023     /* size of Rx FIFO */

/************************************************************************
Tx Priority Buffer - Indexed - External - Fixed
************************************************************************/
#define _TXP_BUF    0x9C0    /* Tx Priority Buffer  32  Bytes   Read / Write */
#define TXP_SIZE    0x20     /* 32 bytes */

/************************************************************************
Channel Register Offsets - Indexed - Internal - Fixed
************************************************************************/

#define _TX_CTRL    0xFF0    /* Transmit Control               16  Write */
#define _RX_CTRL    0xFF2    /* Receive Control                 8  Write */
#define _BAUD       0xFF4    /* Baud Rate                      16  Write */
#define _CLK_PRE    0xFF6    /* Clock Prescaler                 8  Write */

/************************************************************************
  Baud rate divisors using mod 9 clock prescaler and 36.864 clock
  clock prescaler, MUDBAC prescale is in upper nibble (=0x10)
  AIOP prescale is in lower nibble (=0x9)
************************************************************************/
#define DEF_ROCKETPORT_PRESCALER 0x14 /* div 5 prescale, max 460800 baud(NO 50baud!) */
#define DEF_ROCKETPORT_CLOCKRATE 36864000

#define DEF_RPLUS_PRESCALER  0x12 /* div by 3 baud prescale, 921600, crystal:44.2368Mhz */
#define DEF_RPLUS_CLOCKRATE 44236800

//#define BRD9600           47
//#define RCKT_CLK_RATE   (2304000L / ((CLOCK_PRESC & 0xf)+1))
//#define BRD9600           (((RCKT_CLK_RATE + (9600 / 2)) / 9600) - 1)
//#define BRD57600          (((RCKT_CLK_RATE + (57600 / 2)) / 57600) - 1)
//#define BRD115200         (((RCKT_CLK_RATE + (115200 / 2)) / 115200) - 1)


/************************************************************************
        Channel register defines
************************************************************************/
/* channel data register stat mode status byte (high byte of word read) */
#define STMBREAK   0x08        /* BREAK */
#define STMFRAME   0x04        /* framing error */
#define STMRCVROVR 0x02        /* receiver over run error */
#define STMPARITY  0x01        /* parity error */
#define STMERROR   (STMBREAK | STMFRAME | STMPARITY)
#define STMBREAKH   0x800      /* BREAK */
#define STMFRAMEH   0x400      /* framing error */
#define STMRCVROVRH 0x200      /* receiver over run error */
#define STMPARITYH  0x100      /* parity error */
#define STMERRORH   (STMBREAKH | STMFRAMEH | STMPARITYH)
/* channel status register low byte */
#define CTS_ACT   0x20        /* CTS input asserted */
#define DSR_ACT   0x10        /* DSR input asserted */
#define CD_ACT    0x08        /* CD input asserted */
#define TXFIFOMT  0x04        /* Tx FIFO is empty */
#define TXSHRMT   0x02        /* Tx shift register is empty */
#define RDA       0x01        /* Rx data available */
#define DRAINED (TXFIFOMT | TXSHRMT)  /* indicates Tx is drained */

/* channel status register high byte */
#define STATMODE  0x8000      /* status mode enable bit */
#define RXFOVERFL 0x2000      /* receive FIFO overflow */
#define RX2MATCH  0x1000      /* receive compare byte 2 match */
#define RX1MATCH  0x0800      /* receive compare byte 1 match */
#define RXBREAK   0x0400      /* received BREAK */
#define RXFRAME   0x0200      /* received framing error */
#define RXPARITY  0x0100      /* received parity error */
#define STATERROR (RXBREAK | RXFRAME | RXPARITY)
/* transmit control register low byte */
#define CTSFC_EN  0x80        /* CTS flow control enable bit */

/////////////////NEW////////////////////////////
#define DSRFC_EN  0x01        /* DSR flow control enable bit */
////////////////////////////////////////////////////////

#define RTSTOG_EN 0x40        /* RTS toggle enable bit */
#define TXINT_EN  0x10        /* transmit interrupt enable */
#define STOP2     0x08        /* enable 2 stop bits (0 = 1 stop) */
#define PARITY_EN 0x04        /* enable parity (0 = no parity) */
#define EVEN_PAR  0x02        /* even parity (0 = odd parity) */
#define DATA8BIT  0x01        /* 8 bit data (0 = 7 bit data) */
/* transmit control register high byte */
#define SETBREAK  0x10        /* send break condition (must clear) */
#define LOCALLOOP 0x08        /* local loopback set for test */
#define SET_DTR   0x04        /* assert DTR */
#define SET_RTS   0x02        /* assert RTS */
#define TX_ENABLE 0x01        /* enable transmitter */

/* receive control register */
#define RTSFC_EN  0x40        /* RTS flow control enable */
#define RXPROC_EN 0x20        /* receive processor enable */
#define TRIG_NO   0x00        /* Rx FIFO trigger level 0 (no trigger) */
#define TRIG_1    0x08        /* trigger level 1 char */
#define TRIG_1_2  0x10        /* trigger level 1/2 */
#define TRIG_7_8  0x18        /* trigger level 7/8 */
#define TRIG_MASK 0x18        /* trigger level mask */
#define SRCINT_EN 0x04        /* special Rx condition interrupt enable */
#define RXINT_EN  0x02        /* Rx interrupt enable */
#define MCINT_EN  0x01        /* modem change interrupt enable */

/* interrupt ID register */
#define RXF_TRIG  0x20        /* Rx FIFO trigger level interrupt */
#define TXFIFO_MT 0x10        /* Tx FIFO empty interrupt */
#define SRC_INT   0x08        /* special receive condition interrupt */
#define DELTA_CD  0x04        /* CD change interrupt */
#define DELTA_CTS 0x02        /* CTS change interrupt */
#define DELTA_DSR 0x01        /* DSR change interrupt */

/* Tx processor enables register */
#define REP1W2_EN 0x10        /* replace byte 1 with 2 bytes enable */
#define IGN2_EN   0x08        /* ignore byte 2 enable */
#define IGN1_EN   0x04        /* ignore byte 1 enable */
#define COMP2_EN  0x02        /* compare byte 2 enable */
#define COMP1_EN  0x01        /* compare byte 1 enable */

/* AIOP command register */
#define RESET_ALL 0x80        /* reset AIOP (all channels) */
#define TXOVERIDE 0x40        /* Transmit software off override */
#define RESETUART 0x20        /* reset channel's UART */
#define RESTXFCNT 0x10        /* reset channel's Tx FIFO count register */
#define RESRXFCNT 0x08        /* reset channel's Rx FIFO count register */
/* bits 2-0 indicate channel to operate upon */

/************************************************************************
   MUDBAC register defines
************************************************************************/
/* base + 1 */
#define INTSTAT0  0x01        /* AIOP 0 interrupt status */
#define INTSTAT1  0x02        /* AIOP 1 interrupt status */
#define INTSTAT2  0x04        /* AIOP 2 interrupt status */
#define INTSTAT3  0x08        /* AIOP 3 interrupt status */
/* base + 2 */
/* irq selections here tps */
#define INTR_EN   0x08        /* allow interrupts to host */
#define INT_STROB 0x04        /* strobe and clear interrupt line (EOI) */
/* base + 3 */
#define CHAN3_EN  0x08        /* enable AIOP 3 */
#define CHAN2_EN  0x04        /* enable AIOP 2 */
#define CHAN1_EN  0x02        /* enable AIOP 1 */
#define CHAN0_EN  0x01        /* enable AIOP 0 */
#define FREQ_DIS  0x00
#define FREQ_560HZ 0x70
#define FREQ_274HZ 0x60
#define FREQ_137HZ 0x50
#define FREQ_69HZ  0x40
#define FREQ_34HZ  0x30
#define FREQ_17HZ  0x20
#define FREQ_9HZ   0x10
#define PERIODIC_ONLY 0x80    /* only PERIODIC interrupt */

/************************************************************************
   MUDBAC registers re-maped for PCI
************************************************************************/
//#define _CFG_INT_PCI 0x40         /*offset for interupt config register */
#define _PCI_INT_FUNC 0x3A        /*offset for interupt stat register on aiop 0*/
#define INTR_EN_PCI 0x0010          /*Bit 4 of int config reg */
#define PCI_PERIODIC_FREQ     0x0007    // setup periodic
#define PER_ONLY_PCI 0x0008         /*bit 3 of int config reg */
#define PCI_AIOPIC_INT_STATUS 0x0f    // 1bit=Aiop1, 2bit=Aiop2,etc
#define PCI_PER_INT_STATUS    0x10    // interrupt status from board
#define PCI_STROBE 0x2000           /*bit 13 of int aiop reg */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\debuger.c ===
/*----------------------------------------------------------------------------
| debuger.c -
|----------------------------------------------------------------------------*/
#include "precomp.h"

void read_in_queue(char *str);
void reset_box(void);
void reset_port(void);
void reset_modem(void);
void dump_driver(void);
void dump_mem(UCHAR *ptr, ULONG len);
void dump_net(void);
void send_str(char *str);
void dump_ext1(void);
void no_port_message(void);
#ifdef S_VS
void eth_test_pkt(void);
void dump_box(int index);
void dump_nic(int index);
int read_trace_queue(PortMan *pm);
int write_remote_cmd(PortMan *pm, char *cmd);
#endif

#define TraceStr(s) GTrace(D_L10, sz_modid, s)
#define TraceErr(s) GTrace(D_Error, sz_modid_err, s)
#define TraceC(c)   GMark(c,10)

static char *sz_modid = {"deb"};
static char *sz_modid_err = {"Error,deb"};

// following used to restrict to one pending debug packet to box
static int pending_debug_packet = 0;

/*----------------------------------------------------------------------------
| do_cmd_line - complete line entered, handle command line interpreter.
|----------------------------------------------------------------------------*/
void do_cmd_line(char *line)
{
 char *s = line;
 int i, j, k;
 char cmd[20];  // buffer for command only, not for params
 //char str2[20];
 ULONG dnums[5];
 PSERIAL_DEVICE_EXTENSION ext;

  i = strlen(s);
  if (i==0)
    return;

  if (s[i-1] == 0xd)
  {
    s[i-1] = 0;
    if (i == 0)
      deb_printf("\x0d\x0a:");
  }

  while ((*s == ' ') || (*s == 0xa))
    ++s;
  if (*s == 0)
  {
    deb_printf("\x0d\x0a:");
    return;
  }

  deb_printf(":%s\x0d\x0a", s);  // echo cmd line
  i = 0;
  while ((*s != ' ') && (*s != 0)  && (*s != ',') && (i < 8))
  {
    cmd[i++] = (char)my_toupper(*s);
    ++s;
  }
  cmd[i] = 0;

  while (*s == ' ')
    ++s;

  dnums[0] = 0;
  dnums[1] = 0;
  dnums[2] = 0;
  i = getnumbers(s, (long *)dnums, 4, 1);  // get max of 4 hex dword numbers

  Driver.DebugTimeOut = 1000;  // about 600 second seconds timeout
  switch (cmd[0])
  {
   case 'B':  // b - box selection to debug
#ifdef S_VS
#if 0
     if (*s != 0)
     {
       write_remote_cmd(&Driver.pm[0], s);
     }
     else
     {
       read_trace_queue(&Driver.pm[0]);
     }
#endif
#endif
   break;

   case 'D':  // d - dump memory
      getstr(cmd, s, &j, 16);
      if (my_lstricmp(cmd, "ext") == 0)
        dump_mem((UCHAR *)Driver.DebugExt,
                  sizeof(*Driver.DebugExt));  // dump memory
      else if (my_lstricmp(cmd, "RxBuf") == 0)
      {
        k = Driver.DebugExt->RxQ.QPut;
        dump_mem((UCHAR *)&Driver.DebugExt->RxQ.QBase[0], 0x200);  // dump memory
      }
      else if (my_lstricmp(cmd, "port") == 0)
      {
#ifdef S_VS
        dump_mem((UCHAR *)Driver.DebugExt->Port, 
                  sizeof(*Driver.DebugExt->Port));  // dump memory
#else
        dump_mem((UCHAR *)Driver.DebugExt->ChP, 
                  sizeof(*Driver.DebugExt->ChP));  // dump memory
#endif
      }
      else if (my_lstricmp(cmd, "driver") == 0)
      {
        dump_driver();
      }
      else if (i == 1)  // 1 number
        dump_mem((UCHAR *)dnums[0], 0x100);  // dump memory
    break;

    case 'E': // EXIT
      if (my_lstricmp(cmd, "EXIT") == 0)
        debug_all_off();
    break;

    case 'I': // iw
      if (cmd[1] == 'W')
      {
        dnums[1] = READ_PORT_USHORT((PUSHORT) dnums[0]);
        deb_printf("iw[%x] = %x\n", dnums[0], dnums[1]);
      }
      else if (cmd[1] == ' ')
      {
        dnums[1] = READ_PORT_UCHAR((PUCHAR) dnums[0]);
        deb_printf("i[%x] = %x\n", dnums[0], dnums[1]);
      }

    case 'L': //  L
        Driver.load_testing = dnums[0];
        deb_printf("test load = %d\n", Driver.load_testing);
    break;

    case 'M': //  M
      if (my_lstricmp(cmd, "M") == 0)  //  MON  {RX | TX | EV}
      {
        Driver.GTraceFlags = D_Error;
        debug_all_off();
        break;
      }

      if (my_lstricmp(cmd, "MONG") == 0)  //  MONG {0,1,2,3,4...}
      {
        if (dnums[0] == 0)
             Driver.GTraceFlags = D_Error | D_Init;
        else Driver.GTraceFlags |= (1 << dnums[0]);
        break;
      }

      if (Driver.DebugExt == NULL)
      {
        no_port_message();
        break;
      }

      if (my_lstricmp(cmd, "MON") == 0)  //  MON  {RX | TX | EV}
      {

        getstr(cmd, s, &j, 16);
        if (my_lstricmp(cmd, "rx") == 0)
        {
          Driver.DebugExt->TraceOptions |= 2;
          Driver.TraceOptions |= 2;
        }
        else if (my_lstricmp(cmd, "off") == 0)
        {
          Driver.DebugExt->TraceOptions = 0;
          Driver.TraceOptions = 0;
        }
        else if (my_lstricmp(cmd, "tx") == 0)
        {
          Driver.DebugExt->TraceOptions |= 4;
          Driver.TraceOptions |= 4;
        }
        else if (my_lstricmp(cmd, "ev") == 0)
        {
          Driver.DebugExt->TraceOptions |= 1;
          Driver.TraceOptions |= 1;
        }
        else if (my_lstricmp(cmd, "irq") == 0)
        {
          Driver.DebugExt->TraceOptions |= 8;
          Driver.TraceOptions |= 8;
        }
      }
    break;

#ifdef S_VS    
    case 'N': //  Net
      dump_net();
    break;
#endif

    case 'O':
      if (cmd[1] == 'D')
      {
        WRITE_PORT_ULONG((PULONG) dnums[0], (ULONG) dnums[1]);
        deb_printf("od[%x] = %x\n", dnums[0], dnums[1]);
      }
      else if (cmd[1] == 'W')
      {
        WRITE_PORT_USHORT((PUSHORT) dnums[0], (USHORT) dnums[1]);
        deb_printf("ow[%x] = %x\n", dnums[0], dnums[1]);
      }
      else if (cmd[1] == ' ')
      {
        WRITE_PORT_UCHAR((PUCHAR) dnums[0], (UCHAR) dnums[1]);
        deb_printf("o[%x] = %x\n", dnums[0], dnums[1]);
      }
    break;

     case 'P': //  PORT name
      debug_all_off();

      getstr(cmd, s, &j, 10);
      deb_printf("Port - %s\n", cmd);

      ext = find_ext_by_name(cmd, NULL);
      Driver.DebugExt = ext;
      if (ext != NULL)
           deb_printf("Found port.\n");
      else deb_printf("Not Found!!!\n");
    break;

    case 'R': //  RESET PORT
      if (Driver.DebugExt == NULL)
      {
        no_port_message();
        break;
      }

      if (my_lstricmp(cmd, "RESET") == 0)
      {
        getstr(cmd, s, &j, 16);
        if (my_lstricmp(cmd, "port") == 0)
          reset_port();

        if (my_lstricmp(cmd, "modem") == 0)
          reset_modem();

#ifdef S_VS
        if (my_lstricmp(cmd, "box") == 0)
          reset_box();
#endif
      }
    break;

    case 'S': //  STAT
#ifdef S_VS
      if (my_lstricmp(cmd, "SENDE") == 0)
      {
        eth_test_pkt();
        break;
      }
#endif
      if (Driver.DebugExt == NULL)
      {
        no_port_message();
        break;
      }

      if (my_lstricmp(cmd, "STAT") == 0)
      {
        deb_printf("--stats--\n");
          dump_ext1();
      }
      else if (my_lstricmp(cmd, "SEND") == 0)
      {
        send_str(s);
      }
    break;

#ifdef COMMENT_OUT
    case 'T': //  timer
      if (my_lstricmp(cmd, "timer") == 0)
      {
        LARGE_INTEGER t1,t2;
        our_assert(123, 0);
        t1 = KeQueryPerformanceCounter(NULL);
        deb_printf("Low:%x High:%x\n", Driver.PollIntervalTime.LowPart,
                   Driver.PollIntervalTime.HighPart);
        t2 = KeQueryPerformanceCounter(NULL);
        deb_printf("L2:%x L1:%x H2:%x H1:%x\n", t2.LowPart, t1.LowPart,
                   t2.HighPart, t1.HighPart);
      }
    break;
#endif

    default:
      deb_printf("Driver Version:%s\n", VER_PRODUCTVERSION_STR);
      deb_printf("? - This help.\n");
      deb_printf("PORT COM# - set the port to work on.\n");
      deb_printf("D {ext | chp | rxbuf | driver}  - Dump structure.\n");
      deb_printf("STAT - Dump key info.\n");
      deb_printf("SEND string - Send string out port.\n");
#ifdef S_VS
      //deb_printf("SENDE - Send a test ethernet pkt.\n");
      //deb_printf("RESET {PORT | BOX} - Reset Port or device.\n");
#endif
      deb_printf("M - Turn event/data monitor off.\n");
#ifdef S_VS    
      deb_printf("NET - Dump network statistics.\n");
#endif
      deb_printf("MON {EV | TX | RX} - monitor events, rx-data or tx-data\n");
#ifdef S_VS
      deb_printf("MONG {0,1,...10} - monitor stack 1=nic 3=hdlc 5=port\n");
      deb_printf("RESET modem - Reset VS2000 modem(on selected port).\n");
#endif
    break;
  }

  deb_printf("\x0d\x0a:");
}

#ifdef S_VS
/*----------------------------------------------------------------------------
| eth_test_pkt -
|----------------------------------------------------------------------------*/
void eth_test_pkt(void)
{
 BYTE buf[80];
 int stat, len;
 static BYTE cnt;
 Nic *nic;

  nic = Driver.board_ext->pm->nic;
  if (nic == NULL)
  {
    Tprintf("Null Nic!");
    return;
  }
  len = 64;
  //memset(&buf[0], 0xff, 6);
  memcpy(&buf[0], Driver.board_ext->hd->dest_addr, 6);
  memcpy(&buf[6], nic->address, 6);  // our addr

  // BYTE 12-13: Comtrol PCI ID  (11H, FEH), Ethernet Len field
  *((WORD *)&buf[12]) = 0xfe11;

  buf[14] = ASYNC_PRODUCT_HEADER_ID;  // comtrol packet type = driver management, any product.
  buf[15] = 0;     // conc. index field
  buf[16] = 1;     // admin
  *((WORD *)&buf[17]) = len;
  buf[19] = 0x70;     // ADMIN packet type, 1=boot-loader, 3=id-reply
  buf[20] = cnt++;

  stat = nic_send_pkt(nic, buf, len);
  if (stat)
  {
    deb_printf("Error sending.\x0d\x0a:");
  }
  else deb_printf("Sent.\x0d\x0a:");
}
#endif

/*----------------------------------------------------------------------------
| bad_cmd_message -
|----------------------------------------------------------------------------*/
void bad_cmd_message(void)
{
  deb_printf("Unknown command!");
}

/*----------------------------------------------------------------------------
| no_port_message -
|----------------------------------------------------------------------------*/
void no_port_message(void)
{
  deb_printf("Use PORT com# to setup a port to monitor!");
}

/*----------------------------------------------------------------------------
| read_in_queue -
|----------------------------------------------------------------------------*/
void read_in_queue(char *str)
{
 int j,k;
 PSERIAL_DEVICE_EXTENSION ext;

  ext = Driver.DebugExt;

  k = getint(str, &j);
  if (j==0)  // got a number
  {
//    dump_mem(UCHAR *ptr, ULONG len);
      deb_printf("read %d!\n", k);
  }
}

/*----------------------------------------------------------------------------
| debug_poll - used to timeout inactive debug session and turn off any
|   tracing which might be active.  Called roughly every 6 seconds.
|----------------------------------------------------------------------------*/
void debug_poll(void)
{
  if (Driver.DebugTimeOut == 0)  // used to timeout inactive debug sessions.
    return;
  --Driver.DebugTimeOut;

  if (Driver.DebugTimeOut == 0)  // used to timeout inactive debug sessions.
  {
    debug_all_off();
  }
}

/*----------------------------------------------------------------------------
| debug_all_off - 
|----------------------------------------------------------------------------*/
void debug_all_off(void)
{
#ifdef S_VS
 int Dev;
#endif

  PSERIAL_DEVICE_EXTENSION ext;
  PSERIAL_DEVICE_EXTENSION board_ext;

  // Driver.DebugExt = NULL;
  Driver.TraceOptions = 0;

  board_ext = Driver.board_ext;
  while (board_ext)
  {
    ext = board_ext->port_ext;
    while (ext)
    {
      ext->TraceOptions = 0;
      ext = ext->port_ext;  // next in chain
    }  // while port extension
    board_ext = board_ext->board_ext;
  }  // while board extension
}

#ifdef S_VS
/*----------------------------------------------------------------------------
| reset_box -
|----------------------------------------------------------------------------*/
void reset_box(void)
{
  PSERIAL_DEVICE_EXTENSION ext;

  ext = Driver.board_ext;
  while (ext)
  {
    ext->pm->state = ST_INIT;
    ext = ext->board_ext;
  }
}
#endif

/*----------------------------------------------------------------------------
| reset_modem - Reset Port Modem Hardware
|----------------------------------------------------------------------------*/
void reset_modem(void)
{
  PSERIAL_DEVICE_EXTENSION ext = Driver.DebugExt;

  if (ext == NULL)
    return;

#ifdef S_VS
  pModemReset(ext->Port);
#endif
}

/*----------------------------------------------------------------------------
| reset_port - Reset Port Hardware(assume modem on with RTS/CTS flow ctrl)
|----------------------------------------------------------------------------*/
void reset_port(void)
{
  PSERIAL_DEVICE_EXTENSION ext = Driver.DebugExt;

  if (ext == NULL)
    return;

#ifndef S_VS
   sFlushTxFIFO(ext->ChP);
   sFlushRxFIFO(ext->ChP);

   // Disable all Tx and Rx functions
   sDisTransmit(ext->ChP);
   sDisRxFIFO(ext->ChP);
   sDisRTSFlowCtl(ext->ChP);
   sDisCTSFlowCtl(ext->ChP);
   sDisRTSToggle(ext->ChP);
   sClrBreak(ext->ChP);

   // Drop the modem outputs
   // Takes care of DTR flow control as well
   sClrRTS(ext->ChP);
   sClrDTR(ext->ChP);

   //---- wait, give time for user to see this reset
   time_stall(10);  // wait 1 second

   ProgramBaudRate(ext, ext->BaudRate);

   // Enable Rx, Tx and interrupts for the channel
   sEnRxFIFO(ext->ChP);    // Enable Rx
   sEnTransmit(ext->ChP);    // Enable Tx
   sSetRxTrigger(ext->ChP,TRIG_1);  // always trigger
   sEnInterrupts(ext->ChP, ext->IntEnables); // allow interrupts

   sEnRTSFlowCtl(ext->ChP);
   sEnCTSFlowCtl(ext->ChP);
   sSetDTR(ext->ChP);
#endif
}

/*----------------------------------------------------------------------------
| send_str - Dump extension data
|----------------------------------------------------------------------------*/
void send_str(char *str)
{
  PSERIAL_DEVICE_EXTENSION ext = Driver.DebugExt;
  ULONG i;

  if (ext == NULL)
    return;

  strcat(str, "\x0d\x0a");  // modems like CR,LF
#ifdef S_VS
  i = q_put(&ext->Port->QOut, str, strlen(str));
#else
  i = sWriteTxBlk(ext->ChP, str, strlen(str));
#endif
  deb_printf("%d bytes sent\n", i);
}

/*----------------------------------------------------------------------------
| dump_driver - Dump driver status
|----------------------------------------------------------------------------*/
void dump_driver(void)
{
  deb_printf("DRIVER, PollCnt:%d, PollStop:%d\n",
             Driver.PollCnt, Driver.Stop_Poll);

  deb_printf(" MemAlloced:%d\n", Driver.mem_alloced);

#ifdef S_VS
  deb_printf(" Tick100usBase:%d\n", Driver.Tick100usBase);
#endif
}

#ifdef S_VS
/*----------------------------------------------------------------------------
| dump_box - Dump box status
|----------------------------------------------------------------------------*/
void dump_box(int index)
{
 PortMan *pm;
 Hdlc *hd;
 int i;
 PSERIAL_DEVICE_EXTENSION ext;

  i = 0;
  ext = Driver.board_ext;
  while (ext != NULL)
  {
    if ((index == i) || (index == 10000))
    {
      pm = ext->pm;
      hd = ext->hd;
      deb_printf("BOX, Index:%d, Nic:%d Ports:%d\n",
                 i, pm->nic_index, pm->num_ports);

    if(pm->backup_server)
      deb_printf(" Backup Server: Timeout:%d min Current Time:%d min/%d tic\n", 
        pm->backup_timer, (pm->load_timer/6000), pm->load_timer);
    else
      deb_printf(" Designated as Primary Server\n");

      deb_printf(" State:%s Reload Errors:%d Timer:%d\n",
                 port_state_str[pm->state],
                 pm->reload_errors, pm->state_timer);

      deb_printf(" MAC:%x %x %x %x %x %x\n",
                  hd->dest_addr[0], hd->dest_addr[1], hd->dest_addr[2],
                  hd->dest_addr[3], hd->dest_addr[4], hd->dest_addr[5]);

      deb_printf("Hdlc Status:\n");
      //----- circular que of outgoing data packets
#if DBG
      deb_printf(" qout.QBase:%x", hd->qout.QBase);  // our packet buffer circular queue
      deb_printf(" Pkt Cnt:%d Put:%d Get:%d\n",
                  q_count(&hd->qout), hd->qout.QPut, hd->qout.QGet);
#endif
      deb_printf(" Pkt Sends:%d ReSends:%d", hd->iframes_sent, hd->iframes_resent);
      deb_printf(" Timeouts, RAck:%d SAck:%d", hd->rec_ack_timeouts,
                   hd->send_ack_timeouts);

      deb_printf(" status:%x\n", hd->status);
#if DBG
      deb_printf(" HDLC: V(s):%x V(r):%x NextIn:%x\n",
                   hd->out_snd_index, hd->in_ack_index, hd->next_in_index);
      deb_printf("  UnAcked:%x TxAckTimer:%x RxAckTimer:%x\n",
                    hd->unacked_pkts, hd->sender_ack_timer, hd->rec_ack_timer);
#endif
      deb_printf("  Window pkt size:%d\n", hd->pkt_window_size);
      deb_printf("  Errors OurOfSeq:%d\n",
                    hd->iframes_outofseq);
      deb_printf("\n");
    }
    ext = ext->board_ext; // next one
    ++i;
  }
}

/*----------------------------------------------------------------------------
| dump_nic - Dump nic status
|----------------------------------------------------------------------------*/
void dump_nic(int index)
{
 Nic *nic;
 int i;

  for (i=0; i<VS1000_MAX_NICS; i++)
  {
    if ((index == i) || (index == 10000))
    {
      if (Driver.nics[i].Open)
      {
        nic = &Driver.nics[i];
        deb_printf("NIC, Name[%d]=%s\n",i, nic->NicName);

        deb_printf(" MAC:%x %x %x %x %x %x\n",
           nic->address[0],nic->address[1],nic->address[2],
           nic->address[3],nic->address[4],nic->address[5]);

        deb_printf(" Packets Rcvd: Ours:%d NotOurs:%d Pend:%d NonPend:%d",
                   nic->pkt_rcvd_ours,
                   nic->pkt_rcvd_not_ours,
                   nic->RxPendingMoves,
                   nic->RxNonPendingMoves);

        deb_printf(" OvrFlows:%d  Rcvd Bytes:%d\n",
                   nic->pkt_overflows, nic->rec_bytes);

        deb_printf(" Packets Sent: Pkts:%d Bytes:%d\n", nic->pkt_sent,
                   nic->send_bytes);
      }  // open
      deb_printf("\n");
    }
  }
}

/*----------------------------------------------------------------------------
| dump_net - Dump network status
|----------------------------------------------------------------------------*/
void dump_net(void)
{
 PSERIAL_DEVICE_EXTENSION ext = Driver.board_ext;
 int num_devs = 0;

 while (ext != NULL)
 {
#if DBG
   //write_device_options(ext);
#endif
   ext = ext->board_ext;
   ++num_devs;
 }
 deb_printf("ScanRate:%d, Base:%d\n", Driver.ScanRate, Driver.Tick100usBase);

 deb_printf("----Num Devices:%d\n", num_devs);

 deb_printf("    threadHandle: %x, threadCount:%d\n",
             Driver.threadHandle, Driver.threadCount);
 dump_nic(10000);  // dump all nic card data;
 dump_box(10000);  // dump all box data;
}
#endif

/*----------------------------------------------------------------------------
| dump_ext1 - Dump extension data
|----------------------------------------------------------------------------*/
void dump_ext1(void)
{
// int i;
 PSERIAL_DEVICE_EXTENSION ext = Driver.DebugExt;

  if (ext == NULL)
    return;

  deb_printf("%s, BaudRate:%d Open:%d\n", ext->SymbolicLinkName,
              ext->BaudRate, ext->DeviceIsOpen);
  if (ext->port_config->LockBaud != 0)
    deb_printf(" LockBaud:%d\n", ext->port_config->LockBaud);

  deb_printf("ModemStatus:%xH DTRRTS:%xH\n", ext->ModemStatus, ext->DTRRTSStatus);

#ifdef NEW_Q
  {
#ifdef S_VS
  LONG tx_remote;
#endif
  LONG rx_buf = 0;
  if (ext->DeviceIsOpen)
    rx_buf = q_count(&ext->RxQ);
#ifdef S_VS
  tx_remote = PortGetTxCntRemote(ext->Port);
  deb_printf("IRP TxCnt:%d TxBufCnt:%d TxRemoteCnt:%d  BufRxCnt:%d\n",
     ext->TotalCharsQueued,
     PortGetTxCnt(ext->Port),
     tx_remote, rx_buf);
  deb_printf(" (nPutRemote:%d, nGetRemote:%d, nGetLocal:%d)\n",
         ext->Port->nPutRemote,
         ext->Port->nGetRemote,
         ext->Port->nGetLocal);
#else
  deb_printf("TxIRP_Cnt:%d TxBoardCnt:%d  RxBufCnt:%d RxBoardCnt:%d\n",
     ext->TotalCharsQueued,
     sGetTxCnt(ext->ChP),
     rx_buf,
     sGetRxCnt(ext->ChP));
#endif
  }

#else
  // old-q-tracking code.....
  deb_printf("RxPut:%d RxGet:%d RxSize:%d RxBufAddr:%xH\n",
     ext->RxQ.QPut, ext->RxQ.QGet, ext->RxQ.QSize, ext->RxQ.QBase);

#ifndef S_VS
  deb_printf("BoardTxCnt:%d BoardRxCnt:%d\n",
     sGetTxCnt(ext->ChP), sGetRxCnt(ext->ChP));
#endif

#endif

  deb_printf("Stats - RxTot:%u TxTot:%u\n",
    ext->OurStats.ReceivedCount,
    ext->OurStats.TransmittedCount);

  deb_printf("Errors - Parity:%d Frame:%d Buf Overflow:%d Hardware Overflow:%d\n",
    ext->OurStats.ParityErrorCount,
    ext->OurStats.FrameErrorCount,
    ext->OurStats.BufferOverrunErrorCount,
    ext->OurStats.SerialOverrunErrorCount);

  deb_printf("Stats - Writes:%u Reads:%u\n", ext->sent_packets, ext->rec_packets);

  deb_printf("IRPs -");
  //------
  if ( (!IsListEmpty(&ext->WriteQueue))  // no queued up output data
     || (ext->CurrentWriteIrp) )
    deb_printf("WrIRP:");
  if (!IsListEmpty(&ext->WriteQueue))  // no queued up output data
    deb_printf("Q");
  if (ext->CurrentWriteIrp)
    deb_printf("C");


  //------
  if ( (!IsListEmpty(&ext->ReadQueue))  // no queued up output data
     || (ext->CurrentReadIrp) )
    deb_printf(" RdIRP:");

  if (!IsListEmpty(&ext->ReadQueue))  // no queued up output data
    deb_printf("Q");
  if (ext->CurrentReadIrp)
    deb_printf("C");
  
  //------
  //if ( (!IsListEmpty(&ext->MaskQueue))  // no queued up output data
  //   || (ext->CurrentMaskIrp) )
  //  deb_printf(" MaskIRP:");

  //if (!IsListEmpty(&ext->MaskQueue))  // no queued up output data
  //  deb_printf("Q");
  //if (ext->CurrentMaskIrp)
  // deb_printf("C");

  //------
  if (ext->CurrentWaitIrp)
    deb_printf(" WaitIRP:C");

  //------
  if ( (!IsListEmpty(&ext->PurgeQueue))  // no queued up output data
    || (ext->CurrentPurgeIrp))
    deb_printf(" PurgeIRP:");

  if (!IsListEmpty(&ext->PurgeQueue))  // no queued up output data
    deb_printf("Q");
  if (ext->CurrentPurgeIrp)
    deb_printf("C");

  deb_printf("\n");
  //------

  if ((ext->WriteLength) ||
       (ext->NumberNeededForRead))
  {
    deb_printf("WrLen:%x, ReadLeft:%x\n",
      ext->WriteLength,
      ext->NumberNeededForRead);
  }

  if (ext->IsrWaitMask ||  ext->HistoryMask || ext->WaitIsISRs)
  {
    deb_printf("WaitMask:%x HistMask:%x MaskLoc:%x\n",
      ext->IsrWaitMask,
      ext->HistoryMask,
      ext->IrpMaskLocation);

    if (ext->IsrWaitMask & 2)  // RXFLAG(event-char)
      deb_printf("Event Char:%xH\n",
         ext->SpecialChars.EventChar);
  }

  if (ext->TXHolding || ext->RXHolding || ext->ErrorWord)
    deb_printf("TXHolding:%x RXHolding:%x ErrorW:%x\n",
      ext->TXHolding,
      ext->RXHolding,
      ext->ErrorWord);

  if (ext->TotalCharsQueued)
    deb_printf("TotalTX:%x\n",
      ext->TotalCharsQueued);
#ifdef S_VS
  deb_printf("%s ExtAddr:%xH(size:%xH)\n",
             ext->SymbolicLinkName,
             ext, sizeof(*ext));
#else
  deb_printf("%s ExtAddr:%xH(size:%xH)  ChnAddr:%xH(size:%xH)\n",
             ext->SymbolicLinkName, ext, sizeof(*ext),
             ext->ChP, sizeof(*ext->ChP));
#endif
}

/*----------------------------------------------------------------------------
| dump_mem - Dump memory to debug channel.
|----------------------------------------------------------------------------*/
void dump_mem(UCHAR *ptr, ULONG len)
{
 unsigned char binbuf[17];
 char tmpstr[60];
 int j,i;
 ULONG off = 0;

  if (ptr == NULL)
  {
    deb_printf("Null\n");
    return;
  }

  if (MmIsAddressValid(ptr) == FALSE)
  {
    deb_printf("Not valid\n");
    return;
  }

  if (len > 0x500) len = 0x500;

  while (len > 0)
  {
    j = 16;
    if (len < 16)
      j = len;

    deb_printf("%08x> ", (ULONG)ptr + off);
    for (i=0; i<j; i++)
    {
      binbuf[i] = ptr[i+off];
      Sprintf(tmpstr, "%02x ", binbuf[i]);
      if ((i % 16) == 7)
        strcat(tmpstr,"- ");
      deb_printf(tmpstr);

      if ((binbuf[i] < 0x20) || (binbuf[i] >= 0x80))
        binbuf[i] = '.';
      else if (binbuf[i] == '\\')
        binbuf[i] = '.';
      else if (binbuf[i] == '%')
        binbuf[i] = '.';
    }
    off += 16;
    binbuf[i] = 0;
    Sprintf(tmpstr, "%s\x0d\x0a", binbuf);
    deb_printf(tmpstr);
    len -= j;
  }
}

/*---------------------------------------------------------------------------
| deb_printf - uart printf.
|---------------------------------------------------------------------------*/
void __cdecl deb_printf(char *format, ...)
{
  va_list next;
  int len;
 static char buf[120];

  va_start(next, format);
  our_vsnprintf(buf, 118, format, next);

  len = strlen(buf);
  if (len > 0)  //--- convert "\n" to a CR,LF
  {
    if (buf[len-1] == 0xa)
    {
      buf[len-1] = 0xd;
      buf[len] = 0xa;
      buf[len+1] = 0;
      ++len;
    }
  }

  //----- log it into our debug Q
  q_put(&Driver.DebugQ, (BYTE *) buf, len);
}

#ifdef S_VS
#if 0
/*---------------------------------------------------------------------------
| write_remote_cmd - Write remote trace debug command. 
   This is experimental code to read box traces, not in working order.
|---------------------------------------------------------------------------*/
int write_remote_cmd(PortMan *pm, char *cmd)
{
 int stat;
 BYTE *buf;
 BYTE cmd_buf[60];
 BYTE *tx_base;

  TraceStr("writeTrace");

  strcpy(cmd_buf, cmd);
  cmd_buf[0x3f] = 1;  // new-command flag

  hdlc_get_ctl_outpkt(pm->hd, &buf);
  if (buf == NULL)
    return 1;
  tx_base = buf - 20;  // backup to start of pkt

  stat = ioctl_device(UPLOAD_COMMAND,
                      (BYTE *) cmd_buf,
                      buf,
                      0x400L,  // offset into memory
                      0x40);   // num bytes of data
  // setup header
  tx_base[14] = ASYNC_PRODUCT_HEADER_ID;  // comtrol packet type = driver management, any product.
  tx_base[15] = 0;     // conc. index field
  tx_base[16] = 1;     // admin
  *((WORD *)&tx_base[17]) = 0x80;
  tx_base[19] = 1;     // ADMIN packet type, 1=boot-loader, 3=id-reply

  if (pending_debug_packet)
    time_stall(1);  // wait 1/10th second
  pending_debug_packet = 1;  // flag to tell when response comes in

  // send it.
  stat = hdlc_send_raw(pm->hd, 60, NULL);

  if (stat)
       {TraceErr("Bad send");}

  return 0;
}

/*---------------------------------------------------------------------------
| read_trace_queue - Read remote trace buffer, so we can display any new
   trace data to the screen.  This routine just sends out the query.
   admin.c will get a reply and stuff the incoming data into the
   local trace queue.
   This is experimental code to read box traces, not in working order.
|---------------------------------------------------------------------------*/
int read_trace_queue(PortMan *pm)
{
 int stat;
 BYTE *buf;
 WORD io_buf[60];
 BYTE *tx_base;

  TraceStr("readTrace");

  hdlc_get_ctl_outpkt(pm->hd, &buf);
  if (buf == NULL)
    return 1;
  tx_base = buf - 20;  // backup to start of pkt

  stat = ioctl_device(IOCTL_COMMAND,
                      (BYTE *) io_buf,
                      buf,
                      22,  // 22 = get trace q
                      0);  // num bytes of data
  // setup header
  tx_base[14] = ASYNC_PRODUCT_HEADER_ID;  // comtrol packet type = driver management, any product.
  tx_base[15] = 0;     // conc. index field
  tx_base[16] = 1;     // admin
  *((WORD *)&tx_base[17]) = 40;
  tx_base[19] = 1;     // ADMIN packet type, 1=boot-loader, 3=id-reply

  if (pending_debug_packet)
    time_stall(1);  // wait 1/10th second
  pending_debug_packet = 22;  // flag to tell when response comes in

  // send it.
  stat = hdlc_send_raw(pm->hd, 60, NULL);

  if (stat)
       {TraceErr("Bad send");}

  return 0;
}

/*---------------------------------------------------------------------------
| debug_device_reply - Handle received debug-boot loader ADMIN packets
    from device.
   This is experimental code to read box traces, not in working order.
|---------------------------------------------------------------------------*/
int debug_device_reply(PVOID *void_pm,   // PortMan *pm,
                 unsigned char *data,
                 unsigned char *pkt);
{
  int i;
  unsigned char chksum;
//  unsigned char *bf;
  unsigned char uc;
  WORD ret_size;
  BYTE *bptr;
  BYTE message_type;
  PortMan *pm = (PortMan *)void_pm;

  bptr = data;


  if (bptr[0] != '|')  // good reply header
  {
    deb_printf("dbg:bad hdr\n");
    return 1;
  }

  chksum = bptr[1];
  ret_size = bptr[1];  // get len

  chksum += bptr[2];
  ret_size += ((WORD)(bptr[2]) << 8);  // get len
  if (ret_size > 1600)  // limit
    ret_size = 0;

  uc = bptr[3];  // get command return word
  message_type = uc & 0x7f;  // strip off 80H bit.

  chksum += uc;
  uc = bptr[4];
  chksum += uc;

  i = 0;
  if ((message_type == IOCTL_COMMAND) || (message_type == DOWNLOAD_COMMAND))
  {
    // o_printf("ret size:%d\n", ret_size-2);
    if (data == NULL)
    {
      pending_debug_packet = 0;
      //deb_printf("dbg:no data\n");
      return 20;  // err out
    }

    //bf = data;
    for (i=0; i<ret_size-2; i++)
    {
      //bf[i] = bptr[5+i];
      chksum += bptr[5+i];
    }
    i = ret_size-2;
  }

  chksum += bptr[5+i];
  if (chksum != 0xff)
  {
    deb_printf("dbg:bad chksum\n");
    return 2;  /* bad chksum */
  }

  //if ((message_type == IOCTL_COMMAND) || (message_type == DOWNLOAD_COMMAND))
  //  *num_bytes = ret_size-2;
  //else
  //  *num_bytes = 0;

  if (message_type == IOCTL_COMMAND)
  {
    if (pending_debug_packet == 22)  // flag to tell when response comes in
    {
      if (ret_size > 2)
        TracePut(&bptr[5], ret_size -2);
      deb_printf("dbg:read q\n");
    }
  }
  else
   deb_printf("dbg:set q\n");
  pending_debug_packet = 0;

  return 0;  // ok
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\hdlc.c ===
/*-------------------------------------------------------------------
  hdlc.c - handle LAN communications.  Provide error free transport
 of packets: take care of packet drop detection, retransmition.
 HDLC like services.  Layer 2.

4-27-98 - adjust for scanrate addition.
6-17-97 - change link-integrity check code.
6-17-97 - rewrite sequencing logic, in hdlc_clear_outpkts().

 Copyright 1996,97 Comtrol Corporation.  All rights reserved.  Proprietary
 information not permitted for development or use with non-Comtrol products.
|---------------------------------------------------------------------*/
#include "precomp.h"

//void hdlc_send_ialive(Hdlc *hd);
int hdlc_send_ack_only(Hdlc *hd);
static void hdlc_clear_outpkts(Hdlc *hd);
int hdlc_SendPkt(Hdlc *hd, int pkt_num, int length);
int hdlc_ctl_SendPkt(Hdlc *hd, int pkt_num, int length);

#define Trace1(s,p1) GTrace1(D_Hdlc, sz_modid, s, p1)
#define TraceStr(s) GTrace(D_Hdlc, sz_modid, s)
#define TraceErr(s) GTrace(D_Error, sz_modid_err, s)
static char *sz_modid = {"Hdlc"};
static char *sz_modid_err = {"Error,Hdlc"};

#define DISABLE()
#define ENABLE()

/*--------------------------------------------------------------------------
| hdlc_open -  setup and initialize a LanPort thing.
|--------------------------------------------------------------------------*/
int hdlc_open(Hdlc *hd, BYTE *box_mac_addr)
{
 int i;
 NTSTATUS Status;
 PNDIS_BUFFER    NdisBuffer;

  TraceStr("open");
  if (hd->qout.QBase != NULL)
  {
    MyKdPrint(D_Error, ("HDLC already open!\n"))
    return 0;
  }

  hd->out_snd_index= 0;
  hd->in_ack_index = 0;
  hd->next_in_index = 0;
  hd->rec_ack_timer = 0;
  hd->sender_ack_timer = 0;
  hd->tx_alive_timer = 0;
  hd->rx_alive_timer = 0;
  hd->qout_ctl.QPut = 0;
  hd->qout_ctl.QGet = 0;
  hd->qout_ctl.QSize = 2;  // 2 pkts
  hd->qout.QPut = 0;
  hd->qout.QGet = 0;
  hd->qout.QSize = HDLC_TX_PKT_QUEUE_SIZE;  // number of iframe pkts
  hd->pkt_window_size = HDLC_TX_PKT_QUEUE_SIZE-2;
  memcpy(hd->dest_addr, box_mac_addr, 6);

  // default to the first nic card slot, port state handling and nic
  // packet reception handling dynamically figures this out.
  // we should probably set it to null, but I'm afraid of this right now
#ifdef BREAK_NIC_STUFF
  hd->nic = NULL;
#else
  hd->nic = &Driver.nics[0];
#endif

  // NDIS packets consist of one or more buffer descriptors which point
  // to the actual data.  We send or receive single packets made up of
  // 1 or more buffers.  A MDL is used as a buffer descriptor under NT.

  //---------  Allocate a packet pool for our tx packets
  NdisAllocatePacketPool(&Status, &hd->TxPacketPool, HDLC_TX_PKT_QUEUE_SIZE,
                         sizeof(PVOID));
                         // sizeof(PACKET_RESERVED));
  if (Status != NDIS_STATUS_SUCCESS)
  {
    hdlc_close(hd);
    return 4;
  }

  //---------  Allocate a buffer pool for our tx packets
  // we will only use 1 buffer per packet.
  NdisAllocateBufferPool(&Status, &hd->TxBufferPool, HDLC_TX_PKT_QUEUE_SIZE);
  if (Status != NDIS_STATUS_SUCCESS)
  {
    hdlc_close(hd);
    return 5;
  }

  //-------- create tx data buffer area
  hd->qout.QBase = our_locked_alloc( MAX_PKT_SIZE * HDLC_TX_PKT_QUEUE_SIZE,"hdTX");

  //-------- form our tx queue packets so they link to our tx buffer area
  for (i=0; i<HDLC_TX_PKT_QUEUE_SIZE; i++)
  {
    // Get a packet from the pool
    NdisAllocatePacket(&Status, &hd->TxPackets[i], hd->TxPacketPool);
    if (Status != NDIS_STATUS_SUCCESS)
    {
      hdlc_close(hd);
      return 8;
    }
    hd->TxPackets[i]->ProtocolReserved[0] = i;  // mark with our index
    hd->TxPackets[i]->ProtocolReserved[1] = 0;  // free for use

    // get a buffer for the header
    NdisAllocateBuffer(&Status, &NdisBuffer, hd->TxBufferPool,
      &hd->qout.QBase[MAX_PKT_SIZE * i], 1500);
    if (Status != NDIS_STATUS_SUCCESS)
    {
      hdlc_close(hd);
      return 9;
    }
    // we use only one data buffer per packet
    NdisChainBufferAtFront(hd->TxPackets[i], NdisBuffer);
  }

  
  
  //---------  Allocate a packet pool for our tx control packets(2)
  NdisAllocatePacketPool(&Status, &hd->TxCtlPacketPool, 2, sizeof(PVOID));
                         // sizeof(PACKET_RESERVED));
  if (Status != NDIS_STATUS_SUCCESS)
  {
    hdlc_close(hd);
    return 4;
  }

  //---------  Allocate a buffer pool for our tx ctl packets
  // we will only use 1 buffer per packet.
  NdisAllocateBufferPool(&Status, &hd->TxCtlBufferPool, 2);
  if (Status != NDIS_STATUS_SUCCESS)
  {
    hdlc_close(hd);
    return 5;
  }

  //-------- create tx control data buffer area
  hd->qout_ctl.QBase = our_locked_alloc( MAX_PKT_SIZE * 2,"hdct");

  //-------- form our tx queue packets so they link to our tx buffer area
  for (i=0; i<2; i++)
  {
    // Get a packet from the pool
    NdisAllocatePacket(&Status, &hd->TxCtlPackets[i], hd->TxCtlPacketPool);
    if (Status != NDIS_STATUS_SUCCESS)
    {
      hdlc_close(hd);
      return 8;
    }
    hd->TxCtlPackets[i]->ProtocolReserved[0] = i;  // mark with our index
    hd->TxCtlPackets[i]->ProtocolReserved[1] = 0;  // free for use

    // get a buffer for the header
    NdisAllocateBuffer(&Status, &NdisBuffer, hd->TxCtlBufferPool,
      &hd->qout_ctl.QBase[MAX_PKT_SIZE * i], 1500);
    if (Status != NDIS_STATUS_SUCCESS)
    {
      hdlc_close(hd);
      return 9;
    }
    // we use only one data buffer per packet
    NdisChainBufferAtFront(hd->TxCtlPackets[i], NdisBuffer);
  }

  return 0;
}

/*--------------------------------------------------------------------------
| hdlc_close - 
|--------------------------------------------------------------------------*/
int hdlc_close(Hdlc *hd)
{
  TraceStr("close");

  if (hd->TxPacketPool != NULL)
    NdisFreePacketPool(hd->TxPacketPool);
  hd->TxPacketPool = NULL;

  if (hd->TxBufferPool != NULL)
    NdisFreeBufferPool(hd->TxBufferPool);
  hd->TxBufferPool = NULL;

  if (hd->qout.QBase != NULL)
    our_free(hd->qout.QBase, "hdTX");
  hd->qout.QBase = NULL;


  //------- close up the control packet buffers
  if (hd->TxCtlPacketPool != NULL)
    NdisFreePacketPool(hd->TxCtlPacketPool);
  hd->TxCtlPacketPool = NULL;

  if (hd->TxCtlBufferPool != NULL)
    NdisFreeBufferPool(hd->TxCtlBufferPool);
  hd->TxCtlBufferPool = NULL;

  if (hd->qout_ctl.QBase != NULL)
    our_free(hd->qout_ctl.QBase, "hdct");
  hd->qout_ctl.QBase = NULL;

  return 0;
}

/*----------------------------------------------------------------
 hdlc_validate_rx_pkt - Handle "hdlc" like validation of the
  rx packets from our nic driver.
  Handle checking sequence index byte and return an error if packet
  is out of sequence.
|-----------------------------------------------------------------*/
int hdlc_validate_rx_pkt(Hdlc *hd, BYTE *buf)
{
#define CONTROL_HEADER  buf[0]
#define SND_INDEX       buf[1]
#define ACK_INDEX       buf[2]
#define PRODUCT_HEADER  buf[3]

  TraceStr("validate");
  switch (CONTROL_HEADER)
  {
    case 1:  // 1H=unindex
      TraceStr("val,unindexed");
    break;

    case 3:  // 1H=unindex, 2H=sync_init
      //----- use to re-sync up our index count
      // the vs-1000 device will never do this now, only us(the server) will
      TraceStr("RESYNC");
      hdlc_resync(hd);
    return ERR_CONTROL_PACKET;  // control packet, no network data

    case 0:  // normal information frame
    break;
  }

  if ((CONTROL_HEADER & 1) == 0)  // indexed, so validate
  {
    if (hd->rec_ack_timer == 0)
      hd->rec_ack_timer = MIN_ACK_REC_TIME;

        // now check that packet is syncronized in-order
        // make sure we didn't miss a packet
    if (SND_INDEX != ((BYTE)(hd->next_in_index)) )
    {
      ++hd->iframes_outofseq;

      hd->status |= LST_SEND_ACK;  // force an acknowledgement packet

      TraceErr("bad index");
      return ERR_GET_BAD_INDEX;  // error, packet out of sequence
    }
    ++hd->unacked_pkts;  // when to trip acknowledge at 80% full
    if (hd->unacked_pkts > (hd->pkt_window_size - 1))
    {
      hd->status |= LST_SEND_ACK;
      TraceStr("i_ack");
    }

    hd->rx_alive_timer = 0;  // reset this since we have a good rx-active link

    ++hd->next_in_index;  // bump our index count
    TraceStr("iframe OK");

  }  // indexed

   //---- now grab the packet acknowledged index.
  if (hd->in_ack_index != ACK_INDEX)  // only act when changed.
  {
    //--- we can assume this ack-index is a reasonable value
    // since it has gone threw the ethernet checksum.
    hd->in_ack_index = ACK_INDEX;  // update our copy
    hd->status |= LST_RECLAIM;  // perform reclaim operation
  }

  return 0;  // ok
}

/*--------------------------------------------------------------------------
| hdlc_poll - Call at regular interval to handle packet sequencing,
   and packet resending.   Called 20 times per second for DOS,embedded,
   for NT called 100 times per sec.
|--------------------------------------------------------------------------*/
void hdlc_poll(Hdlc *hd)
{
 WORD timer;

  hd->tick_timer += ((WORD) Driver.Tick100usBase);
  if (hd->tick_timer >= 1000)  // 1/10th second
  {
    hd->tick_timer = 0;

                           // every 1/10th second
    ++hd->tx_alive_timer;
    ++hd->rx_alive_timer;
    if ((hd->tx_alive_timer >= KEEP_ALIVE_TIMEOUT) ||  // about 1 min.
        (hd->rx_alive_timer >= KEEP_ALIVE_TIMEOUT))
    {
      // Rx or Tx or both activity has not happened, or com-link
      // failure has occurred, so send out a iframe to see if
      // we are in failure or just a state of non-activity.

      // take the biggest timeout value, so we don't have to do
      // the logic twice for each.
      if (hd->tx_alive_timer > hd->rx_alive_timer)
           timer = hd->tx_alive_timer;
      else timer = hd->rx_alive_timer;

      if (timer == KEEP_ALIVE_TIMEOUT)
      {
        //hdlc_send_ialive(hd); // send out a iframe to get ack back.
        //TraceStr("Snd ialive");
        //----- notify owner to check link
        if (hd->upper_layer_proc != NULL)
          (*hd->upper_layer_proc) (hd->context, EV_L2_CHECK_LINK, 0);
      }
      else if (timer == (KEEP_ALIVE_TIMEOUT * 2))
      {
        // declare a bad connection, bring connection down.
        //----- notify owner that it needs to resync
        if (hd->upper_layer_proc != NULL)
          (*hd->upper_layer_proc) (hd->context, EV_L2_RELOAD, 0);

        TraceErr("ialive fail");

        // make sure everything is cleared out, or reset at our level
        hdlc_resync(hd);
        hd->tx_alive_timer = 0;
        hd->rx_alive_timer = 0;
      }
    }

    if (hd->sender_ack_timer > 0)
    {
      --hd->sender_ack_timer;
      if (hd->sender_ack_timer == 0)
      {
        if (!q_empty(&hd->qout)) // have outpkts waiting for ack.
        {
          TraceStr("Snd timeout");
          ++hd->send_ack_timeouts; // statistics: # of send-ack-timeouts
          hdlc_resend_outpkt(hd); // send it out again!
        }
      }
    }

    if (hd->rec_ack_timer > 0)
    {
      --hd->rec_ack_timer;
      if (hd->rec_ack_timer == 0)  // timeout on rec. packet ack.
      {
        ++hd->rec_ack_timeouts; // statistics: # of rec-ack-timeouts
  
        TraceStr("RecAck timeout");
        if (!q_empty(&hd->qout)) // have outpkts waiting for ack.
          hdlc_resend_outpkt(hd); // send it out again!
        else
        {
          // no iframe packets sent out(piggy back acks on them normally)
          // for REC_ACK_TIME amount, so we have to send out just an
          // acknowledgement packet.
          // arrange for a ack-packet to be sent by setting this bit
          hd->status |= LST_SEND_ACK;
        }
      }
    }
  }  // end of 100ms tick period

  // check if received packets more than 80% of senders capacity, if so
  // send immediate ack.
  if (hd->status & LST_SEND_ACK)
  {
    if (hdlc_send_ack_only(hd) == 0) // ok
    {
      hd->status &= ~LST_SEND_ACK;
      TraceStr("Ack Sent");
    }
    else
    {
      TraceStr("Ack Pkt Busy!");
    }
  }

  if (hd->status & LST_RECLAIM)  // check if we should perform reclaim operation
    hdlc_clear_outpkts(hd);

  return;
}

/*--------------------------------------------------------------------------
| hdlc_get_ctl_outpkt - Used to allocate a outgoing control data
   packet, fill in the
   common header elements and return a pointer to the packet, so the
   application can fill in the data in the packet.  The caller is then
   expected to send the packet via hdlc_send_ctl_outpkt().
|--------------------------------------------------------------------------*/
int hdlc_get_ctl_outpkt(Hdlc *hd, BYTE **buf)
{
  BYTE *bptr;

  TraceStr("get_ctl_outpkt");

  bptr = &hd->qout_ctl.QBase[(MAX_PKT_SIZE * hd->qout_ctl.QPut)];

  *buf = &bptr[20];  // return ptr to the sub-packet area

  if (hd->TxCtlPackets[hd->qout_ctl.QPut]->ProtocolReserved[1] != 0)  // free for use
  {
    TraceErr("CPktNotOurs!");
    *buf = NULL;
    return 2;  // error, packet is owned, busy
  }

  return 0;
}

/*--------------------------------------------------------------------------
| hdlc_get_outpkt - Used to allocate a outgoing data packet, fill in the
   common header elements and return a pointer to the packet, so the
   application can fill in the data in the packet.  The caller is then
   expected to send the packet via hdlc_send_outpkt().
|--------------------------------------------------------------------------*/
int hdlc_get_outpkt(Hdlc *hd, BYTE **buf)
{
  BYTE *bptr;

  TraceStr("get_outpkt");
  if (hd->status & LST_RECLAIM)  // check if we should perform reclaim operation
    hdlc_clear_outpkts(hd);

  // if indexed, then reduce by one so we always leave one for an
  // unindexed packet.
  if (q_count(&hd->qout) >= hd->pkt_window_size)
  {
    return 1;  // no room
  }
  if (hd->TxPackets[hd->qout.QPut]->ProtocolReserved[1] != 0)  // free for use
  {
    TraceErr("PktNotOurs!");
    *buf = NULL;
    return 2;
  }
  bptr = &hd->qout.QBase[(MAX_PKT_SIZE * hd->qout.QPut)];

  *buf = &bptr[20];  // return ptr to the sub-packet area

  return 0;
}

/*--------------------------------------------------------------------------
| hdlc_clear_outpkts - go through output queue and re-claim any packet
   buffers which have been acknowledged.
|--------------------------------------------------------------------------*/
static void hdlc_clear_outpkts(Hdlc *hd)
{
#define NEW_WAY

#ifndef NEW_WAY
  int count, get, i, ack_count, ack_get;
  BYTE *tx_base;

#define OUT_SNDINDEX tx_base[18]
#else

#define OUT_SNDINDEX_BYTE_OFFSET 18
#endif
  int put;
  int ack_index;

  TraceStr("clear_outpkt");
  hd->status &= ~LST_RECLAIM;  // clear this flag

  // in_ack_index is the last packet V(r) acknowledgement, so it
  // is equal to what the other party expects the next rec. pkt
  // index to be.
  if (hd->in_ack_index > 0)
       ack_index = hd->in_ack_index-1;
  else ack_index = 0xff;

#ifdef NEW_WAY
  put = hd->qout.QPut;
  // figure out a queue index of the last(most recent) pkt we sent
  // (back up the QPut index)

  while (put != hd->qout.QGet)  // while not end of ack-pending out-packets
  {
    // (back up the QPut index)
    if (put == 0)
     put = HDLC_TX_PKT_QUEUE_SIZE-1;
    else --put;

    // if ack matches the out_snd_index for this packet
    if (hd->qout.QBase[(MAX_PKT_SIZE * put)+OUT_SNDINDEX_BYTE_OFFSET]
         == ack_index)
    {
      // clear all pending up to this packet by updating the QGet index.
      if (put == (HDLC_TX_PKT_QUEUE_SIZE-1))
           hd->qout.QGet = 0;
      else hd->qout.QGet = (put+1);

      hd->tx_alive_timer = 0;  // reset this since we have a good active link

      if (q_empty(&hd->qout))  // all packets cleared
           hd->sender_ack_timer = 0;  // stop the timeout counter
      break;  // bail out of while loop, all done
    }
  }
#else
  count = q_count(&hd->qout);
  get   = hd->qout.QGet;
  ack_count = 0;
  ack_get = get;  // acknowledge all up to this point

  for (i=0; i<count; i++)
  {
    //-- setup a ptr to our first outgoing packet in our resend buffer
    tx_base= &hd->qout.QBase[(MAX_PKT_SIZE * get)];
    ++get;  // setup for next one
    if (get >= HDLC_TX_PKT_QUEUE_SIZE)
      get = 0;

       // if the packet is definitely older than our ACK index
    if (OUT_SNDINDEX <= ack_index)
    {
     
      ++ack_count;    // acknowledge all up to this point
      ack_get = get;  // acknowledge all up to this point
    }
       // else if roll over cases might exist
    else if (ack_index < HDLC_TX_PKT_QUEUE_SIZE)
    {
      if (OUT_SNDINDEX > HDLC_TX_PKT_QUEUE_SIZE)  // roll over case
      {
        ++ack_count;    // acknowledge all up to this point
        ack_get = get;  // acknowledge all up to this point
      }
      else break;  // bail from for loop
    }
    else  // we are all done, because pkts must be in order
    {
      break;  // bail from for loop
    }
  }

  if (ack_count)  // if we did acknowledge(free) some output packets
  {
    hd->tx_alive_timer = 0;  // reset this since we have a good active link

    hd->qout.QGet    = ack_get;   // update the circular get queue index.

    if (q_empty(&hd->qout))  // all packets cleared
         hd->sender_ack_timer = 0;  // stop the timeout counter
  }
#endif
}

/*--------------------------------------------------------------------------
| hdlc_resend_outpkt - resend packet(s) due to sequence error.  Only indexed
   iframe packets get resent.
|--------------------------------------------------------------------------*/
int hdlc_resend_outpkt(Hdlc *hd)
{
  BYTE *tx_base;
  int phy_len, count;
//  BYTE *buf;
//  WORD *wptr;
  int get;

  TraceStr("resend_outpkt");
  if (hd->status & LST_RECLAIM)  // check if we should perform reclaim operation
    hdlc_clear_outpkts(hd);

  count = q_count(&hd->qout);
  get   = hd->qout.QGet;

  if (count == 0)
    return 0;  // none to send

  while (count > 0)
  {
    if (hd->TxPackets[get]->ProtocolReserved[1] == 0) {
      /* Make sure packet has come back from NDIS */

      /* free to resend */
      // assume indexing used
      tx_base= &hd->qout.QBase[(MAX_PKT_SIZE * get)];

      ++hd->iframes_sent;  // statistics
      // get calculated length of packet for resending at out pkt prefix.
      phy_len = hd->phys_outpkt_len[get];

      // always make the ack as current as possible
      tx_base[19] = hd->next_in_index;  // V(r)

      hdlc_SendPkt(hd, get, phy_len);

      ++hd->iframes_resent; // statistics: # of packets re-sent
    }

    ++get;
    if (get >= HDLC_TX_PKT_QUEUE_SIZE)
      get = 0;

    --count;
  }
  hd->unacked_pkts = 0;

  // reset timeout
  hd->sender_ack_timer = (MIN_ACK_REC_TIME * 2);

  // reset this timer, since we are sending out new ack.
  hd->rec_ack_timer = 0;

  return 0;
}

/*--------------------------------------------------------------------------
| hdlc_send_ctl_outpkt - App. calls hdlc_get_ctl_outpkt() to get a buffer.
   App then fills buffer and sends it out by calling us.
|--------------------------------------------------------------------------*/
int hdlc_send_ctl_outpkt(Hdlc *hd, int data_len, BYTE *dest_addr)
{
  BYTE *tx_base;
  int phy_len;
  int get, stat;

  TraceStr("send_ctl_outpkt");
  get = hd->qout_ctl.QPut;

  tx_base = &hd->qout_ctl.QBase[(MAX_PKT_SIZE * get)];
  ++hd->qout_ctl.QPut;
  if (hd->qout_ctl.QPut >= hd->qout_ctl.QSize)
    hd->qout_ctl.QPut = 0;

  ++hd->ctlframes_sent;  // statistics

  if (dest_addr == NULL)
       memcpy(tx_base, hd->dest_addr, 6);   // set dest addr
  else memcpy(tx_base, dest_addr, 6);       // set dest addr

  memcpy(&tx_base[6], hd->nic->address, 6); // set src addr

             // + 1 for trailing 0(sub-pkt terminating header)
  phy_len = 20 + data_len + 1; 

  // BYTE 12-13: Comtrol PCI ID  (11H, FEH), Ethernet Len field
  *((WORD *)&tx_base[12]) = 0xfe11;

  if (phy_len < 60)
    phy_len = 60;

  tx_base[14] = ASYNC_PRODUCT_HEADER_ID;  // comtrol packet type = driver management, any product.
  tx_base[15] = 0;                  // conc. index field
  tx_base[16] = ASYNC_FRAME;        // ASYNC FRAME(0x55)
  tx_base[17] = 1;                  // hdlc control field(ctrl-packet)
  tx_base[18] = 0; // V(s), unindexed so mark as 0 to avoid confusion
  tx_base[19] = hd->next_in_index;  // V(r), acknowl. field
  tx_base[20+data_len] = 0;         // terminating sub-packet type


  hd->unacked_pkts = 0;  // reset this

  // reset this timer, since we are sending out new ack.
  hd->rec_ack_timer = 0;

  stat = hdlc_ctl_SendPkt(hd, get, phy_len);


 return stat;
}

/*--------------------------------------------------------------------------
| hdlc_send_outpkt - App. calls hdlc_get_outpkt() to get a buffer.  App then
    fills buffer and sends it out by calling us.  This packet sits in
   transmit queue for possible re-send until a packet comes in which
   acknowledges reception of it.
|--------------------------------------------------------------------------*/
int hdlc_send_outpkt(Hdlc *hd, int data_len, BYTE *dest_addr)
{
  BYTE *tx_base;
  int phy_len;
  int get, stat;

  TraceStr("send_outpkt");
  get = hd->qout.QPut;

  tx_base = &hd->qout.QBase[(MAX_PKT_SIZE * get)];

  ++hd->qout.QPut;
  if (hd->qout.QPut >= HDLC_TX_PKT_QUEUE_SIZE)
    hd->qout.QPut = 0;
  // setup this timeout for ack. back.
  hd->sender_ack_timer = (MIN_ACK_REC_TIME * 2);

  ++hd->iframes_sent;  // statistics

  if (dest_addr == NULL)
       memcpy(tx_base, hd->dest_addr, 6);   // set dest addr
  else memcpy(tx_base, dest_addr, 6);       // set dest addr

  memcpy(&tx_base[6], hd->nic->address, 6); // set src addr

             // + 1 for trailing 0(sub-pkt terminating header)
  phy_len = 20 + data_len + 1; 

  // BYTE 12-13: Comtrol PCI ID  (11H, FEH), Ethernet Len field
  *((WORD *)&tx_base[12]) = 0xfe11;

  if (phy_len < 60)
    phy_len = 60;

  tx_base[14] = ASYNC_PRODUCT_HEADER_ID;  // comtrol packet type = driver management, any product.
  tx_base[15] = 0;                  // conc. index field
  tx_base[16] = ASYNC_FRAME;        // ASYNC FRAME(0x55)
  tx_base[17] = 0;                  // hdlc control field(iframe-packet)
  tx_base[19] = hd->next_in_index;  // V(r), acknowl. field
  tx_base[20+data_len] = 0;         // terminating sub-packet type

  // save calculated length of packet for resending at out pkt prefix.
  hd->phys_outpkt_len[get] = phy_len;

  tx_base[18] = hd->out_snd_index;  // V(s)
  hd->out_snd_index++;

  hd->unacked_pkts = 0;  // reset this

  // reset this timer, since we are sending out new ack.
  hd->rec_ack_timer = 0;

  stat = hdlc_SendPkt(hd, get, phy_len);


 return stat;
}

/*----------------------------------------------------------------------
 hdlc_ctl_SendPkt - Our send routine.
|----------------------------------------------------------------------*/
int hdlc_ctl_SendPkt(Hdlc *hd, int pkt_num, int length)
{
  NTSTATUS Status;


#if DBG
  if (hd == NULL)
  {
    MyKdPrint(D_Error, ("H1\n"))
    TraceErr("Hsnd1a1");
    return 1;
  }
  if (hd->nic == NULL)
  {
    MyKdPrint(D_Error, ("H2\n"))
    TraceErr("Hsnd1a");
    return 1;
  }
  if (hd->nic->TxBufTemp == NULL)
  {
    MyKdPrint(D_Error, ("H3\n"))
    TraceErr("Hsnd1b");
    return 1;
  }
  if (hd->nic->TxPacketsTemp == NULL)
  {
    MyKdPrint(D_Error, ("H4\n"))
    TraceErr("Hsnd1c");
    return 1;
  }
  if (hd->nic->Open == 0)
  {
    MyKdPrint(D_Error, ("H5\n"))
    TraceErr("Hsnd1d");
    return 1;
  }
#endif
  Trace1("Hsendpkt Nic%d", hd->nic->RefIndex);

  hd->TxCtlPackets[pkt_num]->Private.TotalLength = length;
  NdisAdjustBufferLength(hd->TxCtlPackets[pkt_num]->Private.Head, length);

  hd->TxCtlPackets[pkt_num]->ProtocolReserved[1] = 1;  // mark as pending
  NdisSend(&Status, hd->nic->NICHandle,  hd->TxCtlPackets[pkt_num]);
  if (Status == NDIS_STATUS_SUCCESS)
  {
    TraceStr(" ok");
    hd->TxCtlPackets[pkt_num]->ProtocolReserved[1] = 0;  // free for use
  }
  else if (Status == NDIS_STATUS_PENDING)
  {
    TraceStr(" pend");
      // Status = NicWaitForCompletion(nic);  // wait for completion
  }
  else
  {
    hd->TxCtlPackets[pkt_num]->ProtocolReserved[1] = 0;  // free for use
    TraceErr(" send1A");
    return 1;
  }

  ++hd->nic->pkt_sent;          // statistics
  hd->nic->send_bytes += length;    // statistics

  return 0;
}

/*----------------------------------------------------------------------
 hdlc_SendPkt - Our send routine.
|----------------------------------------------------------------------*/
int hdlc_SendPkt(Hdlc *hd, int pkt_num, int length)
{
  NTSTATUS Status;

  TraceStr("sendpkt");

  hd->TxPackets[pkt_num]->Private.TotalLength = length;
  NdisAdjustBufferLength(hd->TxPackets[pkt_num]->Private.Head, length);

  hd->TxPackets[pkt_num]->ProtocolReserved[1] = 1;  // mark as pending
  NdisSend(&Status, hd->nic->NICHandle,  hd->TxPackets[pkt_num]);
  if (Status == NDIS_STATUS_SUCCESS)
  {
    TraceStr(" ok");
    hd->TxPackets[pkt_num]->ProtocolReserved[1] = 0;  // free for use
  }
  else if (Status == NDIS_STATUS_PENDING)
  {
    TraceStr(" pend");
      // Status = NicWaitForCompletion(nic);  // wait for completion
  }
  else
  {
    hd->TxPackets[pkt_num]->ProtocolReserved[1] = 0;  // free for use
    TraceErr(" send1A");
    return 1;
  }

  ++hd->nic->pkt_sent;        // statistics
  hd->nic->send_bytes += length;  // statistics

  return 0;
}

#ifdef COMMENT_OUT
/*--------------------------------------------------------------------------
 hdlc_send_ialive - Send out a iframe packet which device is required
   to acknowledge(and send iframe back) so that we can determine if he
   is still alive.
|--------------------------------------------------------------------------*/
void hdlc_send_ialive(Hdlc *hd)
{
  int stat;
  BYTE *buf;

  if (!q_empty(&hd->qout)) // have outpkts waiting for ack.
  {
    hdlc_resend_outpkt(hd); // send it out again!
  }
  else
  {
    stat = hdlc_get_outpkt(hd, &buf);
    if (stat == 0)
    {
      buf[0] = 0;   // an empty iframe packet
      buf[1] = 0;
      stat = hdlc_send_outpkt(hd, 1, hd->dest_addr); // send it out!
      if (stat != 0)
        { TraceErr("2D"); }
    }
    else
    {
      // else we might as well go fishing and forget about this stuff.
      TraceErr("3D");
    }
  }
}
#endif

/*--------------------------------------------------------------------------
 hdlc_resync - At appropriate times it is needed to reset the sequence
   indexing logic in order to get the two sides up a talking.  On
   startup(either side) or a fatal(long) timeout, it is needed to send
   a message to the other party saying: "reset your packet sequencing
   logic so we can get sync-ed up".
|--------------------------------------------------------------------------*/
void hdlc_resync(Hdlc *hd)
{
  TraceErr("resync");
  //----- flush re-send output buffer
  hd->qout.QPut   = 0;
  hd->qout.QGet   = 0;

  //----- flush ctl output buffer
  hd->qout_ctl.QPut   = 0;
  hd->qout_ctl.QGet   = 0;

  //----- use to re-sync up our index count
  hd->in_ack_index = 0;
  hd->out_snd_index= 0;
  hd->next_in_index= 0;

  //----- reset our outgoing packet queue
  hd->sender_ack_timer = 0;

  hd->unacked_pkts = 0;
  //----- notify owner that it needs to resync
  if (hd->upper_layer_proc != NULL)
    (*hd->upper_layer_proc) (hd->context, EV_L2_RESYNC, 0);
}

/*--------------------------------------------------------------------------
| hdlc_send_ack_only - Used to recover from timeout condition.  Used to
    resend ACK only.  Used to send over ACK and index fields in a
    unindexed frame(won't flow off).  No data sent along, just HDLC header.
|--------------------------------------------------------------------------*/
int hdlc_send_ack_only(Hdlc *hd)
{
  int ret_stat;
  BYTE *pkt;

  TraceStr("send_ack_only");
  if (hdlc_get_ctl_outpkt(hd, &pkt) == 0)
    ret_stat = hdlc_send_ctl_outpkt(hd, 0, NULL);
  else
    ret_stat = 1; // packet is already in use

  return ret_stat;
}

/*--------------------------------------------------------------------------
| hdlc_send_raw - Used to send raw ethernets out(non-hdlc).
   Caller has gotten a control packet by hdlc_get_ctl_outpkt()
   and has filled in the header.  We just plug in src/dest addr and
   send it out.  Used to send out non-hdlc packets, we provide the service
   in hdlc layer because we have the nic buffers already setup, so its
   convienent to implement here.
|--------------------------------------------------------------------------*/
int hdlc_send_raw(Hdlc *hd, int data_len, BYTE *dest_addr)
{
  BYTE *tx_base;
  int phy_len;
  int get, stat;

  TraceStr("send_raw");
  get = hd->qout_ctl.QPut;

  tx_base = &hd->qout_ctl.QBase[(MAX_PKT_SIZE * get)];
  ++hd->qout_ctl.QPut;
  if (hd->qout_ctl.QPut >= hd->qout_ctl.QSize)
    hd->qout_ctl.QPut = 0;

  ++hd->rawframes_sent;  // statistics

  if (dest_addr == NULL)
       memcpy(tx_base, hd->dest_addr, 6);   // set dest addr
  else memcpy(tx_base, dest_addr, 6);       // set dest addr

  memcpy(&tx_base[6], hd->nic->address, 6); // set src addr

             // + 1 for trailing 0(sub-pkt terminating header)
  phy_len = 20 + data_len + 1; 

  // BYTE 12-13: Comtrol PCI ID  (11H, FEH), Ethernet Len field
  *((WORD *)&tx_base[12]) = 0xfe11;

  if (phy_len < 60)
    phy_len = 60;

  stat = hdlc_ctl_SendPkt(hd, get, phy_len);


 return stat;
}

/*--------------------------------------------------------------------------
| hdlc_send_control - Used to send small un-indexed hdlc frames.
|--------------------------------------------------------------------------*/
int hdlc_send_control(Hdlc *hd, BYTE *header_data, int header_len,
                       BYTE *data, int data_len,
                       BYTE *dest_addr)
{
  BYTE *buf;
  int i,stat;
  BYTE *pkt;

  i = hdlc_get_ctl_outpkt(hd, &pkt);
  if (i)
    return 1; // error

  buf = pkt;

  if (header_len)
  {
    for (i=0; i<header_len; i++)
      buf[i] = header_data[i];
    buf += header_len;
  }
  if (data_len)
  {
    for (i=0; i<data_len; i++)
      buf[i] = data[i];
    buf += data_len;
  }

  if (dest_addr == NULL)
  {
    stat = hdlc_send_ctl_outpkt(hd, header_len + data_len, hd->dest_addr);
  }
  else
  {
    stat = hdlc_send_ctl_outpkt(hd, header_len + data_len, dest_addr);
  }

  return stat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\debuger.h ===
// debuger.h

void debug_all_off(void);
void debug_poll(void);
void do_cmd_line(char *line);
void __cdecl deb_printf(char *format, ...);

int debug_device_reply(PVOID *void_pm,   // PortMan *pm,
                 unsigned char *data,
                 unsigned char *pkt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\initc.h ===
// initc.h

VOID SerialUnload (IN PDRIVER_OBJECT DriverObject);
NTSTATUS CreateDriverDevice(IN PDRIVER_OBJECT DriverObject,
                            OUT PSERIAL_DEVICE_EXTENSION *DeviceExtension);
NTSTATUS CreateBoardDevice(IN PDRIVER_OBJECT DriverObject,
                           OUT PSERIAL_DEVICE_EXTENSION *DeviceExtension);
NTSTATUS CreatePortDevices(IN PDRIVER_OBJECT DriverObject);
NTSTATUS CreateReconfigPortDevices(IN PSERIAL_DEVICE_EXTENSION board_ext,
           int new_num_ports);
NTSTATUS StartPortHardware(IN PSERIAL_DEVICE_EXTENSION port_ext,
                           int chan_num);
NTSTATUS CreatePortDevice(
           IN PDRIVER_OBJECT DriverObject,
           IN PSERIAL_DEVICE_EXTENSION ParentExtension,
           OUT PSERIAL_DEVICE_EXTENSION *DeviceExtension,
           IN int chan_num,
           IN int is_fdo);
VOID RcktDeleteDriverObj(IN PSERIAL_DEVICE_EXTENSION extension);
VOID RcktDeleteDevices(IN PDRIVER_OBJECT DriverObject);
VOID RcktDeleteBoard(IN PSERIAL_DEVICE_EXTENSION extension);
VOID RcktDeletePort(IN PSERIAL_DEVICE_EXTENSION extension);
VOID SerialCleanupDevice (IN PSERIAL_DEVICE_EXTENSION Extension);
PVOID SerialGetMappedAddress(
        IN INTERFACE_TYPE BusType,
        IN ULONG BusNumber,
        PHYSICAL_ADDRESS IoAddress,
        ULONG NumberOfBytes,
        ULONG AddressSpace,
        PBOOLEAN MappedAddress,
        BOOLEAN DoTranslation);
VOID SerialSetupExternalNaming (IN PSERIAL_DEVICE_EXTENSION Extension);
VOID SerialCleanupExternalNaming(IN PSERIAL_DEVICE_EXTENSION Extension);
VOID SerialLogError(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN ULONG SequenceNumber,
    IN UCHAR MajorFunctionCode,
    IN UCHAR RetryCount,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN NTSTATUS SpecificIOStatus,
    IN ULONG LengthOfInsert1,
    IN PWCHAR Insert1);
VOID EventLog(
    IN PDRIVER_OBJECT DriverObject,
    IN NTSTATUS FinalStatus,
    IN NTSTATUS SpecificIOStatus,
    IN ULONG LengthOfInsert1, 
    IN PWCHAR Insert1);
VOID InitPortsSettings(IN PSERIAL_DEVICE_EXTENSION extension);
NTSTATUS RcktInitPollTimer(void);
void InitSocketModems(PSERIAL_DEVICE_EXTENSION ext);
int DeterminePortName(void);
int clear_com_db(char *szComport);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\init.c ===
/*-------------------------------------------------------------------
| init.c - main module for RocketPort NT device driver.  Contains
   mostly initialization code.  Driver Entry is DriverEntry() routine.

 Copyright 1993-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

//------ local routines, function prototypes -----------------------------
NTSTATUS DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath);
#ifndef NT50
static NTSTATUS StartNT40(IN PDRIVER_OBJECT DriverObject);
#endif

//------------ global variables -----------------------------------
#ifdef S_RK
PCI_CONFIG PciConfig[MAX_NUM_BOXES+1];  // array of all our pci-boards in sys
#endif

DRIVER_CONTROL Driver;  // all Driver control information eg ISR

ULONG RocketDebugLevel = 0;
#ifdef S_RK
//char *szClassName = {"Resources RocketPort#"};
#endif

#if DBG
static TCHAR *dbg_label = TEXT("DBG_VERSION");
#endif

/*----------------------------------------------------------------------
 DriverEntry -
    The entry point that the system point calls to initialize
    any driver.
    This routine will gather the configuration information,
    report resource usage, attempt to initialize all serial
    devices, connect to interrupts for ports.  If the above
    goes reasonably well it will fill in the dispatch points,
    reset the serial devices and then return to the system.
Arguments:
    DriverObject - Just what it says,  really of little use
    to the driver itself, it is something that the IO system
    cares more about.
    PathToRegistry - points to the entry for this driver
    in the current control set of the registry.
    typical: "REGISTRY\Machine\System\CurrentControlSet\Services\VSLinka"
Return Value:
    STATUS_SUCCESS if we could initialize a single device,
    otherwise STATUS_SERIAL_NO_DEVICE_INITED.
|----------------------------------------------------------------------*/
NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject,
                     IN PUNICODE_STRING RegistryPath)
{
 NTSTATUS status;
 int stat;
 char tmpstr[120];

  //---- zero out the Driver structure
  RtlZeroMemory(&Driver,sizeof(Driver));

  Driver.GlobalDriverObject = DriverObject;  // used for EventLogging

  Driver.DebugQ.QBase = ExAllocatePool(NonPagedPool,10000+2);
  if ( Driver.DebugQ.QBase == NULL ) {
    return STATUS_INSUFFICIENT_RESOURCES;
  }
  Driver.DebugQ.QSize = 10000;
  Driver.TraceOptions = 0;
#if DBG
   Driver.TraceOptions = 0xffffffffL;
#endif
  KeInitializeSpinLock(&Driver.DebugLock);
  KeInitializeSpinLock(&Driver.TimerLock);

#if DBG
//    RocketDebugLevel = D_Error | D_Test;
//    Driver.GTraceFlags = D_Error | D_Test;

    //RocketDebugLevel = D_Error | D_Nic | D_Hdlc | D_Port;
    //Driver.GTraceFlags = D_Error | D_Nic | D_Hdlc | D_Port;

    //RocketDebugLevel = D_Error | D_Pnp;
    //Driver.GTraceFlags = D_Error | D_Pnp;

    //RocketDebugLevel = D_Error | D_Test | D_Pnp | D_Init;
    //Driver.GTraceFlags = D_Error | D_Test | D_Pnp | D_Init;

    //RocketDebugLevel = D_All;
    //Driver.GTraceFlags = D_All;

    RocketDebugLevel = D_Error;
    Driver.GTraceFlags = D_Error;
#endif

#ifdef S_VS
  stat = LoadMicroCode(NULL);
  if (stat)
  {
    status = STATUS_SERIAL_NO_DEVICE_INITED;
    Eprintf("Err:No VSLINKA.BIN file!");
    return status;
  }
  MyKdPrint(D_Init, ("MicroCode Loaded\n"))

  //----- allocate an array of Nic card structs
  // allow up to VS1000_MAX_NICS nic cards to come and go
  Driver.nics = (Nic *)our_locked_alloc(sizeof(Nic) * VS1000_MAX_NICS, "Dnic");
#endif

  //---- do some registry configuration reading, in options.c
  // Save off RegistryPath to Driver.RegPath
  stat = SaveRegPath(RegistryPath);
  if ( stat ) {
    status = STATUS_SERIAL_NO_DEVICE_INITED;
    return status;
  }

  UToCStr(tmpstr, RegistryPath, sizeof(tmpstr));
  MyKdPrint(D_Test, (" init RegPath=%s\n", tmpstr))

  // read in all the driver level options out of \Parameters
  // this fills out values in Driver struct
  read_driver_options();

  if (Driver.NumDevices == 0)
    Driver.NumDevices = 1;
  if (Driver.NumDevices > MAX_NUM_BOXES)
    Driver.NumDevices = MAX_NUM_BOXES;

  MyKdPrint(D_Init,("DriverEntry\n"))

  if ((Driver.ScanRate < 1) || (Driver.ScanRate > 50))
    Driver.ScanRate = 7;  // default to 7ms operation(137Hz)

  //------ only setup io stuff here if prior to NT5.0
#ifndef NT50
  status = StartNT40(DriverObject);
  if (status != STATUS_SUCCESS)
  {
    EventLog(DriverObject, STATUS_SUCCESS, SERIAL_RP_INIT_FAIL, 0, NULL);
    SerialUnload(DriverObject);  // deallocate our things
    return status;
  }
#endif  // not pnp

  // Initialize the Driver Object with driver's entry points
  DriverObject->DriverUnload = SerialUnload;
  DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS] = SerialFlush;
  DriverObject->MajorFunction[IRP_MJ_WRITE]  = SerialWrite;
  DriverObject->MajorFunction[IRP_MJ_READ]   = SerialRead;
  DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = SerialIoControl;
#ifdef NT50
  DriverObject->DriverExtension->AddDevice  = SerialAddDevice;
  DriverObject->MajorFunction[IRP_MJ_PNP]   = SerialPnpDispatch;
  DriverObject->MajorFunction[IRP_MJ_POWER] = SerialPowerDispatch;
  DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
      SerialInternalIoControl;
#endif
  // these appear to change in 5.0, but not working yet(see serial.sys)....
  DriverObject->MajorFunction[IRP_MJ_CREATE] = SerialCreateOpen;
  DriverObject->MajorFunction[IRP_MJ_CLOSE]  = SerialClose;

  DriverObject->MajorFunction[IRP_MJ_CLEANUP] = SerialCleanup;
  DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] =
      SerialQueryInformationFile;
  DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION] =
      SerialSetInformationFile;

#ifdef NT50
  // pnp
  //---- Log the fact that the driver loaded
  EventLog(DriverObject, STATUS_SUCCESS, SERIAL_NT50_INIT_PASS, 0, NULL);
  return STATUS_SUCCESS;
#endif

#ifndef NT50
# ifdef S_RK
  //--------------- Connect to IRQ, or start Timer.
  StartRocketIRQorTimer();
# else
  RcktInitPollTimer();
  KeSetTimer(&Driver.PollTimer,
             Driver.PollIntervalTime,
             &Driver.TimerDpc);
# endif
  //---- Log the fact that the driver loaded and found some hardware.
  EventLog(DriverObject, STATUS_SUCCESS, SERIAL_RP_INIT_PASS, 0, NULL);
  return STATUS_SUCCESS;
#endif
}

#ifndef NT50
/*----------------------------------------------------------------------
 StartNT40 - Fire up our boards and ports.
|----------------------------------------------------------------------*/
static NTSTATUS StartNT40(IN PDRIVER_OBJECT DriverObject)
{
 NTSTATUS status = STATUS_SUCCESS;
 int i, dstat;
 PSERIAL_DEVICE_EXTENSION ext;
 PSERIAL_DEVICE_EXTENSION board_ext;
  
  if (Driver.NumDevices == 0)  // no rocketports setup.
  {
    Eprintf("No boards configured, run setup.");
    EventLog(DriverObject, STATUS_SUCCESS, SERIAL_RP_INIT_FAIL, 0, NULL);
    return STATUS_SERIAL_NO_DEVICE_INITED;
  }
    //--------Create the driver device object which serves as
    // extensions to link and structure the boards together, and
    // also serve as a special public object for debug and monitor Ioctls.
  if (Driver.driver_ext == NULL)
  {
    status = CreateDriverDevice(Driver.GlobalDriverObject,
                                NULL);  // 
    if (status)
    {
      if (Driver.VerboseLog)
        Eprintf("Err D1.");
      return status;
    }
  }

#ifdef S_VS
    // get our Ethernet running
  i = init_eth_start();
  if (i != STATUS_SUCCESS)
  {
    if (Driver.VerboseLog)
      Eprintf("Err, E1.");
    return i;
  }
#endif

    //--------Create the board device objects which serve as
    // extensions to link and structure the ports together.
  for (i=0; i<Driver.NumDevices; i++)
  {
    status = CreateBoardDevice(DriverObject, NULL);
    if (status)
    {
      if (Driver.VerboseLog)
        Eprintf("Err B1.");
      return status;
    }
  }

  board_ext = Driver.board_ext;
  while (board_ext != NULL)
  {
    read_device_options(board_ext);

    if (board_ext->config->NumPorts == 0)
        board_ext->config->NumPorts = 8;

    board_ext = board_ext->board_ext;
  }

#ifdef S_RK
    // rocketport specific startup code.  Setup some of
    // the config structs, look for PCI boards in system, match them up.
  status = init_cfg_rocket(DriverObject);
  if (status != STATUS_SUCCESS)
  {
    if (Driver.VerboseLog)
      Eprintf("Err C1.");
    return STATUS_SERIAL_NO_DEVICE_INITED;
  }
  //------ setup moree rocket hardware specific information
  if (SetupRocketCfg(0) != 0)
  {
    VerboseLogBoards("B -");
    return STATUS_SERIAL_NO_DEVICE_INITED;
  }

  //SetupRocketIRQ();

  //------ Report our RocketPort resource usage to NT, and get IO permissions
  ext = Driver.board_ext;
  while(ext)
  {
    if (RocketReportResources(ext) != 0)
    {
      VerboseLogBoards("C -");
      EventLog(DriverObject, STATUS_SUCCESS, SERIAL_RP_RESOURCE_CONFLICT,0, NULL);
      return STATUS_SERIAL_NO_DEVICE_INITED;
    }
    ext = ext->board_ext;  // next
  }
#endif

  //------ Fire up the boards.
  ext = Driver.board_ext;
  while(ext)
  {
# ifdef S_RK
    dstat = InitController(ext);
    if (dstat != 0)
    {
      VerboseLogBoards("D -");
      return STATUS_SERIAL_NO_DEVICE_INITED;
    }
# else
    status = VSSpecialStartup(ext);
    if (status != STATUS_SUCCESS)
    {
      if (Driver.VerboseLog)
        Eprintf("Hdlc open fail\n");
      status = STATUS_SERIAL_NO_DEVICE_INITED;
      return status;
    }
# endif
    ext->FdoStarted = 1;  // tell ISR that its on.
    ext->config->HardwareStarted = TRUE;  // tell ISR its ready to go
    ext = ext->board_ext;  // next
  }

  //----- make the port devices
  MyKdPrint(D_Init,("CreatePortDevices\n"))
  status = CreatePortDevices(DriverObject);
  if (status != STATUS_SUCCESS)
  {
# ifdef S_RK
    VerboseLogBoards("E -");
# else
    if (Driver.VerboseLog)
      Eprintf("Err, P1.");
# endif
    EventLog(DriverObject, STATUS_SUCCESS, SERIAL_DEVICEOBJECT_FAILED, 0, NULL);
    return STATUS_SERIAL_NO_DEVICE_INITED;
  }

#ifdef S_RK
  //------ If modem boards, initialize modems..
  ext = Driver.board_ext;
  while (ext)
  {
    // pull SocketModem devices out of reset state
    InitSocketModems(ext);

    // load RocketModemII devices...
    InitRocketModemII(ext);
    ext = ext->board_ext;  // next
  }
#endif

  return STATUS_SUCCESS;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\hdlc.h ===
/*----
// hdlc.h
 6-18-97  change timing on timeouts to 1.0 sec base.
------*/

#define HDLC_TRACE_outs(c)

#define HDLC_DEB_outs(s,l) 

// define a circular queue for incoming packets.
// queue uses an extra tail end head room of MAX_PKT_SIZE to avoid having to
// perform to much sypherin concerning queue room.
#define HDLC_TX_PKT_QUEUE_SIZE 9

// control fields for hdlc header control field
#define CONTROL_IFRAME        0
#define CONTROL_UFRAME        1
#define CONTROL_CONNECT_ASK   3
#define CONTROL_CONNECT_REPLY 5
/*--------------------------------------------
 Hdlc struct - main struct for HDLC support(layer 2)
----------------------------------------------*/
typedef struct {
  //LanPort *lp;  // our layer 1 handle.
  Nic *nic;  // nic card we are bound to on lower end
  PVOID context;  // upper layer can put handle here

  BYTE dest_addr[6];  // dest. address(needed for ack/seq. timeouts)

  WORD phys_outpkt_len[HDLC_TX_PKT_QUEUE_SIZE];
  //----- circular que of outgoing data packets
  Queue qout;

  // packet and buffer pool handles, basically points to the
  // tx-buffer space in qout.
  NDIS_HANDLE TxPacketPool;
  NDIS_HANDLE TxBufferPool;
  // queue of packets setup for use
  PNDIS_PACKET TxPackets[HDLC_TX_PKT_QUEUE_SIZE];

  // control packet and buffer pool handles, basically points to the
  // tx-buffer space in qout_ctl.
  NDIS_HANDLE TxCtlPacketPool;
  NDIS_HANDLE TxCtlBufferPool;
  // queue of packets setup for use
  PNDIS_PACKET TxCtlPackets[2];
  //----- circular que of outgoing control packets
  Queue qout_ctl;

  //----- timer statistics
  DWORD  rec_ack_timeouts;  // # of rec-ack-timeouts
  DWORD  send_ack_timeouts;  // # of send-ack-timeouts

  //----- outgoing statistics
  DWORD iframes_resent;    // cout of all resent iframes
  DWORD iframes_sent;    // count of every sent iframe
  DWORD ctlframes_sent;  // count of every sent control frame
  DWORD rawframes_sent;  // count of every sent raw frame
  DWORD iframes_outofseq;  // statistics, error count
  //DWORD ErrBadHeader; // statistics, error count

  //----- incoming statistics
  DWORD frames_rcvd;      // 

  //------ packet driver handle
  WORD status;

      // sent out on each packet, increment by one each time a new packet
      // is sent out.  The receiver uses this to check for packet sequence
      // order.  This value is copied into the snd_index field when we are
      // ready to send a packet.  A sync-message will set this to an
      // initial working value of 0.
  BYTE out_snd_index;

      // last good rx ack_index received.  The receiver will send us a
      // acknowledge index(ack_index field) indicating the last good
      // received packet index it received.  This allows us to remove
      // all packets up to this index number from our transmit buffer
      // since they have been acknowledged.  Until this point we must
      // retain the packet for retransmition in case the receiver does
      // not acknowledge reception after a timeout period.
  BYTE in_ack_index;

      // last good rx snd_index on received packet.  All packets received
      // should have a snd_index value equal to +1 of this value.  So this
      // value is used to check for consequative incrementing index values
      // on the packets received.  On sync-message this value is set to
      // 0xff.
  BYTE next_in_index;  

     // used to measure how many incoming pkts received which are
     // unacknowledged so we can trip a acknowledgement at 80% full
  BYTE unacked_pkts;

      // tick counter used to timeout sent packets and the expected
      // acknowledgement.
  WORD sender_ack_timer;

      // tick counters used to check that connection is still active
      // periodically to recover from device power-cycle or hdlc
      // sequence level failure.  If it ticks up past X many minutes
      // then a iframe packet is sent(and a iframe response is expected
      // back.  If it ticks past (X*2) minutes, then failure is declared
      // and server re-initializes the box.
  WORD tx_alive_timer;  // ticks up, reset every acked-reclaim of sent iframe.
  WORD rx_alive_timer;  // ticks up, reset on every received iframe.

  WORD tick_timer;  // used to generate 10Hz timer signal used for timeouts.

      // tick counter used to timeout rec. packets and our responsibility
      // to send and ack on them
  WORD rec_ack_timer;

  WORD pkt_window_size; // 1 to 8, num tx packets before ack

  WORD state;        // state of hdlc level, see defines
  WORD old_state;    // old state of hdlc level(used to reset timer)
  WORD sub_state;    // sub_state of a particular state
  WORD state_timer;  // state timer

  // following function ptrs is a general method for linking
  // layers together.
  ULONG (*upper_layer_proc) (PVOID context, int message_id, ULONG message_data);
  ULONG (*lower_layer_proc) (PVOID context, int message_id, ULONG message_data);
} Hdlc;

//--- layer 2 HDLC events used in _proc() calls
// layer 2(hdlc) assigned range from 200-299
#define EV_L2_RESYNC        200
#define EV_L2_RX_PACKET     201
#define EV_L2_TX_PACKET     202
#define EV_L2_BOOT_REPLY    203
#define EV_L2_ADMIN_REPLY   204
#define EV_L2_RELOAD        205
#define EV_L2_CHECK_LINK    206

// packet sequence timeout values
#define MIN_ACK_REC_TIME       10   // 10th seconds (1.0 sec)
#define KEEP_ALIVE_TIMEOUT     300  // 10th seconds (30.0 sec)

// state field defines
//#define ST_HDLC_OFF          0  // HDLC is off, won't do anything.
//#define ST_HDLC_DISCONNECTED 1  // HDLC is turned on, will allow connections
//#define ST_HDLC_CONNECTED    2  // HDLC is connected up and active

// status field bit values
#define LST_RESYNC        0x0001  // set if we need to re-sync the packet index
// #define LST_SEND_NAK   0x0002  // set if we need to update other side with index
#define LST_RECLAIM       0x0004  // set if we should attempt to reclaim tx packets
#define LST_SEND_ACK      0x0008  // set if we need to send immediate ACK

//------------------ public functions
int hdlc_open(Hdlc *hd, BYTE *box_mac_addr);
int hdlc_close(Hdlc *hd);

#define ERR_GET_EMPTY      1  // empty
#define ERR_GET_BAD_INDEX  2  // error, packet out of sequence
#define ERR_GET_BADHDR     3  // error, not our packet
#define ERR_CONTROL_PACKET 4  // hdlc control packet only, no data
int hdlc_validate_rx_pkt(Hdlc *hd, BYTE *buf);

int hdlc_send_outpkt(Hdlc *hd, int data_len, BYTE *dest_addr);
int hdlc_send_ctl_outpkt(Hdlc *hd, int data_len, BYTE *dest_addr);

int hdlc_get_outpkt(Hdlc *hd, BYTE **buf);
int hdlc_get_ctl_outpkt(Hdlc *hd, BYTE **buf);

int hdlc_send_raw(Hdlc *hd, int data_len, BYTE *dest_addr);
int hdlc_resend_outpkt(Hdlc *hd);
void hdlc_resync(Hdlc *hd);
void hdlc_poll(Hdlc *hd);
int hdlc_close(Hdlc *hd);

int hdlc_send_control(Hdlc *hd, BYTE *header_data, int header_len,
                      BYTE *data, int data_len, BYTE *dest_addr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\init.h ===
//--- init.h(common for vs and rk)

// use 2.04.03 format 3 part optional for non-released versions)
// use 2.05    format 2 part for released changes
#ifdef S_RK
  #ifdef NT50
    #define VER_PRODUCTVERSION_STR "4.50"
    #define VER_PRODUCTVERSION      4,50
  #else
    #define VER_PRODUCTVERSION_STR "4.50"
    #define VER_PRODUCTVERSION      4,50
  #endif
#else
  #ifdef NT50
    #define VER_PRODUCTVERSION_STR "2.50"
    #define VER_PRODUCTVERSION      2,50
  #else
    #define VER_PRODUCTVERSION_STR "2.50"
    #define VER_PRODUCTVERSION      2,50
  #endif
#endif

// these are now turned on or off in the sources file in rk or vs dir
//#define ROCKET
//#define VS1000
//#define NT50

// make the ExAllocatePool call "WDM-compatible" - use pool tags version
// with our tag "Rckt" (little endian format)

#ifdef NT50
  #ifdef POOL_TAGGING
    #ifdef ExAllocatePool
      #undef ExAllocatePool
    #endif
    #define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'tkcR')
  #endif
#endif

//	
//	define paths to Rockwell modem firmware...
//
#define	MODEM_CSREC_PATH	"\\SystemRoot\\system32\\ROCKET\\ctmmdmfw.rm"
#define	MODEM_CSM_SREC_PATH	"\\SystemRoot\\system32\\ROCKET\\ctmmdmld.rm"

//#define TRY_DYNAMIC_BINDING

// define to allow modem download for new pci rocketmodem 56k product(no flash)
#define MDM_DOWNLOAD

// these should be on, they are left in just in case(will strip out in future)
#define RING_FAKE
#define USE_SYNC_LOCKS
#define NEW_WAIT
#define NEW_WRITE_SYNC_LOCK
#define NEW_WAIT_SYNC_LOCK

#ifdef S_RK
// we can only use this on rocketport
#define NEW_FAST_TX
#endif

#define TRACE_PORT
#define USE_HAL_ASSIGNSLOT

// pnp bus-driver stuff
#define DO_BUS_EXTENDER

// attempted io-aliasing solution for nt5.0 to properly get resources
// for isa-bus cards using alias io space
#define DO_ISA_BUS_ALIAS_IO

#define GLOBAL_ASSERT
#define GLOBAL_TRACE
#define TRACE_PORT

#ifdef S_VS
#define MAX_NUM_BOXES 64
#else
#define MAX_NUM_BOXES 8
#endif

#define MAX_PORTS_PER_DEVICE 64

//---- following used to trace driver activity
//#define D_L0        0x00001L
//#define D_L2        0x00004L
//#define D_L4        0x00010L
//#define D_L6        0x00040L
//#define D_L7        0x00080L
//#define D_L8        0x00100L
//#define D_L9        0x00200L
//#define D_L10       0x00400L
//#define D_L11       0x00800L
#define D_Error     0x08000L
#define D_All       0xffffffffL

#define D_Nic       0x00002L
#define D_Hdlc      0x00008L
#define D_Port      0x00020L

#define D_Options      0x01000L
//---- following used to trace driver activity
#define D_Init         0x00010000L
#define D_Pnp          0x00020000L
#define D_Ioctl        0x00040000L
#define D_Write        0x00080000L
#define D_Read         0x00100000L
#define D_Ssci         0x00200000L
#define D_Thread       0x00400000L
#define D_Test         0x00800000L
#define D_PnpAdd       0x01000000L
#define D_PnpPower     0x02000000L

//Constant definitions for the I/O error code log values.
//  Values are 32 bit values layed out as follows:
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//  where
//      Sev - is the severity code
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//      C - is the Customer code flag
//      R - is a reserved bit
//      Facility - is the facility code
//      Code - is the facility's status code

// Define the facility codes
#define FACILITY_SERIAL_ERROR_CODE       0x6
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4

// Define the severity codes
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3
#ifdef S_RK
#define SERIAL_RP_INIT_FAIL              ((NTSTATUS)0x80060001L)
#else
#define SERIAL_RP_INIT_FAIL              ((NTSTATUS)0xC0060001L)
#endif
#define SERIAL_RP_INIT_PASS              ((NTSTATUS)0x40060002L)
#define SERIAL_NO_SYMLINK_CREATED        ((NTSTATUS)0x80060003L)
#define SERIAL_NO_DEVICE_MAP_CREATED     ((NTSTATUS)0x80060004L)
#define SERIAL_NO_DEVICE_MAP_DELETED     ((NTSTATUS)0x80060005L)
#define SERIAL_UNREPORTED_IRQL_CONFLICT  ((NTSTATUS)0xC0060006L)
#define SERIAL_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC0060007L)
#define SERIAL_NO_PARAMETERS_INFO        ((NTSTATUS)0xC0060008L)
#define SERIAL_UNABLE_TO_ACCESS_CONFIG   ((NTSTATUS)0xC0060009L)
#define SERIAL_UNKNOWN_BUS               ((NTSTATUS)0xC006000AL)
#define SERIAL_BUS_NOT_PRESENT           ((NTSTATUS)0xC006000BL)
#define SERIAL_INVALID_USER_CONFIG       ((NTSTATUS)0xC006000CL)
#define SERIAL_RP_RESOURCE_CONFLICT      ((NTSTATUS)0xC006000DL)
#define SERIAL_RP_HARDWARE_FAIL          ((NTSTATUS)0xC006000EL)
#define SERIAL_DEVICEOBJECT_FAILED       ((NTSTATUS)0xC006000FL)
#define SERIAL_CUSTOM_ERROR_MESSAGE      ((NTSTATUS)0xC0060010L)
#define SERIAL_CUSTOM_INFO_MESSAGE       ((NTSTATUS)0x40060011L)
#define SERIAL_NT50_INIT_PASS            ((NTSTATUS)0x40060012L)

// max number of nic cards we will allow
#define VS1000_MAX_NICS 6

#ifdef GLOBAL_ASSERT
#define GAssert(id, exp ) { if (!(exp)) our_assert(id, __LINE__); }
#else
#define GAssert(id, exp )
#endif

#ifdef GLOBAL_TRACE

#define GTrace3(_Mask,_LeadStr, _Msg,_P1,_P2, _P3) \
  { if (Driver.GTraceFlags & _Mask) TTprintf(_LeadStr, _Msg, _P1, _P2, _P3); }

#define GTrace2(_Mask,_LeadStr, _Msg,_P1,_P2) \
  { if (Driver.GTraceFlags & _Mask) TTprintf(_LeadStr, _Msg, _P1, _P2); }

#define GTrace1(_Mask,_LeadStr, _Msg,_P1) \
  { if (Driver.GTraceFlags & _Mask) TTprintf(_LeadStr, _Msg, _P1); }

#define GTrace(_Mask_, _LeadStr, _Msg_) \
  { if (Driver.GTraceFlags & _Mask_) OurTrace(_LeadStr, _Msg_); }
//#define GMark(c, x)
#else
#define GTrace2(_Mask,_LeadStr, _Msg,_P1, _P2) {}
#define GTrace1(_Mask,_LeadStr, _Msg,_P1) {}
#define GTrace(_Mask_, _LeadStr, _Msg_) {}
//#define GMark(c, x) {}
#endif

// following are for debug, when checked build is made DBG is defined
// and the messages go to our debug queue and the nt debug string output.
#if DBG
#define DTrace3(_Mask_,_LeadStr,_Msg_,_P1_,_P2_,_P3_) \
  { if (RocketDebugLevel & _Mask_) TTprintf(_LeadStr,_Msg_,_P1_,_P2_,_P3_); }

#define DTrace2(_Mask_,_LeadStr,_Msg_,_P1_,_P2_) \
  { if (RocketDebugLevel & _Mask_) TTprintf(_LeadStr,_Msg_,_P1_,_P2_); }

#define DTrace1(_Mask_,_LeadStr,_Msg_,_P1_) \
  { if (RocketDebugLevel & _Mask_) TTprintf(_LeadStr,_Msg_,_P1_); }

#define DTrace(_Mask_,_LeadStr,_Msg_) \
  { if (RocketDebugLevel & _Mask_) OurTrace(_LeadStr, _Msg_); }

#define DPrintf(_Mask_,_Msg_) \
  { if (RocketDebugLevel & _Mask_) Tprintf _Msg_; }
#else
#define DTrace3(_Mask,_LeadStr, _Msg,_P1, _P2, _P3) {}
#define DTrace2(_Mask,_LeadStr, _Msg,_P1, _P2) {}
#define DTrace1(_Mask,_LeadStr, _Msg,_P1) {}
#define DTrace(_Mask_, _LeadStr, _Msg_) {}
#define DPrintf(_Mask_,_Msg_) {}
#endif


#ifdef TRACE_PORT

#define ExtTrace4(_Ext_,_Mask_,_Msg_,_P1_,_P2_,_P3_, _P4_) \
  { if (_Ext_->TraceOptions & 1) Tprintf(_Msg_,_P1_,_P2_,_P3_,_P4_); }

#define ExtTrace3(_Ext_,_Mask_,_Msg_,_P1_,_P2_,_P3_) \
  { if (_Ext_->TraceOptions & 1) Tprintf(_Msg_,_P1_,_P2_,_P3_); }

#define ExtTrace2(_Ext_,_Mask_,_Msg_,_P1_,_P2_) \
  { if (_Ext_->TraceOptions & 1) Tprintf(_Msg_,_P1_,_P2_); }

#define ExtTrace1(_Ext_,_Mask_,_Msg_,_P1_) \
  { if (_Ext_->TraceOptions & 1) Tprintf(_Msg_,_P1_); }

#define ExtTrace(_Ext_,_Mask_,_Msg_) \
  { if (_Ext_->TraceOptions & 1) Tprintf(_Msg_); }
#else
#define ExtTrace3(_Mask_,_Msg_,_P1_,_P2_,_P3_) {}
#define ExtTrace2(_Mask_,_Msg_,_P1_,_P2_) {}
#define ExtTrace1(_Mask_,_Msg_,_P1_) {}
#define ExtTrace(_Mask_,_Msg_) {}
#endif

#if DBG
#define MyAssert( exp ) { if (!(exp)) MyAssertMessage(__FILE__, __LINE__); }

# ifdef S_VS
#define MyKdPrint(_Mask_,_Msg_) \
  { \
    if (_Mask_ & RocketDebugLevel) { \
      DbgPrint ("VS:"); \
      DbgPrint _Msg_; \
    } \
  } 
# else
#define MyKdPrint(_Mask_,_Msg_) \
  { \
    if (_Mask_ & RocketDebugLevel) { \
      DbgPrint ("RK:"); \
      DbgPrint _Msg_; \
    } \
  } 
# endif
#define MyKdPrintUnicode(_Mask_,_PUnicode_)\
  if(_Mask_ & RocketDebugLevel) \
    {  \
    ANSI_STRING tempstr; \
    RtlUnicodeStringToAnsiString(&tempstr,_PUnicode_,TRUE); \
    DbgPrint("%s",tempstr.Buffer);\
    RtlFreeAnsiString(&tempstr); \
    }
#else    
#define MyAssert( exp ) {}
#define MyKdPrint(_Mask_,_Msg_) {}
#define MyKdPrintUnicode(_Mask_,_PUnicode_) {}
#endif //DBG

#define SERIAL_NONE_PARITY  ((UCHAR)0x00)
#define SERIAL_ODD_PARITY   ((UCHAR)0x08)
#define SERIAL_EVEN_PARITY  ((UCHAR)0x18)
#define SERIAL_MARK_PARITY  ((UCHAR)0x28)
#define SERIAL_SPACE_PARITY ((UCHAR)0x38)
#define SERIAL_PARITY_MASK  ((UCHAR)0x38)

// This should be enough space to hold the numeric suffix of the device name.
// #define DEVICE_NAME_DELTA 20

// Default xon/xoff characters.
#define SERIAL_DEF_XON  0x11
#define SERIAL_DEF_XOFF 0x13

// Reasons that reception may be held up.
#define SERIAL_RX_DTR       ((ULONG)0x01)
#define SERIAL_RX_XOFF      ((ULONG)0x02)
#define SERIAL_RX_RTS       ((ULONG)0x04)
#define SERIAL_RX_DSR       ((ULONG)0x08)

// Reasons that transmission may be held up.
#define SERIAL_TX_CTS       ((ULONG)0x01)
#define SERIAL_TX_DSR       ((ULONG)0x02)
#define SERIAL_TX_DCD       ((ULONG)0x04)
#define SERIAL_TX_XOFF      ((ULONG)0x08)
#define SERIAL_TX_BREAK     ((ULONG)0x10)
#define ST_XOFF_FAKE        ((ULONG)0x20)  // added for SETXOFF(kpb)

// These values are used by the routines that can be used
// to complete a read (other than interval timeout) to indicate
// to the interval timeout that it should complete.
#define SERIAL_COMPLETE_READ_CANCEL ((LONG)-1)
#define SERIAL_COMPLETE_READ_TOTAL ((LONG)-2)
#define SERIAL_COMPLETE_READ_COMPLETE ((LONG)-3)

//--- flags for MdmCountry (ROW country code)
#define ROW_NOT_USED        0
#define ROW_AUSTRIA         1
#define ROW_BELGIUM         2
#define ROW_DENMARK         3
#define ROW_FINLAND         4
#define ROW_FRANCE          5
#define ROW_GERMANY         6
#define ROW_IRELAND         7
#define ROW_ITALY           8
#define ROW_LUXEMBOURG      9
#define ROW_NETHERLANDS     10
#define ROW_NORWAY          11
#define ROW_PORTUGAL        12
#define ROW_SPAIN           13
#define ROW_SWEDEN          14
#define ROW_SWITZERLAND     15
#define ROW_UK              16
#define ROW_GREECE          17
#define ROW_ISRAEL          18
#define ROW_CZECH_REP       19
#define ROW_CANADA          20
#define ROW_MEXICO          21
#define ROW_USA             22         
#define ROW_NA              ROW_USA         
#define ROW_HUNGARY         23
#define ROW_POLAND          24
#define ROW_RUSSIA          25
#define ROW_SLOVAC_REP      26
#define ROW_BULGARIA        27
// 28
// 29
#define ROW_INDIA           30
// 31
// 32
// 33
// 34
// 35
// 36
// 37
// 38
// 39
#define ROW_AUSTRALIA       40
#define ROW_CHINA           41
#define ROW_HONG_KONG       42
#define ROW_JAPAN           43
#define ROW_PHILIPPINES     ROW_JAPAN
#define ROW_KOREA           44
// 45
#define ROW_TAIWAN          46
#define ROW_SINGAPORE       47
#define ROW_NEW_ZEALAND     48

#define ROW_DEFAULT         ROW_USA



// Ext->DeviceType:  // DEV_PORT, DEV_DRIVER, DEV_BOARD
#define DEV_PORT   0
#define DEV_BOARD  1

/* Configuration information structure for one port */
typedef struct {
  char Name[12];
  ULONG LockBaud;
  ULONG TxCloseTime;
  int WaitOnTx : 1;
  int RS485Override : 1;
  int RS485Low : 1;
  int Map2StopsTo1 : 1;
  int MapCdToDsr : 1;
  int RingEmulate : 1;
} PORT_CONFIG;


/* Configuration information structure for one board or vs1000("device") */
typedef struct
{
#ifdef S_RK
   unsigned int MudbacIO;              /* I/O address of MUDBAC */
   PUCHAR pMudbacIO;                   /* NT ptrs to I/O address of MUDBAC */
   unsigned int BaseIoAddr;   // normal io-address
   unsigned int TrBaseIoAddr; // translated io-address
   PUCHAR       pBaseIoAddr;  // final indirect mapped handle for io-address
   unsigned int BaseIoSize;            /* 44H for 1st isa, 40 for isa addition, etc */
   unsigned int ISABrdIndex;           /* 0 for first, 1 for second, etc(isa only) */
   unsigned int AiopIO[AIOP_CTL_SIZE]; /* I/O addresses of AIOPs */
   PUCHAR pAiopIO[AIOP_CTL_SIZE];      /* NT ptrs to I/O address of AIOPs */
   //int NumChan;                        /* number of channels on this controller */
   // use NumPorts instead
   int NumAiop;                        /* number of Aiops on board */
   unsigned int RocketPortFound;       /* indicates ctl was found and init'd */
   INTERFACE_TYPE BusType;             /* PCIBus or Isa */
   int PCI_DevID;
   int PCI_RevID;
   int PCI_SVID;
   int PCI_SID;

   int Irq;
   int InterruptMode;
   int IrqLevel;
   int IrqVector;
   int Affinity;

   int TrInterruptMode;
   int TrIrqLevel;
   int TrIrqVector;
   int TrAffinity;

   int PCI_Slot;
   int BusNumber;

   int IsRocketPortPlus;  // true if rocketport plus hardware
#else
   int IsHubDevice;  // true if device(RHub) uses slower baud clock
#endif

  BOOLEAN HardwareStarted;

  BYTE MacAddr[6];      // vs1000
  int BackupServer;     // vs1000
  int BackupTimer;      // vs1000

  //int StartComIndex;   // starting com-port index
  ULONG Hardware_ID;     // software derived hardware id(used for nt50 now)
  ULONG IoAddress;      // user interface io-address selection

  int ModemDevice;       // true for RocketModems & Vs2000
  int NumPorts;         // configured number of ports on this device

  ULONG ClkRate;  // def:36864000=rcktport, 44236800=rplus, 18432000=rhub
  ULONG ClkPrescaler;  // def:14H=rcktport, 12H=rplus, 14H=rhub

#ifdef NT50
       // this holds the pnp-name we use as a registry key to hold
       // our device parameters in the registry for RocketPort & NT50
  char szNt50DevObjName[50];  // typical: "Device_002456
#else
  int  DevIndex;  // nt40 keeps simple linear list of devices 0,1,2...
#endif

  PORT_CONFIG port[MAX_PORTS_PER_DEVICE];  // our read in port configuration

} DEVICE_CONFIG;

#define TYPE_RM_VS2000  1       
#define TYPE_RMII       2       
#define TYPE_RM_i       3


// forward declaration
typedef struct _SERIAL_DEVICE_EXTENSION *PSERIAL_DEVICE_EXTENSION;

typedef struct _SERIAL_DEVICE_EXTENSION {
    USHORT DeviceType;  // DEV_PORT, DEV_BOARD
    USHORT BoardNum;    // 0,1,2,3 for DEV_BOARD type

    BOOLEAN         IsPDO;  // a nt50 pnp thing, tells if we are a pdo or fdo
    char NtNameForPort[32];     // like "RocketPort0"
    char SymbolicLinkName[16];  // like "COM5"
#ifdef S_VS
    //int box_num;  // index into box & hdlc array
    SerPort *Port;  // if a DEV_PORT type extension
    PortMan *pm;    // if a DEV_BOARD type extension
    Hdlc    *hd;    // if a DEV_BOARD type extension

    //int DeviceNum;  // index into total port array
#else
    CHANPTR_T ChP;                  // ptr to channel structure
    CHANNEL_T ch;                   // our board channel structure
#endif
    unsigned int UniqueId; // 0,1,2,3... CreateBoardDevice() bumps...

    // if we are DEV_BOARD, the this points to next board extension
    // if we are DEV_PORT, then it points to our parent board
    PSERIAL_DEVICE_EXTENSION   board_ext;

    // if we are DEV_BOARD, the this points to start of port extensions
    // if we are DEV_PORT, then it points to next port extension
    PSERIAL_DEVICE_EXTENSION   port_ext;  // next port extension

    // if we are DEV_BOARD, the this points to start of pdo port extensions
    PSERIAL_DEVICE_EXTENSION   port_pdo_ext;  // next pdo port extension

    ULONG BaudRate;                 // NT defined baud rate      
    SERIAL_LINE_CONTROL LineCtl;    // NT defined line control
    ULONG ModemStatus;              // NT defined modem status
    ULONG DTRRTSStatus;             // NT defined modem status

    USHORT DevStatus;     // device status

    //unsigned int FlowControl;
    //unsigned int DetectEn;
#ifdef S_RK
    USHORT io_reported; // flag to tell if we have io,irq to unreport.
    ULONG EventModemStatus;         // used to detect change for events
    unsigned int ModemCtl;
    unsigned int IntEnables;		// RP specific ints to enable
#endif
    int PortIndex;      // if port: index into ports on board(0,1,2..)

#ifdef TXBUFFER
    //PUCHAR TxBuf;
    //LONG TxIn;
    //LONG TxOut;
    //LONG TxBufSize;
#endif
    Queue RxQ;

    // Used to keep ISR from completing a read while it is being started.
    BOOLEAN ReadPending;

      // This value is set by the read code to hold the time value
      // used for read interval timing.  We keep it in the extension
      // so that the interval timer dpc routine determine if the
      // interval time has passed for the IO.
    LARGE_INTEGER IntervalTime;

      // These two values hold the "constant" time that we should use
      // to delay for the read interval time.
    LARGE_INTEGER ShortIntervalAmount;
    LARGE_INTEGER LongIntervalAmount;

      // This holds the value that we use to determine if we should use
      // the long interval delay or the short interval delay.
    LARGE_INTEGER CutOverAmount;

      // This holds the system time when we last time we had
      // checked that we had actually read characters.  Used
      // for interval timing.
    LARGE_INTEGER LastReadTime;

      // This points the the delta time that we should use to
      // delay for interval timing.
    PLARGE_INTEGER IntervalTimeToUse;

      // Points to the device object that contains
      // this device extension.
    PDEVICE_OBJECT DeviceObject;

      // This list head is used to contain the time ordered list
      // of read requests.  Access to this list is protected by
      // the global cancel spinlock.
    LIST_ENTRY ReadQueue;

      // This list head is used to contain the time ordered list
      // of write requests.  Access to this list is protected by
      // the global cancel spinlock.
    LIST_ENTRY WriteQueue;

      // Holds the serialized list of purge requests.
    LIST_ENTRY PurgeQueue;

      // This points to the irp that is currently being processed
      // for the read queue.  This field is initialized by the open to
      // NULL.
      // This value is only set at dispatch level.  It may be
      // read at interrupt level.
    PIRP CurrentReadIrp;

      // This points to the irp that is currently being processed
      // for the write queue.
      // This value is only set at dispatch level.  It may be
      // read at interrupt level.
    PIRP CurrentWriteIrp;

      // Points to the irp that is currently being processed to
      // purge the read/write queues and buffers.
    PIRP CurrentPurgeIrp;

      // Points to the current irp that is waiting on a comm event.
    PIRP CurrentWaitIrp;

      // Points to the irp that is being used to count the number
      // of characters received after an xoff (as currently defined
      // by the IOCTL_SERIAL_XOFF_COUNTER ioctl) is sent.
    PIRP CurrentXoffIrp;

      // Holds the number of bytes remaining in the current write irp.
      // This location is only accessed while at interrupt level.
    ULONG WriteLength;

      // The syncronization between the various threads in this
      // driver is hosed up in places, besides being really confusing.
      // This is an attempt to have a protected flag which is set
      // to 1 if the ISR owns the currentwriteirp, 2 if the ISR
      // is in the progress of ending the IRP(going to serialcompletewrite),
      // and 0 when it is complete.  The starter routine sets it
      // from 0 to 1 to give a new irp to the isr/timer routine for
      // processing.  The ISR sets it from 1 to 2 when it queues
      // the DPC to finalize the irp.  The DPC sets it from 2 to
      // 0 when it completes the irp.  The cancel or timer routines
      // must run a synchronized routine which guarentees sole access
      // to this flag.  Looks if it is 1, if it is 1 then it takes
      // by setting it to zero, and returning a flag to indicate to
      // the caller to finalize the irp.  If it is a 2, it assumes
      // the isr has arranged to finalize the irp.  Geez-O-Pete
      // what a lot of silly gears!
    ULONG WriteBelongsToIsr;

      // Holds a pointer to the current character to be sent in
      // the current write.
      // This location is only accessed while at interrupt level.
    PUCHAR WriteCurrentChar;

      // This variable holds the size of whatever buffer we are currently
      // using.
    ULONG BufferSize;

      // This variable holds .8 of BufferSize. We don't want to recalculate
      // this real often - It's needed when so that an application can be
      // "notified" that the buffer is getting full.
    ULONG BufferSizePt8;

      // This value holds the number of characters desired for a
      // particular read.  It is initially set by read length in the
      // IRP.  It is decremented each time more characters are placed
      // into the "users" buffer buy the code that reads characters
      // out of the typeahead buffer into the users buffer.  If the
      // typeahead buffer is exhausted by the read, and the reads buffer
      // is given to the isr to fill, this value is becomes meaningless.
    ULONG NumberNeededForRead;

      // This mask will hold the bitmask sent down via the set mask
      // ioctl.  It is used by the interrupt service routine to determine
      // if the occurence of "events" (in the serial drivers understanding
      // of the concept of an event) should be noted.
    ULONG IsrWaitMask;

      // This mask will always be a subset of the IsrWaitMask.  While
      // at device level, if an event occurs that is "marked" as interesting
      // in the IsrWaitMask, the driver will turn on that bit in this
      // history mask.  The driver will then look to see if there is a
      // request waiting for an event to occur.  If there is one, it
      // will copy the value of the history mask into the wait irp, zero
      // the history mask, and complete the wait irp.  If there is no
      // waiting request, the driver will be satisfied with just recording
      // that the event occured.  If a wait request should be queued,
      // the driver will look to see if the history mask is non-zero.  If
      // it is non-zero, the driver will copy the history mask into the
      // irp, zero the history mask, and then complete the irp.
    ULONG HistoryMask;

      // This is a pointer to the where the history mask should be
      // placed when completing a wait.  It is only accessed at
      // device level.
      // We have a pointer here to assist us to synchronize completing a wait.
      // If this is non-zero, then we have wait outstanding, and the isr still
      // knows about it.  We make this pointer null so that the isr won't
      // attempt to complete the wait.
      // We still keep a pointer around to the wait irp, since the actual
      // pointer to the wait irp will be used for the "common" irp completion
      // path.
    ULONG *IrpMaskLocation;
    ULONG WaitIsISRs;  // 1=owned by isr.c(expicit help)
    ULONG DummyIrpMaskLoc;  // Point the IrpMaskLocation here when not in use

      // This mask holds all of the reason that transmission
      // is not proceeding.  Normal transmission can not occur
      // if this is non-zero.
      // This is only written from interrupt level.
      // This could be (but is not) read at any level.
    ULONG TXHolding;

      // This mask holds all of the reason that reception
      // is not proceeding.  Normal reception can not occur
      // if this is non-zero.
      // This is only written from interrupt level.
      // This could be (but is not) read at any level.
    ULONG RXHolding;

      // This holds the reasons that the driver thinks it is in
      // an error state.
      // This is only written from interrupt level.
      // This could be (but is not) read at any level.
    ULONG ErrorWord;

      // This keeps a total of the number of characters that
      // are in all of the "write" irps that the driver knows
      // about.  It is only accessed with the cancel spinlock
      // held.
    ULONG TotalCharsQueued;

      // This holds a count of the number of characters read
      // the last time the interval timer dpc fired.  It
      // is a long (rather than a ulong) since the other read
      // completion routines use negative values to indicate
      // to the interval timer that it should complete the read
      // if the interval timer DPC was lurking in some DPC queue when
      // some other way to complete occurs.
    LONG CountOnLastRead;

      // This is a count of the number of characters read by the
      // isr routine.  It is *ONLY* written at isr level.  We can
      // read it at dispatch level.
    ULONG ReadByIsr;

      // This is the number of characters read since the XoffCounter
      // was started.  This variable is only accessed at device level.
      // If it is greater than zero, it implies that there is an
      // XoffCounter ioctl in the queue.
    LONG CountSinceXoff;

      // Holds the timeout controls for the device.  This value
      // is set by the Ioctl processing.
      // It should only be accessed under protection of the control
      // lock since more than one request can be in the control dispatch
      // routine at one time.
    SERIAL_TIMEOUTS Timeouts;

      // This holds the various characters that are used
      // for replacement on errors and also for flow control.
      // They are only set at interrupt level.
    SERIAL_CHARS SpecialChars;

      // This structure holds the handshake and control flow
      // settings for the serial driver.
      // It is only set at interrupt level.  It can be
      // be read at any level with the control lock held.
    SERIAL_HANDFLOW HandFlow;

      // We keep track of whether the somebody has the device currently
      // opened with a simple boolean.  We need to know this so that
      // spurious interrupts from the device (especially during initialization)
      // will be ignored.  This value is only accessed in the ISR and
      // is only set via synchronization routines.  We may be able
      // to get rid of this boolean when the code is more fleshed out.
    BOOLEAN DeviceIsOpen;

      // Records whether we actually created the symbolic link name
      // at driver load time.  If we didn't create it, we won't try
      // to distry it when we unload.
    BOOLEAN CreatedSymbolicLink;

      // We place all of the kernel and Io subsystem "opaque" structures
      // at the end of the extension.  We don't care about their contents.
      // This lock will be used to protect various fields in
      // the extension that are set (& read) in the extension
      // by the io controls.
    KSPIN_LOCK ControlLock;

      // This points to a DPC used to complete read requests.
    KDPC CompleteWriteDpc;

      // This points to a DPC used to complete read requests.
    KDPC CompleteReadDpc;

      // This dpc is fired off if the timer for the total timeout
      // for the read expires.  It will execute a dpc routine that
      // will cause the current read to complete.
    KDPC TotalReadTimeoutDpc;

      // This dpc is fired off if the timer for the interval timeout
      // expires.  If no more characters have been read then the
      // dpc routine will cause the read to complete.  However, if
      // more characters have been read then the dpc routine will
      // resubmit the timer.
    KDPC IntervalReadTimeoutDpc;

      // This dpc is fired off if the timer for the total timeout
      // for the write expires.  It will execute a dpc routine that
      // will cause the current write to complete.
    KDPC TotalWriteTimeoutDpc;

      // This dpc is fired off if a comm error occurs.  It will
      // execute a dpc routine that will cancel all pending reads
      // and writes.
    KDPC CommErrorDpc;

      // This dpc is fired off if an event occurs and there was
      // a irp waiting on that event.  A dpc routine will execute
      // that completes the irp.
    KDPC CommWaitDpc;

      // This dpc is fired off if the timer used to "timeout" counting
      // the number of characters received after the Xoff ioctl is started
      // expired.
    KDPC XoffCountTimeoutDpc;

      // This dpc is fired off if the xoff counter actually runs down
      // to zero.
    KDPC XoffCountCompleteDpc;

      // This is the kernal timer structure used to handle
      // total read request timing.
    KTIMER ReadRequestTotalTimer;

      // This is the kernal timer structure used to handle
      // interval read request timing.
    KTIMER ReadRequestIntervalTimer;

      // This is the kernal timer structure used to handle
      // total time request timing.
    KTIMER WriteRequestTotalTimer;

      // This timer is used to timeout the xoff counter
      // io.
    KTIMER XoffCountTimer;

    USHORT sent_packets;   // number of write() packets
    USHORT  rec_packets;    // number of read() packets

    SERIALPERF_STATS OurStats;  // our non-resetable stats
    SERIALPERF_STATS OldStats;  // performance monitor statistics(resetable)

    USHORT TraceOptions;  // Debug Trace Options. 1=trace, 2=in data, 4=out dat
       // 8 = isr level events

    USHORT ISR_Flags;  // bit flags used to control ISR, detects EV_TXEMPTY
        // used by NT virt-driver to embed modem status changes in input stream
    unsigned char escapechar; 
    unsigned char Option;  // used for per port options
                                 
    void *TraceExt;  // Debug Trace Extension

    PORT_CONFIG *port_config; // if a port extension, points to port config data
    DEVICE_CONFIG *config;    // if a board extension, points to config data

    //KEVENT SerialSyncEvent;
#ifdef S_RK
    CONTROLLER_T *CtlP; // if a board extension, points to controller struct
#endif

    // This is to tell the driver that we have received a QUERY_POWER asking 
    // to power down.  The driver will then queue any open requests until after
    // the power down.
    BOOLEAN ReceivedQueryD3;
#ifdef NT50
    PDEVICE_OBJECT  Pdo;  // new PnP object used to open registry.
    PDEVICE_OBJECT  LowerDeviceObject;  // new PnP stack arrangement.
    // This is where keep track of the power state the device is in.
    DEVICE_POWER_STATE PowerState;

    // String where we keep the symbolic link that is returned to us when we
    // register our device under the COMM class with the Plug and Play manager.
    //
	UNICODE_STRING  DeviceClassSymbolicName;
#endif
    // Count of pending IRP's
    ULONG PendingIRPCnt;
    
    // Accepting requests?
    ULONG DevicePNPAccept;

    // No IRP's pending event
    KEVENT PendingIRPEvent;

    // PNP State
    ULONG PNPState;

    // Used by PnP.c module
    //BOOLEAN DeviceIsOpened;

    BOOLEAN FdoStarted;

#ifdef RING_FAKE
    BYTE ring_char;   // used to implement RING emulation via software
    BYTE ring_timer;  // used to implement RING emulation via software
#endif

#ifdef NT50
    // WMI Information
    WMILIB_CONTEXT WmiLibInfo;

    // Name to use as WMI identifier
    UNICODE_STRING WmiIdentifier;

    // WMI Comm Data
    SERIAL_WMI_COMM_DATA WmiCommData;

    // WMI HW Data
    SERIAL_WMI_HW_DATA WmiHwData;

    // WMI Performance Data
    SERIAL_WMI_PERF_DATA WmiPerfData;
#endif

} SERIAL_DEVICE_EXTENSION,*PSERIAL_DEVICE_EXTENSION;

//--- bits for Option field in extension
#define OPTION_RS485_OVERRIDE    0x0001  // always use 485 mode
#define OPTION_RS485_SOFTWARE_TOGGLE 0x0002  // port in toggle mode
#define OPTION_RS485_HIGH_ACTIVE  0x0004  // use hardware to toggle rts low

//--- bit flags for ISR_Flags
#define TX_NOT_EMPTY       0x0001

#define SERIAL_PNPACCEPT_OK       0x0L
#define SERIAL_PNPACCEPT_REMOVING 0x1L
#define SERIAL_PNPACCEPT_STOPPING 0x2L
#define SERIAL_PNPACCEPT_STOPPED  0x4L

#define SERIAL_PNP_ADDED          0x0L
#define SERIAL_PNP_STARTED        0x1L
#define SERIAL_PNP_QSTOP          0x2L
#define SERIAL_PNP_STOPPING       0x3L
#define SERIAL_PNP_QREMOVE        0x4L
#define SERIAL_PNP_REMOVING       0x5L

#define SERIAL_FLAGS_CLEAR	  0x0L
#define SERIAL_FLAGS_STARTED      0x1L

typedef struct _DRIVER_CONTROL {

    PDRIVER_OBJECT GlobalDriverObject;

    // copy of RegistryPath into DriverEntry, with room for adding options
    UNICODE_STRING RegPath;

    // working global RegistryPath string, , with room for adding options
    UNICODE_STRING OptionRegPath;

    // head link of all board extensions
    PSERIAL_DEVICE_EXTENSION board_ext;

    USHORT VerboseLog;   // boolean flag tells to log verbose to eventlog.
    USHORT ScanRate;     // scan rate in milliseconds
    USHORT PreScaler;    // optional prescaler value for rocketport boards

    USHORT MdmCountryCode; // country code for ROW RocketModems
    USHORT MdmSettleTime;  // time to allow modems to settle (unit=0.10 sec)

    ULONG  load_testing;  // load testing(creates artificial load in isr.c)
#ifdef S_VS

    // This is the names of the NIC cards which we get from the Registry.
    // Used to specify the nic card when we do an OpenAdapter call.
    char *BindNames;  // list of strings, null, null terminated [VS1000_MAX_BINDINGS];

#ifdef OLD_BINDING_GATHER
    PWCHAR BindString;  // binding in registry, tells us what nic cards we have

    // This is the names of the NIC cards which we get from the Registry.
    // Used to specify the nic card when wee do an OpenAdapter call.
    UNICODE_STRING NicName[VS1000_MAX_BINDINGS];

    int num_nics;  // number of nic cards in system which we use

    int num_bindings;  // number of nic card bindings in our NicName list
      // there may be lots of old useless bindings with NT, PCI adapters
      // leave an old binding resident for each slot they are booted in
      // under nt50, pcmcia adapters also have inactive bindings.

#endif

#ifdef TRY_DYNAMIC_BINDING
    // bind passes in a handle as a reference, when we get an un-bind
    // we get passed in another handle.  At unbind time, we look up in
    // this table to figure which nic card it references.
    NDIS_HANDLE  BindContext[VS1000_MAX_NICS];
#endif

    Nic *nics;    // our open nic adapters, array of Nic structs.

    //Hdlc *hd;     // array of Hdlc structs(NumBoxes # of elements)
    //PortMan *pm;  // array of PortMan structs(NumBoxes # of elements)
    //SerPort *sp;  // total array of serial-port structs(1 per port)

      // tells if thread needs to save off a detected mac-address back
      // to config reg area.
    PSERIAL_DEVICE_EXTENSION AutoMacDevExt; 
#endif

#ifdef S_RK
    ULONG SetupIrq;  // Irq used, 0 if none, 1 if PCI automatic
#endif
    PKINTERRUPT InterruptObject;

    // Timer fields
    KTIMER PollTimer;
    LARGE_INTEGER PollIntervalTime;
    KDPC TimerDpc;
    //USHORT TotalNTPorts;  // count of ports registered with NT
    ULONG PollCnt;  // count of interrupts/timer ticks
    ULONG WriteDpcCnt;
    USHORT TimerCreated;
    USHORT InRocketWrite;

    ULONG TraceOptions;  // bit flags, tells what driver parts to trace
    ULONG TraceFlags;
    Queue DebugQ;        // data output buffer for driver debug log
    PSERIAL_DEVICE_EXTENSION DebugExt;
    KSPIN_LOCK DebugLock;
    ULONG DebugTimeOut;  // used to timeout inactive debug sessions.

#ifdef S_RK
    USHORT RS485_Flags;  // 1H bit set if Reverse hardware type
                         //       clear if driver toggles RTS high
#endif

    ULONG GTraceFlags;  // trace flags, global.
    ULONG mem_alloced;  // track how much memory we are using

#ifdef S_VS
    UCHAR *MicroCodeImage;  // mem buf for micro code to download to unit
    ULONG MicroCodeSize;    // size of it in bytes

    // This is the handle for the protocol returned by ndisregisterprotocol
    NDIS_HANDLE NdisProtocolHandle;
    ULONG ndis_version;  // 3=NT3.51, 4=NT4.0(includes dynamic binding)

      // for auto-find boxes, make a list of boxes which respond with
      // there mac address.  Keep 2 extra bytes, byte [6] is for
      // flags in response tells us if main-driver-app loaded, 
      // while last byte[7] we stuff with the nic-index which responded.
    int   NumBoxMacs;
    BYTE  BoxMacs[MAX_NUM_BOXES*8];
    // following is a counter per mac-address added to list where
    // the list entry will be removed after it ticks down to zero.
    // when the mac-address is added to the list or found again,
    // the counter is initialized to some non-zero value(say 5)
    // and then each time a broadcast query is sent out, all the
    // counters are decremented by 1.  When they hit zero, they
    // are removed from the list.
    BYTE  BoxMacsCounter[MAX_NUM_BOXES];
#else

    UCHAR *ModemLoaderCodeImage;	// --> mem buf for modem loader code to download to unit
    ULONG ModemLoaderCodeSize;		// size in bytes

    UCHAR *ModemCodeImage;		// --> mem buf for modem code to download to unit
    ULONG ModemCodeSize;		// size in bytes
#endif

    int NoPnpPorts;  // flag to tell if we should eject port pdo's
#ifdef S_RK
    PSERIAL_DEVICE_EXTENSION irq_ext; // board ext doing global irq, null if not used
#endif
    //int NT50_PnP;

    int NumDevices; // configuration count of NumDevices for NT4.0
    int Stop_Poll;  // flag to stop poll access

    KSPIN_LOCK TimerLock;   // Timer DPC(ISR) lock to sync up code
#ifdef S_VS
    HANDLE threadHandle;
    int threadCount;
    //int TotalNTPorts;  // this should go away(vs uses it)
#endif
   LARGE_INTEGER IsrSysTime;  // ISR service routine gets this every time
                              // so we know what are time base is.
   LARGE_INTEGER LastIsrSysTime;  // used to recalculate the tick rate periodically
   ULONG TickBaseCnt;  // used to recalculate the tick rate periodically
     // this is the isr-tick rate in 100us units.  Timers called by the
     // isr-service routine can assume they are called periodically based
     // on this rate.  Needed for accurate time bases(VS protocol timers).
   ULONG Tick100usBase;

   // one of these made, and is used to support the global driver
   // object which the applications can open and talk to driver.
   PSERIAL_DEVICE_EXTENSION   driver_ext;

} DRIVER_CONTROL;

typedef struct {
	char	*imagepath;
	char	*imagetype;
	UCHAR	*image;
	ULONG	imagesize;
	int		rc;
} MODEM_IMAGE;

/* Configuration information structure for one port */
typedef struct {
  ULONG BusNumber;
  ULONG PCI_Slot;
  ULONG PCI_DevID;
  ULONG PCI_RevID;
  ULONG BaseIoAddr;
  ULONG Irq;
  ULONG NumPorts;
  ULONG PCI_SVID;
  ULONG PCI_SID;
  ULONG Claimed;  // 1 if we assigned or used it.
} PCI_CONFIG;

typedef
NTSTATUS
(*PSERIAL_START_ROUTINE) (
    IN PSERIAL_DEVICE_EXTENSION
    );

typedef
VOID
(*PSERIAL_GET_NEXT_ROUTINE) (
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent,
    PSERIAL_DEVICE_EXTENSION Extension
    );

typedef struct _SERIAL_UPDATE_CHAR {
    PSERIAL_DEVICE_EXTENSION Extension;
    ULONG CharsCopied;
    BOOLEAN Completed;
    } SERIAL_UPDATE_CHAR,*PSERIAL_UPDATE_CHAR;

//
// The following simple structure is used to send a pointer
// the device extension and an ioctl specific pointer
// to data.
//
typedef struct _SERIAL_IOCTL_SYNC {
    PSERIAL_DEVICE_EXTENSION Extension;
    PVOID Data;
    } SERIAL_IOCTL_SYNC,*PSERIAL_IOCTL_SYNC;

//
// Return values for mouse detection callback
//
//#define SERIAL_FOUNDPOINTER_PORT   1
//#define SERIAL_FOUNDPOINTER_VECTOR 2

//
// The following three macros are used to initialize, increment
// and decrement reference counts in IRPs that are used by
// this driver.  The reference count is stored in the fourth
// argument of the irp, which is never used by any operation
// accepted by this driver.
//
#define SERIAL_REF_ISR         (0x00000001)
#define SERIAL_REF_CANCEL      (0x00000002)
#define SERIAL_REF_TOTAL_TIMER (0x00000004)
#define SERIAL_REF_INT_TIMER   (0x00000008)
#define SERIAL_REF_XOFF_REF    (0x00000010)


#define SERIAL_INIT_REFERENCE(Irp) { \
    ASSERT(sizeof(LONG) <= sizeof(PVOID)); \
    IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4 = NULL; \
    }

#define SERIAL_SET_REFERENCE(Irp,RefType) \
   do { \
       LONG _refType = (RefType); \
       PLONG _arg4 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4; \
       GAssert(515,!(*_arg4 & _refType)); \
       *_arg4 |= _refType; \
   } while (0)

#define SERIAL_CLEAR_REFERENCE(Irp,RefType) \
   do { \
       LONG _refType = (RefType); \
       PLONG _arg4 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4; \
       *_arg4 &= ~_refType; \
   } while (0)
       //GAssert(516,*_arg4 & _refType); \  (pull out, not valid, kpb, 1-18-98)

//#define SERIAL_INC_REFERENCE(Irp) \
//   ((*((LONG *)(&(IoGetCurrentIrpStackLocation((Irp)))->Parameters.Others.Argument4)))++)

//#define SERIAL_DEC_REFERENCE(Irp) \
//   ((*((LONG *)(&(IoGetCurrentIrpStackLocation((Irp)))->Parameters.Others.Argument4)))--)

#define SERIAL_REFERENCE_COUNT(Irp) \
    ((LONG)((IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4)))

extern ULONG RocketDebugLevel;
extern DRIVER_CONTROL Driver;   // driver related options and references

#ifdef S_RK
extern PCI_CONFIG PciConfig[MAX_NUM_BOXES+1];  // array of all our pci-boards in sys
#endif

extern  int	LoadModemCode(char *firm_pathname,char *flm_pathname);
extern  void FreeModemFiles();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\initc.c ===
/*----------------------------------------------------------------------
  initc.c - init, common code(pull out of custom init.c, put in here)
 1-27-99 - take out "\device\" in hardware\serialcomm reg entries, kpb.
 1-20-99 - adjust unique_id in CreatePortDevice to start names at "RocketPort0".
 1-25-99 - adjust again from "\Device\RocketPort0" to "RocketPort0".  kpb.
|----------------------------------------------------------------------*/
#include "precomp.h"

//------------ local variables -----------------------------------
static int CheckPortName(IN OUT char *name,
                         IN PSERIAL_DEVICE_EXTENSION extension);
static int IsPortNameInHardwareMap(char *name);

static char *szDosDevices = {"\\DosDevices\\"};
static char *szDevice     = {"\\Device\\"};
#ifdef S_RK
static char *szRocket = {"rocket"};
static char *szRocketSys = {"rocketsys"};
#else
char *szRocket = {"vslinka"};
char *szRocketSys = {"vslinkasys"};

#endif

typedef struct
{
  char  *response[2];
  int   response_length[2];
  int   nextstate[2];
} MSTATE_CHOICE;

static USHORT ErrNum = 1;  // used with event logging

#define SEND_CMD_STRING(portex,string) \
  ModemWrite(portex,(char *)string,sizeof(string) - 1)

#define SEND_CMD_DELAY_STRING(portex,string) \
  ModemWriteDelay(portex,(char *)string,sizeof(string) - 1)

#define READ_RESPONSE_STRINGS(portex,s0,s1,retries) \
  ModemReadChoice(portex,(char *)s0,sizeof(s0) - 1,(char *)s1,sizeof(s1) - 1,retries)

#define READ_RESPONSE_STRING(portex,string,retries) \
  ModemRead(portex,(char *)string,sizeof(string) - 1,retries)

#define  ONE_SECOND     10
#define  TWO_SECONDS    (2 * ONE_SECOND)
#define  THREE_SECONDS  (3 * ONE_SECOND)
#define  FOUR_SECONDS   (4 * ONE_SECOND)
#define  FIVE_SECONDS   (5 * ONE_SECOND)
#define  TENTH_SECOND   (ONE_SECOND / 10)
#define  HALF_SECOND    (ONE_SECOND / 2)

#define  MAX_MODEM_ATTEMPTS 3

#ifdef S_RK

#define  MAX_STALL                      50              // fifo stall count

#define RMODEM_FAILED           0
#define RMODEM_NOT_LOADED       1
#define RMODEM_LOADED           2

#define VERSION_CHAR            'V'

char ChecksumString[16];
int      gModemToggle = 0;

typedef struct {
  int                   status;
  unsigned long index;
  PSERIAL_DEVICE_EXTENSION  portex;
} MODEM_STATE;


//------------ local variables -----------------------------------
void    ModemTxFIFOWait(PSERIAL_DEVICE_EXTENSION ext);
void    ModemResetAll(PSERIAL_DEVICE_EXTENSION ext);
void    ChecksumAscii(unsigned short *valueptr);
int     IssueEvent(PSERIAL_DEVICE_EXTENSION ext,int (*modemfunc)(),MODEM_STATE *pModemState);
void    DownModem(MODEM_STATE *pModemState);
#endif


/*----------------------------------------------------------------------
SerialUnload -
    This routine cleans up all of the memory associated with
    any of the devices belonging to the driver.  It  will
    loop through the device list.
Arguments:
    DriverObject - Pointer to the driver object controling all of the
        devices.
Return Value:
    None.
|----------------------------------------------------------------------*/
VOID SerialUnload (IN PDRIVER_OBJECT DriverObject)
{
  PDEVICE_OBJECT currentDevice = DriverObject->DeviceObject;
  // char full_sysname[40];
#ifdef S_VS
  int i;
#endif //S_VS

#ifdef S_RK
  if (Driver.InterruptObject != NULL)
  {
    CONTROLLER_T *CtlP;                 /* ptr to controller structure */
    // Disable interupts from RocketPort clear the EOI and
    CtlP = Driver.irq_ext->CtlP;
    if(CtlP->BusType == Isa)
    {
   MyKdPrint(D_Init,("Clear ISA IRQ\n"))
   sDisGlobalInt(CtlP);
   sControllerEOI(CtlP);
    }
    if(CtlP->BusType == PCIBus)
    {
   MyKdPrint(D_Init,("Clear PCI IRQ\n"))
   sDisGlobalIntPCI(CtlP);
   sPCIControllerEOI(CtlP);
    }

    IoDisconnectInterrupt(Driver.InterruptObject);
    Driver.InterruptObject = NULL;
  }
#endif

#ifdef S_VS
  if (Driver.threadHandle != NULL)
  {
    ZwClose(Driver.threadHandle);
    Driver.threadHandle = NULL;  // tell thread to kill itself
    time_stall(15);  // wait 1.5 second
  }
#endif

  if (Driver.TimerCreated != 0)
  {
    KeCancelTimer(&Driver.PollTimer);
    Driver.TimerCreated = 0;
  }

  if (DriverObject->DeviceObject != NULL)
  {
    // delete all the Deviceobjects and symbolic links
    RcktDeleteDevices(DriverObject);
    DriverObject->DeviceObject = NULL;
  }

#ifdef S_VS
  if (Driver.MicroCodeImage != NULL)
  {
    our_free(Driver.MicroCodeImage, "MCI");
    Driver.MicroCodeImage = NULL;
  }

  if (Driver.nics != NULL)
  {
    for (i=0; i<VS1000_MAX_NICS; i++)
    {
      if (Driver.nics[i].NICHandle != NULL) {
        NicClose(&Driver.nics[i]);
      }
    }
    our_free(Driver.nics, "nics");
  }
  Driver.nics = NULL;

  if (Driver.NdisProtocolHandle != NULL)
    NicProtocolClose();
  Driver.NdisProtocolHandle = NULL;

  if (Driver.BindNames != NULL)
      ExFreePool(Driver.BindNames);
  Driver.BindNames = NULL;
#endif

  if (Driver.DebugQ.QBase)
  {
    ExFreePool(Driver.DebugQ.QBase);
    Driver.DebugQ.QBase = NULL;
  }

  if (Driver.RegPath.Buffer != NULL)
  {
    ExFreePool(Driver.RegPath.Buffer);
    Driver.RegPath.Buffer = NULL;
  }

  if (Driver.OptionRegPath.Buffer != NULL)
  {
    ExFreePool(Driver.OptionRegPath.Buffer);
    Driver.OptionRegPath.Buffer = NULL;
  }
}

/*----------------------------------------------------------------------
  CreateDriverDevice - Create "rocket" driver object, this is for access to the
   driver as a whole.  The monitoring program uses this to open up
   a channel to get driver information.
   Creates a symbolic link name to do special IOctl calls
|----------------------------------------------------------------------*/
NTSTATUS CreateDriverDevice(IN PDRIVER_OBJECT DriverObject,
	   OUT PSERIAL_DEVICE_EXTENSION *DeviceExtension)
{
 PDEVICE_OBJECT deviceObject = NULL;
 NTSTATUS       ntStatus;
 PSERIAL_DEVICE_EXTENSION extension = NULL;
 char full_ntname[40];
 char full_symname[40];

  MyKdPrint(D_Init,("CreateDriverDevice\n"))

  // Create an device object
  {
    strcpy(full_ntname,szDevice);     // "\\Device\\"
    strcat(full_ntname,szRocketSys);  // "RocketSys"

    // special name
    strcpy(full_symname,szDosDevices);  // "\\DosDevices\\"
    strcat(full_symname,szRocket);      // "ROCKET" or "VSLINKA"

    ntStatus = IoCreateDevice(
      DriverObject,
      sizeof(SERIAL_DEVICE_EXTENSION),
      CToU1(full_ntname),
//#ifdef NT50
//                 FILE_DEVICE_BUS_EXTENDER,
//#else
      0,  // unknown device?   ,  so make a 0 device(unknown?)
//#endif
      0,      // file characteristics
      FALSE,  // exclusive?
      &deviceObject);  // create this

    if (!NT_SUCCESS(ntStatus))
    {
      MyKdPrint(D_Init,("Err CDD1A\n"))
      switch (ntStatus)
      {
	case STATUS_INSUFFICIENT_RESOURCES:
	  MyKdPrint(D_Init,("Err CDD1B\n"))
	break;

	case STATUS_OBJECT_NAME_EXISTS:
	  MyKdPrint(D_Init,("Err CDD1C\n"))
	break;

	case STATUS_OBJECT_NAME_COLLISION:
	  MyKdPrint(D_Init,("Err CDD1D\n"))
	break;

	default:
	  MyKdPrint(D_Init,("Err CDD1E\n"))
	break;
      }
      return(ntStatus);
    }

    MyKdPrint(D_Init,("CreateDriver DevObj[%x]: NT:%s\n", 
      deviceObject, szRocketSys))

    //
    // Create a symbolic link, e.g. a name that a Win32 app can specify
    // to open the device
    //
    // initialize some of the extension values to make it look like
    // another serial port to fake out the supporting functions
    // ie open,close, ...

    deviceObject->Flags |= DO_BUFFERED_IO;
#ifdef NT50
    //
    // Enables Irp assignments to be accepted
    //
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
#endif

    extension = deviceObject->DeviceExtension;
    // Initialize the list heads for the read, write, and mask queues.
    // These lists will hold all of the queued IRP's for the device.
    InitializeListHead(&extension->ReadQueue);
    InitializeListHead(&extension->WriteQueue);
    InitializeListHead(&extension->PurgeQueue);

    KeInitializeEvent(&extension->PendingIRPEvent, SynchronizationEvent,
      FALSE);

    // init to 1, so on irp enter its 1 to 2, on exit 2 to 1.  0 on pnp stop.
    extension->PendingIRPCnt = 1;

    // Mark this device as not being opened by anyone.  We keep a
    // variable around so that spurious interrupts are easily
    // dismissed by the ISR.
    extension->DeviceIsOpen = FALSE;
    extension->WriteLength = 0;
    extension->DeviceObject = deviceObject;

    strcpy(extension->NtNameForPort, szRocketSys);  // "RocketSys"
    extension->DeviceType = DEV_BOARD;  // really a driver type, but..
    extension->UniqueId = 0;

#ifdef NT50
    extension->PowerState = PowerDeviceD0;
#endif

    //------ add to the global links
    Driver.driver_ext = extension;

    // make the public ROCKET or VSLINKA name for applications
    ntStatus = IoCreateSymbolicLink(CToU1(full_symname),
	     CToU2(full_ntname));

    if (!NT_SUCCESS(ntStatus))
    {
      // Symbolic link creation failed- note this & then delete th
      MyKdPrint(D_Init,("CDD1E\n"))
      return(ntStatus);
    }
    extension->CreatedSymbolicLink = TRUE;

    strcpy(extension->SymbolicLinkName, szRocket);  // "ROCKET"
    //Driver.RocketSysDeviceObject = deviceObject;  //set global device object

    //extension->config = ExAllocatePool(NonPagedPool, sizeof(DEVICE_CONFIG));
    //RtlZeroMemory(extension->config, sizeof(DEVICE_CONFIG));
#ifdef S_RK
    //extension->CtlP = ExAllocatePool(NonPagedPool, sizeof(CONTROLLER_T));
    //RtlZeroMemory(extension->config, sizeof(CONTROLLER_T));
#endif
    //------- Pass back the extension to the caller.
    if (DeviceExtension != NULL)
      *DeviceExtension = extension;
  }
  return(ntStatus);
}

/*----------------------------------------------------------------------
  CreateBoardDevice - Create "rocket" driver object, this is for access to the
   driver as a whole.  The monitoring program uses this to open up
   a channel to get driver information.
   Creates a symbolic link name to do special IOctl calls

   Need one for each board so we can use them to do IOReportResources
   per board(needed for diferent buses.)
   The first board device gets a "ROCKET" symbolic link so we can
   open it and query the driver as a whole.
|----------------------------------------------------------------------*/
NTSTATUS CreateBoardDevice(IN PDRIVER_OBJECT DriverObject,
	  OUT PSERIAL_DEVICE_EXTENSION *DeviceExtension)
{
  PDEVICE_OBJECT deviceObject = NULL;
  NTSTATUS       ntStatus;
  PSERIAL_DEVICE_EXTENSION extension = NULL;
  char full_ntname[40];
  char full_symname[40];
  char ntname[40];

  // for naming device objects, resource submitting, etc we need a
  // unique name or id which is unique to the driver.  We used to
  // use board number or port number for this, but with pnp, things
  // come and go on the fly, so instead we create a unique number
  // each time we create one of these things.
  static int unique_id = 0;

  MyKdPrint(D_Init,("CreateBoardDevice\n"))

  // Create an EXCLUSIVE device object (only 1 thread at a time
  // can make requests to this device)
  {
    strcpy(ntname, szRocketSys);
    our_ultoa(unique_id, &ntname[strlen(ntname)], 10);
    strcpy(full_ntname,szDevice);     // "\\Device\\"
    strcat(full_ntname,ntname);  // "RocketPort#"

    full_symname[0] = 0;

    ntStatus = IoCreateDevice(
      DriverObject,
      sizeof(SERIAL_DEVICE_EXTENSION),
      CToU1(full_ntname),
#ifdef NT50
      FILE_DEVICE_BUS_EXTENDER,
#else
      0,  // unknown device?   ,  so make a 0 device(unknown?)
#endif
      0,      // file characteristics
      FALSE,  // exclusive?
      &deviceObject);  // create this

    if (!NT_SUCCESS(ntStatus))
    {
      MyKdPrint(D_Error,("CBD1A\n"))
      switch (ntStatus)
      {
	case STATUS_INSUFFICIENT_RESOURCES:
	  MyKdPrint(D_Error,("CBD1B\n"))
	  break;
	case STATUS_OBJECT_NAME_EXISTS:
	  MyKdPrint(D_Error,("CBD1C\n"))
	  break;
	case STATUS_OBJECT_NAME_COLLISION:
	  MyKdPrint(D_Error,("CBD1D\n"))
	  break;
	default:
	  MyKdPrint(D_Error,("CBD1E\n"))
	  break;
      }
      return(ntStatus);
    }

    ++unique_id;  // go to next id so next call will be different.

    // Create a symbolic link, e.g. a name that a Win32 app can specify
    // to open the device
    //
    // initialize some of the extension values to make it look like
    // another serial port to fake out the supporting functions
    // ie open,close, ...

    deviceObject->Flags |= DO_BUFFERED_IO;
#ifdef NT50
    //
    // Enables Irp assignments to be accepted
    //
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
#endif

    MyKdPrint(D_Init,("CreateBoard DevObj[%x]: NT:%s\n", 
      deviceObject, ntname))

    extension = deviceObject->DeviceExtension;
    // Initialize the list heads for the read, write, and mask queues.
    // These lists will hold all of the queued IRP's for the device.
    InitializeListHead(&extension->ReadQueue);
    InitializeListHead(&extension->WriteQueue);
    //InitializeListHead(&extension->MaskQueue);
    InitializeListHead(&extension->PurgeQueue);

    KeInitializeEvent(&extension->PendingIRPEvent, SynchronizationEvent,
      FALSE);

    // init to 1, so on irp enter its 1 to 2, on exit 2 to 1.  0 on pnp stop.
    extension->PendingIRPCnt = 1;

    // Mark this device as not being opened by anyone.  We keep a
    // variable around so that spurious interrupts are easily
    // dismissed by the ISR.
    extension->DeviceIsOpen = FALSE;
    extension->WriteLength = 0;
    extension->DeviceObject = deviceObject;

    strcpy(extension->NtNameForPort, ntname);  // "RocketSys"
    extension->DeviceType = DEV_BOARD;
    extension->UniqueId = unique_id;

#ifdef NT50
    extension->PowerState = PowerDeviceD0;
#endif

    //------ add to the chain of boards
    if (Driver.board_ext == NULL)
      Driver.board_ext = extension;
    else
    {
      PSERIAL_DEVICE_EXTENSION add_ext;
      add_ext = Driver.board_ext;
      while (add_ext->board_ext != NULL)
	add_ext = add_ext->board_ext;
      add_ext->board_ext = extension;
    }

    extension->SymbolicLinkName[0] = 0;

    extension->config = ExAllocatePool(NonPagedPool, sizeof(DEVICE_CONFIG));
    if ( extension->config == NULL ) {
      return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(extension->config, sizeof(DEVICE_CONFIG));
#ifdef S_RK
    extension->CtlP = ExAllocatePool(NonPagedPool, sizeof(CONTROLLER_T));
    if ( extension->CtlP == NULL ) {
      return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(extension->config, sizeof(CONTROLLER_T));
#endif

#ifdef S_VS
    // allocate the hdlc & port manager structs
    extension->hd = (Hdlc *)our_locked_alloc(sizeof(Hdlc), "Dhd");
    extension->pm = (PortMan *)our_locked_alloc(sizeof(PortMan),"Dpm");
    extension->pm->hd = extension->hd;  // set this up, avoids trouble
#endif

    //------- Pass back the extension to the caller.
    if (DeviceExtension != NULL)
      *DeviceExtension = extension;
  }
  return(ntStatus);
}

/*----------------------------------------------------------------------
CreateReconfigPortDevices -
    This routine attempts to resize a rocketport or vs1000 number of
    ports.
|----------------------------------------------------------------------*/
NTSTATUS CreateReconfigPortDevices(IN PSERIAL_DEVICE_EXTENSION board_ext,
      int new_num_ports)
{
  PSERIAL_DEVICE_EXTENSION newExtension = NULL;
  PSERIAL_DEVICE_EXTENSION next_ext;
  PSERIAL_DEVICE_EXTENSION port_ext;

  int ch;
  NTSTATUS stat;
    // bugbug: if pnp-ports, we should be adding and removing pdo's,
    //  not fdo's.
  int is_fdo = 1;
  int existing_ports;

  MyKdPrint(D_Init,("ReconfigNumPorts"))

  if (board_ext == NULL)
  {
    return STATUS_INSUFFICIENT_RESOURCES;
  }

#ifdef S_RK
  // doesn't make as much sense to redo this on the fly as in VS.
  // rocketport special re-configure startup code would be needed.
  return STATUS_INSUFFICIENT_RESOURCES;
#endif
  // code needs work!  don't allow for nt40 as well....
  return STATUS_INSUFFICIENT_RESOURCES;

#ifdef NT50
  // if we are doing pnp-ports, we probably need to remove the
  // pdo's then inform the os to rescan pdos.
  if (!Driver.NoPnpPorts)
    return STATUS_INSUFFICIENT_RESOURCES;
#endif

  existing_ports = NumPorts(board_ext);

  if (new_num_ports == existing_ports)
    return STATUS_SUCCESS;

  if (new_num_ports == 0)
    return STATUS_INSUFFICIENT_RESOURCES;

  MyKdPrint(D_Init,("ReconfigNumPorts B"))

  ++Driver.Stop_Poll;  // flag to stop poll access

  if (new_num_ports < existing_ports)  // want less ports
  {
    // see if anyones got the ports we want to kill off open.
    port_ext = board_ext->port_ext;
    for (ch=0; ch<existing_ports; ch++)
    {
      if (ch>=new_num_ports)
      {
	if (port_ext->DeviceIsOpen)
	{
	  --Driver.Stop_Poll;  // flag to stop poll access
	  MyKdPrint(D_Error,("Port OpenErr\n"))
	  return STATUS_INSUFFICIENT_RESOURCES;  // no they are open
	}
      }
      port_ext = port_ext->port_ext;
    }

    MyKdPrint(D_Error,("Removing Ports\n"))

    //---- must be ok to kill them off
    port_ext = board_ext->port_ext;
    for (ch=0; ch<existing_ports; ch++)
    {
      next_ext = port_ext->port_ext;
      if (ch>=new_num_ports)
      {
	RcktDeletePort(port_ext);
      }
      port_ext = next_ext;
    }
  }
  else if (new_num_ports > existing_ports)  // want more ports
  {
    for (ch=existing_ports; ch<new_num_ports; ch++)
    {
      stat = CreatePortDevice(Driver.GlobalDriverObject,
			      board_ext,
			      &newExtension,
			      ch,is_fdo);
      if (stat != STATUS_SUCCESS)
      {
	--Driver.Stop_Poll;  // flag to stop poll access
	MyKdPrint(D_Error,("StartErr 8E"))
	return stat;
      }
    }  // loop thru ports
  }  // if more ports
  board_ext->config->NumPorts = new_num_ports;

#ifdef S_VS
  stat = VSSpecialStartup(board_ext);
  if (stat != STATUS_SUCCESS)
  {
    --Driver.Stop_Poll;  // flag to start poll access
    MyKdPrint(D_Error,("StartErr 8F"))
    return stat;
  }
#endif

  --Driver.Stop_Poll;  // flag to stop poll access
  return STATUS_SUCCESS;
}

/*----------------------------------------------------------------------
CreatePortDevices -
    This routine attempts to initialize all the ports on a multiport board
Arguments:
    DriverObject - Simply passed on to the controller initialization routine.
    ConfigData - A linked list of configuration information for all
      the ports on a multiport card.
    DeviceExtension - Will point to the first successfully initialized
	   port on the multiport card.
Return Value: None.
|----------------------------------------------------------------------*/
NTSTATUS CreatePortDevices(IN PDRIVER_OBJECT DriverObject)
{
  PSERIAL_DEVICE_EXTENSION newExtension = NULL;
  int ch, bd;
  NTSTATUS stat;
  int is_fdo = 1;

  PSERIAL_DEVICE_EXTENSION ext;

  ext = Driver.board_ext;
  bd = 0;
  while (ext)
  {
    for (ch=0; ch<ext->config->NumPorts; ch++)
    {
      stat = CreatePortDevice(DriverObject,
			      ext,
			      &newExtension,
			      ch,is_fdo);
      if (stat != STATUS_SUCCESS)
	return stat;

      stat = StartPortHardware(newExtension, ch);
      if (stat != STATUS_SUCCESS)
	return stat;
    }
    ++bd;
    ext = ext->board_ext;  // next in chain
  }  // while ext

  return STATUS_SUCCESS;
}

/*----------------------------------------------------------------------
 StartPortHardware -
|----------------------------------------------------------------------*/
NTSTATUS StartPortHardware(IN PSERIAL_DEVICE_EXTENSION port_ext,
	  int chan_num)
{
#ifdef S_VS
  int i;
  PSERIAL_DEVICE_EXTENSION board_ext;

  board_ext = port_ext->board_ext;
  MyKdPrint(D_Pnp, ("StartHrdw bd:%d ch:%d\n", 
     BoardExtToNumber(board_ext), chan_num))

  if (port_ext->Port == NULL)
  {
    port_ext->Port = board_ext->pm->sp[chan_num];
    if (port_ext->Port == NULL)
    {
      MyKdPrint(D_Error,("FATAL Err4F\n"))
      KdBreakPoint();
    }
  }
#else
  CONTROLLER_T *CtlP;                 /* ptr to controller structure */
  PSERIAL_DEVICE_EXTENSION board_ext;
  int aiop_i, ch_i;

  board_ext = port_ext->board_ext;
  //board_num = BoardExtToNumber(board_ext);

  MyKdPrint(D_Pnp,("StartHrdw bd:%d ch:%d\n", 
     BoardExtToNumber(board_ext), chan_num))
  CtlP = board_ext->CtlP;      // point to our board struct

  // Set pointers to the Rocket's info
  port_ext->ChP = &port_ext->ch;

  // bugbug: what about special rocketmodem startup? Should we
  // be doing this for pdo's and fdo's?  Should we have a flag
  // indicating job done?

  aiop_i = chan_num / CtlP->PortsPerAiop;
  ch_i   = chan_num % CtlP->PortsPerAiop;
  if(!sInitChan(CtlP,   // ptr to controller struct
     port_ext->ChP,   // ptr to chan struct
     aiop_i,  // aiop #
     (unsigned char)ch_i))     // chan #
  {
    Eprintf("Err Ch %d on Brd %d", chan_num+1,
      BoardExtToNumber(board_ext)+1);
    return STATUS_INSUFFICIENT_RESOURCES;
  }
#endif

  return STATUS_SUCCESS;
}

/*----------------------------------------------------------------------
 CreatePortDevice -
    Forms and sets up names, creates the device, initializes kernel
    synchronization structures, allocates the typeahead buffer,
    sets up defaults, etc.
Arguments:
    DriverObject - Just used to create the device object.
    ParentExtension - a pnp port this will be null.
    DeviceExtension - Points to the device extension of the successfully
	   initialized controller. We return this handle.
    chan_num - 0,1,2,... port index
    is_fdo - is a functional device object(normal port) as apposed to
      a pdo(physical device object) which is used to pnp enumerate
      "found" hardware by our driver.

Return Value:
    STATUS_SUCCCESS if everything went ok.  A !NT_SUCCESS status
    otherwise.
|----------------------------------------------------------------------*/
NTSTATUS CreatePortDevice(
      IN PDRIVER_OBJECT DriverObject,
      IN PSERIAL_DEVICE_EXTENSION ParentExtension,
      OUT PSERIAL_DEVICE_EXTENSION *DeviceExtension,
      IN int chan_num,  // 0,1,2,... port index
      IN int is_fdo)  // is a functional device object(normal port)
{
  char full_ntname[40];

  char comname[16];
  char ntname[20];
  NTSTATUS status = STATUS_SUCCESS;
  int stat;
  ULONG do_type;
  PUNICODE_STRING pucodename;
  static int unique_id = 0;
  ULONG do_characteristics;
  BOOLEAN do_is_exclusive;

    // Points to the device object (not the extension) created
    // for this device.
  PDEVICE_OBJECT deviceObject;

    // Points to the device extension for the device object
    // (see above) created for the device we are initializing.
  PSERIAL_DEVICE_EXTENSION extension = NULL;

#ifdef S_VS
    strcpy(ntname, "Vslinka");
#else
    strcpy(ntname, "RocketPort");
#endif

  // copy over the name in the configuration for dos-name
  strcpy(comname, ParentExtension->config->port[chan_num].Name);

  // setup the nt io-object nt-name
  if (is_fdo)
  {
    strcpy(full_ntname, szDevice); // "\\Device\\"
  }
  else
  {
    // this is what serenum does for naming its pdo's
    strcpy(full_ntname, "\\Serial\\");
    strcat(ntname, "Pdo");  // just to make sure its unique
  }

  our_ultoa(unique_id, &ntname[strlen(ntname)], 10);
  strcat(full_ntname, ntname);

  if (is_fdo)
  {
    ++unique_id;  // go to next id so next call will be different.
    // normal case(nt40), and a functional device object in nt5
    stat = CheckPortName(comname, NULL);  // ensure name is unique
    if (stat)  // name changed
    {
      // save back the new name to the configuration struct
      strcpy(ParentExtension->config->port[chan_num].Name, comname);
    }
    do_type = FILE_DEVICE_SERIAL_PORT;
    do_characteristics = 0;
    do_is_exclusive = TRUE;
  }
  else
  {
    // nt5 pnp physical device object(spawns a fdo later)
    //do_type = FILE_DEVICE_BUS_EXTENDER;
    do_type = FILE_DEVICE_UNKNOWN;
#ifdef NT50
    // nt4 doesn't know what FILE_AUTOGENERATED_DEVICE_NAME is.
    do_characteristics = FILE_AUTOGENERATED_DEVICE_NAME;
#else
    do_characteristics = 0;
#endif
    do_is_exclusive = FALSE;
    //pucodename = NULL;  // no name if a PDO
  }
  pucodename = CToU1(full_ntname);


  //---------------------------- Create the device object for this device.
  status = IoCreateDevice(
      DriverObject,
      sizeof(SERIAL_DEVICE_EXTENSION),
     pucodename,        // name
     do_type,           // FILE_DEVICE_BUS_EXTENDER, FILE_DEVICE_SERIAL_PORT, etc
     do_characteristics,// characteristics
     do_is_exclusive,   // exclusive
     &deviceObject);    // new thing this call creates

  // If we couldn't create the device object, then there
  // is no point in going on.
  if (!NT_SUCCESS(status))
  {
    MyKdPrint(D_Init,("Err, IoCreate: NT:%s, SYM:%s\n",
      ntname, comname))

    EventLog(DriverObject,
	     status,
	     SERIAL_DEVICEOBJECT_FAILED,
	     0, NULL);
    return STATUS_INSUFFICIENT_RESOURCES;
  }


  // The device object has a pointer to an area of non-paged
  // pool allocated for this device.  This will be the device extension.
  extension = deviceObject->DeviceExtension;

   // Zero all of the memory associated with the device extension.
  RtlZeroMemory(extension, sizeof(SERIAL_DEVICE_EXTENSION));

  extension->PortIndex = chan_num;  // record the port index 0,1,2..
  // for NT5.0, set this up here so we don't crash.(NT4.0 sets
  // up prior to this.
  extension->port_config = &ParentExtension->config->port[chan_num];
  extension->UniqueId = unique_id;
  if (!is_fdo)
  {
    MyKdPrint(D_Init,("PDO-"))
  }
  MyKdPrint(D_Init,("CreatePort DevObj[%x]: NT:%s, SYM:%s\n",
    deviceObject, ntname, comname))

  // save off a ptr to our parent board extension
  extension->board_ext = ParentExtension;

  {
    PSERIAL_DEVICE_EXTENSION add_ext = NULL;
    if (is_fdo)
    {
      //------ add to the chain of ports under board ext
      if (ParentExtension->port_ext == NULL)
	ParentExtension->port_ext = extension;
      else
	add_ext = ParentExtension->port_ext;
    }
    else  // pdo, ejected pnp enumeration
    {
      //------ add to the chain of pdo-ports under board ext
      if (ParentExtension->port_pdo_ext == NULL)
	ParentExtension->port_pdo_ext = extension;
      else
	add_ext = ParentExtension->port_pdo_ext;
    }
    if (add_ext)
    {
      while (add_ext->port_ext != NULL)
	add_ext = add_ext->port_ext;
      add_ext->port_ext = extension;
    }
  }

  // Initialize the list heads for the read, write, and mask queues.
  // These lists will hold all of the queued IRP's for the device.
  InitializeListHead(&extension->ReadQueue);
  InitializeListHead(&extension->WriteQueue);
  //InitializeListHead(&extension->MaskQueue);
  InitializeListHead(&extension->PurgeQueue);

  // Initialize the spinlock associated with fields read (& set)
  // by IO Control functions.
  KeInitializeSpinLock(&extension->ControlLock);

  // Initialize the timers used to timeout operations.
  KeInitializeTimer(&extension->ReadRequestTotalTimer);
  KeInitializeTimer(&extension->ReadRequestIntervalTimer);
  KeInitializeTimer(&extension->WriteRequestTotalTimer);
  KeInitializeTimer(&extension->XoffCountTimer);

  KeInitializeDpc(&extension->CompleteWriteDpc,
		  SerialCompleteWrite,
		  extension);

  KeInitializeDpc(&extension->CompleteReadDpc,
		  SerialCompleteRead,
		  extension);

  // Timeout Dpc initialization
  KeInitializeDpc(&extension->TotalReadTimeoutDpc,
		  SerialReadTimeout,
		  extension);

  KeInitializeDpc(&extension->IntervalReadTimeoutDpc,
		  SerialIntervalReadTimeout,
		  extension);

  KeInitializeDpc(&extension->TotalWriteTimeoutDpc,
		  SerialWriteTimeout,
		  extension);

  KeInitializeDpc(&extension->CommErrorDpc,
		  SerialCommError,
		  extension);

  KeInitializeDpc(&extension->CommWaitDpc,
		  SerialCompleteWait,
		  extension);

  KeInitializeDpc(&extension->XoffCountTimeoutDpc,
		  SerialTimeoutXoff,
		  extension);

  KeInitializeDpc(&extension->XoffCountCompleteDpc,
		  SerialCompleteXoff,
		  extension);

  // Get a "back pointer" to the device object and specify
  // that this driver only supports buffered IO.  This basically
  // means that the IO system copies the users data to and from
  // system supplied buffers.
  extension->DeviceObject = deviceObject;
  extension->DevStatus = 0;

  deviceObject->Flags |= DO_BUFFERED_IO;
#ifdef NT50
  deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
  if (!is_fdo)  // its a PDO, so adjust stack requirements
  {
    deviceObject->StackSize += ParentExtension->DeviceObject->StackSize;
  }
#endif

  KeInitializeEvent(&extension->PendingIRPEvent, SynchronizationEvent,
    FALSE);

  // init to 1, so on irp enter its 1 to 2, on exit 2 to 1.  0 on pnp stop.
  extension->PendingIRPCnt = 1;

  // Set up the default device control fields.
  // Note that if the values are changed after
  // the file is open, they do NOT revert back
  // to the old value at file close.
  extension->SpecialChars.XonChar = SERIAL_DEF_XON;
  extension->SpecialChars.XoffChar = SERIAL_DEF_XOFF;
  extension->SpecialChars.ErrorChar=0;
  extension->SpecialChars.EofChar=0;
  extension->SpecialChars.EventChar=0;
  extension->SpecialChars.BreakChar=0;

  extension->HandFlow.ControlHandShake = SERIAL_DTR_CONTROL;
  extension->HandFlow.FlowReplace = SERIAL_RTS_CONTROL;
  extension->BaudRate = 9600;
  extension->LineCtl.Parity = NO_PARITY;
  extension->LineCtl.WordLength = 8;
  extension->LineCtl.StopBits = STOP_BIT_1;
#ifdef S_RK
  extension->ModemCtl=COM_MDM_RTS | COM_MDM_DTR;
  extension->IntEnables =(RXINT_EN | MCINT_EN | CHANINT_EN | TXINT_EN);
#endif
  // We set up the default xon/xoff limits.
  extension->HandFlow.XoffLimit = extension->BufferSize >> 3;
  extension->HandFlow.XonLimit = extension->BufferSize >> 1;
  extension->BufferSizePt8 = ((3*(extension->BufferSize>>2))+
    (extension->BufferSize>>4));

  // Initialize stats counters
  extension->OurStats.ReceivedCount = 0L;
  extension->OurStats.TransmittedCount = 0L;
  extension->OurStats.ParityErrorCount = 0L;
  extension->OurStats.FrameErrorCount = 0L;
  extension->OurStats.SerialOverrunErrorCount = 0L;
  extension->OurStats.BufferOverrunErrorCount = 0L;
    
  // Mark this device as not being opened by anyone.  We keep a
  // variable around so that spurious interrupts are easily
  // dismissed by the ISR.
  extension->DeviceIsOpen = FALSE;
  extension->WriteLength = 0;

#ifdef NT50
  extension->PowerState = PowerDeviceD0;
#endif

  // This call will set up the naming necessary for
  // external applications to get to the driver.  It
  // will also set up the device map.
  strcpy(extension->NtNameForPort, ntname);      // RocketPort# or VSLINKA#
  strcpy(extension->SymbolicLinkName, comname);  // "COM#"

  if (is_fdo)
  {
    SerialSetupExternalNaming(extension);  // Configure ports!!!!

    // Check for default settings in registry
    InitPortsSettings(extension);
  }
  else
  {
    // eject PDOs (physical device objects)representing port hardware.
    extension->IsPDO = 1;  // we are a pdo
  }

  // Store values into the extension for interval timing.
  // If the interval timer is less than a second then come
  // in with a short "polling" loop.
  // For large ( >2 seconds) use a 1 second poller.
  extension->ShortIntervalAmount.QuadPart = -1;
  extension->LongIntervalAmount.QuadPart = -10000000;
  extension->CutOverAmount.QuadPart = 200000000;

  //------- Pass back the extension to the caller.
  *DeviceExtension = extension;

  return STATUS_SUCCESS;
}

/*-----------------------------------------------------------------------
RcktDeleteDriverObj - This routine will delete a board and all its ports
  for PnP remove handling.
|----------------------------------------------------------------------*/
VOID RcktDeleteDriverObj(IN PSERIAL_DEVICE_EXTENSION extension)
{
  //int i;
  //PSERIAL_DEVICE_EXTENSION ext;
  PSERIAL_DEVICE_EXTENSION del_ext;

  MyKdPrint(D_Init,("Delete Driver Obj:%x\n", extension->DeviceObject))
  MyKdPrint(D_Init,("  IrpCnt:%x\n", extension->PendingIRPCnt))
  
  if (NULL == extension)
  {
    MyKdPrint(D_Init,("Err8U\n"))
    return;
  }

  ++Driver.Stop_Poll;  // flag to stop poll access

  del_ext = extension;  // now kill board
  SerialCleanupDevice(del_ext);  // delete any port stuff on ext.

#ifdef NT50
  if (del_ext->LowerDeviceObject != NULL)
  {
    IoDetachDevice(del_ext->LowerDeviceObject);
    del_ext->LowerDeviceObject = NULL;
  }
#endif
  
  IoDeleteDevice(del_ext->DeviceObject);

  --Driver.Stop_Poll;  // flag to stop poll access
}

/*----------------------------------------------------------------------
RcktDeleteDevices - This routine will delete all devices
|----------------------------------------------------------------------*/
VOID RcktDeleteDevices(IN PDRIVER_OBJECT DriverObject)
{
  PDEVICE_OBJECT currentDevice = DriverObject->DeviceObject;
  int i;

  i = 0;
  while(currentDevice)
  {
    PSERIAL_DEVICE_EXTENSION extension = currentDevice->DeviceExtension;
    currentDevice = currentDevice->NextDevice;
    SerialCleanupDevice(extension);
#ifdef NT50
    if (extension->LowerDeviceObject != NULL)
    {
      IoDetachDevice(extension->LowerDeviceObject);
      extension->LowerDeviceObject = NULL;
    }
#endif
    MyKdPrint(D_Init,("RcktDeleteDev Obj:%x\n", extension->DeviceObject))
    //MyKdPrint(D_Init,("  IrpCnt:%x\n", extension->PendingIRPCnt))
    IoDeleteDevice(extension->DeviceObject);
    i++;
  }
  MyKdPrint(D_Init,("Deleted %d Device Objects\n", i))
}

/*----------------------------------------------------------------------
RcktDeleteBoard - This routine will delete a board and all its ports
  for PnP remove handling.
|----------------------------------------------------------------------*/
VOID RcktDeleteBoard(IN PSERIAL_DEVICE_EXTENSION extension)
{
  int i;
  PSERIAL_DEVICE_EXTENSION ext;
  PSERIAL_DEVICE_EXTENSION del_ext;

  MyKdPrint(D_Init, ("Delete Board\n"))
  if (NULL == extension)
  {
    MyKdPrint(D_Error,("Err9X\n"))
    return;
  }

  ++Driver.Stop_Poll;  // flag to stop poll access

  MyKdPrint(D_Init, ("Delete Ports\n"))
  // release any port things
  ext = extension->port_ext;
  i = 0;
  while (ext)
  {
    del_ext = ext;  // kill this one
    ext = ext->port_ext;  // next in list
    
    SerialCleanupDevice(del_ext);  // delete any allocated stuff on ext.

#ifdef NT50
    if (del_ext->LowerDeviceObject != NULL)
    {
      IoDetachDevice(del_ext->LowerDeviceObject);
      del_ext->LowerDeviceObject = NULL;
    }
#endif
    MyKdPrint(D_Init,("RcktDeleteBoard Port Obj:%x\n", del_ext->DeviceObject))
    //MyKdPrint(D_Init,("  IrpCnt:%x\n", del_ext->PendingIRPCnt))
    IoDeleteDevice(del_ext->DeviceObject);
    i++;
  }
  extension->port_ext = NULL;
  MyKdPrint(D_Init,("Deleted %d Ports\n", i))

  // release any PDO port things
  ext = extension->port_pdo_ext;
  i = 0;
  while (ext)
  {
    del_ext = ext;  // kill this one
    ext = ext->port_ext;  // next in list
    
    SerialCleanupDevice(del_ext);  // delete any port stuff on ext.
#ifdef NT50
    if (del_ext->LowerDeviceObject != NULL)
    {
      IoDetachDevice(del_ext->LowerDeviceObject);
      del_ext->LowerDeviceObject = NULL;
    }
#endif
    MyKdPrint(D_Init,("RcktDeleteBoard PDO Port Obj:%x\n", del_ext->DeviceObject))
    //MyKdPrint(D_Init,("  IrpCnt:%x\n", del_ext->PendingIRPCnt))
    IoDeleteDevice(del_ext->DeviceObject);
    i++;
  }
  extension->port_pdo_ext = NULL;
  MyKdPrint(D_Init,("Deleted PDO %d Ports\n", i))

  del_ext = NULL;
  // take out of linked list  
  ext = Driver.board_ext;
  if (ext == extension)  // first in list
  {
    del_ext = extension;  // kill this board
    Driver.board_ext = extension->board_ext;
  }
  else
  {
    while (ext)
    {
      if (ext->board_ext == extension)  // found in list, so take out of list
      {
   del_ext = extension;  // kill this board
   ext->board_ext = extension->board_ext;  // link around deleted one
   break;
      }
      ext = ext->board_ext;
    }
  }

  MyKdPrint(D_Init,("Delete board_ext:%x, remaining: %d\n",
	 extension, NumDevices()))
    
  if (del_ext != NULL)
  {
    SerialCleanupDevice(del_ext);  // delete any port stuff on ext.

#ifdef NT50
    if (del_ext->LowerDeviceObject != NULL)
    {
     IoDetachDevice(del_ext->LowerDeviceObject);
      del_ext->LowerDeviceObject = NULL;
    }
#endif
    MyKdPrint(D_Init,("RcktDeleteBoard Obj:%x\n", del_ext->DeviceObject))
    //MyKdPrint(D_Init,("  IrpCnt:%x\n", del_ext->PendingIRPCnt))
    IoDeleteDevice(del_ext->DeviceObject);
  }

  --Driver.Stop_Poll;  // flag to stop poll access
}

/*----------------------------------------------------------------------
RcktDeletePort - This routine will delete a port and is used for
  PnP remove, start handling.  I don't think we ever delete PDO's,
  (other than driver unload) here.
|----------------------------------------------------------------------*/
VOID RcktDeletePort(IN PSERIAL_DEVICE_EXTENSION extension)
{
  PSERIAL_DEVICE_EXTENSION ext;
  PSERIAL_DEVICE_EXTENSION del_ext;

  MyKdPrint(D_Init,("RcktDeletePort\n"))
  if (NULL == extension)
  {
    MyKdPrint(D_Error,("Err8X\n"))
    return;
  }

  ++Driver.Stop_Poll;  // flag to stop poll access

  MyKdPrint(D_Init, ("Delete Port\n"))
  del_ext = NULL;

  ext = extension->board_ext;  // parent board extension
  while (ext)
  {
    if (ext->port_ext == extension)  // found the one before it
    {
      del_ext = extension;
      ext->port_ext = extension->port_ext;  // skip link to next
      break;
    }
    ext = ext->port_ext;
  }

  if (del_ext != NULL)
  {
    SerialCleanupDevice(del_ext);  // delete any port stuff on ext.

#ifdef NT50
    if (del_ext->LowerDeviceObject != NULL)
    {
      IoDetachDevice(del_ext->LowerDeviceObject);
      del_ext->LowerDeviceObject = NULL;
    }
#endif
    MyKdPrint(D_Init,("RcktDeletePort Obj:%x\n", del_ext->DeviceObject))
    //MyKdPrint(D_Init,("  IrpCnt:%x\n", del_ext->PendingIRPCnt))
    IoDeleteDevice(del_ext->DeviceObject);
    MyKdPrint(D_Init,("Deleted Port\n"))
  }

  --Driver.Stop_Poll;  // flag to stop poll access
}

/*----------------------------------------------------------------------
SerialCleanupDevice -
    This routine will deallocate all of the memory used for
    a particular device.  It will also disconnect any resources
    if need be.
Arguments:
    Extension - Pointer to the device extension which is getting
     rid of all it's resources.
Return Value:
    None.
|----------------------------------------------------------------------*/
VOID SerialCleanupDevice (IN PSERIAL_DEVICE_EXTENSION Extension)
{
  MyKdPrint(D_Test, ("Mem Alloced Start:%d\n", Driver.mem_alloced))

  ++Driver.Stop_Poll;  // flag to stop poll access
  if (Extension)
  {
    if (Extension->DeviceType == DEV_PORT)
    {
      //KeRemoveQueueDpc(&Extension->RocketReadDpc);
      //KeRemoveQueueDpc(&Extension->RocketWriteDpc);

      KeCancelTimer(&Extension->ReadRequestTotalTimer);
      KeCancelTimer(&Extension->ReadRequestIntervalTimer);
      KeCancelTimer(&Extension->WriteRequestTotalTimer);
      KeCancelTimer(&Extension->XoffCountTimer);
      KeRemoveQueueDpc(&Extension->CompleteWriteDpc);
      KeRemoveQueueDpc(&Extension->CompleteReadDpc);

      // Timeout
      KeRemoveQueueDpc(&Extension->TotalReadTimeoutDpc);
      KeRemoveQueueDpc(&Extension->IntervalReadTimeoutDpc);
      KeRemoveQueueDpc(&Extension->TotalWriteTimeoutDpc);

      // Timeout
      KeRemoveQueueDpc(&Extension->CommErrorDpc);
      KeRemoveQueueDpc(&Extension->CommWaitDpc);
      KeRemoveQueueDpc(&Extension->XoffCountTimeoutDpc);
      KeRemoveQueueDpc(&Extension->XoffCountCompleteDpc);
    }
    else  // board device
    {
#ifdef S_VS
      if (Extension->hd)
      {
	hdlc_close(Extension->hd);
	our_free(Extension->hd, "Dhd");
	Extension->hd = NULL;
      }
      if (Extension->pm)
      {
	portman_close(Extension->pm);
	our_free(Extension->pm,"Dpm");
	Extension->pm = NULL;
      }
#endif
#ifdef S_RK
      if (Extension->io_reported)  // tells that we should deallocate on unload.
      {
	SerialUnReportResourcesDevice(Extension);  // give back io,irq resources
	Extension->io_reported = 0;
      }
      if (Extension->CtlP)
      {
	ExFreePool(Extension->CtlP);
	Extension->CtlP = NULL;
      }
#endif
      // free board config if present
      if (Extension->config)
      {
	ExFreePool(Extension->config);
	Extension->config = NULL;
      }
    }  // board dev

    // Get rid of all external naming as well as removing
    // the device map entry.
    SerialCleanupExternalNaming(Extension);
  }  // if not a null extension

  MyKdPrint(D_Test, ("Mem Alloced End:%d\n", Driver.mem_alloced))

  --Driver.Stop_Poll;  // flag to stop poll access
}

#ifdef S_RK
/*------------------------------------------------------------------
SerialGetMappedAddress -
    This routine maps an IO address to system address space.
Arguments:
    BusType - what type of bus - eisa, mca, isa
    IoBusNumber - which IO bus (for machines with multiple buses).
    IoAddress - base device address to be mapped.
    NumberOfBytes - number of bytes for which address is valid.
    AddressSpace - Denotes whether the address is in io space or memory.
    MappedAddress - indicates whether the address was mapped.
	 This only has meaning if the address returned
	 is non-null.
Return Value:
    Mapped address
----------------------------------------------------------------------*/
PVOID SerialGetMappedAddress(
   IN INTERFACE_TYPE BusType,
   IN ULONG BusNumber,
   PHYSICAL_ADDRESS IoAddress,
   ULONG NumberOfBytes,
   ULONG AddressSpace,
   PBOOLEAN MappedAddress,
   BOOLEAN DoTranslation)
{
  PHYSICAL_ADDRESS cardAddress;
  PVOID address;

  if (DoTranslation)
  {
    if(!HalTranslateBusAddress(
       BusType,
       BusNumber,
       IoAddress,
       &AddressSpace,
       &cardAddress)){
      // if the translate address call failed return null so we don't load
      address = NULL;
      return address;
    }
  }
  else
  {
    cardAddress = IoAddress;
  }

  // Map the device base address into the virtual address space
  // if the address is in memory space.
  if (!AddressSpace) {
    address = MmMapIoSpace(cardAddress,
			   NumberOfBytes,
			   FALSE);
    *MappedAddress = (BOOLEAN)((address)?(TRUE):(FALSE));
  }
  else
  {
    address = (PVOID)cardAddress.LowPart;
    *MappedAddress = FALSE;
  }
  return address;
}
#endif

/*------------------------------------------------------------------
Routine Description:
    This routine will be used to create a symbolic link
    to the driver name in the given object directory.
    It will also create an entry in the device map for
    this device - IF we could create the symbolic link.
Arguments:
    Extension - Pointer to the device extension.
Return Value:
    None.
-------------------------------------------------------------------*/
VOID SerialSetupExternalNaming (IN PSERIAL_DEVICE_EXTENSION Extension)
{
  char full_ntname[50];
  char full_comname[40];
  NTSTATUS status;

  strcpy(full_ntname, szDevice); // "\\Device\\"
  strcat(full_ntname, Extension->NtNameForPort);  // "Rocket#"

  strcpy(full_comname, szDosDevices); // "\\DosDevices\\"
  strcat(full_comname, Extension->SymbolicLinkName);  // "COM#"

  MyKdPrint(D_Init,("SetupExtName:%s\n", Extension->SymbolicLinkName))

  status = IoCreateSymbolicLink(
	 CToU2(full_comname), // like "\\DosDevices\\COM5"
	 CToU1(full_ntname)); // like "\\Device\\RocketPort0"

  if (NT_SUCCESS(status)) {

	  MyKdPrint( D_Init, ("Symbolic link %s created\n", full_comname ))
  }
  else {

	  MyKdPrint(D_Init,("Err SymLnkCreate.\n"))
    // Oh well, couldn't create the symbolic link.  No point
    // in trying to create the device map entry.
    SerialLogError(
       Extension->DeviceObject->DriverObject,
       Extension->DeviceObject,
       0,
       0,
       0,
       ErrNum++,
       status,
       SERIAL_NO_SYMLINK_CREATED,
       CToU1(Extension->SymbolicLinkName)->Length+sizeof(WCHAR),
       CToU1(Extension->SymbolicLinkName)->Buffer);
    return;
  }

  Extension->CreatedSymbolicLink = TRUE;

  // Add entry to let system and apps know about our ports

    // after V3.23 I added "\device\" into the registry entry(this was wrong)
    // 1-26-99, bugfix, don't add "\device\" into the registry entry,
    // this is not what serial.sys does. kpb.
  status = RtlWriteRegistryValue(
      RTL_REGISTRY_DEVICEMAP,
      L"SERIALCOMM",
      CToU2(Extension->NtNameForPort)->Buffer,  // "RocketPort0"
	//CToU2(full_ntname)->Buffer,  // "\Device\Vslinka0"
      REG_SZ,
      CToU1(Extension->SymbolicLinkName)->Buffer,  // COM#
      CToU1(Extension->SymbolicLinkName)->Length+sizeof(WCHAR));

  if (!NT_SUCCESS(status))
  {
    MyKdPrint(D_Init,("GenError C2.\n"))
    SerialLogError(Extension->DeviceObject->DriverObject,
		   Extension->DeviceObject,
		   0,
		   0,
		   0,
		   ErrNum++,
		   status,
		   SERIAL_NO_DEVICE_MAP_CREATED,
		   CToU1(Extension->SymbolicLinkName)->Length+sizeof(WCHAR),
		   CToU1(Extension->SymbolicLinkName)->Buffer);
  }
}
   
/*---------------------------------------------------------------------
SerialCleanupExternalNaming -
    This routine will be used to delete a symbolic link
    to the driver name in the given object directory.
    It will also delete an entry in the device map for
    this device if the symbolic link had been created.
Arguments:
    Extension - Pointer to the device extension.
|----------------------------------------------------------------------*/
VOID SerialCleanupExternalNaming(IN PSERIAL_DEVICE_EXTENSION Extension)
{
  char name[60];
  NTSTATUS status;

  // We're cleaning up here.  One reason we're cleaning up
  // is that we couldn't allocate space for the directory
  // name or the symbolic link.
  if (Extension->CreatedSymbolicLink)
  {
    MyKdPrint(D_Init,("KillSymLink:%s\n", Extension->SymbolicLinkName))
    strcpy(name, szDosDevices);  // "\\DosDevices\\"
    strcat(name, Extension->SymbolicLinkName);  // like "COM5"
    IoDeleteSymbolicLink(CToU1(name));
#ifdef NT50

	// Only for ports!

	if (Extension->DeviceType == DEV_PORT &&
		&Extension->DeviceClassSymbolicName != NULL &&
		Extension->DeviceClassSymbolicName.Buffer != NULL) {

      MyKdPrint(D_Init,("KillInterface:%s\n", 
		      UToC1(&Extension->DeviceClassSymbolicName)))
	  status = IoSetDeviceInterfaceState( &Extension->DeviceClassSymbolicName, FALSE );
      if (!NT_SUCCESS(status)) {

        MyKdPrint(D_Error,("Couldn't clear class association for %s\n",
	   	        UToC1(&Extension->DeviceClassSymbolicName)))
	  }
      else {

        MyKdPrint(D_Init, ("Cleared class association for device: %s\n", 
			    UToC1(&Extension->DeviceClassSymbolicName)))
	  }

	  RtlFreeUnicodeString( &Extension->DeviceClassSymbolicName );
	  Extension->DeviceClassSymbolicName.Buffer = NULL;
	}

#endif
    Extension->CreatedSymbolicLink = 0;
  }

  if (Extension->DeviceType == DEV_PORT)
  {
    // Delete any reg entry to let system and apps know about our ports
    strcpy(name, szDevice); // "\\Device\\"
    strcat(name, Extension->NtNameForPort);  // "Rocket#"
    status = RtlDeleteRegistryValue(
	  RTL_REGISTRY_DEVICEMAP,
	  L"SERIALCOMM",
	  CToU1(Extension->NtNameForPort)->Buffer);  // "RocketPort0"
	  //CToU1(name)->Buffer);
	MyKdPrint(D_Init, ("RtlDeleteRegistryValue:%s\n",Extension->NtNameForPort))

#if NT50
	// Make sure the ComDB binary data is cleared for the specific port.  There 
	// are some problems with W2000 PnP Manager taking care of this in every
	// circumstance.

    (void)clear_com_db( Extension->SymbolicLinkName );
#endif
  }
}

/*-----------------------------------------------------------------------
 SerialLogError - 
    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.
Arguments:
    DriverObject - A pointer to the driver object for the device.
    DeviceObject - A pointer to the device object associated with the
    device that had the error, early in initialization, one may not
    yet exist.
    P1,P2 - If phyical addresses for the controller ports involved
    with the error are available, put them through as dump data.
    SequenceNumber - A ulong value that is unique to an IRP over the
    life of the irp in this driver - 0 generally means an error not
    associated with an irp.
    MajorFunctionCode - If there is an error associated with the irp,
    this is the major function code of that irp.
    RetryCount - The number of times a particular operation has been
    retried.
    UniqueErrorValue - A unique long word that identifies the particular
    call to this function.
    FinalStatus - The final status given to the irp that was associated
    with this error.  If this log entry is being made during one of
    the retries this value will be STATUS_SUCCESS.
    SpecificIOStatus - The IO status for a particular error.
    LengthOfInsert1 - The length in bytes (including the terminating NULL)
	   of the first insertion string.
Return Value:
    None.
|-----------------------------------------------------------------------*/
VOID SerialLogError(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN ULONG SequenceNumber,
    IN UCHAR MajorFunctionCode,
    IN UCHAR RetryCount,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN NTSTATUS SpecificIOStatus,
    IN ULONG LengthOfInsert1,
    IN PWCHAR Insert1)
{
 PIO_ERROR_LOG_PACKET errorLogEntry;

 PVOID objectToUse;
 PUCHAR ptrToFirstInsert;

  if (DeviceObject != NULL)
    objectToUse = DeviceObject;
  else
    objectToUse = DriverObject;

  errorLogEntry = IoAllocateErrorLogEntry(
	 objectToUse,
	 (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) + LengthOfInsert1));

  if ( errorLogEntry == NULL)
  {
    MyKdPrint(D_Init,("SerialLogErr, Err A size:%d obj:%x\n",
	  LengthOfInsert1,objectToUse))
    return;
  }

  errorLogEntry->ErrorCode = SpecificIOStatus;
  errorLogEntry->SequenceNumber = SequenceNumber;
  errorLogEntry->MajorFunctionCode = MajorFunctionCode;
  errorLogEntry->RetryCount = RetryCount;
  errorLogEntry->UniqueErrorValue = UniqueErrorValue;
  errorLogEntry->FinalStatus = FinalStatus;
  errorLogEntry->DumpDataSize = 0;

  ptrToFirstInsert = (PUCHAR)&errorLogEntry->DumpData[0];

  if (LengthOfInsert1)
  {
    errorLogEntry->NumberOfStrings = 1;
    errorLogEntry->StringOffset = (USHORT)(ptrToFirstInsert -
		(PUCHAR)errorLogEntry);
    RtlCopyMemory(ptrToFirstInsert,
       Insert1,
       LengthOfInsert1);
  }

  IoWriteErrorLogEntry(errorLogEntry);
}

/*-----------------------------------------------------------------------
 EventLog - To put a shell around the SerialLogError to make calls easier
   to use.
|-----------------------------------------------------------------------*/
VOID EventLog(
    IN PDRIVER_OBJECT DriverObject,
    IN NTSTATUS FinalStatus,
    IN NTSTATUS SpecificIOStatus,
    IN ULONG LengthOfInsert1, 
    IN PWCHAR Insert1)
{
    SerialLogError(
      DriverObject,
      NULL,
      0,
      0,
      0,
      ErrNum++,
      FinalStatus,
      SpecificIOStatus,
      LengthOfInsert1,
      Insert1);
    return;
}

/*-----------------------------------------------------------------------
 InitPortsSettings - Read registry default Port setting
|-----------------------------------------------------------------------*/
VOID InitPortsSettings(IN PSERIAL_DEVICE_EXTENSION extension)
{
  RTL_QUERY_REGISTRY_TABLE paramTable[2];

#define MAX_STRING 256
  WCHAR StrValBuf[MAX_STRING+1];
  char comname[20];

  UNICODE_STRING USReturn;

  USReturn.Buffer = NULL;
  RtlInitUnicodeString(&USReturn, NULL);
  USReturn.MaximumLength = sizeof(WCHAR)*MAX_STRING;
  USReturn.Buffer = StrValBuf;

  if(strlen(extension->SymbolicLinkName) < sizeof(comname))
  {
      strncpy(comname, extension->SymbolicLinkName, strlen(extension->SymbolicLinkName) + 1);
      strcat(comname, ":");
  }

  RtlZeroMemory(&paramTable[0],sizeof(paramTable));

  paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
  paramTable[0].Name = CToU1(comname)->Buffer;
  paramTable[0].EntryContext = &USReturn;
  paramTable[0].DefaultType = REG_SZ;
  paramTable[0].DefaultData = L"";
  paramTable[0].DefaultLength = 0;

  if (!NT_SUCCESS(RtlQueryRegistryValues(
    // \Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion
	   RTL_REGISTRY_WINDOWS_NT,
	   L"Ports",
	   &paramTable[0],
	   NULL,
	   NULL
	   )))
  {
    // no entry
    return;
  }

  // Check for data, indicates settings exist for COMX
  if (USReturn.Length == 0)
  {
    // no entry
    return;
  }

#define TOKENS 5
#define MAX_DIGITS 6
  {
    unsigned int TokenCounter;
    unsigned int CharCounter;
    unsigned int LastCount;
    WCHAR *TokenPtrs[TOKENS];
    ULONG BaudRateValue;

    // Make sure all Token ptrs point to NULL
    for(TokenCounter = 0; TokenCounter < TOKENS; TokenCounter++)
      TokenPtrs[TokenCounter] = NULL;

    // init counters
    TokenCounter = 0;
    LastCount = 0;

    for(CharCounter = 0; CharCounter < USReturn.Length; CharCounter++)
    {
      if(StrValBuf[CharCounter] == ',')
      {
	StrValBuf[CharCounter] = '\0'; //Null terminate DbgPrint

	TokenPtrs[TokenCounter++] = &StrValBuf[LastCount];

	//point to beginning of next string
	LastCount = CharCounter +1;
      }
    }

    // set up the last token
    if(CharCounter < MAX_STRING)
      StrValBuf[CharCounter] = '\0'; //Null terminate DbgPrint NULL

    if(TokenCounter < TOKENS)
      TokenPtrs[TokenCounter] = &StrValBuf[LastCount];

    // token 0: baud rate
    if(TokenPtrs[0] != NULL)
    {
      BaudRateValue = 0;
      CharCounter = 0;

      while( (TokenPtrs[0][CharCounter] != '\0') && //DbgPrint NULL
	     (CharCounter < MAX_DIGITS) &&
	     (BaudRateValue != ~0x0L) )
      {
	BaudRateValue *= 10;
	switch(TokenPtrs[0][CharCounter++])
	{
	  case '0': break;
	  case '1': BaudRateValue += 1; break;
	  case '2': BaudRateValue += 2; break;
	  case '3': BaudRateValue += 3; break;
	  case '4': BaudRateValue += 4; break;
	  case '5': BaudRateValue += 5; break;
	  case '6': BaudRateValue += 6; break;
	  case '7': BaudRateValue += 7; break;
	  case '8': BaudRateValue += 8; break;
	  case '9': BaudRateValue += 9; break;
	  default: BaudRateValue = ~0x0UL; break;
	}
      }

      if ((BaudRateValue >= 50) && (BaudRateValue <= 460800))
	extension->BaudRate = BaudRateValue;  // allow any baud rate

#ifdef COMMENT_OUT
      switch (BaudRateValue)
      {
	// Valid baud rates
	case 50:    case 75:    case 110:
	case 134:   case 150:   case 200:
	case 300:   case 600:   case 1200:
	case 1800:  case 2400:  case 4800:
	case 7200:  case 9600:  case 19200:
	case 38400: case 57600: case 76800:
	case 115200: case 230400: case 460800:
	  extension->BaudRate = BaudRateValue;
	break;

	default:
	  // Selected baud rate not available for RocketPort COMX
	break;
      }
#endif
    }

    // token 1: parity
    if(TokenPtrs[1] != NULL)
    {
      switch (TokenPtrs[1][0])
      {
	case 'n':
	  extension->LineCtl.Parity = NO_PARITY;
	break;

	case 'o':
	  extension->LineCtl.Parity = ODD_PARITY;
	break;

	case 'e':
	  extension->LineCtl.Parity = EVEN_PARITY;
	break;

	default:
	  // Selected parity not available for RocketPort COMX
	break;
      }
    }

    // token 2: data bits
    if(TokenPtrs[2] != NULL)
    {
      switch (TokenPtrs[2][0])
      {
	case '7':
	  extension->LineCtl.WordLength = 7;
	break;

	case '8':
	  extension->LineCtl.WordLength = 8;
	break;

	default:
	  // Selected databits not available for RocketPort COMX
	break;
      }
    }

    // token 3: Stop bits
    if(TokenPtrs[3] != NULL)
    {
      switch (TokenPtrs[3][0])
      {
	case '1':
	  extension->LineCtl.StopBits = STOP_BIT_1;
	break;

	case '2':
	  extension->LineCtl.StopBits = STOP_BITS_2;
	break;

	default:
	break;
      }
    }

    // token 4: flow control: rts/cts or XON/XOFF
    if(TokenPtrs[4] != NULL)
    {
      switch (TokenPtrs[4][0])
      {
	case 'x': // XON/XOFF f/c
	  extension->HandFlow.FlowReplace |=
	    (SERIAL_AUTO_TRANSMIT | SERIAL_AUTO_RECEIVE) ;
	break;

	case 'p': // RTS/CTS f/c
	  extension->HandFlow.FlowReplace &= ~SERIAL_RTS_MASK;
	  extension->HandFlow.FlowReplace |= SERIAL_RTS_HANDSHAKE;

	  extension->HandFlow.ControlHandShake |= SERIAL_CTS_HANDSHAKE;
	break;

	default:
	break;

      } // Selected flowcontrol not available for RocketPort COMX
    } // flow control token
  }
}

/*----------------------------------------------------------------------
 CheckPortName - If the name is already used, then derive one that is
   not in use.
   name - name of port to check.  Modify if a problem.
   Return - 0=name ok, 1=generated modified name, other= error.
|----------------------------------------------------------------------*/
static int CheckPortName(IN OUT char *name,
       IN PSERIAL_DEVICE_EXTENSION extension)
{
  int i;
  char prefix[20];
  int num;
  int new_name_given = 0;

  MyKdPrint(D_Init, ("CheckPortName:%s\n", name));

  // if no name, give a reasonable default.
  if (name[0] == 0)
  {
    new_name_given = 1;  // flag it
    strcpy(name, "COM3");
  }
  // load prefix(such as "COM" from "COM25" from name)
  i = 0;
  while ( (!our_isdigit(name[i])) && (name[i] != 0) && (i < 18))
  {
    prefix[i] = name[i];
    ++i;
  }
  prefix[i] = 0;

  // now grab post-fix number value incase we need to derive a new name
  num = 0;
  if (our_isdigit(name[i]))
    num = getint(&name[i], NULL);

  i = 0;
  for (;;)
  {
    // if we are already using this name, or if its in the registry
    if ((find_ext_by_name(name, NULL) != NULL) || 
	(IsPortNameInHardwareMap(name)) )
    {
      // name already in use, so derive a new one
      new_name_given = 1;  // flag it
      ++num;  // give a new post-fix index(so "COM4" to "COM5")
      Sprintf(name, "%s%d", prefix, num);
    }
    else
    {  // name is ok
      if (new_name_given)
      {
	MyKdPrint(D_Init, ("Form new name:%s\n", name))
      }
      return new_name_given; // return 0 if no change made, 1 if changed
    }
    ++i;
    if (i > 5000)
    {
      // problems
      return 2;  // return error
    }
  }
}

/*----------------------------------------------------------------------
 IsPortNameInHardwareMap - For Pnp operation, we startup before configuration,
   so pick a reasonable starting com-port name.  We do this by finding
   registry entries for all existing com-ports in the system.  This
   info is used to determine a name for the port.
|----------------------------------------------------------------------*/
static int IsPortNameInHardwareMap(char *name)
{
  static char *szRegRMHDS = 
    {"\\Registry\\Machine\\Hardware\\DeviceMap\\SerialComm"};

  HANDLE KeyHandle = NULL;
  ULONG data_type;
  int node_num = 0;
  char buffer[200];
  char KeyNameStr[60];
  char *data_ptr;
  int stat;

  //MyKdPrint(D_Init, ("IsPortNameInHardwareMap\n"))

  stat = our_open_key(&KeyHandle, NULL, szRegRMHDS, KEY_READ);
  if (stat)
  {
    MyKdPrint(D_Init, ("Failed OpenKey\n"))
    return 0;  // return no name clash
  }
  KeyNameStr[0] = 0;

  for(;;)
  {
    stat = our_enum_value(KeyHandle,
	 node_num,
	 buffer,
	 200,
	 &data_type,
	 &data_ptr,
	 KeyNameStr);
    ++node_num;

    if (stat)
    {
       //MyKdPrint(D_Init, ("Done\n"))
       break;
    }
    //MyKdPrint(D_Init, ("Got Value:%s\n", KeyNameStr))

    if (data_type != REG_SZ)
    {
      MyKdPrint(D_Init, ("Not RegSZ\n"))
      break;
    }

    WStrToCStr(KeyNameStr, (PWCHAR)data_ptr, 18);
    //MyKdPrint(D_Init, ("KeyFound:%s\n", KeyNameStr))

    if (my_lstricmp(KeyNameStr, name) == 0)  // match
    {
      // we got trouble, our name matches one already in registry
      //MyKdPrint(D_Init, ("Not a good name.\n"))
      return 1; // err: name clash
    }
  }
  return 0;  // ok, no name clash
}

/*----------------------------------------------------------------------
 RcktInitPollTimer - Initialize the poll timer for no interrupt operation.
   The fastest we can poll seems to be 10ms under NT.
|----------------------------------------------------------------------*/
NTSTATUS RcktInitPollTimer(void)
{
  MyKdPrint(D_Init,("RcktInitPollTimer\n"))
  KeInitializeDpc(&Driver.TimerDpc, TimerDpc, NULL);

  KeInitializeTimer(&Driver.PollTimer);

  // ScanRate is registry option in MS units.
  if (Driver.ScanRate < 1) Driver.ScanRate = 1;
  if (Driver.ScanRate > 40) Driver.ScanRate = 40;

  // NT Interval unit is 100nsec so to get Freq polls/sec
  Driver.PollIntervalTime.QuadPart = Driver.ScanRate * -10000;
#ifdef S_VS
  Driver.Tick100usBase = 100; // 100us base units(typical:100)
  Driver.TickBaseCnt = Driver.ScanRate * 10;
  KeQuerySystemTime(&Driver.IsrSysTime);
  KeQuerySystemTime(&Driver.LastIsrSysTime);
#endif

  Driver.TimerCreated = 1;  // tells to deallocate
  return STATUS_SUCCESS;
}

/*-----------------------------------------------------------------------
 InitSocketModems -
    This function is responsible for clearing the initial reset state on
    any device with SocketModems and initializing the location information
    (ROW) for each SocketModem on the device.  We only initialize extensions
    for which the device extension has the ModemDevice field enabled in
    the config information.  VS2000 devices don't need to be cleared from
    reset since the firmware does that.
|-----------------------------------------------------------------------*/
void InitSocketModems(PSERIAL_DEVICE_EXTENSION ext)
{
  DEVICE_CONFIG *cfg = ext->config;
  PSERIAL_DEVICE_EXTENSION portex,head_portex;

  MyKdPrint(D_Init,("InitSocketModems\n"))

  // use the PDO port list, if present since they start up first under nt5
  head_portex = (ext->port_pdo_ext) ? ext->port_pdo_ext : ext->port_ext;

  if (!cfg->ModemDevice)  return;

#ifdef S_RK
/*
    RMII boards don't require ROW codes set...
*/
    if (
    ((cfg->PCI_DevID == PCI_DEVICE_RMODEM6)       
    ||
    (cfg->PCI_DevID == PCI_DEVICE_RMODEM4))
    &&
    (cfg->PCI_RevID == PCI_REVISION_RMODEM_II)
    )
	return;

#ifdef MDM_RESET
    // in case the modems are hung up, we'd like server reloads to clear them
    // up...so, even though it's likely the modems are in reset state already,
    // put them there again...
  portex = head_portex;
  while (portex)
  {
    ModemReset(portex,1);
    portex = portex->port_ext;
  }

    // allow the socketmodems to reset...
  time_stall(Driver.MdmSettleTime);
#endif

    // clear the ports on the board from the reset state
  portex = head_portex;
  while (portex)
  {
    ModemReset(portex, 0);
    portex = portex->port_ext;
  }

    // allow the socketmodems to settle after clearing them from reset
  time_stall(Driver.MdmSettleTime);

#endif
  time_stall(20);
/*
    send the localization string (ROW) to each socketmodem, whether internal 
    or external (VS2000)...
*/
  portex = (ext->port_pdo_ext) ? ext->port_pdo_ext : ext->port_ext;

  while (portex) {
    ModemWriteROW(portex, Driver.MdmCountryCode);
    portex = portex->port_ext;
  }
  MyKdPrint(D_Init,("InitSocketModems: exit\n"))
}

#ifdef TRYED_IT_WORKED_REALLY_BAD
/*-----------------------------------------------------------------------
 DumpTracefile -
|-----------------------------------------------------------------------*/
static int DumpTracefile(void)
{
  NTSTATUS ntStatus;
  HANDLE NtFileHandle;
  OBJECT_ATTRIBUTES ObjectAttributes;
  IO_STATUS_BLOCK IoStatus;
  USTR_160 uname;
  FILE_STANDARD_INFORMATION StandardInfo;
  //ULONG LengthOfFile;
  static char *def_filename = {"\\SystemRoot\\system32\\VSLINKA\\trace.txt"};
  BYTE *buf;


  buf = our_locked_alloc(1010,"dump");

  CToUStr((PUNICODE_STRING)&uname, def_filename, sizeof(uname));

  InitializeObjectAttributes ( &ObjectAttributes,
	      &uname.ustr,
	      OBJ_CASE_INSENSITIVE,
	      NULL,
	      NULL );

#ifdef COMMENT_OUT

  ntStatus = ZwCreateFile( &NtFileHandle,
	  SYNCHRONIZE | FILE_WRITE_DATA | FILE_APPEND_DATA,
//                           GENERIC_WRITE | SYNCHRONIZE,
	  &ObjectAttributes,
	  &IoStatus,
	  NULL,              // alloc size = none
	  FILE_ATTRIBUTE_NORMAL,
	  FILE_SHARE_WRITE,
	  FILE_SUPERSEDE,
	  FILE_SYNCHRONOUS_IO_NONALERT,
	  NULL,  // eabuffer
	  0);   // ealength

  if (!NT_SUCCESS(ntStatus))
  {
    Eprintf("Dump Error B");
    our_free(buf, "dump");
    return 1;
  }

  // Write the file from our buffer.
  ntStatus = ZwWriteFile(NtFileHandle,
      NULL,NULL,NULL,
      &IoStatus,
      "Start of file>   ",
      14,
      FILE_WRITE_TO_END_OF_FILE, NULL);

  while (!q_empty(&Driver.DebugQ))
  {
    int q_cnt;
    q_cnt = q_count(&Driver.DebugQ);
    if (q_cnt > 1000)
      q_cnt = 1000;
    q_get(&Driver.DebugQ, buf, q_cnt);

    // Write the file from our buffer.
    ntStatus = ZwWriteFile(NtFileHandle,
	NULL,NULL,NULL,
	&IoStatus,
	buf,
	q_cnt,
	FILE_WRITE_TO_END_OF_FILE, NULL);
  }

  if (!NT_SUCCESS(ntStatus))
     Eprintf("Dump Error A:%d",ntStatus);

  ZwClose(NtFileHandle);
#endif

  our_free(buf, "dump");
  return 0;
}
#endif


/********************************************************************

    RocketModem II loader stuff...

********************************************************************/
#ifdef S_RK
/*
   responses are forced to upper case for ease in checking (response case
   varies depending on whether the modem was loaded already or not...
*/
#define  MODEM_LOADCHECK_CMD     "ATI3\r"
#define  MODEM_RESET_CMD         "ATZ0\r"
#define  MODEM_LOAD_CMD          "AT**\r"

#define  MODEM_LOADCHECK_RESP    "V2.101A2-V90_2M_DLS_RAM\r\n"

#define  DOWNLOAD_INITIATED_RESP "DOWNLOAD INITIATED ..\r\n"
#define  CSM_READY_RESP          "115.2K\r\n"
#define  FIRMWARE_READY_RESP     "DEVICE SUCCESSFULLY PROGRAMMED\r\nCHECKSUM: "
#define  OK_RESP                 "OK"


/**********************************************************************

   send ATI3 to determine if modem is loaded...

**********************************************************************/
static int
RM_Snd_ATI3_Command(MODEM_STATE *pModemState)
{
/*
    discard any data currently in the receive FIFO...
*/
    if (RxFIFOReady(pModemState->portex)) {

	    pModemState->status = RMODEM_FAILED;

	    Eprintf("Warning: Modem on %s overrun",
			pModemState->portex->SymbolicLinkName);

	    return(0);
    }

    SEND_CMD_STRING(pModemState->portex,MODEM_LOADCHECK_CMD);

	return(1);
}

/**********************************************************************

   check response to ATI3 - modem loaded or unloaded...

**********************************************************************/
static int 
RM_Rcv_ATI3_Response(MODEM_STATE *pModemState)
{
    int index;

    index = READ_RESPONSE_STRINGS(pModemState->portex,
	    OK_RESP,
	    MODEM_LOADCHECK_RESP,
	    ONE_SECOND);

    switch (index) {
/*
    loaded with the firmware revision this release of RocketPort NT driver expects...
*/
	case 0: {
	    pModemState->status = RMODEM_NOT_LOADED;

	    break;
	}
	case 1: {
	    pModemState->status = RMODEM_LOADED;

	    break;
	}
	default: {
/*
  either it didn't respond, or responded with the wrong string. either way,
  we'll reset it (again) and then reload it...
*/
	    pModemState->status = RMODEM_FAILED;

	    Eprintf("Warning: Modem on %s no response (I3)",
		    pModemState->portex->SymbolicLinkName);

	    return(0);
	}
    }
	return(1);
}

/**********************************************************************

   response to AT** command received...

**********************************************************************/
static int
RM_Rcv_ModemLoad_Response(MODEM_STATE *pModemState)
{
    int index;

    index = READ_RESPONSE_STRING(
		pModemState->portex,
	    DOWNLOAD_INITIATED_RESP,
	    FIVE_SECONDS);

    if (index) {

		pModemState->status = RMODEM_FAILED;

		Eprintf("Warning: Modem on %s no response (LL)",
			pModemState->portex->SymbolicLinkName);

		return(0);
	}

	return(1);
}

/**********************************************************************

   CSM loaded response...

**********************************************************************/
static int 
RM_Rcv_FirmwareLoader_Loaded(MODEM_STATE *pModemState)
{
    int index;

    index = READ_RESPONSE_STRING(
	    pModemState->portex,
	    CSM_READY_RESP,
	    FIVE_SECONDS);

    if (index) {

		pModemState->status = RMODEM_FAILED;

		Eprintf("Warning: Modem on %s no response (FL)",
			pModemState->portex->SymbolicLinkName);

		return(0);
    }
	return(1);
}

/**********************************************************************

    check if firmware loaded successfully...

**********************************************************************/
static int 
RM_Rcv_FirmwareLoaded_Response(MODEM_STATE *pModemState)
{
    int index;
    char    workstring[sizeof(FIRMWARE_READY_RESP) + 4];
    char    *to,*from;

    from = FIRMWARE_READY_RESP;
    to  = workstring;

    index = sizeof(FIRMWARE_READY_RESP) -  1;

    while (index--) 
	    *(to++) = *(from++);
    
    from = ChecksumString;

    index = 4;

    while (index--) 
	    *(to++) = *(from++);
	
    *(to++) = 0; 

    index = 0;

    index = READ_RESPONSE_STRING(
	    pModemState->portex,
	    workstring,
	    FIVE_SECONDS);

    if (index) {

	    pModemState->status = RMODEM_FAILED;

	    Eprintf("Warning: Modem %s bad response to load",
	        pModemState->portex->SymbolicLinkName);

		return(0);
    }

	pModemState->status = RMODEM_LOADED;

	return(1);
}

/**********************************************************************

   write a CSM byte. flush any '.' response...

**********************************************************************/
static int 
RM_Snd_Loader_Data(MODEM_STATE *pModemState)
{
	int     loop;

	loop = 100;
/*
    see if there's any available space in the transmit FIFO. if not, pause...
*/
	while (
	(!TxFIFOReady(pModemState->portex)) 
	&&
	(loop-- > 0)
	) {
/*
    pause for any characters currently in the transmit FIFO to move on out...
*/
	    ms_time_stall(1);
	}
/*
    if still no room, bail out...
*/
	if (!TxFIFOReady(pModemState->portex)) {

		pModemState->status = RMODEM_FAILED;

		Eprintf("Warning: Modem %s won't accept loader",
			pModemState->portex->SymbolicLinkName);

		return(0);
	}
/*
    write a byte, then go on to next modem...
*/
    ModemWrite(
	    pModemState->portex,
	    (char *)&Driver.ModemLoaderCodeImage[pModemState->index++],
	    (int)1);
/*
    discard any data currently in the receive FIFO...
*/
    if (RxFIFOReady(pModemState->portex)) {

	    pModemState->status = RMODEM_FAILED;

	    Eprintf("Warning: Modem %s loader overrun",
	        pModemState->portex->SymbolicLinkName);

		return(0);
    }
	return(1);
}

/**********************************************************************

   write a firmware byte. flush any '.' response...

**********************************************************************/
static int 
RM_Snd_Firmware_Data(MODEM_STATE *pModemState)
{
    int origcount;
	int loop;

	origcount = (int)TxFIFOStatus(pModemState->portex);

	loop = 100;
/*
    see if there's any available space in the transmit FIFO. if not, pause...
*/
	while (
	(!TxFIFOReady(pModemState->portex)) 
	&&
	(loop-- > 0)
	) {
/*
    pause for characters currently in the transmit FIFO to make room...
*/
	    ms_time_stall(1);
	}

	if (!TxFIFOReady(pModemState->portex)) {

		pModemState->status = RMODEM_FAILED;

		Eprintf("Warning: Modem %s won't accept firmware",
			pModemState->portex->SymbolicLinkName);

		return(0);
	}
/*
    write a byte, then go on to next modem...
*/
    ModemWrite(
	    pModemState->portex,
	    (char *)&Driver.ModemCodeImage[pModemState->index++],
	    (int)1);
/*
    discard any data currently in the receive FIFO...
*/
    if (RxFIFOReady(pModemState->portex)) {

	    pModemState->status = RMODEM_FAILED;

	    Eprintf("Warning: Modem %s firmware overrun",
	        pModemState->portex->SymbolicLinkName);

	    return(0);
    }
	return(1);
}

/**********************************************************************

   send modem load AT command...

**********************************************************************/
static int 
RM_Snd_ModemLoad_Command(MODEM_STATE *pModemState)
{
	SEND_CMD_STRING(pModemState->portex,MODEM_LOAD_CMD);

	return(1);
}

/**********************************************************************

   shutdown modem and port...

**********************************************************************/
static int 
RM_CleanUp(MODEM_STATE *pModemState)
{

	if (pModemState->status == RMODEM_FAILED) {

		DownModem(pModemState);

		return(0);
	}

	ModemUnReady(pModemState->portex);

	return(1);
}


#endif

/**********************************************************************

   load RocketModemII devices...

**********************************************************************/
void 
InitRocketModemII(PSERIAL_DEVICE_EXTENSION ext)
{
#ifdef S_RK
    DEVICE_CONFIG *           cfg;
    PSERIAL_DEVICE_EXTENSION  portex,head_portex;
    MODEM_STATE                  ModemState[8];
    int modem_count,
		loaded_modem_count,
	    modem_index,
	    retry;
    ULONG   index,version_index;
    long    checksum;
	char    VersionString[9];
    char    *cptr,*endptr;

//    Eprintf("RocketModemII init start");      // turn on for timing purposes...

    cfg = ext->config;
/*
    verify this is a RMII board, 4 or 6 port, before proceeding further...
*/
    if (!cfg->ModemDevice) {
		return;
	}

    if (
    (cfg->PCI_DevID != PCI_DEVICE_RMODEM6) 
    &&
    (cfg->PCI_DevID != PCI_DEVICE_RMODEM4)
    )  
		return;
 
    if (cfg->PCI_RevID != PCI_REVISION_RMODEM_II)  
		return;
 /*
    use the PDO port list, if present since they start up first under nt5.
    prepare the ports to each modem...
*/
    head_portex = (ext->port_pdo_ext) ? ext->port_pdo_ext : ext->port_ext;

    if (head_portex == (PSERIAL_DEVICE_EXTENSION)NULL) {

		MyKdPrint(D_Init,("InitRocketModemII: No port extensions\r"))

		return;
    }

    retry = 1;

    do {
		modem_count = 0;

		head_portex = (ext->port_pdo_ext) ? ext->port_pdo_ext : ext->port_ext;

		portex = head_portex;

		while ((void *)portex) {

			ModemIOReady(portex,115200);

			ModemState[modem_count].status = RMODEM_NOT_LOADED;
			ModemState[modem_count].portex = portex;
			ModemState[modem_count].index  = 0;

			portex = portex->port_ext;
			++modem_count;
		}
    
		time_stall(ONE_SECOND);  
/*
    after pausing for ports to set up, start with modem hardware reset, before issuing ATI3, 
    making sure that modems are cleaned up and in command mode...
*/
		ModemResetAll(ext);
/*
    enable RMII speaker...
*/
		ModemSpeakerEnable(head_portex);
/*
    start with check on modem load status, by issuing ATI3 to just the first modem. if the first modem
	isn't loaded, assume all the others aren't either. if the first modem is loaded, check the rest. if the
	first modem receive fifo doesn't clear, mark accordingly, then proceed with loading...
*/
		(void) RM_Snd_ATI3_Command(ModemState);
	
		ModemTxFIFOWait(ext);
    
		(void) RM_Rcv_ATI3_Response(ModemState);

		loaded_modem_count = 0;

		if (ModemState[0].status == RMODEM_LOADED) {
/*
    modem 0 was loaded. check remaining modems. if any aren't loaded, load them all...
*/
            ++loaded_modem_count;

			modem_index = 1;

			portex = head_portex->port_ext;

			while ((void *)portex) {

				if (ModemState[modem_index].status != RMODEM_FAILED)  
					(void) RM_Snd_ATI3_Command(&ModemState[modem_index]);
	 
				++modem_index;

				portex = portex->port_ext;
			}
/*
    ATI3 load probe command sent, waiting for OK or loaded firmware revision 
    response. if no modems respond, ignore for now...
*/
			ModemTxFIFOWait(ext);
    
			modem_index = 1;

			portex = head_portex->port_ext;

			while ((void *)portex) {

				if (ModemState[modem_index].status != RMODEM_FAILED)  
					(void) RM_Rcv_ATI3_Response(&ModemState[modem_index]);
	 
				++modem_index;

				portex = portex->port_ext;
			}
/*
    now see if any modems require loading. if any do, reset all modems again,
    and then issue the download modem command to all modems...
*/
    		modem_index = 0;
		
            portex = head_portex->port_ext;

    		while ((void *)portex) {

    			if (ModemState[modem_index++].status == RMODEM_LOADED) 
    				++loaded_modem_count;

    			portex = portex->port_ext;
    		}
		}
/*
	if any modems are unloaded, load them all...
*/
		if (loaded_modem_count != modem_count) {

			ModemResetAll(ext);

			(void) IssueEvent(ext,RM_Snd_ModemLoad_Command,ModemState);
/*
    load commands output. while they're leaving the transmit FIFO, 
    read in the CSM loader and modem firmware files...
*/
			if (LoadModemCode((char *)NULL,(char *)NULL)) {

				Eprintf("Warning: Modem firmware file error");

				FreeModemFiles();

				continue;
			}
/*
    wait until the download commands are truly gone. then start waiting for
    the response. if no modems respond, bail out...
*/
			ModemTxFIFOWait(ext);

			if (IssueEvent(ext,RM_Rcv_ModemLoad_Response,ModemState) == 0) {

				FreeModemFiles();

				continue;
			}

			modem_index = 0;
			while (modem_index < modem_count) 
				ModemState[modem_index++].index = 0;
/*  
    response received, apparently. grind through CSM loader file, sending a byte to 
    all modems...
*/
			index = 0;
			while (index++ < Driver.ModemLoaderCodeSize)   
				(void) IssueEvent(ext,RM_Snd_Loader_Data,ModemState);
/*
    spin while transmit FIFOs clear, then pause for responses to arrive...
*/
			ModemTxFIFOWait(ext);
/*
    wait for loading at 115.2K response to CSM load. after response, pause
    a moment for any remaining receive data to arrive. bail out if no modems
    respond...
*/
			if (IssueEvent(ext,RM_Rcv_FirmwareLoader_Loaded,ModemState) == 0) {

				MyKdPrint(D_Init,("InitRocketModemII: No recognized responses to loader load datastream\r"))

				FreeModemFiles();

				continue;
			}

			time_stall(HALF_SECOND);

			modem_index = 0;
			while (modem_index < modem_count) 
				ModemState[modem_index++].index = 0;
/*
    grind through firmware file, sending a byte to all modems. skip the location
	in the binary where the checksum will reside - it's just trash right now, but
	space still has to be set aside for it - but don't include the trash in the 
	checksum (usually 0xFFFF)...
*/
			checksum = 0x00008000;
			index = 0;
			version_index = 0;

			while (index < Driver.ModemCodeSize) {

				(void) IssueEvent(ext,RM_Snd_Firmware_Data,ModemState);
	
				if (
				(index != (unsigned long)0xFFBE) 
				&&
				(index != (unsigned long)0xFFBF)
				)
					checksum += Driver.ModemCodeImage[index];
/*
    attempt to isolate the firmware version. version should be in form 'Vn.nnnan'. note
    that we _could_ send another ati3 command to a representative modem to pick up the version
    number after the load is complete, but that would take additional time...

    also, note that though we've sent an ati3 command to at least one modem - so we have a 
    pretty good idea what the version is supposed to be based on the string we're expecting 
    on the response - we'll pretend that isn't applicable at this point to avoid dependencies 
    on the ati3 command... 
    
    whether that's a good idea or not remains to be seen. but the following processing seems 
    harmless at this time. if the form of the version changes, though, it might be annoying 
    to change the ati3 response string AND the following code to fit the new version form...
*/
                if (
                (Driver.ModemCodeImage[index] == VERSION_CHAR)
                &&
                (!gModemToggle)
                &&
                (!version_index) 
                ) {
/*
    only look for the version on the first modem board load, and if we haven't found the version yet,
    see if the current character is a 'V'. if so, start the process of examining the following characters...
*/
                    cptr = &Driver.ModemCodeImage[index];
                    endptr = Driver.ModemCodeImage + Driver.ModemCodeSize;

                    while (version_index < sizeof(VersionString)) {
/*
    are we about to go past the end of the file? if so, bail out...
*/
                        if (cptr >= endptr) {
                            version_index = 0;
                            break;
                        }
/*
    check if this character looks ok...
*/
                        if (
                        (*cptr < '.') 
                        ||
                        (*cptr > 'Z')
                        ) {
/*
    not a printable-enough character. have we enough characters to assume this is the version string? if not,
    give up, start search over. if we do, though, then we're done, bail out...
*/
                            if (version_index != (sizeof(VersionString) - 1))                     
                                version_index = 0;
                             
                            break;
                        }
/*
    printable character. if this is the third character in the string, though, it must be a dot. if not,
    give up, start search over...
*/
                        if (
                        ((*cptr == '.')
                        &&
                        (version_index != 2))
                        ||
                        ((*cptr != '.')
                        &&
                        (version_index == 2))
                        ) {
                            version_index = 0;
                            break;
                        }
/*
    printable character, save it away for later. this includes the leading 'V', incidentally...
*/
                        VersionString[version_index++] = *(cptr++);
                        VersionString[version_index] = 0;
                    }                        
                }
				index++;
		    }

		    ChecksumAscii((unsigned short *)&checksum);
/*
	output one time messages. the version shouldn't change from modem board to modem board, and 
	neither should the computed checksum (though we do recompute it)...
*/
			if (!gModemToggle) {

                if (version_index) {
			        Eprintf("RocketModemII firmware %s-%s",VersionString,ChecksumString);
				}
				else if (ChecksumString[0]) {
					Eprintf("RocketModemII checksum %s",ChecksumString);
				}
			}
/*
    all done with files, release them...
*/
		    FreeModemFiles();
/*
    spin while transmit FIFOs clear, then pause for response to arrive...
*/
		    ModemTxFIFOWait(ext);
/* 
    wait for successful load message from each modem...
*/
		    if (IssueEvent(ext,RM_Rcv_FirmwareLoaded_Response,ModemState) == 0) {

				MyKdPrint(D_Init,("InitRocketModemII: No recognized responses to firmware load datastream\r"))
		
				continue;
		    }
		}
/*
    pause for newly-loaded modems to settle down...
*/
		time_stall(HALF_SECOND);   
/*
    unready ports, reset ports associated with any failing modems. bail out if done...
*/
        if (IssueEvent(ext,RM_CleanUp,ModemState) == modem_count)  
			break;

    } while (retry--);

	++gModemToggle;

//    Eprintf("RocketModemII init end");    // turn on for timing purposes...

#endif
}

#ifdef S_RK

/**********************************************************************

   check response...

**********************************************************************/
int 
IssueEvent(PSERIAL_DEVICE_EXTENSION ext,int (*modemfunc)(),MODEM_STATE *pModemState)
{
    PSERIAL_DEVICE_EXTENSION        portex;
    int   responding_modem_count;
/*
    issue event to each modem...
*/
    responding_modem_count = 0;

    portex = (ext->port_pdo_ext) ? ext->port_pdo_ext : ext->port_ext;

    while ((void *)portex) {

		if (pModemState->status != RMODEM_FAILED) { 
			responding_modem_count += (modemfunc)(pModemState);
		}
	 
		++pModemState;

	portex = portex->port_ext;
    }

    return(responding_modem_count);
}

/**********************************************************************

   dynamic delay for transmit. waits only as long as necessary, but 
   doesn't get caught if a transmit fifo stalls (for whatever reason)...

**********************************************************************/
void 
ModemTxFIFOWait(PSERIAL_DEVICE_EXTENSION ext)
{
    PSERIAL_DEVICE_EXTENSION  portex;
    int index,activity;
	int     fifo_count[16];                 // arbitrary, but reasonably safe, array size
	int     fifo_stall[16];                 // ditto
/*
    build baseline transmit fifo counts, init stall counts to zero...
*/
    portex = (ext->port_pdo_ext) ? ext->port_pdo_ext : ext->port_ext;

	index = 0;

	while ((void *)portex) {
		fifo_count[index] = (int)TxFIFOStatus(portex);
		fifo_stall[index] = 0;
		++index;
	portex = portex->port_ext;
	}
/*
    loop until all transmit fifos are empty, or we've given up on the stalled ones...
*/
	do {
		index = 0;
		activity = 0;
    
		portex = (ext->port_pdo_ext) ? ext->port_pdo_ext : ext->port_ext;

		while ((void *)portex) {
/*
    check only those ports that indicate data in the transmit fifo, but then only as
	long as they don't appear to be stalled...
*/
			if (
			((int)TxFIFOStatus(portex))
			&&
			(fifo_stall[index] < MAX_STALL)
			) {

				if (fifo_count[index] == (int)TxFIFOStatus(portex)) {
/*
    pause for a non-moving transmit fifo, flag this fifo as suspect...
*/
					fifo_stall[index]++;
					ms_time_stall(1);
				}
				else {
/*
    this particular transmit fifo count changed. pick up new value to monitor. unflag this 
	fifo as suspect...
*/
					fifo_count[index] = (int)TxFIFOStatus(portex);
					fifo_stall[index] = 0;
				}
/*
    whether they're stalled or not, flag fifos as still active. this goes on until
	they're empty, or stall limit count is reached...
*/
				++activity;
			}
			portex = portex->port_ext;
			++index;
		}
/*
	still some (apparent) activity in transmit fifos? yep, loop some more...
*/
    } while (activity);
}

/**********************************************************************

  unready and reset modem...

**********************************************************************/
void
DownModem(MODEM_STATE *pModemState)
{
    ModemUnReady(pModemState->portex);

    ModemReset(pModemState->portex,1);

    time_stall(Driver.MdmSettleTime);

    ModemReset(pModemState->portex,0);
}


/**********************************************************************

   reset all modems on this board at the same time...

**********************************************************************/
void 
ModemResetAll(PSERIAL_DEVICE_EXTENSION ext)
{
    PSERIAL_DEVICE_EXTENSION  portex;

    portex = (ext->port_pdo_ext) ? ext->port_pdo_ext : ext->port_ext;

    while ((void *)portex) {

	ModemReset(portex,1);

	portex = portex->port_ext;
    }

    time_stall(HALF_SECOND);

    portex = (ext->port_pdo_ext) ? ext->port_pdo_ext : ext->port_ext;

    while ((void *)portex) {

	ModemReset(portex,0);
	portex = portex->port_ext;
    }

    time_stall(ONE_SECOND);

}

/**********************************************************************

   2 byte conversion to ascii...

**********************************************************************/
void 
ChecksumAscii(unsigned short *valueptr)
{
    int     count,index;
    unsigned short   work;

    ChecksumString[4] = 0;

    index = 0;
    count = 3;

    do {
	work = (*valueptr) & 0x7fff;

	work >>= (count * 4);

	work &= 0x000F;

	if (work > 9)
	    work += '7';
	else
	    work += '0';

	ChecksumString[index++] = (unsigned char)work;

    } while (count--);
}
#endif

/*********************************************************************************
*
* get_comdb_offsets
*
*********************************************************************************/
static int get_comdb_offsets( IN char *portLabel, OUT int *indx, OUT BYTE *mask )
{
	char	*pComLbl;
	int     i, portNum, portIndx;
	BYTE    portMask;

    // Make sure a COMxx string is being passed in

	ASSERT( portLabel );
	ASSERT( indx );
	ASSERT( mask );

	if ( strlen( portLabel ) < 4 ) {

		return 0;
	}

	if ( strncmp( portLabel, "COM", 3 ) ) {

		return 0;
	}

    // A lot of checking, but if the wrong ComDB bit is cleared, the 
    // corresponding COM# may get reassigned although another device
    // is using it.

	pComLbl = portLabel + 3;
	for ( i = 0; pComLbl[i]; i++ ) {

		if (!our_isdigit( pComLbl[i] )) {

			return 0;
		}
	}

    // Convert the string to numeric, then translate into bit & byte 
	// offsets

	portNum = getint( pComLbl, NULL );

	portMask = (BYTE) (1 << ( (portNum - 1) % 8 ));
	portIndx = (int) ((portNum - 1) >> 3);

	MyKdPrint( D_Init, ("Mask value for COM%d is 0x%02x at byte index %d\n",
		portNum, portMask, portIndx ) );

	*indx = portIndx;
	*mask = portMask;

	return portNum;
}


/*********************************************************************************
*
* get_com_db
*
* Makes sure the bit in the \Registry\Machine\System\CurrentControlSet\Control\COM Name Arbiter
* for the specific port gets cleared on an uninstall.  Ordinarily the PnP Manager
* does this automatically but old builds of W2000 don't nor do more recent builds
* under certain circumstances.  If this bit isn't cleared the OS won't reuse the 
* COM port number if the RocketPort is re-installed or another serial device is
* installed.
*
*********************************************************************************/
static char *szRMSCCComNameArbiter =
	{ "\\Registry\\Machine\\System\\CurrentControlSet\\Control\\COM Name Arbiter" };
static char *szValueID = { "ComDB" };

int clear_com_db( char *szComport )
{
	HANDLE  key_handle = NULL;
//	BYTE    *buffer;
	BYTE    *data_ptr = NULL;
	int     i, stat, indx, port_num;
	BYTE    portMask;
	USTR_40 ubuf;		// Unicode key name 
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    ULONG   length;

	// Get the COM #

    indx = 0;
	portMask = 0;
	if ( szComport != NULL ) {

		port_num = get_comdb_offsets( szComport, &indx, &portMask );

		if ( port_num < 3 || port_num > 256 ) {

			MyKdPrint( D_Error, ("Invalid COM port number from %d\n", szComport) );
			return 1;
		}
	}
	else {

		MyKdPrint( D_Error, ("COM port parameter was NULL\n") );
		return 1;
	}

    // Open the registry key

	stat = our_open_key( &key_handle, 
		                 NULL,
						 szRMSCCComNameArbiter,
						 KEY_ALL_ACCESS );

    if ( stat ) {

		MyKdPrint(D_Error, ("Unable to find Com Port Arbiter key\n"));
		return 1;
	}

    // convert our name to unicode

    CToUStr((PUNICODE_STRING) &ubuf, // where unicode struct & string gets put
            szValueID,               // our c-string we wish to convert
            sizeof(ubuf));

// The 2-pass ZwQueryValueKey approach ensures accurate buffer size allocation.  
// Pass 1 with a NULL buffer parameter returns the length of the 
// PKEY_VALUE_PARTIAL_INFORMATION structure.  After allocating a buffer of
// this length, pass 2 reads the structure.  The trick is to ignore any return
// code on pass 1 except STATUS_OBJECT_NAME_NOT_FOUND, i.e., the value doesn't
// exist.

	// Determine the required size for the registry data buffer

	stat = ZwQueryValueKey( key_handle,
		                    (PUNICODE_STRING) &ubuf,
							KeyValuePartialInformation,
							NULL,
							0,
							&length);

	if ( stat == STATUS_OBJECT_NAME_NOT_FOUND || length == 0L ) {

		MyKdPrint(D_Error, ("Unable to find %s in specified key\n", szValueID));
		ZwClose( key_handle );
		return 1;
	}

    MyKdPrint(D_Init, 
		("Allocating PKEY_VALUE_PARTIAL_INFORMATION buffer: %d bytes\n", length));

	// Make a buffer for the KEY_VALUE_PARTIAL_INFORMATION struct

	KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION) ExAllocatePool( PagedPool, length );

	if ( KeyValueInfo == NULL ) {

		MyKdPrint(D_Error, ("Unable to allocate PKEY_VALUE_PARTIAL_INFORMATION struct\n"))
		ZwClose( key_handle );
		return 1;
	}

	RtlZeroMemory( KeyValueInfo, length );

	// Now get the actual data structure

	stat = ZwQueryValueKey( key_handle,
		                    (PUNICODE_STRING) &ubuf,
							KeyValuePartialInformation,
							KeyValueInfo,
							length,
							&length );

	if ( !NT_SUCCESS(stat) || length == 0L ) {

		MyKdPrint(D_Error, ("Unable to read PKEY_VALUE_PARTIAL_INFORMATION struct\n"));
		ExFreePool( KeyValueInfo );
		ZwClose( key_handle );
		return 1;
	}

	length = KeyValueInfo->DataLength;
	MyKdPrint(D_Init, ("Data buffer length is %d bytes\n", length));

	if ( KeyValueInfo->Type != REG_BINARY ) {
		MyKdPrint(D_Error, ("Unexpected registry type in PKEY_VALUE_PARTIAL_INFORMATION struct\n"));
		ExFreePool( KeyValueInfo );
		ZwClose( key_handle );
		return 1;
	}

	data_ptr = (PCHAR)(&KeyValueInfo->Data[0]);
    if ( data_ptr ) {

		MyKdPrint(D_Init, ("ComDB byte %d is 0x%02x\n", indx, data_ptr[indx]));
		if ( (data_ptr[indx] & portMask) != 0 ) {

			MyKdPrint(D_Init, 
				("Clearing bit position 0x%02x in ComDB byte value 0x%02x\n", 
				portMask, data_ptr[indx]));
			data_ptr[indx] &= ~portMask;
			
			// Now we write the modified data back to the registry

			stat = our_set_value( key_handle,
				                  (char *)szValueID,
								  data_ptr,
								  length,
								  REG_BINARY);
			if ( stat ) {

				MyKdPrint(D_Error, ("Unable to write ComDB value\n"));
				ExFreePool( KeyValueInfo );
				ZwClose( key_handle );
				return 1;
			}
		}
		else {

			// Previously cleared

			MyKdPrint(D_Init, 
				("Bit position 0x%02x already cleared in ComDB byte value 0x%02x!\n", 
				portMask, data_ptr[indx]));
		}
	}

	// cleanup

    ExFreePool( KeyValueInfo );
	ZwClose( key_handle );

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\initrk.c ===
/*-------------------------------------------------------------------
| initrk.c - main init code for RocketPort/Modem NT device driver.
   Contains mostly initialization code.
 Copyright 1996-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

char *szResourceClassName = {"Resources RocketPort"};

MODEM_IMAGE * ReadModemFile(MODEM_IMAGE *mi);
void FreeModemFiles();

/*----------------------------------------------------------------------
 FindPCIBus -
    Purpose:  To query system for pci bus.  If there is a PCI bus
              call FindPCIRocket to check for PCI rocket cards.
    Returns:  Bus number of the PCI bus, or 0 if no PCI bus found.
|----------------------------------------------------------------------*/
UCHAR  FindPCIBus(void)
{
  NTSTATUS Status;
  int i,NumPCIBuses=0;
  unsigned char tmpstr[8];  // place to put data

  for(i=0;i<255;++i)
  {
    Status = HalGetBusData(PCIConfiguration,
                           i,  // bus
                           0,  // slot
                           (PCI_COMMON_CONFIG *) tmpstr, // ptr to buffer
                           2);  // get two bytes of data

    if (Status == 0)   // No more PCI buses
        break;

    if (Status >= 2)  // the bus exists
        ++NumPCIBuses;
  }

  MyKdPrint(
    D_Init,
      ("Found %d PCI Bu%s\n",
      NumPCIBuses,
      (NumPCIBuses != 1 ? "sses" : "s")))

  return((UCHAR)NumPCIBuses);
}

/*----------------------------------------------------------------------
 FindPCIRockets -  Gather info on all rocketport pci boards in the system.
    Returns:  0 if found, 1 if not found.
|----------------------------------------------------------------------*/
int FindPCIRockets(UCHAR NumPCI)
{
  PCI_COMMON_CONFIG *PCIDev;
  UCHAR i;
  NTSTATUS Status;
  int Slot;
  int find_index = 0;

  MyKdPrint(D_Init,("FindPciRocket\n"))

  RtlZeroMemory(&PciConfig,sizeof(PciConfig));

  PCIDev = ExAllocatePool(NonPagedPool,sizeof(PCI_COMMON_CONFIG));
  if ( PCIDev == NULL ) {
    Eprintf("FindPCIRockets no memory");
    return 1;
  }
  for(i=0;i<NumPCI;++i)
  {
    for(Slot = 0;Slot < 32;++Slot) /*5 bits for device 32 = 2^5*/
    {
      // get a few bytes of pci-config space(vendor-id & device-id).
      Status = HalGetBusData(PCIConfiguration,i,Slot,PCIDev,0x4);
      if (Status == 0)
      {
        Eprintf("PCI Bus %d does not exist.",i);
      }

      if (Status > 2)        /* Found Device Is it ours? */
      {
        if (PCIDev->VendorID == PCI_VENDOR_ID)
        {

////////////////new///////////////////////
		switch (PCIDev->DeviceID)
			{
			case PCI_DEVICE_4Q:   // 4 Port Quadcable
			case PCI_DEVICE_4RJ:   // 4 Port RJ
			case PCI_DEVICE_8RJ:   // 8 Port RJ
			case PCI_DEVICE_8O:   // 8 Port Octacable
			case PCI_DEVICE_8I:  // 8 Port interface
			case PCI_DEVICE_SIEMENS8:
			case PCI_DEVICE_SIEMENS16:
			case PCI_DEVICE_16I:  //16 Port interface
			case PCI_DEVICE_32I:  // 32 Port interface
			case PCI_DEVICE_RPLUS2:
			case PCI_DEVICE_422RPLUS2:
			case PCI_DEVICE_RPLUS4:
			case PCI_DEVICE_RPLUS8:
			case PCI_DEVICE_RMODEM6:
			case PCI_DEVICE_RMODEM4:

				break;

			default:

				continue;
			}  // switch

//////////////////////////////////////////

          // get 0x40 worth of pci-config space(includes irq, addr, etc.)
          Status = HalGetBusData(PCIConfiguration,i,Slot,PCIDev,0x40);

          if (Driver.VerboseLog)
            Eprintf("PCI Board found, IO:%xh, Int:%d ID:%d.",
                               PCIDev->u.type0.BaseAddresses[0]-1,
                               PCIDev->u.type0.InterruptLine,
                               PCIDev->DeviceID);

          PciConfig[find_index].BusNumber = i; //get from previous halquerysysin
          PciConfig[find_index].PCI_Slot = Slot;
          PciConfig[find_index].PCI_DevID = PCIDev->DeviceID;
          PciConfig[find_index].PCI_RevID = PCIDev->RevisionID;
          PciConfig[find_index].PCI_SVID = PCIDev->u.type0.SubVendorID;
          PciConfig[find_index].PCI_SID = PCIDev->u.type0.SubSystemID;
          PciConfig[find_index].BaseIoAddr =
              PCIDev->u.type0.BaseAddresses[0]-1;
          PciConfig[find_index].NumPorts = id_to_num_ports(PCIDev->DeviceID);
          if (PCIDev->u.type0.InterruptLine != 255)
          {
            MyKdPrint(D_Init,("Saving the Interrupt: %d\n",
                    PCIDev->u.type0.InterruptLine))

            PciConfig[find_index].Irq = PCIDev->u.type0.InterruptLine;
          }

          if (Driver.VerboseLog)
             Eprintf("Bus:%d,Slt:%x,Dev:%x,Pin:%x",
                 i, Slot, PCIDev->DeviceID, PCIDev->u.type0.InterruptPin);

          if ((PCIDev->Command & 1) == 0)
          {
            if (Driver.VerboseLog)
              Eprintf("Turn on PCI io access");

            PCIDev->Command = PCI_ENABLE_IO_SPACE;
            Status = HalSetBusDataByOffset(PCIConfiguration,
                           i,  // bus
                           Slot,  // slot
                           &PCIDev->Command,
                           FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
                           sizeof(PCIDev->Command));  // len of buffer
          }

          MyKdPrint(D_Init,("Ctlr: __ Slot: %x Device: %x, Base0: %x, IPin: %x, ILine: %x\n",
             Slot,PCIDev->DeviceID,PCIDev->u.type0.BaseAddresses[0]-1,
             PCIDev->u.type0.InterruptPin,
               PCIDev->u.type0.InterruptLine))
          if (find_index < MAX_NUM_BOXES)
            ++find_index;
        } // if (PCIDev->VendorID == PCI_VENDOR_ID)
      }   // if (Status > 2)
    }     // pci slots
  }       // pci buses

  ExFreePool(PCIDev);

  if (find_index > 0)
    return 0;   // ok: found
  return 1;     // err: not found
}

/*----------------------------------------------------------------------
 FindPCIRocket -  Help enumerate Rocketport PCI devices.  Fills in
   enties in config structure.

 match_option : 0 - match exact, 1 - match if desired ports <= actual.
    Returns:  0 if found, 1 if not found.
|----------------------------------------------------------------------*/
int FindPCIRocket(DEVICE_CONFIG *config, int match_option)
{
  int brd = 0;
  int good;

  while (PciConfig[brd].BaseIoAddr != 0)
  {
    good = 1;
    if (PciConfig[brd].Claimed)  // used
      good = 0;

    switch (match_option)
    {
      case 0:
        if (id_to_num_ports(PciConfig[brd].PCI_DevID) != config->NumPorts)
          good = 0;
      break;
      case 1:
        if (id_to_num_ports(PciConfig[brd].PCI_DevID) < config->NumPorts)
          good = 0;
      break;
    }

    if (good)  // assign it.
    {
      config->BusNumber  = PciConfig[brd].BusNumber;
      config->PCI_Slot   = PciConfig[brd].PCI_Slot;
      config->PCI_DevID  = PciConfig[brd].PCI_DevID;
      config->PCI_RevID  = PciConfig[brd].PCI_RevID;
      config->PCI_SVID   = PciConfig[brd].PCI_SVID;
      config->PCI_SID    = PciConfig[brd].PCI_SID;
      config->BaseIoAddr = PciConfig[brd].BaseIoAddr;
      config->Irq        = PciConfig[brd].Irq;
      config->BusType    = PCIBus;

      config->AiopIO[0]  = config->BaseIoAddr;

      // bugfix, 9-30-98  9:20 A.M.
      PciConfig[brd].Claimed = 1;  // used

      return 0;  // ok, found
      //SetupConfig(config);  // fill in NumPorts based on model, etc
    }

    ++brd;
  }
  return 1;  // err, not found
}

/*----------------------------------------------------------------------
 RcktConnectInt -  Connect the Driver.isr to an Interrupt
|----------------------------------------------------------------------*/
NTSTATUS RcktConnectInt(IN PDRIVER_OBJECT DriverObject)
{

  NTSTATUS status;

  KINTERRUPT_MODE InterruptMode;
  BOOLEAN ShareVector;
  ULONG Vector;
  KIRQL Irql;
  KAFFINITY ProcessorAffinity;

  MyKdPrint(D_Init,("RcktConnectInt\n"))
  status = STATUS_SUCCESS;

  //------ Get an interrupt vector from HAL
  Vector = HalGetInterruptVector(
                      Driver.irq_ext->config->BusType,
                      Driver.irq_ext->config->BusNumber,
                      Driver.irq_ext->config->Irq,
                      Driver.irq_ext->config->Irq,
                      &Irql,
                      &ProcessorAffinity);

#if DBG
  //Eprintf("b:%d,n:%d,i:%d",
  //                    Driver.irq_ext->config->BusType,
  //                    Driver.irq_ext->config->BusNumber,
  //                    Driver.irq_ext->config->Irq);
#endif
  MyKdPrint(D_Init,("Vector %x Irql %x Affinity %x\n",
                       Vector, Irql, ProcessorAffinity))
  
  MyKdPrint(D_Init,("Connecting To IRQ %x on a %x bus \n",
                       Driver.irq_ext->config->Irq,
                       Driver.irq_ext->config->BusType))

  // Rocket port doesn't need a context for the ISR
  //Driver.OurIsrContext = NULL;
  //Driver.OurIsr = SerialISR;

  if(Driver.irq_ext->config->BusType == PCIBus)
  {
    InterruptMode = LevelSensitive; //PCI style
    ShareVector = TRUE;
  }
  else  // ISA
  {
    InterruptMode = Latched;   //ISA style
    ShareVector = FALSE;
  }

  status = IoConnectInterrupt(
                     &Driver.InterruptObject,
                     (PKSERVICE_ROUTINE) SerialISR, // Driver.OurIsr,
                     NULL,      // Driver.OurIsrContext,
                     NULL,
                     Vector,
                     Irql,
                     Irql,
                     InterruptMode,
                     ShareVector,
                     ProcessorAffinity,
                     FALSE);

  MyKdPrint(D_Init,("Vector %x Irql %x Affity %x Irq %x\n",
                Vector, Irql,
                ProcessorAffinity,
                Driver.irq_ext->config->Irq))

  if (!NT_SUCCESS(status))
  {
    Driver.InterruptObject = NULL;
    MyKdPrint(D_Init,("Not Avalable IRQ:%d, Status:%xH",
                Driver.irq_ext->config->Irq, status))
  }

  return status;
}


/*----------------------------------------------------------------------
 VerboseLogBoards - Log the Board IO, IRQ configuration.
|----------------------------------------------------------------------*/
void VerboseLogBoards(char *prefix)
{
  int k;
  char tmpstr[80];
  PSERIAL_DEVICE_EXTENSION board_ext;

  MyKdPrint(D_Init,("VerboseLogBoards\n"))

  k = 0;
  board_ext = Driver.board_ext;
  while (board_ext != NULL)
  {
    strcpy(tmpstr, prefix);
    Sprintf(&tmpstr[strlen(tmpstr)], " Brd:%d,IO:%xH,NumCh:%d,NumA:%d,Bus:%d",
       k+1,
       board_ext->config->AiopIO[0],
       board_ext->config->NumPorts,
       board_ext->config->NumAiop,
       board_ext->config->BusType);

    //Sprintf(&tmpstr[strlen(tmpstr)], ",Irq:%d", board_ext->config->.Irq);
    Eprintf(tmpstr); // Log it

    board_ext = board_ext->board_ext;
    ++k;
  }
}

/*-----------------------------------------------------------------------
 SetupRocketCfg - Sets up the details in the DEVICE_CONFIG structure
    based on the information passed to it from DriverEntry() or PnP.
   The NT4.0 DriverEntry handling should be easy, because our boards
   are ordered by us.  NT5.0 is more complex, because we may not see
   the "first" rocketport board in the correct order.
|-----------------------------------------------------------------------*/
int SetupRocketCfg(int pnp_flag)
{
  //int i,j;
  //DEVICE_CONFIG *cfctl;

  int have_isa_boards = 0;
  PSERIAL_DEVICE_EXTENSION first_isa_ext;
  PSERIAL_DEVICE_EXTENSION ext;
  int pnp_isa_index = 1;
  ULONG first_isa_MudbacIO;


  MyKdPrint(D_Init,("SetupRocketCfg\n"))
  // Set up the Mudbac I/O addresses
  // see if we have any isa-boards, and mark a ptr to this first board.
  ext = Driver.board_ext;
  while (ext)
  {
    if (ext->config->BusType == Isa)
    {
      have_isa_boards = 1;
    }
    ext = ext->board_ext;  // next in chain
  }  // while ext

  if (have_isa_boards)
  {
    MyKdPrint(D_Init,("Stp1\n"))
    first_isa_ext = FindPrimaryIsaBoard();
    if (first_isa_ext == NULL)
    {
      MyKdPrint(D_Init,("Err1X\n"))
      if (Driver.VerboseLog)
        Eprintf("First Isa-brd not 44H io");
      // return 1;  // err
      first_isa_MudbacIO = 0x1c0;  // this is cheating
    }
    else
    {
      MyKdPrint(D_Init,("Stp2\n"))

      //----- setup the initial Mudback IO
      if (first_isa_ext->config->MudbacIO == 0)
        first_isa_ext->config->MudbacIO = first_isa_ext->config->AiopIO[0] + 0x40;
      first_isa_MudbacIO = first_isa_ext->config->MudbacIO;
    }

    //----- setup any remaining Mudback IO addresses
    ext = Driver.board_ext;
    while (ext)
    {
      if (ext->config->BusType == Isa)
      {
        if ((ext != first_isa_ext) && (ext->config->BaseIoSize == 0x44))
        {
          MyKdPrint(D_Init,("Unused MudbackIO\n"))
          // don't allow them to configure two boards with space for mudback.
          ext->config->BaseIoSize = 0x40;
        }

        if ((ext != first_isa_ext) && (ext->config->BaseIoSize == 0x40))
        {
          if (ext->config->ISABrdIndex == 0)
          {
            // this case shouldn't come up, pnpadd.c code generates index
            // and saves it to the registry.  Or nt40 driverentry does it.
            MyKdPrint(D_Init,("Bad IsaIndx\n"))
            ext->config->ISABrdIndex = pnp_isa_index;
          }
          ++pnp_isa_index;

          // setup the Mudback IO
          ext->config->MudbacIO = first_isa_MudbacIO +
            (ext->config->ISABrdIndex * 0x400);
        }
      }
      ext = ext->board_ext;  // next in chain
    }  // while ext
  }

  // Set up the rest of the Aiop addresses
  ext = Driver.board_ext;
  while (ext)
  {
    ConfigAIOP(ext->config);   //SetupConfig(ext->config);
    ext = ext->board_ext;  // next in chain
  }  // while ext

  return(0);
}

/*-----------------------------------------------------------------------
 ConfigAIOP -  Setup the number of AIOP's based on:

    * if PCI, use the pci-id to determine number of ports, since
    detecting is unreliable do to back-to-back aiop-is slots possibility.

    * if ISA, set to max and let init controller figure it out.
|-----------------------------------------------------------------------*/
int ConfigAIOP(DEVICE_CONFIG *config)
{
  int j;
  int found_ports=0;

  MyKdPrint(D_Init,("ConfigAIOP\n"))

  if (config->BusType == Isa)      /* Set up ISA adrs */
  {
    if (config->NumPorts == 0)
      config->NumAiop=AIOP_CTL_SIZE;  // let init figure it out
    else if (config->NumPorts <= 8)
      config->NumAiop=1;
    else if (config->NumPorts <= 16)
      config->NumAiop=2;
    else if (config->NumPorts <= 32)
      config->NumAiop=4;

    for(j = 1;j < config->NumAiop;j++)         /* AIOP aliases */
      config->AiopIO[j] = config->AiopIO[j - 1] + 0x400;
  }

  if (config->BusType == PCIBus)      // Set up PCI adrs
  {
    switch (config->PCI_DevID)
    {
      case PCI_DEVICE_4Q:   // 4 Port Quadcable
      case PCI_DEVICE_4RJ:   // 4 Port RJ
        found_ports=4;
        config->NumAiop=1;
        config->AiopIO[0] = config->BaseIoAddr;
        break;

      case PCI_DEVICE_8RJ:   // 8 Port RJ
      case PCI_DEVICE_8O:   // 8 Port Octacable
      case PCI_DEVICE_8I:  // 8 Port interface
      case PCI_DEVICE_SIEMENS8:
        found_ports=8;
        config->NumAiop=1;
        config->AiopIO[0] = config->BaseIoAddr;
        break;

      case PCI_DEVICE_SIEMENS16:
      case PCI_DEVICE_16I:  //16 Port interface
        found_ports=16;
        config->NumAiop=2;
        config->AiopIO[0] = config->BaseIoAddr;
        config->AiopIO[1] = config->BaseIoAddr + 0x40;
        break;

      case PCI_DEVICE_32I:  // 32 Port interface
        found_ports=32;
        config->NumAiop=4;
        config->AiopIO[0] = config->BaseIoAddr;
        config->AiopIO[1] = config->BaseIoAddr + 0x40;
        config->AiopIO[2] = config->BaseIoAddr + 0x80;
        config->AiopIO[3] = config->BaseIoAddr + 0xC0;
        break;

      case PCI_DEVICE_RPLUS2:
      case PCI_DEVICE_422RPLUS2:
        found_ports=2;
        config->NumAiop=1;
        config->AiopIO[0] = config->BaseIoAddr;
        config->AiopIO[1] = 0;
        break;

      case PCI_DEVICE_RPLUS4:
        found_ports=4;
        config->NumAiop=1;
        config->AiopIO[0] = config->BaseIoAddr;
        config->AiopIO[1] = 0;
        break;

      case PCI_DEVICE_RPLUS8:
        found_ports=8;
        config->NumAiop=2;
        config->AiopIO[0] = config->BaseIoAddr;
        config->AiopIO[1] = config->BaseIoAddr + 0x40;
        config->AiopIO[2] = 0;
        break;

      case PCI_DEVICE_RMODEM6:
        found_ports=6;
        config->NumAiop=1;
        config->AiopIO[0] = config->BaseIoAddr;
        break;

      case PCI_DEVICE_RMODEM4:
        found_ports=4;
        config->NumAiop=1;
        config->AiopIO[0] = config->BaseIoAddr;
        break;

      default:
        found_ports=0;
        config->NumAiop=0;
        Eprintf("Err,Bad PCI Dev ID!");
        break;
    }  // switch

    // allow for user configured smaller number of ports
    if ((config->NumPorts == 0) || (config->NumPorts > found_ports))
      config->NumPorts = found_ports;

  }  // if pci

  return 0;  // ok
}

/*-----------------------------------------------------------------------
  SerialUnReportResourcesDevice -
    This routine unreports the resources used for the board.
|-----------------------------------------------------------------------*/
VOID SerialUnReportResourcesDevice(IN PSERIAL_DEVICE_EXTENSION Extension)
{
  CM_RESOURCE_LIST resourceList;
  ULONG sizeOfResourceList = 0;
  char name[70];
  BOOLEAN junkBoolean;

  MyKdPrint(D_Init,("UnReportResourcesDevice\n"))
    RtlZeroMemory(&resourceList, sizeof(CM_RESOURCE_LIST));

  resourceList.Count = 0;
  strcpy(name, szResourceClassName);
  our_ultoa(Extension->UniqueId, &name[strlen(name)], 10);

  IoReportResourceUsage(
      CToU1(name),
      Extension->DeviceObject->DriverObject,
      NULL,
      0,
      Extension->DeviceObject,
      &resourceList,
      sizeof(CM_RESOURCE_LIST),
      FALSE,
      &junkBoolean);
}

/*-----------------------------------------------------------------------
 RocketReportResources -
|-----------------------------------------------------------------------*/
int RocketReportResources(IN PSERIAL_DEVICE_EXTENSION extension)
{
  PCM_RESOURCE_LIST resourceList;
  ULONG sizeOfResourceList;
  ULONG countOfPartials;
  PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
  NTSTATUS status;
  PHYSICAL_ADDRESS MyPort;
  BOOLEAN ConflictDetected;
  BOOLEAN MappedFlag;
  int i,j;
  int brd = extension->UniqueId;
  DEVICE_CONFIG *Ctl;
  char name[70];

  MyKdPrint(D_Init,("ReportResources\n"))
  ConflictDetected=FALSE;

  countOfPartials=0;
  Ctl = extension->config;

#ifdef USE_HAL_ASSIGNSLOT
  if (Ctl->BusType == PCIBus)
  {
    //-------- Report the resources indicated by partial list (resourceList)
    strcpy(name, szResourceClassName);
    our_ultoa(extension->UniqueId, &name[strlen(name)], 10);

    status= HalAssignSlotResources (
        &Driver.RegPath,                       // RegistryPath
        CToU1(name),                           // DriverClassName(optional)
        extension->DeviceObject->DriverObject, // DriverObject
          // Driver.GlobalDriverObject,        // 
        NULL,                                  // DeviceObject(optional)
        Ctl->BusType,  // PCIBus
        Ctl->BusNumber,  // Bus Num
        Ctl->PCI_Slot,  // slot num
        &resourceList); // IN OUT PCM_RESOURCE_LIST *AllocatedResources

    if (status != STATUS_SUCCESS)
    {
      if (Driver.VerboseLog)
        Eprintf("Err RR21");
      return(1);
    }
    if (resourceList == NULL)
    {
      if (Driver.VerboseLog)
        Eprintf("Err RR22");
      return(2);
    }

    if (resourceList->Count != 1)
    {
      if (Driver.VerboseLog)
        Eprintf("Err ResCnt RR23");
      return(3);
    }

    countOfPartials = resourceList->List[0].PartialResourceList.Count;
    if ( ((countOfPartials > 2) &&
          (Ctl->PCI_SVID != PCI_VENDOR_ID)) ||
         (countOfPartials < 1)) {
      if (Driver.VerboseLog)
        Eprintf("Err ResCnt RR24");
      return(4);
    }

    if (resourceList->List[0].InterfaceType != PCIBus)
    {
      if (Driver.VerboseLog)
        Eprintf("Err ResCnt RR25");
      return(5);
    }
    partial = &resourceList->List[0].PartialResourceList.PartialDescriptors[0];
    for (i=0; i<(int)countOfPartials; i++)
    {
//    partial->u.Port.Start = MyPort;
//    partial->u.Port.Length = SPANOFMUDBAC;
      switch(partial->Type)
      {
        case CmResourceTypePort:
          if ((partial->u.Port.Length != SPANOFAIOP) &&
              (partial->u.Port.Length != (SPANOFAIOP*2)) &&
              (partial->u.Port.Length != (SPANOFAIOP*3)) &&
              (partial->u.Port.Length != (SPANOFAIOP*4)) )
          {
            if (Driver.VerboseLog)
              Eprintf("Err RR35");
            return 6;
          }
          Ctl->pAiopIO[0] =
             SerialGetMappedAddress(Ctl->BusType,
                     Ctl->BusNumber,
                     partial->u.Port.Start,
                     partial->u.Port.Length,
                     1,  // port-io
                     &MappedFlag,1);

          if (Ctl->pAiopIO[0] == NULL)
          {
            if (Driver.VerboseLog)
              Eprintf("Err RR36");
            return 7;
          }
          Ctl->pAiopIO[1] = Ctl->pAiopIO[0] + 0x40;
          Ctl->pAiopIO[2] = Ctl->pAiopIO[0] + 0x80;
          Ctl->pAiopIO[3] = Ctl->pAiopIO[0] + 0xc0;

          Ctl->AiopIO[0] = partial->u.Port.Start.LowPart;
          Ctl->AiopIO[1] = partial->u.Port.Start.LowPart + 0x40;
          Ctl->AiopIO[2] = partial->u.Port.Start.LowPart + 0x80;
          Ctl->AiopIO[3] = partial->u.Port.Start.LowPart + 0xc0;
          break;

        case CmResourceTypeInterrupt:
#ifdef DO_LATER
#endif
          break;

        case CmResourceTypeMemory:
#ifdef DO_LATER
#endif
          break;

        default:
          if (Driver.VerboseLog)
            Eprintf("Err ResCnt RR26");
          return(8);
      }
      ++partial;  // to next io-resource in list.
    }

    // Release the memory used for the resourceList
    if (resourceList)
      ExFreePool(resourceList);
    resourceList = NULL;

    return(0);
  }
#endif

  if (Ctl->BusType == Isa)
    countOfPartials++;        //Mudbacs only exist on ISA Boards

  MyKdPrint(D_Init,("Report Resources brd:%d bus:%d\n",brd+1, Ctl->BusType))

  for (j=0; j<Ctl->NumAiop; j++)
  {
    if (Ctl->AiopIO[j] > 0)
      countOfPartials++;  // For each Aiop, we will get resources
  }

  if (Driver.irq_ext == extension)
  {
    MyKdPrint(D_Init,("IRQ:%d\n",Driver.SetupIrq))
    countOfPartials++;   // plus 1 for IRQ info
  }

  sizeOfResourceList = sizeof(CM_RESOURCE_LIST) +
                       sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +  // add, kpb
                        (sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)*
                        countOfPartials);

                       // add 64 for slop -kpb(this structure sucks)
  resourceList = ExAllocatePool(PagedPool, sizeOfResourceList+64);

  if (!resourceList)
  {
    if (Driver.VerboseLog)
      Eprintf("No ResourceList");

    EventLog(extension->DeviceObject->DriverObject,
               ////Driver.GlobalDriverObject,
             STATUS_SUCCESS,
             SERIAL_INSUFFICIENT_RESOURCES,
             0, NULL);
    return(9);
  }

  RtlZeroMemory(resourceList, sizeOfResourceList);

  resourceList->Count = 1;
  resourceList->List[0].InterfaceType = Ctl->BusType;
  resourceList->List[0].BusNumber = Ctl->BusNumber;  //change for multibus
  resourceList->List[0].PartialResourceList.Count = countOfPartials;
  partial = &resourceList->List[0].PartialResourceList.PartialDescriptors[0];

  // Account for the space used by the Rocket.
  // Report the use of the Mudbacs on Isa boards only
  if (Ctl->BusType == Isa)
  {
    MyPort.HighPart=0x0;
    MyPort.LowPart=Ctl->MudbacIO;
    partial->Type = CmResourceTypePort;
    partial->ShareDisposition = CmResourceShareDeviceExclusive;
    partial->Flags = CM_RESOURCE_PORT_IO;
    partial->u.Port.Start = MyPort;
    partial->u.Port.Length = SPANOFMUDBAC;
    partial++;
  }

  for (j=0; j<Ctl->NumAiop; j++)
  {
    // Report the use of the AIOPs.
    if (Ctl->AiopIO[j] > 0)
    {
      MyPort.HighPart=0x0;
      MyPort.LowPart=Ctl->AiopIO[j];
      partial->Type = CmResourceTypePort;
      partial->ShareDisposition = CmResourceShareDeviceExclusive;
      partial->Flags = CM_RESOURCE_PORT_IO;
      partial->u.Port.Start = MyPort;
      partial->u.Port.Length = SPANOFAIOP;
      partial++;
    }
    else
    {
      MyKdPrint(D_Init,("Aiop Count Wrong, A.\n"))
      if (Driver.VerboseLog)
        Eprintf("Error RR12");
    }
  }  // end for j


  if (Driver.irq_ext == extension)
  {
    // Report the interrupt information.
    partial->Type = CmResourceTypeInterrupt;

    if(Ctl->BusType == PCIBus)
    {
      partial->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
      partial->ShareDisposition = CmResourceShareShared;
    }
    else // if (Ctl->BusType == Isa)  //Isa and Pci use differnt int mech
    {
      partial->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
      partial->ShareDisposition = CmResourceShareDriverExclusive;
    }

    partial->u.Interrupt.Vector = Driver.SetupIrq;
    partial->u.Interrupt.Level = Driver.SetupIrq;
#ifdef DO_LATER
   // is the above wrong???
#endif
    // partial->u.Interrupt.Affinity = -1; //per CM_PARTIAL_RESOURCE_DESCRIPTOR
    partial++;                          // definition  DbgPrintf
  }

  //-------- Report the resources indicated by partial list (resourceList)
  strcpy(name, szResourceClassName);
  our_ultoa(extension->UniqueId, &name[strlen(name)], 10);

  MyKdPrint(D_Init,("Reporting Resources To system\n"))
  status=IoReportResourceUsage(
      CToU1(name),                     // DriverClassName OPTIONAL,
      extension->DeviceObject->DriverObject,  // DriverObject,
      // Driver.GlobalDriverObject,
      NULL,                          // DriverList OPTIONAL,
      0,                             // DriverListSize OPTIONAL,
      extension->DeviceObject,       // DeviceObject
      resourceList,                  // DeviceList OPTIONAL,
      sizeOfResourceList,            // DeviceListSize OPTIONAL,
      FALSE,                         // OverrideConflict,
      &ConflictDetected);            // ConflictDetected

  if (!NT_SUCCESS(status))
  {
    if (Driver.VerboseLog)
      Eprintf("Err RR13");
    MyKdPrint(D_Init,("Error from IoReportResourceUsage.\n"))
  }

  if (ConflictDetected) 
  {
    Eprintf("Error, Resource Conflict.");
    if (resourceList)
      ExFreePool(resourceList);
    resourceList = NULL;
    EventLog(extension->DeviceObject->DriverObject,
             ////Driver.GlobalDriverObject,
             STATUS_SUCCESS,
             SERIAL_INSUFFICIENT_RESOURCES,
             0, NULL);
    MyKdPrint(D_Init,("Resource Conflict Detected.\n"))
    return(10);
  }

  // OK, even more important than reporting resources is getting
  // the pointers to the I/O ports!!

  if (Ctl->BusType == Isa)
  {
    MyPort.HighPart=0x0;
    MyPort.LowPart=Ctl->MudbacIO;

    Ctl->pMudbacIO =
        SerialGetMappedAddress(Isa,Ctl->BusNumber,MyPort,SPANOFMUDBAC,1,&MappedFlag,1);
    if (Ctl->pMudbacIO == NULL) 
    {
      if (Driver.VerboseLog)
        Eprintf("Err RR15");
      MyKdPrint(D_Init,("Resource Error A.\n"))
      return 11;
    }
  }

  for (j=0; j<Ctl->NumAiop; j++)
  {
    if (Ctl->AiopIO[j] > 0)
    {
      MyPort.HighPart=0x0;
      MyPort.LowPart=Ctl->AiopIO[j];
      Ctl->pAiopIO[j] =
          SerialGetMappedAddress(Ctl->BusType,
                      Ctl->BusNumber,MyPort,SPANOFAIOP,1,&MappedFlag,1);

      if (Ctl->pAiopIO[j] == NULL) 
      {
        if (Driver.VerboseLog)
          Eprintf("Err RR16");
        MyKdPrint(D_Init,("Resource Error B.\n"))
        return 12;
      }

    }
    else
    {
      if (Driver.VerboseLog)
        Eprintf("Err RR17");
      MyKdPrint(D_Init,("Aiop Count Wrong, B.\n"))
      return 13;
    }
  }

  extension->io_reported = 1; // tells that we should deallocate on unload.

  // Release the memory used for the resourceList
  if (resourceList)
    ExFreePool(resourceList);
  resourceList = NULL;
  MyKdPrint(D_Init,("Done Reporting Resources\n"))
  return 0;
}

/*-----------------------------------------------------------------------
 InitController -
|-----------------------------------------------------------------------*/
int InitController(PSERIAL_DEVICE_EXTENSION ext)
{
  int Aiop;                           /* AIOP number */
  CONTROLLER_T *CtlP;                 /* ptr to controller structure */
  int periodic_only = 1;
  CHANNEL_T *Chan;                    /* channel structure */
  CHANNEL_T ch;                       /* channel structure */
  int Irq;
  int freq;                           // poll frequency
  int Ch;                             /* channel number */
  int NumChan;
  static int Dev = 0;
  int Ctl = (int) ext->UniqueId;
  DEVICE_CONFIG *pConfig = ext->config;

//   if (pConfig->pMudbacIO,
  MyKdPrint(D_Init,("InitController\n"))

  if (ext == Driver.irq_ext)  // irq extension
  {
    Irq = pConfig->Irq;
#if DBG
//     Eprintf("Irq Used:%d", Irq);
#endif
    if (Driver.ScanRate == 0)
      freq = FREQ_137HZ;
    else if (Driver.ScanRate <= 2)
    {
      if (pConfig->BusType == PCIBus)
        freq = FREQ_560HZ;
      else
        freq = FREQ_274HZ;
    }
    else if (Driver.ScanRate <= 5)   freq = FREQ_274HZ;
    else if (Driver.ScanRate <= 10)  freq = FREQ_137HZ;
    else if (Driver.ScanRate <= 20)  freq = FREQ_69HZ;
    else if (Driver.ScanRate <= 35)  freq = FREQ_34HZ;
    else if (Driver.ScanRate <= 70)  freq = FREQ_17HZ;
    else                             freq = FREQ_137HZ;
  }
  else
  {
    freq = 0;
    Irq=0;
  }

  if ( (ext->config->BusType == PCIBus) &&
       ((ext->config->PCI_DevID == PCI_DEVICE_RPLUS2) ||
        (ext->config->PCI_DevID == PCI_DEVICE_422RPLUS2) ||
		(ext->config->PCI_DevID == PCI_DEVICE_RPLUS4) ||
        (ext->config->PCI_DevID == PCI_DEVICE_RPLUS8)) )
     ext->config->IsRocketPortPlus = 1;  // true if rocketport plus hardware

  // setup default ClkRate if not specified
  if (ext->config->ClkRate == 0)
  {
    // use default
    if (ext->config->IsRocketPortPlus)  // true if rocketport plus hardware
      ext->config->ClkRate = DEF_RPLUS_CLOCKRATE;
    else
      ext->config->ClkRate = DEF_ROCKETPORT_CLOCKRATE;
  }

  // setup default PreScaler if not specified
  if (ext->config->ClkPrescaler == 0)
  {
    // use default
    if (ext->config->IsRocketPortPlus)  // true if rocketport plus hardware
      ext->config->ClkPrescaler = DEF_RPLUS_PRESCALER;
    else
      ext->config->ClkPrescaler = DEF_ROCKETPORT_PRESCALER;
  }

  // --- stop doing this, 5-7-98, setup now sets, we could check!
  //pConfig->NumPorts = 0;  // this gets calculated in initcontroller

  CtlP = ext->CtlP;      // point to our board struct

  CtlP->ClkPrescaler = (BYTE)ext->config->ClkPrescaler;
  CtlP->ClkRate = ext->config->ClkRate;

  // Initialize PCI Bus and  Dev
  CtlP->BusNumber = (UCHAR)pConfig->BusNumber;
  CtlP->PCI_Slot = (UCHAR)pConfig->PCI_Slot;

  CtlP->PCI_DevID = pConfig->PCI_DevID;
  CtlP->PCI_SVID = pConfig->PCI_SVID;
  CtlP->PCI_SID = pConfig->PCI_SID;

#ifdef TRY_EVENT_IRQ
  periodic_only = 0;
#endif

  if (pConfig->BusType == Isa)
  {
    MyKdPrint(D_Init,("Mbio:%x %x IO len:%x\n",
        pConfig->MudbacIO, pConfig->pMudbacIO, pConfig->BaseIoSize))
  }
  MyKdPrint(D_Init,("Aiopio:%x %x num:%x\n",
      pConfig->AiopIO[0], pConfig->pAiopIO[0], pConfig->NumAiop))

  if (sInitController(CtlP, // Ctl,
                      pConfig->pMudbacIO,
                      pConfig->pAiopIO,
                      pConfig->AiopIO,
                      pConfig->NumAiop,
                      Irq,
                      (unsigned char)freq,
                      TRUE,
                      pConfig->BusType,
                      pConfig->ClkPrescaler) != 0)
  {
    Eprintf("Error, Failed Init, Brd:%d, IO:%xH",
       Ctl, pConfig->AiopIO[0]);
    if (Driver.VerboseLog)
    {
      Eprintf("Init: pM:%x,pA:%x,N:%d,B:%d",
              pConfig->pMudbacIO, pConfig->pAiopIO[0], pConfig->NumAiop,
              pConfig->BusType);
    }
    // This controller was in the registry, but it couldn't be initialized
    pConfig->RocketPortFound = FALSE;
    //pConfig->NumChan = 0; stop messing with NumPorts
    return 2;  // err
  }
  else
  {
    // this controller was successfully initialized
    // if it's the first one found, tell the rest of the init that
    // it should be the one to interrupt.
    pConfig->RocketPortFound = TRUE;
  }

  for(Aiop = 0;Aiop < CtlP->NumAiop; Aiop++)
  {
    if (CtlP->BusType == Isa)
      sEnAiop(CtlP,Aiop);

    NumChan = CtlP->AiopNumChan[Aiop];

    for(Ch = 0; Ch < NumChan; Ch++)
    {
      Chan = &ch;

      //MyKdPrint(D_Init,("sInitChan %d\n", Ch+1))
      if(!sInitChan(CtlP,Chan,Aiop,(unsigned char)Ch))
      {
        if (Driver.VerboseLog)
          Eprintf("Err Ch %d on Brd %d", Ch+1, Ctl+1);

        MyKdPrint(D_Error,("sInitChan %d\n", Ch+1))
        return (-1);
      }
      Dev++;
    }  // for ch
    // pConfig->NumChan += NumChan; [kpb, 5-7-98, stop messing with config]
  }  // for Aiop

  if (Driver.VerboseLog)
  {
    Eprintf("Initialized OK, Brd:%d, IO:%xH",
            Ctl+1, pConfig->AiopIO[0]);
  }

  return 0;
}

/*----------------------------------------------------------------------
  StartRocketIRQorTimer -
|----------------------------------------------------------------------*/
void StartRocketIRQorTimer(void)
{
#ifdef DO_ROCKET_IRQ
  //--------------- Connect to IRQ, or start Timer.
  if (Driver.irq_ext)
  {
    status = RcktConnectInt(DriverObject);
    if (!NT_SUCCESS(status))
    {
      Eprintf("Error,IRQ not found, using Timer!");
      Driver.irq_ext = NULL;
      Driver.SetupIrq = 0;  // use timer instead
    }
  }

  //--- kick start the interrupts
  if (Driver.irq_ext)    // if using interrupt
  {
    CtlP = Driver.irq_ext->CtlP;  // first boards struct
    if(CtlP->BusType == Isa)
    {
      MyKdPrint(D_Init,("ISA IRQ Enable.\n"))
      sEnGlobalInt(CtlP);
    }
    if(CtlP->BusType == PCIBus)
    {
      MyKdPrint(D_Init,("PCI IRQ Enable.\n"))
      sEnGlobalIntPCI(CtlP);
    }
  }
  else
#endif
  {
    MyKdPrint(D_Init,("Initializing Timer\n"))
    RcktInitPollTimer();

    MyKdPrint(D_Init,("Set Timer\n"))
    KeSetTimer(&Driver.PollTimer,
               Driver.PollIntervalTime,
               &Driver.TimerDpc);
  }
}

#ifdef DO_ROCKET_IRQ
/*----------------------------------------------------------------------
  SetupRocketIRQ - 
|----------------------------------------------------------------------*/
void SetupRocketIRQ(void)
{
  PSERIAL_DEVICE_EXTENSION ext;

  //------ Determine a board to use for interrupts
  Driver.irq_ext = NULL;
  if (Driver.SetupIrq != 0)
  {
    ext = Driver.board_ext;
    while(ext)
    {
      if (Driver.SetupIrq == 1)  // auto-pci irq pick
      {
        if ((ext->config->BusType == PCIBus) &&
            (ext->config->Irq != 0))
        {
          Driver.irq_ext = ext; // found a pci-board with irq
          break;  // bail from while
        }
      }
      else
      {
        if (ext->config->BusType == Isa)
        {
          ext->config->Irq = Driver.SetupIrq;
          Driver.irq_ext = ext; // found a isa-board with irq
          break;  // bail from while
        }
      }
      ext = ext->board_ext;  // next
    }
    if (Driver.irq_ext == NULL)  // board for irq not found
    {
      Eprintf("Warning, IRQ not available");
    }
  }
}
#endif

/*----------------------------------------------------------------------
  init_cfg_rocket - rocketport specific startup code.  Setup some of
    the config structs, look for PCI boards in system, match them up.
|----------------------------------------------------------------------*/
NTSTATUS init_cfg_rocket(IN PDRIVER_OBJECT DriverObject)
{
  // Holds status information return by various OS and driver
  // initialization routines.
  UCHAR NumPCIBuses, NumPCIRockets, NumISARockets, all_found;
  PSERIAL_DEVICE_EXTENSION board_ext;

  int do_pci_search = 0;

  //------ get the Box information from setup.exe

  board_ext = Driver.board_ext;
  while (board_ext != NULL)
  {
    if (board_ext->config->IoAddress == 1) // PCI board setup
      do_pci_search = 1;
    board_ext = board_ext->board_ext;
  }

  //---- tally up boards
  //---- interrupting board always first.
  NumPCIRockets = 0;
  NumISARockets = 0;

  // configure ISA boards, and see if we have any pci boards
  board_ext = Driver.board_ext;
  while (board_ext != NULL)
  {
    if (board_ext->config->IoAddress >= 0x100)  // ISA io address
    {
      board_ext->config->BusType = Isa;
      board_ext->config->AiopIO[0] = board_ext->config->IoAddress;
      board_ext->config->BaseIoAddr = board_ext->config->IoAddress;

      board_ext->config->ISABrdIndex = NumISARockets;
      if (NumISARockets == 0)
           board_ext->config->BaseIoSize = 0x44;
      else board_ext->config->BaseIoSize = 0x40;

      ++NumISARockets;
    }
    else if (board_ext->config->IoAddress == 1)  // PCI board setup
    {
      ++NumPCIRockets;  // we have some pci boards configured
    }
    else if (board_ext->config->IoAddress == 0)  // bad setup
    {
      Eprintf("Error, Io Address is 0.");
      EventLog(DriverObject, STATUS_SUCCESS, SERIAL_RP_INIT_FAIL, 0, NULL);
      return STATUS_SERIAL_NO_DEVICE_INITED;
    }

    board_ext = board_ext->board_ext;  // next
  }

  // configure PCI boards, and see if we have any pci boards
  if (NumPCIRockets > 0)  // we have some pci boards configured
  {
    NumPCIBuses = FindPCIBus();
    if (NumPCIBuses == 0)
    {
      Eprintf("Error, No PCI BUS");
      return STATUS_SERIAL_NO_DEVICE_INITED;
    }
    if (FindPCIRockets(NumPCIBuses) != 0) // err, none found
    {
      Eprintf("Error, PCI board not found");
      return STATUS_SERIAL_NO_DEVICE_INITED;
    }

    all_found = 1;
    board_ext = Driver.board_ext;
    while (board_ext != NULL)
    {
      if (board_ext->config->IoAddress == 1)  // PCI board setup
      {
        // see if direct matches exist
        if (FindPCIRocket(board_ext->config, 0) != 0)
        {
          all_found = 0;  // not found
        }
      }
      board_ext = board_ext->board_ext;  // next
    }  // while more boards

    // try again, this time allowing NumPorts <= actual_ports
    if (!all_found)
    {
      board_ext = Driver.board_ext;
      while (board_ext != NULL)
      {
        if ((board_ext->config->IoAddress == 1) &&  // PCI board setup
            (board_ext->config->BaseIoAddr == 0))  // not setup yet
        {
          // see if match exist, NumPorts <= actual_ports
          if (FindPCIRocket(board_ext->config, 1) != 0)
          {
            Eprintf("Error, PCI brd %d setup", BoardExtToNumber(board_ext)+1);
            return STATUS_SERIAL_NO_DEVICE_INITED;
          }
        }
        board_ext = board_ext->board_ext;  // next
      }  // while more boards
      Eprintf("Warning, PCI num-ports mismatch");
    }  // if (!all_found)
  } // if (NumPCIRockets > 0)

  return STATUS_SUCCESS;
}

/********************************************************************

  load up the modem microcode from disk.

********************************************************************/
int LoadModemCode(char *Firm_pathname,char *Loader_pathname)
{
#ifdef S_RK
  MODEM_IMAGE   Mi;
  MODEM_IMAGE   *pMi;
  static char   *Firm_def_pathname = {MODEM_CSREC_PATH};
  static char   *Loader_def_pathname = {MODEM_CSM_SREC_PATH};

#define  MLOADER_TYPE  "CSM"
#define  FIRM_TYPE   "MFW"

  // flush any leftovers...
  FreeModemFiles();
  pMi = &Mi;

  // first, do the FLM or CSM loader...
  pMi->imagepath = Loader_pathname;
  pMi->image     = (UCHAR *)NULL;
  pMi->imagesize = (ULONG)0;
  pMi->imagetype = MLOADER_TYPE;
  pMi->rc        = 0;

  if (pMi->imagepath == (char *)NULL)
    pMi->imagepath = Loader_def_pathname;

  pMi = ReadModemFile(pMi);

  if (pMi->rc)
    return(pMi->rc);

  Driver.ModemLoaderCodeImage = pMi->image;
  Driver.ModemLoaderCodeSize  = pMi->imagesize;

  //  tinydump(Driver.ModemLoaderCodeImage,Driver.ModemLoaderCodeSize);

  pMi->imagepath  = Firm_pathname;
  pMi->image    = (UCHAR *)NULL;
  pMi->imagesize  = (ULONG)0;
  pMi->imagetype  = FIRM_TYPE;
  pMi->rc     = 0;

  if (pMi->imagepath == (char *)NULL)
    pMi->imagepath = Firm_def_pathname;

  pMi = ReadModemFile(pMi);

  if (pMi->rc) {
    // earlier read of CSM should have been successful, so we should dump
    // the CSM buffer before we bail...
    if (Driver.ModemLoaderCodeImage)
    {
      our_free(Driver.ModemLoaderCodeImage,MLOADER_TYPE);

      Driver.ModemLoaderCodeImage = (UCHAR *)NULL;
      Driver.ModemLoaderCodeSize = 0;
    }
    return(pMi->rc);
  }

  Driver.ModemCodeImage = pMi->image;
  Driver.ModemCodeSize  = pMi->imagesize;

  //  tinydump(Driver.ModemCodeImage,Driver.ModemCodeSize);

#endif
  return(0);
}

/********************************************************************

  free up space no longer necessary...

********************************************************************/
void FreeModemFiles(void)
{
#ifdef S_RK
  if (Driver.ModemLoaderCodeImage)
  {
    our_free(Driver.ModemLoaderCodeImage,MLOADER_TYPE);

    Driver.ModemLoaderCodeImage = (UCHAR *)NULL;
    Driver.ModemLoaderCodeSize  = 0;
  }

  if (Driver.ModemCodeImage)
  {
    our_free(Driver.ModemCodeImage,FIRM_TYPE);

    Driver.ModemCodeImage = (UCHAR *)NULL;
    Driver.ModemCodeSize = 0;
  }
#endif
}

/********************************************************************

  load up a specified file from disk...

********************************************************************/
MODEM_IMAGE * ReadModemFile(MODEM_IMAGE *pMi)
{
#ifdef S_RK
  NTSTATUS                  ntStatus;
  HANDLE                    NtFileHandle;
  OBJECT_ATTRIBUTES         ObjectAttributes;
  IO_STATUS_BLOCK           IoStatus;
  USTR_160                  uname;
  FILE_STANDARD_INFORMATION StandardInfo;
  ULONG                     LengthOfFile;

  CToUStr((PUNICODE_STRING)&uname,
          pMi->imagepath,
          sizeof(uname));

  InitializeObjectAttributes(&ObjectAttributes,
                             &uname.ustr,
                             OBJ_CASE_INSENSITIVE,
                             NULL,
                             NULL);

  ntStatus = ZwCreateFile(&NtFileHandle,
                          SYNCHRONIZE | FILE_READ_DATA,
                          &ObjectAttributes,
                          &IoStatus,
                          NULL,                           // alloc size = none
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ,
                          FILE_OPEN,
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,                           // eabuffer
                          0);                             // ealength

  if (!NT_SUCCESS(ntStatus))
  {
    pMi->rc = 1;
    return(pMi);
  }

  // query the object to determine its length...
  ntStatus = ZwQueryInformationFile(NtFileHandle,
                                    &IoStatus,
                                    &StandardInfo,
                                    sizeof(FILE_STANDARD_INFORMATION),
                                    FileStandardInformation );

  if (!NT_SUCCESS(ntStatus))
  {
    ZwClose(NtFileHandle);

    pMi->rc = 2;

    return(pMi);
  }

  LengthOfFile = StandardInfo.EndOfFile.LowPart;

  if (LengthOfFile < 1)
  {
    ZwClose(NtFileHandle);

    pMi->rc = 3;

    return(pMi);
  }

  // allocate buffer for this file...
  pMi->image = (UCHAR *)our_locked_alloc(LengthOfFile,pMi->imagetype);
  if (pMi->image == (UCHAR *)NULL )
  {
    ZwClose(NtFileHandle );

    pMi->rc = 4;

    return(pMi);
  }

  // read the file into our buffer...
  ntStatus = ZwReadFile(NtFileHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatus,
                        pMi->image,
                        LengthOfFile,
                        NULL,
                        NULL);

  if((!NT_SUCCESS(ntStatus)) || (IoStatus.Information != LengthOfFile))
  {
    our_free(pMi->image,pMi->imagetype);

    pMi->rc = 5;

    return(pMi);
  }

  ZwClose(NtFileHandle);

  pMi->imagesize = LengthOfFile;

#endif

  return(pMi);
}

#ifdef DUMPFILE
/********************************************************************

  grind through S3 files, dumping out each line. assumes there
  are embedded CRs/LFs in the stream...

********************************************************************/
void tinydump(char *ptr, int count)
{
  int   tbcount;
  char  tinybuf[128];

  while (count > 0)
  {
    tbcount = 0;
    if (*ptr >= '0')
    {
      while (*ptr >= '0')
      {
        --count;
        tinybuf[tbcount++] = *(ptr++);
      }
    }
    else
    {
      while (*ptr < '0')
      {
        --count;
        ++ptr;
      }
    }
    tinybuf[tbcount] = 0;
    if (tbcount)
      MyKdPrint(D_Init,("%s\r",tinybuf));
  }
  MyKdPrint(D_Init,("\r"));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\initrk.h ===
// initrk.h
extern char *szResourceClassName;  // used in pnprckt.c

void InitRocketModemII(PSERIAL_DEVICE_EXTENSION ext);

UCHAR  FindPCIBus(void);
int FindPCIRockets(UCHAR NumPCI);
int FindPCIRocket(DEVICE_CONFIG *config, int match_option);
NTSTATUS RcktConnectInt(IN PDRIVER_OBJECT DriverObject);
void VerboseLogBoards(char *prefix);
int SetupRocketCfg(int pnp_flag);
int ConfigAIOP(DEVICE_CONFIG *config);
VOID SerialUnReportResourcesDevice(IN PSERIAL_DEVICE_EXTENSION Extension);
int RocketReportResources(IN PSERIAL_DEVICE_EXTENSION extension);
int InitController(PSERIAL_DEVICE_EXTENSION ext);
void StartRocketIRQorTimer(void);
void SetupRocketIRQ(void);
NTSTATUS init_cfg_rocket(IN PDRIVER_OBJECT DriverObject);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\ioctl.h ===
//--- ioctl.h
NTSTATUS
SerialIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PSERIAL_DEVICE_EXTENSION
FindDevExt(IN PCHAR PortName);

NTSTATUS
ProgramBaudRate(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN ULONG DesiredBaudRate
);

NTSTATUS
ProgramLineControl(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PSERIAL_LINE_CONTROL Lc
);

NTSTATUS
SerialInternalIoControl(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp);

void SerialSetHandFlow(PSERIAL_DEVICE_EXTENSION Extension,
                              SERIAL_HANDFLOW *HandFlow);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\initvs.c ===
/*-------------------------------------------------------------------
| initvs.c - main init code for VS1000/2000 NT device driver.  Contains
   mostly initialization code.
 Copyright 1996-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

static int CatBindList(IN WCHAR *pwstr);
static void GetBindingNames(void);
static Nic *FindFreeNic(void);
static int BindNameUsed(char *nicname);
static int NicNameUsed(char *nicname);
static void ScanForNewNicCards(void);
static int reg_list_nt50_linkage(void);
static int reg_list_nt40_linkage(void);

/*----------------------------------------------------------------------
 CatBindList - Given the multisz Wchar string read out of the registry,
   convert it to normal c-string multisz list.
|----------------------------------------------------------------------*/
static int CatBindList(IN WCHAR *pwstr)
{
 char *cstr;
 int size = 0;

  cstr = Driver.BindNames;

  MyKdPrint(D_Thread, ("CatBindList\n"))

  // cat on to end of existing list, so find end of list
  while (cstr[size] != 0)
  {
    //MyKdPrint(D_Thread, ("ExList:%s\n", &cstr[size]))
    while (cstr[size] != 0)
      ++size;
    ++size;  // pass up string null to next string
  }
  cstr += size;

  MyKdPrint(D_Thread, ("CatList Size:%d\n", size))

  if (*pwstr == 0)
  {
    MyKdPrint(D_Thread, ("Null List!\n"))
  }

  while ((*pwstr != 0) && (size < 7700))
  {
    // first convert it past the list end and check if its already in the list
    WStrToCStr(cstr+4, pwstr, 200);
    if (!BindNameUsed(cstr+4))
    {
      WStrToCStr(cstr, pwstr, 200);  // put at end of list

      MyKdPrint(D_Thread, ("Bind: %s\n", cstr))

      size = (strlen(cstr) + 1);
      cstr += size;
      *cstr = 0;  // double null end of list
      *(cstr+1) = 0;
    }
    //-----  Advance to the next string of the MULTI_SZ string
    while (*pwstr != 0)
      ++pwstr;
    ++pwstr;
  }

  return 0; // ok
}

/*----------------------------------------------------------------------
 GetBindingNames - Reads Binding info to find possible nic-card export
   names from registry.  Reads the list into Driver.BindNames multisz
   list.
|----------------------------------------------------------------------*/
static void GetBindingNames(void)
{
  if (Driver.BindNames == NULL)
  {
    Driver.BindNames = ExAllocatePool(PagedPool, 8000 * sizeof(WCHAR));
    if (Driver.BindNames == NULL) {
      Eprintf("GetBindingNames no memory");
      return;
    }
  }
  // clear list
  RtlZeroMemory( (PUCHAR)Driver.BindNames, sizeof(WCHAR)*2);

#ifdef NT50
  reg_list_nt50_linkage();
#else
  reg_list_nt40_linkage();
#endif
}

/*----------------------------------------------------------------------
 FindFreeNic - Find an unused Nic structure to try and open.
|----------------------------------------------------------------------*/
static Nic *FindFreeNic(void)
{
 int i;
#ifdef BREAK_NIC_STUFF
  for (i=VS1000_MAX_NICS-1; i>=0; i--)
#else
  for (i=0; i<VS1000_MAX_NICS; i++)
#endif
  {
    if (Driver.nics[i].NICHandle == NULL)
      return &Driver.nics[i];
  }
  return NULL;
}

/*----------------------------------------------------------------------
 BindNameUsed - Return true if Bind Nic name already in bind list.
|----------------------------------------------------------------------*/
static int BindNameUsed(char *nicname)
{
 char *szptr;

  szptr = Driver.BindNames;  // multisz list

  while (*szptr != 0)  // while list of binding nic-names to try
  {
    if (my_lstricmp(szptr, nicname) == 0) // a match
    {
      return 1;  // its in use.
    }

    while (*szptr != 0)  // to next bind string to try
      ++szptr;
    ++szptr;
  } // while (szptr (more bind strings to try)

  return 0;  // its not in use.
}

/*----------------------------------------------------------------------
 NicNameUsed - Return true if Nic name is in use.
|----------------------------------------------------------------------*/
static int NicNameUsed(char *nicname)
{
 int i;
  for (i=0; i<VS1000_MAX_NICS; i++)
  {
    if (Driver.nics[i].NicName[0] != 0)
    {
      if (my_lstricmp(Driver.nics[i].NicName, nicname) == 0) // a match
      {
        return 1;  // its in use.
      }
    }
  }
  return 0;  // its not in use.
}

/*----------------------------------------------------------------------
 ScanForNewNicCards - Reads Binding info to find possible nic-card export
   names.  Scans through all nic cards and attempts to open those that 
  have not been successfully opened already.
|----------------------------------------------------------------------*/
static void ScanForNewNicCards(void)
{
 Nic *nic;
 char *szptr;
 int stat;

  MyKdPrint(D_Thread, ("ScanForNewNicCards\n"))

  GetBindingNames();

  szptr = Driver.BindNames;  // multisz list

  if ((szptr == NULL) || (*szptr == 0))
  {
    MyKdPrint(D_Error, ("No Binding\n"))
    return;  // err
  }

  while (*szptr != 0)  // while list of binding nic-names to try
  {
    if (!NicNameUsed(szptr))  // if this name is not in use yet
    {
      nic = FindFreeNic();
      if (nic == NULL)
      {
        MyKdPrint(D_Error, ("Out of Nics\n"))
        break;
      }

      // try to open NIC card
      stat = NicOpen(nic, CToU1(szptr));
      if (stat == 0)
      {
        MyKdPrint(D_Thread, ("Opened nic %s\n", szptr))
      }
      else
      {
        MyKdPrint(D_Thread, ("Failed Opened nic %s\n", szptr))
      }
    }
    else
    {
      MyKdPrint(D_Thread, ("Nic %s already used.\n", szptr))
    }

    while (*szptr != 0)  // to next bind string to try
      ++szptr;
    ++szptr;
  } // while (szptr (more bind strings to try)

  MyKdPrint(D_Thread, ("End ScanForNewNicCards\n"))
}

/*----------------------------------------------------------------------
 NicThread - Scans through all nic cards and attempts to open those that 
  have not been successfully opened already.  If all nic cards are not opened
  successfully timeout for 1 second and try it again.  This function operates
  as a separate thread spawned by Driver_Entry in init.c.  When all the nic
  cards have been successfully opened this thread will terminate itself.
|----------------------------------------------------------------------*/
VOID NicThread(IN PVOID Context)
{
  int i, stat;
  int SearchForNicsFlag;
  int ticks = 0;
  PSERIAL_DEVICE_EXTENSION ext;

  for (;;)
  {
    // this time of wait is critically matched to a timeout associated
    // with killing this task.
    time_stall(10);  // wait 1 second

    Driver.threadCount++;
    //----- open up any unopened the nic cards.
    if (Driver.threadHandle == NULL)  // request to kill ourselves
      break;

    ++ticks;

    if (Driver.Stop_Poll)  // flag to stop poll access
      ticks = 0;  // don't do config stuff now(contention)

    if (Driver.AutoMacDevExt)
    {
      MyKdPrint(D_Test, ("Auto Mac Assign Thread\n"))
      port_set_new_mac_addr(Driver.AutoMacDevExt->pm,
                            Driver.AutoMacDevExt->config->MacAddr);
      write_dev_mac(Driver.AutoMacDevExt);

      Driver.AutoMacDevExt = NULL;
    }

    if (ticks > 60)  // every 60 seconds
    {

      // if any boxes are not in the init state of communications,
      // then assume that there may be a missing nic-card we need to
      // find in the system.
      SearchForNicsFlag = FALSE;

      ext = Driver.board_ext;
      while(ext)
      {
        if (ext->pm->state == ST_INIT)
        {
          SearchForNicsFlag = TRUE;
        }
        ext = ext->board_ext;  // next
      }

      if (SearchForNicsFlag)
      {
        ticks = 0;  // come back around after full 60 second timeout
        ScanForNewNicCards();
      }
      else
        ticks -= 30;  // come back around in 30 seconds
    }
  }

  Driver.threadHandle = NULL;
  // Terminate myself
  PsTerminateSystemThread( STATUS_SUCCESS );
}

#ifdef NT50

/*-----------------------------------------------------------------
 reg_list_nt50_linkage - Find ethernet nic-card names in the
   registry.  Official binding tells us what we are bound to
   via NT's binding rules.  But, this binding process is combersome
   and has problems.  Another technique is to search the registry
   and look for nic-card names to use.  Under NT50, this is easier
   in that there is a Net class, and we can search it for cards
   with "Ethernet" linkage.  So we do both, this gives some backward
   compatibility if we choose to install and get the proper bindings
   and/or if we want to avoid these binding shortcomings by hacking
   our own list of nic-cards from the registry.

   Installing as a protocol might solve some of the linkage problems,
   (and present new problems too.)

NT4.0 and below stores this in "Services\Servicename\Linkage" area.

NT5.0 PnP network card linkage info stored at:
"REGISTRY\Machine\System\CurrentControlSet\Control\Class\{4d36e972-e325-11ce-bfc1-08002be10318}\0000\Linkage"

Id to determine if node is ours(vs):
"REGISTRY\Machine\System\CurrentControlSet\Control\Class\{4d36e972-e325-11ce-bfc1-08002be10318}\0000\ComponentId"=
"vslinka_did"
|------------------------------------------------------------------*/
static int reg_list_nt50_linkage(void)
{
  static char *szLowerRange = {"LowerRange"};
  static char *szNdiInterfaces = {"Ndi\\Interfaces"};
  static char *szComponentId = {"ComponentId"};
  static char *szLinkage = {"Linkage"};
  static char *szBind = {"Bind"};
  static char *szExport = {"Export"};
  static char *szRegRMSCCNetGuid = 
   {"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Class\\{4d36e972-e325-11ce-bfc1-08002be10318}"};
  static char *szEthernet = {"Ethernet"};

  static char tmpstr[200];  // make static, don't put too much on stack..
  static char compstr[40];
  static char nodestr[20];
  WCHAR *wstr_ptr;
  char *buffer = NULL;
  char *data_ptr;
  HANDLE KeyHandle = NULL;
  HANDLE KeyHandle2 = NULL;
  HANDLE KeyHandle3 = NULL;
  int node_num = 0;
  int linkage_found = 0;
  int stat;

#define OUR_BUF_SIZE (8000*2)

  MyKdPrint(D_Thread, ("Start RegFind Linkage\n"))

  stat = our_open_key(&KeyHandle, NULL, szRegRMSCCNetGuid, KEY_READ);
  if (stat)
  {
    MyKdPrint(D_Error, ("Failed OpenKey\n"))
    return 1;
  }

  buffer = ExAllocatePool(PagedPool, OUR_BUF_SIZE);
  if ( buffer == NULL ) {
    Eprintf("RegFindLinkage no memory");
    return 1;
  }

  for(;;)
  {
    stat = our_enum_key(KeyHandle,
                        node_num,
                        buffer,
                        OUR_BUF_SIZE,
                        &data_ptr);
    ++node_num;

    if (stat)
    {
       MyKdPrint(D_Thread, ("Done\n"))
       break;
    }

    // does this come back as wchar?
    WStrToCStr(nodestr, (PWCHAR)data_ptr, 18);
    //if (strlen(data_ptr) < 18)
    //  strcpy(nodestr, data_ptr);

    MyKdPrint(D_Thread, ("Got Key Node:%s.\n", nodestr))
  
    // open up the sub-key (0000, 0001, etc..)
    stat = our_open_key(&KeyHandle2, KeyHandle, nodestr, KEY_READ);
    if (stat)
    {
      MyKdPrint(D_Error, ("Err 1X\n"))
      continue;
    }

    stat = our_query_value(KeyHandle2,
                           szComponentId,
                           buffer,
                           OUR_BUF_SIZE,
                           NULL,  // pDataType
                           &data_ptr);

    if (stat)
    {
      // no component id
      MyKdPrint(D_Thread, ("No compId\n"))
      compstr[0] = 0;
    }
    else
    {
      WStrToCStr(compstr, (PWCHAR)data_ptr, 38);
    }
    //if (strlen(data_ptr) < 38)
    //  strcpy(compstr, data_ptr);

    MyKdPrint(D_Thread, ("Got compid:%s.\n", compstr))
    if ((my_lstricmp(compstr, "vslink1_did") == 0) ||
         (my_lstricmp(compstr, "vslink2_did") == 0))
    {
      MyKdPrint(D_Thread, ("Match\n"))

      // open up the sub-key "Linkage" and get "Bind" multisz string
      stat = our_open_key(&KeyHandle3, KeyHandle2, szLinkage, KEY_READ);
      if (stat)
      {
        MyKdPrint(D_Thread, ("No Linkage\n"))
        continue;
      }

      stat = our_query_value(KeyHandle3,
                             szBind,
                             buffer,
                             OUR_BUF_SIZE,
                             NULL,  // pDataType
                             &data_ptr);

      if (stat)
      {
        // no component id
        MyKdPrint(D_Thread, ("No Bind\n"))
        continue;
      }
      MyKdPrint(D_Thread, ("Got bind!\n"))

      wstr_ptr = (PWCHAR)(data_ptr);
#if DBG
      //while (*wstr_ptr != 0)  // while more multisz strings
      //{
      //  WStrToCStr(tmpstr, wstr_ptr, 100);
      //  MyKdPrint(D_Thread, ("Got Bind Name:%s.\n", tmpstr))
      //  while (*wstr_ptr != 0)  // pass up this string
      //    ++wstr_ptr;
      //  ++wstr_ptr;
      //}
      //wstr_ptr = (PWCHAR)(data_ptr);
#endif

      CatBindList(wstr_ptr);
      ++linkage_found;
    }
    else  //------- not a VS node
    {
      // so check to see if its a ethernet nic-card which we can
      // use the exported name to add to our bind list

      // open up the sub-key "Ndi\\Interfaces" and get "LowerRange" multisz string
      stat = our_open_key(&KeyHandle3, KeyHandle2, szNdiInterfaces, KEY_READ);
      if (stat)
      {
        MyKdPrint(D_Thread, ("Not a e.nic-card\n"))
        continue;
      }

      stat = our_query_value(KeyHandle3,
                           szLowerRange,
                           buffer,
                           OUR_BUF_SIZE,
                           NULL,  // pDataType
                           &data_ptr);

      if (stat)
      {
        MyKdPrint(D_Thread, ("No LowRange\n"))
        continue;
      }
      WStrToCStr(tmpstr, (PWCHAR)data_ptr, 38);

      if (my_lstricmp(tmpstr, szEthernet) != 0)
      {
        MyKdPrint(D_Thread, ("Not Eth\n"))
        continue;
      }

      MyKdPrint(D_Thread, ("Found a Nic Card!\n"))

      // open up the sub-key "Linkage" and get "Export" multisz string
      stat = our_open_key(&KeyHandle3, KeyHandle2, szLinkage, KEY_READ);
      if (stat)
      {
        MyKdPrint(D_Thread, ("No Linkage on E card\n"))
        continue;
      }

      stat = our_query_value(KeyHandle3,
                           szExport,
                           buffer,
                           OUR_BUF_SIZE,
                           NULL,  // pDataType
                           &data_ptr);

      if (stat)
      {
        MyKdPrint(D_Thread, ("No Export on E.nic-card\n"))
        continue;
      }

      MyKdPrint(D_Thread, ("Got e.card export 2!\n"))
      wstr_ptr = (PWCHAR) data_ptr;
#if DBG
      //while (*wstr_ptr != 0)  // while more multisz strings
      //{
      //  WStrToCStr(tmpstr, wstr_ptr, 100);
      //  MyKdPrint(D_Thread, ("Got E. Card Name:%s.\n", tmpstr))
      //  while (*wstr_ptr != 0)  // pass up this string
      //    ++wstr_ptr;
      //  ++wstr_ptr;
      //}
      //wstr_ptr = (PWCHAR) data_ptr;
#endif
      ++linkage_found;
      MyKdPrint(D_Thread, ("E card 3!\n"))
      CatBindList(wstr_ptr);
    }
  }  // for

  if (KeyHandle != NULL)
    ZwClose(KeyHandle);

  if (KeyHandle2 != NULL)
    ZwClose(KeyHandle2);

  if (KeyHandle3 != NULL)
    ZwClose(KeyHandle3);

  if (buffer != NULL)
     ExFreePool(buffer);

  if (linkage_found == 0)
  {
    MyKdPrint(D_Thread, ("ERROR, No Ethernet found!\n"))
  }

  MyKdPrint(D_Thread, ("reg_list done\n"))
  return 1;  // err, not found
}
#else
/*----------------------------------------------------------------------------
  nt40
|----------------------------------------------------------------------------*/
static int reg_list_nt40_linkage(void)
{
    //static char *szLowerRange = {"LowerRange"};
    //static char *szNdiInterfaces = {"Ndi\\Interfaces"};
    //static char *szComponentId = {"ComponentId"};
    //static char *szExport = {"Export"};
    //static char *szRegRMSCCNetGuid = 
    // {"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Class\\{4d36e972-e325-11ce-bfc1-08002be10318}"};
    //static char *szEthernet = {"Ethernet"};

  static char *szRegRMSCS = 
   {"\\Registry\\Machine\\System\\CurrentControlSet\\Services"};

  static char *szLinkage = {"Linkage"};
  static char *szBind = {"Bind"};
  static char tmpstr[200];  // make static, don't put too much on stack..
  static char compstr[40];
  static char nodestr[20];
  WCHAR *wstr_ptr;
  char *buffer = NULL;
  char *data_ptr;
  HANDLE KeyHandle = NULL;
  HANDLE KeyHandle2 = NULL;
  HANDLE KeyHandle3 = NULL;
  int node_num = 0;
  int linkage_found = 0;
  int stat;
  OBJECT_ATTRIBUTES objAttribs;
  NTSTATUS status;

#define OUR_BUF_SIZE (8000*2)

  MyKdPrint(D_Thread, ("Start RegFind Linkage\n"))

  MyKdPrint(D_Thread, ("str:%s\n", UToC1(&Driver.RegPath) ))
  
  buffer = ExAllocatePool(PagedPool, OUR_BUF_SIZE);
  if ( buffer == NULL ) {
    Eprintf("RegFindLinkage no memory");
    return 1;
  }

  for (;;)
  {
    //--- open up our service key: controlset\services\vslinka
    InitializeObjectAttributes(&objAttribs,
                             &Driver.RegPath,
                             OBJ_CASE_INSENSITIVE,
                             NULL,  // root dir relative handle
                             NULL);  // security desc

    status = ZwOpenKey(&KeyHandle,
                     KEY_READ,
                     &objAttribs);

    if (status != STATUS_SUCCESS)
    {
      MyKdPrint(D_Error, ("Err 4D:%d\n", status))
      break;
    }

    // open up the sub-key "Linkage" and get "Bind" multisz string
    stat = our_open_key(&KeyHandle2, KeyHandle, szLinkage, KEY_READ);
    if (stat)
    {
      MyKdPrint(D_Thread, ("No Linkage\n"))
      break;
    }

    stat = our_query_value(KeyHandle2,
                           szBind,
                           buffer,
                           OUR_BUF_SIZE,
                           NULL,  // pDataType
                           &data_ptr);

    if (stat)
    {
      // no component id
      MyKdPrint(D_Thread, ("No Bind\n"))
      break;
    }
    MyKdPrint(D_Thread, ("Got bind!\n"))

    wstr_ptr = (PWCHAR)(data_ptr);
#if DBG
    while (*wstr_ptr != 0)  // while more multisz strings
    {
      WStrToCStr(tmpstr, wstr_ptr, 100);
      MyKdPrint(D_Thread, ("Got Bind Name:%s.\n", tmpstr))
      while (*wstr_ptr != 0)  // pass up this string
        ++wstr_ptr;
      ++wstr_ptr;
    }
    MyKdPrint(D_Thread, ("bind 3!\n"))
    wstr_ptr = (PWCHAR)(data_ptr);
#endif
    CatBindList(wstr_ptr);
    MyKdPrint(D_Thread, ("bind 4!\n"))
    ++linkage_found;

    break;  // all done.
  }

  // now go nab tcpip's bindings...
  for (;;)
  {
    MyKdPrint(D_Thread, ("Get other Linkage\n"))

    stat = our_open_key(&KeyHandle, NULL, szRegRMSCS, KEY_READ);
    if (stat)
    {
      MyKdPrint(D_Thread, ("Failed OpenKey\n"))
      break;
    }

    // open up the sub-key "tcpip\\Linkage" and get "Bind" multisz string
    tmpstr[0] = 't';
    tmpstr[1] = 'c';
    tmpstr[2] = 'p';
    tmpstr[3] = 'i';
    tmpstr[4] = 'p';
    tmpstr[5] = '\\';
    tmpstr[6] = 0;
    strcat(tmpstr, szLinkage);
    stat = our_open_key(&KeyHandle2, KeyHandle, tmpstr, KEY_READ);
    if (stat)
    {
      MyKdPrint(D_Thread, ("No other binding\n"))
      break;
    }

    stat = our_query_value(KeyHandle2,
                           szBind,
                           buffer,
                           OUR_BUF_SIZE,
                           NULL,  // pDataType
                           &data_ptr);
    if (stat)
    {
      // no component id
      MyKdPrint(D_Thread, ("No other Bind\n"))
      break;
    }

    MyKdPrint(D_Thread, ("Got other bind!\n"))

    wstr_ptr = (PWCHAR)(data_ptr);
#if DBG
    while (*wstr_ptr != 0)  // while more multisz strings
    {
      WStrToCStr(tmpstr, wstr_ptr, 100);
      MyKdPrint(D_Thread, ("Got Bind Name:%s.\n", tmpstr))
      while (*wstr_ptr != 0)  // pass up this string
        ++wstr_ptr;
      ++wstr_ptr;
    }
    wstr_ptr = (PWCHAR)(data_ptr);
#endif
    CatBindList(wstr_ptr);
    ++linkage_found;

    break;
  }

  if (KeyHandle != NULL)
    ZwClose(KeyHandle);

  if (KeyHandle2 != NULL)
    ZwClose(KeyHandle2);

  if (KeyHandle3 != NULL)
    ZwClose(KeyHandle3);

  if (buffer != NULL)
     ExFreePool(buffer);

  MyKdPrint(D_Thread, ("reg_list done\n"))
  if (linkage_found == 0)
  {
    MyKdPrint(D_Thread, ("ERROR, No Ethernet found!\n"))
    return 1;
  }
  return 0;  // ok, linkage found
}
#endif

/*----------------------------------------------------------------------
 init_eth_start - start up ethernet work.
|----------------------------------------------------------------------*/
int init_eth_start(void)
{
  int stat,i;

  for (i=0; i<VS1000_MAX_NICS; i++)
  {
    // this is only used for debug display
    Driver.nics[i].RefIndex = i;
  }

  stat = ProtocolOpen();  // fills in Driver.ndis_version
  if (stat != 0)
  {
    Eprintf("Protocol fail:%d",stat);
    SerialUnload(Driver.GlobalDriverObject);
    return STATUS_SERIAL_NO_DEVICE_INITED;
  }

  // start up our nic handler thread, to periodically find any
  // new nic cards in the system

  ScanForNewNicCards();  // do initial scan.

  // start up our thread
  if (Driver.threadHandle == NULL)
  {
    Driver.threadCount = 0;
    stat = PsCreateSystemThread(
                 &Driver.threadHandle,
                 THREAD_ALL_ACCESS,
                 NULL,
                 NULL,
                 NULL,
                 (PKSTART_ROUTINE)NicThread,
                 NULL);  // our context

    if (Driver.threadHandle == NULL)
    {
      Eprintf("Thread Fail\n");
      SerialUnload(Driver.GlobalDriverObject);
      return STATUS_SERIAL_NO_DEVICE_INITED;
    }
  } // if threadHandle

  return STATUS_SUCCESS;
}

/*-----------------------------------------------------------------------
 VSSpecialStartup - after board_ext is created and after port_ext's are
   created.  This sets up further structs.
|-----------------------------------------------------------------------*/
NTSTATUS VSSpecialStartup(PSERIAL_DEVICE_EXTENSION board_ext)

{
  //PSERIAL_DEVICE_EXTENSION ext = NULL;
  int stat, port_index;

  if (board_ext->config->NumPorts <= 8) // its a RHub device
     board_ext->config->IsHubDevice = 1;

  // setup default ClkRate if not specified
  if (board_ext->config->ClkRate == 0)
  {
    // use default
    if (board_ext->config->IsHubDevice)
      board_ext->config->ClkRate = DEF_RHUB_CLOCKRATE;
    else 
      board_ext->config->ClkRate = DEF_VS_CLOCKRATE;
  }

  // setup default PreScaler if not specified
  if (board_ext->config->ClkPrescaler == 0)
  {
    // use default
    if (board_ext->config->IsHubDevice)
      board_ext->config->ClkPrescaler = DEF_RHUB_PRESCALER;
    else
      board_ext->config->ClkPrescaler = DEF_VS_PRESCALER;
  }

  stat =  portman_init(board_ext->hd,
                       board_ext->pm,
                       board_ext->config->NumPorts,
                       board_ext->UniqueId,
                       board_ext->config->BackupServer,
                       board_ext->config->BackupTimer,
                       board_ext->config->MacAddr);
  if (stat != 0)
  {
    MyKdPrint(D_Init, ("Hdlc Failed Open\n"))
    return STATUS_SERIAL_NO_DEVICE_INITED;
  }

#ifdef NT40
  board_ext->config->HardwareStarted = TRUE;  // tell ISR its ready to go
  board_ext->FdoStarted = 1;  // ok to start using
#endif

  return STATUS_SUCCESS;
}

/*----------------------------------------------------------------------
 init_stop - unload thread, ndis nic cards, etc
|----------------------------------------------------------------------*/
int init_stop(void)
{
 int i;
  MyKdPrint(D_Init, ("Init Stop\n"))
  if (Driver.threadHandle != NULL)
  {
    ZwClose(Driver.threadHandle);
    Driver.threadHandle = NULL;  // tell thread to kill itself
    time_stall(15);  // wait 1.5 second
  }

  if (Driver.nics != NULL)
  {
    for (i=0; i<VS1000_MAX_NICS; i++)
    {
      if (Driver.nics[i].NICHandle != NULL)
        NicClose(&Driver.nics[i]);
    }
    //our_free(Driver.nics, "nics");
  }
  //Driver.nics = NULL;

  if (Driver.NdisProtocolHandle != NULL)
    NicProtocolClose();
  Driver.NdisProtocolHandle = NULL;
  MyKdPrint(D_Init, ("Init Stop End\n"))
  return 0;
}

/*----------------------------------------------------------------------
 find_all_boxes - Locate all boxes out on the networks.  Use broadcasts.
|----------------------------------------------------------------------*/
int find_all_boxes(int pass)
{
  int inic, j;

  if (pass == 0)
    Driver.NumBoxMacs = 0;  // clear out mac query-respond list

  // do the query on all nic-segments
  for (inic=0; inic<VS1000_MAX_NICS; inic++)
  {
    // broadcast request id
    if (Driver.nics[inic].Open)  // if nic-card open for use
    {
      admin_send_query_id(&Driver.nics[inic], broadcast_addr, 0,0);
    }
  }

  // wait for responses which are accumulated in Driver.BoxMacs[] and
  // Driver.NumBoxMacs.
  time_stall((4*pass)+4);  // wait .2 second

  if (Driver.NumBoxMacs == 0)  // no reply
  {
    return 1;  // return error
  }

  // sort the replies in ascending order
  sort_macs();

#if DBG
  if (Driver.VerboseLog && (pass == 0))
  {
    unsigned char *mac;
    for (j=0; j<Driver.NumBoxMacs; j++)
    {
      mac = &Driver.BoxMacs[j*8];
      Tprintf("MacLst:%x %x %x %x %x %x ,N:%d",
        mac[0], mac[1], mac[2], mac[3], mac[4], mac[5],   mac[7]);
    }
  }
#endif
  return 0;  // return ok
}

/*----------------------------------------------------------------------
 sort_macs - sort mac addresses returned by query_id requests sent
   out to boxes.  Mac array is 8 bytes to allow extra room to indicate
   nic-segment it was found on.
|----------------------------------------------------------------------*/
void sort_macs(void)
{
 int i;
 BYTE temp_mac[8];
 BYTE *mac1;
 BYTE *mac2;
 int done;
  int num_macs = Driver.NumBoxMacs;

  if (num_macs <= 1)
    return;

  // bubble sort
  done = 0;
  while (!done)
  {
    done = 1;
    for (i=1; i<num_macs; i++)
    {
      mac1 = &Driver.BoxMacs[i*8];
      mac2 = &Driver.BoxMacs[(i-1)*8];
      if (mac_cmp(mac1, mac2) < 0)
      {
        done = 0;
        // swap em
        memcpy(temp_mac, mac1, 8);
        memcpy(mac1, mac2, 8);
        memcpy(mac2, temp_mac, 8);
      }  // sort op-swap
    }  // sort loop
  }  // !done
}

/*-----------------------------------------------------------------------
 LoadMicroCode - Load up the micro-code from disk.
|-----------------------------------------------------------------------*/
int LoadMicroCode(char *filename)
{
  NTSTATUS ntStatus;
  HANDLE NtFileHandle;
  OBJECT_ATTRIBUTES ObjectAttributes;
  IO_STATUS_BLOCK IoStatus;
  USTR_160 uname;
  FILE_STANDARD_INFORMATION StandardInfo;
  // WCHAR PathPrefix[] = L"\\SystemRoot\\system32\\drivers\\";
  ULONG LengthOfFile;
//  ULONG FullFileNameLength;
  static char *def_filename = {"\\SystemRoot\\system32\\drivers\\vslinka.bin"};

  if (filename == NULL)
    filename = def_filename;

  CToUStr((PUNICODE_STRING)&uname, filename, sizeof(uname));

  InitializeObjectAttributes ( &ObjectAttributes,
                               &uname.ustr,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL );

  ntStatus = ZwCreateFile( &NtFileHandle,
                           SYNCHRONIZE | FILE_READ_DATA,
                           &ObjectAttributes,
                           &IoStatus,
                           NULL,              // alloc size = none
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ,
                           FILE_OPEN,
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,  // eabuffer
                           0);   // ealength

   if (!NT_SUCCESS(ntStatus))
   {
     return 1;
   }

  //
  // Query the object to determine its length.
  //
  ntStatus = ZwQueryInformationFile( NtFileHandle,
                                     &IoStatus,
                                     &StandardInfo,
                                     sizeof(FILE_STANDARD_INFORMATION),
                                     FileStandardInformation );

  if (!NT_SUCCESS(ntStatus))
  {
    ZwClose(NtFileHandle);
    return 2;
  }

  LengthOfFile = StandardInfo.EndOfFile.LowPart;

  //ZwCFDump(ZWCFDIAG1, ("File length is %d\n", LengthOfFile));
  if (LengthOfFile < 1)
  {
    ZwClose(NtFileHandle);
    return 3;
  }

  if (Driver.MicroCodeImage != NULL)
  {
    our_free(Driver.MicroCodeImage, "MCI");
  }
  // Allocate buffer for this file
  Driver.MicroCodeImage = our_locked_alloc(  LengthOfFile, "MCI");

  if( Driver.MicroCodeImage == NULL )
  {
    MyKdPrint(D_Init, ("Err 12A\n"))
    ZwClose( NtFileHandle );
    return 4;
  }

  // Read the file into our buffer.
  ntStatus = ZwReadFile( NtFileHandle,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatus,
                         Driver.MicroCodeImage,
                         LengthOfFile,
                         NULL,
                         NULL);

  if( (!NT_SUCCESS(ntStatus)) || (IoStatus.Information != LengthOfFile) )
  {
    MyKdPrint(D_Init, ("Err 12B\n"))
    our_free(Driver.MicroCodeImage,"MCI");
    return 5;
  }

  ZwClose( NtFileHandle );

  Driver.MicroCodeSize = LengthOfFile;

  // no, lets not corrupt the startup code!
  ////Driver.MicroCodeImage[50] = 0;

  // TraceStr(Driver.MicroCodeImage);
  // TraceStr(">>> Done Reading");

  return 0;
}

#if 0
/*----------------------------------------------------------------------
  is_mac_unused - Used for autoconfig of mac-address.
|----------------------------------------------------------------------*/
int is_mac_used(DRIVER_MAC_STATUS *)
{
  PSERIAL_DEVICE_EXTENSION board_ext;

  if (mac_entry->flags & FLAG_APPL_RUNNING)
    return 1;  // its used

  board_ext = Driver.board_ext;
  while (board_ext != NULL)
  {
    if ((!board_ext->FdoStarted) || (!board_ext->config->HardwareStarted))
    {
      board_ext = board_ext->board_ext;  // next in chain
      return 1;  // might be used
    }
    if (mac_match(ext->config->MacAddr, mac_entry->mac)
      return 1;  // its used
    }
    board_ext = board_ext->board_ext;
  }
  return 0;  // its not used
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\initvs.h ===
VOID NicThread(IN PVOID Context);
int init_eth_start(void);
int find_all_boxes(int pass);
int mac_already_used(int for_box, UCHAR *mac);
//int init_start(void);
int init_stop(void);
void sort_macs(void);
int LoadMicroCode(char *filename);
NTSTATUS VSSpecialStartup(PSERIAL_DEVICE_EXTENSION board_ext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\isr.c ===
/*-------------------------------------------------------------------
| isr.c - Interrupt(or Timer) Service Routine, RocketPort & VS.

1-21-99 fix broken EV_TXEMPTY events due to 1-18-99 spinlock changes.  kpb
1-18-99 implement better write spinlocking to avoid blue-screen
  with wait on tx option.
1-18-99 implement wait on tx option for VS.
9-24-98 add RING emulation.

Copyright 1993-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

// #define LOAD_TESTING
// #define SOFT_LOOP_BACK

// local prototypes
static BOOLEAN SerialPoll(void);
static void ServiceRocket(PSERIAL_DEVICE_EXTENSION extension);
static void ServiceVS(PSERIAL_DEVICE_EXTENSION extension);
static void RocketRead(PSERIAL_DEVICE_EXTENSION extension);
static void VSRead(PSERIAL_DEVICE_EXTENSION extension);
static void RocketRefresh(void);
static void ring_check(PSERIAL_DEVICE_EXTENSION extension,
                BYTE *data,
                int len);

#ifdef S_VS
#define USE_MEMCHR_SCAN
#ifdef USE_MEMCHR_SCAN
#define search_match(buf, cnt, chr) \
   (memchr(buf, chr, cnt) != NULL)
#else
static int search_match(BYTE *buf, int count, BYTE eventchar);
#endif
#endif

#ifdef S_RK
/*---------------------------------------------------------------------------
  Function : SerialISR
  Purpose:   This is the Interrupt Service Routine for RocketPort.
  Call:      SerialISR(InterruptObject,Context)
             PDEVICE_OBJECT DeviceObject: Pointer to the Device Object
             Context: Pointer to the extensionst Packet
  Return:   STATUS_SUCCESS: always
  Comments: This function is the device driver ISR entry point.  
            The interrupt from the first active board is used to poll the
            ports for any work to be done.
|---------------------------------------------------------------------------*/
BOOLEAN SerialISR(
         IN PKINTERRUPT InterruptObject,
         IN PVOID Context)
{
   CONTROLLER_T *CtlP;
   unsigned char CtlInt;               /* controller interrupt status */
//static int trace_cnt = 0;
//   ++trace_cnt;
//  if (trace_cnt < 5)
//   {
//     {
//       char str[20];
//       Sprintf(str, "isr trace:%d\n", trace_cnt);
//       q_put(&Driver.DebugQ, (BYTE *) str, strlen(str));
//       // showed IRQL:2, ms doc says should be at DISPATCH_LEVEL
//     }
//   }

   CtlP = Driver.irq_ext->CtlP;  // &sController[0];
   if (CtlP->BusType == Isa)
   {
      CtlInt = sGetControllerIntStatus(CtlP);
   }
   else if (CtlP->BusType == PCIBus)
   {
      CtlInt = sPCIGetControllerIntStatus(CtlP);
      if ((CtlInt & PCI_PER_INT_STATUS) ==0)
        return FALSE;  // Not our Interupt PCI devices share interrupts
   }
   SerialPoll();

   if (CtlP->BusType == Isa)
   {
     sControllerEOI(CtlP);
   }
   else if (CtlP->BusType == PCIBus)
     sPCIControllerEOI(CtlP);

   return TRUE;
}
#endif

/*---------------------------------------------------------------------------
  Function : TimerDpc
  Purpose:   This is the Timer routine, alternative to interrupts for polling.
  Call:      SerialTimerDpc(InterruptObject,Context)
             PDEVICE_OBJECT DeviceObject: Pointer to the Device Object
             Context: Pointer to the extensionst Packet
  Return:   STATUS_SUCCESS: always
|---------------------------------------------------------------------------*/
VOID TimerDpc(
      IN PKDPC Dpc,
      IN PVOID DeferredContext,
      IN PVOID SystemContext1,
      IN PVOID SystemContext2)
{
 KIRQL OldIrql;

#ifdef USE_SYNC_LOCKS
   KeAcquireSpinLock(&Driver.TimerLock, &OldIrql);
#endif

   SerialPoll();  // poll the rocketport for work to do

#ifdef USE_SYNC_LOCKS
   KeReleaseSpinLock(&Driver.TimerLock, OldIrql );
#endif

   // setup the Timer again.
   KeSetTimer(&Driver.PollTimer,
              Driver.PollIntervalTime,
              &Driver.TimerDpc);

   return;
}

/*---------------------------------------------------------------------------
  Function : SerialPoll
  Purpose:   This is called from ISR or Timer routine.  Common routine to
             periodically service the rocketport card.
  Return:    FALSE if not our interrupt(sharing allowed so causes the
             OS to pass on to next handler(if present).
             TRUE if it was our interrupt.  Return value does not matter
             if running off from Kernal TIMER.
|---------------------------------------------------------------------------*/
static BOOLEAN SerialPoll(void)
{
   PSERIAL_DEVICE_EXTENSION extension;
   PSERIAL_DEVICE_EXTENSION board_ext;

  // periodically we will re-calculate the timer base of NT.
  // we do it periodically, so that we don't waste a bunch of
  // CPU time, we only do it every 128 ticks..
  // We use this information so that our timers can have a
  // valid tick-base.  The timers could do these system calls
  // everytime, but this would get expense CPU wise, so we
  // calculate the basic tick rate in milliseconds so that
  // timer routines can do something simple like
  //   ticktime += msTickBase
  ++Driver.TickBaseCnt;
  if (Driver.TickBaseCnt > 128)
  {
    ULONG msBase;
  
    Driver.TickBaseCnt = 0;
    KeQuerySystemTime(&Driver.IsrSysTime);
    msBase = (ULONG)(Driver.IsrSysTime.QuadPart - Driver.LastIsrSysTime.QuadPart);
      // msBase now has 100ns ticks since last time we did this(128 ticks ago)
    msBase = (msBase / 128);
      // now msBase has the average 100ns time for 1 of our ISR ticks.
      // covert this to 100us units
    msBase = (msBase / 1000);
    if (msBase < 10)  // make at least 1ms
      msBase = 10;
    if (msBase > 200)  // ensure it is less than 20ms
      msBase = 200;
  
    // store it for timer use
    Driver.Tick100usBase = msBase;
    Driver.LastIsrSysTime.QuadPart = Driver.IsrSysTime.QuadPart;
  }

  ++Driver.PollCnt;

  if (Driver.Stop_Poll)  // flag to stop poll access
     return TRUE;  // signal it was our interrupt

  if ((Driver.PollCnt & 0x7f) == 0)  // every 128 ticks(about once a sec)
  {
    RocketRefresh();  // general background activity
  }

#ifdef LOAD_TESTING
   if (Driver.load_testing != 0)
   {
     unsigned int i,j;
     for (j=1000; j<Driver.load_testing; j++)
     {
       for (i=0; i<10000; i++)
       {
         //ustat = sGetModemStatus(extension->ChP);
         ustat = i+1;
       }
     }
   }
#endif

  // main poll service loop, service each board...
  board_ext = Driver.board_ext;
  while (board_ext != NULL)
  {
    if ((!board_ext->FdoStarted) || (!board_ext->config->HardwareStarted))
    {
       board_ext = board_ext->board_ext;  // next in chain
       continue;         // Check next port on this board
    }

#ifdef S_VS
    if (board_ext->pm->state == ST_ACTIVE)
    {
      port_poll(board_ext->pm);  // poll x times per second
      hdlc_poll(board_ext->hd);
    }
    else
    {
      port_state_handler(board_ext->pm);
    }
#endif

    // main poll service loop, service each board...
    extension = board_ext->port_ext;
    while (extension != NULL)
    {
            // If device not open, don't do anything
      if ( !extension->DeviceIsOpen )
      {
         extension = extension->port_ext;  // next in chain
         continue;         // Check next port on this board
      }

#ifdef S_RK
      ServiceRocket(extension);
#else
      ServiceVS(extension);
#endif

      extension = extension->port_ext;  // next in chain
    }  // while port extension
    board_ext = board_ext->board_ext;  // next in chain
  }  // while board extension

  return TRUE;  // signal it was our interrupt
}

#ifdef S_VS
/*---------------------------------------------------------------------------
  ServiceVS - Service the VS virtual hardware(queues, nic handling..)
|---------------------------------------------------------------------------*/
static void ServiceVS(PSERIAL_DEVICE_EXTENSION extension)
{
  SerPort *sp;
  ULONG wCount;
  int wrote_some_data;

  sp = extension->Port;

#ifdef SOFT_LOOP_BACK
  if (sp->mcr_value & MCR_LOOP_SET_ON)
  {
int room, out_cnt, wrap_cnt;
Queue *qin, *qout;
    //--------- Do a simple loopback emulation
    if (!q_empty(&sp->QOut))  // if output queue has data
    {
      qin = &sp->QIn;
      qout = &sp->QOut;
      room = q_room(qin);  // chk if room to dump it in
      out_cnt = q_count(qout);
      if (out_cnt > room)
          out_cnt = room;
      if (out_cnt > (int)(extension->BaudRate / 1000))  // assume 10ms tick
      {
        out_cnt = (int)(extension->BaudRate / 1000);
      }

      if (out_cnt != 0)
      {
        if (q_room_put_till_wrap(qin) < out_cnt)  // need a two part move
        {
          wrap_cnt = q_room_put_till_wrap(qin);
                      // read in the data to the buffer, first block
          q_get(qout, &qin->QBase[qin->QPut], wrap_cnt);
  
                    // read in the data to the buffer, second block
          q_get(qout, qin->QBase, out_cnt - wrap_cnt);
        }
        else  // single move will do, no wrap
        {
                   // read in the data to the buffer, 1 block
          q_get(qout, &qin->QBase[qin->QPut], out_cnt);
        }
        q_putted(qin, out_cnt);  // update queue indexes
      }  // room to put it
    }  // output q not empty
  }
#endif

  //////////////////////////////////////
  // If there is any data in the Rx FIFO
  // Read the data and do error checking
  if(!q_empty(&extension->Port->QIn))
     VSRead(extension);

  if (extension->port_config->RingEmulate)
  {
    if (extension->ring_timer != 0)  // RI on
    {
      --extension->ring_timer;
      if (extension->ring_timer != 0)  // RI on
         sp->msr_value |= MSR_RING_ON;
      else
      {
        //MyKdPrint(D_Test,("RING OFF!\n"))
        sp->msr_value &= ~MSR_RING_ON;
      }
    }
  }

  if (sp->old_msr_value != sp->msr_value)  // delta change bits
  {
    WORD diff, ModemStatus;

    diff = sp->old_msr_value ^ sp->msr_value;
    sp->old_msr_value = sp->msr_value;

    if (Driver.TraceOptions & 8)  // trace output data
    {
      char str[20];
      Sprintf(str, "msr:%x\n", sp->msr_value);
      q_put(&Driver.DebugQ, (BYTE *) str, strlen(str));
    }

    // Check on modem changes and update the modem status
    if (diff & (MSR_CD_ON | MSR_CTS_ON | MSR_RING_ON | MSR_DSR_ON | MSR_TX_FLOWED_OFF))
    {
      // make a bit set that ioctl can use in report
      ModemStatus = 0;
      if (sp->msr_value & MSR_CTS_ON)
      {
        ModemStatus |= SERIAL_CTS_STATE;
        if (extension->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE)
          extension->TXHolding &= ~SERIAL_TX_CTS;   // set holding
      }
      else
      {
        if (extension->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE)
          extension->TXHolding |= SERIAL_TX_CTS;   // set holding
      }

      if (sp->msr_value & MSR_DSR_ON)
      {
        ModemStatus |= SERIAL_DSR_STATE;
        if (extension->HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE)
          extension->TXHolding &= ~SERIAL_TX_DSR;   // set holding
      }
      else
      {
        if (extension->HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE)
          extension->TXHolding |= SERIAL_TX_DSR;   // set holding
      }

      if (sp->msr_value & MSR_RING_ON)
             ModemStatus |=  SERIAL_RI_STATE;

      if (sp->msr_value & MSR_CD_ON)
      {
        ModemStatus |= SERIAL_DCD_STATE;
        if (extension->HandFlow.ControlHandShake & SERIAL_DCD_HANDSHAKE)
          extension->TXHolding &= ~SERIAL_TX_DCD;   // set holding
      }
      else
      {
        if (extension->HandFlow.ControlHandShake & SERIAL_DCD_HANDSHAKE)
          extension->TXHolding |= SERIAL_TX_DCD;   // set holding
      }

      if (sp->msr_value & MSR_TX_FLOWED_OFF)
      {
        // handle holding detection if xon,xoff tx control activated
        if (extension->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT)
        {
          extension->TXHolding |= SERIAL_TX_XOFF; // holding
        }
      }
      else if (extension->TXHolding & SERIAL_TX_XOFF)
      {
        extension->TXHolding &= ~SERIAL_TX_XOFF; // not holding
      }

      extension->ModemStatus = (ULONG) ModemStatus;

      // following is for built in NT virtual 16450 uart support
      // virtual uart depends on escape commands in data stream to
      // detect modem-signal changes.
      if (extension->escapechar != 0)
      {
        UCHAR msr;
        if (q_room(&extension->RxQ) > 2)
        {
          q_put_one(&extension->RxQ, extension->escapechar);
          q_put_one(&extension->RxQ, SERIAL_LSRMST_MST);

          msr = (UCHAR)extension->ModemStatus;
          if (diff & MSR_CD_ON) msr |= 8;  // SERIAL_MSR_DDCD
          if (diff & MSR_RING_ON) msr |= 4;  // SERIAL_MSR_TERI
          if (diff & MSR_DSR_ON) msr |= 2; // SERIAL_MSR_DDSR
          if (diff & MSR_CTS_ON) msr |= 1; // SERIAL_MSR_DCTS
          q_put_one(&extension->RxQ, msr);
        }  // q_room
      } // if escapechar

      // Check if there are any modem events in the WaitMask
      if (extension->IsrWaitMask & ( SERIAL_EV_RING |
                                     SERIAL_EV_CTS |
                                     SERIAL_EV_DSR | 
                                     SERIAL_EV_RLSD ))
      {
        if( (extension->IsrWaitMask & SERIAL_EV_RING) &&
            (diff & MSR_RING_ON) )
        {  extension->HistoryMask |= SERIAL_EV_RING;
        }
        if ((extension->IsrWaitMask & SERIAL_EV_CTS) &&
            (diff & MSR_CTS_ON) )
        {  extension->HistoryMask |= SERIAL_EV_CTS;
        }
        if( (extension->IsrWaitMask & SERIAL_EV_DSR) &&
            (diff & MSR_DSR_ON) )
        {  extension->HistoryMask |= SERIAL_EV_DSR;
        }
        if( (extension->IsrWaitMask & SERIAL_EV_RLSD) &&
            (diff & MSR_CD_ON) )
        {  extension->HistoryMask |= SERIAL_EV_RLSD;
        }
      }  // isrwaitmask
    }  // diff
  } // old_msr != msr

  ////////////////////////////////////////////////////////////
  // At this point, all receive events should be chalked up.
  // Some events have been checked in VSRead()
  // Any Tx related WaitMask events will be reported in Tx Dpc

  // Abort all pending reads and writes if an error and ERROR_ABORT
  if( (extension->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) &&
      (extension->ErrorWord) )
  {
     KeInsertQueueDpc(&extension->CommErrorDpc,NULL,NULL);
  }

  // Tell the app about any Wait events that have occurred if needed
  if (extension->WaitIsISRs && extension->HistoryMask)
  {   

     *extension->IrpMaskLocation = extension->HistoryMask;

     // Done with these
     extension->WaitIsISRs = 0;
     extension->HistoryMask = 0;
     extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

     KeInsertQueueDpc(&extension->CommWaitDpc,NULL,NULL);
  }

  //-------- check for data to move from input queue to irp-buffer
  if (extension->ReadPending &&  // we are given control to fill
      extension->NumberNeededForRead &&  // more to be filled
      extension->CurrentReadIrp) // rug not pulled out from our feet
  {
    if (extension->RxQ.QPut != extension->RxQ.QGet)  // not empty
    {
      // move data from input queue to IRP buffer.
      extension->CountOnLastRead |=
                    SerialGetCharsFromIntBuffer(extension);

      if (extension->NumberNeededForRead == 0) // IRP complete!
      {
         extension->CurrentReadIrp->IoStatus.Information =
             IoGetCurrentIrpStackLocation(
                 extension->CurrentReadIrp
                 )->Parameters.Read.Length;
         extension->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;

         // We're finished with this read
         extension->ReadPending = FALSE;

         KeInsertQueueDpc( &extension->CompleteReadDpc, NULL, NULL );
      }  // irp complete
    }  // more data to read out of input queue
  } // end of Read completion

  wrote_some_data = 0;
  if (extension->WriteBelongsToIsr == 1)  // its ours to process
  {
    // own the cur write irp, have data to write
    if (extension->WriteLength)
    {
       wrote_some_data = 1;
       extension->ISR_Flags |= TX_NOT_EMPTY;  // use to detect fifo empty
                            // Send it all ,WriteTxBlk will chk fifo
       wCount = q_put( &extension->Port->QOut,
                  (PUCHAR)((extension->CurrentWriteIrp)->AssociatedIrp.SystemBuffer)+ 
                    (extension->CurrentWriteIrp)->IoStatus.Information,
                    extension->WriteLength);
  
       extension->OurStats.TransmittedCount += wCount;
       extension->WriteLength -= wCount;
       (extension->CurrentWriteIrp)->IoStatus.Information += wCount;
   
       if(!extension->WriteLength)//No more to write Close the DPC call
       {
         if (!extension->port_config->WaitOnTx)
         {
           extension->WriteBelongsToIsr = 2;
           KeInsertQueueDpc( &extension->CompleteWriteDpc, NULL, NULL );
         }
       }
    } // if (extension->WriteLength)  // data to write
  }

  if (!wrote_some_data)
  {
    if (extension->ISR_Flags & TX_NOT_EMPTY)
    {
      //----- check for EV_TXEMPTY condition
      // and no pending writes
      // check to see if tx-fifo is empty
      if ((q_empty(&extension->Port->QOut)) &&
          (PortGetTxCntRemote(extension->Port) == 0))
      {
        if (IsListEmpty(&extension->WriteQueue))
        {
          extension->ISR_Flags &= ~TX_NOT_EMPTY;

          // do we have an ev_txempty thing to take care of?
          if (extension->IrpMaskLocation &&
             (extension->IsrWaitMask & SERIAL_EV_TXEMPTY) )
          {
            // app has wait irp pending
            if (extension->CurrentWaitIrp)
            {
              extension->HistoryMask |= SERIAL_EV_TXEMPTY;
            }
          }
        }  // no more write irps queued up

          // see if we need to finish waitontx write irp
        if (extension->port_config->WaitOnTx)
        {
          if (extension->WriteBelongsToIsr == 1)  // its ours to process
          {
             extension->WriteBelongsToIsr = 2;
             KeInsertQueueDpc( &extension->CompleteWriteDpc, NULL, NULL );
          }
        }
      }   // tx fifo is empty
    }  // TX_NOT_EMPTY 
  }  // !wrote_some_data

      // Tell the app about any Wait events that have occurred if needed
  if (extension->WaitIsISRs && extension->HistoryMask)
  {   
#ifdef COMMENT_OUT
    if (Driver.TraceOptions & 8)  // trace output data
    {
      char str[20];
      Sprintf(str, "ISR Event:%xH\n", extension->HistoryMask);
      q_put(&Driver.DebugQ, (BYTE *) str, strlen(str));
    }
#endif
    *extension->IrpMaskLocation = extension->HistoryMask;

    // Done with these
    extension->WaitIsISRs = 0;
    extension->HistoryMask = 0;
    extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

    KeInsertQueueDpc(&extension->CommWaitDpc,NULL,NULL);
  }
}
#endif

#ifdef S_RK
/*---------------------------------------------------------------------------
  ServiceRocket - Handle the RocketPort hardware service
|---------------------------------------------------------------------------*/
static void ServiceRocket(PSERIAL_DEVICE_EXTENSION extension)
{
  ULONG ustat;
  ULONG wCount;
  int wrote_some_data;

  ustat = sGetChanIntID(extension->ChP);

  //////////////////////////////////////
  // If there is any data in the Rx FIFO
  // Read the data and do error checking
  if (ustat & RXF_TRIG)
  {
       RocketRead(extension);
  }

  // Check on modem changes and update the modem status
  if (ustat & (DELTA_CD|DELTA_CTS|DELTA_DSR))
  {
     // Read and update the modem status in the extension
     SetExtensionModemStatus(extension);
  }

  // handle RPortPlus RI signal
  if (extension->board_ext->config->IsRocketPortPlus)
  {
    if (sGetRPlusModemRI(extension->ChP) != 0)  // RI on
    {
      extension->ModemStatus |=  SERIAL_RI_STATE;
    }
    else
    {
      extension->ModemStatus &= ~SERIAL_RI_STATE;
    }
  }

#ifdef RING_FAKE
    if (extension->port_config->RingEmulate)
    {
      if (extension->ring_timer != 0)  // RI on
      {
        --extension->ring_timer;
        if (extension->ring_timer != 0)  // RI on
          extension->ModemStatus |=  SERIAL_RI_STATE;
        else
          extension->ModemStatus &= ~SERIAL_RI_STATE;
      }
    }
#endif

  if (extension->EventModemStatus != extension->ModemStatus)
  {
     // xor to show changed bits
     ustat = extension->EventModemStatus ^ extension->ModemStatus;

     // update change
     extension->EventModemStatus = extension->ModemStatus;

     // following is for built in NT virtual 16450 uart support
     // virtual uart depends on escape commands in data stream to
     // detect modem-signal changes.
     if (extension->escapechar != 0)
     {
       UCHAR msr;
       // we are assuming we have room to put the following!
       if (q_room(&extension->RxQ) > 2)
       {
         q_put_one(&extension->RxQ, extension->escapechar);
         q_put_one(&extension->RxQ, SERIAL_LSRMST_MST);

         msr = (UCHAR)extension->ModemStatus;
         if (ustat & SERIAL_DCD_STATE) msr |= 8; // SERIAL_MSR_DDCD
         if (ustat & SERIAL_RI_STATE)  msr |= 4; // SERIAL_MSR_TERI
         if (ustat & SERIAL_DSR_STATE) msr |= 2; // SERIAL_MSR_DDSR
         if (ustat & SERIAL_CTS_STATE) msr |= 1; // SERIAL_MSR_DCTS
         q_put_one(&extension->RxQ, msr);
       }
     }

     // Check if there are any modem events in the WaitMask
     if(extension->IsrWaitMask & ( SERIAL_EV_RING |
                                   SERIAL_EV_CTS |
                                   SERIAL_EV_DSR | 
                                   SERIAL_EV_RLSD )
       )
     {
        if( (extension->IsrWaitMask & SERIAL_EV_RING) &&
            (ustat & SERIAL_RI_STATE) )
        {  extension->HistoryMask |= SERIAL_EV_RING;
        }
        if( (extension->IsrWaitMask & SERIAL_EV_CTS) &&
            (ustat & SERIAL_CTS_STATE) )
        {  extension->HistoryMask |= SERIAL_EV_CTS;
        }
        if( (extension->IsrWaitMask & SERIAL_EV_DSR) &&
            (ustat & SERIAL_DSR_STATE) )
        {  extension->HistoryMask |= SERIAL_EV_DSR;
        }
        if( (extension->IsrWaitMask & SERIAL_EV_RLSD) &&
            (ustat & SERIAL_DCD_STATE) )
        {  extension->HistoryMask |= SERIAL_EV_RLSD;
        }
     }
  } // end if modem-control detect change

  ////////////////////////////////////////////////////////////
  // At this point, all receive events should be chalked up.
  // Some events have been checked in RocketRead()
  // Any Tx related WaitMask events will be reported in Tx Dpc

  // Abort all pending reads and writes if an error and ERROR_ABORT
  if( (extension->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) &&
      (extension->ErrorWord) )
  {
     KeInsertQueueDpc(&extension->CommErrorDpc,NULL,NULL);
  }

  //-------- check for data to move from input queue to irp-buffer
  if (extension->ReadPending &&  // we are given control to fill
      extension->NumberNeededForRead &&  // more to be filled
      extension->CurrentReadIrp) // rug not pulled out from our feet
  {
    if (extension->RxQ.QPut != extension->RxQ.QGet)  // not empty
    {
      // move data from input queue to IRP buffer.
      extension->CountOnLastRead |=
                    SerialGetCharsFromIntBuffer(extension);

      if (extension->NumberNeededForRead == 0) // IRP complete!
      {
         extension->CurrentReadIrp->IoStatus.Information =
             IoGetCurrentIrpStackLocation(
                 extension->CurrentReadIrp
                 )->Parameters.Read.Length;
         extension->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;

         // We're finished with this read
         extension->ReadPending = FALSE;

         KeInsertQueueDpc( &extension->CompleteReadDpc, NULL, NULL );
      }  // irp complete
    }  // more data to read out of input queue
  } // end of Read completion

  wrote_some_data = 0;

  //-------- do BREAK handling
  if ( extension->TXHolding & SERIAL_TX_BREAK )
  {
    // Check if we need to start the break
    if(extension->DevStatus & COM_REQUEST_BREAK)
    {
      // Make sure Transmitter is empty before slamming BREAK
      // Check the bit twice in case of time between buf and txshr load
      if( (sGetChanStatusLo(extension->ChP) & TXSHRMT) &&
          (sGetChanStatusLo(extension->ChP) & TXSHRMT) )
      {
          sSendBreak(extension->ChP);
          extension->DevStatus &= ~COM_REQUEST_BREAK;
      }
    }
  }
  else if (extension->WriteBelongsToIsr == 1)  // its ours to process
  {
    //----- Not holding due to BREAK so try to enqueue Tx data
    if (extension->WriteLength)
    {
       wrote_some_data = 1;
       if (extension->Option & OPTION_RS485_SOFTWARE_TOGGLE)
       {
         if ((extension->DTRRTSStatus & SERIAL_RTS_STATE) == 0)
         {
           sSetRTS(extension->ChP);
           extension->DTRRTSStatus |= SERIAL_RTS_STATE;
         }
       }

       extension->ISR_Flags |= TX_NOT_EMPTY;  // use to detect fifo empty

                            // Send it all ,WriteTxBlk will chk fifo
       wCount = sWriteTxBlk( extension->ChP,
                  (PUCHAR)((extension->CurrentWriteIrp)->AssociatedIrp.SystemBuffer)+ 
                    (extension->CurrentWriteIrp)->IoStatus.Information,
                    extension->WriteLength);
  
       extension->OurStats.TransmittedCount += wCount;
       extension->WriteLength -= wCount;
       (extension->CurrentWriteIrp)->IoStatus.Information += wCount;
   
       if(!extension->WriteLength)//No more to write Close the DPC call
       {
         if (!extension->port_config->WaitOnTx)
         {
           extension->WriteBelongsToIsr = 2;
           KeInsertQueueDpc( &extension->CompleteWriteDpc, NULL, NULL );
         }
       }
    } // if (extension->WriteLength)  // data to write
  }  // end if !TXholding and WriteBelongsToIsr == 1

  if (!wrote_some_data)
  {
    if (extension->ISR_Flags & TX_NOT_EMPTY)
    {
      //----- check for EV_TXEMPTY condition
      // and no pending writes
      // check to see if tx-fifo truely empty
      // need to check twice due to hardware quirks
      if ( (sGetTxCnt(extension->ChP) == 0) &&
           (sGetChanStatusLo(extension->ChP) & TXSHRMT) )
      {
        if (IsListEmpty(&extension->WriteQueue))
        {
          extension->ISR_Flags &= ~TX_NOT_EMPTY;

          // do we have an ev_txempty thing to take care of?
          if (extension->IrpMaskLocation &&
             (extension->IsrWaitMask & SERIAL_EV_TXEMPTY) )
          {
            // app has wait irp pending
            if (extension->CurrentWaitIrp)
            {
              extension->HistoryMask |= SERIAL_EV_TXEMPTY;
            }
          }

          if (extension->Option & OPTION_RS485_SOFTWARE_TOGGLE)
          {
            if ((extension->DTRRTSStatus & SERIAL_RTS_STATE) != 0)
            {
              extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
              sClrRTS(extension->ChP);
            }
          }
        }  // no more write irps queued up

          // see if we need to finish waitontx write irp
        if (extension->port_config->WaitOnTx)
        {
          if (extension->WriteBelongsToIsr == 1)  // its ours to process
          {
            extension->WriteBelongsToIsr = 2;
            KeInsertQueueDpc( &extension->CompleteWriteDpc, NULL, NULL );
          }
        }
      }   // tx fifo went empty
    }  // TX_NOT_EMPTY 
  }  // !wrote_some_data

      // Tell the app about any Wait events that have occurred if needed
  if (extension->WaitIsISRs && extension->HistoryMask)
  {   
#ifdef COMMENT_OUT
    if (Driver.TraceOptions & 8)  // trace output data
    {
      char str[20];
      Sprintf(str, "ISR Event:%xH\n", extension->HistoryMask);
      q_put(&Driver.DebugQ, (BYTE *) str, strlen(str));
    }
#endif
    *extension->IrpMaskLocation = extension->HistoryMask;

    // Done with these
    extension->WaitIsISRs = 0;
    //extension->IrpMaskLocation = NULL;
    extension->HistoryMask = 0;
    extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

    KeInsertQueueDpc(&extension->CommWaitDpc,NULL,NULL);
  }
}

/*-----------------------------------------------------------------------------
  Function : RocketRead
  Purpose:   Moves data from Rocket's Rx FIFO to RxIn of dev's extension
  NOTES:     The error checking assumes that if no replacement is required,
             the errored chars are ignored.
             The RXMATCH feature is used for EventChar detection. 
  Return:    None
|-----------------------------------------------------------------------------*/
static void RocketRead(PSERIAL_DEVICE_EXTENSION extension)
{
   int WrapCount;       // Number of bytes in wrap (2 stage copy)
   int RxFree;
   int sCount;
   unsigned int ChanStatus;
   unsigned int StatusWord;
   int OriginalCount;  // Used to determine if Rx event occurred

   // Save off the original Rx buff ptr. Test later for Rx event
   OriginalCount = extension->RxQ.QPut;

   // Get count before reading status
   // NOTE: Should always have a count if we entered this code
   sCount = sGetRxCnt(extension->ChP);

   if (sCount == 0)
   {
     //GTrace("Error, RXF_TRIG lied");
     return;
   }

   // Have count, now get status
   ChanStatus = sGetChanStatus(extension->ChP) &
                     (STATMODE | RXFOVERFL | RXBREAK |
                      RXFRAME |  RX2MATCH | RX1MATCH | RXPARITY);

   // Make sure we're in statmode if errors are pending in the FIFO
   if (ChanStatus)
   {
     if (ChanStatus & RX1MATCH)  // Must signal Rx Match immediately
     {
       if (extension->IsrWaitMask & SERIAL_EV_RXFLAG)
           extension->HistoryMask |= SERIAL_EV_RXFLAG;
       ChanStatus &= ~RX1MATCH;
     }
     if (ChanStatus)
       sEnRxStatusMode(extension->ChP);
   }

   // See how much space we have in RxBuf (host side buffer)
   RxFree = q_room(&extension->RxQ);


   if (RxFree > 20)  // plenty of space in RX queue
   {
      RxFree -= 20;  // leave some space for virtual insertion stuff
      extension->ReadByIsr++;  // Increment statistics Read flag

      //------ Adjust count to maximum we can put in RxIn buffer
      if (RxFree < sCount)
         sCount = RxFree;
   }
   else // no more room in server buffer input queue
   {
      extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_RX80FULL);

      // No room in host side buffer, only do the software flow ctl check

      // check for overflow
      if (ChanStatus & RXFOVERFL)
      {
        // extension->ErrorWord |= SERIAL_ERROR_OVERRUN;
        extension->ErrorWord |= SERIAL_ERROR_QUEUEOVERRUN;
        extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_ERR);
        ++extension->OurStats.BufferOverrunErrorCount;
      }

      goto FlowControlCheck;
   }

   //--------------------------- Attempt to read any pending data
   // ChanStatus indicates any pending errors or matches
   if (ChanStatus)
   {
      // Loop on reading Rocket FIFO
      // sCount represents Rocket data, RxFree represents host buffer
      while(sCount)
      {
         // Get stat byte and data
         StatusWord = sReadRxWord( sGetTxRxDataIO(extension->ChP));
         sCount--;
         ++extension->OurStats.ReceivedCount;       // keep status

         switch(StatusWord & (STMPARITYH | STMFRAMEH | STMBREAKH) )
         {
            case STMPARITYH:
            {
               if (extension->HandFlow.FlowReplace & SERIAL_ERROR_CHAR)
               {
                   q_put_one(&extension->RxQ,
                             extension->SpecialChars.ErrorChar);
               }
               else  // queue the character received(add 12-03-96)
               {
                   q_put_one(&extension->RxQ, (UCHAR)StatusWord);
               }

               extension->ErrorWord |= SERIAL_ERROR_PARITY;
               extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_ERR);
               ++extension->OurStats.ParityErrorCount;
               break;
            }

            case STMFRAMEH:
            {
               if (extension->HandFlow.FlowReplace & SERIAL_ERROR_CHAR)
               {
                 q_put_one(&extension->RxQ,
                             extension->SpecialChars.ErrorChar);
               }
               else  // queue the character received(add 12-03-96) 
               {
                 q_put_one(&extension->RxQ, (UCHAR)StatusWord);
               }

               extension->ErrorWord |= SERIAL_ERROR_FRAMING;
               extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_ERR);
               ++extension->OurStats.FrameErrorCount;
               break;
            }

            // PARITY can be set along with BREAK, BREAK overrides PARITY
            case ( STMBREAKH | STMPARITYH ):
            case STMBREAKH:
            {
               if (extension->HandFlow.FlowReplace & SERIAL_BREAK_CHAR)
               {
                 q_put_one(&extension->RxQ,
                           extension->SpecialChars.BreakChar);
               }
               extension->ErrorWord |= SERIAL_ERROR_BREAK;
               extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_BREAK);
               break;
            }

            default:
            {
               if (extension->TXHolding & ST_XOFF_FAKE)
               {
                 if ((UCHAR)StatusWord == extension->SpecialChars.XonChar)
                 {
                   extension->TXHolding &= ~ST_XOFF_FAKE;
                   extension->TXHolding &= ~SERIAL_TX_XOFF;
                   sEnTransmit(extension->ChP); // Start up the transmitter
                   sDisRxCompare2(extension->ChP);  // turn off match
                   sEnTxSoftFlowCtl(extension->ChP);  // turn on Tx software flow control

                   // override an actual XOFF from remote
                   sClrTxXOFF(extension->ChP);
                 }
                 else
                   { q_put_one(&extension->RxQ, (UCHAR)StatusWord); } // queue normal char
               }
               else
                 { q_put_one(&extension->RxQ, (UCHAR)StatusWord); } // queue normal char


               if (extension->escapechar != 0)
               {
                 if ((UCHAR)StatusWord == extension->escapechar)
                 {
                   // Modem status escape convention for virtual port
                   // support, escape the escape char.
                   { q_put_one(&extension->RxQ, SERIAL_LSRMST_ESCAPE); }
                 }
               }
            }
         } // end switch

         //------ check for near overflow condition due to insertions
         if (q_room(&extension->RxQ) < 10)
           sCount = 0;  // stop reading hardware!
      } // end while sCount

      //--- if rx-data all read down, turn off slow status mode
      if(!(sGetChanStatusLo(extension->ChP) & RDA))
      {
         sDisRxStatusMode(extension->ChP);
      }

      // Overflow is reported immediately, statmode can't do it properly
      if (ChanStatus & RXFOVERFL)
      {   extension->ErrorWord |= SERIAL_ERROR_OVERRUN;
          extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_ERR);
          ++extension->OurStats.SerialOverrunErrorCount;
      }
   } // end if ChanStatus
   else
   {
      //--------------------------------------------------------
      // No pending errors or matches in the FIFO, read the data normally (fast)
      // Check for wrap condition first

      WrapCount = q_room_put_till_wrap(&extension->RxQ);
      if (sCount > WrapCount)  // then 2 moves required
      {
        // This will require a wrap
        sReadRxBlk(extension->ChP,
                   extension->RxQ.QBase + extension->RxQ.QPut,
                   WrapCount);

        // Do the second copy...
        sReadRxBlk(extension->ChP,
                   extension->RxQ.QBase,
                   sCount-WrapCount);
#ifdef RING_FAKE
        if (extension->port_config->RingEmulate)
        {
          if ((extension->ModemStatus & SERIAL_DCD_STATE) == 0) // if CD off
          {
            ring_check(extension, extension->RxQ.QBase + extension->RxQ.QPut,
                      WrapCount);
            ring_check(extension, extension->RxQ.QBase,
                      sCount-WrapCount);
          }
        }
#endif
      }
      else  // only one move required
      {
        // no queue wrap required
        sReadRxBlk(extension->ChP,
                   extension->RxQ.QBase + extension->RxQ.QPut,
                   sCount);
#ifdef RING_FAKE
        if (extension->port_config->RingEmulate)
        {
          if ((extension->ModemStatus & SERIAL_DCD_STATE) == 0) // if CD off
          {
            ring_check(extension, extension->RxQ.QBase + extension->RxQ.QPut,
                      sCount);
          }
        }
#endif
      }
      extension->RxQ.QPut = (extension->RxQ.QPut + sCount) % extension->RxQ.QSize;
      extension->OurStats.ReceivedCount += sCount;
   } // end fast read


FlowControlCheck:   ;

   ///////////////////////////////////////
   // Software and DTR input flow control checking
   if(  (extension->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) ||
        (extension->HandFlow.ControlHandShake & SERIAL_DTR_HANDSHAKE )
     )
   {  
      // check for flow control conditions
      if (extension->DevStatus & COM_RXFLOW_ON)
      {
         // do we need to stop Rx?
         if(sGetRxCnt(extension->ChP) >= RX_HIWATER)
         {
            if(extension->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE)
            {
               // send XOFF
               sWriteTxPrioByte(extension->ChP,
                                extension->SpecialChars.XoffChar);
               extension->DevStatus &= ~COM_RXFLOW_ON;
               extension->RXHolding |= SERIAL_RX_XOFF;
            }

            if(extension->HandFlow.ControlHandShake & SERIAL_DTR_HANDSHAKE)
            {
               // drop DTR
               sClrDTR(extension->ChP);
               extension->DTRRTSStatus &= ~SERIAL_DTR_STATE;
               extension->DevStatus &= ~COM_RXFLOW_ON;
               extension->RXHolding |= SERIAL_RX_DSR;
            }
         }
      }
      else // Rx flow is stopped
      {
         // can we resume Rx?
         if(sGetRxCnt(extension->ChP) <= RX_LOWATER)
         {
            if(extension->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE)
            {
               // send XON
               sWriteTxPrioByte(extension->ChP,
                                extension->SpecialChars.XonChar);
               extension->DevStatus |= COM_RXFLOW_ON;
               extension->RXHolding &= ~SERIAL_RX_XOFF;
            }

            if(extension->HandFlow.ControlHandShake & SERIAL_DTR_HANDSHAKE)
            {
               // raise DTR
               sSetDTR(extension->ChP);
               extension->DTRRTSStatus |= SERIAL_DTR_STATE;
               extension->DevStatus |= COM_RXFLOW_ON;
               extension->RXHolding &= ~SERIAL_RX_DSR;
            }
         }
      }
   } // end of software and DTR input flow control check

   // Should we mark a Rx event?
   if ( OriginalCount != extension->RxQ.QPut )
      extension->HistoryMask|=(extension->IsrWaitMask & SERIAL_EV_RXCHAR);
}
#endif

#ifdef RING_FAKE
/*------------------------------------------------------------------------------
  ring_check - scan the rx data for a modem "RING<CR>" or "2<CR>" string.
    If found, trigger a emulated hardware RING signal.
|------------------------------------------------------------------------------*/
static void ring_check(PSERIAL_DEVICE_EXTENSION extension,
                BYTE *data,
                int len)
{
 int i;

  for (i=0; i<len; i++)
  {
    switch (data[i])
    {
      case '2':
        if (len <= 2)
          extension->ring_char = '2';
        else extension->ring_char = 0;
      break;
      case 'R':
        extension->ring_char = 'R';
      break;
      case 'I':
        if (extension->ring_char == 'R')
          extension->ring_char = 'I';
        else extension->ring_char = 0;
      break;
      case 'N':
        if (extension->ring_char == 'I')
          extension->ring_char = 'N';
        else extension->ring_char = 0;
      break;
      case 'G':
        if (extension->ring_char == 'N')
          extension->ring_char = 'G';
        else extension->ring_char = 0;
      break;
      case 0xd:
        if ( (extension->ring_char == 'G') ||
             ((extension->ring_char == '2') && (len <= 2)) )
        {
          //MyKdPrint(D_Init,("RING!\n"))
          // OK, look s like the data stream says a "RING" took place.
          // so setup a timer which will cause a hardware RING to be made
          // set to .5 sec for 10ms scanrate, .05sec for 1ms scanrate
          extension->ring_timer = 50;  
        }
        extension->ring_char = 0;
      break;
      default:
        extension->ring_char = 0;
      break;
    }
  }
}
#endif

/*-----------------------------------------------------------------------------
  RocketRefresh - This runs every 255 ticks or so, in order to perform
    background activities.  We will go read the modem status, and update
  the ModemCtl field.  The monitor program reads this variable, and we
  don't want to waste time reading it too often, so we just update it
  occasionally here.
|-----------------------------------------------------------------------------*/
static void RocketRefresh(void)
{
   PSERIAL_DEVICE_EXTENSION extension;
   PSERIAL_DEVICE_EXTENSION board_ext;

#ifdef S_RK
  board_ext = Driver.board_ext;
  while (board_ext)
  {
    if ((!board_ext->FdoStarted) || (!board_ext->config->HardwareStarted))
    {
      board_ext = board_ext->board_ext;
      continue;
    }
    extension = board_ext->port_ext;
    while (extension)
    {
      // Read and update the modem status in the extension
      SetExtensionModemStatus(extension);
 
      extension = extension->port_ext;  // next in chain
    }  // while port extension
    board_ext = board_ext->board_ext;
  }  // while board extension
#endif

  debug_poll();  // handle turn off of debug on inactivity timeout
}

#ifdef S_VS
/*-----------------------------------------------------------------------------
  Function : VSRead
  Purpose:   Moves data from VS's Rx FIFO to RxIn of dev's extension
  NOTES:     The error checking assumes that if no replacement is required,
             the errored chars are ignored.
             The RXMATCH feature is used for EventChar detection. 
  Return:    None
|-----------------------------------------------------------------------------*/
static void VSRead(PSERIAL_DEVICE_EXTENSION extension)
{
   int WrapCount;       // Number of bytes in wrap (2 stage copy)
   int RxFree;
   int sCount;
   LONG OriginalCount;  // Used to determine if Rx event occurred

   // Save off the original Rx buff ptr. Test later for Rx event
   OriginalCount = extension->RxQ.QPut;

   // Get count before reading status
   // NOTE: Should always have a count if we entered this code
   sCount=PortGetRxCnt(extension->Port);

   if (sCount == 0)
   {
     //MyTrace("Error, RXF_TRIG lied");
     return;
   }

  // See how much space we have in RxBuf (host side buffer)
  RxFree = q_room(&extension->RxQ);

  // if no space in RxBuf, don't read from RocketPort
  if (RxFree > 20)  // plenty of space in RX queue
  {
     RxFree -= 20;  // leave some space for virtual insertion stuff
     extension->ReadByIsr++;  // Increment statistics Read flag

     //------ Adjust count to maximum we can put in RxIn buffer
     if (RxFree < sCount)
        sCount = RxFree;
  }
  else // no more room in server buffer input queue
  {
     extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_RX80FULL);

     // No room in host side buffer, only do the software flow ctl check

     // check for overflow
     if (extension->Port->esr_reg & ESR_OVERFLOW_ERROR)
     {
       // extension->ErrorWord |= SERIAL_ERROR_OVERRUN;
       extension->ErrorWord |= SERIAL_ERROR_QUEUEOVERRUN;
       extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_ERR);
       extension->Port->esr_reg = 0;  // reset to zero on read
       ++extension->OurStats.BufferOverrunErrorCount;
     }

     goto FlowControlCheck;
  }

   //------ report any rx error conditions.
  if (extension->Port->esr_reg)
  {
    if (extension->Port->esr_reg & ESR_OVERFLOW_ERROR)
    {
      extension->ErrorWord |= SERIAL_ERROR_OVERRUN;
      extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_ERR);
      ++extension->OurStats.SerialOverrunErrorCount;
    }
    else if (extension->Port->esr_reg & ESR_BREAK_ERROR)
    {
      extension->ErrorWord |= SERIAL_ERROR_BREAK;
      extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_BREAK);
    }
    else if (extension->Port->esr_reg & ESR_FRAME_ERROR)
    {
      extension->ErrorWord |= SERIAL_ERROR_FRAMING;
      extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_ERR);
      ++extension->OurStats.FrameErrorCount;
    }
    else if (extension->Port->esr_reg & ESR_PARITY_ERROR)
    {
      extension->ErrorWord |= SERIAL_ERROR_PARITY;
      extension->HistoryMask |= (extension->IsrWaitMask&SERIAL_EV_ERR);
      ++extension->OurStats.ParityErrorCount;
    }
    extension->Port->esr_reg = 0;  // reset to zero on read
  }

  //--------------------------------------------------------
  // No pending errors or matches in the FIFO, read the data normally (fast)
  // Check for wrap condition first

  WrapCount = q_room_put_till_wrap(&extension->RxQ);
  if (sCount > WrapCount)  // then 2 moves required
  {
     q_get(&extension->Port->QIn,
                extension->RxQ.QBase + extension->RxQ.QPut,
                WrapCount);

     // Do the second copy...
     q_get(&extension->Port->QIn,
                extension->RxQ.QBase,
                sCount-WrapCount);
     if (extension->IsrWaitMask & SERIAL_EV_RXFLAG)
     {
       if (search_match(extension->RxQ.QBase + extension->RxQ.QPut,
                WrapCount,extension->SpecialChars.EventChar))
         extension->HistoryMask |= SERIAL_EV_RXFLAG;
       if (search_match(extension->RxQ.QBase,
                sCount-WrapCount,extension->SpecialChars.EventChar))
         extension->HistoryMask |= SERIAL_EV_RXFLAG;
     }

#ifdef RING_FAKE
     if (extension->port_config->RingEmulate)
     {
       if ((extension->ModemStatus & SERIAL_DCD_STATE) == 0) // if CD off
       {
         ring_check(extension, extension->RxQ.QBase + extension->RxQ.QPut,
                   WrapCount);
         ring_check(extension, extension->RxQ.QBase,
                   sCount-WrapCount);
       }
     }
#endif
  }
  else  // only one move required
  {
     q_get(&extension->Port->QIn,
           extension->RxQ.QBase + extension->RxQ.QPut,
           sCount);
     if (extension->IsrWaitMask & SERIAL_EV_RXFLAG)
     {
       if (search_match(extension->RxQ.QBase + extension->RxQ.QPut,
                sCount,extension->SpecialChars.EventChar))
         extension->HistoryMask |= SERIAL_EV_RXFLAG;
     }

#ifdef RING_FAKE
     if (extension->port_config->RingEmulate)
     {
       if ((extension->ModemStatus & SERIAL_DCD_STATE) == 0) // if CD off
       {
         ring_check(extension, extension->RxQ.QBase + extension->RxQ.QPut,
                   sCount);
       }
     }
#endif
  }
  extension->RxQ.QPut = (extension->RxQ.QPut + sCount) % extension->RxQ.QSize;
  extension->OurStats.ReceivedCount += sCount;
  extension->Port->Status |= S_UPDATE_ROOM;
#ifdef NEW_Q
  extension->Port->nGetLocal += sCount;
#endif

FlowControlCheck:   ;

  //----- Should we mark a Rx event?
  if ( OriginalCount != extension->RxQ.QPut )
     extension->HistoryMask|=(extension->IsrWaitMask & SERIAL_EV_RXCHAR);
}

#ifndef USE_MEMCHR_SCAN
/*------------------------------------------------------------------
 search_match -
|------------------------------------------------------------------*/
static int search_match(BYTE *buf, int count, BYTE eventchar)
{
  int i;
  for (i=0; i<count; i++)
  {
    if (buf[i] == eventchar)
      return 1;  // found
  }
  return 0;  // not found
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\nic.c ===
/*----------------------------------------------------------------------
 nic.c - routines for protocol access to NIC card via upper edge NDIS
  routines.
Change History:
1-18-99 - avoid sending empty HDLC packet(ACK only) up stack.
4-10-98 - Allow for NDIS40 dynamic bind capability if available.
11-14-97 - Created a thread to retry opening NIC's req by NT5.0.  DCS
 Copyright 1996-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"
#define DbgNicSet(n) {sz_modid[3] = nic->RefIndex + '0';}
#define Trace1(s,p1) GTrace1(D_Nic, sz_modid, s, p1)
#define TraceStr(s) GTrace(D_Nic, sz_modid, s)
#define TraceErr(s) GTrace(D_Error, sz_modid_err, s)
static char *sz_modid = {"Nic#"};
static char *sz_modid_err = {"Error,Nic"};

#ifdef NT50
#define DO_AUTO_CONFIG 1
#endif

//---- local functions
static PSERIAL_DEVICE_EXTENSION need_mac_autoassign(void);

int NicOpenAdapter(Nic *nic, IN PUNICODE_STRING NicName);
NDIS_STATUS NicWaitForCompletion(Nic *nic);

#ifdef OLD_BINDING_GATHER
NTSTATUS PacketReadRegistry(
    IN  PWSTR              *MacDriverName,
    IN  PWSTR              *PacketDriverName,
    IN  PUNICODE_STRING     RegistryPath,
    IN  int style);  // 0=nt4.0 location, 1=nt5.0 location
NTSTATUS PacketQueryRegistryRoutine(
    IN PWSTR     ValueName,
    IN ULONG     ValueType,
    IN PVOID     ValueData,
    IN ULONG     ValueLength,
    IN PVOID     Context,
    IN PVOID     EntryContext);
#endif

VOID PacketRequestComplete(
    IN NDIS_HANDLE   ProtocolBindingContext,
    IN PNDIS_REQUEST NdisRequest,
    IN NDIS_STATUS   Status);
VOID PacketSendComplete(
       IN NDIS_HANDLE   ProtocolBindingContext,
       IN PNDIS_PACKET  pPacket,
       IN NDIS_STATUS   Status);
NDIS_STATUS PacketReceiveIndicate (
    IN NDIS_HANDLE ProtocolBindingContext,
    IN NDIS_HANDLE MacReceiveContext,
    IN PVOID       HeaderBuffer,
    IN UINT        HeaderBufferSize,
    IN PVOID       LookAheadBuffer,
    IN UINT        LookAheadBufferSize,
    IN UINT        PacketSize);
VOID PacketTransferDataComplete (
    IN NDIS_HANDLE   ProtocolBindingContext,
    IN PNDIS_PACKET  pPacket,
    IN NDIS_STATUS   Status,
    IN UINT          BytesTransfered);
VOID PacketOpenAdapterComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_STATUS  Status,
    IN NDIS_STATUS  OpenErrorStatus);
VOID PacketCloseAdapterComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_STATUS  Status);
VOID PacketResetComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_STATUS  Status);
VOID PacketReceiveComplete(IN NDIS_HANDLE ProtocolBindingContext);
VOID PacketStatus(
    IN NDIS_HANDLE   ProtocolBindingContext,
    IN NDIS_STATUS   Status,
    IN PVOID         StatusBuffer,
    IN UINT          StatusBufferSize);
VOID PacketStatusComplete(IN NDIS_HANDLE  ProtocolBindingContext);

#ifdef TRY_DYNAMIC_BINDING
void PacketBind(
  OUT PNDIS_STATUS Status,
  IN  NDIS_HANDLE  BindContext,
  IN  PNDIS_STRING DeviceName,
  IN  PVOID SystemSpecific1,
  IN  PVOID SystemSpecific2);
VOID PacketUnBind(
  OUT PNDIS_STATUS Status,
  IN  NDIS_HANDLE ProtocolBindingContext,
  IN  NDIS_HANDLE  UnbindContext);
#endif

VOID GotOurPkt(Nic *nic);
void eth_rx_async(Nic *nic);
void eth_rx_admin(Nic *nic, BYTE *rx, BYTE *pkt_hdr, int len, int server);
Hdlc *find_hdlc_handle(BYTE *rx);
static int nic_handle_to_index(Nic *nic);

BYTE broadcast_addr[6] = {0xff,0xff,0xff,0xff,0xff,0xff};
BYTE mac_zero_addr[6] = {0,0,0,0,0,0};
BYTE mac_bogus_addr[6] = {0,0xc0,0x4e,0,0,0};
/*----------------------------------------------------------------------
 ProtocolOpen -
|----------------------------------------------------------------------*/
int ProtocolOpen(void)
{
  NTSTATUS Status = STATUS_SUCCESS;
  NDIS_PROTOCOL_CHARACTERISTICS  ProtocolChar;
  NDIS_STRING ProtoName = NDIS_STRING_CONST("VSLinka");
  int i;


  MyKdPrint(D_Init,("Proto Open\n"))
  if (Driver.NdisProtocolHandle == NULL)
  {
    MyKdPrint(D_Init,("P1\n"))
    RtlZeroMemory(&ProtocolChar,sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
    ProtocolChar.MajorNdisVersion            = 4;
    ProtocolChar.MinorNdisVersion            = 0;
    ProtocolChar.Reserved                    = 0;
    ProtocolChar.OpenAdapterCompleteHandler  = PacketOpenAdapterComplete;
    ProtocolChar.CloseAdapterCompleteHandler = PacketCloseAdapterComplete;
    ProtocolChar.SendCompleteHandler         = PacketSendComplete;
    ProtocolChar.TransferDataCompleteHandler = PacketTransferDataComplete;
    ProtocolChar.ResetCompleteHandler        = PacketResetComplete;
    ProtocolChar.RequestCompleteHandler      = PacketRequestComplete;
    ProtocolChar.ReceiveHandler              = PacketReceiveIndicate;
    ProtocolChar.ReceiveCompleteHandler      = PacketReceiveComplete;
    ProtocolChar.StatusHandler               = PacketStatus;
    ProtocolChar.StatusCompleteHandler       = PacketStatusComplete;
    ProtocolChar.Name                        = ProtoName;

    // version 4.0 NDIS parts:  
    ProtocolChar.ReceivePacketHandler    = NULL;
#ifdef TRY_DYNAMIC_BINDING
    ProtocolChar.BindAdapterHandler      = PacketBind;
    ProtocolChar.UnbindAdapterHandler    = PacketUnBind;
#endif
    //ProtocolChar.TranslateHandler        = NULL;
    ProtocolChar.UnloadHandler           = NULL;
    Driver.ndis_version = 4;
#ifdef TRY_DYNAMIC_BINDING
  // don't do this yet(not fully debugged)
    NdisRegisterProtocol(
        &Status,
        &Driver.NdisProtocolHandle,
        &ProtocolChar,
        sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
    if (Status != NDIS_STATUS_SUCCESS)
#endif
    {
      MyKdPrint(D_Init,("No NDIS40\n"))

      // try NDIS30
      ProtocolChar.MajorNdisVersion           = 3;
      ProtocolChar.BindAdapterHandler      = NULL;
      ProtocolChar.UnbindAdapterHandler    = NULL;

      NdisRegisterProtocol(
          &Status,
          &Driver.NdisProtocolHandle,
          &ProtocolChar,
          sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
      if (Status != NDIS_STATUS_SUCCESS)
      {
        MyKdPrint(D_Init,("No NDIS30\n"))
        return 1;  // error
      }
      Driver.ndis_version = 3;
    }
  }

  MyKdPrint(D_Init,("NDIS V%d\n",Driver.ndis_version))

  return 0;  // ok
}

/*----------------------------------------------------------------------
 NicOpen - Setup all our stuff for our own protocol, so we can
  talk ethernet.  Setup our callbacks to upper edge NDIS routines,
  grab registry entries which tell us who we are and what NIC cards
  we are bound to.  Take care of all init stuff associated with using
  the NIC card.
|----------------------------------------------------------------------*/
int NicOpen(Nic *nic, IN PUNICODE_STRING NicName)
{
  NTSTATUS Status = STATUS_SUCCESS;
  //NDIS_HANDLE NdisProtocolHandle;

  int i;
  NDIS_STATUS     ErrorStatus;
  PNDIS_BUFFER    NdisBuffer;

  //MyKdPrint(D_Init,("Nic Open\n"))
  DbgNicSet(nic);
  TraceStr("NicOpen");

  //----- This event is used in case any of the NDIS requests pend;
  KeInitializeEvent(&nic->CompletionEvent,
                    NotificationEvent, FALSE);

  Status = NicOpenAdapter(nic, NicName);
  if (Status)
  {
    MyKdPrint(D_Init,("Nic Fail Open\n"))
    NicClose(nic);
    return Status;
  }
  MyKdPrint(D_Init,("Nic Open OK\n"))

#ifdef COMMENT_OUT
  Nic->MacInfo.DestinationOffset = 0;
  Nic->MacInfo.SourceOffset = 6;
  Nic->MacInfo.SourceRouting = FALSE;
  Nic->MacInfo.AddressLength = 6;
  Nic->MacInfo.MaxHeaderLength = 14;
  Nic->MacInfo.MediumType = NdisMedium802_3;
#endif
  // NDIS packets consist of one or more buffer descriptors which point
  // to the actual data.  We send or receive single packets made up of
  // 1 or more buffers.  A MDL is used as a buffer descriptor under NT.

  //---------  Allocate a packet pool for our tx packets

  NdisAllocatePacketPool(&Status, &nic->TxPacketPoolTemp, 1,
                         sizeof(PVOID));
                 //        sizeof(PACKET_RESERVED));
  if (Status != NDIS_STATUS_SUCCESS)
  {
    NicClose(nic);
    return 4;
  }

  //---------  Allocate a buffer pool for our tx packets
  // we will only use 1 buffer per packet.
  NdisAllocateBufferPool(&Status, &nic->TxBufferPoolTemp, 1);
  if (Status != NDIS_STATUS_SUCCESS)
  {
    NicClose(nic);
    return 5;
  }

  //-------- create tx data buffer area
  nic->TxBufTemp = our_locked_alloc( MAX_PKT_SIZE,"ncTX");
  if (nic->TxBufTemp == NULL)
  {
    NicClose(nic);
    return 16;
  }

  //-------- form our tx queue packets so they link to our tx buffer area
  {
    // Get a packet from the pool
    NdisAllocatePacket(&Status, &nic->TxPacketsTemp, nic->TxPacketPoolTemp);
    if (Status != NDIS_STATUS_SUCCESS)
    {
      NicClose(nic);
      return 8;
    }
    nic->TxPacketsTemp->ProtocolReserved[0] = 0;  // mark with our index
    nic->TxPacketsTemp->ProtocolReserved[1] = 0;  // free for use

    // get a buffer for the temp output packet
    NdisAllocateBuffer(&Status, &NdisBuffer, nic->TxBufferPoolTemp,
      &nic->TxBufTemp[0], 1520);
    if (Status != NDIS_STATUS_SUCCESS)
    {
      NicClose(nic);
      return 9;
    }
    // we use only one data buffer per packet
    NdisChainBufferAtFront(nic->TxPacketsTemp, NdisBuffer);
  }

  //----------  Allocate a packet pool for our rx packets
  NdisAllocatePacketPool(&Status, &nic->RxPacketPool, MAX_RX_PACKETS,
                         sizeof(PVOID));
               //        sizeof(PACKET_RESERVED));

  if (Status != NDIS_STATUS_SUCCESS)
  {
    NicClose(nic);
    return 6;
  }

  //---------  Allocate a buffer pool for our rx packets
  // we will only use 1 buffer per packet.
  NdisAllocateBufferPool(&Status, &nic->RxBufferPool, MAX_RX_PACKETS);
  if (Status != NDIS_STATUS_SUCCESS)
  {
    NicClose(nic);
    return 7;
  }

  //-------- create rx data buffer area, add in space at front
  // of packets to put our private data
  nic->RxBuf = our_locked_alloc(
                (MAX_PKT_SIZE+HDR_SIZE) * MAX_RX_PACKETS,"ncRX");

  //------- form our rx queue packets so they link to our rx buffer area
  for (i=0; i<MAX_RX_PACKETS; i++)
  {
    // Get a packet from the pool
    NdisAllocatePacket(&Status, &nic->RxPackets[i], nic->RxPacketPool);
    if (Status != NDIS_STATUS_SUCCESS)
    {
      NicClose(nic);
      return 10;
    }
    nic->RxPackets[i]->ProtocolReserved[0] = i;  // mark with our index
    nic->RxPackets[i]->ProtocolReserved[1] = 0;  // free for use

    //--- link the buffer to our actual buffer space, leaving 20 bytes
    // at start of buffer for our private data(length, index, etc)
    NdisAllocateBuffer(&Status, &NdisBuffer, nic->RxBufferPool,
      &nic->RxBuf[((MAX_PKT_SIZE+HDR_SIZE) * i)+HDR_SIZE], MAX_PKT_SIZE);
    if (Status != NDIS_STATUS_SUCCESS)
    {
      NicClose(nic);
      return 11;
    }
    // we use only one data buffer per packet
    NdisChainBufferAtFront(nic->RxPackets[i], NdisBuffer);
  }

  strcpy(nic->NicName, UToC1(NicName));

  Trace1("Done Open NicName %s", nic->NicName);

  nic->Open = 1;
  return 0;  // ok
}

/*----------------------------------------------------------------------
 NicOpenAdapter -
|----------------------------------------------------------------------*/
int NicOpenAdapter(Nic *nic, IN PUNICODE_STRING NicName)
{
  UINT            Medium;
  NDIS_MEDIUM     MediumArray=NdisMedium802_3;
  NTSTATUS Status = STATUS_SUCCESS;
  NDIS_STATUS     ErrorStatus;
  ULONG RBuf;

  DbgNicSet(nic);

  NdisOpenAdapter(
        &Status,              // return status
        &ErrorStatus,
        &nic->NICHandle,      // return handle value
        &Medium,
        &MediumArray,
        1,
        Driver.NdisProtocolHandle,  // pass in our protocol handle
        (NDIS_HANDLE) nic,    // our handle passed to protocol callback routines
        NicName,        // name of nic-card to open
        0,
        NULL);

  if (Status == NDIS_STATUS_SUCCESS)
      PacketOpenAdapterComplete(nic,  Status, NDIS_STATUS_SUCCESS);
  else if (Status == NDIS_STATUS_PENDING)
  {
    TraceErr("NicOpen Pended");
    Status = NicWaitForCompletion(nic);  // wait for completion
  }

  if (Status != NDIS_STATUS_SUCCESS)
  {
    GTrace2(D_Nic, sz_modid, "NicOpen fail:%xH Err:%xH", Status, ErrorStatus);
    TraceStr(UToC1(NicName));
    nic->NICHandle = NULL;
    NicClose(nic);
    return 3;
  }

  GTrace1(D_Nic, sz_modid, "Try NicOpened:%s", nic->NicName);

  //----- get the local NIC card identifier address
  Status = NicGetNICInfo(nic, OID_802_3_CURRENT_ADDRESS,
                         (PVOID)nic->address, 6);

  //----- set the rx filter
  RBuf = NDIS_PACKET_TYPE_DIRECTED;
  Status = NicSetNICInfo(nic, OID_GEN_CURRENT_PACKET_FILTER,
                         (PVOID)&RBuf, sizeof(ULONG));

  return 0;  // ok
}

/*----------------------------------------------------------------------
 NicClose - Shut down our NIC access.  Deallocate any NIC resources.
|----------------------------------------------------------------------*/
int NicClose(Nic *nic)
{
  NTSTATUS Status;

  DbgNicSet(nic);
  TraceStr("NicClose");

  nic->Open = 0;
  nic->NicName[0] = 0;
  if (nic->NICHandle != NULL)
  {
    NdisCloseAdapter(&Status, nic->NICHandle);
    if (Status == NDIS_STATUS_PENDING)
    {
      Status = NicWaitForCompletion(nic);  // wait for completion
    }
    nic->NICHandle = NULL;
  }

  if (nic->TxPacketPoolTemp != NULL)
    NdisFreePacketPool(nic->TxPacketPoolTemp);
  nic->TxPacketPoolTemp = NULL;

  if (nic->TxBufferPoolTemp != NULL)
    NdisFreeBufferPool(nic->TxBufferPoolTemp);
  nic->TxBufferPoolTemp = NULL;

  if (nic->TxBufTemp != NULL)
    our_free(nic->TxBufTemp, "ncTX");
  nic->TxBufTemp = NULL;


  if (nic->RxPacketPool != NULL)
    NdisFreePacketPool(nic->RxPacketPool);
  nic->RxPacketPool = NULL;

  if (nic->RxBufferPool != NULL)
    NdisFreeBufferPool(nic->RxBufferPool);
  nic->RxBufferPool = NULL;

  if (nic->RxBuf != NULL)
    our_free(nic->RxBuf,"ncRX");
  nic->RxBuf = NULL;

  MyKdPrint(D_Nic,("Nic Close End\n"))
  return 0;
}

/*----------------------------------------------------------------------
 NicProtocolClose - Deregister our protocol.
|----------------------------------------------------------------------*/
int NicProtocolClose(void)
{
  NTSTATUS Status;

  MyKdPrint(D_Nic,("Nic Proto Close\n"))

  if (Driver.NdisProtocolHandle != NULL)
    NdisDeregisterProtocol(&Status, Driver.NdisProtocolHandle);
  Driver.NdisProtocolHandle = NULL;
  return 0;
}

/*----------------------------------------------------------------------
 PacketRequestComplete - If a call is made to NdisRequest() to get
   information about the NIC card(OID), then it may return PENDING and
   this routine would then be called by NDIS to finalize the call.
|----------------------------------------------------------------------*/
VOID PacketRequestComplete(
    IN NDIS_HANDLE   ProtocolBindingContext,
    IN PNDIS_REQUEST NdisRequest,
    IN NDIS_STATUS   Status)
{

  Nic *nic = (Nic *)ProtocolBindingContext;

  MyKdPrint(D_Nic,("PacketReqComp\n"))
  //MyDeb(NULL, 0xffff, "PktRqComp\n");

  nic->PendingStatus = Status;
  KeSetEvent(&nic->CompletionEvent, 0L, FALSE);
  return;
}

/*----------------------------------------------------------------------
 PacketSendComplete - Callback routine if NdisSend() returns PENDING.
|----------------------------------------------------------------------*/
VOID PacketSendComplete(
       IN NDIS_HANDLE   ProtocolBindingContext,
       IN PNDIS_PACKET  pPacket,
       IN NDIS_STATUS   Status)
{
  Nic *nic = (Nic *)ProtocolBindingContext;

#if DBG
    if (nic == NULL)
    {
      MyKdPrint(D_Error, ("**** NicP Err1"))
      return;
    }
    DbgNicSet(nic);

    //nic->PendingStatus = Status;
    if (Status == STATUS_SUCCESS)
      {TraceStr("PcktSendComplete");}
    else
      {TraceErr("PcktSendComplete Error!");}
#endif

    pPacket->ProtocolReserved[1] = 0;  // free for use

    //--- not using this
    //KeSetEvent(&nic->CompletionEvent, 0L, FALSE);

    return;
}

/*----------------------------------------------------------------------
 NicWaitForCompletion - Utility routine to wait for async. routine
   to complete.
|----------------------------------------------------------------------*/
NDIS_STATUS NicWaitForCompletion(Nic *nic)
{
   MyKdPrint(D_Nic,("WaitOnComp\n"))
   // The completion routine will set PendingStatus.
   KeWaitForSingleObject(
         &nic->CompletionEvent,
              Executive,
              KernelMode,
              TRUE,
              (PLARGE_INTEGER)NULL);

   KeResetEvent(&nic->CompletionEvent);
   MyKdPrint(D_Nic,("WaitOnCompEnd\n"))
   return nic->PendingStatus;
}
  
/*----------------------------------------------------------------------
 PacketReceiveIndicate - When a packet comes in, this routine is called
   to let us(protocol) know about it.  We may peek at the data and
   optionally arrange for NDIS to transfer the complete packet data to
   one of our packets.

   LookAheadBufferSize is guarenteed to be as big as the
    OID_GEN_CURRENT_LOOKAHEAD value or packet size, whichever is smaller.
   If (PacketSize != LookAheadBufferSize) then a NdisTransferData() is
    required.  Otherwise the complete packet is available in the
    lookahead buffer.
    !!!!Check the OID_GEN_somethin or other, there is a bit which indicates
    if we can copy out of lookahead buffer.
    The header len is typically 14 bytes in length for ethernet.
|----------------------------------------------------------------------*/
NDIS_STATUS PacketReceiveIndicate (
  IN NDIS_HANDLE ProtocolBindingContext,
  IN NDIS_HANDLE MacReceiveContext,
  IN PVOID       HeaderBuffer,
  IN UINT        HeaderBufferSize,
  IN PVOID       LookAheadBuffer,
  IN UINT        LookAheadBufferSize,
  IN UINT        PacketSize)
{
  NDIS_STATUS Status;
  UINT BytesTransfered;
  WORD LenOrId;

  //  int stat;
  //static char tmparr[60];

  Nic *nic = (Nic *)ProtocolBindingContext;
#if DBG
  if (nic == NULL)
  {
    MyKdPrint(D_Error, ("Eth15b\n"))
  }
  if (!nic->Open)
  {
    MyKdPrint(D_Error, ("Eth15a\n"))
    return 1;
  }
#endif
  DbgNicSet(nic);
  TraceStr("pkt_rec_ind");

  if (HeaderBufferSize != 14)
  {
    TraceErr("Header Size!");
    ++nic->pkt_rcvd_not_ours;
    return NDIS_STATUS_NOT_ACCEPTED;
  }

  LenOrId = *(PWORD)(((PBYTE)HeaderBuffer)+12);
  if (LenOrId != 0xfe11)
  {
    // this not our packet
    ++nic->pkt_rcvd_not_ours;
    return NDIS_STATUS_NOT_ACCEPTED;
  }

  if (LookAheadBufferSize > 1)
  {
    //------ lets check for our product id header
    LenOrId = *(PBYTE)(((PBYTE)HeaderBuffer)+14);
       // serial concentrator product line
    if (LenOrId != ASYNC_PRODUCT_HEADER_ID)
    {
      if (LenOrId != 0xff)
      {
        TraceStr("nic,not async");
        // this not our packet
        ++nic->pkt_rcvd_not_ours;
        return NDIS_STATUS_NOT_ACCEPTED;
      }
    }
  }

#ifdef BREAK_NIC_STUFF
  if (nic->RxPackets[0]->ProtocolReserved[1] & 1)  // marked as pending
  {
     // our one rx buffer is in use!  (should never happen)
     MyKdPrint(D_Error, ("****** RxBuf in use!"))
     //TraceErr("Rx Buf In Use!");
     return NDIS_STATUS_NOT_ACCEPTED;
  }
  nic->RxPackets[0]->ProtocolReserved[1] |= 1;  // marked as pending
#endif

  memcpy(nic->RxBuf, (BYTE *)HeaderBuffer, 14);  // copy the eth. header

  if (LookAheadBufferSize == PacketSize)
  {
    TraceStr("nic,got complete");
    ++nic->RxNonPendingMoves;
    // we can just copy complete packet out of lookahead buffer
    // store the 14 byte header data at start of buffer

    memcpy(&nic->RxBuf[HDR_SIZE], (BYTE *)LookAheadBuffer, PacketSize);
    HDR_PKTLEN(nic->RxBuf) = PacketSize;  // save the pkt size here
    ++nic->pkt_rcvd_ours;
    GotOurPkt(nic);
  }
  else // LookAhead not complete buffer, pending, do transfer
  {
    ++nic->RxPendingMoves;
    //MyDeb(NULL, 0xffff, "PktRecInd, Pend\n");

    //  Call the Mac to transfer the packet
    NdisTransferData(&Status, nic->NICHandle, MacReceiveContext,
       0, PacketSize, nic->RxPackets[0], &BytesTransfered);

    if (Status == NDIS_STATUS_SUCCESS)
    {
      TraceStr("nic,got trsfer complete");
      HDR_PKTLEN(nic->RxBuf) = PacketSize;

      //------ lets check for our product id header
      if ((nic->RxBuf[HDR_SIZE] != ASYNC_PRODUCT_HEADER_ID) &&
          (nic->RxBuf[HDR_SIZE] != 0xff) )
      {
         nic->RxPackets[0]->ProtocolReserved[1] = 0;  // marked as not use
         TraceStr("nic,not async");
         // this not our packet
         ++nic->pkt_rcvd_not_ours;
         return NDIS_STATUS_NOT_ACCEPTED;
      }

      ++nic->pkt_rcvd_ours;
      GotOurPkt(nic);
    }
    else if (Status == NDIS_STATUS_PENDING)
    {
      TraceStr("nic,got pending");
      // ndis will call PacketTransferDataComplete.
    }
    else  // an error occurred(adapter maybe getting reset)
    {
      MyKdPrint(D_Error, ("nic, Err1D"))
      nic->RxPackets[0]->ProtocolReserved[1] = 0;  // marked as not use
      //MyDeb(NULL, 0xffff, "PktRecInd, PendError\n");
    }
  }
  return NDIS_STATUS_SUCCESS;
}

/*----------------------------------------------------------------------
 GotOurPkt - Its our packet(0x11fe for id at [12,13],
  and ASYNC(VS1000) or ff as [14],
  index byte we don't care about[16],
   rx = ptr to rx_pkt[16].
   [12,13] WORD 11fe(comtrol-pci-id, used as ethertype)
   [14] Product(55H=async, 15H=isdn, FFH=all)
   [15] Index Field(Server assigned box index)
   [16] Packet Class, 1=ADMIN, 0x55=VS1000 packet
     [17] word len for admin packet
     [17] hdlc control field for vs1000 packet
|----------------------------------------------------------------------*/
VOID GotOurPkt(Nic *nic)
{
  // [HDR_SIZE] is after 14 byte header, so contains [14] data
  // [14]=55H or FFH, [15]=Index, not used [16]=1(ADMIN),55H=ASYNC_MESSAGE
  switch(nic->RxBuf[HDR_SIZE+2])  
  {
    case ADMIN_FRAME:  // ADMIN function, special setup admin functions
      TraceStr("admin");
      eth_rx_admin(nic,
                   nic->RxBuf+(HDR_SIZE+3), // ptr to admin data
                   nic->RxBuf,              // ptr to ethernet header data
                   HDR_PKTLEN(nic->RxBuf),  // we embed length at [12] 0x11fe
                   1);  // server flag
    break;

     case ASYNC_FRAME:  // async frame(normal iframe/control hdlc packets)
       TraceStr("iframe");
       eth_rx_async(nic);
     break;

     default:
       TraceStr("badf");
       Tprintf("D: %x %x %x %x",
               nic->RxBuf[HDR_SIZE],
               nic->RxBuf[HDR_SIZE+1],
               nic->RxBuf[HDR_SIZE+2],
               nic->RxBuf[HDR_SIZE+3]);
     break;
   }
   nic->RxPackets[0]->ProtocolReserved[1] = 0;  // mark as not use
}

/*----------------------------------------------------------------
 eth_rx_async - We receive from layer1, validate using the
   hdlc validation call, and ship rx-pkt up to the next upper layer.
|-----------------------------------------------------------------*/
void eth_rx_async(Nic *nic)
{
 int i;
 Hdlc *hd;
 //WORD hd_index;
 WORD id;
 BYTE *rx;
 PSERIAL_DEVICE_EXTENSION ext;

  rx = nic->RxBuf;

#ifdef USE_INDEX_FIELD
  id = rx[HDR_SIZE];
#endif

  // find the HDLC level with the reply address
  //hd_index = 0xffff;  // save index to hdlc handle in header area
  hd = NULL;

  i = 0;
  ext = Driver.board_ext;
  while (ext != NULL)
  {
#ifdef USE_INDEX_FIELD
    if (id == ext->pm->unique_id)
#else
    if (mac_match(&rx[6], ext->hd->dest_addr))
#endif
    {
      hd = ext->hd;
      break;
    }
    ++i;
    ext = ext->board_ext; // next one
  }

  if (hd == NULL)
  {
    TraceErr("no Mac Match!");
    return;
  }

  if (!hd->nic || !hd->nic->Open)
  {
    TraceErr("notOpen!");
    return;
  }

  // 55 0 55 control snd_index ack_index
  rx += (HDR_SIZE+3);  // skip over header

  i = hdlc_validate_rx_pkt(hd, rx);  // validate the packet

  if (i == 0)
  {
    TraceStr("nic, pass upper");
    if (hd->upper_layer_proc != NULL)
    {
      if (*(rx+3) != 0)  // not an empty packet(HDLC ACK packets, t1 timeout)
      {
        (*hd->upper_layer_proc)(hd->context,
                              EV_L2_RX_PACKET,
                              (DWORD) (rx+3) );
      }
      ++(hd->frames_rcvd);
    }
  }
  else
  {
    switch (i)
    {
      case ERR_GET_EMPTY      : // 1  // empty
        TraceErr("Empty!");
      break;
      case ERR_GET_BAD_INDEX  : // 2  // error, packet out of sequence
        TraceErr("LanIdx!");
      break;
      case ERR_GET_BADHDR     : // 3  // error, not our packet
        // TraceErr("LanHdr!");
      break;
      case ERR_CONTROL_PACKET :
      break;

      default: TraceErr("LanErr!"); break;
    }
  }  // else hdlc, error or control, not iframe
}

/*----------------------------------------------------------------------------
| eth_rx_admin - PortMan handles admin functions, validate and pass on as
  event messages.  rx is ptr to admin data, [17][18]=len, [19]=sub-admin-header
|----------------------------------------------------------------------------*/
void eth_rx_admin(Nic *nic, BYTE *rx, BYTE *pkt_hdr, int len, int server)
{
  Hdlc *hd;

  rx += 2;

  TraceStr("AdminPkt");
  if (mac_match(pkt_hdr, broadcast_addr))   // its a broadcast
  {
    if ((*rx == 2) && (!server)) // Product ID request, Broadcast by server
    {
      // ok, we will reply
    }
    else if ((*rx == 3) && (server)) // Product ID reply, reply by concentrator.
    {
      // might be box waking up, or responding to server request.
      // shouldn't see it broadcast, but ISDN box currently broadcasts
      // on power-up.
    }
    else
    {
      TraceErr("bad b-admin!");
    }
    TraceErr("broadcast admin!");
    return;
  }

  switch(*rx)
  {
#ifdef COMMENT_OUT
    case 2:  // Product ID request, Broadcast or sent by server
      TraceStr("idreq");
      if (!server)  // we are not a server, we are box
        eth_id_req(&pkt_hdr[6]);
    break;
#endif

    case 1:  // boot loader query
      if (!server)  // we are a server
        break;

      if ((hd = find_hdlc_handle(&pkt_hdr[6])) != NULL)
      {
        PortMan *pm = (PortMan *) hd->context;
        if (pm->state != ST_SENDCODE)
        {
#if 0
          // not functional at this point.
          // port manager is not uploading code, so it must be debug pkt
          // let port.c code handle boot-loader ADMIN reply.
          debug_device_reply(pm, 
                    rx+1,
                    pkt_hdr);
#endif
        }
        else
        {
          TraceStr("load_reply");
          // tell upper layer(port-manager) about ID reply
          // port-manager does code loading.
          if (hd->upper_layer_proc != NULL)
            (*hd->upper_layer_proc)(hd->context,
                                    EV_L2_BOOT_REPLY,
                                    (DWORD) (rx+1));
        }
      }
#ifdef COMMENT_OUT
#endif
    break;

    case 3:  // Product ID reply, reply by concentrator.
      TraceStr("id_reply");
      if (!server)  // we are a server
        break;
      {
        BYTE *list;
        BYTE *new;
        int i, found;
        // driver previously sent out directed or broadcast query
        // on network to detect boxes.
        // build a list of units which reply.
        // (rx+1) = ptr to reply address
        // *(rx+1+6) = flags byte which indicate if main-driver loaded.
        found = 0;  // default to "did not find mac addr in list"
        new  = rx+1;
        if (Driver.NumBoxMacs < MAX_NUM_BOXES)
        {
          for (i=0; i<Driver.NumBoxMacs; i++)
          {
             list = &Driver.BoxMacs[i*8];
             if (mac_match(list, new))
               found = 1;  // found mac addr in list
          }
        }

        if (!found)  // then add to list of mac addresses found on network
        {
          if (Driver.NumBoxMacs < MAX_NUM_BOXES)
          {
            memcpy(&Driver.BoxMacs[Driver.NumBoxMacs*8], rx+1, 8);
            Driver.BoxMacs[Driver.NumBoxMacs*8+7] = (BYTE) 
              nic_handle_to_index(nic);
            Driver.BoxMacs[Driver.NumBoxMacs*8+6] = *(rx+1+6); // flags byte
            if (Driver.NumBoxMacs < (MAX_NUM_BOXES-1))
             ++Driver.NumBoxMacs;
          }
        }
        if (!Driver.TimerCreated) // init time(no hdlc levels active)
          break;  // so don't try to use hdlc

        if ((hd = find_hdlc_handle(&pkt_hdr[6])) != NULL)
        {
          // stash the nic index in byte after flags byte
          *(rx+1+7) = (BYTE) nic_handle_to_index(nic);
          // tell upper layer(port-mananger) about ID reply
          if (hd->upper_layer_proc != NULL)
            (*hd->upper_layer_proc)(hd->context,
                                    EV_L2_ADMIN_REPLY,
                                    (DWORD) (rx+1));
        }
        else
        {
#ifdef DO_AUTO_CONFIG
          PSERIAL_DEVICE_EXTENSION need_ext;

          MyKdPrint(D_Test,("Got Reply, Check AutoAssign\n"))
          if (!(*(rx+1+6) & FLAG_APPL_RUNNING))  // no box driver running
          {
            MyKdPrint(D_Test,("AutoAssign1\n"))
            // so probably free to auto-assign.
            // see if any extensions need auto assignment
            need_ext =need_mac_autoassign();
            if ((need_ext != NULL) && (Driver.AutoMacDevExt == NULL))
            {
              MyKdPrint(D_Test,("AutoAssigned!\n"))
                // set the mac addr for use
              memcpy(need_ext->config->MacAddr, (rx+1), 6);
                // signal the thread that auto-config needs
                // to be written out to registry
              Driver.AutoMacDevExt = need_ext;
            }
          }
#endif
        }
      }
    break;

    case 4:  // Loopback request
      TraceStr("aloop");
      //eth_loop_back(rx, pkt_hdr, len);
    break;

    case 5:  // Command, Reset
      TraceStr("reset");
      //eth_command_reset(rx, pkt_hdr, len);
    break;
    default:
      TraceErr("admin, badpkt!");
    break;
  }
}

/*----------------------------------------------------------------------
  find_hdlc_handle - find the Hdlc object with the same mac-address
    as the ethernet header source mac address.
|----------------------------------------------------------------------*/
Hdlc *find_hdlc_handle(BYTE *rx)
{
 PSERIAL_DEVICE_EXTENSION ext;

  ext = Driver.board_ext;
  while (ext != NULL)
  {
    if (mac_match(rx, ext->hd->dest_addr))
    {
      return ext->hd;
    }
    ext = ext->board_ext; // next one
  }

  TraceStr("find,NoMac Match!");
  return NULL;
}

/*----------------------------------------------------------------------
  need_mac_autoassign - Used for autoconfig of mac-address.
|----------------------------------------------------------------------*/
static PSERIAL_DEVICE_EXTENSION need_mac_autoassign(void)
{
  PSERIAL_DEVICE_EXTENSION board_ext;

  board_ext = Driver.board_ext;
  while (board_ext != NULL)
  {
      // see if not configured
    if ( (mac_match(board_ext->config->MacAddr, mac_zero_addr)) ||
         (mac_match(board_ext->config->MacAddr, mac_bogus_addr)) )
      return board_ext;  // needs auto-assignment

    board_ext = board_ext->board_ext;
  }
  return NULL;  // its not used
}

/*----------------------------------------------------------------------
 PacketReceiveComplete -
|----------------------------------------------------------------------*/
VOID PacketReceiveComplete(IN NDIS_HANDLE ProtocolBindingContext)
{
  //Nic *nic = (Nic *)ProtocolBindingContext;

  TraceStr("PcktRxComp");
  //MyDeb(NULL, 0xffff, "PktRecComp, 1\n");

  //lan_rec_proc(Driver->lan, nic->RxBuf, nic->len);
  //netio_got_packet(Driver->lan, nic->RxBuf);
  return;
}

/*----------------------------------------------------------------------
 PacketTransferDataComplete -
|----------------------------------------------------------------------*/
VOID PacketTransferDataComplete (
    IN NDIS_HANDLE   ProtocolBindingContext,
    IN PNDIS_PACKET  pPacket,
    IN NDIS_STATUS   Status,
    IN UINT          BytesTransfered)
{
  Nic *nic = (Nic *)ProtocolBindingContext;

  TraceStr("nic, pend rx complete");
  if ((nic->RxBuf[HDR_SIZE] != ASYNC_PRODUCT_HEADER_ID) &&
      (nic->RxBuf[HDR_SIZE] != 0xff) )
  {
    TraceStr("not ours");
    ++nic->pkt_rcvd_not_ours;
    nic->RxPackets[0]->ProtocolReserved[1] = 0;  // mark as not use
    return;
  }

  ++nic->pkt_rcvd_ours;
  GotOurPkt(nic);

  return;
}

/*----------------------------------------------------------------------
 PacketOpenAdapterComplete - Callback.
|----------------------------------------------------------------------*/
VOID PacketOpenAdapterComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_STATUS  Status,
    IN NDIS_STATUS  OpenErrorStatus)
{
  Nic *nic = (Nic *)ProtocolBindingContext;
  nic->PendingStatus = Status;
  TraceStr("PcktOpenAd");
  KeSetEvent(&nic->CompletionEvent, 0L, FALSE);
  return;
}

/*----------------------------------------------------------------------
 PacketCloseAdapterComplete -
|----------------------------------------------------------------------*/
VOID PacketCloseAdapterComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_STATUS  Status)
{
  Nic *nic = (Nic *)ProtocolBindingContext;
  TraceStr("PcktCloseAd");
  nic->PendingStatus = Status;
  KeSetEvent(&nic->CompletionEvent, 0L, FALSE);
  return;
}

/*----------------------------------------------------------------------
 PacketResetComplete -
|----------------------------------------------------------------------*/
VOID PacketResetComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_STATUS  Status)
{
  Nic *nic = (Nic *)ProtocolBindingContext;
  TraceStr("PcktResetComplete");
  nic->PendingStatus = Status;
  KeSetEvent(&nic->CompletionEvent, 0L, FALSE);
  return;
}

/*----------------------------------------------------------------------
 PacketStatus -
|----------------------------------------------------------------------*/
VOID PacketStatus(
    IN NDIS_HANDLE   ProtocolBindingContext,
    IN NDIS_STATUS   Status,
    IN PVOID         StatusBuffer,
    IN UINT          StatusBufferSize)
{
  TraceStr("PcktStat");
   return;
}

/*----------------------------------------------------------------------
 PacketStatusComplete -
|----------------------------------------------------------------------*/
VOID PacketStatusComplete(IN NDIS_HANDLE  ProtocolBindingContext)
{
  TraceStr("PcktStatComplete");
   return;
}

/*----------------------------------------------------------------------
 NicSetNICInfo -
|----------------------------------------------------------------------*/
NDIS_STATUS NicSetNICInfo(Nic *nic, NDIS_OID Oid, PVOID Data, ULONG Size)
{
  NDIS_STATUS    Status;
  NDIS_REQUEST   Request;

  // Setup the request to send
  Request.RequestType=NdisRequestSetInformation;
  Request.DATA.SET_INFORMATION.Oid=Oid;
  Request.DATA.SET_INFORMATION.InformationBuffer=Data;
  Request.DATA.SET_INFORMATION.InformationBufferLength=Size;

  NdisRequest(&Status,
              nic->NICHandle,
              &Request);

  if (Status == NDIS_STATUS_SUCCESS)
  {}
  else if (Status == NDIS_STATUS_PENDING)
    Status = NicWaitForCompletion(nic);  // wait for completion

  if (Status != NDIS_STATUS_SUCCESS)
  {
    MyKdPrint (D_Init,("NdisRequest Failed- Status %x\n",Status))
  }
  return Status;
}

/*----------------------------------------------------------------------
 NicGetNICInfo - To call the NICs QueryInformationHandler
|----------------------------------------------------------------------*/
NDIS_STATUS NicGetNICInfo(Nic *nic, NDIS_OID Oid, PVOID Data, ULONG Size)
{
  NDIS_STATUS    Status;
  NDIS_REQUEST   Request;
             
  // Setup the request to send
  Request.RequestType=NdisRequestQueryInformation;
  Request.DATA.SET_INFORMATION.Oid=Oid;
  Request.DATA.SET_INFORMATION.InformationBuffer=Data;
  Request.DATA.SET_INFORMATION.InformationBufferLength=Size;

  NdisRequest(&Status,
              nic->NICHandle,
              &Request);

  if (Status == NDIS_STATUS_SUCCESS)
  {}
  else if (Status == NDIS_STATUS_PENDING)
    Status = NicWaitForCompletion(nic);  // wait for completion

  if (Status != NDIS_STATUS_SUCCESS)
  {
    MyKdPrint (D_Init,("NdisRequest Failed- Status %x\n",Status))
  }
  return Status;
}

/*--------------------------------------------------------------------------
| nic_send_pkt -
|--------------------------------------------------------------------------*/
int nic_send_pkt(Nic *nic, BYTE *buf, int len)
{
// BYTE *bptr;
// int cnt;
 NTSTATUS Status;
//int pkt_num;

  if (nic == NULL)
  {
    MyKdPrint(D_Error, ("E1\n"))
    TraceErr("snd1a");
    return 1;
  }
  if (nic->TxBufTemp == NULL)
  {
    MyKdPrint(D_Error, ("E2\n"))
    TraceErr("snd1b");
    return 1;
  }
  if (nic->TxPacketsTemp == NULL)
  {
    MyKdPrint(D_Error, ("E3\n"))
    TraceErr("snd1c");
    return 1;
  }
  if (nic->Open == 0)
  {
    MyKdPrint(D_Error, ("E4\n"))
    TraceErr("snd1d");
    return 1;
  }
  DbgNicSet(nic);
  TraceStr("send_pkt");

  if (nic->TxPacketsTemp->ProtocolReserved[1] & 1)  // marked as pending
  {
    TraceErr("snd1e");

       // reset in case it got stuck
       // nic->TxPacketsTemp->ProtocolReserved[1] = 0;
    return 3;
  }

  memcpy(nic->TxBufTemp, buf, len);

  nic->TxPacketsTemp->Private.TotalLength = len;
  NdisAdjustBufferLength(nic->TxPacketsTemp->Private.Head, len);

  nic->TxPacketsTemp->ProtocolReserved[1] = 1;  // mark as pending
  NdisSend(&Status, nic->NICHandle,  nic->TxPacketsTemp);
  if (Status == NDIS_STATUS_SUCCESS)
  {           
    TraceStr("snd ok");
    nic->TxPacketsTemp->ProtocolReserved[1] = 0;  // free for use
  }
  else if (Status == NDIS_STATUS_PENDING)
  {
    TraceStr("snd pend");
      // Status = NicWaitForCompletion(nic);  // wait for completion
  }
  else
  {
    nic->TxPacketsTemp->ProtocolReserved[1] = 0;  // free for use
    TraceErr("send1A");
    return 1;
  }
 
  ++nic->pkt_sent;             // statistics
  nic->send_bytes += len;      // statistics

  return 0;
}

#ifdef TRY_DYNAMIC_BINDING
/*----------------------------------------------------------------------
  PacketBind - Called when nic card ready to use.  Passes in name of
    nic card.  NDIS40 protocol only.
|----------------------------------------------------------------------*/
VOID PacketBind(
  OUT PNDIS_STATUS Status,
  IN  NDIS_HANDLE  BindContext,
  IN  PNDIS_STRING DeviceName,
  IN  PVOID SystemSpecific1,
  IN  PVOID SystemSpecific2)
{
 int i,stat;

  MyKdPrint(D_Init,("Dyn. Bind\n"))

  TraceErr("DynBind");
  TraceErr(UToC1(DeviceName));

  // NIC not open - retry open
  for (i=0; i<VS1000_MAX_NICS; i++)
  {
    MyKdPrint(D_Init,("D1\n"))
    if((Driver.nics[i].NICHandle == NULL) &&
       (Driver.NicName[i].Buffer == NULL))
    {
      MyKdPrint(D_Init,("D2\n"))
      // make a copy of the nic-name
      Driver.NicName[i].Buffer =
        our_locked_alloc(DeviceName->Length + sizeof(WCHAR), "pkbd");
      memcpy(Driver.NicName[i].Buffer, DeviceName->Buffer, DeviceName->Length);
      Driver.NicName[i].Length = DeviceName->Length;
      Driver.NicName[i].MaximumLength = DeviceName->Length;

      stat = NicOpen(&Driver.nics[i], &Driver.NicName[i]);
      if (stat)
      {
        TraceErr("Bad NicOpen");
        *Status = NDIS_STATUS_NOT_ACCEPTED;
        return;
      }
      else
      {
        MyKdPrint(D_Init,("D3\n"))
        Driver.BindContext[i] = BindContext;  // save this for the unbind
        *Status = NDIS_STATUS_SUCCESS;
        return;
      }
    }
  }

  MyKdPrint(D_Init,("D4\n"))
  *Status = NDIS_STATUS_NOT_ACCEPTED;
  return;

  //if (pended)
  //  NdisCompleteBindAdapter(BindContext);
}

/*----------------------------------------------------------------------
  PacketUnBind -  Called when nic card is shutting down, going away.
    NDIS40 protocol only.
|----------------------------------------------------------------------*/
VOID PacketUnBind(
  OUT PNDIS_STATUS Status,
  IN  NDIS_HANDLE ProtocolBindingContext,
  IN  NDIS_HANDLE  UnbindContext)
{
 int i, pi;
  TraceErr("DynUnBind");

  //if (pend)
  //  NdisCompleteUnBindAdapter(BindContext);
  // NIC not open - retry open

  // find the nic card which is closing up shop
  for (i=0; i<Driver.num_nics; i++)
  {
    if (Driver.BindContext[i] == ProtocolBindingContext) // a match!
    {
      TraceErr("fnd UnBind");
      if((Driver.nics[i].NICHandle != NULL) &&
         (Driver.nics[i].Open))
      {
        // first find all the box objects, and shut them down
        // BUGBUG: we should use some spinlocks here, we are in danger of
        // doing two things at once(pulling the rug out from under
        // port.c operations while it is running.
        ext = Driver.board_ext;
        while (ext)
        {
          if (Driver.pm[pi].nic_index == i)  // its using this nic card
          {
            if (Driver.pm[pi].state == Driver.pm[i].state)
            {
              TraceErr("Shutdown box");
              Driver.pm[pi].state = ST_INIT;
            }
          }
          ext = ext->board_ext;
        }

        NicClose(&Driver.nics[i]);
        if (Driver.NicName[i].Buffer)
        {
          our_free(Driver.NicName[i].Buffer, "pkbd");  // free up the unicode buf
          Driver.NicName[i].Buffer = 0;
        }
      }
      Driver.BindContext[i] = 0;
    }
  }

  *Status = NDIS_STATUS_SUCCESS;
  return;
}
#endif

/*----------------------------------------------------------------------
  nic_handle_to_index - given a nic handle, give the index into the
    linked list, or array.
|----------------------------------------------------------------------*/
static int nic_handle_to_index(Nic *nic)
{
 int i;

  for (i=0; i<VS1000_MAX_NICS; i++)
  {
    if ((&Driver.nics[i]) == nic)
      return i;
  }
  TraceErr("BadIndex");
  return 0;
}

#if 0
/*----------------------------------------------------------------------
  PacketTranslate -
|----------------------------------------------------------------------*/
VOID PacketTranslate(
  OUT PNDIS_STATUS Status,
  IN NDIS_HANDLE ProtocolBindingContext,
  OUT  PNET_PNP_ID  IdList,
  IN ULONG IdListLength,
  OUT PULONG BytesReturned)
{
}

/*----------------------------------------------------------------------
  PacketUnLoad -
|----------------------------------------------------------------------*/
VOID PacketUnLoad(VOID)
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\isr.h ===
//--- isr.h

BOOLEAN SerialISR(
         IN PKINTERRUPT InterruptObject,
         IN PVOID Context);

VOID TimerDpc(
      IN PKDPC Dpc,
      IN PVOID DeferredContext,
      IN PVOID SystemContext1,
      IN PVOID SystemContext2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\ioctl.c ===
/*-------------------------------------------------------------------
| ioctl.c - handle all the misc. serial ioctl calls.
4-05-00 - Add address (&) operator to actual parameter passed to sWriteTxBlk
5-13-99 - enable RTS toggling for VS
2-15-99 - make SerialSetHandflow() public, so pnp can call it. kpb
1-21-99  - fix immed char send to trigger EV_TXEMPTY, add some support
  for VS immediate char send.
11-24-98 - update DBG kdprint messages for event handling tests - kpb
 9-24-98 - include tx-shift-reg in getcommstat report - kpb.
 4-29-98 - adjust break output to start immediately if possible - kpb.
Copyright 1993-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

typedef struct {
   ULONG struct_size;
   ULONG num_ports;
   ULONG total_loads;
   ULONG good_loads;
   ULONG backup_server;
   ULONG state;
   ULONG iframes_sent;
   ULONG rawframes_sent;  // was send_rawframes
   ULONG ctlframes_sent;  // was send_ctlframes
   ULONG iframes_resent;  // was pkt_resends
   ULONG iframes_outofseq;  // was ErrBadIndex
   ULONG frames_rcvd;    // was: rec_pkts
   ULONG nic_index;
   unsigned char dest_addr[6];
} PROBE_DEVICE_STRUCT;

typedef struct {
  ULONG struct_size;
  ULONG Open;
  ULONG pkt_sent;
  ULONG pkt_rcvd_ours;
  ULONG pkt_rcvd_not_ours;
  char NicName[64];
  unsigned char address[6];
} PROBE_NIC_STRUCT;

static PSERIAL_DEVICE_EXTENSION find_ext_mac_match(unsigned char *mac_addr);
static int ProbeDevices(unsigned char *pPtr, int availableLength);
static int ProbeNic(unsigned char *pPtr, int availableLength);

/*-------------------------------------------------------------------
  Function : SerialIoControl
  Purpose:   Process Ioctls for a device.
  Call:      SerialIoControl(DeviceObject,Irp)
             PDEVICE_OBJECT DeviceObject: Pointer to the Device Object
             PIRP Irp: Pointer to the I/O Request Packet
  Return:    STATUS_SUCCESS: always
             STATUS_FAIL: if request couldn't be fulfilled
  Comments:  This function is the device driver IOCTL entry point.
|--------------------------------------------------------------------*/
NTSTATUS SerialIoControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    KIRQL OldIrql;
    BOOLEAN acceptingIRPs;

    acceptingIRPs = SerialIRPPrologue(Extension);

    if (acceptingIRPs == FALSE) {
       MyKdPrint(D_Ioctl,("Ioctl:no irps accepted!\n"))
       Irp->IoStatus.Information = 0;
       Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
       SerialCompleteRequest(Extension, Irp, IO_NO_INCREMENT);
       return STATUS_NO_SUCH_DEVICE;
    }

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0L;

    MyKdPrint(D_Ioctl,("SerialIoControl: %x\n",
                          IrpSp->Parameters.DeviceIoControl.IoControlCode))
    // Make sure we aren't aborting due to error (ERROR_ABORT)

    if (Extension->ErrorWord)
    {
      if (Extension->DeviceType == DEV_PORT)
      {
        if (SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS)
        {
           MyKdPrint(D_Ioctl,("ErrSet, Cancel!\n"))
           {ExtTrace(Extension,D_Ioctl,"ErrSet!");}
           return STATUS_CANCELLED;
        }
      }
    }

    //
    // Make sure IOCTL is applicable for the device type (i.e. ignore port
    // level IOCTL's if board object is specified
    //

    if (Extension->DeviceType == DEV_BOARD)
    {
        switch (IrpSp->Parameters.DeviceIoControl.IoControlCode)
        {
           case IOCTL_SERIAL_CONFIG_SIZE:
           case IOCTL_SERIAL_GET_COMMCONFIG:
           case IOCTL_SERIAL_SET_COMMCONFIG:
           case IOCTL_RCKT_GET_STATS:
           case IOCTL_RCKT_ISR_CNT:
           case IOCTL_RCKT_CHECK:
           case IOCTL_RCKT_MONALL:
           case IOCTL_RCKT_SET_MODEM_RESET:
           case IOCTL_RCKT_CLEAR_MODEM_RESET:
           case IOCTL_RCKT_SEND_MODEM_ROW:
           case IOCTL_RCKT_SET_MODEM_RESET_OLD:
           case IOCTL_RCKT_CLEAR_MODEM_RESET_OLD:
           case IOCTL_RCKT_GET_RCKTMDM_INFO_OLD:
           case IOCTL_RCKT_SEND_MODEM_ROW_OLD:

              break; // Allowable board level IOCTL's

           default:
              MyKdPrint (D_Ioctl, (" Bad Status: %xH on IIOCTL: %xH\n", Status,
                         IrpSp->Parameters.DeviceIoControl.IoControlCode));
              ExtTrace2 (Extension, D_Ioctl, " Bad Status:%xH on IIOCTL:%xH",
                         Status, IrpSp->Parameters.DeviceIoControl.IoControlCode);
              Irp->IoStatus.Information = 0;
              Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
              SerialCompleteRequest(Extension, Irp, IO_NO_INCREMENT);
              return STATUS_INVALID_DEVICE_REQUEST;
        }
    };

    // Main IOCTL switch
    //ExtTrace1(Extension,D_Ioctl,"Ioctl:%x",
    //                      IrpSp->Parameters.DeviceIoControl.IoControlCode);

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode)
    {

      //******************************
      case IOCTL_SERIAL_GET_STATS :  // get performace stats
      {
       PSERIALPERF_STATS sp = Irp->AssociatedIrp.SystemBuffer;

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(SERIALPERF_STATS)) {

            Status = STATUS_BUFFER_TOO_SMALL;
            break;

        }
        Irp->IoStatus.Information = sizeof(SERIALPERF_STATS);
        Status = STATUS_SUCCESS;

       
       sp->TransmittedCount = Extension->OurStats.TransmittedCount -
                              Extension->OldStats.TransmittedCount;
       sp->FrameErrorCount = Extension->OurStats.FrameErrorCount - 
                             Extension->OldStats.FrameErrorCount;
       sp->SerialOverrunErrorCount = Extension->OurStats.SerialOverrunErrorCount -
                                     Extension->OldStats.SerialOverrunErrorCount;
       sp->BufferOverrunErrorCount = Extension->OurStats.BufferOverrunErrorCount -
                                     Extension->OldStats.BufferOverrunErrorCount;
       sp->ParityErrorCount = Extension->OurStats.ParityErrorCount -
                              Extension->OldStats.ParityErrorCount;
      }
      break;

      //******************************
      case IOCTL_SERIAL_CLEAR_STATS :  // clear performace stats
      {

        Extension->OldStats.TransmittedCount =
          Extension->OurStats.TransmittedCount;

        Extension->OldStats.FrameErrorCount = 
          Extension->OurStats.FrameErrorCount;

        Extension->OldStats.SerialOverrunErrorCount =
          Extension->OurStats.SerialOverrunErrorCount;

        Extension->OldStats.BufferOverrunErrorCount =
          Extension->OurStats.BufferOverrunErrorCount;

        Extension->OldStats.ParityErrorCount =
          Extension->OurStats.ParityErrorCount;

        Irp->IoStatus.Information = 0;
        Status = STATUS_SUCCESS;
      }
      break;

      //******************************
      case IOCTL_SERIAL_SET_BAUD_RATE :
      {
         ULONG DesiredBaudRate;
         MyKdPrint(D_Ioctl,("[Set Baud Rate]\n"))
         if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(SERIAL_BAUD_RATE))
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             MyKdPrint(D_Ioctl,("[Buffer too Small]\n"))
             break;
         }
         DesiredBaudRate =
            ((PSERIAL_BAUD_RATE)(Irp->AssociatedIrp.SystemBuffer))->BaudRate;

         ExtTrace1(Extension,D_Ioctl,"Set Baud Rate:%d",DesiredBaudRate);

         Status = ProgramBaudRate(Extension,DesiredBaudRate);

         break;
      }

      //******************************
      case IOCTL_SERIAL_GET_BAUD_RATE:
      {
         PSERIAL_BAUD_RATE Br =
                      (PSERIAL_BAUD_RATE)Irp->AssociatedIrp.SystemBuffer;
         MyKdPrint(D_Ioctl,("[Get Baud Rate]\n"))
         ExtTrace1(Extension,D_Ioctl,"Get Baud Rate:%d",Extension->BaudRate);

         if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIAL_BAUD_RATE))
         {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
         }
         KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);
         Br->BaudRate = Extension->BaudRate;
         KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
         Irp->IoStatus.Information = sizeof(SERIAL_BAUD_RATE);
         break;
      }

      //*********************************
      case IOCTL_SERIAL_SET_LINE_CONTROL:
      {
         PSERIAL_LINE_CONTROL DesiredLineControl;
         MyKdPrint(D_Ioctl,("[Set Line Control]\n"))

         if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(SERIAL_LINE_CONTROL))
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }
         DesiredLineControl =
             ((PSERIAL_LINE_CONTROL)(Irp->AssociatedIrp.SystemBuffer));

         ExtTrace(Extension,D_Ioctl, "Set Line Ctrl");

         Status = ProgramLineControl(Extension,DesiredLineControl);
         break;
      }

      //*********************************
      case IOCTL_SERIAL_GET_LINE_CONTROL:
      {
         PSERIAL_LINE_CONTROL Lc =
                  (PSERIAL_LINE_CONTROL)Irp->AssociatedIrp.SystemBuffer;
         MyKdPrint(D_Ioctl,("[Get Line Control]\n"))
         ExtTrace(Extension,D_Ioctl,"Get Line Ctrl");

         Irp->IoStatus.Information = sizeof(SERIAL_LINE_CONTROL);
         if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(SERIAL_LINE_CONTROL))
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }
         Lc->Parity=Extension->LineCtl.Parity;
         Lc->WordLength=Extension->LineCtl.WordLength;
         Lc->StopBits=Extension->LineCtl.StopBits;
         break;
      }

      //******************************
      case IOCTL_SERIAL_SET_TIMEOUTS:
      {
          PSERIAL_TIMEOUTS NewTimeouts =
              ((PSERIAL_TIMEOUTS)(Irp->AssociatedIrp.SystemBuffer));
          MyKdPrint(D_Ioctl,("[Set Timeouts]\n"))

          if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(SERIAL_TIMEOUTS))
          {
              Status = STATUS_BUFFER_TOO_SMALL;
              break;
          }

          if ((NewTimeouts->ReadIntervalTimeout == MAXULONG) &&
              (NewTimeouts->ReadTotalTimeoutMultiplier == MAXULONG) &&
              (NewTimeouts->ReadTotalTimeoutConstant == MAXULONG))
          {
              Status = STATUS_INVALID_PARAMETER;
              break;
          }

          ExtTrace3(Extension,D_Ioctl,"Timeouts-RIT:%xH RM:%xH RC:%xH",
                   NewTimeouts->ReadIntervalTimeout,
                   NewTimeouts->ReadTotalTimeoutMultiplier,
                   NewTimeouts->ReadTotalTimeoutConstant);

          ExtTrace2(Extension,D_Ioctl," WM:%xH WC:%xH",
                   NewTimeouts->WriteTotalTimeoutMultiplier,
                   NewTimeouts->WriteTotalTimeoutConstant);


          KeAcquireSpinLock( &Extension->ControlLock, &OldIrql );

          Extension->Timeouts.ReadIntervalTimeout =
              NewTimeouts->ReadIntervalTimeout;

          Extension->Timeouts.ReadTotalTimeoutMultiplier =
              NewTimeouts->ReadTotalTimeoutMultiplier;

          Extension->Timeouts.ReadTotalTimeoutConstant =
              NewTimeouts->ReadTotalTimeoutConstant;

          Extension->Timeouts.WriteTotalTimeoutMultiplier =
              NewTimeouts->WriteTotalTimeoutMultiplier;

          Extension->Timeouts.WriteTotalTimeoutConstant =
              NewTimeouts->WriteTotalTimeoutConstant;

          KeReleaseSpinLock( &Extension->ControlLock, OldIrql );

          break;
      }

      //******************************
      case IOCTL_SERIAL_GET_TIMEOUTS:
      {
         MyKdPrint(D_Ioctl,("[Get Timeouts]\n"))
         ExtTrace(Extension,D_Ioctl,"Get Timeouts");

          if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(SERIAL_TIMEOUTS))
          {
              Status = STATUS_BUFFER_TOO_SMALL;
              break;
          }

          KeAcquireSpinLock( &Extension->ControlLock, &OldIrql );

          *((PSERIAL_TIMEOUTS)Irp->AssociatedIrp.SystemBuffer) = Extension->Timeouts;
          Irp->IoStatus.Information = sizeof(SERIAL_TIMEOUTS);

          KeReleaseSpinLock( &Extension->ControlLock, OldIrql );

          break;
      }

      //**************************
      case IOCTL_SERIAL_SET_CHARS:
      {
         SERIAL_IOCTL_SYNC S;
         PSERIAL_CHARS NewChars =
             ((PSERIAL_CHARS)(Irp->AssociatedIrp.SystemBuffer));
         MyKdPrint(D_Ioctl,("[Set Xon/Xoff Chars]\n"))
         if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(SERIAL_CHARS))
         {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
         }

         ExtTrace3(Extension,D_Ioctl,"Set Chars Xon:%xH, Xoff:%xH Evt:%xH",
                  NewChars->XonChar,NewChars->XoffChar, NewChars->EventChar);

         // The only thing that can be wrong with the chars
         // is that the xon and xoff characters are the same.
#ifdef COMMENT_OUT
// comment out kpb, problem with hardware flow control, nt
// may connect and do this(Delrina WinFaxPro, SAPS modem pooling
// had trouble erroring out, but not on standard microsoft port.

         if (NewChars->XonChar == NewChars->XoffChar)
         {
             Status = STATUS_INVALID_PARAMETER;
             break;
         }
#endif
         // We acquire the control lock so that only
         // one request can GET or SET the characters
         // at a time.  The sets could be synchronized
         // by the interrupt spinlock, but that wouldn't
         // prevent multiple gets at the same time.
         S.Extension = Extension;
         S.Data = NewChars;

         KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);

         Extension->SpecialChars.EofChar = NewChars->EofChar;
         Extension->SpecialChars.ErrorChar = NewChars->ErrorChar;
         Extension->SpecialChars.BreakChar=NewChars->BreakChar;

         // Only set up byte in case we're already EventChar-ing it,
         // Actual programming of interrupt is done in wait on mask call.
         Extension->SpecialChars.EventChar=NewChars->EventChar;
         Extension->SpecialChars.XonChar=NewChars->XonChar;
         Extension->SpecialChars.XoffChar=NewChars->XoffChar;
#ifdef S_RK
         sSetRxCmpVal1(Extension->ChP,NewChars->EventChar);
         sSetTxXONChar(Extension->ChP,NewChars->XonChar);
         sSetTxXOFFChar(Extension->ChP,NewChars->XoffChar);
#else
         pSetEventChar(Extension->Port,NewChars->EventChar);
         pSetXONChar(Extension->Port,NewChars->XonChar);
         pSetXOFFChar(Extension->Port,NewChars->XoffChar);
#endif
         KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
         break;
      }

      //**************************
      case IOCTL_SERIAL_GET_CHARS:
      {
         MyKdPrint(D_Ioctl,("[Get Xon/Xoff Chars]\n"))
         ExtTrace(Extension,D_Ioctl,"Get Xon/Xoff Chars");
         if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(SERIAL_CHARS))
         {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
         }

         KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);

         // Copy the whole struct over to the buffer
         *((PSERIAL_CHARS)Irp->AssociatedIrp.SystemBuffer) =
                             Extension->SpecialChars;

         Irp->IoStatus.Information = sizeof(SERIAL_CHARS);
         KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
         break;
      }

        case IOCTL_SERIAL_SET_DTR:
        case IOCTL_SERIAL_CLR_DTR:
        {
         MyKdPrint(D_Ioctl,("[Set and Clr DTR]\n"))
            // We acquire the lock so that we can check whether
            // automatic dtr flow control is enabled.  If it is,
            // then return an error since the app is not allowed
            // to touch this if it is automatic.

            KeAcquireSpinLock(&Extension->ControlLock, &OldIrql);

            if ((Extension->HandFlow.ControlHandShake & SERIAL_DTR_MASK)
                == SERIAL_DTR_HANDSHAKE)
            {   // bogus
                //Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                //Status = STATUS_INVALID_PARAMETER;
            }
            else
            {
               if(IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                  IOCTL_SERIAL_SET_DTR )
               {
                  ExtTrace(Extension,D_Ioctl,"Set DTR");
#ifdef S_VS
                  pSetDTR(Extension->Port);
#else
                  sSetDTR(Extension->ChP);
#endif
                  Extension->DTRRTSStatus |= SERIAL_DTR_STATE;
               }
               else
               {
                  //must be IOCTL_SERIAL_CLR_DTR
                  ExtTrace(Extension,D_Ioctl,"Clr DTR");
#ifdef S_VS
                  pClrDTR(Extension->Port);
#else
                  sClrDTR(Extension->ChP);
#endif
                  Extension->DTRRTSStatus &= ~SERIAL_DTR_STATE;
               }
            }

            KeReleaseSpinLock(&Extension->ControlLock, OldIrql);

            break;
        }

      //************************
      case IOCTL_SERIAL_RESET_DEVICE:
         MyKdPrint(D_Ioctl,("[Reset Device]\n"));
         ExtTrace(Extension,D_Ioctl,"Reset Device");
         // Example driver also takes no action
         break;

      //************************
      case IOCTL_SERIAL_SET_RTS:
         MyKdPrint(D_Ioctl,("[Set RTS]\n"));
         ExtTrace(Extension,D_Ioctl,"Set RTS");
        // Make sure RTS isn't already used for handshake or toggle
        if( ( (Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
                                                 SERIAL_RTS_HANDSHAKE) ||
            ( (Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
                                                 SERIAL_TRANSMIT_TOGGLE)
          )
        {
           Status = STATUS_INVALID_PARAMETER;
           ExtTrace(Extension,D_Ioctl," not set,flow");
        }
        else
        {
          if (!(Extension->Option & OPTION_RS485_OVERRIDE))
          {
#ifdef S_VS
            pSetRTS(Extension->Port);
#else
            sSetRTS(Extension->ChP);
#endif
            Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
          }
          else
          {
            ExtTrace(Extension,D_Ioctl," not set,485");
          }
        }
        break;

      //************************
      case IOCTL_SERIAL_CLR_RTS:
         MyKdPrint(D_Ioctl,("[Clr RTS]\n"));
         ExtTrace(Extension,D_Ioctl,"Clr RTS");

        // Make sure RTS isn't already used for handshake or toggle
        if( ( (Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
                                                 SERIAL_RTS_HANDSHAKE) ||
            ( (Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
                                                 SERIAL_TRANSMIT_TOGGLE)
          )
        {
           Status = STATUS_INVALID_PARAMETER;
           ExtTrace(Extension,D_Ioctl," not clr,flow");
        }
        else
        {
           if (!(Extension->Option & OPTION_RS485_OVERRIDE))
           {
#ifdef S_VS
             pClrRTS(Extension->Port);
#else
             sClrRTS(Extension->ChP);
#endif
             Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
           }
           else
           {
             ExtTrace(Extension,D_Ioctl," not clr,485");
           }
        }

        break;

      //*************************
      case IOCTL_SERIAL_SET_XOFF:
         MyKdPrint(D_Ioctl,("[Set Xoff]\n"));
         ExtTrace(Extension,D_Ioctl,"Set Xoff");

#ifdef S_RK
         if (sIsTxSoftFlowCtlEnabled(Extension->ChP))
         {
           sDisTxSoftFlowCtl(Extension->ChP);  // turn off Tx software flow control
           sDisTransmit(Extension->ChP); // Stop the transmitter
           sEnRxIntCompare2(Extension->ChP,(unsigned char) Extension->SpecialChars.XonChar);
           Extension->TXHolding |= SERIAL_TX_XOFF;
           Extension->TXHolding |= ST_XOFF_FAKE;
         }
#else
        if (Extension->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT)
        {
           Extension->TXHolding |= SERIAL_TX_XOFF;
           pOverrideSetXoff(Extension->Port);
        }
#endif
         break;

      //************************
      case IOCTL_SERIAL_SET_XON:
         MyKdPrint(D_Ioctl,("[Set Xon]\n"));
         ExtTrace(Extension,D_Ioctl,"Set Xon");
#ifdef S_VS
         {
           pOverrideClearXoff(Extension->Port);
           Extension->TXHolding &= ~SERIAL_TX_XOFF;
         }
#else
         if (Extension->TXHolding & ST_XOFF_FAKE)
         {
           Extension->TXHolding &= ~SERIAL_TX_XOFF;
           Extension->TXHolding &= ~ST_XOFF_FAKE;
           if ((Extension->TXHolding & 
              (SERIAL_TX_DCD | SERIAL_TX_DSR | ST_XOFF_FAKE)) == 0)
             sEnTransmit(Extension->ChP); // Start up the transmitter
           sDisRxCompare2(Extension->ChP);
           sEnTxSoftFlowCtl(Extension->ChP);  // turn off Tx software flow control
         }

         // override an actual XOFF from remote
         sClrTxXOFF(Extension->ChP);

         // check for IOCTL_SERIAL_SET_XOFF state
         if(Extension->TXHolding & SERIAL_TX_XOFF)
         {
             // Make sure BREAK state hasn't disabled the Transmitter
             if(!(Extension->TXHolding & SERIAL_TX_BREAK))
                sEnTransmit(Extension->ChP);
             Extension->TXHolding &= ~SERIAL_TX_XOFF;
         }
#endif
         break;

      //******************************
      case IOCTL_SERIAL_SET_BREAK_ON:
      {

         ExtTrace(Extension,D_Ioctl,"Set Break on");
#ifdef S_VS
         pSetBreak(Extension->Port);
         Extension->TXHolding |= SERIAL_TX_BREAK;
#else
         IoAcquireCancelSpinLock(&OldIrql);
         if( !(Extension->TXHolding & SERIAL_TX_BREAK) )
         {
            // Stop the transmitter
            sDisTransmit(Extension->ChP);

            // Request break, Polling will check on Transmitter empty
            Extension->TXHolding |= SERIAL_TX_BREAK;

            // Make sure Transmitter is empty before slamming BREAK
            // Check the bit twice in case of time between buf and txshr load
            if( (sGetChanStatusLo(Extension->ChP) & TXSHRMT) &&
                (sGetChanStatusLo(Extension->ChP) & TXSHRMT) )
            {
              sSendBreak(Extension->ChP);
              Extension->DevStatus &= ~COM_REQUEST_BREAK;
            }
            else
              Extension->DevStatus |= COM_REQUEST_BREAK;
         }
         IoReleaseCancelSpinLock(OldIrql);
#endif
         break;
      }

      //******************************
      case IOCTL_SERIAL_SET_BREAK_OFF:
      {
         ExtTrace(Extension,D_Ioctl,"Set Break Off");

#ifdef S_VS
         if (Extension->TXHolding & SERIAL_TX_BREAK)
         {
            Extension->TXHolding &= ~SERIAL_TX_BREAK;
            pClrBreak(Extension->Port);
         }
#else
         IoAcquireCancelSpinLock(&OldIrql);
         if(Extension->TXHolding & SERIAL_TX_BREAK)
         {
            Extension->TXHolding &= ~SERIAL_TX_BREAK;

            sClrBreak(Extension->ChP);

            if(!(Extension->TXHolding & SERIAL_TX_XOFF))
            {
               sEnTransmit(Extension->ChP);
            }
         }

         if(Extension->DevStatus & COM_REQUEST_BREAK)
         {
            // If we hit this code, the requested BREAK will not have gone out
            Extension->DevStatus &= ~COM_REQUEST_BREAK;
         }

         IoReleaseCancelSpinLock(OldIrql);
#endif
         break;
      }

      //******************************
      case IOCTL_SERIAL_SET_QUEUE_SIZE:
      {
        LONG new_size;
        PUCHAR NewBuf;

        PSERIAL_QUEUE_SIZE Rs =
            ((PSERIAL_QUEUE_SIZE)(Irp->AssociatedIrp.SystemBuffer));

         MyKdPrint(D_Ioctl,("[Set Queue Size]\n"));

         if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(SERIAL_QUEUE_SIZE))
         {
           Status = STATUS_BUFFER_TOO_SMALL;
           break;
         }

         new_size = (LONG) Rs->InSize;
         ExtTrace1(Extension,D_Ioctl,"Set Queue Size, In:%d", new_size);
         if (new_size > 0x20000L)
            new_size = 0x20000L;  /// limit to about 128K

         // try to allocate buffer here if user requests larger buffer
              // don't resize if they want to shrink(why bother)
         if (new_size <= Extension->RxQ.QSize)
         {
            Status = STATUS_SUCCESS;
            break;
         }
  
         ++new_size;  // some circular queue wierdness

         IoAcquireCancelSpinLock(&OldIrql);

         NewBuf = our_locked_alloc(new_size+16, "exRX");  // add some slop
         if (NewBuf != NULL)
         {
           // Eprintf("Resized Buffer, new:%d, old:%d",new_size-1, Extension->RxQ.QSize-1);
           Extension->RxQ.QSize = new_size;
           our_free(Extension->RxQ.QBase, "exRX");
           Extension->RxQ.QBase= NewBuf;
           Extension->RxQ.QGet = 0;
           Extension->RxQ.QPut = 0;
           Status = STATUS_SUCCESS;
         }
         else
         {
            Status = STATUS_INVALID_PARAMETER; // not the greatest choise
         }
         IoReleaseCancelSpinLock(OldIrql);
 
         break;
      }

      //******************************
      case IOCTL_SERIAL_GET_WAIT_MASK:
         // This mask contains the various Events the WaitIrp is waiting
         // for from SetCommMask(), such as EV_BREAK, EV_CTS, EV_DSR,
         // EV_ERR, EV_RING, EV_RLSD, EV_RXCHAR, EV_RXFLAG, EV_TXEMPTY

         MyKdPrint(D_Ioctl,("[Get Wait Mask:%xH\n]",Extension->IsrWaitMask))

         if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(ULONG))
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }

         ExtTrace1(Extension,D_Ioctl,"Get Wait Mask:%xH",Extension->IsrWaitMask);

         Irp->IoStatus.Information = sizeof(ULONG);
         *((ULONG *)Irp->AssociatedIrp.SystemBuffer) = Extension->IsrWaitMask;
         break;

      //******************************
      case IOCTL_SERIAL_SET_WAIT_MASK:
      {
         ULONG NewMask;

         if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(ULONG) )
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }
         else
         {
             NewMask = *((ULONG *)Irp->AssociatedIrp.SystemBuffer);
             MyKdPrint(D_Ioctl,("set wait mask:%xH\n",NewMask))
             ExtTrace1(Extension,D_Ioctl,"Set Wait Mask:%xH",NewMask);
         }

         //------- Complete the old wait if there is one.
#ifdef NEW_WAIT_SYNC_LOCK
         SyncUp(Driver.InterruptObject,
                &Driver.TimerLock,
                SerialGrabWaitFromIsr,
                Extension);
#endif
         IoAcquireCancelSpinLock(&OldIrql);
         if (Extension->CurrentWaitIrp)
         {
           PIRP Irp;
           Extension->IrpMaskLocation = NULL;
           MyKdPrint(D_Ioctl,("[kill old wait]\n"))
           ExtTrace(Extension,D_Ioctl, " Kill Old Wait");
           *(ULONG *)Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer = 0;
           Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
           Extension->CurrentWaitIrp->IoStatus.Status = STATUS_SUCCESS;
           Irp = Extension->CurrentWaitIrp;
           IoSetCancelRoutine(Irp, NULL);
           Extension->CurrentWaitIrp = 0;
           IoReleaseCancelSpinLock(OldIrql);
           SerialCompleteRequest(Extension, Irp, IO_SERIAL_INCREMENT);
         }
         else
           IoReleaseCancelSpinLock(OldIrql);

         //----- retain any bits from when no WaitIrp present
         Extension->HistoryMask &= NewMask;

         //----- set the mask of interested events
         Extension->IsrWaitMask = NewMask;

         // move this from wait_on_mask call to here, kpb, 1-16-97
#ifdef S_RK
         if (Extension->IsrWaitMask & SERIAL_EV_RXFLAG)
         {
            sEnRxIntCompare1(Extension->ChP, 
                             Extension->SpecialChars.EventChar);
         }
         else
         {
            sDisRxCompare1(Extension->ChP);
         }
#endif
      }
      break;

      //******************************
      case IOCTL_SERIAL_WAIT_ON_MASK:
      {
         MyKdPrint(D_Ioctl,("[wait on mask]\n"))
         ExtTrace(Extension,D_Ioctl,"Wait On Mask");
         if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(ULONG))
         {
             ExtTrace(Extension,D_Ioctl,"Wait IRP, Bad Size");
             Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }

// put this in to fix an incompatibility with WaitOnMultipleObjects()
// 6-26-98 kpb
         if (Extension->CurrentWaitIrp)
         {
           MyKdPrint(D_Ioctl,("[Already pending]\n"))
           Status = STATUS_INVALID_PARAMETER;
           break;
         }

#ifdef NEW_WAIT_SYNC_LOCK
         SyncUp(Driver.InterruptObject,
                &Driver.TimerLock,
                SerialGrabWaitFromIsr,
                Extension);
#else
         Extension->WaitIsISRs = 0;
         Extension->IrpMaskLocation = &Extension->DummyIrpMaskLoc;
#endif
         IoAcquireCancelSpinLock(&OldIrql);

         //------- Complete the old wait if there is one.
         if (Extension->CurrentWaitIrp)
         {
           PIRP Irp;

           MyKdPrint(D_Ioctl,("[kill old wait]\n"))
           ExtTrace(Extension,D_Ioctl, " Kill Old Wait");
           *(ULONG *)Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer = 0;
           Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
           Extension->CurrentWaitIrp->IoStatus.Status = STATUS_SUCCESS;

           Irp = Extension->CurrentWaitIrp;
           IoSetCancelRoutine(Irp, NULL);
           Extension->CurrentWaitIrp = 0;
           IoReleaseCancelSpinLock(OldIrql);
           SerialCompleteRequest(Extension, Irp, IO_SERIAL_INCREMENT);
         }
         else
           IoReleaseCancelSpinLock(OldIrql);

         if (Extension->IsrWaitMask == 0)
         {
           ExtTrace(Extension,D_Ioctl," WaitMask==0");
           Status = STATUS_INVALID_PARAMETER;
         }
         else
         {
           IoAcquireCancelSpinLock(&OldIrql);

           if (Irp->Cancel)
           {
             IoReleaseCancelSpinLock(OldIrql);
             Irp->IoStatus.Status = STATUS_CANCELLED;
             SerialCompleteRequest(Extension, Irp, 0);
             Status = STATUS_CANCELLED;
           }
           else
           {
             Extension->CurrentWaitIrp = Irp;
             Irp->IoStatus.Status = STATUS_PENDING;
             IoMarkIrpPending(Irp);
             IoSetCancelRoutine(Extension->CurrentWaitIrp,  SerialCancelWait);
             IoReleaseCancelSpinLock(OldIrql);
             // give to ISR to process
             Extension->IrpMaskLocation = (ULONG *)
                Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer;
             Extension->WaitIsISRs = 1;  // give to ISR
             ExtTrace(Extension,D_Ioctl," PENDING.");
             return STATUS_PENDING;
          }
        }
      }
      break;

      case IOCTL_SERIAL_IMMEDIATE_CHAR:
      {
         UCHAR TxByte;
         KIRQL OldIrql;
         ExtTrace(Extension,D_Ioctl,"Immed. Char");

         if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(UCHAR) )
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }

         IoAcquireCancelSpinLock(&OldIrql);

         TxByte = *((UCHAR *)(Irp->AssociatedIrp.SystemBuffer));

         Extension->ISR_Flags |= TX_NOT_EMPTY;  // fix for EV_TXEMPTY 1-21-99
#ifdef S_RK
         if(!sWriteTxPrioByte(Extension->ChP,TxByte))
         {
             // No room for immediate character in Priority queue
             Status = STATUS_INVALID_PARAMETER;
         }
#else
          if ( (ULONG)(PortGetTxRoom(Extension->Port)) > 0)
          {
            // Send the byte
            q_put(&Extension->Port->QOut,
                        (PUCHAR) &TxByte,
                        1);
          }
#endif
         IoReleaseCancelSpinLock(OldIrql);
         break;
      }

      //**********************
      case IOCTL_SERIAL_PURGE:
      {
         ULONG Mask;

         MyKdPrint(D_Ioctl,("[Serial Purge]"));

         // Check to make sure that the mask only has 0 or the other
         // appropriate values. A null mask is equivalent to a mask of 0

         if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(ULONG) )
         {
             Status = STATUS_INVALID_PARAMETER;
             break;
         };
         
         if ( Irp->AssociatedIrp.SystemBuffer )
         {
           Mask = *((ULONG *)(Irp->AssociatedIrp.SystemBuffer));
           ExtTrace1(Extension,D_Ioctl,"Serial Purge:%xH",Mask);
         }
         else
         {
           Mask = 0;
         }

         if ((!Mask) || (Mask & (~(SERIAL_PURGE_TXABORT |
                                   SERIAL_PURGE_RXABORT |
                                   SERIAL_PURGE_TXCLEAR |
                                   SERIAL_PURGE_RXCLEAR )
                                ) ))
         {
             Status = STATUS_INVALID_PARAMETER;
             break;
         }

         return SerialStartOrQueue(Extension,
                                   Irp,
                                   &Extension->PurgeQueue,
                                   &Extension->CurrentPurgeIrp,
                                   SerialStartPurge );

      }

      //*****************************
      case IOCTL_SERIAL_GET_HANDFLOW:
      {
         MyKdPrint(D_Ioctl,("[Get Handflow]\n"))
         ExtTrace(Extension,D_Ioctl,"Get Handflow");
         if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(SERIAL_HANDFLOW))
         {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
         }

         Irp->IoStatus.Information = sizeof(SERIAL_HANDFLOW);

          *((PSERIAL_HANDFLOW)Irp->AssociatedIrp.SystemBuffer) =
              Extension->HandFlow;

         break;
      }

      //*****************************
      case IOCTL_SERIAL_SET_HANDFLOW:
      {
         ULONG trace_flags = 0;
         SERIAL_IOCTL_SYNC S;
         PSERIAL_HANDFLOW HandFlow = Irp->AssociatedIrp.SystemBuffer;

         MyKdPrint(D_Ioctl,("[Set HandFlow]\n"))
         ExtTrace(Extension,D_Ioctl,"Set HandFlow");

         // Make sure that the buffer is big enough
         if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(SERIAL_HANDFLOW))
         {
             ExtTrace(Extension,D_Ioctl,"ErZ!");
             Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }

         ///////////////////////////////////////////////////////
         // Make sure that no invalid parameters have been set

         // Check ControlHandShake first
         // For Rocket, we or in several that can't be supported

         if(HandFlow->ControlHandShake & (SERIAL_CONTROL_INVALID |
                                          SERIAL_DSR_SENSITIVITY
                                         ) )
         {
            
            { ExtTrace(Extension,D_Ioctl,"Err M!"); }

            if(HandFlow->ControlHandShake & SERIAL_DSR_SENSITIVITY)
               { ExtTrace(Extension,D_Ioctl,"No DSR Sen!"); }
            if(HandFlow->ControlHandShake & SERIAL_CONTROL_INVALID)
               { ExtTrace(Extension,D_Ioctl,"Invalid con!"); }
            // don't bail out - kpb(5-23-96)
            //Status = STATUS_INVALID_PARAMETER;
            //break;
         }

         if (HandFlow->FlowReplace & SERIAL_FLOW_INVALID)
         {
            ExtTrace(Extension,D_Ioctl,"ErA!");
            Status = STATUS_INVALID_PARAMETER;
            break;
         }

         // Make sure that the app hasn't set an invalid DTR mode.
         // Both options can't be set
         if((HandFlow->ControlHandShake & SERIAL_DTR_MASK) == SERIAL_DTR_MASK)
         {
             ExtTrace(Extension,D_Ioctl,"ErB!");
             Status = STATUS_INVALID_PARAMETER;
             break;
         }

         // Xon/Xoff limits unused for RocketPort (they're internal).
         HandFlow->XonLimit=0;
         HandFlow->XoffLimit=0;

         S.Extension = Extension;
         S.Data = HandFlow;

         KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);

         SerialSetHandFlow(Extension, HandFlow);

         KeReleaseSpinLock(&Extension->ControlLock,OldIrql);

         if ((Extension->HandFlow.ControlHandShake & SERIAL_RTS_MASK) == 
              SERIAL_RTS_HANDSHAKE)
           {ExtTrace(Extension,D_Ioctl,"RTS-Auto");}

         if (Extension->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE)
           {ExtTrace(Extension,D_Ioctl,"CTS-Auto");}

         if ((Extension->HandFlow.ControlHandShake & SERIAL_DTR_MASK) == 
              SERIAL_DTR_HANDSHAKE)
           {ExtTrace(Extension,D_Ioctl,"DTR-Auto");}

         if (Extension->HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE)
           {ExtTrace(Extension,D_Ioctl,"DSR-Auto");}

         if (Extension->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT)
           {ExtTrace(Extension,D_Ioctl,"Xon-Auto");}
      }
      break;
      //********************************
      case IOCTL_SERIAL_GET_MODEMSTATUS:
      {

         if ( IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(ULONG) )
         {   Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }

         Irp->IoStatus.Information = sizeof(ULONG);
         //Irp->IoStatus.Status = STATUS_SUCCESS;  bogus(set at end)
         Status = STATUS_SUCCESS;  // don't need, default
#ifdef S_RK
         // Update the modem inputs, fn() reads and converts the bits
         SetExtensionModemStatus(Extension);
#endif

         ExtTrace1(Extension,D_Ioctl,"Get ModemStatus:%xH",Extension->ModemStatus);

         *(PULONG)Irp->AssociatedIrp.SystemBuffer = Extension->ModemStatus;

         break;
      }

      //***************************
      case IOCTL_SERIAL_GET_DTRRTS:
      {
         MyKdPrint(D_Ioctl,("[Get DTR/RTS]\n"))
         // The Rocket cannot truly reflect RTS setting, best guess is returned
         if ( IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(ULONG) )
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }

         Irp->IoStatus.Information = sizeof(ULONG);
         //Irp->IoStatus.Status = STATUS_SUCCESS; bogus, set at end
         Status = STATUS_SUCCESS;  // don't need

         *(PULONG)Irp->AssociatedIrp.SystemBuffer = Extension->DTRRTSStatus;
         ExtTrace1(Extension,D_Ioctl,"Get DTR/RTS:%xH",Extension->DTRRTSStatus);

         break;
      }

      //*******************************
      case IOCTL_SERIAL_GET_COMMSTATUS:
      {
         PSERIAL_STATUS Stat;
         LONG RxCount;
         LONG TxCount;

         if ( IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(SERIAL_STATUS) )
         {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
         }

         Irp->IoStatus.Information = sizeof(SERIAL_STATUS);
         Stat =  Irp->AssociatedIrp.SystemBuffer;

         // EOF is always off, NT only supports binary mode
         // This in keeping with the example driver
         Stat->EofReceived = FALSE;

         // Reading error status clears out the errors.
         Stat->Errors = Extension->ErrorWord;
         Extension->ErrorWord = 0;

         // We only report here what can be read immediately by the next read
         // The RocketPort's hardware FIFO is not added into this count
         RxCount = q_count(&Extension->RxQ);

         Stat->AmountInInQueue = RxCount;

#ifdef NEW_Q
#ifdef S_VS
         {
         LONG tx_remote;
         tx_remote = PortGetTxCntRemote(Extension->Port);
         TxCount = PortGetTxCnt(Extension->Port);
         Stat->AmountInOutQueue = Extension->TotalCharsQueued + TxCount + tx_remote;
         ExtTrace4(Extension,D_Ioctl,"Get CommStat,In:%d IRPOut:%d BufOut:%d Remote:%d",
             RxCount, Extension->TotalCharsQueued, TxCount, tx_remote);
         }
#else
         TxCount = sGetTxCnt(Extension->ChP);
         if ((sGetChanStatusLo(Extension->ChP) & DRAINED) != DRAINED)
          ++TxCount;

         Stat->AmountInOutQueue = Extension->TotalCharsQueued + TxCount;
         ExtTrace3(Extension,D_Ioctl,"Get CommStat,In:%d IRPOut:%d HardOut:%d",
             RxCount, Extension->TotalCharsQueued, TxCount);

#endif
#else
   // older q-tracking code....
#ifdef S_VS
         TxCount = PortGetTxCnt(Extension->Port);
#else
         TxCount = sGetTxCnt(Extension->ChP);
#endif
         Stat->AmountInOutQueue = Extension->TotalCharsQueued + TxCount;

         ExtTrace3(Extension,D_Ioctl,"Get CommStat,In:%d SoftOut:%d HardOut:%d",
             RxCount, Extension->TotalCharsQueued, TxCount);
   // end older q-tracking code....
#endif
#ifdef S_RK
         // NOTE: this can fail due to the Priority buffer bug.
         // If the immediate byte ended up in the FIFO, this will
         // not accurately reflect the Immediate char state.
         if(sGetTxPriorityCnt(Extension->ChP))
            Stat->WaitForImmediate = TRUE;
         else
            Stat->WaitForImmediate = FALSE;
#else
         Stat->WaitForImmediate = FALSE;
#endif
         // Holding reasons are hidden in the part
         // Hardware takes care of all the details
         Stat->HoldReasons = 0;
         if (Extension->TXHolding)
         {
           if (Extension->TXHolding & SERIAL_TX_XOFF)
             Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_XON;
           if (Extension->TXHolding & SERIAL_TX_CTS)
             Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_CTS;
           if (Extension->TXHolding & SERIAL_TX_DSR)
             Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_DSR;
           if (Extension->TXHolding & SERIAL_TX_BREAK)
             Stat->HoldReasons |= SERIAL_TX_WAITING_ON_BREAK;
           if (Extension->TXHolding & SERIAL_TX_DCD)
             Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_DCD;
         }
         if (Extension->RXHolding & SERIAL_RX_DSR)
             Stat->HoldReasons |= SERIAL_RX_WAITING_FOR_DSR;
         if (Extension->RXHolding & SERIAL_RX_XOFF)
               Stat->HoldReasons |= SERIAL_TX_WAITING_XOFF_SENT;

         Status = STATUS_SUCCESS;
         Irp->IoStatus.Information = sizeof(SERIAL_STATUS);

         break;
      }

      //*******************************
      case IOCTL_SERIAL_GET_PROPERTIES:
      {
         PSERIAL_COMMPROP Properties;

         MyKdPrint(D_Ioctl,("[Get Properties]\n"))
         ExtTrace(Extension,D_Ioctl,"Get Properties");
         if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(SERIAL_COMMPROP))
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }

         Properties=(PSERIAL_COMMPROP)Irp->AssociatedIrp.SystemBuffer;
         RtlZeroMemory(Properties,sizeof(SERIAL_COMMPROP));
         Properties->PacketLength = sizeof(SERIAL_COMMPROP);
         Properties->PacketVersion = 2;
         Properties->ServiceMask = SERIAL_SP_SERIALCOMM;
         Properties->MaxTxQueue = 0;
         Properties->MaxRxQueue = 0;

         Properties->MaxBaud = SERIAL_BAUD_USER;

         Properties->SettableBaud = SERIAL_BAUD_075 |
                                    SERIAL_BAUD_110 |
                                    SERIAL_BAUD_134_5 |
                                    SERIAL_BAUD_150 |
                                    SERIAL_BAUD_300 |
                                    SERIAL_BAUD_600 |
                                    SERIAL_BAUD_1200 |
                                    SERIAL_BAUD_1800 |
                                    SERIAL_BAUD_2400 |
                                    SERIAL_BAUD_4800 |
                                    SERIAL_BAUD_7200 |
                                    SERIAL_BAUD_9600 |
                                    SERIAL_BAUD_14400 |
                                    SERIAL_BAUD_19200 |
                                    SERIAL_BAUD_38400 |
                                    SERIAL_BAUD_56K |
                                    SERIAL_BAUD_128K |
                                    SERIAL_BAUD_115200 |
                                    SERIAL_BAUD_57600 |
                                    SERIAL_BAUD_USER;

         Properties->ProvSubType = SERIAL_SP_RS232;
         Properties->ProvCapabilities = SERIAL_PCF_RTSCTS |
                                        SERIAL_PCF_CD     |
                                        SERIAL_PCF_PARITY_CHECK |
                                        SERIAL_PCF_XONXOFF |
                                        SERIAL_PCF_SETXCHAR |
                                        SERIAL_PCF_TOTALTIMEOUTS |
                                        SERIAL_PCF_INTTIMEOUTS;

         Properties->SettableParams = SERIAL_SP_PARITY |
                                      SERIAL_SP_BAUD |
                                      SERIAL_SP_DATABITS |
                                      SERIAL_SP_STOPBITS |
                                      SERIAL_SP_HANDSHAKING |
                                      SERIAL_SP_PARITY_CHECK |
                                      SERIAL_SP_CARRIER_DETECT;


         Properties->SettableData = SERIAL_DATABITS_7 |
                                    SERIAL_DATABITS_8;

         Properties->SettableStopParity = SERIAL_STOPBITS_10 |
                                          SERIAL_STOPBITS_20 |
                                          SERIAL_PARITY_NONE |
                                          SERIAL_PARITY_ODD  |
                                          SERIAL_PARITY_EVEN;

         Properties->CurrentTxQueue = 0; // as per MS

         // circular buffer req's -1
         Properties->CurrentRxQueue = Extension->RxQ.QSize -1;

         Irp->IoStatus.Information = sizeof(SERIAL_COMMPROP);
         //Irp->IoStatus.Status = STATUS_SUCCESS; bogus, set at end
         Status = STATUS_SUCCESS;  // don't need
         break;
      }

      //*****************************
      case IOCTL_SERIAL_XOFF_COUNTER:
      {
         PSERIAL_XOFF_COUNTER Xc = Irp->AssociatedIrp.SystemBuffer;

         MyKdPrint(D_Ioctl,("[Xoff Counter]\n"));
         ExtTrace(Extension,D_Ioctl,"Xoff Counter");

         if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(SERIAL_XOFF_COUNTER))
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }

         if (Xc->Counter <= 0)
         {   Status = STATUS_INVALID_PARAMETER;
             break;
         }

         // write the 13H(don't play the xoff-counter game)
         // which queues things up in the write queue.  We may
         // screw up the order of outgoing data if other writes
         // pended, but thats life, and this xoff-counter nonsense
         // sucks.  Its used in the msdos 16450 uart emuluation on
         // com1-com4.
#ifdef S_RK
         sWriteTxBlk( Extension->ChP, (PUCHAR) &Xc->XoffChar, 1);
#else
         q_put(&Extension->Port->QOut,(unsigned char *)&Xc->XoffChar,1);         
#endif
        Status = STATUS_SUCCESS;

        break;
      }

      //******************************
      case IOCTL_SERIAL_CONFIG_SIZE:
      {
        ExtTrace(Extension,D_Ioctl,"Config Size");
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(ULONG))
        {
          Status = STATUS_BUFFER_TOO_SMALL;
          break;
        }

        Irp->IoStatus.Information = sizeof(ULONG);
        Status = STATUS_SUCCESS;

        *(PULONG)Irp->AssociatedIrp.SystemBuffer = 0;
        break;
      }

      //******************************
      case IOCTL_SERIAL_GET_COMMCONFIG:
      {
         // this function is not defined or used in the sample driver.
         ExtTrace(Extension,D_Ioctl,"Get Config");
         Status = STATUS_INVALID_PARAMETER;
         break;
      }

      //******************************
      case IOCTL_SERIAL_SET_COMMCONFIG:
      {
         // this function is not defined or used in the sample driver.
         ExtTrace(Extension,D_Ioctl,"Set Config");
         Status = STATUS_INVALID_PARAMETER;
         break;
      }

      //******************************
      case IOCTL_SERIAL_LSRMST_INSERT:
      {
         PUCHAR escapeChar;

		 if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
			  sizeof (ULONG) )
		 {
			 Status = STATUS_INVALID_PARAMETER;
			 break;
		 }
		 else
		 {
             escapeChar = Irp->AssociatedIrp.SystemBuffer;
		 };

         ExtTrace1(Extension,D_Ioctl,"LSRMST Insert, Esc=%xH",
                                    (ULONG) *escapeChar);

         MyKdPrint(D_Ioctl,("[LSRMST Insert]\n"))
         // this "feature" allows setting a escape character, which when
         // non-zero will cause it to be used as an escape character for
         // changes in MSR/LSR registers.  If the Escape char is seen in
         // from the port, it is escaped also.  Oh what fun.

         // used in Virtual driver of microsofts.
         Extension->escapechar = *escapeChar;
#ifdef S_RK
         if (Extension->escapechar != 0)
           {sEnRxIntCompare2(Extension->ChP,Extension->escapechar);}
         else
           {sDisRxCompare2(Extension->ChP);}
#endif
         // Status = STATUS_INVALID_PARAMETER;
         break;
      }

#ifdef NT50
      //******************************
      case IOCTL_SERIAL_GET_MODEM_CONTROL:
      {
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(ULONG)) {
               Status = STATUS_BUFFER_TOO_SMALL;
               break;
        }
        Irp->IoStatus.Information = sizeof(ULONG);

        //#define SERIAL_DTR_STATE         ((ULONG)0x00000001)
        //#define SERIAL_RTS_STATE         ((ULONG)0x00000002)

        //#define SERIAL_IOC_MCR_DTR              ((ULONG)0x00000001)
        //#define SERIAL_IOC_MCR_RTS              ((ULONG)0x00000002)
        //#define SERIAL_IOC_MCR_OUT1             ((ULONG)0x00000004)
        //#define SERIAL_IOC_MCR_OUT2             ((ULONG)0x00000008)
        //#define SERIAL_IOC_MCR_LOOP             ((ULONG)0x00000010)

        *((ULONG *)Irp->AssociatedIrp.SystemBuffer) =
           (Extension->DTRRTSStatus & 3);
        ExtTrace1(Extension,D_Ioctl,"get MCR:=%xH",
                             *((ULONG *)Irp->AssociatedIrp.SystemBuffer) );
      }
      break;

      //******************************
      case IOCTL_SERIAL_SET_MODEM_CONTROL:
      {
        ULONG mcr;
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(ULONG)) {

            Status = STATUS_BUFFER_TOO_SMALL;
            break;

        }
        mcr = *((ULONG *)Irp->AssociatedIrp.SystemBuffer);

#ifdef S_VS
        pDisRTSFlowCtl(Extension->Port);
#else
        sDisRTSFlowCtl(Extension->ChP);
#endif

        if (mcr & SERIAL_RTS_STATE)
        {
#ifdef S_VS
            pSetRTS(Extension->Port);
#else
            sSetRTS(Extension->ChP);
#endif
          Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
        }
        else
        {
#ifdef S_VS
          pClrRTS(Extension->Port);
#else
          sClrRTS(Extension->ChP);
#endif
          Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
        }

        if (mcr & SERIAL_DTR_STATE)
        {
#ifdef S_VS
          pSetDTR(Extension->Port);
#else
          sSetDTR(Extension->ChP);
#endif
          Extension->DTRRTSStatus |= SERIAL_DTR_STATE;
        }
        else
        {
#ifdef S_VS
          pClrDTR(Extension->Port);
#else
          sClrDTR(Extension->ChP);
#endif
          Extension->DTRRTSStatus &= ~SERIAL_DTR_STATE;
        }

        ExtTrace1(Extension,D_Ioctl,"set MCR:=%xH", mcr);
      }
      break;

      //******************************
      case IOCTL_SERIAL_SET_FIFO_CONTROL:
      {
      }
      break;
#endif

      //******************************
      case IOCTL_RCKT_CLR_STATS:
      {
         Tracer *tr;
         PSERIAL_DEVICE_EXTENSION ComDevExt;
         // PortStats *Stats;

         MyKdPrint(D_Ioctl,("[Get Stats]\n"))
         if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(Tracer))
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             MyKdPrint(D_Ioctl,("[Buffer too small]\n"))
             break;
         }

         tr = (Tracer *)Irp->AssociatedIrp.SystemBuffer;
         MyKdPrint(D_Ioctl,("Com_port: %s\n",tr->port_name))
         ComDevExt = FindDevExt(tr->port_name);
         if (ComDevExt == NULL)
         {
            Status = STATUS_INVALID_PARAMETER;
            break;
         }
  
         ComDevExt->OurStats.TransmittedCount = 0;
         ComDevExt->OurStats.ReceivedCount = 0;
         ComDevExt->OurStats.ParityErrorCount = 0;
         ComDevExt->OurStats.FrameErrorCount = 0;
         ComDevExt->OurStats.SerialOverrunErrorCount = 0;
         ComDevExt->OurStats.BufferOverrunErrorCount = 0;

         tr->status = 0;
         Irp->IoStatus.Information = sizeof(Tracer);
         Status = STATUS_SUCCESS;

         break; 
      }

      //******************************
      case IOCTL_RCKT_SET_LOOPBACK_ON:
      {
         ExtTrace(Extension,D_Ioctl,"LoopBk On");
         MyKdPrint(D_Ioctl,("[Set LoopBack On]"))
#ifdef S_VS
         pEnLocalLoopback(Extension->Port);
#else
         sEnLocalLoopback(Extension->ChP);
#endif
      }
      break;

      //******************************
      case IOCTL_RCKT_SET_LOOPBACK_OFF:
      {
         ExtTrace(Extension,D_Ioctl,"LoopBk Off");
         MyKdPrint(D_Ioctl,("[Set LoopBack Off]"))
#ifdef S_VS
         pDisLocalLoopback(Extension->Port);
#else
         sDisLocalLoopback(Extension->ChP);
#endif
      }
      break;

      //******************************
      case IOCTL_RCKT_SET_TOGGLE_LOW:
      {
         ExtTrace(Extension,D_Ioctl,"Set 485 Low");
         Extension->Option &= ~OPTION_RS485_HIGH_ACTIVE;
         Extension->Option &= ~OPTION_RS485_SOFTWARE_TOGGLE;
         Extension->Option |= OPTION_RS485_OVERRIDE;
         // hardware reverse case
#ifdef S_VS
         pEnRTSToggleLow(Extension->Port);
#else
         sEnRTSToggle(Extension->ChP);
#endif
         Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
      }
      break;

      case IOCTL_RCKT_CLEAR_TOGGLE_LOW:
      {
         ExtTrace(Extension,D_Ioctl,"Clear 485 Low");
         Extension->Option &= ~OPTION_RS485_HIGH_ACTIVE;
         Extension->Option &= ~OPTION_RS485_SOFTWARE_TOGGLE;
         Extension->Option &= ~OPTION_RS485_OVERRIDE;
         // hardware reverse case
#ifdef S_VS
         pDisRTSToggle(Extension->Port);
         pSetRTS(Extension->Port);
#else
         sDisRTSToggle(Extension->ChP);
         sSetRTS(Extension->ChP);
#endif
         Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
      }
      break;

      //******************************
      case IOCTL_RCKT_GET_STATS:
      {
         Tracer *tr;
         PSERIAL_DEVICE_EXTENSION ComDevExt;
         PortStats *Stats;

         ExtTrace(Extension,D_Ioctl,"Get_Stats");
         MyKdPrint(D_Ioctl,("[Get Stats]\n"));
         if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(Tracer))
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             MyKdPrint(D_Ioctl,("[Buffer too small]\n"))
             break;
         }

         tr = (Tracer *)Irp->AssociatedIrp.SystemBuffer;
         MyKdPrint(D_Ioctl,("Com_port: %s\n",tr->port_name))
         ComDevExt = FindDevExt(tr->port_name);
         if (ComDevExt == NULL)
            {
            Status = STATUS_INVALID_PARAMETER;
            break;
            }
   
         Stats = (PortStats *)tr->data;
  
         if(ComDevExt->DeviceIsOpen)
           {
#ifdef S_VS
           Stats->transmitFifo = (LONG) (PortGetTxCnt(ComDevExt->Port));
           Stats->receiveFifo  = (LONG) (PortGetRxCnt(ComDevExt->Port));
#else
           Stats->transmitFifo = (LONG) sGetTxCnt(ComDevExt->ChP);
           Stats->receiveFifo = (LONG) sGetRxCnt(ComDevExt->ChP);
#endif
           }
         else
           {
           Stats->transmitFifo = 0;
           Stats->receiveFifo = 0;
           }

         Stats->transmitBytes  = ComDevExt->OurStats.TransmittedCount;
         Stats->receiveBytes  = ComDevExt->OurStats.ReceivedCount;
         Stats->parityErrors  = ComDevExt->OurStats.ParityErrorCount;
         Stats->framingErrors  = ComDevExt->OurStats.FrameErrorCount;
         Stats->overrunHardware = ComDevExt->OurStats.SerialOverrunErrorCount;
         Stats->overrunSoftware = ComDevExt->OurStats.BufferOverrunErrorCount;
         tr->status = 0;
   
         Irp->IoStatus.Information = sizeof(Tracer);
         Status = STATUS_SUCCESS;

         break;
      }
      //******************************
      case IOCTL_RCKT_ISR_CNT:
      {
         Tracer *tr;
         Global_Track *Gt;

         ExtTrace(Extension,D_Ioctl,"Isr_Cnt");
         MyKdPrint(D_Ioctl,("[Get Stats]\n"))
         if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(Tracer))
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             MyKdPrint(D_Ioctl,("[Buffer too small]\n"))
             break;
         }

         tr = (Tracer *)Irp->AssociatedIrp.SystemBuffer;
         tr->status = 0;
         Gt = (Global_Track *)tr->data;
         Gt->int_counter = Driver.PollCnt;
         Gt->WriteDpc_counter = Driver.WriteDpcCnt;
         Gt->Timer_counter = 0;
         Gt->Poll_counter = Driver.PollCnt;

         Irp->IoStatus.Information = sizeof(Tracer);
         Status = STATUS_SUCCESS;
      }
      break;
      //******************************
      case IOCTL_RCKT_CHECK:
      {
         Tracer *tr;

         ExtTrace(Extension,D_Ioctl,"Rckt_Chk");
         MyKdPrint(D_Ioctl,("[Check]\n"))
         if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(Tracer))
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             MyKdPrint(D_Ioctl,("[Buffer too small]\n"))
             break;
         }
         tr = (Tracer *)Irp->AssociatedIrp.SystemBuffer;
         MyKdPrint(D_Ioctl,("Com_port: %s\n",tr->port_name))
         tr->status = 0x5555;
         Irp->IoStatus.Information = sizeof(Tracer);
         Status = STATUS_SUCCESS;
      }  
      break;

      //****************************** monitor
      case IOCTL_RCKT_MONALL:
      {
        PSERIAL_DEVICE_EXTENSION extension;
        PSERIAL_DEVICE_EXTENSION board_ext;
        int Dev;
        // int total_size;
        PortMonBase *pmb;
        PortMonNames *pmn;
        PortMonStatus *pms;
        char *buf;
        MyKdPrint(D_Ioctl,("[MonAll..]"))

        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
			sizeof (PortMonBase) )
		{
			Status = STATUS_INVALID_PARAMETER;
            break;
		}
	    else
		{
		    pmb = (PortMonBase *)Irp->AssociatedIrp.SystemBuffer;
		};

        switch (pmb->struct_type)
        {
          case 9:  // old probe ioctl
            Status = STATUS_SUCCESS;  // don't need, default
          break;

          //*************** 
          case 10:  // name array [12] bytes
            pmn = (PortMonNames *) &pmb[1];  // ptr to after first struct
            if (pmb->struct_size != sizeof(PortMonNames))
            {
              MyKdPrint(D_Ioctl,("Err1L"))
              Status = STATUS_BUFFER_TOO_SMALL;
              break;
            }

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                (((NumPorts(NULL)+1) * sizeof(PortMonNames)) + sizeof(PortMonBase)) )
            {
               MyKdPrint(D_Ioctl,("Err4M, size:%d needed:%d\n",
                  IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                  (((NumPorts(NULL)+1) * sizeof(PortMonNames)) + sizeof(PortMonBase))
                  ))
               Status = STATUS_BUFFER_TOO_SMALL;
               break;
            }

            Dev=0;
            board_ext = Driver.board_ext;
            while (board_ext)
            {
              extension = board_ext->port_ext;
              while (extension)
              {
                strcpy(pmn->port_name, extension->SymbolicLinkName);
                ++pmn;

                ++Dev;
                extension = extension->port_ext;  // next in chain
              }  // while port extension
              board_ext = board_ext->board_ext;
            }  // while port extension
            pmb->num_structs = Dev;
            pmn->port_name[0] = 0;  // null terminate list.
            Irp->IoStatus.Information = (sizeof(PortMonBase) +
                               sizeof(PortMonNames) *(Dev+1));
            Status = STATUS_SUCCESS;
          break;  // case 10, names
 
          //*************** 
          case 11:  // status array
            pms = (PortMonStatus *) &pmb[1];  // ptr to after first struct
            if (pmb->struct_size != sizeof(PortMonStatus))
            {
              MyKdPrint(D_Ioctl,("Err1M"))
              Status = STATUS_BUFFER_TOO_SMALL;
              break;
            }
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                ((NumPorts(NULL) * sizeof(PortMonStatus)) + sizeof(PortMonBase)) )
            {
              MyKdPrint(D_Ioctl,("Err3M"))
              Status = STATUS_BUFFER_TOO_SMALL;
              break;
            }

            Dev=0;
            board_ext = Driver.board_ext;
            while (board_ext)
            {
              extension = board_ext->port_ext;
              while (extension)
              {
                pms->sent_bytes     = extension->OurStats.TransmittedCount; // total number of sent bytes
                pms->rec_bytes      = extension->OurStats.ReceivedCount;  // total number of receive bytes
 
                pms->sent_packets   = extension->sent_packets;   // number of write() packets
                pms->rec_packets    = extension->rec_packets;    // number of read() packets
 
                pms->overrun_errors = (USHORT)(extension->OurStats.SerialOverrunErrorCount +
                                    extension->OurStats.BufferOverrunErrorCount);
                pms->framing_errors = (USHORT)(extension->OurStats.FrameErrorCount);
                pms->parity_errors  = (USHORT)(extension->OurStats.ParityErrorCount);
#ifdef S_VS 
                if (extension->Port != NULL)
                  pms->status_flags =     // 20H, 10H, 8H
                  (extension->Port->msr_value & (CTS_ACT | DSR_ACT | CD_ACT)) |
                                      // 1H, 2H
                  (WORD)(extension->DTRRTSStatus & (SERIAL_DTR_STATE | SERIAL_RTS_STATE));
#else
                pms->status_flags =     // 20H, 10H, 8H
                  (extension->ModemCtl & (CTS_ACT | DSR_ACT | CD_ACT)) |
                                    // 1H, 2H
                  (WORD)(extension->DTRRTSStatus & (SERIAL_DTR_STATE | SERIAL_RTS_STATE));
#endif 
                if (extension->DeviceIsOpen)
                   pms->status_flags  |= 0x100;
 
#ifdef COMMENT_OUT
                if (sIsCTSFlowCtlEnabled(sIsComDevExt->ChP))
                  pms->status_flags  |= 0x1000;
                if (sIsRTSFlowCtlEnabled(sIsComDevExt->ChP)) 
                   pms->status_flags  |= 0x2000;
                if (sIsTxSoftFlowCtlEnabled(sIsComDevExt->ChP))
                   pms->status_flags  |= 0x4000;
#endif
                ++pms;
                ++Dev;
                extension = extension->port_ext;  // next in chain
              }  // while port extension
                board_ext = board_ext->board_ext;  // next in chain
            }  // while board extension

            Irp->IoStatus.Information = (sizeof(PortMonBase) +
                               sizeof(PortMonStatus)*Dev);
            Status = STATUS_SUCCESS;
          break;   // case 11(status)

#ifdef COMMENT_OUT
      //****************************** debug PCI
          case 12:  // debug in/out instructions
            {
            char *str;
            int i,j,k;
            // KIRQL newlevel, oldlevel;

            Status = STATUS_SUCCESS;

            buf = (char *) &pmb[1];  // ptr to after first struct
            //  Eprintf("dump %s",buf);
            str = buf;
            while ((*str != 0) && (*str != ' '))
              ++str;
            if (*str == ' ')
              ++str;
 
               // newlevel = 2;
               // KeRaiseIrql(newlevel, &oldlevel);
               // KeLowerIrql(oldlevel);
+
            if ((buf[0] == 'i') && (buf[1] == 'n'))
            {
              j = 0;
              i = gethint(str, &j);

              if (buf[2] == 'w')
              {
                str = (char *) i;
                k = READ_PORT_USHORT((PUSHORT) str);

                Sprintf(buf, "InW[%x] = %x\n",i, k);
              }
              else
              {
                str = (char *) i;
                k = READ_PORT_UCHAR((PUCHAR) str);
                // k = inp(i);
                Sprintf(buf, "InB[%x] = %x\n",i, k);
              }

            }
            else if ((buf[0] == 'o') && (buf[1] == 'u'))
            {
              j = 0;
              i = gethint(str, &j);
              k = gethint(&str[j], &j);
              str = (char *) i;
              buf[0] = 0;
              if (buf[3] == 'd')
              {
                //sOutDW(i, k);
                WRITE_PORT_ULONG((PULONG) str, (ULONG) k);
                Sprintf(buf, "OutDW[%x] = %x\n",i, k);
              }
              else if (buf[3] == 'w')
              {
                //sOutW(i, k);
                WRITE_PORT_USHORT((PUSHORT) str, (USHORT) k);
                Sprintf(buf, "OutW[%x] = %x\n",i, k);
              }
              else
              {
                WRITE_PORT_UCHAR((PUCHAR) str, (UCHAR) k);
                //sOutB(i, k);
                Sprintf(buf, "OutB[%x] = %x\n",i, k);
              }
              // Eprintf("Out[%x] = %x\n",i, k);
            }
            else
            {
              Status = STATUS_BUFFER_TOO_SMALL;  // return an error
              strcpy(buf, "Bad ioctl");
              Eprintf("bad io ioctl %s",buf);
            }

            Irp->IoStatus.Information = sizeof(PortMonBase) +
                               strlen(buf) + 1;
            }
          break;   // case 12(in/out)
#endif

          //*************** driver debug log
          case 13:  // driver debug log
          {
            char *str;
            int i;

            Status = STATUS_SUCCESS;

            // someone is actively running the debugger, so don't timeout
            if (Driver.DebugTimeOut > 0)  // used to timeout inactive debug sessions.
               Driver.DebugTimeOut = 100;  // about 600 second seconds timeout

            buf = (char *) &pmb[1];  // ptr to after first struct
            //  Eprintf("dump %s",buf);
            str = buf;

            //----- limit incoming line buffer size
            i = 0;
            while ((*str != 0) && (i < 160))
            {
              ++str;
              ++i;
            }
            *str = 0;

            str = buf;
            if (*str != 0)
              do_cmd_line(str);

            if (!q_empty(&Driver.DebugQ))
            {
              int q_cnt;
              q_cnt = q_count(&Driver.DebugQ);
              if (q_cnt > 1000)
                q_cnt = 1000;
              Irp->IoStatus.Information = sizeof(PortMonBase) + q_cnt;
              pmb->struct_size = (ULONG) q_cnt;
              buf = (char *) &pmb[1];  // ptr to after first struct
              q_get(&Driver.DebugQ, (BYTE *) &pmb[1], q_cnt);
            }
            else
            {
              pmb->struct_size = (ULONG) 0;
              Irp->IoStatus.Information = sizeof(PortMonBase);
            }
          }
          break;   // driver debug log

          //*************** driver option set
          case 14:
            {
            int stat;

            Status = STATUS_SUCCESS;
            buf = (char *) &pmb[1];  // ptr to after first struct
            MyKdPrint(D_Init, ("Ioctl Option:%s\n", buf))
            stat = SetOptionStr(buf);
            Sprintf(buf, "Option stat:%d\n",stat);

            if (stat != 0)
            {
              MyKdPrint(D_Init, (" Err:%d\n", stat))
            }
            Irp->IoStatus.Information = sizeof(PortMonBase) +
                               strlen(buf) + 1;
            }
          break;   // driver option set

#ifdef S_VS
          //*************** mac-address list
          case 15:
            {
              MyKdPrint(D_Ioctl,("start mac list\n"))
              Status = STATUS_SUCCESS;
              buf = (char *) &pmb[1];  // ptr to after first struct
              buf[0] = 0;

              MyKdPrint(D_Ioctl,("do find\n"))
              find_all_boxes(0);  // get list of all boxes out on networks
              find_all_boxes(1);  // do 2nd scan just to be sure

              memcpy(buf, Driver.BoxMacs, 8*Driver.NumBoxMacs);
            
              Irp->IoStatus.Information = sizeof(PortMonBase) +
                               8*Driver.NumBoxMacs;
              MyKdPrint(D_Ioctl,("end mac list\n"))
            }
          break;

          case 16: // advisor sheet: probe NIC status
            MyKdPrint(D_Ioctl,("start nic probe"))
            Irp->IoStatus.Information = 
              (ProbeNic((unsigned char *)&pmb[1],
                        (int)pmb->struct_size)) + sizeof(PortMonBase);
            Status = STATUS_SUCCESS;  // don't need, default
            MyKdPrint(D_Ioctl,("end nic probe"))
          break;

          case 17:  // advisor sheet: probe VS status
            MyKdPrint(D_Ioctl,("start vs probe"))
            Irp->IoStatus.Information = 
              (ProbeDevices((unsigned char *)&pmb[1],
                            (int)pmb->struct_size)) + sizeof(PortMonBase);
        
            MyKdPrint(D_Ioctl,("end vs probe"))
            Status = STATUS_SUCCESS;  // don't need, default
          break;
#endif
          default:
            Status = STATUS_BUFFER_TOO_SMALL;
          break;
        }  // switch
      }
      break;

      //******************************

      case IOCTL_RCKT_SET_MODEM_RESET:
      {
        char *ResetData;
        PSERIAL_DEVICE_EXTENSION ext;

        ExtTrace(Extension,D_Ioctl,"Set Modem Reset");
		if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
			sizeof (char *) )
		{
		   Status = STATUS_INVALID_PARAMETER;
		}
	    else
		{
		   ResetData = (char *)Irp->AssociatedIrp.SystemBuffer;
           MyKdPrint(D_Ioctl,("Set reset on Port: %s\n", ResetData))
           ext = find_ext_by_name(ResetData, NULL);
           if (ext)
             ModemReset(ext, 1);

           Irp->IoStatus.Information = 0;
           Status = STATUS_SUCCESS;
		};
        break;
      }

      case IOCTL_RCKT_CLEAR_MODEM_RESET:
      {
        char *ResetData;
        PSERIAL_DEVICE_EXTENSION ext;

        ExtTrace(Extension,D_Ioctl,"Clear Modem Reset");

		if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
			sizeof (char *) )
		{
           Status = STATUS_INVALID_PARAMETER;
		}
	    else
		{
           ResetData = (char *)Irp->AssociatedIrp.SystemBuffer;
           MyKdPrint(D_Ioctl,("Clear reset on Port: %s\n", ResetData))
           ext = find_ext_by_name(ResetData, NULL);
           if (ext)
             ModemReset(ext, 0);

           Irp->IoStatus.Information = 0;
           Status = STATUS_SUCCESS;
		};
        break;
      }

      case IOCTL_RCKT_SEND_MODEM_ROW:
      {
        char *ResetData;
        PSERIAL_DEVICE_EXTENSION ext;

        ExtTrace(Extension,D_Ioctl,"Send Modem ROW");
		if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
			sizeof (char *) )
		{
		   Status = STATUS_INVALID_PARAMETER;
		}
	    else
		{
		   ResetData = (char *)Irp->AssociatedIrp.SystemBuffer;
           MyKdPrint(D_Ioctl,("ROW write on Port: %s\n", ResetData))
           ext = find_ext_by_name(ResetData, NULL);
           if (ext)
             ModemWriteROW(ext, Driver.MdmCountryCode);

           Irp->IoStatus.Information = 0;
           Status = STATUS_SUCCESS;
		};
        break;
      }

#ifdef S_RK
      //******************************
      // These are the old versions of
      // the Reset/ROW ioctls and are
      // provided here only for
      // compatibility with RktReset

      case IOCTL_RCKT_SET_MODEM_RESET_OLD:
      {
        int *ResetData;
        int ChanNum;
        int DevNum;
        PSERIAL_DEVICE_EXTENSION ext;

        ExtTrace(Extension,D_Ioctl,"Set Modem Reset");
		if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
			sizeof (int *) )
		{
		   Status = STATUS_INVALID_PARAMETER;
		}
		else
		{
           ResetData = (int *)Irp->AssociatedIrp.SystemBuffer;
           ChanNum = (*ResetData) & 0xFFFF;
           DevNum = (*ResetData) >> 0x10;
           MyKdPrint(D_Ioctl,("Set reset on Dev: %x, Chan: %x\n", DevNum, ChanNum))
           ext = find_ext_by_index(DevNum, ChanNum);
           if (ext)
             sModemReset(ext->ChP, 1);

           Irp->IoStatus.Information = 0;
           Status = STATUS_SUCCESS;
		};

        break;
      }

      case IOCTL_RCKT_CLEAR_MODEM_RESET_OLD:
      {
        int *ResetData;
        int ChanNum;
        int DevNum;
        PSERIAL_DEVICE_EXTENSION ext;

        ExtTrace(Extension,D_Ioctl,"Clear Modem Reset");
		if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
			sizeof (int *) )
		{
		   Status = STATUS_INVALID_PARAMETER;
		}
	    else
		{
		   ResetData = (int *)Irp->AssociatedIrp.SystemBuffer;
           ChanNum = (*ResetData) & 0xFFFF;
           DevNum = (*ResetData) >> 0x10;
           MyKdPrint(D_Ioctl,("Clear reset on Dev: %x, Chan: %x\n", DevNum, ChanNum))
           ext = find_ext_by_index(DevNum, ChanNum);
           if (ext)
             sModemReset(ext->ChP, 0);

           Irp->IoStatus.Information = 0;
           Status = STATUS_SUCCESS;
		};

        break;
      }

      case IOCTL_RCKT_GET_RCKTMDM_INFO_OLD:
      {
        // to maintain compatibility with RktReset, only the first
        // four boards are reported and only the first eight ports
        // on each are allowed.
        RocketModemConfig *RMCfg;
        int BoardNum;
        int PortNum;
        int np;
        PSERIAL_DEVICE_EXTENSION ext_p;   // port extension
        PSERIAL_DEVICE_EXTENSION ext_b;   // board extension

        MyKdPrint(D_Ioctl, ("[Get RktMdm Cfg]\n"))
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(RocketModemConfig))
        {
          Status = STATUS_BUFFER_TOO_SMALL;
          MyKdPrint(D_Ioctl, ("[Buffer too small]\n"))
          break;
        }

        RMCfg = (RocketModemConfig *)Irp->AssociatedIrp.SystemBuffer;
        RMCfg->rm_country_code = Driver.MdmCountryCode;
        RMCfg->rm_settle_time = Driver.MdmSettleTime;
        ext_b = Driver.board_ext;
        BoardNum = 0;
        while ((ext_b) && (BoardNum < 4) )
        {
          if (ext_b->config->ModemDevice) {
            //np = ext_b->config->NumChan;  [kpb, 5-7-98]
            np = ext_b->config->NumPorts;
            if (np > 8)
              np = 8;   // force to 8 since structure only has room for 8
            RMCfg->rm_board_cfg[BoardNum].num_rktmdm_ports = np;
            PortNum = 0;
            ext_p = find_ext_by_index(BoardNum, PortNum);
            while ( (ext_p) && (PortNum < np) )
            {
              if (ext_p)
                strcpy(RMCfg->rm_board_cfg[BoardNum].port_names[PortNum],
                       ext_p->SymbolicLinkName);
              else
                strcpy(RMCfg->rm_board_cfg[BoardNum].port_names[PortNum], 0);
              PortNum++;
              ext_p = find_ext_by_index(BoardNum, PortNum);
            }
          }
          ext_b = ext_b->board_ext;
          BoardNum++;
        }
        Irp->IoStatus.Information = sizeof(RocketModemConfig);
        Status = STATUS_SUCCESS;
        break;
      }

      case IOCTL_RCKT_SEND_MODEM_ROW_OLD:
      {
        int *ResetData;
        int ChanNum;
        int DevNum;
        PSERIAL_DEVICE_EXTENSION ext;

        ExtTrace(Extension,D_Ioctl,"Send Modem ROW");
		if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
			sizeof (int *) )
		{
		   Status = STATUS_INVALID_PARAMETER;
		}
	    else
		{
           ResetData = (int *)Irp->AssociatedIrp.SystemBuffer;
           ChanNum = (*ResetData) & 0xFFFF;
           DevNum = (*ResetData) >> 0x10;
           MyKdPrint(D_Ioctl,("ROW write on Dev: %x, Chan: %x\n", DevNum, ChanNum))
           ext = find_ext_by_index(DevNum, ChanNum);
           if (ext)
             sModemWriteROW(ext->ChP, Driver.MdmCountryCode);

           Irp->IoStatus.Information = 0;
           Status = STATUS_SUCCESS;		    
		};

        break;
      }
#endif

      //******************************
      default:        // bad IOCTL request
      {
        MyKdPrint(D_Ioctl,("Err1O"))
        ExtTrace1(Extension,D_Ioctl," UnHandle IoCtl:%d",
                 IrpSp->Parameters.DeviceIoControl.IoControlCode);
        Status = STATUS_INVALID_PARAMETER;
        break;
      }
   }

   Irp->IoStatus.Status = Status;
   if (Status != STATUS_SUCCESS)
   {
     MyKdPrint(D_Ioctl, (" Bad Status:%xH on IOCTL:%xH",
           Status, IrpSp->Parameters.DeviceIoControl.IoControlCode));
     ExtTrace2(Extension, D_Ioctl, " Bad Status:%xH on IOCTL:%xH",
           Status, IrpSp->Parameters.DeviceIoControl.IoControlCode);
     switch (Status)
     { 
       case STATUS_BUFFER_TOO_SMALL:
         MyKdPrint(D_Ioctl,(" Err, Buf Too Small!"));
         ExtTrace(Extension,D_Ioctl," Err, Buf Too Small!");
       break;
       case STATUS_INVALID_PARAMETER:
         MyKdPrint(D_Ioctl,(" Err, Bad Parm!"));
         ExtTrace(Extension,D_Ioctl," Err, Bad Parm!");
       break;
       default:
       break;

     }
   }
   SerialCompleteRequest(Extension, Irp, 0);
   return Status;
}

/*--------------------------------------------------------------------------
 FindDevExt -
  Purpose:  To scan through my Dev objects and return a device object ext
  Return:  PSERIAL_DEVICE_EXTENSION 
|--------------------------------------------------------------------------*/
PSERIAL_DEVICE_EXTENSION FindDevExt(IN PCHAR PortName)
{
   PSERIAL_DEVICE_EXTENSION extension;
   PSERIAL_DEVICE_EXTENSION board_ext;
   int Dev;
   char *pn;
   char *dev_pn;
   int done;
   Dev =0;
   board_ext = Driver.board_ext;
   while (board_ext)
   {
     extension = board_ext->port_ext;
     while (extension)
     {
       pn = PortName;
       dev_pn = extension->SymbolicLinkName;
       done = 0;
       while ((*dev_pn != 0) && (*pn != 0) && (done == 0))
       {
         if (*dev_pn != *pn)
           done = 1;  // no match, try next
         ++dev_pn;
         ++pn;
       }
       if ((*dev_pn == 0) && (*pn == 0))
         return (extension);  // found it, return ext.

      ++Dev;
      extension = extension->port_ext;  // next in chain
    }  // while port extension
    board_ext = board_ext->board_ext;
  }  // while board extension

   return NULL;
}

/*--------------------------------------------------------------------------
 ProgramBaudRate -
  Purpose:   Configure channel for desired baud rate
  Return:    STATUS_SUCCESS: if baud rate was configured
             STATUS_INVALID_PARAMETER: if baud rate cannot be configured
|--------------------------------------------------------------------------*/
NTSTATUS
ProgramBaudRate(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN ULONG DesiredBaudRate
)
{
 ULONG InBaud = DesiredBaudRate;

   //---- handle baud mapping
   if (Extension->port_config->LockBaud != 0)
     DesiredBaudRate = Extension->port_config->LockBaud;

   MyKdPrint(D_Ioctl,("[DesiredBaud %d]",DesiredBaudRate))
   if (DesiredBaudRate == 56000) DesiredBaudRate = 57600;
   else if (DesiredBaudRate == 128000) DesiredBaudRate = 115200;
   else if (DesiredBaudRate == 256000) DesiredBaudRate = 230400;

#ifdef S_VS
   if(PortSetBaudRate(Extension->Port,DesiredBaudRate,FALSE,
           Extension->board_ext->config->ClkRate,
           Extension->board_ext->config->ClkPrescaler))
         return(STATUS_INVALID_PARAMETER);
#else
   if(sSetBaudRate(Extension->ChP,DesiredBaudRate,FALSE))
         return(STATUS_INVALID_PARAMETER);
#endif
   Extension->BaudRate = InBaud;

#ifdef S_VS
   PortSetBaudRate(Extension->Port,DesiredBaudRate, TRUE,
           Extension->board_ext->config->ClkRate,
           Extension->board_ext->config->ClkPrescaler);
#else
   sSetBaudRate(Extension->ChP,DesiredBaudRate,TRUE);
#endif

   return (STATUS_SUCCESS);
}

/*--------------------------------------------------------------------------
  ProgramLineControl
  Purpose:   Configure channels line control (data bits, stop bits, parity)
  Return:    STATUS_SUCCESS: if line control was programmed as desired
             STATUS_INVALID_PARAMETER: if line control setting was invalid
|--------------------------------------------------------------------------*/
NTSTATUS
ProgramLineControl(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PSERIAL_LINE_CONTROL Lc
)
{
   switch (Lc->WordLength)
   {
      case 7:
         ExtTrace(Extension,D_Ioctl, "7-bits");
#ifdef S_VS
         pSetData7(Extension->Port);
#else
         sSetData7(Extension->ChP);
         sSetRxMask(Extension->ChP,0x7f);
#endif
         Extension->LineCtl.WordLength = Lc->WordLength;
      break;

      case 8:
         ExtTrace(Extension,D_Ioctl, "8-bits");
#ifdef S_VS
         pSetData8(Extension->Port);
#else
         sSetData8(Extension->ChP);
         sSetRxMask(Extension->ChP,0xff);
#endif
         Extension->LineCtl.WordLength = Lc->WordLength;
      break;

      case 5:
         ExtTrace(Extension,D_Ioctl, "Err WL5");
         return(STATUS_INVALID_PARAMETER);
      case 6:
         ExtTrace(Extension,D_Ioctl, "Err WL6");
         return(STATUS_INVALID_PARAMETER);
      default:
         ExtTrace(Extension,D_Ioctl, "Err WL?");
         return(STATUS_INVALID_PARAMETER);
   }

   switch (Lc->Parity)
   {
      case NO_PARITY:
         ExtTrace(Extension,D_Ioctl, "No-Par.");
#ifdef S_VS
         pDisParity(Extension->Port);
#else
         sDisParity(Extension->ChP);
#endif
         Extension->LineCtl.Parity = Lc->Parity;
         break;

      case EVEN_PARITY:
         ExtTrace(Extension,D_Ioctl, "Ev-Par.");
#ifdef S_VS
         pSetEvenParity(Extension->Port);
#else
         sEnParity(Extension->ChP);
         sSetEvenParity(Extension->ChP);
#endif
         Extension->LineCtl.Parity = Lc->Parity;
         break;

      case ODD_PARITY:
         ExtTrace(Extension,D_Ioctl, "Odd-Par.");
#ifdef S_VS
         pSetOddParity(Extension->Port);
#else
         sEnParity(Extension->ChP);
         sSetOddParity(Extension->ChP);
#endif
         Extension->LineCtl.Parity = Lc->Parity;
         break;

      case MARK_PARITY:
         ExtTrace(Extension,D_Ioctl, "Err PM");
         return(STATUS_INVALID_PARAMETER);
      case SPACE_PARITY:
         ExtTrace(Extension,D_Ioctl, "Err PS");
         return(STATUS_INVALID_PARAMETER);
      default:
         ExtTrace(Extension,D_Ioctl, "Err P?");
         return(STATUS_INVALID_PARAMETER);
   } // end switch parity...

   switch (Lc->StopBits)
   {
      case STOP_BIT_1:
         ExtTrace(Extension,D_Ioctl, "1-StopB");
#ifdef S_VS
         pSetStop1(Extension->Port);
#else
         sSetStop1(Extension->ChP);
#endif
         Extension->LineCtl.StopBits = Lc->StopBits;
         break;

      case STOP_BITS_1_5:
         ExtTrace(Extension,D_Ioctl, "Err S1.5");
         return(STATUS_INVALID_PARAMETER);

      case STOP_BITS_2:
         if (Extension->port_config->Map2StopsTo1)
         {
           ExtTrace(Extension,D_Ioctl, "2to1-StopB");
#ifdef S_VS
           pSetStop1(Extension->Port);
#else
           sSetStop1(Extension->ChP);
#endif
         }
         else
         {
           ExtTrace(Extension,D_Ioctl, "2-StopB");
#ifdef S_VS
           pSetStop2(Extension->Port);
#else
           sSetStop2(Extension->ChP);
#endif
         }
         Extension->LineCtl.StopBits = Lc->StopBits;
         break;
   }
   return (STATUS_SUCCESS);
}

/*--------------------------------------------------------------------
 SerialSetHandFlow -
Note: This is somewhat redundant to ForceExtensionSettings() in openclos.c.
|-------------------------------------------------------------------*/
void SerialSetHandFlow(PSERIAL_DEVICE_EXTENSION Extension,
                              SERIAL_HANDFLOW *HandFlow)
{
         //////////////////////////////////////////////
         // All invalid parameters have been dealt with.
         // Now, program the settings.

         //////////////
         // DTR control

         if ((Extension->HandFlow.ControlHandShake & SERIAL_DTR_MASK) !=
             (HandFlow->ControlHandShake & SERIAL_DTR_MASK))
         {
            Extension->RXHolding &= ~SERIAL_RX_DSR;
            if (  (HandFlow->ControlHandShake & SERIAL_DTR_MASK) ==
                    SERIAL_DTR_CONTROL )
            {
#ifdef S_VS
               pSetDTR(Extension->Port);
#else
               sSetDTR(Extension->ChP);
#endif
               Extension->DTRRTSStatus |= SERIAL_DTR_STATE;
            }
            else if (  (HandFlow->ControlHandShake & SERIAL_DTR_MASK) ==
                    SERIAL_DTR_HANDSHAKE )
            {
#ifdef S_VS
               pEnDTRFlowCtl(Extension->Port);
               Extension->DTRRTSStatus |= SERIAL_DTR_STATE;
#else
               if(  (sGetRxCnt(Extension->ChP) >= RX_HIWATER) ||
                    (!(Extension->DevStatus & COM_RXFLOW_ON))
                 )
               {
                  // drop DTR
                  Extension->DevStatus &= ~COM_RXFLOW_ON;
                  sClrDTR(Extension->ChP);
                  Extension->DTRRTSStatus &= ~SERIAL_DTR_STATE;
                  Extension->RXHolding |= SERIAL_RX_DSR;
               }
               else
               {
                  // DTR should be on
                  sSetDTR(Extension->ChP);
                  Extension->DTRRTSStatus |= SERIAL_DTR_STATE;
               }
#endif
            }
            else
            {
#ifdef S_VS
               pClrDTR(Extension->Port);
#else
               sClrDTR(Extension->ChP);
#endif
               Extension->DTRRTSStatus &= ~SERIAL_DTR_STATE;
            }
         }

         //////////////
         // RTS control

         if ((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) !=
             (HandFlow->FlowReplace & SERIAL_RTS_MASK))
         {

            Extension->Option &= ~OPTION_RS485_SOFTWARE_TOGGLE;
#ifdef S_VS
            pDisRTSFlowCtl(Extension->Port);
#else
            sDisRTSFlowCtl(Extension->ChP);  // add V2.8.001(2-19-96)
#endif
            switch(HandFlow->FlowReplace & SERIAL_RTS_MASK)
            {
               case SERIAL_RTS_CONTROL: // RTS Should be asserted while open
#ifdef S_VS
                  pSetRTS(Extension->Port);
#else
                  sSetRTS(Extension->ChP);
#endif
                  Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
                  break;
               case SERIAL_RTS_HANDSHAKE: // RTS hardware input flow control
#ifdef S_VS
                  pEnRTSFlowCtl(Extension->Port);
#else
                  sEnRTSFlowCtl(Extension->ChP);
#endif
                  Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
                  break;
               case SERIAL_TRANSMIT_TOGGLE: // RTS transmit toggle enabled

                  if (Extension->Option & OPTION_RS485_HIGH_ACTIVE)
                  {  // normal case, emulate standard operation
                    Extension->Option |= OPTION_RS485_SOFTWARE_TOGGLE;
                    Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
#ifdef S_VS
                    pEnRTSToggleHigh(Extension->Port);
#else
                    sClrRTS(Extension->ChP);
#endif
                  }
                  else 
                  {  // hardware reverse case
#ifdef S_VS
                    pEnRTSToggleLow(Extension->Port);
#else
                    sEnRTSToggle(Extension->ChP);
#endif
                    Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
                  }
                  break;
               default:
#ifdef S_VS
                  pClrRTS(Extension->Port);
#else
                  sClrRTS(Extension->ChP);
#endif
                  Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
                  break;
            }
         }

         if (Extension->Option & OPTION_RS485_OVERRIDE)  // 485 override
         {
           if (Extension->Option & OPTION_RS485_HIGH_ACTIVE)
           {  // normal case, emulate standard operation
             Extension->Option |= OPTION_RS485_SOFTWARE_TOGGLE;
             Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
#ifdef S_VS
             pEnRTSToggleHigh(Extension->Port);
#else
             sClrRTS(Extension->ChP);
#endif
           }
           else 
           {  // hardware reverse case
#ifdef S_VS
             pEnRTSToggleLow(Extension->Port);
#else
             sEnRTSToggle(Extension->ChP);
#endif
             Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
           }
         }

         ///////////////////////////////
         // Software output flow control

         if ((Extension->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT) !=
             (HandFlow->FlowReplace & SERIAL_AUTO_TRANSMIT))
         {
            if (HandFlow->FlowReplace & SERIAL_AUTO_TRANSMIT)
            {
#ifdef S_VS
               pEnTxSoftFlowCtl(Extension->Port);
#else
               sEnTxSoftFlowCtl(Extension->ChP);
#endif
            }
            else
            {
#ifdef S_VS
              pDisTxSoftFlowCtl(Extension->Port);
#else
              if (Extension->TXHolding & ST_XOFF_FAKE)
              {
                Extension->TXHolding &= ~ST_XOFF_FAKE;
                if ((Extension->TXHolding & 
                  (SERIAL_TX_DCD | SERIAL_TX_DSR | ST_XOFF_FAKE)) == 0)
                   sEnTransmit(Extension->ChP); // Start up the transmitter
                sDisRxCompare2(Extension->ChP);
              }
              sDisTxSoftFlowCtl(Extension->ChP);
              sClrTxXOFF(Extension->ChP);
#endif
              Extension->TXHolding &= ~SERIAL_TX_XOFF;
            }
         }

         ///////////////////////////////////////////////////////////////
         // SERIAL_AUTO_RECEIVE checked only because it may be necessary
         // to send an XON if we were using s/w input flow control

         // Did the setting change?
         if ((Extension->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) !=
             (HandFlow->FlowReplace & SERIAL_AUTO_RECEIVE))
         {
#ifdef S_VS
            if (HandFlow->FlowReplace & SERIAL_AUTO_RECEIVE)
            {
              pEnRxSoftFlowCtl(Extension->Port);
            }
            else
            {
              pDisRxSoftFlowCtl(Extension->Port);
            }
#endif
            // Are we turning AUTO_REC.. off?
            if(!(HandFlow->FlowReplace & SERIAL_AUTO_RECEIVE))
            {
               // Is the remote flowed off?
               if(!(Extension->DevStatus & COM_RXFLOW_ON))
               {
                  // send XON
                  Extension->DevStatus |= COM_RXFLOW_ON;
#ifdef S_RK
                  sWriteTxPrioByte(Extension->ChP,
                                    Extension->SpecialChars.XonChar);
#endif
               }
            }
         }

         /////////////////////////////////////////////////////////
         // No need to program the Rocket for following:
         // SERIAL_BREAK_CHAR
         // Replace Break error (NULL) with SpecialChars.BreakChar
         // SERIAL_ERROR_CHAR
         // Replace Parity and Framing with SpecialChars.ErrorChar

         ///////////////////////////////////
         // CTS hardware output flow control

         if ((Extension->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE) !=
             (HandFlow->ControlHandShake & SERIAL_CTS_HANDSHAKE))
         {
            if (HandFlow->ControlHandShake & SERIAL_CTS_HANDSHAKE)
            {
#ifdef S_VS
               pEnCTSFlowCtl(Extension->Port);
#else
               sEnCTSFlowCtl(Extension->ChP);
#endif
               if (!(Extension->ModemStatus & SERIAL_CTS_STATE))
                  Extension->TXHolding |= SERIAL_TX_CTS;    // clear holding
            }
            else
            {
#ifdef S_VS
               pDisCTSFlowCtl(Extension->Port);
#else
               sDisCTSFlowCtl(Extension->ChP);
#endif
               Extension->TXHolding &= ~SERIAL_TX_CTS;    // clear holding
            }
         }

         ///////////////////////////////////
         // DSR hardware output flow control
#ifdef S_VS
         if ((Extension->HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE) !=
             (HandFlow->ControlHandShake & SERIAL_DSR_HANDSHAKE))
         {
            if (HandFlow->ControlHandShake & SERIAL_DSR_HANDSHAKE)
            {
              pEnDSRFlowCtl(Extension->Port);
              if (!(Extension->ModemStatus & SERIAL_DSR_STATE))
                 Extension->TXHolding |= SERIAL_TX_DSR;
            }
            else
            {
              pDisDSRFlowCtl(Extension->Port);
              Extension->TXHolding &= ~SERIAL_TX_DSR;
            }
         }
#endif

#ifdef S_VS
         ///////////////////////////////////
         // DCD hardware output flow control

         if ((Extension->HandFlow.ControlHandShake & SERIAL_DCD_HANDSHAKE) !=
             (HandFlow->ControlHandShake & SERIAL_DCD_HANDSHAKE))
         {
            if (HandFlow->ControlHandShake & SERIAL_DCD_HANDSHAKE)
            {
              pEnCDFlowCtl(Extension->Port);
              if (!(Extension->ModemStatus & SERIAL_DCD_STATE))
                 Extension->TXHolding |= SERIAL_TX_DCD;
            }
            else
            {
              pDisCDFlowCtl(Extension->Port);
              Extension->TXHolding &= ~SERIAL_TX_DCD;
            }
         }
#endif

         /////////////////
         // Null stripping

         if (HandFlow->FlowReplace & SERIAL_NULL_STRIPPING)
         {
#ifdef S_VS
            pEnNullStrip(Extension->Port);
#else
            sEnRxIgnore0(Extension->ChP,0);
#endif
         }
         else
         {
#ifdef S_VS
            pDisNullStrip(Extension->Port);
#else
            sDisRxCompare0(Extension->ChP);
#endif
         }

         Extension->HandFlow.FlowReplace = HandFlow->FlowReplace;
         Extension->HandFlow.ControlHandShake = HandFlow->ControlHandShake;

#ifdef S_RK
         // update this because it handles flow-control and holding update
         SetExtensionModemStatus(Extension);
#endif
}

#ifdef NT50
/*--------------------------------------------------------------------
 SerialInternalIoControl -
|-------------------------------------------------------------------*/
NTSTATUS
SerialInternalIoControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    KIRQL OldIrql;
    BOOLEAN acceptingIRPs;

    acceptingIRPs = SerialIRPPrologue(Extension);

    if (acceptingIRPs == FALSE) {
       MyKdPrint(D_Ioctl,("Ioctl:no irps aceepted\n"))
       Irp->IoStatus.Information = 0;
       Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
       SerialCompleteRequest(Extension, Irp, IO_NO_INCREMENT);
       return STATUS_NO_SUCH_DEVICE;
    }

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0L;

    MyKdPrint(D_Ioctl,("SerialIntIoControl: %x\n",
                          IrpSp->Parameters.DeviceIoControl.IoControlCode))
    // Make sure we aren't aborting due to error (ERROR_ABORT)

    if (Extension->ErrorWord)
    {
      if (Extension->DeviceType == DEV_PORT)
      {
        if (SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS)
        {
           {ExtTrace(Extension,D_Ioctl,"ErrSet!");}
           return STATUS_CANCELLED;
        }
      }
    }

    if (Extension->DeviceType == DEV_BOARD)
    {
       ExtTrace2 (Extension, D_Ioctl, " Bad Status:%xH on IIOCTL:%xH",
                  Status, IrpSp->Parameters.DeviceIoControl.IoControlCode);
       Status = STATUS_INVALID_DEVICE_REQUEST;
       SerialCompleteRequest (Extension, Irp, 0);
       return Status;
    };

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode)
    {
#if 0
    case IOCTL_SERIAL_INTERNAL_DO_WAIT_WAKE:
       // Send a wait-wake IRP
       Status = SerialSendWaitWake(Extension);
       break;

    case IOCTL_SERIAL_INTERNAL_CANCEL_WAIT_WAKE:
       if (Extension->PendingWakeIrp != NULL) {
          IoCancelIrp(Extension->PendingWakeIrp);
       }
       break;
#endif

      case IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS:
      case IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS:
      {
        SERIAL_BASIC_SETTINGS basic;
        PSERIAL_BASIC_SETTINGS pBasic;
        //SHORT AppropriateDivisor;
        //SERIAL_IOCTL_SYNC S;

        if (IrpSp->Parameters.DeviceIoControl.IoControlCode ==
            IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS)
        {

            MyKdPrint(D_Ioctl,("[Set Internal Settings]\n"))
            ExtTrace(Extension,D_Ioctl,"Set Int Settings");

            // Check the buffer size
            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIAL_BASIC_SETTINGS))
            {
               Status = STATUS_BUFFER_TOO_SMALL;
               break;
	    }

            //
            // Everything is 0 -- timeouts and flow control.  If
            // We add additional features, this zero memory method
            // may not work.
            //

            RtlZeroMemory(&basic, sizeof(SERIAL_BASIC_SETTINGS));

            Irp->IoStatus.Information = sizeof(SERIAL_BASIC_SETTINGS);
            pBasic = (PSERIAL_BASIC_SETTINGS)Irp->AssociatedIrp.SystemBuffer;

            //
            // Save off the old settings
            //

            RtlCopyMemory(&pBasic->Timeouts, &Extension->Timeouts,
                          sizeof(SERIAL_TIMEOUTS));

            RtlCopyMemory(&pBasic->HandFlow, &Extension->HandFlow,
                          sizeof(SERIAL_HANDFLOW));

            //
            // Point to our new settings
            //

            pBasic = &basic;
        }
        else //restoring settings
        { 
            MyKdPrint(D_Ioctl,("[Restore Internal Settings]\n"))
            ExtTrace(Extension,D_Ioctl,"Reset Int Settings");

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength
                < sizeof(SERIAL_BASIC_SETTINGS))
            {
               Status = STATUS_BUFFER_TOO_SMALL;
               break;
	    }

            pBasic = (PSERIAL_BASIC_SETTINGS)Irp->AssociatedIrp.SystemBuffer;
	}

        KeAcquireSpinLock(&Extension->ControlLock, &OldIrql);

        //
        // Set the timeouts
        //

        RtlCopyMemory(&Extension->Timeouts, &pBasic->Timeouts,
                      sizeof(SERIAL_TIMEOUTS));

        //
        // Set flowcontrol
        //
       
        //S.Extension = Extension;
        //S.Data = &pBasic->HandFlow;
        SerialSetHandFlow(Extension, &pBasic->HandFlow);
        //KeSynchronizeExecution(Extension->Interrupt, SerialSetHandFlow, &S);

        KeReleaseSpinLock(&Extension->ControlLock, OldIrql);
      }
      break;

      default:
        Status = STATUS_INVALID_PARAMETER;
      break;
   }

   Irp->IoStatus.Status = Status;
   if (Status != STATUS_SUCCESS)
   {
     ExtTrace2(Extension, D_Ioctl, " Bad Status:%xH on IIOCTL:%xH",
           Status, IrpSp->Parameters.DeviceIoControl.IoControlCode);
   }
   SerialCompleteRequest(Extension, Irp, 0);
   return Status;
}
#endif

#ifdef S_VS
#define  RESET_STATS    1

/*--------------------------------------------------------------------
 find_ext_mac_match 
|-------------------------------------------------------------------*/
static PSERIAL_DEVICE_EXTENSION find_ext_mac_match(unsigned char *mac_addr)
{
  PSERIAL_DEVICE_EXTENSION ext;
  ext = Driver.board_ext;
  while (ext != NULL)
  {
    if (mac_match(mac_addr, ext->hd->dest_addr))
    {
      //MyKdPrint(D_Ioctl,("Found ext:%x\n", ext))
      return ext;
    }
    ext = ext->board_ext; // next one
  }
  return NULL;
}

/*--------------------------------------------------------------------
 ProbeNic - determine status associated nic card.
|-------------------------------------------------------------------*/
static int ProbeNic(unsigned char *pPtr, int availableLength)
{
 int nic_index;
 int stat;
 PROBE_NIC_STRUCT *pn;
 Nic *nic;
 int flag;

  pn = (PROBE_NIC_STRUCT *) pPtr;

  nic_index = (int) pPtr[0];  // they passed in an index to which nic card
  flag = (int) pPtr[1];  // they passed in a flag too

  stat = 0;
  if (nic_index >= VS1000_MAX_NICS)
  {
    MyKdPrint(D_Error,("Err PD1F\n"))
    stat = 1;  // err
  }

  if (Driver.nics == NULL)
  {
    MyKdPrint(D_Error,("Err PD1G\n"))
    stat = 2;  // err
  }

  if (Driver.nics[nic_index].NICHandle == NULL)
  {
    MyKdPrint(D_Error,("Err PD1H\n"))
    stat = 3;  // err
  }
  if (stat != 0)
  {
    pn->struct_size = 0;
    return sizeof(PROBE_NIC_STRUCT);
  }
  pn->struct_size = sizeof(PROBE_NIC_STRUCT);

  nic = &Driver.nics[nic_index];

#if 0
  if (flag & RESET_STATS) {
    nic->pkt_sent      = 0;
    nic->pkt_rcvd_ours = 0;
    nic->pkt_rcvd_not_ours  = 0;
  }
#endif

  // copy over the data
  memcpy(pn->NicName, nic->NicName, 60);
  pn->NicName[59] = 0;  // ensure null terminated
  memcpy(pn->address, nic->address, 6);
  pn->Open = nic->Open;
  pn->pkt_sent = nic->pkt_sent;
  pn->pkt_rcvd_ours = nic->pkt_rcvd_ours;
  pn->pkt_rcvd_not_ours = nic->pkt_rcvd_not_ours;

  return sizeof(PROBE_NIC_STRUCT);
}

/*--------------------------------------------------------------------
 ProbeDevices - determine status associated with the hex MAC address at pPtr; 
  find associated Comtrol devices...
|-------------------------------------------------------------------*/
static int ProbeDevices(unsigned char *pPtr, int availableLength)
{
  Nic     *nic;
  PortMan *pm;
  Hdlc    *hd;
  unsigned char mac_address[6];
  int    flag;
  int stat,i;
  PSERIAL_DEVICE_EXTENSION ext;
  PROBE_DEVICE_STRUCT *pr = (PROBE_DEVICE_STRUCT *) pPtr;

  memcpy(mac_address,pPtr,sizeof(mac_address));
  flag = pPtr[sizeof(mac_address)];

  // find the active device with the matching address
  ext = find_ext_mac_match(mac_address);

  stat = 0;
  if (ext == NULL)
  {
    MyKdPrint(D_Error,("No found mac:%x %x %x %x %x %x\n",
              mac_address[0],mac_address[1],mac_address[2],
              mac_address[3],mac_address[4],mac_address[5]))
    stat = 1;
  }

  if (ext != NULL)
  {
    pm = ext->pm;
    hd = ext->hd;
    if ((pm == NULL) || (hd == NULL))
    {
      MyKdPrint(D_Error,("No pm or hd\n"))
      stat = 2;
    }
  }

  if (stat != 0)
  {
    pr->struct_size = 0;
    MyKdPrint(D_Error,("ProbeErr1\n"))
    return sizeof(PROBE_DEVICE_STRUCT);
  }

  pr->struct_size = sizeof(PROBE_DEVICE_STRUCT);
#if 0
  if (flag & RESET_STATS) {
      pm->good_loads    = 0;
      pm->total_loads  = 0;
      hd->iframes_sent  = 0;
      hd->ctlframes_sent = 0;
      hd->rawframes_sent = 0;
      hd->iframes_resent  = 0;
      hd->frames_rcvd    = 0;
      hd->iframes_outofseq  = 0;
  }
#endif

  // give back a nic_index to use as a handle
  pr->nic_index = 0;  // default
  for (i=0; i<VS1000_MAX_NICS; i++)
  {
    if ((hd->nic == &Driver.nics[i]) && (hd->nic != NULL))
      pr->nic_index = i;
  }
  pr->num_ports = pm->num_ports;
  pr->total_loads = pm->total_loads;
  pr->good_loads = pm->good_loads;
  pr->backup_server = pm->backup_server;
  memcpy(pr->dest_addr, hd->dest_addr, 6);
  pr->state = pm->state;
  pr->iframes_sent = hd->iframes_sent;
  pr->rawframes_sent = hd->rawframes_sent;
  pr->ctlframes_sent = hd->ctlframes_sent;
  pr->iframes_resent = hd->iframes_resent;
  pr->iframes_outofseq = hd->iframes_outofseq;
  pr->frames_rcvd = hd->frames_rcvd;
          
  return sizeof(PROBE_DEVICE_STRUCT);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\nic.h ===
//----- nic.h

#if DBG
//#define BREAK_NIC_STUFF
#endif

#define MAX_RX_PACKETS 1

#define MAX_PKT_SIZE 1550

#ifndef BYTE
#define BYTE  UCHAR
#endif

#ifndef WORD
#define WORD  USHORT
#endif

#ifndef DWORD
#define DWORD ULONG
#endif

#ifndef PBYTE
#define PBYTE PUCHAR
#endif

#ifndef PWORD
#define PWORD PUSHORT
#endif 

#ifndef LWORD
#define LWORD ULONG
#endif

#ifndef PLWORD
#define PLWORD PULONG
#endif

// header space we leave before ndis packet data, since ndis
// wants to split the 14 byte header anyway
#define HDR_SIZE 20
#define HDR_SRC_ADDR(_buf)   (_buf)
#define HDR_DEST_ADDR(_buf)  (&_buf[6])
#define HDR_PKTLEN(_buf)     *((WORD *)&_buf[12])

typedef struct _Nic Nic;
typedef struct _Nic {

  // This is the name of the NIC card which we got from the Registry.
  // Used to specify the nic card when wee do an OpenAdapter call.
  //PUNICODE_STRING NicName;
  char NicName[160];

  int Open;  // flag, set when open for operation (use handle)

  // This is the handle for the NIC card returned from NdisOpenAdapter
  NDIS_HANDLE NICHandle;

  // This event will be set when a compeltion routine finishes so
  // if someone is waiting on it it can continue
  KEVENT CompletionEvent;

  // our local NIC address(6-bytes, two just padding)
  BYTE address[8];

  // following is for temporary output packet(convient but lots of overhead)
  // packet and buffer pool handles
  NDIS_HANDLE TxPacketPoolTemp;
  NDIS_HANDLE TxBufferPoolTemp;
  PNDIS_PACKET TxPacketsTemp;  // []
  // queue data buffer space for all packets
  UCHAR *TxBufTemp;

  // packet and buffer pool handles
  NDIS_HANDLE RxPacketPool;
  NDIS_HANDLE RxBufferPool;

  // queue of packets setup for use
  PNDIS_PACKET RxPackets[MAX_RX_PACKETS];

  // queue data buffer space for all packets
  UCHAR *RxBuf;

  LIST_ENTRY RxPacketList;
  
  NDIS_STATUS PendingStatus;

  //----- statistics
  DWORD RxPendingMoves;
  DWORD RxNonPendingMoves;

  //----- incoming statistics
  WORD pkt_overflows;  // statistics: receiver queue overflow count
  //DWORD RxPacketOurs;
  DWORD pkt_rcvd_ours;
  DWORD rec_bytes;     // statistics: running tally of bytes received.
  DWORD pkt_rcvd_not_ours;

  //----- outgoing statistics
  DWORD pkt_sent;    // statistics: running tally of packets sent.
  DWORD send_bytes;    // statistics: running tally of bytes sent.
  //Nic *next_nic;  // next nic struct in linked list or null if end of chain

  int RefIndex;
} Nic;

#define  FLAG_APPL_RUNNING  0x01
#define  FLAG_NOT_OWNER    0x02
#define  FLAG_OWNER_TIMEOUT  0x04
typedef struct {
  unsigned char  mac[6];
  unsigned char  flags;
  unsigned char  nic_index;
} DRIVER_MAC_STATUS;

//--- layer 1 ethernet events used in _proc() calls
// layer 1(ethernet) assigned range from 100-199
#define EV_L1_RX_PACKET  100
#define EV_L1_TX_PACKET  101

// comtrol_type defines(byte [14] of ethernet packet):
#define ASYNC_PRODUCT_HEADER_ID   0x55
#define  ISDN_PRODUCT_HEADER_ID   0x15
#define   ANY_PRODUCT_HEADER_ID   0xFF

// comtrol_type defines(byte [14] of ethernet packet):
#define ASYNC_PRODUCT_HEADER_ID   0x55
#define  ISDN_PRODUCT_HEADER_ID   0x15
#define   ANY_PRODUCT_HEADER_ID   0xFF

//---- macro to see if mac-addresses match
#define mac_match(_addr1, _addr2) \
     ( (*((DWORD *)_addr1) == *((DWORD *)_addr2) ) && \
       (*((WORD *)(_addr1+4)) == *((WORD *)(_addr2+4)) ) )

//-- packet type
#define ADMIN_FRAME  1
#define ASYNC_FRAME  0x55

#define ADMIN_ID_BOOT     0
#define ADMIN_BOOT_PACKET 1
#define ADMIN_ID_QUERY    2
#define ADMIN_ID_REPLY    3
#define ADMIN_ID_LOOP     4
#define ADMIN_ID_RESET    5

int ProtocolOpen(void);
int NicMakeList(IN PUNICODE_STRING RegistryPath,
                int style);  // 0=nt3.51,4.0 1=nt5.0
int NicOpen(Nic *nic, IN PUNICODE_STRING NicName);
int NicClose(Nic *nic);
int NicProtocolClose(void);
  // int NicSend(Nic *nic, UCHAR *data, int length);
NDIS_STATUS NicSetNICInfo(Nic *nic, NDIS_OID Oid, PVOID Data, ULONG Size);
NDIS_STATUS NicGetNICInfo(Nic *nic, NDIS_OID Oid, PVOID Data, ULONG Size);
int nic_send_pkt(Nic *nic, BYTE *buf, int len);

extern BYTE broadcast_addr[6];
extern BYTE mac_zero_addr[6];
extern BYTE mac_bogus_addr[6];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\openclos.h ===
//--- openclos.h

NTSTATUS
SerialCreateOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ForceExtensionSettings(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

VOID
SetExtensionModemStatus(
    IN PSERIAL_DEVICE_EXTENSION extension
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\opstr.c ===
/*-----------------------------------------------------------------------
 opstr.c - Option Strings.  These are strings which define the options
  associated with the driver at the three levels: driver, device, port.
  This code is special, in that the source may be used for both driver
  and setup program, so consists only of the strings which can be shared
  in source code.

  This has expanded to other code which should be shared by
  both setup program and driver.

Copyright 1998 Comtrol(TM) Corporation.
|-----------------------------------------------------------------------*/
#include "precomp.h"

// driver options
const char szVerboseLog[]   = {"VerboseLog"};
const char szNumDevices[]   = {"NumDevices"};
const char szNoPnpPorts[]     = {"NoPnpPorts"};
const char szScanRate[]     = {"ScanRate"};
const char szModemCountry[] = {"ModemCountry"};
const char szGlobalRS485[]  = {"GlobalRS485Options"};

// device options
//const char szStartComIndex[] = {"StartComIndex"};
const char szNumPorts[]      = {"NumPorts"};
const char szMacAddr[]       = {"MacAddr"};
const char szBackupServer[]  = {"BackupServer"};
const char szBackupTimer[]   = {"BackupTimer"};
const char szName[]          = {"Name"};
const char szModelName[]     = {"ModelName"};
const char szIoAddress[]     = {"IoAddress"};
const char szModemDevice[]   = {"ModemDevice"};
const char szHubDevice[]     = {"HubDevice"};
const char szClkRate[]       = {"ClkRate"};
const char szClkPrescaler[]  = {"ClkPrescaler"};


// port options
const char szWaitOnTx[]      = {"WaitOnTx"};
const char szRS485Override[] = {"RS485Override"};
const char szRS485Low[]      = {"RS485Low"};
const char szTxCloseTime[]   = {"TxCloseTime"};
const char szLockBaud[]      = {"LockBaud"};
const char szMap2StopsTo1[]  = {"Map2StopsTo1"};
const char szMapCdToDsr[]    = {"MapCdToDsr"};
const char szRingEmulate[]    = {"RingEmulate"};

Our_Options driver_options[] = {
  // driver options
  {szVerboseLog,     OP_VerboseLog   , OP_T_DWORD, OP_F_VSRK},
  {szNumDevices,     OP_NumDevices   , OP_T_DWORD, OP_F_VSRK},
#ifdef NT50
  {szNoPnpPorts,       OP_NoPnpPorts     , OP_T_DWORD, OP_F_VSRK},
#endif
  {szScanRate,       OP_ScanRate     , OP_T_DWORD, OP_F_VSRK},
  {szModemCountry,   OP_ModemCountry , OP_T_DWORD, OP_F_VSRK},
  {szGlobalRS485,    OP_GlobalRS485  , OP_T_DWORD, OP_F_VSRK},
  {NULL,0,0,0}
};

Our_Options device_options[] = {
  // device options
//  {szStartComIndex,  OP_StartComIndex, OP_T_DWORD , OP_F_VSRK},
  {szNumPorts,       OP_NumPorts     , OP_T_DWORD , OP_F_VSRK},
#ifdef S_VS
  {szMacAddr,        OP_MacAddr      , OP_T_STRING, OP_F_VS},
  {szBackupServer,   OP_BackupServer , OP_T_DWORD , OP_F_VS},
  {szBackupTimer,    OP_BackupTimer  , OP_T_DWORD , OP_F_VS},
#endif
  {szName,           OP_Name         , OP_T_STRING, OP_F_VSRK},
  {szModelName,      OP_ModelName    , OP_T_STRING, OP_F_VSRK},
#ifdef S_RK
#ifndef NT50
  {szIoAddress,      OP_IoAddress    , OP_T_DWORD , OP_F_RK},
#endif
#endif
  {szModemDevice,    OP_ModemDevice  , OP_T_DWORD , OP_F_VSRK},
  {szHubDevice,      OP_HubDevice    , OP_T_DWORD , OP_F_VS},
  {szClkRate,        OP_ClkRate      , OP_T_DWORD , OP_F_VSRK},
  {szClkPrescaler,   OP_ClkPrescaler , OP_T_DWORD , OP_F_VSRK},
  {NULL,0,0,0}
};

Our_Options port_options[] = {
  // port options
  {szWaitOnTx,       OP_WaitOnTx     , OP_T_DWORD,  OP_F_VSRK},
  {szRS485Override,  OP_RS485Override, OP_T_DWORD,  OP_F_VSRK},
  {szRS485Low,       OP_RS485Low     , OP_T_DWORD,  OP_F_VSRK},
  {szTxCloseTime,    OP_TxCloseTime  , OP_T_DWORD,  OP_F_VSRK},
  {szLockBaud,       OP_LockBaud     , OP_T_DWORD,  OP_F_VSRK},
  {szMap2StopsTo1,   OP_Map2StopsTo1 , OP_T_DWORD,  OP_F_VSRK},
  {szMapCdToDsr,     OP_MapCdToDsr   , OP_T_DWORD,  OP_F_VSRK},
  {szName,           OP_PortName     , OP_T_STRING, OP_F_VSRK},
  {szRingEmulate,    OP_RingEmulate  , OP_T_DWORD,  OP_F_VSRK},
  {NULL,0,0,0}
};

#define INFO_WANT_NUMPORTS        0
#define INFO_WANT_MODEM_DEVICE    1
#define INFO_WANT_HUB_DEVICE      2
#define INFO_WANT_PORTS_PER_AIOP  3
#define INFO_WANT_DEF_CLOCK_PRESC 4

static int IdToInfo(int id, int *ret_dword, int info_wanted);

/*-----------------------------------------------------------------
  IdToInfo -
|------------------------------------------------------------------*/
static int IdToInfo(int id, int *ret_val, int info_wanted)
{ 
 int num_ports = 8;
 int modem_device = 0;
 int hub_device = 0;
 int ret_stat = 0;  // ok
 
    switch (id)
    {
      case PCI_DEVICE_RPLUS2:
      case PCI_DEVICE_422RPLUS2:
        num_ports = 2;
      break;

      case PCI_DEVICE_RPLUS4:
        num_ports = 4;
      break;

      case PCI_DEVICE_4Q  :
        num_ports = 4;
      break;

      case PCI_DEVICE_RMODEM4:
        num_ports = 4;
        modem_device = 1;
      break;

      case PCI_DEVICE_4RJ :
        num_ports = 4;
      break;
      case PCI_DEVICE_8RJ :
        num_ports = 8;
      break;
      case PCI_DEVICE_8O  :
        num_ports = 8;
      break;
      case PCI_DEVICE_8I  :
        num_ports = 8;
      break;
      case PCI_DEVICE_RPLUS8:
        num_ports = 8;
      break;
      case PCI_DEVICE_SIEMENS8:
        num_ports = 8;
      break;

      case PCI_DEVICE_16I :
        num_ports = 16;
      break;
      case PCI_DEVICE_SIEMENS16:
        num_ports = 16;
      break;

      case PCI_DEVICE_32I :
        num_ports = 32;
      break;

      case PCI_DEVICE_RMODEM6 :
        num_ports = 6;
        modem_device = 1;
      break;

      case ISA_DEVICE_RPORT4:  // rocketport
        num_ports = 4;
      break;
      case ISA_DEVICE_RPORT8:
        num_ports = 8;
      break;
      case ISA_DEVICE_RPORT16:
        num_ports = 16;
      break;
      case ISA_DEVICE_RPORT32:
        num_ports = 32;
      break;

      case ISA_DEVICE_RMODEM4:  // rocketmodem isa
        num_ports = 4;
        modem_device = 1;
      break;
      case ISA_DEVICE_RMODEM8:  // rocketmodem isa
        num_ports = 8;
        modem_device = 1;
      break;
      case NET_DEVICE_VS1000:
        num_ports = 16;  // vs1000, base is 16, expandable
      break;
      case NET_DEVICE_VS2000:  // vs2000, base is 8?
        num_ports = 8;
        modem_device = 1;
      break;
      case NET_DEVICE_RHUB8:  // vshub-8 port
        num_ports = 8;
        hub_device = 1;
      break;
      case NET_DEVICE_RHUB4:  // vshub-4 port
        num_ports = 4;
        hub_device = 1;
      break;
      default:
        ret_stat = 1; // err, unknown device
      break;
    }

  switch (info_wanted)
  {
    case INFO_WANT_NUMPORTS:
      *ret_val = num_ports;
    break;

    case INFO_WANT_MODEM_DEVICE:
      *ret_val = modem_device;
    break;

    case INFO_WANT_HUB_DEVICE:
      *ret_val = hub_device;
    break;

#if 0
    case INFO_WANT_PORTS_PER_AIOP:
        if (PortsPerAiop > num_ports)
            PortsPerAiop = num_ports;
      *ret_val = PortsPerAiop;

    case INFO_WANT_DEF_CLOCK_PRESC:
      *ret_val = clk_prescaler;
    break;
#endif

    default:
      ret_stat = 2; // unkown info request
    break;
  }
  return ret_stat;
}

/*-----------------------------------------------------------------
  id_to_num_ports - pci model-id number used, rest come from NT5 .inf
    files.
|------------------------------------------------------------------*/
int id_to_num_ports(int id)
{ 
 int stat;
 int num_ports;

  stat = IdToInfo(id, &num_ports, INFO_WANT_NUMPORTS);
  return num_ports;
}

/*-----------------------------------------------------------------
  IsHubDevice -
|------------------------------------------------------------------*/
int IsHubDevice(int Hardware_ID)
{ 
 int stat;
 int ishub;

  stat = IdToInfo(Hardware_ID, &ishub, INFO_WANT_HUB_DEVICE);
  return ishub;
}

/*-----------------------------------------------------------------
  IsModemDevice -
|------------------------------------------------------------------*/
int IsModemDevice(int Hardware_ID)
{ 
 int stat;
 int ismodemdev;

  stat = IdToInfo(Hardware_ID, &ismodemdev, INFO_WANT_MODEM_DEVICE);
  return ismodemdev;
}

/*-----------------------------------------------------------------
  HdwIDStrToID - Parse the hardware ID string obtained by the WinNT
    Pnp system.
    This is broke if we ever get ID's starting digit >= HEX(A,B..)
|------------------------------------------------------------------*/
int HdwIDStrToID(int *Hardware_ID, char *idstr)
{ 
  char *s = idstr;
#define _IS_STR_DIGIT(c) ((c >= '0') && (c <= '9'))
#define _IS_STR_LET_D(c) ((c == 'D') || (c == 'd'))

  if (strlen(s) < 12)  // a isa hardware id
  {
    while ( (*s != 0) && (!_IS_STR_DIGIT(*s)) )  // find digit
      ++s;
  }
  else // a pci hardware id
  {
    while ( (*s != 0) && (!_IS_STR_LET_D(*s)) ) // find "DEV_
      ++s;
    if (*s != 0)
      ++s;  // pass up the 'D'
    while ( (*s != 0) && (!_IS_STR_DIGIT(*s)) )  // find digit
      ++s;
    // asume we found "DEV_000X"
  }

  if (*s == 0)
  {
    *Hardware_ID = 0;  // unknown
    return 1;  // err
  }

  *Hardware_ID = gethint(s, NULL);
  return 0;  // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\openclos.c ===
/*-------------------------------------------------------------------
| openclos.c - RocketPort/VS1000 driver Open & Close code.

12-6-00 add code to force modem status update on open.
5-13-99 - enable RTS toggling for VS
2-15-99 - clear any xoff tx state on port-open for VS.
2-09-99 - initialize RocketPort & VS modemstatus variables used
  to detect and generate modem status change event callbacks.
  Spurious initial events could be generated previously.  kpb
9-24-98 add RING emulation, adjust VS port-close to wait on tx-data,
   start using user-configured tx-data port-close wait timeout option.
6-13-97 allow multiple instances of opening monitor port.
5-27-96 minor corrections in ForceExtensionSettings - RTS setup
   replaced this with code from ioctl(previous last case was clearing
   SERIAL_RTS_STATE when shouldn't have.  NULL_STRIPPING setup, 
   this was using RxCompare1 register, ioctl code using 0 so
   changed to match. kpb.

4-16-96 add sDisLocalLoopback() to open() routine - kpb

Copyright 1993-97 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"


static LARGE_INTEGER SerialGetCharTime(IN PSERIAL_DEVICE_EXTENSION Extension);

/******************************************************************************
  Function : SerialCreateOpen
  Purpose:   Open a device.
  Call:      SerialCreateOpen(DeviceObject,Irp)
             PDEVICE_OBJECT DeviceObject: Pointer to the Device Object
             PIRP Irp: Pointer to the I/O Request Packet
  Return:    STATUS_SUCCESS: if successful
             STATUS_DEVICE_ALREADY_ATTACHED: if device is already open
             STATUS_NOT_A_DIRECTORY : if someone thinks this is a file! 
             STATUS_INSUFFICIENT_RESOURCES : if Tx or Rx buffer couldn't be
                                            allocated from memory
  Comments: This function is the device driver OPEN entry point
******************************************************************************/
NTSTATUS
SerialCreateOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
   PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
   BOOLEAN acceptingIRPs;


   ExtTrace(extension,D_Ioctl,("Open Port"));

    acceptingIRPs = SerialIRPPrologue(extension);

   if (acceptingIRPs == FALSE) {
       // || (extension->PNPState != SERIAL_PNP_STARTED)) {
      MyKdPrint(D_Init,("NotAccIrps\n"))
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
      SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
      return STATUS_NO_SUCH_DEVICE;
   }

   // object for special ioctls
   if (extension->DeviceType != DEV_PORT)
   {
     MyKdPrint(D_Init,("Open Driver\n"))
     //MyKdPrint(D_Init,("Driver IrpCnt:%d\n",extension->PendingIRPCnt))
     // Hardware is ready, indicate that the device is open
     //extension->DeviceIsOpen=TRUE;
     ++extension->DeviceIsOpen;  // more than one can open
     // If it is the rocketsys dev object return don't set up serial port
     Irp->IoStatus.Status = STATUS_SUCCESS;
     Irp->IoStatus.Information=0L;
     SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
     return STATUS_SUCCESS;
   }

   // Check for the device already being open
   if (extension->DeviceIsOpen)
   {
       Irp->IoStatus.Status = STATUS_DEVICE_ALREADY_ATTACHED;
       Irp->IoStatus.Information = 0;
       SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);

       return STATUS_DEVICE_ALREADY_ATTACHED;
   }   

   // Make sure they aren't trying to create a directory.  
   if (IoGetCurrentIrpStackLocation(Irp)->Parameters.Create.Options &
       FILE_DIRECTORY_FILE)
   {
       Irp->IoStatus.Status = STATUS_NOT_A_DIRECTORY;
       Irp->IoStatus.Information = 0;
       SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
       return STATUS_NOT_A_DIRECTORY;
   }

   // Create a system side buffer for the RX data.

   extension->RxQ.QSize = 4096 + 1;
   extension->RxQ.QBase= our_locked_alloc(extension->RxQ.QSize, "exRX");

   // Check that Rx buffer allocation was succesful
   if (!extension->RxQ.QBase)
   {  extension->RxQ.QSize = 0;
      Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
      Irp->IoStatus.Information = 0;
      SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   extension->RxQ.QPut = extension->RxQ.QGet = 0;

#ifdef TXBUFFER
   // Create a system side buffer for the TX data.
   extension->TxBufSize = 4096;
   extension->TxBuf= our_locked_alloc(extension->TxBufSize, "exTX");

   // Check that Tx buffer allocation was succesful
   if (!extension->TxBuf)
   {  extension->TxBufSize = 0;
      Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
      Irp->IoStatus.Information = 0;
      SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   // Buffer allocation was successful
   // Set up the indexes for our buffers
   extension->TxIn = extension->TxOut = 0;
#endif //TXBUFFER

   //------ reset our performance stats
   extension->OldStats.TransmittedCount =
     extension->OurStats.TransmittedCount;

   extension->OldStats.FrameErrorCount = 
     extension->OurStats.FrameErrorCount;

   extension->OldStats.SerialOverrunErrorCount =
     extension->OurStats.SerialOverrunErrorCount;

   extension->OldStats.BufferOverrunErrorCount =
     extension->OurStats.BufferOverrunErrorCount;

   extension->OldStats.ParityErrorCount =
     extension->OurStats.ParityErrorCount;

   // Must start with a clear HistoryMask
   extension->HistoryMask = 0;
   extension->WaitIsISRs = 0;
   extension->IrpMaskLocation = &extension->DummyIrpMaskLoc;
   extension->IsrWaitMask = 0;

   // Must start with a clear ErrorWord
   extension->ErrorWord = 0;

   extension->RXHolding = 0;
   extension->TXHolding = 0;
#ifdef S_VS
   if (extension->Port == NULL)
   {
     MyKdPrint(D_Error,("FATAL Err5F\n"))
     KdBreakPoint();
   }
   pDisLocalLoopback(extension->Port);
   PortFlushTx(extension->Port);    // flush tx hardware
   PortFlushRx(extension->Port);    // flush tx hardware
   // Clear any software flow control states
#ifdef DO_LATER
   //sClrTxXOFF(extension->ChP);
#endif
#else
   // Set pointers to the Rocket's info
   extension->ChP = &extension->ch;
   sDisLocalLoopback(extension->ChP);
   sFlushRxFIFO(extension->ChP);
   sFlushTxFIFO(extension->ChP);
   // Clear any software flow control states
   sClrTxXOFF(extension->ChP);
   // Clear any pending errors
   if(sGetChanStatus(extension->ChP) & STATMODE)
   {  // Take channel out of statmode if necessary
      sDisRxStatusMode(extension->ChP);
   }
   // Clear any pending modem changes
   sGetChanIntID(extension->ChP);
#endif

   extension->escapechar = 0;  // virtual NT port uses this

   // Set Status to indicate no flow control
   extension->DevStatus = COM_RXFLOW_ON;

   // Clear any holding states
   extension->TXHolding = 0;

   // Start with 0 chars queued
   extension->TotalCharsQueued = 0;

   // Force settings as specified in the extension
   // Line settings and flow control settings "stick" between close and open
   ForceExtensionSettings(extension);

   
#ifdef S_VS

   //force an update of modem status to get current status from
   // hub.
   extension->Port->old_msr_value = ! extension->Port->msr_value;

#else

   // fix, used to detect change and trip callbacks for rocketport.
   extension->EventModemStatus = extension->ModemStatus;
   SetExtensionModemStatus(extension);

   // Enable Rx, Tx and interrupts for the channel
   sEnRxFIFO(extension->ChP);    // Enable Rx
   sEnTransmit(extension->ChP);    // Enable Tx
   sSetRxTrigger(extension->ChP,TRIG_1);  // always trigger
   sEnInterrupts(extension->ChP, extension->IntEnables);// allow interrupts
#endif

   extension->ISR_Flags = 0;

   // Make sure we don't have a stale value in this var
   extension->WriteLength = 0;

   // Hardware is ready, indicate that the device is open
   extension->DeviceIsOpen=TRUE;

  // check if we should set RS485 override option
  if (extension->port_config->RS485Override)
        extension->Option |= OPTION_RS485_OVERRIDE;
  else  extension->Option &= ~OPTION_RS485_OVERRIDE;

  if (!extension->port_config->RS485Low)
       extension->Option |= OPTION_RS485_HIGH_ACTIVE;
  else extension->Option &= ~OPTION_RS485_HIGH_ACTIVE;

   if (extension->Option & OPTION_RS485_OVERRIDE)  // 485 override
   {
     if (extension->Option & OPTION_RS485_HIGH_ACTIVE)
     {  // normal case, emulate standard operation
       extension->Option |= OPTION_RS485_SOFTWARE_TOGGLE;
       extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
#ifdef S_VS
       pEnRTSToggleHigh( extension->Port );
#else
       sClrRTS(extension->ChP);
#endif
     }
     else 
     {  // hardware reverse case
#ifdef S_VS
       pEnRTSToggleLow( extension->Port );
#else
       sEnRTSToggle(extension->ChP);
#endif
       extension->DTRRTSStatus |= SERIAL_RTS_STATE;
     }
   }

   // Finish the Irp
   Irp->IoStatus.Status = STATUS_SUCCESS;
   Irp->IoStatus.Information=0L;
   SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);

   return STATUS_SUCCESS;
}

/******************************************************************************
  Function : SerialClose
  Purpose:   Close a device.
  Call:      SerialClose(DeviceObject,Irp)
             PDEVICE_OBJECT DeviceObject: Pointer to the Device Object
             PIRP Irp: Pointer to the I/O Request Packet
  Return:   STATUS_SUCCESS: always
  Comments: This function is the device driver CLOSE entry point
******************************************************************************/
NTSTATUS
SerialClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
   LARGE_INTEGER charTime; // 100 ns ticks per char, related to baud rate
   PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
   LARGE_INTEGER WaitTime; // Actual time req'd for buffer to drain
   ULONG check_cnt, nochg_cnt;
   ULONG last_tx_count;
   ULONG tx_count;
   BOOLEAN acceptingIRPs;
   ULONG time_to_stall;

   acceptingIRPs = SerialIRPPrologue(extension);

   if (acceptingIRPs == FALSE) {
      MyKdPrint(D_Init,("NotAccIrps Close\n"))
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_SUCCESS;
      SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
      return STATUS_SUCCESS;
   }

   // object for special ioctls
   if (extension->DeviceType != DEV_PORT)
   {
     MyKdPrint(D_Init,("Close Driver\n"))
     //MyKdPrint(D_Init,("Driver IrpCnt:%d\n",extension->PendingIRPCnt))
     // Hardware is ready, indicate that the device is open
     --extension->DeviceIsOpen;
     // If it is the rocketsys dev object return don't set up serial port
     Irp->IoStatus.Status = STATUS_SUCCESS;
     Irp->IoStatus.Information=0L;
     SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
     return STATUS_SUCCESS;
   }

   ExtTrace(extension,D_Ioctl,("Close"))
   // Calculate 100ns ticks to delay for each character
   // Negate for call to KeDelay...
   charTime = RtlLargeIntegerNegate(SerialGetCharTime(extension));

#ifdef TXBUFFER
   // Wait until ISR has pulled all data out of system side TxBuf
   while (extension->TxIn != extension->TxOut)
   {  // Determine how many characters are actually in TxBuf
      TxCount= (extension->TxIn - extension->TxOut);
      if (TxCount < 0L)
         TxCount+=extension->TxBufSize;
      WaitTime= RtlExtendedIntegerMultiply(charTime,TxCount);
      KeDelayExecutionThread(KernelMode,FALSE,&WaitTime);
   }
#endif //TXBUFFER


   // Send an XON if Tx is suspend by IS_FLOW
   // send now so we are sure that it gets out of the port before shutdown
   if (extension->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE)
   {
      if(!(extension->DevStatus & COM_RXFLOW_ON))
      {
#ifdef S_RK
         sWriteTxPrioByte(extension->ChP,extension->SpecialChars.XonChar);
         extension->DevStatus |= COM_RXFLOW_ON;
#endif
         extension->RXHolding &= ~SERIAL_RX_XOFF;
      }
   }

   //----- wait for Tx data to finish spooling out
   // If tx-data still in transmit buffers, then stall close for
   // the configured amount of time waiting for data to spool out.
   // If no data movement is seen, we timeout after TxCloseTime.
   // If data movement is seen, wait and timeout after (TxCloseTime*3).

   time_to_stall = extension->port_config->TxCloseTime;
   if (time_to_stall <= 0)
     time_to_stall = 1;  // use 1-sec if set to 0
   if (time_to_stall > 240)  // 4-minute max
     time_to_stall = 240;

   time_to_stall *= 10;  // change from seconds to 100ms(1/10th sec) units

#ifdef S_RK
   tx_count = extension->TotalCharsQueued + sGetTxCnt(extension->ChP);
   if ((sGetChanStatusLo(extension->ChP) & DRAINED) != DRAINED)
     ++tx_count;
#else
   tx_count = extension->TotalCharsQueued +
              PortGetTxCntRemote(extension->Port) +
              PortGetTxCnt(extension->Port);
#endif
   last_tx_count = tx_count;

   if (tx_count != 0)
   {
     ExtTrace(extension,D_Ioctl,("Tx Stall"));
   }

   // wait for Tx data to finish spooling out
   check_cnt = 0;
   nochg_cnt = 0;
   while ( (tx_count != 0) && (check_cnt < (time_to_stall*2)) )
   {
     // set wait-time to .1 second.(-1000 000 = relative(-), 100-ns units)
     WaitTime = RtlConvertLongToLargeInteger(-1000000L);
     KeDelayExecutionThread(KernelMode,FALSE,&WaitTime);

     if (tx_count != last_tx_count)
     {
       tx_count = last_tx_count;
       nochg_cnt = 0;
     }
     else
     {
       ++nochg_cnt;
       if (nochg_cnt > (time_to_stall))  // no draining occuring!
         break;  // bail out of while loop
     }
     ++check_cnt;
#ifdef S_RK
     tx_count = extension->TotalCharsQueued + sGetTxCnt(extension->ChP);
     if ((sGetChanStatusLo(extension->ChP) & DRAINED) != DRAINED)
       ++tx_count;
#else
     tx_count = extension->TotalCharsQueued +
                PortGetTxCntRemote(extension->Port) +
                PortGetTxCnt(extension->Port);
#endif
   }  // while tx_count

   if (tx_count != 0)
   {
     ExtTrace(extension,D_Ioctl,("Tx Dropped!"));
   }

#ifdef COMMENT_OUT
      // Calculate total chars and time, then wait.
      WaitTime= RtlExtendedIntegerMultiply(charTime,sGetTxCnt(extension->ChP));
      KeDelayExecutionThread(KernelMode,FALSE,&WaitTime);
#endif

#ifdef S_RK
   // Tx Data is drained, shut down the port
   sDisInterrupts(extension->ChP, extension->IntEnables);

   // Disable all Tx and Rx functions
   sDisTransmit(extension->ChP);
   sDisRxFIFO(extension->ChP);
   sDisRTSFlowCtl(extension->ChP);
   sDisCTSFlowCtl(extension->ChP);
   sDisRTSToggle(extension->ChP);
   sClrBreak(extension->ChP);

   // Drop the modem outputs
   // Takes care of DTR flow control as well
   sClrRTS(extension->ChP);
   sClrDTR(extension->ChP);
#else
   // add this, 2-9-99, kpb, CNC xon/xoff problems...
   PortFlushRx(extension->Port);    // flush rx hardware
   PortFlushTx(extension->Port);    // flush tx hardware
   pClrBreak(extension->Port);
   pDisDTRFlowCtl(extension->Port);
   pDisRTSFlowCtl(extension->Port);
   pDisCTSFlowCtl(extension->Port);
   pDisRTSToggle(extension->Port);
   pDisDSRFlowCtl(extension->Port);
   pDisCDFlowCtl(extension->Port);
   pDisTxSoftFlowCtl(extension->Port);
   pDisRxSoftFlowCtl(extension->Port);
   pDisNullStrip(extension->Port);
   pClrRTS(extension->Port);
   pClrDTR(extension->Port);
#endif

   //extension->ModemCtl &= ~(CTS_ACT | DSR_ACT | CD_ACT);
   extension->DTRRTSStatus &= ~(SERIAL_DTR_STATE | SERIAL_RTS_STATE);
   
#ifdef TXBUFFER
   // Release the memory being used for this device's buffers...
   extension->TxBufSize = 0;
   our_free(extension->TxBuf,"exTX");
   extension->TxBuf = NULL;
#endif //TXBUFFER

   extension->DeviceIsOpen = FALSE;
   extension->RxQ.QSize = 0;
   our_free(extension->RxQ.QBase,"exRx");
   extension->RxQ.QBase = NULL;

   // Finish the Irp
   Irp->IoStatus.Status = STATUS_SUCCESS;
   Irp->IoStatus.Information = 0L;

   SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);

   return STATUS_SUCCESS;
}


/***************************************************************************
Routine Description:
    This function is used to kill all longstanding IO operations.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request
Return Value:
    The function value is the final status of the call
****************************************************************************/
NTSTATUS
SerialCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    KIRQL oldIrql;
    BOOLEAN acceptingIRPs;

    MyKdPrint(D_Init,("SerialCleanup\n"))

    acceptingIRPs = SerialIRPPrologue(extension);

    if (acceptingIRPs == FALSE) {
       Irp->IoStatus.Information = 0;
       Irp->IoStatus.Status = STATUS_SUCCESS;
       SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
       return STATUS_SUCCESS;
    }
    if (extension->DeviceType != DEV_PORT)
    {
      MyKdPrint(D_Init,("Driver IrpCnt:%d\n",extension->PendingIRPCnt))
    }
#if DBG
    if (extension->CurrentWriteIrp)
    {
      MyKdPrint(D_Error,("CleanUp WriteQ\n"))
    }
    if (extension->CurrentReadIrp)
    {
      MyKdPrint(D_Error,("CleanUp ReadQ\n"))
    }
    if (extension->CurrentPurgeIrp)
    {
      MyKdPrint(D_Error,("CleanUp PurgeQ\n"))
    }
    if (extension->CurrentWaitIrp)
    {
      MyKdPrint(D_Error,("CleanUp WaitQ\n"))
    }
#endif

    ExtTrace(extension,D_Ioctl,("SerialCleanup"));

    // First kill all the reads and writes.
    SerialKillAllReadsOrWrites(
        DeviceObject,
        &extension->WriteQueue,
        &extension->CurrentWriteIrp
        );

    SerialKillAllReadsOrWrites(
        DeviceObject,
        &extension->ReadQueue,
        &extension->CurrentReadIrp
        );

    // Next get rid of purges.
    SerialKillAllReadsOrWrites(
        DeviceObject,
        &extension->PurgeQueue,
        &extension->CurrentPurgeIrp
        );

    // Get rid of any mask operations.
    //SerialKillAllReadsOrWrites(
    //    DeviceObject,
    //    &extension->MaskQueue,
    //    &extension->CurrentMaskIrp
    //    );

    if (extension->DeviceType != DEV_PORT)
    {
      MyKdPrint(D_Init,("Driver IrpCnt:%d\n",extension->PendingIRPCnt))
    }
    // Now get rid of any pending wait mask irp.
    IoAcquireCancelSpinLock(&oldIrql);
    if (extension->CurrentWaitIrp) {
        PDRIVER_CANCEL cancelRoutine;
        cancelRoutine = extension->CurrentWaitIrp->CancelRoutine;
        extension->CurrentWaitIrp->Cancel = TRUE;
        if (cancelRoutine)
        {   extension->CurrentWaitIrp->CancelIrql = oldIrql;
            extension->CurrentWaitIrp->CancelRoutine = NULL;
            cancelRoutine( DeviceObject, extension->CurrentWaitIrp );
        }
    }
    else
    {   IoReleaseCancelSpinLock(oldIrql);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information=0L;

    SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}


/************************************************************************
Routine: SerialGetCharTime
    This function will return the number of 100 nanosecond intervals
    there are in one character time (based on the present form
    of flow control.
Return Value:
    100 nanosecond intervals in a character time.
*************************************************************************/
LARGE_INTEGER SerialGetCharTime(IN PSERIAL_DEVICE_EXTENSION Extension)
{
    ULONG dataSize;
    ULONG paritySize;
    ULONG stopSize;
    ULONG charTime;
    ULONG bitTime;

    dataSize = Extension->LineCtl.WordLength;
    if(!Extension->LineCtl.Parity)
       paritySize = 0;
    else
       paritySize = 1;

    if(Extension->LineCtl.StopBits == STOP_BIT_1)
       stopSize = 1;
    else
       stopSize = 2;

    // Calculate number of 100 nanosecond intervals in a single bit time
    if (Extension->BaudRate == 0)
    {
      MyKdPrint(D_Init, ("0 Baud!\n"))
      Extension->BaudRate = 9600;
    }
      
    bitTime = (10000000+(Extension->BaudRate-1))/Extension->BaudRate;
    // Calculate number of 100 nanosecond intervals in a character time
    charTime = bitTime + ((dataSize+paritySize+stopSize)*bitTime);

    return RtlConvertUlongToLargeInteger(charTime);
}

/*****************************************************************************
   Function : ForceExtensionSettings
   Description: "Forces" the RocketPort to settings as indicated
                 by the device extension
Note: This is somewhat redundant to SerialSetHandFlow() in ioctl.c.
*****************************************************************************/
VOID ForceExtensionSettings(IN PSERIAL_DEVICE_EXTENSION Extension)
#ifdef S_VS
{
   /////////////////////////////////////////////////////////////
   // set the baud rate....
   ProgramBaudRate(Extension, Extension->BaudRate);

   /////////////////////////////////////////////////////////////
   // set Line Control.... Data, Parity, Stop
   ProgramLineControl(Extension, &Extension->LineCtl);

   // HandFlow related options
   /////////////////////////////////////////////////////////////
   // set up RTS control

   Extension->Option &= ~OPTION_RS485_SOFTWARE_TOGGLE;
   switch(Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK)
   {
     case SERIAL_RTS_CONTROL: // RTS Should be asserted while open
       pDisRTSFlowCtl(Extension->Port);
       pSetRTS(Extension->Port);
       Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
     break;

     case SERIAL_RTS_HANDSHAKE: // RTS hardware input flow control
        // Rocket can't determine RTS state... indicate true for this option
       pEnRTSFlowCtl(Extension->Port);
       Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
     break;

     case SERIAL_TRANSMIT_TOGGLE: // RTS transmit toggle enabled
       if ( Extension->Option & OPTION_RS485_HIGH_ACTIVE ) {
         Extension->Option |= OPTION_RS485_SOFTWARE_TOGGLE;
         Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
         pEnRTSToggleHigh(Extension->Port);
       } else {
         pEnRTSToggleLow(Extension->Port);
         Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
       }
     break;

     default:
       pDisRTSFlowCtl(Extension->Port);
       // Is RTS_CONTROL off?
       pClrRTS(Extension->Port);
       Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
     break;
   }

   if (Extension->Option & OPTION_RS485_OVERRIDE)  // 485 override
   {
     if (Extension->Option & OPTION_RS485_HIGH_ACTIVE)
     {  // normal case, emulate standard operation
       Extension->Option |= OPTION_RS485_SOFTWARE_TOGGLE;
       Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
       pEnRTSToggleHigh(Extension->Port);
     }
     else 
     {  // hardware reverse case
       pEnRTSToggleLow(Extension->Port);
       Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
     }
   }

   /////////////////////////////////////////////////////////////
   // set up DTR control

   pDisDTRFlowCtl(Extension->Port);
   // Should DTR be asserted when the port is opened?
   if (  (Extension->HandFlow.ControlHandShake & SERIAL_DTR_MASK) ==
           SERIAL_DTR_CONTROL )
   {
      pSetDTR(Extension->Port);
      Extension->DTRRTSStatus |= SERIAL_DTR_STATE;
   }
   else if (  (Extension->HandFlow.ControlHandShake & SERIAL_DTR_MASK) ==
           SERIAL_DTR_HANDSHAKE )
   {
      pEnDTRFlowCtl(Extension->Port);
      Extension->DTRRTSStatus |= SERIAL_DTR_STATE;
   }
   else
   {
      pClrDTR(Extension->Port);
      Extension->DTRRTSStatus &= ~SERIAL_DTR_STATE;
   }

   ///////////////////////////////////
   // DSR hardware output flow control

   if (Extension->HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE)
   {
     pEnDSRFlowCtl(Extension->Port);
   }
   else
   {
     pDisDSRFlowCtl(Extension->Port);
   }

   ///////////////////////////////////
   // DCD hardware output flow control
   if (Extension->HandFlow.ControlHandShake & SERIAL_DCD_HANDSHAKE)
   {
     pEnCDFlowCtl(Extension->Port);
   }
   else
   {
     pDisCDFlowCtl(Extension->Port);
   }

   /////////////////////////////////////////////////////////////
   // Set up CTS Flow Control
   if (Extension->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE)
   {
      pEnCTSFlowCtl(Extension->Port);
   }
   else
   {
      pDisCTSFlowCtl(Extension->Port);
   }

   /////////////////////////////////////////////////////////////
   // Set up NULL stripping    OPTIONAL
   // fix: this was using RxCompare1 register, ioctl code using 0 so
   // changed to match.
   if (Extension->HandFlow.FlowReplace & SERIAL_NULL_STRIPPING)
   {
      pEnNullStrip(Extension->Port);
   }
   else
   {
      pDisNullStrip(Extension->Port);
   }

   /////////////////////////////////////////////////////////////
   // Set up Software Flow Control   OPTIONAL

   /////////////////////////////////////////////////////////////
   // Special chars needed by RocketPort
   pSetXOFFChar(Extension->Port,Extension->SpecialChars.XoffChar);
   pSetXONChar(Extension->Port,Extension->SpecialChars.XonChar);

   // Software input flow control
   // SERIAL_AUTO_RECEIVE
   if (Extension->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE)
   {
     pEnRxSoftFlowCtl(Extension->Port);
   }
   else
   {
     pDisRxSoftFlowCtl(Extension->Port);
   }

   // Software output flow control
   if (Extension->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT)
   {
      pEnTxSoftFlowCtl(Extension->Port);
   }
   else
   {
      pDisTxSoftFlowCtl(Extension->Port);
   }
}

#else  // rocketport code
{
   /////////////////////////////////////////////////////////////
   // set the baud rate....
   ProgramBaudRate(Extension, Extension->BaudRate);

   /////////////////////////////////////////////////////////////
   // set Line Control.... Data, Parity, Stop
   ProgramLineControl(Extension, &Extension->LineCtl);

   // HandFlow related options
   /////////////////////////////////////////////////////////////
   // set up RTS control

   Extension->Option &= ~OPTION_RS485_SOFTWARE_TOGGLE;
   switch(Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK)
   {
     case SERIAL_RTS_CONTROL: // RTS Should be asserted while open
       sSetRTS(Extension->ChP);
       Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
     break;

     case SERIAL_RTS_HANDSHAKE: // RTS hardware input flow control
        // Rocket can't determine RTS state... indicate true for this option
       sEnRTSFlowCtl(Extension->ChP);
       Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
     break;

     case SERIAL_TRANSMIT_TOGGLE: // RTS transmit toggle enabled
       if (Extension->Option & OPTION_RS485_HIGH_ACTIVE)
       {  // normal case, emulate standard operation
         Extension->Option |= OPTION_RS485_SOFTWARE_TOGGLE;
         Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
         sClrRTS(Extension->ChP);
       }
       else 
       {  // hardware reverse case
         sEnRTSToggle(Extension->ChP);
         Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
       }
     break;

     default:
       // Is RTS_CONTROL off?
       sClrRTS(Extension->ChP);
       Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
     break;
   }

   if (Extension->Option & OPTION_RS485_OVERRIDE)  // 485 override
   {
     if (Extension->Option & OPTION_RS485_HIGH_ACTIVE)
     {  // normal case, emulate standard operation
       Extension->Option |= OPTION_RS485_SOFTWARE_TOGGLE;
       Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
       sClrRTS(Extension->ChP);
     }
     else 
     {  // hardware reverse case
       sEnRTSToggle(Extension->ChP);
       Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
     }
   }

   /////////////////////////////////////////////////////////////
   // set up DTR control

   // Should DTR be asserted when the port is opened?
   if(  Extension->HandFlow.ControlHandShake &
        (SERIAL_DTR_CONTROL|SERIAL_DTR_HANDSHAKE)
     )
   {
      sSetDTR(Extension->ChP);
      Extension->DTRRTSStatus |= SERIAL_DTR_STATE;
   }
   else
   {
      sClrDTR(Extension->ChP);
      Extension->DTRRTSStatus &= ~SERIAL_DTR_STATE;
   }

   /////////////////////////////////////////////////////////////
   // Set up CTS Flow Control
   if (Extension->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE)
   {
      sEnCTSFlowCtl(Extension->ChP);
   }
   else
   {
      sDisCTSFlowCtl(Extension->ChP);
   }

   /////////////////////////////////////////////////////////////
   // Set up NULL stripping    OPTIONAL
   // fix: this was using RxCompare1 register, ioctl code using 0 so
   // changed to match.
   if (Extension->HandFlow.FlowReplace & SERIAL_NULL_STRIPPING)
   {
      sEnRxIgnore0(Extension->ChP,0);
   }
   else
   {
      sDisRxCompare0(Extension->ChP);
   }

   /////////////////////////////////////////////////////////////
   // Set up Software Flow Control   OPTIONAL

   /////////////////////////////////////////////////////////////
   // Special chars needed by RocketPort
   sSetTxXOFFChar(Extension->ChP,Extension->SpecialChars.XoffChar);
   sSetTxXONChar(Extension->ChP,Extension->SpecialChars.XonChar);

   // SERIAL_AUTO_RECEIVE is taken care of by the driver

   // Software output flow control
   if (Extension->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT)
   {
      sEnTxSoftFlowCtl(Extension->ChP);
   }
   else
   {
      sDisTxSoftFlowCtl(Extension->ChP);
      sClrTxXOFF(Extension->ChP);
   }
}
#endif

#ifdef S_RK
/*****************************************************************************
   Function : SetExtensionModemStatus
   Description: Reads and saves a copy of the modem control inputs,
                then fills out the ModemStatus member in the extension.
*****************************************************************************/
VOID
SetExtensionModemStatus(
    IN PSERIAL_DEVICE_EXTENSION extension
    )
{
   unsigned int ModemStatus = 0;  // start off with no status
   ULONG wstat;



   //MyKdPrint(D_Init, ("SetExtModemStat"))

   // ModemCtl is an image of the RocketPort's modem status
   // ModemStatus member is passed to host via IOCTL
#if DBG
   // this is called during isr.c poll, so put
   // some assertions where we have been burned before...
   if (extension->board_ext->config == NULL)
   {
     MyKdPrint(D_Init, ("SetExtMdm Err0\n"))
     return;
   }
#ifdef S_RK
   if (!extension->board_ext->config->RocketPortFound)
   {
     MyKdPrint(D_Init, ("SetExtMdm Err1\n"))
     return;
   }
#endif
   if (NULL == extension->ChP)
   {
     MyKdPrint(D_Init, ("SetExtMdm Err2\n"))
     return;
   }
   if (0 == extension->ChP->ChanStat)
   {
     MyKdPrint(D_Init, ("SetExtMdm Err3\n"))
     return;
   }
   if (NULL == extension->port_config)
   {
     MyKdPrint(D_Init, ("SetExtMdm Err4\n"))
     return;
   }
#endif

   // Read the port's modem control inputs and save off a copy
   extension->ModemCtl = sGetModemStatus(extension->ChP);

   if (extension->port_config->MapCdToDsr)  // if CD to DSR option, swap signals
   {
     // swap CD and DSR handling for RJ11 board owners,
     // so they can have pick between CD or DSR
     if ((extension->ModemCtl & (CD_ACT | DSR_ACT)) == CD_ACT)
     {
       // swap
       extension->ModemCtl &= ~CD_ACT;
       extension->ModemCtl |= DSR_ACT;
     }
     else if ((extension->ModemCtl & (CD_ACT | DSR_ACT)) == DSR_ACT)
     {
       extension->ModemCtl &= ~DSR_ACT;
       extension->ModemCtl |= CD_ACT;
     }
   }

   // handle RPortPlus RI signal
   if (extension->board_ext->config->IsRocketPortPlus)
   {
     if (sGetRPlusModemRI(extension->ChP))
          ModemStatus |=  SERIAL_RI_STATE;
     else ModemStatus &= ~SERIAL_RI_STATE;
   }

#ifdef RING_FAKE
    if (extension->port_config->RingEmulate)
    {
      if (extension->ring_timer != 0)  // RI on
           ModemStatus |=  SERIAL_RI_STATE;
      else ModemStatus &= ~SERIAL_RI_STATE;
    }
#endif

   if (extension->ModemCtl & COM_MDM_DSR)  // if DSR on
   {
     ModemStatus |= SERIAL_DSR_STATE;
     if (extension->TXHolding & SERIAL_TX_DSR)  // holding
     {
        extension->TXHolding &=  ~SERIAL_TX_DSR;  // clear holding
        // if not holding due to other reason
        if ((extension->TXHolding &
            (SERIAL_TX_DCD | SERIAL_TX_DSR | ST_XOFF_FAKE)) == 0)
          sEnTransmit(extension->ChP);  // re-enable transmit
     }
   }
   else    // if DSR off
   {
     if (extension->HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE)
     {
       if (!(extension->TXHolding & SERIAL_TX_DSR)) // not holding
       {
          extension->TXHolding |= SERIAL_TX_DSR;   // set holding
          sDisTransmit(extension->ChP);  // hold transmit
       }
     }
   }

   if (extension->ModemCtl & COM_MDM_CTS)  // if CTS on
   {
     ModemStatus |= SERIAL_CTS_STATE;
     if (extension->TXHolding & SERIAL_TX_CTS)  // holding
         extension->TXHolding &= ~SERIAL_TX_CTS;  // clear holding
   }
   else  // cts off
   {
     if (extension->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE)
     {
       if (!(extension->TXHolding & SERIAL_TX_CTS))  // not holding
             extension->TXHolding |= SERIAL_TX_CTS;   // set holding
     }
   }

   if (extension->ModemCtl & COM_MDM_CD)  // if CD on
   {
     ModemStatus |= SERIAL_DCD_STATE;
     if (extension->TXHolding & SERIAL_TX_DCD)  // holding
     {
        extension->TXHolding &=  ~SERIAL_TX_DCD;  // clear holding
        // if not holding due to other reason
        if ((extension->TXHolding & 
            (SERIAL_TX_DCD | SERIAL_TX_DSR | ST_XOFF_FAKE)) == 0)
          sEnTransmit(extension->ChP);  // re-enable transmit
     }
   }
   else    // if CD off
   {
     if (extension->HandFlow.ControlHandShake & SERIAL_DCD_HANDSHAKE)
     {
       if (!(extension->TXHolding & SERIAL_TX_DCD)) // not holding
       {
          extension->TXHolding |= SERIAL_TX_DCD;   // set holding
          sDisTransmit(extension->ChP);  // hold transmit
       }
     }
   }


   // handle holding detection if xon,xoff tx control activated
   if (extension->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT)
   {
     wstat = sGetChanStatusLo(extension->ChP);

     // check for tx-flowed off condition to report
     if ((wstat & (TXFIFOMT | TXSHRMT)) == TXSHRMT)
     {
       if (!extension->TXHolding) // not holding
       {
         wstat = sGetChanStatusLo(extension->ChP);
         if ((wstat & (TXFIFOMT | TXSHRMT)) == TXSHRMT)
         {
           extension->TXHolding |= SERIAL_TX_XOFF; // holding
         }
       }
     }
     else  // clear xoff holding report
     {
       if (extension->TXHolding & SERIAL_TX_XOFF)
         extension->TXHolding &= ~SERIAL_TX_XOFF; // not holding
     }
   }

   extension->ModemStatus = ModemStatus;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\options.h ===
//--- options.h

int SaveRegPath(PUNICODE_STRING RegistryPath);

int MakeRegPath(CHAR *optionstr);

int write_device_options(PSERIAL_DEVICE_EXTENSION ext);

int read_device_options(PSERIAL_DEVICE_EXTENSION ext);

int read_driver_options(void);

int SetOptionStr(char *option_str);

#if 0
int reg_get_str(IN WCHAR *RegPath,
                       int reg_location,
                       const char *str_id,
                       char *dest,
                       int max_dest_len);

int reg_get_dword(IN WCHAR *RegPath,
                          const char *str_id,
                          ULONG *dest);

int reg_set_dword(IN WCHAR *RegPath,
                          const char *str_id,
                          ULONG val);
#endif

int write_port_name(PSERIAL_DEVICE_EXTENSION dev_ext, int port_index);
int write_dev_mac(PSERIAL_DEVICE_EXTENSION dev_ext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\pnp.c ===
/*----------------------------------------------------------------------
 pnp.c -
 4-18-00 Remove IoStartNextPacket call from PnPBoardFDO function
 4-06-00 Reject irps for query_device_relations if not a bus_relation request
 3-30-99 fix hybernate power on to restore dtr/rts states
  properly, in RestorePortSettings().
 2-15-99 - allow to hibernate with open ports, restore ports when
  comes back up now - kpb.
11-24-98 - fix power handling to avoid crash,
           allow hibernation if no ports open. kpb
----------------------------------------------------------------------*/
#include "precomp.h"

#ifdef NT50

NTSTATUS PnPBoardFDO(IN PDEVICE_OBJECT devobj, IN PIRP Irp);
NTSTATUS PnPPortFDO(IN PDEVICE_OBJECT devobj, IN PIRP Irp);
NTSTATUS PnpPortPDO(IN PDEVICE_OBJECT devobj, IN PIRP Irp);
NTSTATUS BoardBusRelations(IN PDEVICE_OBJECT devobj, IN PIRP Irp);
NTSTATUS WaitForLowerPdo(IN PDEVICE_OBJECT fdo, IN PIRP Irp);
NTSTATUS BoardFilterResReq(IN PDEVICE_OBJECT devobj, IN PIRP Irp);

NTSTATUS SerialRemoveFdo(IN PDEVICE_OBJECT pFdo);
NTSTATUS SerialIoCallDriver(PSERIAL_DEVICE_EXTENSION PDevExt,
           PDEVICE_OBJECT PDevObj,
           PIRP PIrp);
NTSTATUS Serial_PDO_Power (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS Serial_FDO_Power (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS PowerUpDevice(PSERIAL_DEVICE_EXTENSION    Ext);
void RestorePortSettings(PSERIAL_DEVICE_EXTENSION Ext);

//NTSTATUS SerialPoCallDriver(PSERIAL_DEVICE_EXTENSION PDevExt,
//           PDEVICE_OBJECT PDevObj,
//           PIRP PIrp);
//NTSTATUS SerialSetPowerD0(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS OurPowerCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);

NTSTATUS SerialD3Complete(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS SerialStartDevice(
        IN PDEVICE_OBJECT Fdo,
        IN PIRP Irp);

NTSTATUS SerialSyncCompletion(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP Irp,
                       IN PKEVENT SerialSyncEvent
                       );

NTSTATUS SerialFinishStartDevice(IN PDEVICE_OBJECT Fdo,
           IN PCM_RESOURCE_LIST resourceList,
           IN PCM_RESOURCE_LIST trResourceList);
static NTSTATUS RocketPortSpecialStartup(PSERIAL_DEVICE_EXTENSION Ext);

#if DBG
static char *power_strs[] = {
"WAIT_WAKE",       //             0x00
"POWER_SEQUENCE",  //             0x01
"SET_POWER",       //             0x02
"QUERY_POWER",     //             0x03
"UNKNOWN", // 
NULL};

static char *pnp_strs[] = {
"START_DEVICE", //                 0x00
"QUERY_REMOVE_DEVICE", //          0x01
"REMOVE_DEVICE", //                0x02
"CANCEL_REMOVE_DEVICE", //         0x03
"STOP_DEVICE", //                  0x04
"QUERY_STOP_DEVICE", //            0x05
"CANCEL_STOP_DEVICE", //           0x06
"QUERY_DEVICE_RELATIONS", //       0x07
"QUERY_INTERFACE", //              0x08
"QUERY_CAPABILITIES", //           0x09
"QUERY_RESOURCES", //              0x0A
"QUERY_RESOURCE_REQUIREMENTS", //  0x0B
"QUERY_DEVICE_TEXT", //            0x0C
"FILTER_RESOURCE_REQUIREMENTS", // 0x0D
"UNKNOWN", // 
"READ_CONFIG", //                  0x0F
"WRITE_CONFIG", //                 0x10
"EJECT", //                        0x11
"SET_LOCK", //                     0x12
"QUERY_ID", //                     0x13
"QUERY_PNP_DEVICE_STATE", //       0x14
"QUERY_BUS_INFORMATION", //        0x15
"PAGING_NOTIFICATION", //          0x16
NULL};
#endif

/*----------------------------------------------------------------------
 SerialPnpDispatch -
    This is a dispatch routine for the IRPs that come to the driver with the
    IRP_MJ_PNP major code (plug-and-play IRPs).
|----------------------------------------------------------------------*/
NTSTATUS SerialPnpDispatch(IN PDEVICE_OBJECT devobj, IN PIRP Irp)
{
   PSERIAL_DEVICE_EXTENSION  Ext = devobj->DeviceExtension;
   //PDEVICE_OBJECT pdo = Ext->LowerDeviceObject;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   NTSTATUS                    status          = STATUS_NOT_SUPPORTED;
   BOOLEAN acceptingIRPs;
   int index;

   // dump out some debug info
   index = irpStack->MinorFunction;
   if (index > 0x16)
     index = 0x0e;

#ifdef DO_BUS_EXTENDER
   if (Ext->IsPDO)
   {
     MyKdPrint(D_Pnp,("Port PDO %s PnPIrp:%d,%s\n", 
             Ext->SymbolicLinkName, irpStack->MinorFunction,
        pnp_strs[index]))
     InterlockedIncrement(&Ext->PendingIRPCnt);
     return PnpPortPDO(devobj, Irp);
   }
   else
#endif
   {
     if (Ext->DeviceType == DEV_BOARD)
     {
       MyKdPrint(D_Pnp,("Board %s PnPIrp:%d,%s\n", 
               Ext->SymbolicLinkName, irpStack->MinorFunction,
               pnp_strs[index]))
     }
     else
     {
       MyKdPrint(D_Pnp,("Port %s PnPIrp:%d,%s\n", 
          Ext->SymbolicLinkName, irpStack->MinorFunction,
          pnp_strs[index]))
     }

     acceptingIRPs = SerialIRPPrologue(Ext);

#if 0
     if ((irpStack->MinorFunction != IRP_MN_REMOVE_DEVICE)
         && (irpStack->MinorFunction != IRP_MN_CANCEL_REMOVE_DEVICE)
         && (irpStack->MinorFunction != IRP_MN_STOP_DEVICE)
         && (irpStack->MinorFunction != IRP_MN_CANCEL_STOP_DEVICE)
         && (acceptingIRPs == FALSE))
     {
        MyKdPrint(D_Pnp,("Removed!\n"))
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        SerialCompleteRequest(Ext, Irp, IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;
     }
#endif

     if (Ext->DeviceType == DEV_BOARD)
     {
       return PnPBoardFDO(devobj, Irp);
     }
     else
     {
       //return PnPPortFDO(devobj, Irp);
       return PnPBoardFDO(devobj, Irp);
     }
   }
}

/*----------------------------------------------------------------------
 PnPBoardFDO - This handles both Board and Port FDO's
|----------------------------------------------------------------------*/
NTSTATUS PnPBoardFDO(IN PDEVICE_OBJECT devobj, IN PIRP Irp)
{
 PSERIAL_DEVICE_EXTENSION  Ext = devobj->DeviceExtension;
 PDEVICE_OBJECT pdo = Ext->LowerDeviceObject;
 PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
 NTSTATUS  status = STATUS_NOT_SUPPORTED;
 ULONG pendingIRPs;
 int pass_down = 1;

  ASSERT( devobj );
  ASSERT( Ext );

#if DBG
  if (* ((BYTE *)(Irp)) != 6)  // in signiture of irp
  {
    MyKdPrint(D_Pnp,("bad irp!!!\n"))
  }
#endif

  switch (irpStack->MinorFunction)
  {
    case IRP_MN_START_DEVICE:   // 0x00
      MyKdPrint(D_Pnp,("StartDevice\n"))
      status = SerialStartDevice(devobj, Irp);
//
// Is this were we should register and enable the device, or should it be in
// the PDO start? (see DoPnpAssoc(Pdo) in pnpadd.c)
//
      Irp->IoStatus.Status = status;
      pass_down = 0;  // already passed down
    break;

   case IRP_MN_STOP_DEVICE:    // 0x04
      // need to unhook from resources so system rebalance resources
      // on the fly.
      MyKdPrint(D_Pnp,("StopDevice\n"))
       //Ext->Flags |= SERIAL_FLAGS_STOPPED;

       Ext->PNPState = SERIAL_PNP_STOPPING;
       Ext->DevicePNPAccept |= SERIAL_PNPACCEPT_STOPPED;
       Ext->DevicePNPAccept &= ~SERIAL_PNPACCEPT_STOPPING;

      InterlockedDecrement(&Ext->PendingIRPCnt);  // after dec, =1

      pendingIRPs = InterlockedDecrement(&Ext->PendingIRPCnt); // after dec, =0

      if (pendingIRPs) {
         KeWaitForSingleObject(&Ext->PendingIRPEvent, Executive,
                               KernelMode, FALSE, NULL);
      }

      Ext->FdoStarted = FALSE;  // this should stop service of the device
#ifdef NT50

	  if (Ext->DeviceType != DEV_BOARD) {

		  // Disable the interface

          status = IoSetDeviceInterfaceState( &Ext->DeviceClassSymbolicName,
                                              FALSE);

          if (!NT_SUCCESS(status)) {

             MyKdPrint(D_Error,("Couldn't clear class association for %s\n",
	    	      UToC1(&Ext->DeviceClassSymbolicName)))
		  }
          else {

             MyKdPrint(D_PnpAdd, ("Cleared class association for device: %s\n and ", 
			      UToC1(&Ext->DeviceClassSymbolicName)))
		  }
	  }   
#endif

      // Re-increment the count for exit
      InterlockedIncrement(&Ext->PendingIRPCnt);  //after inc=1
      InterlockedIncrement(&Ext->PendingIRPCnt);  //after inc=2
      // exit this irp decr it to=1


      status = STATUS_SUCCESS;
      Irp->IoStatus.Status = STATUS_SUCCESS;
        //Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        //pass_down = 0;  // we are failing it
   break;

#if 0
   case IRP_MN_QUERY_DEVICE_RELATIONS:  // 0x7
     if ( irpStack->Parameters.QueryDeviceRelations.Type != BusRelations )
     {
       //
       // Verifier requires pass down is PDO present
       //

       if ( (Ext->DeviceType == DEV_BOARD) && (pdo == 0) )
       {
           status = STATUS_NOT_IMPLEMENTED;
           pass_down = 0;
       };
       break;
     }
     if (!Driver.NoPnpPorts)
     {
       if (Ext->DeviceType == DEV_BOARD)
       {
         status = BoardBusRelations(devobj, Irp);
       }
     }
   break;
#endif
#ifdef DO_BUS_EXTENDER
   case IRP_MN_QUERY_DEVICE_RELATIONS:  // 0x7
       //
       // Verifier requires pass down is PDO present
       //

     if ( (Ext->DeviceType == DEV_BOARD) && (pdo == 0) )
     {
         pass_down = 0;
     }
	 if ( irpStack->Parameters.QueryDeviceRelations.Type != BusRelations ) {

         status = STATUS_NOT_IMPLEMENTED;
		 break;
	 }
     if (!Driver.NoPnpPorts)
     {
       if (Ext->DeviceType == DEV_BOARD)
       {
         status = BoardBusRelations(devobj, Irp);
       }
     }
   break;
#endif

#ifdef DO_BRD_FILTER_RES_REQ
   case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:  // 0x0D
     if (Ext->DeviceType == DEV_BOARD)
     {
       status = BoardFilterResReq(devobj, Irp);
       pass_down = 0;  // already passed down
     }
   break;
#endif

   case IRP_MN_QUERY_STOP_DEVICE: //            0x05
     MyKdPrint(D_Pnp,("QueryStopDevice\n"))

     status = STATUS_SUCCESS;
     if (Ext->DeviceType == DEV_BOARD)
     {
       if (is_board_in_use(Ext))
         status = STATUS_DEVICE_BUSY;
     }
     else
     {
       if (Ext->DeviceIsOpen)
         status = STATUS_DEVICE_BUSY;
     }

     if (status == STATUS_DEVICE_BUSY)
     {
       MyKdPrint(D_Pnp,("Can't Remove, Busy\n"))
       Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
       pass_down = 0;  // we are failing it out, no need to pass down
     }
     else
     {
       Ext->PNPState = SERIAL_PNP_QSTOP;
         // this is hosing up things(kpb)
         //Ext->DevicePNPAccept |= SERIAL_PNPACCEPT_STOPPING;
       Irp->IoStatus.Status = STATUS_SUCCESS;
       status = STATUS_SUCCESS;
     }
   break;

   case IRP_MN_CANCEL_STOP_DEVICE:     // 0x06
     MyKdPrint(D_Pnp,("CancelStopDevice\n"))
     if (Ext->PNPState == SERIAL_PNP_QSTOP)
     {
       Ext->PNPState = SERIAL_PNP_STARTED;
       Ext->DevicePNPAccept &= ~SERIAL_PNPACCEPT_STOPPING;
     }
     Irp->IoStatus.Status = STATUS_SUCCESS;
     status = STATUS_SUCCESS;
   break;

   case IRP_MN_CANCEL_REMOVE_DEVICE:
     MyKdPrint(D_Pnp,("CancelRemoveDevice\n"))

     // Restore the device state

     Ext->PNPState = SERIAL_PNP_STARTED;
     Ext->DevicePNPAccept &= ~SERIAL_PNPACCEPT_REMOVING;

     Irp->IoStatus.Status = STATUS_SUCCESS;
     status = STATUS_SUCCESS;
   break;

   case IRP_MN_QUERY_REMOVE_DEVICE:  // 0x01
     // If we were to fail this call then we would need to complete the
     // IRP here.  Since we are not, set the status to SUCCESS and
     // call the next driver.
     MyKdPrint(D_Pnp,("QueryRemoveDevice\n"))
     status = STATUS_SUCCESS;
     if (Ext->DeviceType == DEV_BOARD)
     {
       if (is_board_in_use(Ext))
         status = STATUS_DEVICE_BUSY;
     }
     else
     {
       if (Ext->DeviceIsOpen)
         status = STATUS_DEVICE_BUSY;
     }

     if (status == STATUS_DEVICE_BUSY)
     {
       MyKdPrint(D_Pnp,("Can't Remove, Busy\n"))
       Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
       pass_down = 0;  // we are failing it out, no need to pass down
     }
     else
     {
       Ext->PNPState = SERIAL_PNP_QREMOVE;
       Ext->DevicePNPAccept |= SERIAL_PNPACCEPT_REMOVING;
       Irp->IoStatus.Status = STATUS_SUCCESS;
       status = STATUS_SUCCESS;
     }
   break;

   case IRP_MN_REMOVE_DEVICE:  // 0x02
     // If we get this, we have to remove
     // Mark as not accepting requests
     Ext->DevicePNPAccept |= SERIAL_PNPACCEPT_REMOVING;


     // Complete all pending requests
     SerialKillPendingIrps(devobj);

       // Pass the irp down
       //WaitForLowerPdo(devobj, Irp);

     Irp->IoStatus.Status = STATUS_SUCCESS;

     MyKdPrint(D_Pnp,("RemoveDevice\n"))
     IoSkipCurrentIrpStackLocation (Irp);
       //IoCopyCurrentIrpStackLocationToNext(Irp);

       // We do decrement here because we incremented on entry here.
       //SerialIRPEpilogue(Ext);
     SerialIoCallDriver(Ext, pdo, Irp);

     // Wait for any pending requests we raced on.
     pendingIRPs = InterlockedDecrement(&Ext->PendingIRPCnt);

     MyKdPrint(D_Pnp,("Remove, C\n"))
     if (pendingIRPs) {
       MyKdPrint(D_Pnp,("Irp Wait\n"))
       KeWaitForSingleObject(&Ext->PendingIRPEvent, Executive,
          KernelMode, FALSE, NULL);
     }

     // Remove us
     SerialRemoveFdo(devobj);
     status = STATUS_SUCCESS;
     // MyKdPrint(D_Pnp,("End PnPDispatch(Remove)\n"))
   return status;   // BAIL


   case IRP_MN_QUERY_INTERFACE:         // 0x8
   case IRP_MN_QUERY_RESOURCES :       // 0x0A
   case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:  // 0x0B
   case IRP_MN_READ_CONFIG:            // 0x0f
   case IRP_MN_WRITE_CONFIG:           // 0x10
   case IRP_MN_EJECT:                  // 0x11
   case IRP_MN_SET_LOCK:               // 0x12
   //case IRP_MN_PNP_DEVICE_STATE:       // 0x14
   case IRP_MN_QUERY_BUS_INFORMATION:  // 0x15
   //case IRP_MN_PAGING_NOTIFICATION:    // 0x16
   default:
      MyKdPrint(D_Pnp,("Unhandled\n"));
      // all these get passed down, we don't set the status return code
   break;
   }   // switch (irpStack->MinorFunction)

#if DBG
  if (* ((BYTE *)(Irp)) != 6)  // in signiture of irp
  {
    MyKdPrint(D_Pnp,("bad irp b!!!\n"))
  }
#endif
   if (pass_down)
   {
      MyKdPrint(D_Pnp,(" Send irp down\n"))
      // Pass to driver beneath us
      IoSkipCurrentIrpStackLocation(Irp);
      status = SerialIoCallDriver(Ext, pdo, Irp);
   }
   else
   {
      Irp->IoStatus.Status = status;
      //MyKdPrint(D_Pnp,(" Complete irp\n"))
      SerialCompleteRequest(Ext, Irp, IO_NO_INCREMENT);
   }

   // MyKdPrint(D_Pnp,(" End PnPDispatch\n"))

   return status;
}


#ifdef DO_BUS_EXTENDER
/*----------------------------------------------------------------------
  PnpPortPDO -
|----------------------------------------------------------------------*/
NTSTATUS PnpPortPDO(IN PDEVICE_OBJECT devobj, IN PIRP Irp)
{
   PSERIAL_DEVICE_EXTENSION    Ext = devobj->DeviceExtension;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   NTSTATUS status = Irp->IoStatus.Status;

   switch (irpStack->MinorFunction)
   {
     case IRP_MN_START_DEVICE:   // 0x00
       status = STATUS_SUCCESS;
     break;

     case IRP_MN_STOP_DEVICE:
       status = STATUS_SUCCESS;
     break;

     case IRP_MN_REMOVE_DEVICE:
       MyKdPrint(D_Pnp,("Remove PDO\n"))
       // shut down everything, call iodelete device
       status = STATUS_SUCCESS;
     break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
       status = STATUS_SUCCESS;
     break;


     case IRP_MN_QUERY_CAPABILITIES: {  // x09
       PDEVICE_CAPABILITIES    deviceCapabilities;

        deviceCapabilities=irpStack->Parameters.DeviceCapabilities.Capabilities;
        MyKdPrint(D_Pnp,("Report Caps.\n"))
        // Set the capabilities.
        deviceCapabilities->Version = 1;
        deviceCapabilities->Size = sizeof (DEVICE_CAPABILITIES);

        // We cannot wake the system.
        deviceCapabilities->SystemWake = PowerSystemUnspecified;
        deviceCapabilities->DeviceWake = PowerDeviceUnspecified;

        // We have no latencies
        deviceCapabilities->D1Latency = 0;
        deviceCapabilities->D2Latency = 0;
        deviceCapabilities->D3Latency = 0;

        // No locking or ejection
        deviceCapabilities->LockSupported = FALSE;
        deviceCapabilities->EjectSupported = FALSE;

        // Device can be physically removed.
        // Technically there is no physical device to remove, but this bus
        // driver can yank the PDO from the PlugPlay system, when ever it
        // receives an IOCTL_GAMEENUM_REMOVE_PORT device control command.
        //deviceCapabilities->Removable = TRUE;
        // we switch this to FALSE to emulate the stock com port behavior, kpb
        deviceCapabilities->Removable = FALSE;

        // not Docking device
        deviceCapabilities->DockDevice = FALSE;
 
        // BUGBUG: should we do uniqueID???
        deviceCapabilities->UniqueID = FALSE;

        status = STATUS_SUCCESS;
      }
     break;

     case IRP_MN_QUERY_DEVICE_RELATIONS:  // 0x7
      if (irpStack->Parameters.QueryDeviceRelations.Type !=
          TargetDeviceRelation)
        break;  //

      {
         PDEVICE_RELATIONS pDevRel;

         // No one else should respond to this since we are the PDO
         ASSERT(Irp->IoStatus.Information == 0);
         if (Irp->IoStatus.Information != 0) {
            break;
         }

         pDevRel = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));

         if (pDevRel == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
         }

         pDevRel->Count = 1;
         pDevRel->Objects[0] = devobj;
         ObReferenceObject(devobj);

         status = STATUS_SUCCESS;
         Irp->IoStatus.Information = (ULONG_PTR)pDevRel;
      }
     break;

     case IRP_MN_QUERY_ID:  // 0x13
     {
       switch (irpStack->Parameters.QueryId.IdType)
       {
        case BusQueryInstanceID:
        {
           WCHAR *wstr;
           CHAR our_id[40];

           // Build an instance ID.  This is what PnP uses to tell if it has
           // seen this thing before or not.
           // its used to form the ENUM\ key name along with the DeviceID.
           //Sprintf(our_id, "Ctm_%s", Ext->NtNameForPort);
           Sprintf(our_id, "Port%04d", PortExtToIndex(Ext,0));
           MyKdPrint(D_Pnp,("InstanceId:%s\n", our_id))
           wstr = str_to_wstr_dup(our_id, PagedPool);
           if ( wstr ) {
             // as per serenum bus enumerator:
             status = STATUS_SUCCESS;
           } else {
             status = STATUS_INSUFFICIENT_RESOURCES;
           }
           Irp->IoStatus.Information = (ULONG)wstr;
        }
        break;

        case BusQueryDeviceID:
        {
           // This is the name used under ENUM to form the device instance
           // name under which any new PDO nodes will be created.
           // after find new hardware install we find this as an example
           // new port node under ENUM:
           // Enum\CtmPort\RDevice\6&Port0000
           // Enum\CtmPort\RDevice\6&Port0000\Control
           // Enum\CtmPort\RDevice\6&Port0000\Device Parameters
           // Enum\CtmPort\RDevice\6&Port0000\LogConf

           WCHAR *wstr;
           CHAR our_id[40];

#ifdef S_VS
           strcpy(our_id, "CtmPort\\VSPORT");
#else
           strcpy(our_id, "CtmPort\\RKPORT");
#endif
           wstr = str_to_wstr_dup(our_id, PagedPool);
           MyKdPrint(D_Pnp,("DevID:%s\n", our_id))

           Irp->IoStatus.Information = (ULONG)wstr;
           if ( wstr ) {
             status = STATUS_SUCCESS;
           } else {
             status = STATUS_INSUFFICIENT_RESOURCES;
           }
        }
        break;

        case BusQueryHardwareIDs:
        {
            // return a multi WCHAR (null terminated) string (null terminated)
            // array for use in matching hardare ids in inf files;
           WCHAR *wstr;
           CHAR our_id[40];

#ifdef S_VS
           Sprintf(our_id, "CtmvPort%04d",
              PortExtToIndex(Ext, 0 /* driver_flag */) );
#else
           Sprintf(our_id, "CtmPort%04d", 
              PortExtToIndex(Ext, 0 /* driver_flag */) );
#endif
           MyKdPrint(D_Pnp,("HrdwrID:%s\n", our_id))
           wstr = str_to_wstr_dup(our_id, PagedPool);
           Irp->IoStatus.Information = (ULONG)wstr;
           if ( wstr ) {
             status = STATUS_SUCCESS;
           } else {
             status = STATUS_INSUFFICIENT_RESOURCES;
           }
        }  //BusQueryHardwareIDs
        break;

        case BusQueryCompatibleIDs:
        {
#if 0
           WCHAR *wstr;
           CHAR our_id[40];

           // The generic ids for installation of this pdo.

           Sprintf(our_id, "Cpt_CtmPort0001");
           MyKdPrint(D_Pnp,("CompID:%s\n", our_id))
           wstr = str_to_wstr_dup(our_id, PagedPool);

           Irp->IoStatus.Information = (ULONG)wstr;
           status = STATUS_SUCCESS;
#endif
           // no compatible id's
           Irp->IoStatus.Information = 0;
           status = STATUS_SUCCESS;
        }
        break;
        default:
           MyKdPrint(D_Pnp,(" UnHandled\n"))
           // Irp->IoStatus.Information = 0;
           // status = STATUS_SUCCESS;
        break;

       }  // switch IdType
     }  // IRP_MN_QUERY_ID
     break;

     case IRP_MN_QUERY_DEVICE_TEXT: // 0x0C
       MyKdPrint(D_Pnp,("QueryDevText\n"))

       if (irpStack->Parameters.QueryDeviceText.DeviceTextType
            != DeviceTextDescription)
       {
         MyKdPrint(D_Pnp,(" Unhandled Text Type\n"))
         break;
       }

       {
           // this is put in the Found New Hardware dialog box message.
           WCHAR *wstr;
#if DBG
           if (Irp->IoStatus.Information != 0)
           {
             MyKdPrint(D_Error,("StrExists!\n"))
           }
#endif

#ifdef S_VS
           wstr = str_to_wstr_dup("Comtrol VS Port", PagedPool);
#else
           wstr = str_to_wstr_dup("Comtrol Port", PagedPool);
#endif
           Irp->IoStatus.Information = (ULONG)wstr;
           if ( wstr ) {
             status = STATUS_SUCCESS;
           } else {
             status = STATUS_INSUFFICIENT_RESOURCES;
           }
       }
     break;  // IRP_MN_QUERY_DEVICE_TEXT

     default:
       //MyKdPrint(D_Pnp,(" PDO Unhandled\n"))
     break;
   }

   Irp->IoStatus.Status = status;
   InterlockedDecrement(&Ext->PendingIRPCnt);
   IoCompleteRequest (Irp, IO_NO_INCREMENT);
   MyKdPrint(D_Pnp,(" PDO Dispatch End\n"))
   return status;
}

/*----------------------------------------------------------------------
 BoardBusRelations -  handle  IRP_MN_QUERY_DEVICE_RELATIONS:  // 0x7
  for our board FDO entity.
|----------------------------------------------------------------------*/
NTSTATUS BoardBusRelations(IN PDEVICE_OBJECT devobj, IN PIRP Irp)
{
 PSERIAL_DEVICE_EXTENSION  Ext = devobj->DeviceExtension;
 PDEVICE_OBJECT pdo = Ext->LowerDeviceObject;
 PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
 NTSTATUS                    status          = STATUS_NOT_SUPPORTED;
 ULONG i, length, NumPDOs;
 PDEVICE_RELATIONS   relations;
 PSERIAL_DEVICE_EXTENSION ext;

  ASSERT( devobj );

  switch (irpStack->Parameters.QueryDeviceRelations.Type)
  {
    case BusRelations:
      MyKdPrint(D_Pnp,("BusRelations\n"))
      // Tell the plug and play system about all the PDOs.
      //
      // There might also be device relations below and above this FDO,
      // so, be sure to propagate the relations from the upper drivers.
      //
      // No Completion routine is needed so long as the status is preset
      // to success.  (PDOs complete plug and play irps with the current
      // IoStatus.Status and IoStatus.Information as the default.)
      //

      NumPDOs = 0;  // count the number of pdo's
      // count up pdo's for device
      ext = Ext->port_pdo_ext;
      while (ext != NULL)
      {
        ++NumPDOs;
        ext = ext->port_ext;
      }
      // The current number of PDOs
      i = 0;
      if (Irp->IoStatus.Information != 0)
        i = ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Count;

      MyKdPrint(D_Pnp, ("Num PDOs:%d + %d\n", i, NumPDOs))

      length = sizeof(DEVICE_RELATIONS) +
              ((NumPDOs + i) * sizeof (PDEVICE_OBJECT));

      relations = (PDEVICE_RELATIONS) ExAllocatePool (NonPagedPool, length);

      if (NULL == relations) {
         return STATUS_INSUFFICIENT_RESOURCES;
      }

      // Copy in the device objects so far
      if (i) {
          RtlCopyMemory (
                relations->Objects,
                ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Objects,
                i * sizeof (PDEVICE_OBJECT));
      }
      relations->Count = NumPDOs + i;

      //
      // For each PDO on this bus add a pointer to the device relations
      // buffer, being sure to take out a reference to that object.
      // The PlugPlay system will dereference the object when it is done with
      // it and free the device relations buffer.
      //
      ext = Ext->port_pdo_ext;
      while (ext != NULL)
      {
        relations->Objects[i++] = ext->DeviceObject;
        ObReferenceObject (ext->DeviceObject); // add 1 to lock on this object
        ext = ext->port_ext;
      }

      // Set up and pass the IRP further down the stack
      Irp->IoStatus.Status = STATUS_SUCCESS;

      if (0 != Irp->IoStatus.Information) {
          ExFreePool ((PVOID) Irp->IoStatus.Information);
      }
      Irp->IoStatus.Information = (ULONG) relations;
    break;

    case EjectionRelations:
     MyKdPrint(D_Pnp, ("EjectRelations\n"))
    break;

    case PowerRelations:
     MyKdPrint(D_Pnp,("PowerRelations\n"))
    break;

    case RemovalRelations:
     MyKdPrint(D_Pnp,("RemovalRelations\n"))
    break;

    case TargetDeviceRelation:
     MyKdPrint(D_Pnp,("TargetDeviceRelations\n"))
    break;

    default:
     MyKdPrint(D_Pnp,("UnknownRelations\n"))
    break;
  }  // switch .Type

  status = STATUS_SUCCESS;
  return status;
}

#endif

/*----------------------------------------------------------------------
 WaitForLowerPdo -
|----------------------------------------------------------------------*/
NTSTATUS WaitForLowerPdo(IN PDEVICE_OBJECT fdo, IN PIRP Irp)
{
 PSERIAL_DEVICE_EXTENSION  Ext = fdo->DeviceExtension;
 PDEVICE_OBJECT pdo = Ext->LowerDeviceObject;
 NTSTATUS status;
 KEVENT Event;

  KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

  IoCopyCurrentIrpStackLocationToNext(Irp);
  IoSetCompletionRoutine(Irp, SerialSyncCompletion, &Event,
                         TRUE, TRUE, TRUE);
  status = IoCallDriver(pdo, Irp);

  // Wait for lower drivers to be done with the Irp
  if (status == STATUS_PENDING)
  {
    MyKdPrint(D_Pnp,("WaitPend\n"))
    KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE,
                            NULL);
    status = Irp->IoStatus.Status;
  }

  if (!NT_SUCCESS(status))
  {
    MyKdPrint(D_Pnp,("WaitErr\n"))
    return status;
  }
  return 0;
}

/*----------------------------------------------------------------------
 SerialPowerDispatch -
    This is a dispatch routine for the IRPs that come to the driver with the
    IRP_MJ_POWER major code (power IRPs).

Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request

Return Value:
    The function value is the final status of the call
|----------------------------------------------------------------------*/
NTSTATUS SerialPowerDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
  PSERIAL_DEVICE_EXTENSION Ext = DeviceObject->DeviceExtension;
  PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
  NTSTATUS status = STATUS_SUCCESS;
  BOOLEAN hook_it = FALSE;
  PDEVICE_OBJECT pdo = Ext->LowerDeviceObject;
  BOOLEAN acceptingIRPs = TRUE;
  int index;

   // dump out some debug info
   index = irpStack->MinorFunction;
   if (index > 0x3)
     index = 0x4;

   if (Ext->IsPDO)
   {
#if DBG
     MyKdPrint(D_PnpPower,("Port PDO PowerIrp:%d,%s\n", irpStack->MinorFunction,
	power_strs[index]))
#endif
     return Serial_PDO_Power (DeviceObject, Irp);
   }

   // else it's a FDO
#if DBG
   if (Ext->DeviceType == DEV_BOARD)
   {
     MyKdPrint(D_PnpPower,("Board PowerIrp:%d,%s\n", irpStack->MinorFunction,
        power_strs[index]))
   }
   else
   {
     MyKdPrint(D_PnpPower,("Port PowerIrp:%d,%s\n", irpStack->MinorFunction,
        power_strs[index]))
   }
#endif
   return Serial_FDO_Power (DeviceObject, Irp);
}


/*----------------------------------------------------------------------
 Serial_FDO_Power - Handle board and port FDO power handling.
|----------------------------------------------------------------------*/
NTSTATUS Serial_FDO_Power (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
  PSERIAL_DEVICE_EXTENSION Ext = DeviceObject->DeviceExtension;
  PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
  NTSTATUS status = STATUS_SUCCESS;
  BOOLEAN hook_it = FALSE;
  PDEVICE_OBJECT pdo = Ext->LowerDeviceObject;
  PDEVICE_OBJECT pPdo = Ext->Pdo;
  BOOLEAN acceptingIRPs = TRUE;
  POWER_STATE         powerState;
  POWER_STATE_TYPE    powerType;
  int ChangePower = 0;
  int fail_it = 0;

   powerType = irpStack->Parameters.Power.Type;
   powerState = irpStack->Parameters.Power.State;
   status      = STATUS_SUCCESS;

   acceptingIRPs = SerialIRPPrologue(Ext);

   if (acceptingIRPs == FALSE)
   {
     MyKdPrint(D_PnpPower,("Removed!\n"))
     status = STATUS_NO_SUCH_DEVICE;  // ?????????????
     fail_it = 1;
   }
   else
   {
     switch (irpStack->MinorFunction)
     {
       case IRP_MN_SET_POWER:
         MyKdPrint(D_PnpPower,("SET_POWER Type %d, SysState %d, DevStat %d\n",powerType,powerState.SystemState,powerState.DeviceState));
         // Perform different ops if it was system or device
         switch (irpStack->Parameters.Power.Type)
         {
           case DevicePowerState:
             // do power up & down work on device
             ChangePower = 1;
           break;
  
           case SystemPowerState:
             //if (pDevExt->OwnsPowerPolicy != TRUE) {
             //    status = STATUS_SUCCESS;
             //    goto PowerExit;
             // }
  

             ChangePower = 1;
             switch (irpStack->Parameters.Power.State.SystemState)
             {
               case PowerSystemUnspecified:
                 powerState.DeviceState = PowerDeviceUnspecified;
               break;
  
               case PowerSystemWorking:
                 powerState.DeviceState = PowerDeviceD0;
               break;
  
               case PowerSystemSleeping1:
               case PowerSystemSleeping2:
               case PowerSystemSleeping3:
               case PowerSystemHibernate:
               case PowerSystemShutdown:
               case PowerSystemMaximum:
               default:
                 powerState.DeviceState = PowerDeviceD3;
               break;
             }
           break;  // end case SystemPowerState
  
         }  // end switch
  
        if (ChangePower)
        {
          // If we are already in the requested state, just pass the IRP down
          if (Ext->PowerState == powerState.DeviceState)
          {
             MyKdPrint(D_PnpPower,(" Same\n"))
             status      = STATUS_SUCCESS;
             Irp->IoStatus.Status = status;
             ChangePower = 0;
          }
        }
  
        if (ChangePower)
        {
          MyKdPrint(D_PnpPower,("ExtPowerState %d, DeviceState %d\n",Ext->PowerState,powerState.DeviceState));
          switch (powerState.DeviceState)
          {
            case PowerDeviceD0: 
              if (Ext->DeviceType == DEV_BOARD)
              {
                // powering up board.
                MyKdPrint(D_PnpPower,(" Hook\n"))
                ASSERT(Ext->LowerDeviceObject);
                hook_it = TRUE;
              }
            break;
  
            case PowerDeviceD1:  
            case PowerDeviceD2: 
            case PowerDeviceD3:
            default:
              // we should be doing this on the way up in the hook routine.
              MyKdPrint(D_PnpPower,(" PwDown\n"))
              // Before we power down, call PoSetPowerState
              PoSetPowerState(DeviceObject, powerType, powerState);
  
              // Shut it down
              //.....
              //
       
              Ext->PowerState = powerState.DeviceState; // PowerDeviceD0;
              if (Ext->DeviceType == DEV_BOARD)
              {
                MyKdPrint(D_PnpPower,(" PwDown Board\n"))
                // shut some things down, so it comes back up ok
#if S_RK
                Ext->config->RocketPortFound = 0;   // this tells if its started
#endif
                Ext->config->HardwareStarted = FALSE;
              }
              Irp->IoStatus.Status = STATUS_SUCCESS;
              status      = STATUS_SUCCESS;
            break;
          }   // switch (IrpSp->Parameters.Power.State.DeviceState)
        }  // ChangePower
       break;  // SET_POWER
  
       case IRP_MN_QUERY_POWER:
         MyKdPrint(D_PnpPower,(" QueryPower SystemState 0x%x\n",irpStack->Parameters.Power.State.SystemState))
           // if they want to go to a power-off state(sleep, hibernate, etc)
         if (irpStack->Parameters.Power.State.SystemState != PowerSystemWorking)
         {
           MyKdPrint(D_PnpPower,(" QueryPower turn off\n"))
           // only handle power logic for the board as a whole
           if (Ext->DeviceType == DEV_BOARD)
           {
             MyKdPrint(D_PnpPower,(" PwDown Board\n"))
             // if a port is open and being used, then fail the request
#if 0
// try to get the wake up restore of hardware working...
// kpb, 2-7-99
             if (is_board_in_use(Ext))
             {
               MyKdPrint(D_PnpPower,(" PwDown Board In Use!\n"))
               // if wants to powerdown
               // BUGBUG:, refuse hibernation
               status = STATUS_NO_SUCH_DEVICE;  // ?
               fail_it = 1;
             }
             else
#endif
             {
               MyKdPrint(D_PnpPower,(" PwDown Board, allow it!\n"))
#ifdef MTM_CLOSE_NIC_ATTEMPT
               if ( Driver.nics ) {
                 for( i=0; i<VS1000_MAX_NICS; i++ ) {
                   if ( Driver.nics[i].NICHandle ) {
                     MyKdPrint(D_PnpPower,("Closing Nic %d\n",i))
                     NicClose( &Driver.nics[i] );
                   }
                 }
               }
#endif
             }
           }
         }
         if (!fail_it)
         {
           status = STATUS_SUCCESS;
           Irp->IoStatus.Status = status;
         }
       break;
       //case IRP_MN_WAIT_WAKE:
         // Here is where support for a
         // serial device (like a modem) waking the system when the
         // phone rings.
       //case IRP_MN_POWER_SEQUENCE:
       default:
       break;
     }   // switch (irpStack->MinorFunction)
   }   // else, handle irp

   if (fail_it)
   {
     // status assumed set above
     PoStartNextPowerIrp (Irp);
     Irp->IoStatus.Information = 0;
     Irp->IoStatus.Status = status;
     InterlockedDecrement(&Ext->PendingIRPCnt);
     IoCompleteRequest (Irp, IO_NO_INCREMENT);
     return status;
   }

   // Pass to the lower driver
   if (hook_it)
   {
     IoCopyCurrentIrpStackLocationToNext (Irp);
     MyKdPrint(D_PnpPower,(" Hooked\n"))
     IoSetCompletionRoutine(Irp, OurPowerCompletion, NULL, TRUE, TRUE, TRUE);
	 MyKdPrint(D_PnpPower,(" Ready to send Irp 0x%x to PDO 0x%x\n", Irp, pdo))
     status = PoCallDriver(pdo, Irp);
     // hooking proc is responsible for decrementing reference count in ext
     // and calling PoStartNextPowerIrp().
   }
   else
   {
     IoCopyCurrentIrpStackLocationToNext (Irp);
     /// try this ^ instead ---- IoSkipCurrentIrpStackLocation (Irp);
     MyKdPrint(D_PnpPower,(" Passed\n"))
     PoStartNextPowerIrp(Irp);
     status = PoCallDriver(pdo, Irp);
     SerialIRPEpilogue(Ext);
   }

   MyKdPrint(D_PnpPower,("End PowerDisp\n"))
   return status;
}

/*----------------------------------------------------------------------
 Serial_PDO_Power - Handle port PDO power handling.
|----------------------------------------------------------------------*/
NTSTATUS Serial_PDO_Power (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
  PSERIAL_DEVICE_EXTENSION Ext = DeviceObject->DeviceExtension;
  PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
  NTSTATUS status = STATUS_SUCCESS;
  BOOLEAN hook_it = FALSE;
  PDEVICE_OBJECT pdo = Ext->LowerDeviceObject;
  BOOLEAN acceptingIRPs = TRUE;
  POWER_STATE         powerState;
  POWER_STATE_TYPE    powerType;

   powerType = irpStack->Parameters.Power.Type;
   powerState = irpStack->Parameters.Power.State;
   status      = STATUS_SUCCESS;


     switch (irpStack->MinorFunction)
     {
       case IRP_MN_SET_POWER:
        if (powerType == SystemPowerState)
        {
           MyKdPrint(D_PnpPower,(" SysPower\n"))
           status      = STATUS_SUCCESS;
           Irp->IoStatus.Status = status;
           break;
        }

        if (powerType != DevicePowerState)
        {
          MyKdPrint(D_PnpPower,(" OtherType\n"))
          // They asked for a system power state change which we can't do.
          // Pass it down to the lower driver.
          status      = STATUS_SUCCESS;
          Irp->IoStatus.Status = status;
          break;
        }

        // If we are already in the requested state, just pass the IRP down
        if (Ext->PowerState == powerState.DeviceState)
        {
          MyKdPrint(D_PnpPower,(" Same\n"))
          status      = STATUS_SUCCESS;
          Irp->IoStatus.Status = status;
          break;
        }

        MyKdPrint(D_PnpPower,(" Set\n"))
        Ext->PowerState = powerState.DeviceState; // PowerDeviceD0;
        PoSetPowerState(DeviceObject, powerType, powerState);
      break;

      case IRP_MN_QUERY_POWER:
        status = STATUS_SUCCESS;
      break;

      case IRP_MN_WAIT_WAKE:
      case IRP_MN_POWER_SEQUENCE:
      default:
         MyKdPrint(D_PnpPower,("Not Imp!\n"))
         status = STATUS_NOT_IMPLEMENTED;
      break;
     }

     Irp->IoStatus.Status = status;
     PoStartNextPowerIrp (Irp);
     IoCompleteRequest (Irp, IO_NO_INCREMENT);
     MyKdPrint(D_PnpPower,("End PDO PowerDisp\n"))
     return status;
}

/*----------------------------------------------------------------------
 SerialStartDevice -
    This routine first passes the start device Irp down the stack then
    it picks up the resources for the device, ititializes, puts it on any
    appropriate lists (i.e shared interrupt or interrupt status) and 
    connects the interrupt.

Arguments:

    Fdo - Pointer to the functional device object for this device
    Irp - Pointer to the IRP for the current request

Return Value:
    Return status
|----------------------------------------------------------------------*/
NTSTATUS SerialStartDevice(
        IN PDEVICE_OBJECT Fdo,
        IN PIRP Irp)
{
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   NTSTATUS status = STATUS_NOT_IMPLEMENTED;
   PSERIAL_DEVICE_EXTENSION Ext = Fdo->DeviceExtension;
   PDEVICE_OBJECT pdo = Ext->LowerDeviceObject;

   MyKdPrint(D_Pnp,("SerialStartDevice\n"))

   // Set up the external naming and create the symbolic link
   // Pass this down to the Pdo
   status = WaitForLowerPdo(Fdo, Irp);

   status = STATUS_SUCCESS;
   // Do the serial specific items to start the device
   status = SerialFinishStartDevice(Fdo,
            irpStack->Parameters.StartDevice.AllocatedResources,
            irpStack->Parameters.StartDevice.AllocatedResourcesTranslated);

   Irp->IoStatus.Status = status;
   MyKdPrint(D_Pnp,("End Start Dev\n"))
   return status;
}

/*----------------------------------------------------------------------
 SerialSyncCompletion -
|----------------------------------------------------------------------*/
NTSTATUS SerialSyncCompletion(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP Irp,
                       IN PKEVENT SerialSyncEvent
                       )
{
   KeSetEvent(SerialSyncEvent, IO_NO_INCREMENT, FALSE);
   return STATUS_MORE_PROCESSING_REQUIRED;
}

/*----------------------------------------------------------------------
 SerialFinishStartDevice -
    This routine starts driver hardware.  On the RocketPort, this is
    a board, or a port.  On the VS, this would be the whole VS driver
    (all boxes) or a individual port.

    A Pnp ADDDEVICE call(in pnpadd.c) should have been seen before this
    to setup the driver.  After this, we may see Starts or Stops on the
    hardware, which the OS may start and stop to change resource assignments,
    etc.

Arguments:

   Fdo         -  Pointer to the Functional Device Object that is starting
   resourceList   -  Pointer to the untranslated resources needed by this device
   trResourceList -  Pointer to the translated resources needed by this device
   PUserData      -  Pointer to the user-specified resources/attributes 
   
  Return Value:
    STATUS_SUCCESS on success, something else appropriate on failure
|----------------------------------------------------------------------*/
NTSTATUS SerialFinishStartDevice(IN PDEVICE_OBJECT Fdo,
           IN PCM_RESOURCE_LIST resourceList,
           IN PCM_RESOURCE_LIST trResourceList)
{
   PSERIAL_DEVICE_EXTENSION Ext = Fdo->DeviceExtension;
   NTSTATUS status;
   DEVICE_CONFIG *pConfig;
   PSERIAL_DEVICE_EXTENSION newExtension = NULL;
   PDEVICE_OBJECT NewDevObj;
   int ch;
   int is_fdo = 1;
#ifdef NT50
   PWSTR  iBuffer;
#endif

   MyKdPrint(D_Pnp,("SerialFinishStartDevice\n"))

   pConfig = Ext->config;

   MyKdPrint(D_Pnp,("ChkPt A\n"))

   if (Ext->DeviceType != DEV_BOARD)
   {
     MyKdPrint(D_Pnp,("Start PnpPort\n"))
     Ext->FdoStarted     = TRUE;  // i don't thinks this is used on ports
#ifdef NT50
     // Create a symbolic link with IoRegisterDeviceInterface() 
     // 
     status = IoRegisterDeviceInterface( Ext->Pdo,
	                                     (LPGUID)&GUID_CLASS_COMPORT,
		 							     NULL,
									     &Ext->DeviceClassSymbolicName );

     if (!NT_SUCCESS(status)) {

        MyKdPrint(D_Error,("Couldn't register class association\n"))
        Ext->DeviceClassSymbolicName.Buffer = NULL;
	 }
     else {

       MyKdPrint(D_Init, ("Registering class association for:\n PDO:0x%8x\nSymLink %s\n",
		         Ext->Pdo, UToC1(&Ext->DeviceClassSymbolicName)))
	 }

      // Now set the symbolic link for the interface association 
      //

     status = IoSetDeviceInterfaceState( &Ext->DeviceClassSymbolicName,
                                         TRUE);

     if (!NT_SUCCESS(status)) {

        MyKdPrint(D_Error,("Couldn't set class association for %s\n",
	    	 UToC1(&Ext->DeviceClassSymbolicName)))
	 }
     else {

        MyKdPrint(D_PnpAdd, ("Enable class association for device: %s\n", 
			 UToC1(&Ext->DeviceClassSymbolicName)))
	 }

#if 0
     // Strictly for verification - get the entire list of COM class interfaces
	 // for up to 6 COM ports

	 status = IoGetDeviceInterfaces( (LPGUID)&GUID_CLASS_COMPORT, 
		                             NULL, // No PDO - get 'em all
                                     0,
									 &iBuffer );

     if (!NT_SUCCESS(status)) {

        MyKdPrint(D_Error,("Couldn't get interface list for GUID_CLASS_COMPORT\n"))
	 }
     else {

		PWCHAR pwbuf = iBuffer;
		char cbuf[128];
		int  j = 0;
		int  ofs = 0;

		while ( (pwbuf != 0) && (j < 8) ){

           WStrToCStr( cbuf, pwbuf, sizeof(cbuf) );
        
		   MyKdPrint(D_Pnp, ("COM port interface %d: %s\n", j, cbuf))

		   ofs += strlen(cbuf) + 1;
		   pwbuf = &iBuffer[ofs];
		   j++;
        }
		ExFreePool(iBuffer);
	 }
#endif

#endif

     status = STATUS_SUCCESS;
     return status;
   }

   if (Ext->FdoStarted == TRUE)
   {
     MyKdPrint(D_Error,("ReStart PnpBrd\n"))
     status = STATUS_SUCCESS;
     return status;
   }

   if (!Driver.NoPnpPorts)
      is_fdo = 0;  // eject PDOs representing port hardware.

   // Get the configuration info for the device.
#ifdef S_RK
   status = RkGetPnpResourceToConfig(Fdo, resourceList, trResourceList,
                              pConfig);

   if (!NT_SUCCESS (status)) {
     Eprintf("StartErr 1N");
     return status;
   }

#ifdef DO_ISA_BUS_ALIAS_IO
   status = Report_Alias_IO(Ext);
   if (status != 0)
   {
      Eprintf("StartErr Alias-IO");
      MyKdPrint(D_Pnp,("Error 1P\n"))
      status = STATUS_INSUFFICIENT_RESOURCES;
      return status;
   }
   MyKdPrint(D_Pnp,("ChkPt B\n"))
#endif
//DELF
MyKdPrint(D_Pnp,("INIT RCK\n"))
//END DELF
   status = RocketPortSpecialStartup(Ext);
   if (status != STATUS_SUCCESS)
   {
     Eprintf("StartErr 1J");
     return status;
   }
#endif

   MyKdPrint(D_Pnp,("ChkPt C\n"))

#ifdef S_VS
   status = VSSpecialStartup(Ext);
   if (status != STATUS_SUCCESS)
   {
     Eprintf("StartErr 1J");
     return status;
   }
#endif

   //----- Create our port devices, if we are doing pnp ports, then
   // create PDO's, if not, then create normal com-port device objects
   // (same as FDO's.)
   for (ch=0; ch<Ext->config->NumPorts; ch++)
   {
     //MyKdPrint(D_Pnp,("FS,ChanInit:%d\n", ch))
     status = CreatePortDevice(
                          Driver.GlobalDriverObject,
                          Ext, // parent ext.
                          &newExtension,
                          ch,
                          is_fdo);
     if (status != STATUS_SUCCESS)
     {
       Eprintf("StartErr 1Q");
       return status;
     }
     NewDevObj = newExtension->DeviceObject;  //return the new device object
     NewDevObj->Flags |= DO_POWER_PAGABLE;

     if (!is_fdo)  // eject PDOs representing port hardware.
       newExtension->IsPDO = 1;  // we are a pdo

#if S_RK
     if (Ext->config->RocketPortFound)  // if started(not delayed isa)
#endif
     {
       status = StartPortHardware(newExtension,
                         ch);  // channel num, port index

       if (status != STATUS_SUCCESS)
       {
         Eprintf("StartErr 1O");
         return status;
       }
     }
   }  // for ports

#ifdef S_RK
   if (Ext->config->RocketPortFound)  // if started(not delayed isa)
#endif
   {
     Ext->config->HardwareStarted = TRUE;

     // send ROW configuration to SocketModems
     InitSocketModems(Ext);
#ifdef S_RK
	 InitRocketModemII (Ext);
#endif
   }
   MyKdPrint(D_Pnp,("ChkPt D\n"))

  //---- start up the timer
  if (!Driver.TimerCreated)
  {
#ifdef S_RK
    Driver.SetupIrq = 0;
#endif
    //MyKdPrint(D_Pnp,("before rcktinitpolltimer\n"))
    RcktInitPollTimer();
    //MyKdPrint(D_Pnp,("after rcktinitpolltimer\n"))

    KeSetTimer(&Driver.PollTimer,
               Driver.PollIntervalTime,
               &Driver.TimerDpc);
  }
  MyKdPrint(D_Pnp,("ChkPt F, after\n"))

  Ext->FdoStarted = TRUE;

  //if (Drier.VerboseLog)
  //  Eprintf("Success start dev");

   status = STATUS_SUCCESS;
   return status;
}

#ifdef S_RK
/*-----------------------------------------------------------------------
 RocketPortSpecialStartup -
|-----------------------------------------------------------------------*/
static NTSTATUS RocketPortSpecialStartup(PSERIAL_DEVICE_EXTENSION Ext)

{
  int ch;
  int start_isa_flag;
  NTSTATUS status = STATUS_SUCCESS;
  PSERIAL_DEVICE_EXTENSION tmpExt;
  PSERIAL_DEVICE_EXTENSION newExt;

  if (Ext->config->BusType == Isa)
  {
    MyKdPrint(D_PnpPower,("pnp- ISA brd Index:%d\n",
       Ext->config->ISABrdIndex))

    if (Ext->config->ISABrdIndex == 0)
      start_isa_flag = 1;
    else if (is_first_isa_card_started())
      start_isa_flag = 1;
    else
    {
      MyKdPrint(D_PnpPower,("Delay 2ndary ISA card start\n"))
      start_isa_flag = 0;
    }
  }

  //----- Init the RocketPort hardware
  if ((Ext->config->BusType == Isa) && (!start_isa_flag))
    status = 0;  // skip, can't start until we get the first board
  else
  {
    status = InitController(Ext);  // this sets RocketPortFound = TRUE if ok
    if (status != 0)
    {
      status = STATUS_INSUFFICIENT_RESOURCES;
      MyKdPrint(D_Error,("Brd failed startup\n"))

      //if (Driver.VerboseLog)
      //  Eprintf("Error InitCtrl");
      return status;
    }
    MyKdPrint(D_PnpPower,("Brd started\n"))
  }

  if ((Ext->config->BusType == Isa) && (is_first_isa_card_started()) &&
       (is_isa_cards_pending_start()) )
  {
    MyKdPrint(D_Pnp,("Do Pending\n"))
    tmpExt = Driver.board_ext;
    while (tmpExt)
    {
      if ((tmpExt->config->BusType == Isa) &&
          (!tmpExt->config->RocketPortFound))   // this tells if its started
      {
        MyKdPrint(D_Pnp,("Pending 1A\n"))
        status = InitController(tmpExt);  // this sets RocketPortFound = TRUE if ok

        if (status != 0)
        {
          status = STATUS_INSUFFICIENT_RESOURCES;
          if (Driver.VerboseLog)
            Eprintf("Error 5C");
          return status;
        }

        MyKdPrint(D_Pnp,("Pend 2A\n"))
        //----- Find and initialize the controller ports
        newExt = tmpExt->port_ext;
        ch=0;
        while (newExt)
        {
          status = StartPortHardware(newExt,
                         ch);  // channel num, port index

          if (status != STATUS_SUCCESS)
          {
            Eprintf("StartErr 1N");
            return status;
          }
          newExt = newExt->port_ext;
          ++ch;
        }
        tmpExt->config->HardwareStarted = TRUE;

        // send ROW configuration to SocketModems
        InitSocketModems(tmpExt);

        MyKdPrint(D_Pnp,("Pending OK\n"))
      }
      tmpExt = tmpExt->board_ext;
    }
  }  // if isa boards to startup

  return status;
}
#endif

/*-----------------------------------------------------------------------

   This routine kills any irps pending for the passed device object.
   
Arguments:
    DeviceObject - Pointer to the device object whose irps must die.

Return Value:
    VOID
|-----------------------------------------------------------------------*/
VOID SerialKillPendingIrps(PDEVICE_OBJECT DeviceObject)
{
   PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
   KIRQL oldIrql;
   
   //PAGED_CODE();
   //SerialDump (SERTRACECALLS,("SERIAL: Enter SerialKillPendingIrps\n"));

   // this is for the FDO, which currently is the BOARD, so we have to
   // do all ports for this board.(THIS IS NOT A PORT EXTENSION!!!!!)

   // First kill all the reads and writes.
    SerialKillAllReadsOrWrites(
        DeviceObject,
        &extension->WriteQueue,
        &extension->CurrentWriteIrp
        );

    SerialKillAllReadsOrWrites(
        DeviceObject,
        &extension->ReadQueue,
        &extension->CurrentReadIrp
        );

    // Next get rid of purges.
    SerialKillAllReadsOrWrites(
        DeviceObject,
        &extension->PurgeQueue,
        &extension->CurrentPurgeIrp
        );

    // Now get rid a pending wait mask irp.
    IoAcquireCancelSpinLock(&oldIrql);

    if (extension->CurrentWaitIrp) {

        PDRIVER_CANCEL cancelRoutine;

        cancelRoutine = extension->CurrentWaitIrp->CancelRoutine;
        extension->CurrentWaitIrp->Cancel = TRUE;

        if (cancelRoutine) {

            extension->CurrentWaitIrp->CancelIrql = oldIrql;
            extension->CurrentWaitIrp->CancelRoutine = NULL;

            cancelRoutine(
                DeviceObject,
                extension->CurrentWaitIrp
                );

        }

    } else {

        IoReleaseCancelSpinLock(oldIrql);

    }
    //SerialDump (SERTRACECALLS,("SERIAL: Leave SerialKillPendingIrps\n"));
}

/*-----------------------------------------------------------------------

   This function must be called at any IRP dispatch entry point.  It,
   with SerialIRPPrologue(), keeps track of all pending IRP's for the given
   PDevObj.
   
Arguments:
   PDevObj - Pointer to the device object we are tracking pending IRP's for.

Return Value:
   None.
|-----------------------------------------------------------------------*/
VOID SerialIRPEpilogue(IN PSERIAL_DEVICE_EXTENSION PDevExt)
{
   ULONG pendingCnt;

   pendingCnt = InterlockedDecrement(&PDevExt->PendingIRPCnt);

#if DBG
   //MyKdPrint(D_Pnp,("Exit PendingIrpCnt:%d\n", PDevExt->PendingIRPCnt))
#endif

   if (pendingCnt == 0)
   {
      MyKdPrint(D_Pnp,("Set PendingIRPEvent\n"))
      KeSetEvent(&PDevExt->PendingIRPEvent, IO_NO_INCREMENT, FALSE);
   }
}

/*-----------------------------------------------------------------------
 SerialIoCallDriver -
|-----------------------------------------------------------------------*/
NTSTATUS SerialIoCallDriver(PSERIAL_DEVICE_EXTENSION PDevExt,
           PDEVICE_OBJECT PDevObj,
           PIRP PIrp)
{
   NTSTATUS status;

   ASSERT( PDevObj );

   status = IoCallDriver(PDevObj, PIrp);
   SerialIRPEpilogue(PDevExt);
   return status;
}

/*-----------------------------------------------------------------------
 SerialPoCallDriver -
|-----------------------------------------------------------------------*/
NTSTATUS SerialPoCallDriver(PSERIAL_DEVICE_EXTENSION PDevExt,
           PDEVICE_OBJECT PDevObj,
           PIRP PIrp)
{
   NTSTATUS status;

   status = PoCallDriver(PDevObj, PIrp);
   SerialIRPEpilogue(PDevExt);
   return status;
}

/*-----------------------------------------------------------------------
    This routine is a completion handler that is called after the COM port
    has been powered up.  It sets the COM port in a known state by calling
    SerialReset, SerialMarkClose, SerialClrRTS, and SerialClrDTR.  The it
    does a PoCompleteRequest to finish off the power Irp.

Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request
    Context -  None

Return Value:
    Return status in IRP when being called (if not STATUS_SUCCESS) or 
    STATUS_SUCCESS.
|-----------------------------------------------------------------------*/
NTSTATUS OurPowerCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
   NTSTATUS                    status      = Irp->IoStatus.Status;
   PSERIAL_DEVICE_EXTENSION    Ext   = DeviceObject->DeviceExtension;
   PIO_STACK_LOCATION          irpStack    = IoGetCurrentIrpStackLocation(Irp);
   POWER_STATE         powerState;
   POWER_STATE_TYPE    powerType;

   powerType = irpStack->Parameters.Power.Type;
   powerState = irpStack->Parameters.Power.State;

   MyKdPrint(D_PnpPower,("In OurPowerCompletion\n"))

   if (irpStack->MinorFunction == IRP_MN_SET_POWER)
   {
      if (powerState.DeviceState == PowerDeviceD0)
      {
        MyKdPrint(D_PnpPower,("Restoring to Power On State D0\n"))

        status = STATUS_SUCCESS;
        // set hardware to known power up state
        Ext->PowerState = powerState.DeviceState; // PowerDeviceD0;

        if (Ext->DeviceType == DEV_BOARD)
        {
          status = PowerUpDevice(Ext);
        }  // board device
        else if (Ext->DeviceType == DEV_PORT)
        {
          Ext->config->HardwareStarted = TRUE;
        }

        PoSetPowerState(DeviceObject, powerType, powerState);
      }
      else  // if (powerState.DeviceState == PowerDeviceD3)
      {
        status = STATUS_SUCCESS;
        // Clear the flag saying we are waiting for a power down
        Ext->ReceivedQueryD3  = FALSE;

        Ext->PowerState = PowerDeviceD3;
     }
   }

   InterlockedDecrement(&Ext->PendingIRPCnt);

   PoStartNextPowerIrp(Irp);
   return status;
}

/*-----------------------------------------------------------------------
 RestorePortSettings - Try to restore port hardware settings.  Called
   after power-off sleep mode.
|-----------------------------------------------------------------------*/
void RestorePortSettings(PSERIAL_DEVICE_EXTENSION Ext)
{
  SERIAL_HANDFLOW TempHandFlow;
  DWORD TempDTRRTSStatus;
  DWORD xorDTRRTSStatus;

#ifdef S_RK
  // remember what the status of pins are coming into this
  // so we can try to put them back to what they were prior to
  // hardware re-initialization.
  TempDTRRTSStatus = Ext->DTRRTSStatus; // SERIAL_DTR_STATE;

  if(sGetChanStatus(Ext->ChP) & STATMODE)
  {  // Take channel out of statmode if necessary
     sDisRxStatusMode(Ext->ChP);
  }
  // pDisLocalLoopback(Ext->Port);
  // Clear any pending modem changes
  sGetChanIntID(Ext->ChP);
  sEnRxFIFO(Ext->ChP);    // Enable Rx
  sEnTransmit(Ext->ChP);    // Enable Tx
  sSetRxTrigger(Ext->ChP,TRIG_1);  // always trigger
  sEnInterrupts(Ext->ChP, Ext->IntEnables);// allow interrupts

  ForceExtensionSettings(Ext);

  // make a temp. copy of handflow struct
  memcpy(&TempHandFlow, &Ext->HandFlow, sizeof(TempHandFlow));

  // force updates in SerialSetHandFlow, which looks for delta change.
  Ext->HandFlow.ControlHandShake = ~TempHandFlow.ControlHandShake;
  Ext->HandFlow.FlowReplace = ~TempHandFlow.FlowReplace;

  SerialSetHandFlow(Ext, &TempHandFlow);  // in ioctl.c

  // program hardware baudrate
  ProgramBaudRate(Ext, Ext->BaudRate);

  xorDTRRTSStatus = Ext->DTRRTSStatus ^ TempDTRRTSStatus;

  // try to restore the actual dtr & rts outputs 
  if (xorDTRRTSStatus & SERIAL_DTR_STATE)  // changed
  {
    // if not auto-handshake dtr mode
    if (!((Ext->HandFlow.ControlHandShake & SERIAL_DTR_MASK) ==
                    SERIAL_DTR_HANDSHAKE ))
    {
      if (TempDTRRTSStatus & SERIAL_DTR_STATE)  // was on
      {
        sSetDTR(Ext->ChP);
      }
      else
      {
        sClrDTR(Ext->ChP);
      }
    }  // not auto-dtr flow
  }  // chg in dtr

  if (xorDTRRTSStatus & SERIAL_RTS_STATE)  // changed
  {
    // if not auto-flow control rts  
    if (!((Ext->HandFlow.ControlHandShake & SERIAL_RTS_MASK) == 
        SERIAL_RTS_HANDSHAKE))
    {
      if (TempDTRRTSStatus & SERIAL_RTS_STATE)  // was on
      {
        sSetRTS(Ext->ChP);
      }
      else
      {
        sClrRTS(Ext->ChP);
      }
    } // chg in rts
    Ext->DTRRTSStatus = TempDTRRTSStatus;
  }  
#endif
  // the VS boxes will not be powered off, and will hold their state
  // so no hardware re-initialization is needed.  The box will have
  // probably timed out the connection, and force a re-sync operation,
  // we might want to pro-actively start this so there is a smaller
  // delay...
}

/*-----------------------------------------------------------------------
 PowerUpDevice - Used to bring power back on after turning it off.
|-----------------------------------------------------------------------*/
NTSTATUS PowerUpDevice(PSERIAL_DEVICE_EXTENSION    Ext)
{
  PSERIAL_DEVICE_EXTENSION    port_ext;
  int ch;
  NTSTATUS status = STATUS_SUCCESS;

#ifdef S_RK
  MyKdPrint(D_PnpPower,("RocketPort Init %d\n",Ext->config->HardwareStarted))
  status = RocketPortSpecialStartup(Ext);
  if (status != STATUS_SUCCESS)
  {
    MyKdPrint(D_Error,("RocketPort Init Failed\n"))
    //return status;
  }
  if (Ext->config->RocketPortFound)  // if started(not delayed isa)
    Ext->config->HardwareStarted = TRUE;
#endif

#ifdef S_VS
  MyKdPrint(D_PnpPower,("VS Init\n"))
  status = VSSpecialStartup(Ext);
  if (status != STATUS_SUCCESS)
  {
    MyKdPrint(D_Error,("VS Init Failed\n"))
    //return status;
  }
  Ext->config->HardwareStarted = TRUE;
#endif

  if (Ext->config->HardwareStarted == TRUE)
  {
    if (Ext->port_ext == NULL)
      {MyKdPrint(D_Error,("No Ports\n")) }

    //----- Find and initialize the controller ports
    port_ext = Ext->port_ext;
    ch=0;
    while (port_ext)
    {
      MyKdPrint(D_PnpPower,("PowerUp Port %d\n", ch))
      status = StartPortHardware(port_ext,
                 ch);  // channel num, port index

      if (status != STATUS_SUCCESS)
      {
        
        MyKdPrint(D_Error,("PortPowerUp Err1\n"))
        return status;
      }
      MyKdPrint(D_PnpPower,("PowerUp Port %d Restore\n", ch))
      RestorePortSettings(port_ext);

      port_ext = port_ext->port_ext;
      ++ch;
    }
  }
  else
  {
    MyKdPrint(D_Error,("Not started\n"))
  }
  // send ROW configuration to SocketModems
  //InitSocketModems(Ext);

  status = STATUS_SUCCESS;
  return status;
}

/*-----------------------------------------------------------------------
 SerialRemoveFdo -
|-----------------------------------------------------------------------*/
NTSTATUS SerialRemoveFdo(IN PDEVICE_OBJECT pFdo)
{
   PSERIAL_DEVICE_EXTENSION extension = pFdo->DeviceExtension;

   MyKdPrint(D_Pnp,("SerialRemoveFdo\n"))

   // Only do these things if the device has started
   //(comment out 8-15-98) if (extension->FdoStarted)
   {
     if (extension->DeviceType == DEV_BOARD)
     {
       // BUGBUG, shut down this board(are we deallocating resources?)!!!
       RcktDeleteBoard(extension);
       if (Driver.board_ext == NULL)  // no more boards, so delete driver obj
       {
         // Delete Driver obj
         RcktDeleteDriverObj(Driver.driver_ext);
         Driver.driver_ext = NULL;  // no more boards
#ifdef S_VS
         // to allow the driver to unload from nt50, we need to
         // stop the nic-binding thread, shut down the nic
         // cards and the protocol from ndis
         init_stop();  // unload thread, ndis nic cards, etc
#endif
         {
           PDEVICE_OBJECT currentDevice = Driver.GlobalDriverObject->DeviceObject;
           int i;

           i = 0;
           while(currentDevice)
           {
             currentDevice = currentDevice->NextDevice;
             if (currentDevice)
               ++i;
           }
           if (i != 0)
           {
             MyKdPrint(D_Pnp,("Err, %d Devices still remain\n",i))
           }
           else
           {
             MyKdPrint(D_Pnp,("Ok remove\n"))
           }
         }
       }
     }
     else
     {
       RcktDeletePort(extension);
       // must be a port fdo, kill it
     }
   }

   MyKdPrint(D_Pnp,("End SerialRemoveFdo\n"))

   return STATUS_SUCCESS;
}

#endif  // NT50

/*-----------------------------------------------------------------------

   This function must be called at any IRP dispatch entry point.  It,
   with SerialIRPEpilogue(), keeps track of all pending IRP's for the given
   PDevObj.
   
Arguments:
   PDevObj - Pointer to the device object we are tracking pending IRP's for.

Return Value:
    TRUE if the device can accept IRP's.
|-----------------------------------------------------------------------*/
BOOLEAN SerialIRPPrologue(IN PSERIAL_DEVICE_EXTENSION PDevExt)
{
   InterlockedIncrement(&PDevExt->PendingIRPCnt);
#ifdef NT50
   return PDevExt->DevicePNPAccept == SERIAL_PNPACCEPT_OK ? TRUE : FALSE;
#else
   return TRUE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\options.c ===
/*-------------------------------------------------------------------
| options.c - Handle options.
 Copyright 1996-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

#define D_Level D_Options
static int set_reg_option(IN int OptionVarType,
                          IN HANDLE Handle,
                          IN  const char *szVarName,
                          IN VOID *Value);
static int get_reg_option(IN int OptionVarType,
                          IN HANDLE Handle,
                          IN HANDLE DefHandle,
                          IN  const char *szVarName,
                          OUT char *szValue,
                          IN int szValueSize);
static int atomac(BYTE *mac, char *str);

static int SetMainOption(int index, char *value);
static int SetDeviceOption(int device_index, int option_index, char *value);
static int SetPortOption(int device_index,
                         int port_index,
                         int option_index,
                         char *value);

//--- country codes for SocketModem support
#define mcNotUsed         0
#define mcAustria         1
#define mcBelgium         2
#define mcDenmark         3
#define mcFinland         4
#define mcFrance          5
#define mcGermany         6
#define mcIreland         7
#define mcItaly           8
#define mcLuxembourg      9
#define mcNetherlands     10
#define mcNorway          11
#define mcPortugal        12
#define mcSpain           13
#define mcSweden          14
#define mcSwitzerland     15
#define mcUK              16
#define mcGreece          17
#define mcIsrael          18
#define mcCzechRep        19
#define mcCanada          20
#define mcMexico          21
#define mcUSA             22         
#define mcNA              mcUSA          // North America
#define mcHungary         23
#define mcPoland          24
#define mcRussia          25
#define mcSlovacRep       26
#define mcBulgaria        27
// 28
// 29
#define mcIndia           30
// 31
// 32
// 33
// 34
// 35
// 36
// 37
// 38
// 39
#define mcAustralia       40
#define mcChina           41
#define mcHongKong        42
#define mcJapan           43
#define mcPhilippines     mcJapan
#define mcKorea           44
// 45
#define mcTaiwan          46
#define mcSingapore       47
#define mcNewZealand      48

#ifdef NT50
/*----------------------------------------------------------------------
 write_device_options - Normally the driver just reads the config
   from the registry, but NT5.0 is a bit more dynamic(it gets started
   prior to configuration, and we want to write out the port names
   if the driver has no defaults.  This enables the config prop pages
   to be in sync when we fire it up.
|----------------------------------------------------------------------*/
int write_device_options(PSERIAL_DEVICE_EXTENSION ext)
{
#if 0
 int port_i, stat;
 PSERIAL_DEVICE_EXTENSION port_ext;
 HANDLE DevHandle;
 DEVICE_CONFIG *dev_config;


  // make sure \\Parameters subkey is made
  MakeRegPath(szParameters);  // this forms Driver.OptionRegPath
  RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE, Driver.OptionRegPath.Buffer);

   // form "\Parameters\Device#" or "\Parameters\Device<pnp-id>"
  stat = make_device_keystr(ext, devstr);
  if (stat)
    return 1;  // err

  // make sure \Parameters\Device# subkey is made
  MakeRegPath(devstr);  // this forms Driver.OptionRegPath
  RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE, Driver.OptionRegPath.Buffer);
#endif

#if 0
  // no, setup program can grab pnp hardware id, etc as well as we can.

  //---- open and write out critical device entries so setup
  // sees what we have.
  stat = our_open_device_reg(&DevHandle, dev_ext, KEY_ALL_ACCESS);
  if (stat == 0)
  {
    dev_config = ext->config;
    stat = set_reg_option(OP_T_DWORD,  // dword, string, etc
                        DevHandle,
                        szNumPort,      // name of var. to set
                        (VOID *)dev_config->NumPorts);

    if (stat)
      { MyKdPrint(D_Error, ("Write Err B\n")) }
    ZwClose(DevHandle);
  }
#endif

#if 0
  //---- now write out the port names
  port_i = 0;
  port_ext = ext->port_ext;
  while (port_ext != NULL)
  {
    write_port_name(ext, port_i);
    ++port_i;
    port_ext = port_ext->port_ext;
  }
#endif

  return 0;
}

/*----------------------------------------------------------------------
 write_port_name -
|----------------------------------------------------------------------*/
int write_port_name(PSERIAL_DEVICE_EXTENSION dev_ext, int port_index)
{
 //char devstr[60];
 char portstr[20];
 //char tmpstr[80];
 int stat;
 PORT_CONFIG *port_config;
 HANDLE DevHandle = NULL;
 HANDLE PortHandle = NULL;

  port_config = &dev_ext->config->port[port_index];
  MyKdPrint(D_Init, ("write_port_name:%s\n",port_config->Name))


  // make sure \Parameters\Device# subkey is made
  stat = our_open_device_reg(&DevHandle, dev_ext, KEY_ALL_ACCESS);
  if (stat)
  {
    MyKdPrint(D_Error, ("write_port_name, error\n"))
    return 1;
  }

  Sprintf(portstr, "Port%d", port_index);

  stat = our_open_key(&PortHandle,
                      DevHandle,
                      portstr,
                      KEY_ALL_ACCESS);
  if (stat == 0)
  {
    MyKdPrint(D_Init, ("set_reg1, writing %s=%s\n", 
                szName, port_config->Name))

    stat = set_reg_option(OP_T_STRING,  // dword, string, etc
                        PortHandle,
                        szName,      // name of var. to set
                        (VOID *)port_config->Name);
    if (stat)
      { MyKdPrint(D_Error, ("Write Err B\n")) }
    ZwClose(PortHandle);
  }
  ZwClose(DevHandle);

  return 0;
}
#endif

/*----------------------------------------------------------------------
 write_dev_mac - Used for auto-config, writes mac-addr out to reg
|----------------------------------------------------------------------*/
int write_dev_mac(PSERIAL_DEVICE_EXTENSION dev_ext)
{
 char macstr[30];
 int stat;
 HANDLE DevHandle = NULL;
 BYTE *mac;

  MyKdPrint(D_Init, ("write_dev_mac\n"))

  // make sure \Parameters\Device# subkey is made
  stat = our_open_device_reg(&DevHandle, dev_ext, KEY_ALL_ACCESS);
  if (stat)
  {
    MyKdPrint(D_Error, ("write_port_name, error\n"))
    return 1;
  }
  mac = dev_ext->config->MacAddr;
  Sprintf(macstr, "%02x %02x %02x %02x %02x %02x",
      mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);

  MyKdPrint(D_Init, ("set_mac, writing %s=%s\n", 
                  szMacAddr, macstr))

  stat = set_reg_option(OP_T_STRING,  // dword, string, etc
                        DevHandle,
                        szMacAddr,      // name of var. to set
                        (VOID *)macstr);
  if (stat)
    { MyKdPrint(D_Error, ("Write Err 5\n")) }

  ZwClose(DevHandle);

  return 0;
}

/*----------------------------------------------------------------------
 read_device_options - Read in the program options from the registry.
   These options are at device level, and port level.  The device holds
   all the config options for the ports as well.
|----------------------------------------------------------------------*/
int read_device_options(PSERIAL_DEVICE_EXTENSION ext)
{
 int j, port_i, stat;
 ULONG dstat;
 char tmpstr[80];
 char option_str[62];
 char small_str[20];
 HANDLE DevHandle = NULL;
 HANDLE PortHandle = NULL;

 HANDLE DefDevHandle = NULL;
 HANDLE DefPortHandle = NULL;
 HANDLE DriverHandle = NULL;

 //DEVICE_CONFIG *dev_config;
  // dev_config = (DEVICE_CONFIG *) ExAllocatePool(NonPagedPool,sizeof(*dev_config));
  // ExFreePool(dev_config);

  MyKdPrint(D_Init, ("read_device_options\n"))

  dstat = our_open_driver_reg(&DriverHandle, KEY_READ);
  if (dstat == 0)
  {
    // open up a "default" registry areas, where we look for config
    // if the main one does not exist.
    dstat = our_open_key(&DefDevHandle, DriverHandle, "DefDev", KEY_READ);
    dstat = our_open_key(&DefPortHandle, DriverHandle, "DefPort", KEY_READ);
    our_close_key(DriverHandle);
  }

  stat = our_open_device_reg(&DevHandle, ext, KEY_READ);
  if (stat)
  {
    MyKdPrint(D_Error, ("read_device_options: Err1\n"))
  }

  //------ read in the device options
  j = 0;
  while (device_options[j].name != NULL)
  {
    dstat = get_reg_option(device_options[j].var_type,  // dword, string, etc
                           DevHandle,
                           DefDevHandle,  //DefDevHandle,
                           device_options[j].name,  // name of var. to get
                           option_str, 60);  // return string value
    if (dstat == 0) // ok we read it
    {
      Sprintf(tmpstr,"device[%d].%s=%s",
                     BoardExtToNumber(ext),
                     device_options[j].name,
                     option_str);
      dstat = SetOptionStr(tmpstr);
      if (dstat != 0)
      {
        MyKdPrint(D_Init, ("  Err %d, last option\n", dstat))
      }
    }
    else
    {
      MyKdPrint(D_Init, ("No %s option in reg\n", device_options[j].name))
    }
    ++j;
  }

#if DBG
  if (ext == NULL)
  {
    MyKdPrint(D_Init, ("ErrD\n"))
    return 1;
  }

  if (ext->config == NULL)
  {
    MyKdPrint(D_Init, ("ErrE\n"))
    return 1;
  }
#endif

#ifdef S_VS
  if (mac_match(ext->config->MacAddr, mac_zero_addr))  // set to auto
  {
#ifndef NT50
    Eprintf("Error, Device address not setup");
#endif
    // allow to load using bogus mac-address, so driver stays loaded.
    //0 c0 4e # # #
    memcpy(ext->config->MacAddr, mac_bogus_addr, 6);
    //0,0xc0,0x4e,0,0,0
  }
#endif

  if ((DevHandle != NULL) || (DefPortHandle != NULL))
  {
    //------ get the Port information from setup.exe
    for (port_i=0; port_i<ext->config->NumPorts; port_i++)
    {
      Sprintf(small_str, "Port%d", port_i);
  
      stat = our_open_key(&PortHandle,
                   DevHandle,  // relative to this handle
                   small_str,
                   KEY_READ);
      if (stat)
      {
        MyKdPrint(D_Error, ("read_device_options: port Err2\n"))
      }
      j = 0;
      while (port_options[j].name != NULL)
      {
        dstat = get_reg_option(port_options[j].var_type,  // dword, string, etc
                               PortHandle,
                               DefPortHandle, // DefPortHandle,
                               port_options[j].name,  // name of var. to get
                               option_str, 60);  // return string value
    
        if (dstat == 0) // ok we read it
        {
          Sprintf(tmpstr,"device[%d].port[%d].%s=%s",
              BoardExtToNumber(ext), port_i, port_options[j].name, option_str);
          dstat = SetOptionStr(tmpstr);
          if (dstat)
          {
            MyKdPrint(D_Error, ("Err %d, Option:%s\n",dstat, tmpstr))
          }
        }
        ++j;
      }
      our_close_key(PortHandle);
    }  // ports

    our_close_key(DefPortHandle);
    our_close_key(DefDevHandle);
    our_close_key(DevHandle);
  }
  return 0;
}

/*----------------------------------------------------------------------
 read_driver_options - Read in the initial program options from the registry.
   These options are at driver level.
|----------------------------------------------------------------------*/
int read_driver_options(void)
{
 int i;
 ULONG dstat;

 char tmpstr[80];
 char option_str[62];
 HANDLE DriverHandle = NULL;
 HANDLE DefDriverHandle = NULL;

  MyKdPrint(D_Init, ("read_driver_options\n"))

  // set some default options
  Driver.MdmCountryCode = mcNA;     // North America

  dstat = our_open_driver_reg(&DriverHandle, KEY_READ);
  if (dstat == 0)
  {
    // open up a "default" registry area, where we look for config
    // if the main one does not exist.
    dstat = our_open_key(&DefDriverHandle, DriverHandle, "DefDrv", KEY_READ);
    MyKdPrint(D_Init, ("driver Defh:%x\n", DefDriverHandle))

    i = 0;
    while (driver_options[i].name != NULL)
    {
      MyKdPrint(D_Init, ("get %s\n", driver_options[i].name))
      dstat = get_reg_option(driver_options[i].var_type,  // dword, string, etc
                             DriverHandle,
                             DefDriverHandle,
                             driver_options[i].name,  // name of var. to get
                             option_str, 60);  // return string value
  
      if (dstat == 0) // ok we read it
      {
        MyKdPrint(D_Init, ("got %s\n", option_str))

        Sprintf(tmpstr,"%s=%s",driver_options[i].name, option_str);
  
        dstat = SetOptionStr(tmpstr);
        if (dstat != 0)
        {
          Sprintf(tmpstr,"Err %d, last option\n",dstat);
          MyKdPrint(D_Error, (tmpstr))
        }
      }
      ++i;
    }
  }
  else
  {
    MyKdPrint(D_Error, ("Read driver failed key open"))
  }

  our_close_key(DefDriverHandle);
  our_close_key(DriverHandle);

  if (Driver.NumDevices == 0)
    Driver.NumDevices = 1;
  if (Driver.NumDevices > MAX_NUM_BOXES)
    Driver.NumDevices = MAX_NUM_BOXES;

  return 0;
}

/*----------------------------------------------------------------------
 set_reg_option - write out a option to the registry
|----------------------------------------------------------------------*/
static int set_reg_option(IN int OptionVarType,
                          IN HANDLE Handle,
                          IN  const char *szVarName,
                          IN VOID *Value)
{
 int dstat = 1;  // err

  MyKdPrint(D_Init, ("set_reg_option %s=", szVarName))

  if (OptionVarType == OP_T_STRING)  // string option type
  {
    MyKdPrint(D_Init, ("%s\n", (char *)Value))
    dstat = our_set_value(Handle,
                    (char *)szVarName,
                    Value,
                    strlen((char *) Value),
                    REG_SZ);
  }
  else  // DWORD option type
  {
    MyKdPrint(D_Init, ("DWORD\n"))
    dstat = our_set_value(Handle,
                    (char *)szVarName,
                    Value,
                    sizeof(DWORD),
                    REG_DWORD);
  }
  if (dstat)
  {
    MyKdPrint(D_Error, ("set_reg_option:err\n"))
  }

  return dstat;
}

/*----------------------------------------------------------------------
 get_reg_option - read in a option from the registry, and convert it to
   ascii.
|----------------------------------------------------------------------*/
static int get_reg_option(IN int OptionVarType,
                          IN HANDLE Handle,
                          IN HANDLE DefHandle,
                          IN  const char *szVarName,
                          OUT char *szValue,
                          IN int szValueSize)
{
 int dstat = 1;  // err
 ULONG dwValue;
 char buffer[200];
 char  *ret_str;
 ULONG data_type;

  //MyKdPrint(D_Init, ("get_reg_option\n"))

  szValue[0] = 0;

  dstat = our_query_value(Handle,
                 (char *)szVarName,
                 buffer,
                 sizeof(buffer),
                 &data_type,
                 &ret_str);
  if ((dstat != 0) && (DefHandle != NULL))
  {
    dstat = our_query_value(DefHandle,
                 (char *)szVarName,
                 buffer,
                 sizeof(buffer),
                 &data_type,
                 &ret_str);
    if (dstat == 0)
    {
      MyKdPrint(D_Test, ("query default reg val\n"))
    }
  }

  if (OptionVarType == OP_T_STRING)  // string option type
  {
    if (dstat == 0)
    {
      WStrToCStr(szValue, (PWCHAR)ret_str, szValueSize);
      MyKdPrint(D_Test, ("reg read:%s\n", ret_str))
    }
  }
  else  // DWORD option type
  {
    if (dstat == 0)  // value read ok
      dwValue = *((ULONG *) ret_str);
    else
      dwValue = 0;
    Sprintf(szValue,"%d", dwValue);
  }
  if (dstat)
  {
    //MyKdPrint(D_Init, ("get_reg_option:No value for:%s\n", szVarName))
  }
  else
  {
    MyKdPrint(D_Init, ("get_reg_option:%s=%s\n", szVarName, szValue))
  }
  //MyKdPrint(D_Init, ("End get_reg_option\n"))
  return dstat;
}

/*-----------------------------------------------------------------------
 SetOptionStr - set an option, based on simple ascii command line
  entry.  Allow:

   GlobalVar1 = value;
   GlobalVar2 = value;
   box[0].BoxVar = value;
   box[0].port[5].PortVar = value;
|-----------------------------------------------------------------------*/
int SetOptionStr(char *option_str)
{
  int i;
  int option_i = -1;
  int box_i = -1;
  int port_i = -1;
  int option_id = -1;
  int stat;
  PSERIAL_DEVICE_EXTENSION board_ext = NULL;

  MyKdPrint(D_Level, ("SetOptionStr:%s\n", option_str))

  if (my_sub_lstricmp("device", option_str) == 0)  // match
  {
    option_str += 6;  // pass up "device"
    if (*option_str++ != '[')
      return 1;
#if (defined(NT50))
    if (my_toupper(*option_str) == 'D')  // it's a nt5.0 keyword device name
    {
      int k;
      // instead of an index, we key off a pnp-device name
      // this is because nt50 stores devices under a pnp-tree dynamically
      // and does not have just a simple array list of devices.
      board_ext = Driver.board_ext;

      box_i = -1;
      k = 0;
      while (board_ext != NULL)
      {
        if (my_sub_lstricmp(board_ext->config->szNt50DevObjName,
            option_str) == 0)  // match
        {
          i = strlen(board_ext->config->szNt50DevObjName);
          box_i = k;
        }
        board_ext = board_ext->board_ext;
        ++k;
      }
      if (box_i == -1)
      {
        MyKdPrint(D_Error, ("Pnp key not found.\n"))
        return 15;  // err
      }
    }
    else  // set option by device by index(which our reg-reading one does.)
    {
      box_i = getint(option_str, &i);  // get the box index [#]
      if (i==0)
        return 2;
      if (find_ext_by_index(box_i, -1) == NULL)  // if no device exists)
      {
        return 3;
      }
    }
#else
    box_i = getint(option_str, &i);  // get the box index [#]
    if (i==0)
      return 2;
    if (find_ext_by_index(box_i, -1) == NULL)  // if no device exists)
    {
      return 3;
    }
#endif
    option_str += i;
    if (*option_str++ != ']')
      return 4;
    if (*option_str++ != '.')
      return 5;
    if (my_sub_lstricmp("port[", option_str) == 0)  // match
    {
      // its a port option
      
      option_str += 4;  // pass up "port"
      if (*option_str++ != '[')
        return 20;
      port_i = getint(option_str, &i);  // get the port index [#]
      if (i==0)
        return 21;
      option_str += i;

      if (*option_str++ != ']')
        return 23;

      if (*option_str++ != '.')
        return 34;

      //-- find the option-string index
      i = 0;
      while (port_options[i].name != NULL)
      {
        if (my_sub_lstricmp(port_options[i].name, option_str) == 0)  // match
        {
          option_i = i;
          option_id = port_options[i].id;
        }
        ++i;
      }
      if (option_i == -1)
        return 24;  // option not found

      option_str += strlen(port_options[option_i].name);
      while (*option_str == ' ')
       ++option_str;
      if (*option_str++ != '=')
        return 25;
      while (*option_str == ' ')
       ++option_str;

      stat = SetPortOption(box_i, port_i, option_id, option_str);
      if (stat)
        return (50+stat);  // option not set

      return 0; // ok
    }  // == port[

    //-------- its a device level option, find the option-string index
    i = 0;
    while (device_options[i].name != NULL)
    {
      if (my_sub_lstricmp(device_options[i].name, option_str) == 0)  // match
      {
        option_i = i;
        option_id = device_options[i].id;
      }
      ++i;
    }
    if (option_i == -1)
    {
      MyKdPrint(D_Error, ("Option not found:%s\n", option_str))
      return 6;  // option not found
    }

    option_str += strlen(device_options[option_i].name);
    while (*option_str == ' ')
     ++option_str;
    if (*option_str++ != '=')
      return 7;
    while (*option_str == ' ')
     ++option_str;

    stat = SetDeviceOption(box_i, option_id, option_str);
    if (stat)
      return (50+stat);  // option not set
    return 0; // ok
  }

  //-- assume a global option string
  //-- find the option-string index
  i = 0;
  while (driver_options[i].name != NULL)
  {
    if (my_sub_lstricmp(driver_options[i].name, option_str) == 0)  // match
    {
      option_i = i;
      option_id = driver_options[i].id;
    }
    ++i;
  }
  if (option_i == -1)
    return 7;  // option not found

  option_str += strlen(driver_options[option_i].name);
  while (*option_str == ' ')
   ++option_str;
  if (*option_str++ != '=')
    return 7;
  while (*option_str == ' ')
   ++option_str;

  stat = SetMainOption(option_id, option_str);
  if (stat)
    return (50+stat);  // option not set

 return 0;
}

/*-----------------------------------------------------------------------
 SetMainOption -
|-----------------------------------------------------------------------*/
static int SetMainOption(int index, char *value)
{
 int j;
 int ret_stat = 2;  // default, return an error, unknown option

  //MyKdPrint(D_Init, ("SetMainOp[%d]:%s\n", index, value))

  switch (index)
  {
    case OP_VerboseLog:
      Driver.VerboseLog = (WORD)getnum(value,&j);
      ret_stat = 0;  // ok
    break;

    case OP_NumDevices:
      if (NumDevices() == 0)
      {
        Driver.NumDevices = getnum(value,&j);
        if (Driver.NumDevices > MAX_NUM_BOXES)
          Driver.NumDevices = MAX_NUM_BOXES;
        ret_stat = 0;
      }
      else
      {
        // if this gets changed on the fly, this could kill us!!!!!
        ret_stat = 1;  // not allowed
      }
    break;

    case OP_ScanRate:
      Driver.ScanRate = (WORD)getnum(value,&j);
      if (Driver.ScanRate == 0) Driver.ScanRate = 10;
      if (Driver.ScanRate < 1) Driver.ScanRate = 1;
      if (Driver.ScanRate > 50) Driver.ScanRate = 50;
      Driver.PollIntervalTime.QuadPart = Driver.ScanRate * -10000;
#ifdef NT50
      ExSetTimerResolution(Driver.ScanRate, 1);
      //ExSetTimerResolution(-Driver.PollIntervalTime.QuadPart, 1);
#endif
      ret_stat = 0;  // ok
    break;

    case OP_ModemCountry :
      Driver.MdmCountryCode = (WORD)getnum(value,&j);
      MyKdPrint(D_Level, ("ModemCountry=%d\n", Driver.MdmCountryCode))
      ret_stat = 1;  // probably need to restart to reinit modems
    break;

//    case OP_ModemSettleTime :
//      Driver.MdmSettleTime = getnum(value,&j);
//      ret_stat = 1;  // probably need to reinit modems
//    break;

#ifdef NT50
    case OP_NoPnpPorts         :
      Driver.NoPnpPorts = getnum(value,&j);

      ret_stat = 0;  // ok
      // if boards and ports started
      if (Driver.board_ext != NULL)
      {
        if (Driver.board_ext->port_ext != NULL)
        {
          ret_stat = 1;  // currently need a reset to get this operational
        }
      }
    break;
#endif

//    case OP_PreScaler        :
//      Driver.PreScaler = getnum(value,&j);
//      ret_stat = 1;  // currently need a reset to get this going
//    break;

    default:
    return 2;  // err, option unknown
  }
 return ret_stat;
}

/*-----------------------------------------------------------------------
 SetDeviceOption -
|-----------------------------------------------------------------------*/
static int SetDeviceOption(int device_index, int option_index, char *value)
{
 int stat,j, num;
 int ret_stat = 2;  // default, return an error, unknown option
 DEVICE_CONFIG *dev_config;
 PSERIAL_DEVICE_EXTENSION board_ext = NULL;

  //MyKdPrint(D_Level, ("SetDeviceOp[%d.%d]:%s\n", device_index, option_index, value))
  board_ext = find_ext_by_index(device_index, -1);
  if (board_ext == NULL)  // if no device exists)
  {
    MyKdPrint(D_Error, ("Err, SetDevOpt, No Dev"))
    return 6;  // no device found
  }
  dev_config = board_ext->config;
  if (dev_config == NULL)  // if no device exists)
  {
    MyKdPrint(D_Error, ("Err, SetDevOpt, No Config"))
    return 6;  // no device found
  }

  switch (option_index)
  {
#if 0
    case OP_StartComIndex  :
      num = getnum(value,&j);
    break;
#endif

    case OP_NumPorts        :
      num = getnum(value,&j);
      if (NumPorts(board_ext) == 0)
      {
        // assume start up reading in, and other code will adjust
        dev_config->NumPorts = num;
        ret_stat = 0;
      }
      else
      {
        if (num == NumPorts(board_ext))
          ret_stat = 0;
        else  // different number of ports asked for.
        {
           stat = CreateReconfigPortDevices(board_ext, num);
           if (stat == STATUS_SUCCESS)
                ret_stat = 0;
           else
           {
             ret_stat = 1;  // err, need reboot
             MyKdPrint(D_Init, ("NumPorts chg needs reboot\n"))
           }
        }
      }
    break;

    case OP_IoAddress       :
      if (dev_config->IoAddress == 0)
      {
        // assume startup of nt40.
        dev_config->IoAddress = getnum(value,&j);
        ret_stat = 0;
      }
      else
      {
        MyKdPrint(D_Init, ("Io chg needs reboot\n"))
        ret_stat = 1;  // err, need reboot
      }
    break;

    case OP_ModemDevice   :
      dev_config->ModemDevice = getnum(value, &j);
      ret_stat = 0;  // ok
    break;

    case OP_Name:
      ret_stat = 0;  // ok
    break;

    case OP_ModelName:
      ret_stat = 0;  // ok
    break;

    case OP_HubDevice:
      ret_stat = 0;  // ok
    break;

#ifdef S_VS
    case OP_MacAddr         :
      ret_stat = 0;  // ok, took
      stat = atomac(dev_config->MacAddr, value);
      if (stat)
      {
        MyKdPrint(D_Error, ("Error%x device:%d, MAC addr\n",stat, device_index+1))
        ret_stat = 1;
      }
      else
      {
        if (!mac_match(dev_config->MacAddr, board_ext->hd->dest_addr))
        {
          MyKdPrint(D_Init, ("MacAddr:%x %x %x %x %x %x\n",
            dev_config->MacAddr[0],dev_config->MacAddr[1],dev_config->MacAddr[2],
            dev_config->MacAddr[3],dev_config->MacAddr[4],dev_config->MacAddr[5]))
          #if DBG
          if (board_ext->pm->hd == NULL)
          {
            MyKdPrint(D_Error, ("Err, null pm or hd\n"))
            break;
          }
          #endif
          port_set_new_mac_addr(board_ext->pm, dev_config->MacAddr);
        }
      }
      MyKdPrint(D_Error, ("End Mac Chg\n"))
    break;

    case OP_BackupServer    :
      dev_config->BackupServer = getnum(value,&j);
      board_ext->pm->backup_server = dev_config->BackupServer;
      ret_stat = 0;  // ok, took
    break;

    case OP_BackupTimer    :
      dev_config->BackupTimer = getnum(value,&j);
      board_ext->pm->backup_timer = dev_config->BackupTimer;
      ret_stat = 0;  // ok, took
    break;
#endif

    default:
    return 2;
  }
 return ret_stat;
}

/*-----------------------------------------------------------------------
 SetPortOption -
|-----------------------------------------------------------------------*/
static int SetPortOption(int device_index,
                         int port_index,
                         int option_index,
                         char *value)
{
 int j;
 int i = device_index;
 int ret_stat = 2;  // default, return an error, unknown option
 PSERIAL_DEVICE_EXTENSION board_ext = NULL;
 PSERIAL_DEVICE_EXTENSION ext = NULL;
 PORT_CONFIG *port_config;

  MyKdPrint(D_Level, ("SetPortOp[%d.%d,%x]:%s\n",
     device_index, port_index, option_index, value))

  board_ext = find_ext_by_index(device_index, -1);
  if (board_ext == NULL)
  {
    MyKdPrint(D_Error, ("Can't find board\n"))
    return 6;
  }

  ext = find_ext_by_index(device_index, port_index);
  if (ext == NULL)
  {
    // so point it at the boards port config(which is what the ports
    // ptr points to anyway.
    port_config = &board_ext->config->port[port_index];
  }
  else
    port_config = ext->port_config;

  if (port_config == NULL)
  {
    MyKdPrint(D_Error, ("Err 8U\n"))
    return 7;
  }

  switch (option_index)
  {
    case OP_WaitOnTx :
      port_config->WaitOnTx = getnum(value,&j);
      ret_stat = 0;  // ok, took
    break;
    case OP_RS485Override :
      // will take next port open
      port_config->RS485Override = getnum(value,&j);
      ret_stat = 0;  // ok, took
    break;
    case OP_RS485Low :
      port_config->RS485Low = getnum(value,&j);
      // will take next port open
      ret_stat = 0;  // ok, took
    break;
    case OP_TxCloseTime :
      port_config->TxCloseTime = getnum(value,&j);
      ret_stat = 0;  // ok, took
    break;
    case OP_LockBaud :
      port_config->LockBaud = getnum(value,&j);
      if (ext != NULL)
        ProgramBaudRate(ext, ext->BaudRate);
      ret_stat = 0;  // ok, took
    break;
    case OP_Map2StopsTo1 :
      port_config->Map2StopsTo1 = getnum(value,&j);
      ret_stat = 0;  // ok, took
    break;

    case OP_MapCdToDsr :
      port_config->MapCdToDsr = getnum(value,&j);
      ret_stat = 0;  // ok, took
    break;
    case OP_RingEmulate :
      port_config->RingEmulate = getnum(value,&j);
      ret_stat = 0;  // ok, took
    break;

    case OP_PortName :
      if (ext == NULL)  // must be initial load prior to port ext creation
      {
        strcpy(port_config->Name, value);
        ret_stat = 0;  // ok, took
        break;
      }

      // not init time, runtime
      ret_stat = 1;  // err, need reboot
      if (ext == NULL)
      {
        MyKdPrint(D_Error,("Err7K\n"))
        break;
      }
#define ALLOW_RENAMING_ON_FLY
#ifdef ALLOW_RENAMING_ON_FLY
      {
        PSERIAL_DEVICE_EXTENSION other_ext = NULL;
        char othername[20];

        MyKdPrint(D_Init,("NewName:%s OldName:%s\n",
             value, ext->SymbolicLinkName))

        // see if some other port has the name we want
        other_ext = find_ext_by_name(value, NULL);
        if (other_ext == ext)  //it's the same
        {
          ret_stat = 0;  // ok, took
          break;
        }

        if (other_ext)
        {
          MyKdPrint(D_Init,("Change other name\n"))
          // it does, so rename it to ours
          strcpy(othername, other_ext->SymbolicLinkName);
          SerialCleanupExternalNaming(other_ext);
          strcpy(other_ext->port_config->Name, ext->port_config->Name);
          strcpy(other_ext->SymbolicLinkName, ext->port_config->Name);  // "COM#"
        }

        SerialCleanupExternalNaming(ext);
        if (other_ext)
        {
          SerialSetupExternalNaming(other_ext);  // Configure port
        }
        // copy over the name in the configuration for dos-name
        strcpy(port_config->Name, value);
        strcpy(ext->SymbolicLinkName, value);  // "COM#"

        MyKdPrint(D_Init,("NewName:%s\n", ext->SymbolicLinkName))
        SerialSetupExternalNaming(ext);  // Configure port

  MyKdPrint(D_Init,("Done renaming\n"))
        ret_stat = 0;  // ok
      }
    break;
#endif

    default:
    return 2;
  }
 return ret_stat;
}

/*-----------------------------------------------------------------------
 SaveRegPath - Make a copy of the DriverEntry() RegistryPath unicode
   string into the registry area we reside.
   Create and save into Driver.RegPath.
|-----------------------------------------------------------------------*/
int SaveRegPath(PUNICODE_STRING RegistryPath)
{
 int len;

  //MyKdPrint(D_Init, ("SaveRegPath A:%s\n", UToC1(RegistryPath)))

  // if RegPath buffer not allocated, then take care of that
  if (Driver.RegPath.Buffer == NULL)
  {
    // allocate buffer space for original regpath
    len = RegistryPath->Length + 2;
    Driver.RegPath.Buffer = ExAllocatePool(PagedPool, len);
    if ( Driver.RegPath.Buffer == NULL ) {
      Eprintf("SaveRegPath no memory");
      return -1;
    }
    Driver.RegPath.MaximumLength = (WORD)len;
    Driver.RegPath.Length = 0;
  }

  RtlZeroMemory(Driver.RegPath.Buffer, Driver.RegPath.MaximumLength);

  //--- copy registry path to our local copy
  RtlMoveMemory(Driver.RegPath.Buffer,
                RegistryPath->Buffer,
                RegistryPath->Length);

  Driver.RegPath.Length = RegistryPath->Length;  // set unicode length
  return 0;
}

/*-----------------------------------------------------------------------
 MakeRegPath - Form a unicode Registry string to an area where we get
   info from the registry.  Concat's str onto original RegistryPath
   and forms a unicode string at Driver.OptionRegPath.
|-----------------------------------------------------------------------*/
int MakeRegPath(CHAR *optionstr)
{
 //UCHAR *upath;  // a byte ptr for byte indexing path stuff
 //WCHAR *pwstr;
 int len;
 USTR_80 utmpstr;

  if (Driver.RegPath.Buffer == NULL)
    return 1;

  //MyKdPrint(D_Init, ("MakeRegPath A:%s\n", UToC1(&Driver.RegPath)))

  // if OptionRegPath buffer not allocated, then take care of that
  if (Driver.OptionRegPath.Buffer == NULL)
  {
    // allocate buffer space for original regpath + room to tack on option
    // strings.
    len = Driver.RegPath.Length + (128*(sizeof(WCHAR)));
    Driver.OptionRegPath.Buffer = ExAllocatePool(PagedPool, len);
    if ( Driver.OptionRegPath.Buffer == NULL ) {
      Eprintf("MakeRegPath no memory");
      return -1;
    }
    Driver.OptionRegPath.MaximumLength = (WORD)len;
    Driver.OptionRegPath.Length = 0;
  }

  RtlZeroMemory(Driver.OptionRegPath.Buffer,
                Driver.OptionRegPath.MaximumLength);

  // copy over the orignal RegPath
  RtlMoveMemory(Driver.OptionRegPath.Buffer,
                Driver.RegPath.Buffer,
                Driver.RegPath.Length);
  Driver.OptionRegPath.Length = Driver.RegPath.Length;

  //---- now tack on what we want to concatinate(example: L"\\Parameters")
  if (optionstr != NULL)
  {
    // convert to unicode
    CToUStr((PUNICODE_STRING) &utmpstr, optionstr, sizeof(utmpstr));

    // Copy the key string over
    RtlCopyMemory( ((UCHAR *) Driver.OptionRegPath.Buffer) +
                     Driver.OptionRegPath.Length,
                   utmpstr.ustr.Buffer,
                   utmpstr.ustr.Length);

    Driver.OptionRegPath.Length += utmpstr.ustr.Length;
  }
  //MyKdPrint(D_Init, ("MakeRegPath B:%s\n", UToC1(&Driver.OptionRegPath)))

  return 0;  // ok
}
#if 0
/*-----------------------------------------------------------------
  reg_get_str - get a str value out of the registry.
|------------------------------------------------------------------*/
int reg_get_str(IN WCHAR *RegPath,
                       int reg_location,
                       const char *str_id,
                       char *dest,
                       int max_dest_len)
{
 RTL_QUERY_REGISTRY_TABLE paramTable[2];
 PUNICODE_STRING ustr;
 USTR_80 ustr_id;
 USTR_80 ustr_val;
 char *ret_str;

  CToUStr((PUNICODE_STRING)&ustr_id, str_id, sizeof(ustr_id));
  RtlZeroMemory(&paramTable[0],sizeof(paramTable));

  //ustr = CToU2("");  // allocated static space for unicode
  ustr = CToUStr((PUNICODE_STRING)&ustr_val, "", sizeof(ustr_val));

  ustr = (PUNICODE_STRING) &ustr_val;  // allocated static space for unicode
  paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
  paramTable[0].Name = ustr_id.ustr.Buffer;
  paramTable[0].EntryContext = ustr;
  paramTable[0].DefaultType = 0;
  paramTable[0].DefaultData = 0;
  paramTable[0].DefaultLength = 0;

  if (!NT_SUCCESS(RtlQueryRegistryValues(
//                      RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                      reg_location | RTL_REGISTRY_OPTIONAL,
                      RegPath,
                      &paramTable[0],
                      NULL,
                      NULL)))
  {
    dest[0] = 0;
    return 1;
  }

  ret_str = (char *) &ustr_id;  // reuse this stack space for u to c conv.
  UToCStr(ret_str, ustr, 80);
  if ((int)strlen(ret_str) > max_dest_len)
    ret_str[max_dest_len] = 0;
    
  strcpy(dest, ret_str);

  return 0;
}

/*-----------------------------------------------------------------
  reg_get_dword - get a dword value out of the registry.
|------------------------------------------------------------------*/
int reg_get_dword(IN WCHAR *RegPath,
                          const char *str_id,
                          ULONG *dest)
{
 ULONG DataValue;
 RTL_QUERY_REGISTRY_TABLE paramTable[2];
 ULONG notThereDefault = 12345678;
 USTR_80 ustr_id;
  CToUStr((PUNICODE_STRING)&ustr_id, str_id, sizeof(ustr_id));

  RtlZeroMemory(&paramTable[0],sizeof(paramTable));

  paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
  paramTable[0].Name = ustr_id.ustr.Buffer;
  paramTable[0].EntryContext = &DataValue;
  paramTable[0].DefaultType = REG_DWORD;
  paramTable[0].DefaultData = &notThereDefault;
  paramTable[0].DefaultLength = sizeof(ULONG);

  if (!NT_SUCCESS(RtlQueryRegistryValues(
                      RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                      RegPath,
                      &paramTable[0],
                      NULL,
                      NULL)))
  {
    return 1;
  }

  if (DataValue == 12345678)
    return 2;

  *dest = DataValue;
  return 0;
}

/*-----------------------------------------------------------------
  reg_set_str - get a dword value out of the registry.
|------------------------------------------------------------------*/
static int reg_set_str(IN WCHAR *RegPath,
                IN const char *str_id,
                IN const char *str_val)
{
 int status;
  USTR_80 ustr_id;
  USTR_80 ustr_val;
  MyKdPrint(D_Init, ("Reg_set, writing %s=%s\n", str_id, str_val))

  CToUStr((PUNICODE_STRING)&ustr_id, str_id, sizeof(ustr_id));
  CToUStr((PUNICODE_STRING)&ustr_val, str_val, sizeof(ustr_val));

  status = RtlWriteRegistryValue(
      RTL_REGISTRY_ABSOLUTE,
      RegPath,
      ustr_id.ustr.Buffer,
      REG_SZ,
      ustr_val.ustr.Buffer,
      ustr_val.ustr.Length);

  if (status != STATUS_SUCCESS)
  {
    MyKdPrint(D_Error, ("Error, writing %s=%s\n", str_id, str_val))
    MyKdPrint(D_Error, ("  Path:%s\n", RegPath))
    return 1;
  }

  return 0;
}

/*-----------------------------------------------------------------
  reg_set_dword - get a dword value out of the registry.
|------------------------------------------------------------------*/
int reg_set_dword(IN WCHAR *RegPath,
                          const char *str_id,
                          ULONG val)
{
 int status;
 USTR_80 ustr_id;
  CToUStr((PUNICODE_STRING)&ustr_id, str_id, sizeof(ustr_id));

  status = RtlWriteRegistryValue(
      RTL_REGISTRY_ABSOLUTE,
      RegPath,
      ustr_id.ustr.Buffer,
      REG_DWORD,
      &val,
      sizeof(ULONG));

  if (status != STATUS_SUCCESS)
  {
    return 1;
  }

  return 0;
}
#endif

/*-----------------------------------------------------------------
  atomac - convert from ascii to mac-addr.
|------------------------------------------------------------------*/
static int atomac(BYTE *mac, char *str)
{
 int i,j;
 WORD h;

  for (i=0; i<6; i++)
  {
    j = 0;
    h = 0xffff;
    h = (WORD)gethint(str, &j);
    str += j;
    if ((h > 0xff) || (j == 0))
      return 1;
    mac[i] = (BYTE) h;
  }
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\opstr.h ===
// opstr.h

//----- Pnp-ID Defines
/* PCI Defines */
#define PCI_VENDOR_ID           0x11fe
#define PCI_DEVICE_32I          0x0001
#define PCI_DEVICE_8I           0x0002
#define PCI_DEVICE_16I          0x0003
#define PCI_DEVICE_4Q           0x0004
#define PCI_DEVICE_8O           0x0005
#define PCI_DEVICE_8RJ          0x0006
#define PCI_DEVICE_4RJ          0x0007
#define PCI_DEVICE_SIEMENS8     0x0008
#define PCI_DEVICE_SIEMENS16    0x0009
#define PCI_DEVICE_RPLUS4       0x000a
#define PCI_DEVICE_RPLUS8       0x000b
#define PCI_DEVICE_RMODEM6      0x000c
#define PCI_DEVICE_RMODEM4      0x000d
#define PCI_DEVICE_RPLUS2       0x000e
#define PCI_DEVICE_422RPLUS2    0x000f

#define ISA_DEVICE_RPORT4       0x1001
#define ISA_DEVICE_RPORT8       0x1002
#define ISA_DEVICE_RPORT16      0x1003
#define ISA_DEVICE_RPORT32      0x1004
#define ISA_DEVICE_RMODEM4      0x2001
#define ISA_DEVICE_RMODEM8      0x2002
#define NET_DEVICE_VS1000       0x3001  // 16 to 64 port
#define NET_DEVICE_VS2000       0x3002  // 8 port
#define NET_DEVICE_RHUB8        0x3003
#define NET_DEVICE_RHUB4        0x3004

// ids for Our_Option.var_type
#define OP_T_DWORD  0
#define OP_T_STRING 1
#define OP_T_BOOL   2

// flags for Our_Option.flags
#define OP_F_VS             1
#define OP_F_RK             2
#define OP_F_VSRK           3
#define OP_F_SETUP_ONLY     8

typedef struct {
  const char * name;  // name of option see lists
  int id;     // unique id, also has bit which tells option type.
  WORD var_type;  // see OP_T_* types, 0=DWORD, 1=String, 2=BOOL
  WORD    flags;  // see OP_F_* types
} Our_Options;

// driver options
extern const char szVerboseLog[]   ;
extern const char szNumDevices[]   ;
extern const char szNoPnpPorts[]   ;
extern const char szScanRate[]     ;
extern const char szModemCountry[] ;
extern const char szGlobalRS485[]  ;

#define OP_VerboseLog    0x100
#define OP_NumDevices    0x101
#define OP_NoPnpPorts    0x102
#define OP_ScanRate      0x103
#define OP_ModemCountry  0x104
#define OP_GlobalRS485   0x105

// device options
//extern const char szStartComIndex[] ;
extern const char szNumPorts[]      ;
extern const char szMacAddr[]       ;
extern const char szBackupServer[]  ;
extern const char szBackupTimer[]   ;
extern const char szName[]          ;
extern const char szModelName[]     ;
extern const char szIoAddress[]     ;
extern const char szModemDevice[]   ;
extern const char szHubDevice[]     ;
extern const char szClkRate[]       ;
extern const char szClkPrescaler[]  ;

//#define OP_StartComIndex   0x200
#define OP_NumPorts        0x201
#define OP_MacAddr         0x202
#define OP_BackupServer    0x203
#define OP_BackupTimer     0x204
#define OP_Name            0x205
#define OP_ModelName       0x206
#define OP_IoAddress       0x207
#define OP_ModemDevice     0x208
#define OP_HubDevice       0x209
#define OP_ClkRate         0x20a
#define OP_ClkPrescaler    0x20b

// port options
extern const char szWaitOnTx[]      ;
extern const char szRS485Override[] ;
extern const char szRS485Low[]      ;
extern const char szTxCloseTime[]   ;
extern const char szLockBaud[]      ;
extern const char szMap2StopsTo1[]  ;
extern const char szMapCdToDsr[]    ;
extern const char szRingEmulate[]   ;
  	
#define OP_WaitOnTx         0x400
#define OP_RS485Override    0x401
#define OP_RS485Low         0x402
#define OP_TxCloseTime      0x403
#define OP_LockBaud         0x404
#define OP_Map2StopsTo1     0x405
#define OP_MapCdToDsr       0x406
#define OP_PortName         0x407
#define OP_RingEmulate      0x408

extern Our_Options driver_options[];
extern Our_Options device_options[];
extern Our_Options port_options[];

int HdwIDStrToID(int *Hardware_ID, char *idstr);
int id_to_num_ports(int id);
int IsHubDevice(int Hardware_ID);
int IsModemDevice(int Hardware_ID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\pnpadd.c ===
/*----------------------------------------------------------------------
 pnpadd.c - Handle pnp adding devices.
|----------------------------------------------------------------------*/
#include "precomp.h"

#ifdef NT50

NTSTATUS AddBoardDevice(
               IN  PDRIVER_OBJECT DriverObject,
               IN  PDEVICE_OBJECT Pdo,
               OUT PDEVICE_OBJECT *NewDevObj);

NTSTATUS AddPortDevice(
               IN  PDRIVER_OBJECT DriverObject,
               IN  PDEVICE_OBJECT Pdo,
               OUT PDEVICE_OBJECT *NewDevObj,
               IN  int port_index);

NTSTATUS CheckPortName(
               IN PDEVICE_OBJECT Pdo,
               IN PSERIAL_DEVICE_EXTENSION ParentExt,
               IN int port_index);

#define CFG_ID_ISA_BRD_INDEX  0
#define CFG_ID_NODE_INDEX     1
static int read_config_data(PDEVICE_OBJECT Pdo, int *ret_val, int val_id);
static int write_config_data(PDEVICE_OBJECT Pdo, int val, int val_id);
static int derive_unique_node_index(int *ret_val);
static int GetPnpIdStr(PDEVICE_OBJECT Pdo, char *ret_val);


/*----------------------------------------------------------------------
 SerialAddDevice -
    This routine creates a functional device object for boards or
    com ports in the system and attaches them to the physical device
    objects for the boards or ports.

Arguments:
    DriverObject - a pointer to the object for this driver
    PhysicalDeviceObject - a pointer to the physical object we need to attach to

Return Value:
    status from device creation and initialization
|----------------------------------------------------------------------*/
NTSTATUS SerialAddDevice(
               IN PDRIVER_OBJECT DriverObject,
               IN PDEVICE_OBJECT Pdo)
{
   PDEVICE_OBJECT  fdo         = NULL;
   PDEVICE_OBJECT  lowerDevice = NULL;
   PDEVICE_OBJECT  NewDevObj = NULL;
   NTSTATUS        status;
#if DBG_STACK
   int i;
#endif
   int stat;
   int board_device = 1;  // asume pnp board device(not pnp port)
   //PDEVICE_OBJECT   deviceOjbect;
   PSERIAL_DEVICE_EXTENSION    deviceExtension;
   ULONG resultLength;
   USTR_240 *us;  // equal to 240 normal chars length
   char *ptr;
   int port_index;

   // Using stack array instead of static buffer for unicode conversion

   char cstr[320];

   //char temp_szNt50DevObjName[80];
#if DBG_STACK
   DWORD stkchkend;
   DWORD stkchk;
   DWORD *stkptr;
#endif

   MyKdPrint(D_PnpAdd,("RK:SerialAddDevice Start DrvObj:%x, PDO:%x\n",
      DriverObject, Pdo))

   MyKdPrint(D_Pnp, ("SerialAddDevice\n"))
#if DBG_STACK
   stkchk = 0;
   stkptr = (DWORD *)&DriverObject;
   for (i=0; i<50; i++)
   {
     stkchk += *stkptr++;
   }
#endif

   //PAGED_CODE();

   if (Pdo == NULL) {
      //  Bugbug: This is where enumeration occurs.
      //           One possible use for this is to add the user defined
      //           ports from the registry
      // For now: just return no more devices
      MyKdPrint(D_Error, ("NullPDO.\n"))
      return (STATUS_NO_MORE_ENTRIES);
   }

   us = ExAllocatePool(NonPagedPool, sizeof(USTR_240));
   if ( us == NULL ) {
     MyKdPrint(D_Error, ("SerialAddDevice no memory.\n"))
     return STATUS_INSUFFICIENT_RESOURCES;
   }

      // configure the unicode string to: point the buffer ptr to the wstr.
   us->ustr.Buffer = us->wstr;
   us->ustr.Length = 0;
   us->ustr.MaximumLength = sizeof(USTR_240) - sizeof(UNICODE_STRING);

   // get the friendly name
   // "Comtrol xxxx xx" for board, "Comtrol Port(COM24)" for port.
   status = IoGetDeviceProperty (Pdo, 
                                 DevicePropertyFriendlyName,
                                 us->ustr.MaximumLength,
                                 us->ustr.Buffer,
                                 &resultLength);
   us->ustr.Length = (USHORT) resultLength;
//   ptr = UToC1(&us->ustr);
   ptr = UToCStr( cstr,
	              &us->ustr,
				  sizeof( cstr ));
   MyKdPrint(D_Pnp, ("FriendlyName:%s\n", ptr))

   // get the class-name
   // "MultiPortSerial" for board, "Ports" for port.
   status = IoGetDeviceProperty (Pdo, 
                                 DevicePropertyClassName,  // Ports
                                 us->ustr.MaximumLength,
                                 us->ustr.Buffer,
                                 &resultLength);
   us->ustr.Length = (USHORT) resultLength;
//   ptr = UToC1(&us->ustr);
   ptr = UToCStr( cstr,
	              &us->ustr,
				  sizeof( cstr ));
   MyKdPrint(D_Pnp, ("ClassName:%s\n", ptr))
   if (my_toupper(*ptr) == 'P')  // "Ports"
   {
     MyKdPrint(D_Pnp, ("A Port!\n"))
     board_device = 0;  // its a port pnp device
   }
   // else it's the default: a board device

   // get the dev-desc
   // "RocketPort Port0" for port, "RocketPort 8 Port, ISA-BUS" for board
   status = IoGetDeviceProperty (Pdo, 
                                 DevicePropertyDeviceDescription,
                                 us->ustr.MaximumLength,
                                 us->ustr.Buffer,
                                 &resultLength);
   us->ustr.Length = (USHORT) resultLength;
//   ptr = UToC1(&us->ustr);
   ptr = UToCStr( cstr,
	              &us->ustr,
				  sizeof( cstr ));
   MyKdPrint(D_Pnp, ("DevDesc:%s\n", ptr))

   // Find out what the PnP manager thinks my NT Hardware ID is
   // "CtmPort0000" for port, "rckt1002" for isa-board
   // for pci we are getting a huge string, 400 bytes long, not good...
   status = IoGetDeviceProperty (Pdo,
                                 DevicePropertyHardwareID,  // port0000
                                 us->ustr.MaximumLength,
                                 us->ustr.Buffer,
                                 &resultLength);
   MyKdPrint(D_Pnp, ("status:%d\n", status))
   us->ustr.Length = (USHORT) resultLength;
   MyKdPrint(D_Pnp, ("Len:%d\n",resultLength))
//   ptr = UToC1(&us->ustr);
   ptr = UToCStr( cstr,
	              &us->ustr,
				  sizeof( cstr ));
   MyKdPrint(D_Pnp, ("DevHdwID:%s\n", ptr))

   if (board_device)  // record board type according to pnp
   {
//     if (strlen(ptr) < 12)
//     {
//       i = gethint(&ptr[4], NULL);
//       MyKdPrint(D_Pnp, ("HdwID:%d\n", i))
//       Hardware_Id = i;
//     }
   }
   else // its a port pnp device, find the port-index
   {
     while ((*ptr != 0) && (*ptr != '0'))
       ++ptr;
     port_index = getint(ptr, NULL);
     MyKdPrint(D_Pnp, ("port_index:%d\n", port_index))
   }

#if 0
   // key name
   // {50906CB8-BA12-11D1-BF5D-0000F805F530}\0001 for board
   status = IoGetDeviceProperty (Pdo, 
                                 DevicePropertyDriverKeyName,  // 4D36....
                                 us->ustr.MaximumLength,
                                 us->ustr.Buffer,
                                 &resultLength);
   us->ustr.Length = (USHORT) resultLength;
   MyKdPrint(D_Pnp, ("KeyName:%s\n", UToC1(&us->ustr)))


   // Find out what the PnP manager thinks my NT Hardware ID is
   // \Device\003354  typical
   status = IoGetDeviceProperty (Pdo, 
                                 DevicePropertyPhysicalDeviceObjectName,   // \Device\003354
                                 us->ustr.MaximumLength,
                                 us->ustr.Buffer,
                                 &resultLength);
   us->ustr.Length = (USHORT) resultLength;
   MyKdPrint(D_Pnp, ("DevName:%s\n", UToC1(&us->ustr)))

   if (board_device)
   {
     int i,j;
     // we need to use this later as this is what our config data is
     // stored under.  Since we want to read in our config before
     // creating the board and port extensions(where the config
     // record eventually ends up), we setup the first entry in
     // the static array of device configuration records as our
     // own as a temporary measure so our read options routine
     // has a place to put the config data.
     strcpy(temp_szNt50DevObjName, UToC1(&us->ustr));
     // strip off the forward slashes
     i=0;
     j=0;
     while (temp_szNt50DevObjName[i] != 0)
     {
       if (temp_szNt50DevObjName[i] != '\\')
         temp_szNt50DevObjName[j++] = temp_szNt50DevObjName[i];
       i++;
     }
     temp_szNt50DevObjName[j] = 0;
   }
#endif
   ExFreePool(us);
   us = NULL;

   MyKdPrint(D_Pnp, ("CreateFdo\n"))

   if (board_device)
   {
      status = AddBoardDevice(DriverObject, Pdo, &NewDevObj);
      if (status != STATUS_SUCCESS)
      {
        MyKdPrint(D_Error, ("Err, Creating Board Obj\n"))
        return status;
      }
      deviceExtension = NewDevObj->DeviceExtension;
      //strcpy(deviceExtension->config->szNt50DevObjName, temp_szNt50DevObjName);

      // read in our device configuration from the registry
      stat = read_device_options(deviceExtension);

   }  // board device
   else
   {
      status = AddPortDevice(DriverObject, Pdo, &NewDevObj, port_index);
   }

   if (status != STATUS_SUCCESS)
   {
     MyKdPrint(D_Error,("Error on NewPort Create!\n"))

     return status;
   }
   fdo = NewDevObj;
 
   // Layer our FDO on top of the PDO
   // The return value is a pointer to the device object to which the
   //    fdo is actually attached.
   lowerDevice = IoAttachDeviceToDeviceStack(fdo, Pdo);

   MyKdPrint(D_PnpAdd,("RK:SerialAddDevice New FDO:%x, Ext:%x TopOfStack:%x\n",
        fdo, fdo->DeviceExtension, lowerDevice))

   // No status. Do the best we can.
   MyAssert(lowerDevice);

   // fdo source, pdo is target, save handle to lower device object
   deviceExtension                     = fdo->DeviceExtension;
   deviceExtension->LowerDeviceObject  = lowerDevice;
   deviceExtension->Pdo = Pdo;  // save off the handle to the pdo

   // Set the stack requirement for this device object to 2 + the size of the 
   // lower device's stack size.  This will allow the same Irp that comes in 
   // for Open and Close calls to be used for the PoCallDriver calls to change 
   // the power state of the device.
   // fdo->StackSize = lowerDevice->StackSize + 2;

   fdo->Flags    |= DO_POWER_PAGABLE;

#if DBG_STACK
   stkchkend = 0;
   stkptr = (DWORD *)&DriverObject;
   for (i=0; i<50; i++)
   {
     stkchkend += *stkptr++;
   }
   if (stkchkend != stkchk)
   {
     MyKdPrint(D_Error, ("Err, ******** STACK CHECK FAIL!!!!\n"))
   }
   else
   {
     MyKdPrint(D_Error, ("OK Stack chk\n"))
   }
#endif

   MyKdPrint(D_PnpAdd, ("End SerialAddDevice\n"))

   MyKdPrint(D_Pnp, ("End SerialAddDevice\n"))
   return status;
}

/*----------------------------------------------------------------------
  AddBoardDevice - Setup and Create a board device in response to
    AddDevice ioctl.
|----------------------------------------------------------------------*/
NTSTATUS AddBoardDevice(
               IN  PDRIVER_OBJECT DriverObject,
               IN  PDEVICE_OBJECT Pdo,
               OUT PDEVICE_OBJECT *NewDevObj)
{
   PSERIAL_DEVICE_EXTENSION NewExtension = NULL;
   NTSTATUS                    status          = STATUS_SUCCESS;
   char tmpstr[110];
   ULONG Hardware_ID = 0;
   int num_ports = 0;
   int stat;
   static int max_isa_board_index = 0;
   int device_node_index = -1;
   int isa_board_index = -1;

   MyKdPrint(D_Pnp, ("AddBoardDevice\n"))

     // Find out what the PnP manager thinks my NT pnp Hardware ID is
   tmpstr[0] = 0;
   stat = GetPnpIdStr(Pdo, tmpstr);
   if (stat)
   {
     MyKdPrint(D_Error, ("Err, HdwID 1B\n"))
   }
   MyKdPrint(D_Test, ("DevHdwID:%s\n", tmpstr))

     // Parse this info, tells us what type of board we have
   stat = HdwIDStrToID(&Hardware_ID, tmpstr);
   if (stat)
   {
     MyKdPrint(D_Error, ("Err, HdwID 1A:%s\n", tmpstr))
   }
   MyKdPrint(D_Pnp, ("HdwID:%x\n", Hardware_ID))

     // Read in our Node Index, see if we are new...
   stat = read_config_data(Pdo, &device_node_index, CFG_ID_NODE_INDEX);

   if (stat)  // not exist
   {
     derive_unique_node_index(&device_node_index);
     MyKdPrint(D_Test, ("Derive Node ID:%d\n", device_node_index))
     stat = write_config_data(Pdo, device_node_index, CFG_ID_NODE_INDEX);
   }
   else
   {
     MyKdPrint(D_Test, ("Node ID:%d\n", device_node_index))
   }
   if (device_node_index < 0)
       device_node_index = 0;

#ifdef S_RK
   // try to order the ISA boards
   if ((Hardware_ID >= 0x1000) && (Hardware_ID <= 0x2fff))  // its ISA
   {
     stat = read_config_data(Pdo, &isa_board_index, CFG_ID_ISA_BRD_INDEX);
     MyKdPrint(D_Pnp,("Read isa_board_index:%d\n", isa_board_index))
   }
#endif

   //----- create a board device
   Driver.Stop_Poll = 1;  // flag to stop poll access

   if (Driver.driver_ext == NULL)
   {
     status = CreateDriverDevice(Driver.GlobalDriverObject,
                                 &NewExtension);  // create the driver device
#ifdef S_VS
     init_eth_start();
#endif
   }

   status = CreateBoardDevice(Driver.GlobalDriverObject,
                              &NewExtension);  // create the board device

   *NewDevObj = NewExtension->DeviceObject;
   if (status != STATUS_SUCCESS)
   {
      Driver.Stop_Poll = 0;  // flag to stop poll access
      Eprintf("CreateBoardDevice Err1A");
      return status;
   }

   // DoPnpAssoc(Pdo);

     // copy over our key name used to find config info in the registry
   Sprintf(NewExtension->config->szNt50DevObjName, "Device%d", device_node_index);
#if 0
   //strcpy(NewExtension->config->szNt50DevObjName, PnpKeyName);
#endif

   NewExtension->config->Hardware_ID = Hardware_ID;
   num_ports = id_to_num_ports(Hardware_ID);
   MyKdPrint(D_Test, ("NumPorts:%d\n", num_ports))

   // read in our device configuration from the registry
   stat = read_device_options(NewExtension);

   //if (!(Hardware_ID == NET_DEVICE_VS1000))  // jam in
   //  NewExtension->config->NumPorts = num_ports;

   if (NewExtension->config->NumPorts == 0)
     NewExtension->config->NumPorts = num_ports;

   // check for ModemDevice, etc.
   if (IsModemDevice(Hardware_ID))
     NewExtension->config->ModemDevice = 1;

   MyKdPrint(D_Pnp, ("Num Ports:%d\n",NewExtension->config->NumPorts))

#ifdef S_RK
   // try to order the ISA boards
   if ((Hardware_ID >= 0x1000) && (Hardware_ID <= 0x2fff))  // its ISA
   {
     if (isa_board_index == -1)  // new
     {
       isa_board_index = max_isa_board_index;
       stat = write_config_data(Pdo, isa_board_index, CFG_ID_ISA_BRD_INDEX);
       MyKdPrint(D_Pnp,("Save IsaIndex:%d\n", isa_board_index))
     }
     // bump so next isa board gets new index
     if (max_isa_board_index >= isa_board_index)
       max_isa_board_index = isa_board_index + 1;
     NewExtension->config->ISABrdIndex = isa_board_index;
   }  // isa board
#endif

   Driver.Stop_Poll = 0;  // flag to stop poll access

   status = STATUS_SUCCESS;
   return status;
}

/*----------------------------------------------------------------------
  derive_unique_node_index -
|----------------------------------------------------------------------*/
static int derive_unique_node_index(int *ret_val)
{
  HANDLE DrvHandle = NULL;
  HANDLE DevHandle = NULL;
  char tmpstr[40];
  int i, stat;

  // force a creation of "Parameters" if not exist
  stat = our_open_driver_reg(&DrvHandle, KEY_ALL_ACCESS);

  for (i=0; i< 100; i++)
  {
    Sprintf(tmpstr,"Device%d", i);
    stat = our_open_key(&DevHandle,
                 DrvHandle, tmpstr,  KEY_READ);

    if (stat)  // does not exist
    {
      // create it, so next one won't pick up the same
      stat = our_open_key(&DevHandle,
                   DrvHandle, tmpstr,  KEY_ALL_ACCESS);

      ZwClose(DevHandle);
      ZwClose(DrvHandle);
      *ret_val = i;
      return 0;  // ok
    }
  }

  ZwClose(DevHandle);
  ZwClose(DrvHandle);
  return 1;  // err
}

/*----------------------------------------------------------------------
  GetPnpIdStr - 
|----------------------------------------------------------------------*/
static int GetPnpIdStr(PDEVICE_OBJECT Pdo, char *ret_val)
{
  NTSTATUS status = STATUS_SUCCESS;
  UNICODE_STRING ustr;
  ULONG resultLength = 0;
  char *ptr;

   // configure the unicode string to: point the buffer ptr to the wstr.
   ustr.Buffer = ExAllocatePool(PagedPool, 1002);
   if ( ustr.Buffer == NULL ) {
     return -1;
   }
   ustr.Length = 0;
   ustr.MaximumLength = 1000;

   MyKdPrint(D_Pnp, ("AddBoardDevice\n"))

   // Find out what the PnP manager thinks my NT Hardware ID is
   // "CtmPort0000" for port, "rckt1002" for isa-board
   // for pci we are getting a multi-wstring, 400 bytes long with
   //  "PCI\VEN_11FE&DEV_0003&SUBSYS00000...",0,"PCI\VEN.."
   status = IoGetDeviceProperty (Pdo,
                                 DevicePropertyHardwareID,  // port0000
                                 ustr.MaximumLength,
                                 ustr.Buffer,
                                 &resultLength);
   ustr.Length = (USHORT) resultLength;
   if (ustr.Length > 100)
       ustr.Length = 100;  // limit
   ptr = UToC1(&ustr);

   strcpy(ret_val, ptr);

   ExFreePool(ustr.Buffer);
   MyKdPrint(D_Pnp, ("DevHdwID:%s\n", ret_val))
  return 0;
}

#if 0
/*----------------------------------------------------------------------
  DoPnpAssoc - Weird pnp stuff I haven't figured out yet
|----------------------------------------------------------------------*/
static int DoPnpAssoc(PDEVICE_OBJECT Pdo)
{
   if (!Driver.NoPnpPorts)
   {
#ifdef DO_BUS_SHINGLES
     //
     // Tell the PlugPlay system that this device will need an interface
     // device class shingle.
     //
     // It may be that the driver cannot hang the shingle until it starts
     // the device itself, so that it can query some of its properties.
     // (Aka the shingles guid (or ref string) is based on the properties
     // of the device.)
     //
     status = IoRegisterDeviceInterface (
               Pdo,  // BusPhysicalDeviceObject
               (LPGUID) &GUID_CTMPORT_BUS_ENUMERATOR,
               NULL, // No ref string
               &NewExtension->DevClassAssocName);
#endif
        //
        // If for any reason you need to save values in a safe location that
        // clients of this DeviceClassAssociate might be interested in reading
        // here is the time to do so, with the function
        // IoOpenDeviceClassRegistryKey
        // the symbolic link name used is was returned in
        // deviceData->DevClassAssocName (the same name which is returned by
        // IoGetDeviceClassAssociations and the SetupAPI equivs.
        //

        //status = IoGetDeviceProperty (BusPhysicalDeviceObject,
        //                              DevicePropertyPhysicalDeviceObjectName,
        //                              0,
        //                              NULL,
        //                              &nameLength);
        //IoGetDeviceProperty (BusPhysicalDeviceObject,
        //                     DevicePropertyPhysicalDeviceObjectName,
        //                     nameLength,
        //                     deviceName,
        //                     &nameLength);
        //Game_KdPrint (deviceData, GAME_DBG_SS_TRACE,
        //              ("AddDevice: %x to %x->%x (%ws) \n",
        //               deviceObject,
        //               NewExtension->TopOfStack,
        //               BusPhysicalDeviceObject,
        //               deviceName));


        //
        // Turn on the shingle and point it to the given device object.
        //
#ifdef DO_BUS_SHINGLES
        status = IoSetDeviceInterfaceState (
                        &NewExtension->DevClassAssocName,
                        TRUE);

        if (!NT_SUCCESS (status)) {
            Game_KdPrint (deviceData, GAME_DBG_SS_ERROR,
                          ("AddDevice: IoSetDeviceClass failed (%x)", status));
            return status;
        }
#endif
    //IoInvalidateDeviceRelations (NewExtension->DeviceObject, BusRelations);
   }  // !NoPnpPorts
#endif

/*----------------------------------------------------------------------
  write_config_data - 
|----------------------------------------------------------------------*/
static int write_config_data(PDEVICE_OBJECT Pdo, int val, int val_id)
{
  HANDLE                      keyHandle;
  NTSTATUS                    status          = STATUS_SUCCESS;
  USTR_40 uname;

  status = IoOpenDeviceRegistryKey(Pdo, PLUGPLAY_REGKEY_DRIVER, 
              KEY_WRITE, &keyHandle);

  if (!NT_SUCCESS(status))
  {
    MyKdPrint(D_Error, ("Err7V\n"))
    return 1;
  }
  switch(val_id)
  {
    case CFG_ID_ISA_BRD_INDEX:
      CToUStr((PUNICODE_STRING)&uname, "isa_board_index", sizeof(uname));
    break;

    case CFG_ID_NODE_INDEX:
      CToUStr((PUNICODE_STRING)&uname, "CtmNodeId", sizeof(uname));
    break;
  }
  status = ZwSetValueKey (keyHandle,
                          (PUNICODE_STRING) &uname,
                          0,  // type optional
                          REG_DWORD,
                          &val,
                          sizeof(REG_DWORD));
 
  if (!NT_SUCCESS(status))
  {
    MyKdPrint(D_Error, ("Err8V\n"))
  }
  ZwClose(keyHandle);
  return 0;
}

/*----------------------------------------------------------------------
  read_config_data - 
|----------------------------------------------------------------------*/
static int read_config_data(PDEVICE_OBJECT Pdo, int *ret_val, int val_id)
{
   HANDLE                      keyHandle;
   NTSTATUS                    status          = STATUS_SUCCESS;
   ULONG tmparr[100];
   USTR_40 uname;
   PKEY_VALUE_PARTIAL_INFORMATION parInfo =
     (PKEY_VALUE_PARTIAL_INFORMATION) &tmparr[0];
   ULONG length;
   int ret_stat = 1;  // err

   //----- go grab some configuration info from registry
   // PLUGPLAY_REGKEY_DRIVER opens up the control\class\{guid}\node
   // PLUGPLAY_REGKEY_DEVICE opens up the enum\enum-type\node\Device Parameters
   status = IoOpenDeviceRegistryKey(Pdo,
                                    PLUGPLAY_REGKEY_DRIVER,
                                    STANDARD_RIGHTS_READ,
                                    &keyHandle);

   if (!NT_SUCCESS(status))
   {
     return 2;  // err
   }
   switch(val_id)
   {
     case CFG_ID_ISA_BRD_INDEX:
       CToUStr((PUNICODE_STRING)&uname, "isa_board_index", sizeof(uname));
     break;

     case CFG_ID_NODE_INDEX:
       CToUStr((PUNICODE_STRING)&uname, "CtmNodeId", sizeof(uname));
     break;
   }
   // try to order the ISA boards
   status = ZwQueryValueKey (keyHandle,
                             (PUNICODE_STRING) &uname,
                             KeyValuePartialInformation,
                             parInfo,
                             sizeof(tmparr),
                             &length);

   if (NT_SUCCESS(status))
   {
     if (parInfo->Type == REG_DWORD)
     {
       ret_stat = 0;  // ok
       *ret_val = *((ULONG *) &parInfo->Data[0]);
       //MyKdPrint(D_Pnp,("Read isa_board_index:%d\n", isa_board_index))
     }
   }
   ZwClose(keyHandle);

   return ret_stat;
}
/*----------------------------------------------------------------------
  AddPortDevice - Setup and Create a pnp port device in response to
    AddDevice ioctl.  This can be caused by either:
      * pdo port objects ejected from our driver at board startup.
|----------------------------------------------------------------------*/
NTSTATUS AddPortDevice(
               IN  PDRIVER_OBJECT DriverObject,
               IN  PDEVICE_OBJECT Pdo,
               OUT PDEVICE_OBJECT *NewDevObj,
               IN  int port_index)
{
   NTSTATUS status = STATUS_SUCCESS;


   PSERIAL_DEVICE_EXTENSION NewExtension;
   PSERIAL_DEVICE_EXTENSION ext;
   PSERIAL_DEVICE_EXTENSION ParExt;

   MyKdPrint(D_Pnp, ("AddPortDevice\n"))

   // Find the parent device
   ext = (PSERIAL_DEVICE_EXTENSION) Pdo->DeviceExtension;
   if (ext == NULL)
   {
     MyKdPrint(D_Pnp, ("Er7E\n"))
     return STATUS_SERIAL_NO_DEVICE_INITED;
   }
   else
     ParExt = ext->board_ext;

   CheckPortName(Pdo, ParExt, port_index);

   //----- create a port device
   Driver.Stop_Poll = 1;  // flag to stop poll access

   status = CreatePortDevice(
                           Driver.GlobalDriverObject,
                           ParExt, // parent ext.
                           &NewExtension,  // new device ext.
                           port_index,  // port index, channel number
                           1);  // is_fdo

   if (status != STATUS_SUCCESS)
   {
     Driver.Stop_Poll = 0;  // flag to stop poll access
     MyKdPrint(D_Error, ("Error Creating Port\n"))
     return STATUS_SERIAL_NO_DEVICE_INITED;
   }

   if (status == STATUS_SUCCESS)
   {
     *NewDevObj = NewExtension->DeviceObject;

     status = StartPortHardware(NewExtension, port_index);

     if (status != STATUS_SUCCESS)
     {
       Driver.Stop_Poll = 0;  // flag to stop poll access
       MyKdPrint(D_Error, ("5D\n"))
       // bugbug: should delete our port here
       return STATUS_SERIAL_NO_DEVICE_INITED;
     }
   }

   if (!NT_SUCCESS(status)) {
      Driver.Stop_Poll = 0;  // flag to stop poll access
      Eprintf("CreateBoardDevice Err1A");
      return status;
   }

   Driver.Stop_Poll = 0;  // flag to stop poll access

   status = STATUS_SUCCESS;
   return status;
}

/*----------------------------------------------------------------------
  CheckPortName - Make sure the port-name for us in the registry works.
    Get the pnp-port name held in the enum branch, if ours does not match,
    then change it to match(use the pnp-port name.)
|----------------------------------------------------------------------*/
NTSTATUS CheckPortName(
               IN PDEVICE_OBJECT Pdo,
               IN PSERIAL_DEVICE_EXTENSION ParentExt,
               IN int port_index)
{
   HANDLE    keyHandle;
   NTSTATUS  status;
   char namestr[20];

   PORT_CONFIG *port_config;

   MyKdPrint(D_Pnp, ("CheckPortName\n"))

   //----- go grab PORTNAME configuration info from registry
     // serial keeps params under ENUM branch so we open DEVICE not DRIVER
     // which is considered CLASS area.
     // opens: enum\device\node\Device Parameters area
     // status = IoOpenDeviceRegistryKey(Pdo, PLUGPLAY_REGKEY_DRIVER, 

   namestr[0] = 0;
   status = IoOpenDeviceRegistryKey(Pdo,
                                    PLUGPLAY_REGKEY_DEVICE,
                                    STANDARD_RIGHTS_READ,
                                    &keyHandle);

   // go get "Device Parameters\PortName"="COM5"
   // also, key params: PollingPeriod=, Serenumerable=
   if (NT_SUCCESS(status))
   {
     status = get_reg_value(keyHandle, namestr, "PortName", 15);
     if (status)  // err
     {
       namestr[0] = 0;
       MyKdPrint(D_Error, ("No PortName\n"))
     }
     else
     {
       MyKdPrint(D_Pnp, ("PortName:%s\n", namestr))
     }
     ZwClose(keyHandle);
   }

   if ((strlen(namestr) > 10) || (strlen(namestr) <= 0))
   {
     MyKdPrint(D_Error, ("Bad PortName Er1E\n"))
   }

   port_config = &ParentExt->config->port[port_index];

   if (my_lstricmp(port_config->Name, namestr) != 0)  // it does not match!
   {
     MyKdPrint(D_Pnp, ("port name fixup to:%s, from%s\n",
               namestr, port_config->Name))
     // fix it, use one assigned by port class installer
     strcpy(port_config->Name, namestr);
     write_port_name(ParentExt, port_index);
   }

  return 0;
}

#endif // nt50
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\pnp.h ===
// Define an Interface Guid to access the game port enumerator
//

#undef FAR
#define FAR
#undef PHYSICAL_ADDRESS
#define PHYSICAL_ADDRESS LARGE_INTEGER

#ifdef NT50
//DEFINE_GUID (GUID_CTMPORT_BUS_ENUMERATOR, 0x11223344, 0x684a, 0x11d0, 0xd6, 0xf6, 0x00, 0xa0, 0xc9, 0x0f, 0x57, 0xda);
//  11223344-684a-11d0-b6f6-00a0c90f57da

#include <initguid.h>

// GUIDs for the board & ports
//
DEFINE_GUID (GUID_CTMPORT_MPS, 0x50906cb8, 0xba12, 0x11d1, 0xbf, 0x5d, 0x00, 0x00, 0xf8, 0x05, 0xf5, 0x30);
// 50906cb8-ba12-11d1-bf5d-0000f805f530
//DEFINE_GUID (GUID_CLASS_COMPORT, 0x4d36e978, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18);
// 4d36e978-e325-11ce-bfc1-08002be10318
// GUID_CLASS_COMPORT changed for Whistler 
DEFINE_GUID (GUID_CLASS_COMPORT, 0x86e0d1e0, 0x8089, 0x11d0, 0x9c, 0xe4, 0x08, 0x00, 0x3e, 0x30, 0x1f, 0x73);
// 86e0d1e0-8089-11d0-9ce4-08003e301f73

#endif

NTSTATUS SerialPnpDispatch(IN PDEVICE_OBJECT Fdo, IN PIRP Irp);
NTSTATUS SerialPowerDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

VOID SerialKillPendingIrps(PDEVICE_OBJECT DeviceObject);
BOOLEAN SerialIRPPrologue(IN PSERIAL_DEVICE_EXTENSION PDevExt);
VOID SerialIRPEpilogue(IN PSERIAL_DEVICE_EXTENSION PDevExt);
NTSTATUS
SerialIoCallDriver(PSERIAL_DEVICE_EXTENSION PDevExt, PDEVICE_OBJECT PDevObj,
		   PIRP PIrp);
NTSTATUS
SerialPoCallDriver(PSERIAL_DEVICE_EXTENSION PDevExt, PDEVICE_OBJECT PDevObj,
		   PIRP PIrp);

#ifdef NT50
#define SerialCompleteRequest(PDevExt, PIrp, PriBoost) \
   { \
      IoCompleteRequest((PIrp), (PriBoost)); \
      SerialIRPEpilogue((PDevExt)); \
   }
#else
#define SerialCompleteRequest(PDevExt, PIrp, PriBoost) \
   { \
      IoCompleteRequest((PIrp), (PriBoost)); \
      InterlockedDecrement(&((PDevExt)->PendingIRPCnt)); \
   }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\pnprckt.c ===
/*----------------------------------------------------------------------
 pnprckt.c - rocketport pnp specific things.
|----------------------------------------------------------------------*/
#include "precomp.h"
#define TraceStr(s)          GTrace(D_Pnp, sz_modid, s)
#define TraceStr1(s, p1)     GTrace1(D_Pnp, sz_modid, s, p1)
#define TraceStr2(s, p1, p2) GTrace2(D_Pnp, sz_modid, s, p1, p2)

#define DTraceStr(s)         DTrace(D_Pnp, sz_modid, s)
#define TraceErr(s) GTrace(D_Error, sz_modid_err, s)

static char *sz_modid = {"pnpadd"};
static char *sz_modid_err = {"Error,pnpadd"};


/*----------------------------------------------------------------------
 PrimaryIsaBoard - Search for Primary Isa boards, if found then return
  a pointer to the extension.

Return Value:
    Return ptr to extension of primary Isa board, if not found, null.
|----------------------------------------------------------------------*/
PSERIAL_DEVICE_EXTENSION FindPrimaryIsaBoard(void)
{
  PSERIAL_DEVICE_EXTENSION ext;

  ext = Driver.board_ext;
  while (ext)
  {
    if (ext->config->BusType == Isa)
    {
      // first board must have 4 hex io-defined, 4 bytes for mudback.
      // additional isa-boards alias up on original to save space.
      if ((ext->config->BaseIoSize == 0x44) &&
          (ext->config->ISABrdIndex == 0))
      {
        return ext;
      }
    }
    ext = ext->board_ext;  // next in chain
  }  // while ext
  return NULL;
}

#ifdef NT50

/*----------------------------------------------------------------------
 GetPCIRocket - find the pci-card indicated by BaseAddr and fill in
   the rest of the info in the config.
|----------------------------------------------------------------------*/
int GetPCIRocket(ULONG BaseAddr, DEVICE_CONFIG *CfCtl)
{
 PCI_COMMON_CONFIG *PCIDev;
 UCHAR i;
 NTSTATUS Status;
 int Slot;
 int NumPCI;

 NumPCI =  FindPCIBus();
 if (NumPCI == 0)
  return 1;

  PCIDev = ExAllocatePool(NonPagedPool,sizeof(PCI_COMMON_CONFIG));
  if ( PCIDev == NULL ) {
    Eprintf("No memory for PCI device.");
    return 1;
  }

  for(i=0;i<NumPCI;++i)
  {
    for(Slot = 0;Slot < 32;++Slot) /*5 bits for device 32 = 2^5*/
    {
      // get a few bytes of pci-config space(vendor-id & device-id).
      Status = HalGetBusData(PCIConfiguration,i,Slot,PCIDev,0x4);
      if (Status == 0)
      {
        Eprintf("PCI Bus %d does not exist.",i);
      }

      if (Status > 2)        /* Found Device Is it ours? */
      {
        if (PCIDev->VendorID == PCI_VENDOR_ID)
        {
          // get 0x40 worth of pci-config space(includes irq, addr, etc.)
          Status = HalGetBusData(PCIConfiguration,i,Slot,PCIDev,0x40);

          if (BaseAddr == (PCIDev->u.type0.BaseAddresses[0]-1))
          {
            if (Driver.VerboseLog)
              Eprintf("PCI Board found, IO:%xh, Int:%d ID:%d Rev:%d.",
                               PCIDev->u.type0.BaseAddresses[0]-1,
                               PCIDev->u.type0.InterruptLine,
                               PCIDev->DeviceID,
                               PCIDev->RevisionID);

            CfCtl->BusType=PCIBus;
            CfCtl->BusNumber = i; //get from previous halquerysysin
            CfCtl->PCI_Slot = Slot;
            CfCtl->PCI_DevID = PCIDev->DeviceID;
            CfCtl->PCI_RevID = PCIDev->RevisionID;
            CfCtl->PCI_SVID = PCIDev->u.type0.SubVendorID;
            CfCtl->PCI_SID = PCIDev->u.type0.SubSystemID;
            CfCtl->BaseIoAddr =
                PCIDev->u.type0.BaseAddresses[0]-1;

            //if (PCIDev->u.type0.InterruptLine != 255)
            //{
            //RcktCfg->Irq = PCIDev->u.type0.InterruptLine;
            //}
            if (Driver.VerboseLog)
               Eprintf("Bus:%d,Slt:%x,Dev:%x,Rev:%x,Pin:%x",
                 i, Slot, PCIDev->DeviceID, PCIDev->RevisionID, PCIDev->u.type0.InterruptPin);

            ExFreePool(PCIDev);
            return 0;  // fail
          }
        } // if (PCIDev->VendorID == PCI_VENDOR_ID)
      } // if (Status > 2) 
    }
  }
  ExFreePool(PCIDev);
  return 2;  // fail
}

/*----------------------------------------------------------------------
 RkGetPnpResourceToConfig -

    This routine will get the configuration information and put
    it and the translated values into CONFIG_DATA structures.
    It first sets up with  defaults and then queries the registry
    to see if the user has overridden these defaults; if this is a legacy
    multiport card, it uses the info in PUserData instead of groping the
    registry again.

Arguments:

    Fdo - Pointer to the functional device object.
    pResourceList - Pointer to the untranslated resources requested.
    pTrResourceList - Pointer to the translated resources requested.
    pConfig - Pointer to configuration info
    PUserData - Pointer to data discovered in the registry for legacy devices.

Return Value:
    STATUS_SUCCESS if consistant configuration was found - otherwise.
    returns STATUS_SERIAL_NO_DEVICE_INITED.
|----------------------------------------------------------------------*/
NTSTATUS
RkGetPnpResourceToConfig(IN PDEVICE_OBJECT Fdo,
                  IN PCM_RESOURCE_LIST pResourceList,
                  IN PCM_RESOURCE_LIST pTrResourceList,
                  OUT DEVICE_CONFIG *pConfig)
{
   PSERIAL_DEVICE_EXTENSION        fdoExtension    = Fdo->DeviceExtension;
   PDEVICE_OBJECT pdo = fdoExtension->LowerDeviceObject;
   NTSTATUS status = STATUS_NOT_IMPLEMENTED;

   ULONG                           count;
   ULONG                           i;
   BOOLEAN MappedFlag;

   PCM_FULL_RESOURCE_DESCRIPTOR pFullResourceDesc = NULL,
      pFullTrResourceDesc = NULL;

   ULONG zero = 0;


   pFullResourceDesc   = &pResourceList->List[0];
   pFullTrResourceDesc = &pTrResourceList->List[0];

   // Ok, if we have a full resource descriptor.  Let's take it apart.
   if (pFullResourceDesc) {
     PCM_PARTIAL_RESOURCE_LIST       prl;
     PCM_PARTIAL_RESOURCE_DESCRIPTOR prd;
     unsigned int Addr;

      prl    = &pFullResourceDesc->PartialResourceList;
      prd    = prl->PartialDescriptors;
      count                   = prl->Count;

      // Pull out the stuff that is in the full descriptor.
      // for rocketport could be: PCIBus, Isa, MicroChannel
      pConfig->BusType        = pFullResourceDesc->InterfaceType;
      pConfig->BusNumber      = pFullResourceDesc->BusNumber;

      if ((pConfig->BusType != PCIBus) && (pConfig->BusType != Isa))
      {
        Eprintf("Err, Unknown Bus");
        return STATUS_INSUFFICIENT_RESOURCES;
      }

      // Now run through the partial resource descriptors looking for the port,
      // interrupt, and clock rate.
      for (i = 0;     i < count;     i++, prd++)
      {
        switch (prd->Type)
        {
          case CmResourceTypePort:
            Addr = (unsigned int) prd->u.Port.Start.LowPart;
#if 0
// we don't handle aliasing here
            if (pConfig->BusType == Isa)
            {
              // only setup if not an isa-bus alias address
              if (prd->u.Port.Start.LowPart < 0x400)
                pConfig->BaseIoAddr = Addr;
            }
            else
#endif
              pConfig->BaseIoAddr = Addr;

            pConfig->BaseIoSize = prd->u.Port.Length;

            switch(pConfig->BusType)
            {
              case Isa:
                pConfig->AiopIO[0] = pConfig->BaseIoAddr;
                pConfig->AiopIO[1] = pConfig->AiopIO[0] + 0x400;
                pConfig->AiopIO[2] = pConfig->AiopIO[0] + 0x800;
                pConfig->AiopIO[3] = pConfig->AiopIO[0] + 0xc00;
                pConfig->MudbacIO = pConfig->AiopIO[0] + 0x40;
                //if (prd->u.Port.Length == 0x40)
                //pConfig->AddressSpace = prd->Flags;
                //Eprintf("Error, Res 1C");
                GTrace1(D_Pnp,sz_modid,"ISA_Addr:%xH", pConfig->BaseIoAddr);
              break;
              case PCIBus:
                pConfig->AiopIO[0] = pConfig->BaseIoAddr;
                pConfig->AiopIO[1] = pConfig->AiopIO[0] + 0x40;
                pConfig->AiopIO[2] = pConfig->AiopIO[0] + 0x80;
                pConfig->AiopIO[3] = pConfig->AiopIO[0] + 0xc0;
                GTrace1(D_Pnp,sz_modid,"PCI_Addr:%xH", pConfig->BaseIoAddr);
              break;
            }
          break;

          case CmResourceTypeInterrupt:
            pConfig->IrqLevel  = prd->u.Interrupt.Level;
            pConfig->IrqVector = prd->u.Interrupt.Vector;
            pConfig->Affinity  = prd->u.Interrupt.Affinity; 

            if (prd->Flags
               & CM_RESOURCE_INTERRUPT_LATCHED) {
               pConfig->InterruptMode  = Latched;
            } else {
               pConfig->InterruptMode  = LevelSensitive; }
            GTrace1(D_Pnp,sz_modid, "Res_Int:%xH", pConfig->IrqVector);
          break;

          case CmResourceTypeMemory:
            DTraceStr("PnP:Res,DevSpec");
          break;

          case CmResourceTypeDeviceSpecific:
            DTraceStr("PnP:Res,DevSpec");
          break;

          default:
            if (Driver.VerboseLog)
              Eprintf("PnP:Dev. Data 1G:%x",prd->Type);
          break;
        }   // switch (prd->Type)
      }   // for (i = 0;     i < count;     i++, prd++)
   }    // if (pFullResourceDesc)


   //---- Do the same for the translated resources
   if (pFullTrResourceDesc)
   {
     PCM_PARTIAL_RESOURCE_LIST       prl;
     PCM_PARTIAL_RESOURCE_DESCRIPTOR prd;
     PUCHAR pAddr;

      prl = &pFullTrResourceDesc->PartialResourceList;
      prd = prl->PartialDescriptors;
      count = prl->Count;

      for (i = 0;     i < count;     i++, prd++)
      {
        switch (prd->Type)
        {
          case CmResourceTypePort:

            pConfig->TrBaseIoAddr = (unsigned int) prd->u.Port.Start.LowPart;

            pAddr = SerialGetMappedAddress(
                      pConfig->BusType,
                      pConfig->BusNumber,
                      prd->u.Port.Start,
                      prd->u.Port.Length,
                      prd->Flags,  // port-io?
                         //1,  // port-io
                      &MappedFlag,  // do we need to unmap on cleanup?
                      0);  // don't translate
#if 0
// we do not handle the alias io here
            //!!!!!!! this is  guarenteed to work, since it is mapped
            if (pConfig->BusType == Isa)
            {
              // only setup if not an isa-bus alias address
              if (prd->u.Port.Start.LowPart < 0x400)
                pConfig->pBaseIoAddr = pAddr;
            }
            else
#endif
              pConfig->pBaseIoAddr = pAddr;

            if (pConfig->BaseIoSize == 0)
                pConfig->BaseIoSize = prd->u.Port.Length;

            switch(pConfig->BusType)
            {
              case Isa:
                pConfig->NumAiop=AIOP_CTL_SIZE;  // let init figure it out
                pConfig->pAiopIO[0] = pConfig->pBaseIoAddr;
                pConfig->pAiopIO[1] = pConfig->pAiopIO[0] + 0x400;
                pConfig->pAiopIO[2] = pConfig->pAiopIO[0] + 0x800;
                pConfig->pAiopIO[3] = pConfig->pAiopIO[0] + 0xc00;
                if (pConfig->BaseIoSize == 0x44)
                {
                  pConfig->pMudbacIO =  pConfig->pAiopIO[0] + 0x40;
                }
                GTrace1(D_Pnp,sz_modid,"ISA TrRes_Addr:%xH", prd->u.Port.Start.LowPart);
                GTrace1(D_Pnp,sz_modid,"ISA pAddr:%xH", pAddr);
                //Eprintf("ISA TrRes_Addr:%xH", prd->u.Port.Start.LowPart);
              break;
              case PCIBus:
                pConfig->pAiopIO[0] = pConfig->pBaseIoAddr;
                pConfig->pAiopIO[1] = pConfig->pAiopIO[0] + 0x40;
                pConfig->pAiopIO[2] = pConfig->pAiopIO[0] + 0x80;
                pConfig->pAiopIO[3] = pConfig->pAiopIO[0] + 0xc0;
                //if (prd->u.Port.Length == 0x40)
                //pConfig->AddressSpace = prd->Flags;
                //Eprintf("Error, Res 1G");
                GTrace1(D_Pnp,sz_modid,"PCI TrRes_Addr:%xH", prd->u.Port.Start.LowPart);
                GTrace1(D_Pnp,sz_modid,"PCI pAddr:%xH", pAddr);
              break;
            }
          break;

          case CmResourceTypeInterrupt:
            pConfig->TrIrqVector   = prd->u.Interrupt.Vector;
            pConfig->TrIrqLevel = prd->u.Interrupt.Level;
            pConfig->TrAffinity   = prd->u.Interrupt.Affinity;
            GTrace1(D_Pnp,sz_modid,"TrRes_Int:%xH", pConfig->TrIrqVector);
          break;

          case CmResourceTypeMemory:
            DTraceStr("PnP:TransRes,DevSpec");
          break;

          default:
            if (Driver.VerboseLog)
              Eprintf("PnP:Dev. Data 1H:%x",prd->Type);
          break;
        }   // switch (prd->Type)
      }   // for (i = 0;     i < count;     i++, prd++)
   }    // if (pFullTrResourceDesc)

   if (pConfig->BusType == Isa)
   {
     // figure out mudbac alias io space stuff.
     SetupRocketCfg(1);
   }  // isa

   // if PCI bus, then we need to query for device type, etc.
   if (pConfig->BusType == PCIBus)
   {
     if (GetPCIRocket(pConfig->AiopIO[0], pConfig) != 0)
     {
       Eprintf("Unknown PCI type");
     }
   }
   ConfigAIOP(pConfig);

  status = STATUS_SUCCESS;
   return status;
}

#ifdef DO_ISA_BUS_ALIAS_IO
/*-----------------------------------------------------------------------
 Report_Alias_IO -
|-----------------------------------------------------------------------*/
int Report_Alias_IO(IN PSERIAL_DEVICE_EXTENSION extension)
{
 PCM_RESOURCE_LIST resourceList;
 ULONG sizeOfResourceList;
 ULONG countOfPartials;
 PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
 NTSTATUS status;
 PHYSICAL_ADDRESS MyPort;
 BOOLEAN ConflictDetected;
 BOOLEAN MappedFlag;
 int j;
 int brd = extension->UniqueId;
 DEVICE_CONFIG *Ctl;
 char name[70];
 int need_alias = 0;
 int NumAiop;

  DTraceStr("ReportResources");
  ConflictDetected=FALSE;

  countOfPartials=0;
  Ctl = extension->config;

  // we got mudback.
  if (Ctl->BusType != Isa)
  {
    DTraceStr("NotISA");
    return 0;
  }

  // if it only has 1 aiopic and has 4 bytes for mudback,
  // then no aliasing required.
  if (Ctl->BaseIoSize != 0x44)
    need_alias = 1;

   // rocketport boards need extra aiop space for reset circuitry.
  if (extension->config->ModemDevice)
  {
    need_alias = 1;
  }

  if (Ctl->NumPorts > 8)
    need_alias = 1;

  if (need_alias == 0)
  {
    // no aliasing needed.
    DTraceStr("EasyISA");
    return 0;
  }
  // we need to update initcontroller to stall until first controller
  // gets a start.

  // else it is an additional board which needs to alias its mudback
  // ontop of the first ISA(44H) address space, or it is a board
  // with more than 1 aiopic chip(which requires aliasing over itself)
  if (Ctl->BaseIoSize != 0x44)  // must be 2nd, 3rd, or 4th board
  {
     DTraceStr("HasMdBk");
     countOfPartials++;         // so mudback is aliased up
  }

  NumAiop = Ctl->NumAiop;

  if (extension->config->ModemDevice)
  {  // reset circuitry
     ++NumAiop;
  }
  if (NumAiop > 4)
    return 15;  // error

  MyKdPrint(D_Pnp,("Report Resources brd:%d bus:%d\n",brd+1, Ctl->BusType))

  // don't report first aiop(we got that from pnp)
  for (j=1; j<NumAiop; j++)
  {
    if (Ctl->AiopIO[j] > 0)
      countOfPartials++;  // For each Aiop, we will get resources
  }

  sizeOfResourceList = sizeof(CM_RESOURCE_LIST) +
                       sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +  // add, kpb
                        (sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)*
                        countOfPartials);

                       // add 64 for slop
  resourceList = ExAllocatePool(PagedPool, sizeOfResourceList+64);

  if (!resourceList)
  {
    if (Driver.VerboseLog)
      Eprintf("No ResourceList");

    EventLog(Driver.GlobalDriverObject,
             STATUS_SUCCESS,
             SERIAL_INSUFFICIENT_RESOURCES,
             0, NULL);
    return(9);
  }

  RtlZeroMemory(resourceList, sizeOfResourceList);

  resourceList->Count = 1;
  resourceList->List[0].InterfaceType = Ctl->BusType;
  resourceList->List[0].BusNumber = Ctl->BusNumber;  //change for multibus
  resourceList->List[0].PartialResourceList.Count = countOfPartials;
  partial = &resourceList->List[0].PartialResourceList.PartialDescriptors[0];

  // Account for the space used by the Rocket.
  // Report the use of the Mudbacs on Isa boards only
  if (Ctl->BaseIoSize != 0x44)  // must be 2nd, 3rd, or 4th board
  {
    MyPort.HighPart=0x0;
    MyPort.LowPart=Ctl->MudbacIO;
    partial->Type = CmResourceTypePort;
    partial->ShareDisposition = CmResourceShareDeviceExclusive;
    partial->Flags = CM_RESOURCE_PORT_IO;
    partial->u.Port.Start = MyPort;
    partial->u.Port.Length = SPANOFMUDBAC;
    partial++;
  }

  for (j=1; j<NumAiop; j++)
  {
    if (Ctl->AiopIO[j] == 0)
      Ctl->AiopIO[j] = Ctl->AiopIO[j-1];

    // Report the use of the AIOPs.
    if (Ctl->AiopIO[j] > 0)
    {
       MyPort.HighPart=0x0;
       MyPort.LowPart=Ctl->AiopIO[j];
       partial->Type = CmResourceTypePort;
       partial->ShareDisposition = CmResourceShareDeviceExclusive;
       partial->Flags = CM_RESOURCE_PORT_IO;
       partial->u.Port.Start = MyPort;
       partial->u.Port.Length = SPANOFAIOP;
       partial++;
    }
    else
    {
       MyKdPrint(D_Pnp,("Aiop Count Wrong, A.\n"))
       if (Driver.VerboseLog)
         Eprintf("Error RR12");
    }
  }  // end for j

  //-------- Report the resources indicated by partial list (resourceList)
  strcpy(name, szResourceClassName);
  our_ultoa(extension->UniqueId, &name[strlen(name)], 10);

  MyKdPrint(D_Pnp,("Reporting Resources To system\n"))
  status=IoReportResourceUsage(
      CToU1(name),                     // DriverClassName OPTIONAL,
      extension->DeviceObject->DriverObject,  // DriverObject,
      // Driver.GlobalDriverObject,
      NULL,                          // DriverList OPTIONAL,
      0,                             // DriverListSize OPTIONAL,
      extension->DeviceObject,       // DeviceObject
      resourceList,                  // DeviceList OPTIONAL,
      sizeOfResourceList,            // DeviceListSize OPTIONAL,
      FALSE,                         // OverrideConflict,
      &ConflictDetected);            // ConflictDetected

  if (!NT_SUCCESS(status))
  {
    if (Driver.VerboseLog)
      Eprintf("Error, Resources");
    TraceErr("Err5G");
  }

  if (ConflictDetected) 
  {
    Eprintf("Error, Resource Conflict.");
    if (resourceList)
      ExFreePool(resourceList);
    resourceList = NULL;
    EventLog(Driver.GlobalDriverObject,
             STATUS_SUCCESS,
             SERIAL_INSUFFICIENT_RESOURCES,
             0, NULL);
    MyKdPrint(D_Pnp,("Resource Conflict Detected.\n"))
    return(10);
  }

  // OK, even more important than reporting resources is getting
  // the pointers to the I/O ports!!

  if (Ctl->BusType == Isa)
  {
    MyPort.HighPart=0x0;
    MyPort.LowPart=Ctl->MudbacIO;

    if (Ctl->BaseIoSize != 0x44)  // must be 2nd, 3rd, or 4th board
    {
      Ctl->pMudbacIO =
          SerialGetMappedAddress(Isa,Ctl->BusNumber,MyPort,SPANOFMUDBAC,1,&MappedFlag,1);
      if (Ctl->pMudbacIO == NULL) 
      {
        if (Driver.VerboseLog)
          Eprintf("Err RR15");
        MyKdPrint(D_Pnp,("Resource Error A.\n"))
        return 11;
      }
    }
  }

  for (j=1; j<NumAiop; j++)
  {
    if (Ctl->AiopIO[j] > 0)
    {
      MyPort.HighPart=0x0;
      MyPort.LowPart=Ctl->AiopIO[j];
      Ctl->pAiopIO[j] =
          SerialGetMappedAddress(Ctl->BusType,
                      Ctl->BusNumber,MyPort,SPANOFAIOP,1,&MappedFlag,1);

      if (Ctl->pAiopIO[j] == NULL) 
      {
        if (Driver.VerboseLog)
          Eprintf("Err RR16");
        MyKdPrint(D_Pnp,("Resource Error B.\n"))
        return 12;
      }

    }
    else
    {
      if (Driver.VerboseLog)
        Eprintf("Err RR17");
      MyKdPrint(D_Pnp,("Aiop Count Wrong, B.\n"))
      return 13;
    }
  }

  extension->io_reported = 1; // tells that we should deallocate on unload.

  // Release the memory used for the resourceList
  if (resourceList)
    ExFreePool(resourceList);
  resourceList = NULL;
  MyKdPrint(D_Pnp,("Done Reporting Resources\n"))
  return 0;
}
#endif

#if 0
/*----------------------------------------------------------------------
SerialFindInitController -
|----------------------------------------------------------------------*/
NTSTATUS
SerialFindInitController(IN PDEVICE_OBJECT Fdo, IN PCONFIG_DATA PConfig)
{
   PSERIAL_DEVICE_EXTENSION fdoExtension    = Fdo->DeviceExtension;
   PDEVICE_OBJECT pDeviceObject;
   PSERIAL_DEVICE_EXTENSION pExtension;
   PHYSICAL_ADDRESS serialPhysicalMax;
   //SERIAL_LIST_DATA listAddition;
   PLIST_ENTRY currentFdo;
   NTSTATUS status;

   serialPhysicalMax.LowPart = (ULONG)~0;
   serialPhysicalMax.HighPart = ~0;

   //if (address is hosed,)
   //   return STATUS_NO_SUCH_DEVICE;

   //
   // Loop through all of the driver's device objects making
   // sure that this new record doesn't overlap with any of them.
   //
#ifdef DO_LATER
   if (!IsListEmpty(&Driver.AllFdos)) {
      currentFdo = Driver.AllFdos.Flink;
      pExtension = CONTAINING_RECORD(currentFdo, SERIAL_DEVICE_EXTENSION,
                                     AllFdos);
   } else {
      currentFdo = NULL;
      pExtension = NULL;
   }

   //
   // Loop through all previously attached devices
   //
   if (!IsListEmpty(&Driver.AllFdos)) {
      currentFdo = Driver.AllFdos.Flink;
      pExtension = CONTAINING_RECORD(currentFdo, SERIAL_DEVICE_EXTENSION,
                                     AllFdos);
   } else {
      currentFdo = NULL;
      pExtension = NULL;
   }

   //status = SerialInitOneController(Fdo, PConfig);
   //PSERIAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
   // init the thing

   if (!NT_SUCCESS(status)) {
      return status;
   }
#endif

   return STATUS_SUCCESS;
}
#endif  // 0


#ifdef DO_BRD_FILTER_RES_REQ
/*----------------------------------------------------------------------
 BoardFilterResReq -  handle IRP_MN_FILTER_RESOURCE_REQUIREMENTS:  // 0x0D
  for our board FDO entity.  Test to see if we can adjust requirements
  to handle io-aliasing(no, doesn't look too promising).
|----------------------------------------------------------------------*/
NTSTATUS BoardFilterResReq(IN PDEVICE_OBJECT devobj, IN PIRP Irp)
{
   PSERIAL_DEVICE_EXTENSION  Ext = devobj->DeviceExtension;
   PDEVICE_OBJECT pdo = Ext->LowerDeviceObject;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   NTSTATUS                    status          = STATUS_NOT_SUPPORTED;

   //******** see serial driver(changes resource requirements)
   HANDLE pnpKey;
   //KEVENT resFiltEvent;
   //ULONG isMulti = 0;
   PIO_RESOURCE_REQUIREMENTS_LIST prrl;
   PIO_RESOURCE_LIST prl;
   PIO_RESOURCE_DESCRIPTOR prd;

   PIO_RESOURCE_REQUIREMENTS_LIST new_prrl;
   PIO_RESOURCE_LIST new_prl;
   PIO_RESOURCE_DESCRIPTOR new_prd;

   ULONG i, j;
   ULONG reqCnt;
   ULONG rrl_size;
   ULONG rl_size;

   TraceStr1("Filt Res Req, PDO:%x", do);

   status = WaitForLowerPdo(devobj, Irp);

   if (Irp->IoStatus.Information == 0)
   {
      if (irpStack->Parameters.FilterResourceRequirements
          .IoResourceRequirementList == 0)
      {
         DTraceStr("No Resources");
         status = Irp->IoStatus.Status;
         SerialCompleteRequest(Ext, Irp, IO_NO_INCREMENT);
         return status;
      }

      Irp->IoStatus.Information = (ULONG)irpStack->Parameters
                                  .FilterResourceRequirements
                                  .IoResourceRequirementList;
   }

   // Add aliases to IO_RES_REQ_LIST.
   prrl = (PIO_RESOURCE_REQUIREMENTS_LIST)Irp->IoStatus.Information;

#if 0
   new_prrl = (new_prrl) ExAllocatePool(PagedPool,
         prrl->ListSize + (sizeof(IO_RESOURCE_DESCRIPTOR)*2));
   if (new_prrl == NULL)
   {
     TraceErr("Bad Buf Z");
     //ExFreePool();
   }
   memcpy(new_prrl, prrl);
#endif

   //reqCnt = ((prrl->ListSize - sizeof(IO_RESOURCE_REQUIREMENTS_LIST))
   //          / sizeof(IO_RESOURCE_DESCRIPTOR)) + 1;
   reqCnt = 0;

   TraceStr1("RRL Size:%x", sizeof(IO_RESOURCE_REQUIREMENTS_LIST));
   TraceStr1("RL Size:%x", sizeof(IO_RESOURCE_LIST));
   TraceStr1("RD Size:%x", sizeof(IO_RESOURCE_DESCRIPTOR));
   TraceStr1("List Size:%x", prrl->ListSize);

   rrl_size = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) -
                    sizeof(IO_RESOURCE_LIST);
   rl_size = sizeof(IO_RESOURCE_LIST) - sizeof(IO_RESOURCE_DESCRIPTOR);

   TraceStr1("RRL Base Size:%x", rrl_size);
   TraceStr1("RL Base Size:%x", rl_size);

   //for (i = 0; i < reqCnt; i++) {
   reqCnt = rrl_size;  // pass up base of IO_RESOURCE_REQUIREMENTS_LIST
   while (reqCnt < prrl->ListSize)
   {
      prl = (PIO_RESOURCE_LIST) &((BYTE *)prrl)[reqCnt];  // ptr to IO_RESOURCE_LIST
      reqCnt += rl_size;  // pass up base of IO_RESOURCE_LIST

      TraceStr1("Num Res Desc:%d", prl->Count);
      for (j = 0; j < prl->Count; j++)
      {
        reqCnt += sizeof(IO_RESOURCE_DESCRIPTOR);
        prd = &prl->Descriptors[j];
        TraceStr2("Desc Type:%x, Flags:%x", prd->Type, prd->Flags);
        if (prd->Type == CmResourceTypePort)
        {
           DTraceStr("Type:Port");
           TraceStr2("Min:%x Max:%x",
             prd->u.Port.MinimumAddress.LowPart,
             prd->u.Port.MaximumAddress.LowPart);
           TraceStr2("Align:%x Len:%x",
             prd->u.Port.Alignment, prd->u.Port.Length);

           //Addr = (unsigned int) prd->u.Port.Start.LowPart;
           //if (Addr < 0x400)
           //   pConfig->BaseIoAddr = Addr;
           //pConfig->BaseIoSize = prd->u.Port.Length;
        }
      }
      TraceStr1("ByteCnt:%d", reqCnt);
   }

   Irp->IoStatus.Status = STATUS_SUCCESS;
   SerialCompleteRequest(Ext, Irp, IO_NO_INCREMENT);
   return STATUS_SUCCESS;
}
#endif  // DO_BRD_FILTER_RES_REQ


/*----------------------------------------------------------------------------
| is_isa_cards_pending_start - scan linked list of card devices, see if
   any ISA bus cards are not started(delayed or pending a start waiting
   for first ISA card.)
|----------------------------------------------------------------------------*/
int is_isa_cards_pending_start(void)
{
 PSERIAL_DEVICE_EXTENSION Ext;

  Ext = Driver.board_ext;
  while (Ext)
  {
    if (Ext->config->BusType == Isa)
    {
      if (Ext->config->ISABrdIndex == 0)
      {
        if (Ext->config->HardwareStarted)
          return 1;  // true, its pending a start
      }
    }
    Ext = Ext->board_ext;  // next in chain
  }  // while board extension

  return 0;  // false, not started
}

/*----------------------------------------------------------------------------
| is_first_isa_card_started - scan linked list of card devices, see if
   "first" ISA bus card is started.
|----------------------------------------------------------------------------*/
int is_first_isa_card_started(void)
{
 PSERIAL_DEVICE_EXTENSION Ext;

  Ext = Driver.board_ext;
  while (Ext)
  {
    if (Ext->config->BusType == Isa)
    {
      if (Ext->config->ISABrdIndex == 0)
      {
        if (Ext->config->HardwareStarted)
          return 1;  // true, its started
      }
    }
    Ext = Ext->board_ext;  // next in chain
  }  // while board extension

  return 0;  // false, not started
}

#endif  // NT50
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\pnprckt.h ===
#ifdef S_RK
int GetPCIRocket(ULONG BaseAddr, DEVICE_CONFIG *CfCtl);
NTSTATUS
RkGetPnpResourceToConfig(IN PDEVICE_OBJECT Fdo,
                  IN PCM_RESOURCE_LIST pResourceList,
                  IN PCM_RESOURCE_LIST pTrResourceList,
                  OUT DEVICE_CONFIG *pConfig);
int Report_Alias_IO(IN PSERIAL_DEVICE_EXTENSION extension);
PSERIAL_DEVICE_EXTENSION FindPrimaryIsaBoard(void);
NTSTATUS BoardFilterResReq(IN PDEVICE_OBJECT devobj, IN PIRP Irp);
int is_isa_cards_pending_start(void);
int is_first_isa_card_started(void);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\precomp.h ===
//---- precomp.h 
// common include file so we can use pre-compiled headers

#define NDIS40 1

#include <ntddk.h>
#include <ntddser.h>

#include <stdarg.h>
#include <wchar.h>
#include <ndis.h>
#ifdef NT50
#include <wmilib.h>
// #include "wmi.h"
#include <wmidata.h>
#endif
#include "nic.h"
#include "queue.h"
#include "admin.h"
#include "hdlc.h"
#include "port.h"
#include "asic.h"
#include "debuger.h"
#include "ssci.h"
#include "init.h"
#include "utils.h"
#include "options.h"
#include "initc.h"
#include "initvs.h"
#include "initrk.h"
#include "read.h"
#include "write.h"
#include "waitmask.h"
#include "openclos.h"
#include "pnpadd.h"
#include "pnp.h"
#include "pnprckt.h"
#include "isr.h"
#include "ioctl.h"
#include "rcktioct.h"
#include "opstr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\pnpadd.h ===
// pnpadd.h

NTSTATUS SerialAddDevice(
               IN PDRIVER_OBJECT DriverObject,
               IN PDEVICE_OBJECT Pdo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\queue.c ===
/*--------------------------------------------------------------------------
| queue.c - queue code.  This queue code serves the following need:
   It provides circular queue code which is fast and it does so without
   requiring a lock or semaphore between the get and put side of the queue.
   Simpler queue code exists which keeps a qcount member, but this requires
   a lock or semaphore in the implementation.  By calculating everything
   based on the indexes we can run without a lock.  This index arithmetic
   is a bit hairy(and may contain some additional overhead), but when
   working with a complex multiprocessor OS's, the ellimination of the lock
   is very handy.

 Copyright 1996-97 Comtrol Corporation.  All rights reserved.
|--------------------------------------------------------------------------*/
#include "precomp.h"

// much of the queue implementation are macros in the header file.

/*--------------------------------------------------------------------------
| q_flush_count_put - flush the queue and return number of bytes flushed
    from it.  Assume Put side of queue will not be in a state of flux.
|--------------------------------------------------------------------------*/
int q_flush_count_put(Queue *queue)
{
 int Count, QGet;

  // use a copy of QGet, since it may be changing at ISR level while we work.
  QGet = queue->QGet;

  // figure the number of bytes in the queue
  if ((Count = queue->QPut - QGet) < 0)
    Count += queue->QSize; // adjust for wrap

  // flush by setting QGet=QPut;
  queue->QPut = QGet;
  return Count;  // return count of flushed chars
}

/*--------------------------------------------------------------------------
| q_flush_count_get - flush the queue and return number of bytes flushed
    from it.  Assume Get side of queue will not be in a state of flux.
|--------------------------------------------------------------------------*/
int q_flush_count_get(Queue *queue)
{
 int Count, QPut;

  // use a copy of QPut, since it may be changing at ISR level while we work.
  QPut = queue->QPut;

  // figure the number of bytes in the queue
  if ((Count = QPut - queue->QGet) < 0)
    Count += queue->QSize; // adjust for wrap

  // flush by setting QGet=QPut;
  queue->QGet = QPut;
  return Count;  // return count of flushed chars
}

/*----------------------------------
 q_room - return number of chars room in queue we can put.
|----------------------------------*/
int q_room(Queue *queue)
{
 int QCount;

  if ((QCount = (queue->QPut - queue->QGet)) < 0)
      QCount += queue->QSize;
  return (queue->QSize - QCount - 1);
}

/*----------------------------------
 q_count - return number of chars in queue we can get.
|----------------------------------*/
int q_count(Queue *queue)
{
 int QCount;

  if ((QCount = (queue->QPut - queue->QGet)) < 0)
      QCount += queue->QSize;
  return QCount;
}

/*--------------------------------------------------------------------------
| q_get - Get bytes from queue.
   queue : our queue
   buf   : buffer to put the data into
   Count : Max number of bytes to get
   Returns int value equal to number of bytes transferred.
|--------------------------------------------------------------------------*/
int q_get(Queue *queue, unsigned char *buf, int Count)
{
 int get1, get2, ToMove;

  if ((ToMove = queue->QPut - queue->QGet) < 0)
    ToMove += queue->QSize; // adjust for wrap

  if (Count > ToMove)  // only move whats asked
  {
    Count = ToMove;
  }

  if (Count == 0)  // if nothing asked or nothing available
    return 0;

  get1 = queue->QSize - queue->QGet;  // space till wrap point
  if (get1 < Count)
  {
    get2 = Count - get1;  // two moves required
  }
  else  // only one move required
  {
    get2 = 0;
    get1 = Count;
  }

  memcpy(buf, &queue->QBase[queue->QGet], get1);

  queue->QGet = (queue->QGet + get1) % queue->QSize;
  if (get2)
  {
    memcpy(&buf[get1], &queue->QBase[0], get2);
    queue->QGet = get2;
  }

  return Count;
}

/*--------------------------------------------------------------------------
| q_put - Put data into the Queue.
   queue : our queue
   buf   : buffer to get the data from
   Count : Max number of bytes to put
   Returns int value equal to number of bytes transferred.
|--------------------------------------------------------------------------*/
int q_put(Queue *queue, unsigned char *buf, int Count)
{
 int put1, put2, room;

  if ((room = queue->QGet - queue->QPut - 1) < 0)
    room += queue->QSize;  // adjust for wrap

  if (Count > room)
    Count = room;

  if (Count <= 0)  // if nothing asked or nothing available
    return 0;

  put1 = queue->QSize - queue->QPut;

  if (put1 < Count)
  {
    put2 = Count - put1;  // two moves required
  }
  else  // only one move required
  {
    put2 = 0;
    put1 = Count;
  }

  memcpy(&queue->QBase[queue->QPut], buf, put1);
  queue->QPut = (queue->QPut + put1) % queue->QSize;
  if (put2)
  {
    memcpy(&queue->QBase[0], &buf[put1], put2);
    queue->QPut = put2;
  }

  return Count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\queue.h ===
//---- queue.h
// Copyright 1996 Comtrol Corporation.  All rights reserved.

#ifndef BYTE
#define BYTE UCHAR
#endif

//----- a queue data type
typedef struct {
  unsigned char *QBase; // points to base of buffer
  int QSize;  // total Q size
  int QGet;   // get index
  int QPut;   // put index
} Queue;

/*----------------------------------
 q_full - return true if queue is full.
|----------------------------------*/
#define q_full(q) ((((q)->QGet + 1) % (q)->QSize) == (q)->QPut)

/*----------------------------------
 q_empty - return true if queue is empty.
|----------------------------------*/
#define q_empty(q) ((q)->QGet == (q)->QPut)

/*----------------------------------
 q_put_flush - flush the queue, empty it out.
|----------------------------------*/
#define q_put_flush(q)  (q)->QPut = (q)->QGet

/*----------------------------------
 q_get_flush - flush the queue, empty it out.
|----------------------------------*/
#define q_get_flush(q)  (q)->QGet = (q)->QPut
#define q_flush q_get_flush

/*----------------------------------
 q_room_put_till_wrap - return number of chars we can put in queue up to the
   wrap point(end of the queue).  Assumes we already checked to see if
   the total number will fit in the queue using q_room().
|----------------------------------*/
#define q_room_put_till_wrap(q)  \
      ( (q)->QSize - (q)->QPut)

/*----------------------------------
 q_room_get_till_wrap - return number of chars we can get in queue up to the
   wrap point(end of the queue).  Assumes we already checked to see if
   the total number is available from the the queue using q_count().
|----------------------------------*/
#define q_room_get_till_wrap(q)  \
      ( (q)->QSize - (q)->QGet)

/*----------------------------------
 q_room - return number of chars room in queue we can put.
  if (QRoom = (queue->QPut - queue->QGet -1) < 0)
      QRoom += queue->QSize;
|----------------------------------*/
int q_room(Queue *queue);
/* #define q_room(q)  \
   ( (((q)->QGet - (q)->QPut) <= 0) ?             \
      ((q)->QGet - (q)->QPut - 1 + (q)->QSize) :  \
      ((q)->QGet - (q)->QPut - 1) )
   to many references to QPut, contentious!
*/

/*----------------------------------
 q_count - return number of chars in queue we can get.

  if (QCount = (queue->QPut - queue->QGet) < 0)
      QCount += queue->QSize;
|----------------------------------*/
int q_count(Queue *queue);
/* #define q_count(q)  \
   ( (((q)->QPut - (q)->QGet) < 0) ?          \
      ((q)->QPut - (q)->QGet + (q)->QSize) :  \
      ((q)->QPut - (q)->QGet) )
   to many references to QPut, contentious!
*/

/*----------------------------------
 q_put_one - put a single character in the queue.  No check for room
   done, so do a if (!q_full(q)) prior to calling
|----------------------------------*/
#define q_put_one(q, c)  \
   (q)->QBase[(q)->QPut] = c; \
   (q)->QPut += 1; \
   (q)->QPut %= (q)->QSize;

/*--------------------------------------------------------------------------
| q_got - do the arithmetic to update the indexes if someone pulled Count
    many bytes from the queue.
|--------------------------------------------------------------------------*/
#define q_got(q, _cnt) \
  ( (q)->QGet = ((q)->QGet + _cnt) % (q)->QSize )

/*--------------------------------------------------------------------------
| q_putted - do the arithmetic to update the indexes if someone stuffed _cnt
    many bytes into the queue.
|--------------------------------------------------------------------------*/
#define q_putted(q, _cnt) \
  ( (q)->QPut = ((q)->QPut + _cnt) % (q)->QSize )

/*--------------------------------------------------------------------------
| q_flush_amount - flush an amount out of the queue on the get side.
   Used for debugger queue, where we want to dispose oldest so we
   always have room to put new.
   Assumed that called checks that there are enough bytes in the queue
   to clear prior to calling.
|--------------------------------------------------------------------------*/
#define q_flush_amount(q,bytes) \
  { q->QGet = (q->QGet + bytes) % q->QSize; }

int q_flush_count_get(Queue *queue);
int q_flush_count_put(Queue *queue);
int q_get(Queue *queue, unsigned char *buf, int Count);
int q_put(Queue *queue, unsigned char *buf, int Count);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\port.c ===
/*--------------------------------------------------------------------------
| port.c - common port code
Change History:
4-27-98 - adjust for scanrate addition.
3-23-98 - add in broadcast for boxes if not found(had put in V1.12) but
  the changes did not make it into source-safe. kpb.
3-20-98 - Change scheme to track remote tx-buffer level, all changes
  ifdef'ed by NEW_Q in port.h, turned off for now. - kpb.
3-16-98 - VS recovery fix, reset flags in port_resync_all() to force update.
  If RAS lost box, it would continue to see active connections, then on
  recovery, DSR,CD,CTS input signals would not be updated immediately.
11-05-97 - Add Backup Server feature.  DCS
6-17-97 - start using index field assigned to box to id rx-messages.
6-17-97 - change link-integrity check code.
|--------------------------------------------------------------------------*/
#include "precomp.h"

int check_ack_code(PortMan *pm, BYTE *pkt);
int send_code(PortMan *pm);
int send_go(PortMan *pm);

int port_handle_outpkt(PortMan *pm, BYTE **buf, int *tx_used, int *port_set);
BYTE *port_setup_outpkt(PortMan *pm, int *tx_used);
void port_query_reply(PortMan *pm, BYTE *pkt);
void port_load_pkt(PortMan *pm, BYTE *pkt);
ULONG port_event_proc(PVOID context, int message_id, ULONG message_data);
int port_resync_all(PortMan *pm);
int port_connect_reply(Hdlc *hd);
int port_connect_ask(Hdlc *hd);
int port_packet(PortMan *pm, BYTE *buf);

#define DISABLE()
#define ENABLE()

#define TraceErr3(s, p1, p2, p3) GTrace3(D_Error, sz_modid, s, p1, p2, p3)
#define TraceErr2(s, p1, p2) GTrace2(D_Error, sz_modid, s, p1, p2)
#define TraceErr1(s, p1)     GTrace1(D_Error, sz_modid, s, p1)
#define Trace2(s, p1, p2) GTrace2(D_Port, sz_modid, s, p1, p2)
#define Trace1(s, p1)     GTrace1(D_Port, sz_modid, s, p1)
#define TraceStr(s) GTrace(D_Port, sz_modid, s)
#define TraceErr(s) GTrace(D_Error, sz_modid_err, s)
#define TraceAssert(l,s)
static char *sz_modid = {"Port"};
static char *sz_modid_err = {"Error,Port"};

// following for trace or dump messages, make public for other mods as well.
char *port_state_str[] = {"Init", "InitOwn", "SendCode", "Connect", "Active", "."};


#ifdef NEW_Q
/*--------------------------------------------------------------------------
  PortGetTxCntRemote -
|--------------------------------------------------------------------------*/
WORD PortGetTxCntRemote(SerPort *p)
{
  WORD Get, Put;

  Get = p->nGetRemote;
  Put = p->nPutRemote;

  if (Put >= Get)
    return (Put - Get);
  else
    return (Put + (~Get) + 1);
}
#endif

/*--------------------------------------------------------------------------
  PortFlushTx -
|--------------------------------------------------------------------------*/
void PortFlushTx(SerPort *p)
{
  if (!q_empty(&p->QOut))  // flush local side
  {
    q_put_flush(&p->QOut);
  }
  pFlushOutput(p);  // flush remote
}

/*--------------------------------------------------------------------------
  PortFlushRx -
|--------------------------------------------------------------------------*/
void PortFlushRx(SerPort *p)
{
  if (!q_empty(&p->QIn))  // flush local side
  {
#ifdef NEW_Q
    p->nGetLocal += q_count(&p->QIn);
#endif
    q_get_flush(&p->QIn);
    p->Status |= S_UPDATE_ROOM;
  }
  pFlushInput(p);  // flush remote
}

/*--------------------------------------------------------------------------
  port_resync_all - total-resync, this routine is called to reset port
   users, to inform them of a re-sync operation and adjust operation
  accordingly.
  If our case, since remote q is critical to maintain between both sides,
  we clear out all buffer data and start with all empty buffers.
|--------------------------------------------------------------------------*/
int port_resync_all(PortMan *pm)
{
  int i;
  SerPort *Port;

  TraceStr( "ReSync");

  for (i=0; i<pm->num_ports; i++)
  {
    Port = pm->sp[i];
    if (Port != NULL)
    {
      Port->QOut.QSize = OUT_BUF_SIZE;
      Port->QOut.QGet = 0;
      Port->QOut.QPut = 0;

#ifdef NEW_Q
      Port->nPutRemote = 0;
      Port->nGetRemote = 0;
      Port->nGetLocal = 0;
#else
      Port->QInRemote.QSize= OUT_BUF_SIZE;  // for now assume same sizes
      Port->QInRemote.QGet = 0;
      Port->QInRemote.QPut = 0;
#endif

      //Port->LanIndex = i;
      Port->QIn.QSize = IN_BUF_SIZE;
      Port->QIn.QGet = 0;
      Port->QIn.QPut = 0;

      Port->change_flags |= (CHG_BAUDRATE | CHG_SP_CHARS);
      Port->old_baudrate = 0;  // force baud rate update

      Port->old_control_settings = ~Port->control_settings;  // force update
      Port->old_mcr_value = ~Port->mcr_value;  // force update
      // reset this
      memset(&Port->last_sp_chars, 0, sizeof(Port->last_sp_chars));

      Port->msr_value = 0; // back to initial state.
    }
  }

  return 0;
}

/*--------------------------------------------------------------------------
  Callback routine that hdlc(l2) protocol calls on events.
   We are upper layer(3).
|--------------------------------------------------------------------------*/
ULONG port_event_proc(PVOID context, int message_id, ULONG message_data)
{
  TraceStr("L3Event");
  switch(message_id)
  {
    case EV_L2_CHECK_LINK: // hdlc wants us to check link
      TraceStr("Chk Link");
      // request that the portman do a link message check
      ((PortMan *) context)->Status |= S_CHECK_LINK;
    break;

    case EV_L2_ADMIN_REPLY: // got a query-id reply ADMIN packet
      TraceStr("ID PKT");
      port_query_reply((PortMan *) context, (BYTE *) message_data);
    break;

    case EV_L2_BOOT_REPLY:  // got a boot loader ADMIN packet
      TraceStr("LOAD PKT");
      port_load_pkt((PortMan *) context, (BYTE *) message_data);
    break;

    case EV_L2_RESYNC:
      // this happens on RK_CONNECT reply
      port_resync_all((PortMan *) context);
    break;

    case EV_L2_RELOAD:
      // this only happens when alive timer times out,
      // (hdlc-level detects a bad connection),
      // so lets assume box needs to be brought up from ground zero.
      port_resync_all((PortMan *) context);
      ((PortMan *) context)->state = ST_INIT;
      ((PortMan *) context)->load_timer = 0;
      ++((PortMan *) context)->reload_errors;
      TraceErr("Reload device");
    break;

    case EV_L2_RX_PACKET:
      port_packet((PortMan *) context, ((BYTE *) message_data) );
    break;
  }
  return 0;
}

/*--------------------------------------------------------------------------
 port_set_new_mac_addr - 
|--------------------------------------------------------------------------*/
int port_set_new_mac_addr(PortMan *pm, BYTE *box_addr)
{
//  Hdlc *hd;
//  int i;

  // copy over the new mac-address
  memcpy(pm->hd->dest_addr, box_addr, 6);

  // force a complete update of the box
  pm->reload_errors = 0;
  pm->state = 0;
  pm->Status |= S_NEED_CODE_UPDATE;
  pm->Status |= S_SERVER; // yes we are server(not box)

  port_resync_all(pm);
  return 0;
}

/*--------------------------------------------------------------------------
 portman_init - init the Box(PortMAn) struct, and the associated hdlc hd object.
   At this point the Nic object is already open.
|--------------------------------------------------------------------------*/
int portman_init(Hdlc *hd,
                 PortMan *pm,
                 int num_ports,
                 int unique_id,
                 int backup_server, 
                 int backup_timer,
                 BYTE *box_addr)
{
  int i, stat;

  MyKdPrint(D_Init, ("portman_init\n"))

  TraceStr( "PortInit");
  stat = 0;

  // allocate serial-port structures.
  for (i=0; i<num_ports; i++)
  {
    if (pm->sp[i] == NULL)
    {
      pm->sp[i] = (SerPort *)our_locked_alloc(sizeof(SerPort), "Dsp");
      port_init(pm->sp[i]);  // let port create and init some stuff
    }
  }
  pm->num_ports = num_ports;
  pm->backup_server = backup_server;
  pm->backup_timer = backup_timer;
  pm->unique_id = unique_id;
  pm->load_timer = 0;

  // default to the first nic card slot, port state handling and nic
  // packet reception handling dynamically figures this out.
  // we should probably set it to null, but I'm afraid of this right now
#ifdef BREAK_NIC_STUFF
  pm->nic =NULL;
#else
  pm->nic = &Driver.nics[0];
#endif
  pm->nic_index = 0;

  pm->hd = hd;
  pm->reload_errors = 0;
  pm->state = 0;
  pm->state_timer = 0;
  pm->Status |= S_NEED_CODE_UPDATE;
  pm->Status |= S_SERVER; // yes we are server(not box)

  pm->hd = hd;
  stat = hdlc_open(pm->hd, box_addr);
  hd->context = pm;  // put our handle here, so hdlc sends this along
                     // with any upper_layer messages

  if (stat)
  {
    if (Driver.VerboseLog)
      Eprintf("Hdlc open fail:%d",stat);

    TraceStr("Err-Hdlc Open!");
    return 3;
  }

  // set HDLC's callback RX-proc to point to our routine
  hd->upper_layer_proc = port_event_proc;

  port_resync_all(pm);

  return 0;
}

/*--------------------------------------------------------------------------
 portman_close - close down the port manager.
|--------------------------------------------------------------------------*/
int portman_close(PortMan *pm)
{
  int i;

  pm->state = 0;

  // deallocate any Port things
  for (i=0; i<pm->num_ports; i++)
  {
    if (pm->sp[i] != NULL)
    {
      port_close(pm->sp[i]);
      our_free(pm->sp[i], "Dsp");
      pm->sp[i] = NULL;
    }
  }
  return 0;
}

/*--------------------------------------------------------------------------
 port_init - init a SerPort thing.
|--------------------------------------------------------------------------*/
int port_init(SerPort *sp)
{
  TraceStr("SPort_Init");

  if (sp->QOut.QBase == NULL)
  {
    sp->QOut.QBase =  our_locked_alloc(OUT_BUF_SIZE+2,"pmQO");
    if (sp->QOut.QBase == NULL)
    {
      return 1;
    }
  }

  if (sp->QIn.QBase == NULL)
  {
    sp->QIn.QBase = our_locked_alloc(IN_BUF_SIZE+2, "pmQI");
    if (sp->QIn.QBase == NULL)
    {
      return 2;
    }
  }

  sp->Status |= S_OPENED;
  sp->mcr_value = 0;
  //sp->mcr_value = MCR_RTS_SET_ON | MCR_DTR_SET_ON;
  sp->old_mcr_value = sp->mcr_value;

  sp->sp_chars.tx_xon = 0x11;
  sp->sp_chars.tx_xoff = 0x13;
  sp->sp_chars.rx_xon = 0x11;
  sp->sp_chars.rx_xoff = 0x13;
  sp->last_sp_chars = sp->sp_chars;  // copy struct to old
  sp->change_flags = 0;
}

/*--------------------------------------------------------------------------
  port_close -
|--------------------------------------------------------------------------*/
int port_close(SerPort *sp)
{
  int i;

  if (sp == NULL)
    return 0;

  if (sp->QIn.QBase != NULL)
  {
    our_free(sp->QIn.QBase,"pmQI");
    sp->QIn.QBase = NULL;
  }

  if (sp->QOut.QBase != NULL)
  {
    our_free(sp->QOut.QBase,"pmQO");
    sp->QOut.QBase = NULL;
  }

  return 0;
}

/*--------------------------------------------------------------------------
  port_packet - got an incoming packet, do something with it.
|--------------------------------------------------------------------------*/
int port_packet(PortMan *pm, BYTE *buf)
{
  SerPort *Port;
  int port_num;
  int done, len;
  int QInRoom;

  TraceStr( "GotPkt");

  Port = pm->sp[0];  // default to point to first port

  //----- process all the sub-packets in the lan-packet, process
  // until we hit a zero header field, or some header we don't know
  // about(default: case).
  done = 0;
  if (*(buf) == 0)
  {
    // bugbug: this is a problem, we get a bunch of these during
    // normal operation, for now just show in debug version, as
    // they are a nuciance in peer error tracing.
#if DBG
    TraceErr("Empty pkt!");
#endif
  }
  while (!done)
  {
    switch(*buf++)
    {
      case RK_CONNECT_CHECK:  // check link
        TraceStr( "Rk_Conn_Chk_reply");
       
        // do nothing on the server, on box send back a iframe reply
      break;

      case RK_CONNECT_REPLY:  // reply from our request to bring up connection
        TraceStr( "Rk_reply");
        if (pm->Status & S_SERVER)
        {
          if (pm->state == ST_CONNECT) // should happen at this time
          {
            pm->state = ST_ACTIVE;  // fire up a connection
          }
          else  // got it when not expecting it.
          {
            TraceStr("Err-Recover!");
            // client recovering, need resyc.
            port_resync_all(pm);
          }
        }
      break;

      case RK_CONNECT_ASK:  // packet from server
        TraceStr( "Rk_Ask");
        // should not see this on server
      break;

      case RK_PORT_SET:    // set the port num to work with
        TraceStr( "Rk_Port");
        if (*buf >= pm->num_ports)
        {
          TraceErr( "PortI!");
          port_num = *buf++;
          break;
        }
        port_num = *buf++;
        Port = pm->sp[port_num];
      break;

#ifdef COMMENT_OUT   // not on server
      case RK_BAUD_SET:  // set the baud rate
        Port->baudrate = *((DWORD *)(buf));  // Remotes QIn.QGet value
        buf += 4;
        //sSetBaudRate(ChP, Port->baudrate, 1);
      break;

      case RK_CONTROL_SET:  // set the baud rate
        w1 = *((WORD *)(buf));  // control settings
        buf += 2;
        control_set(port_num, w1);
      break;

      case RK_MCR_SET:  // modem control reg pkt
        w1 = *((WORD *)(buf));  // control settings
        buf += 2;
        mcr_set(port_num, w1);
      break;
#endif

      case RK_MSR_SET:  // modem status reg pkt
        Port->msr_value = *((WORD *)(buf));
        Trace1("Rk_MSR:%xH", Port->msr_value);
        buf += 2;
      break;

      case RK_ACTION_ACK:  // modem status reg pkt
        // NT does not use this one, novell driver does to 
        // help dump all data in transit during a flush.
        //Port->action_resp = *((WORD *)(buf));
        Trace1("Rk_Act_Ack:%xH", *((WORD *)(buf)));
        buf += 2;
      break;

      case RK_ESR_SET:  // error status reg pkt
        Port->esr_reg = *((WORD *)(buf));
        Trace1("Rk_ESR:%xH", Port->esr_reg);
        buf += 2;
      break;

      case RK_QIN_STATUS:  // qin status report
        TraceStr( "Rk_QStat");
#ifdef NEW_Q
        Port->nGetRemote = *((WORD *)(buf));  // track remote output buffer space
#else
        Port->QInRemote.QGet = *((short *)(buf));  // Remotes QIn.QGet value
#endif
        buf += 2;
      break;

      case RK_DATA_BLK:    // data block to put in buffer queue
        TraceStr( "Rk_Data");
#ifdef NEW_Q
        //old(does not belong here!):Port->Status |= S_UPDATE_ROOM;
#else
        Port->Status |= S_UPDATE_ROOM;
#endif
        len = *((WORD *)(buf));
        buf += 2;

        QInRoom  = q_room(&Port->QIn);
        TraceAssert((QInRoom < Port->QIn.QSize), "Err1B!!!");
        TraceAssert((QInRoom >= 0), "Err1B!!!");
        if (len > QInRoom)  // Overflow
        {
          TraceErr("Err-Port Overflow!");
          len = 0;
        }
        q_put(&Port->QIn, buf, len);
        buf += len;
      break;

      default:
        done = 1;
        if (*(buf-1) != 0)
        {
          TraceErr("Bad Sub pkt hdr!");
          GTrace1(D_Error,sz_modid," HDR:%xH",*(buf-1));
        }
      break;
    }  // case per sub-packet
  }  // while not done with sub-packets
  return 0;
}

/*--------------------------------------------------------------------------
  port_poll - check to see if we need to send any packets over.  If we have
    new data in or need to send status packets over.
|--------------------------------------------------------------------------*/
int port_poll(PortMan *pm)
{
#define MAX_TX_SPACE 1460
  int i, tx_used;
  SerPort *Port;
  unsigned char *buf;
  int ToMove, ThisMove;
  int QOutCount;
  int QLanRoom;
#ifdef NEW_Q
  WORD tmp_word;
#endif
  int port_set;  // flag it as not setup.


// this logic is in isr.c service routine now
//  if (pm->state != ST_ACTIVE)
//  {
//    port_state_handler(pm);
//    return 0;
//  }

  tx_used = MAX_TX_SPACE+1000;  // indicate no pkt allocated
#if DBG
  if (pm == NULL)
  {
    MyKdPrint(D_Error, ("!!!!!pm null\n"))
    return 0;
  }
#endif

  // handle box things, send out a query to check-connection if
  // hdlc saw inactivity.
  if (pm->Status & S_CHECK_LINK)
  {
    if (tx_used > (MAX_TX_SPACE-50))  // if our tx-pkt is near full or null
    {
       buf = port_setup_outpkt(pm, &tx_used);
       if (buf == NULL)
         return 0;  // no more output packet space available, so all done
       buf[tx_used++] = RK_CONNECT_CHECK;
       // at this point we queued our iframe to query other side(to ensure
       // link-integrity.
       pm->Status &= ~S_CHECK_LINK;  // reset our request to send this
       TraceStr("Check sent");
    }
  }

  for (i=0; i<pm->num_ports; i++)
  {
    Port = pm->sp[pm->last_round_robin];

    //----- see if flag set to tell other side how much room in Port Rx buf
    if (Port->Status & S_UPDATE_ROOM)
    {
      TraceStr("Update needed");
      if (tx_used > (MAX_TX_SPACE-50))  // if our tx-pkt is near full or null
      {
         buf = port_setup_outpkt(pm, &tx_used);
         if (buf == NULL)
           return 0;  // no more output packet space available, so all done
         port_set = 0xff;  // flag it as not setup.
      }
      if (port_set != pm->last_round_robin)   // our port index not setup
      {
        buf[tx_used++] = RK_PORT_SET;
        buf[tx_used++] = (BYTE) pm->last_round_robin;
        port_set = pm->last_round_robin;
      }

      // take away status reminder flag
      Port->Status &= ~S_UPDATE_ROOM;

               // form the sub-packet in our output packet buffer
      buf[tx_used++] = RK_QIN_STATUS;
               // report our actual QGet index to other side.
#ifdef NEW_Q
      *((WORD *)(&buf[tx_used])) = Port->nGetLocal;
#else
      *((short *)(&buf[tx_used])) = Port->QIn.QGet;
#endif
      tx_used += 2;
    }

    //----- do action items
    if (Port->action_reg != 0)
    {
      if (port_handle_outpkt(pm, &buf, &tx_used, &port_set) != 0) // no pkt space avail
         return 0;  // no more output packet space available, so all done

      TraceStr("act pkt");
      buf[tx_used++] = RK_ACTION_SET;
      *((WORD *)(&buf[tx_used])) = Port->action_reg;
      Port->action_reg = 0; // its a one-shot deal, so we reset this now
      tx_used += 2;
    }

    //----- do updates for control settings, mcr, etc
    if (Port->old_control_settings != Port->control_settings)
    {
      if (port_handle_outpkt(pm, &buf, &tx_used, &port_set) != 0) // no pkt space avail
         return 0;  // no more output packet space available, so all done

      Port->old_control_settings = Port->control_settings;
      TraceStr("ctr chg");
      buf[tx_used++] = RK_CONTROL_SET;
      *((WORD *)(&buf[tx_used])) = Port->control_settings;
      tx_used += 2;
    }

    //----- do updates for mcr
    if (Port->old_mcr_value != Port->mcr_value)
    {
      if (port_handle_outpkt(pm, &buf, &tx_used, &port_set) != 0) // no pkt space avail
         return 0;  // no more output packet space available, so all done

      TraceStr("mcr chg");
      Port->old_mcr_value = Port->mcr_value;
      buf[tx_used++] = RK_MCR_SET;
      *((WORD *)(&buf[tx_used])) = Port->mcr_value;
      tx_used += 2;
    }

    //----- do updates for special chars, etc
    if (Port->change_flags)
    {
      if (Port->change_flags & CHG_BAUDRATE)
      {
        //----- do updates for baud rate settings
        if (Port->old_baudrate != Port->baudrate)
        {
          if (port_handle_outpkt(pm, &buf, &tx_used, &port_set) != 0) // no pkt space avail
            return 0;  // no more output packet space available, so all done

          Port->old_baudrate = Port->baudrate;
          Trace1("baud:%lu", Port->baudrate);
          buf[tx_used++] = RK_BAUD_SET;
          *((DWORD *)(&buf[tx_used])) = Port->baudrate;
          tx_used += 4;
        }
      }

      if (Port->change_flags & CHG_SP_CHARS)
      {
        if (memcmp(&Port->last_sp_chars, &Port->sp_chars, 6) != 0)  // compare structs for chg
        {
          Port->last_sp_chars = Port->sp_chars;  // remember last set values
          if (port_handle_outpkt(pm, &buf, &tx_used, &port_set) != 0) // no pkt space avail
             return 0;  // no more output packet space available, so all done

          TraceStr("sp_chars");
          buf[tx_used++] = RK_SPECIAL_CHAR_SET;

          Trace1(" rx_xon:%x", Port->sp_chars.rx_xon);
          Trace1(" rx_xoff:%x", Port->sp_chars.rx_xoff);
          Trace1(" tx_xon:%x", Port->sp_chars.tx_xon);
          Trace1(" tx_xoff:%x", Port->sp_chars.tx_xoff);
          Trace1(" error:%x", Port->sp_chars.error);
          Trace1(" event:%x", Port->sp_chars.event);

          buf[tx_used++] = Port->sp_chars.rx_xon;
          buf[tx_used++] = Port->sp_chars.rx_xoff;
          buf[tx_used++] = Port->sp_chars.tx_xon;
          buf[tx_used++] = Port->sp_chars.tx_xoff;
          buf[tx_used++] = Port->sp_chars.error;
          buf[tx_used++] = Port->sp_chars.event;
        }
      }
      Port->change_flags = 0;  // reset all
    }

    //----- send any outgoing data if other side has room.
    QOutCount = q_count(&Port->QOut);
#ifdef NEW_Q
    // calculate our remote tx-buffer space based on WORD modulo arithmetic
    tmp_word = PortGetTxCntRemote(Port);

    // right now this var is equal to how much tx-data is in remote buffer.
    if (tmp_word < REMOTE_IN_BUF_SIZE)
         QLanRoom = REMOTE_IN_BUF_SIZE - tmp_word;
    else QLanRoom = 0;
    // now it is how much room we have in the remote tx-buffer.
#else
    QLanRoom  = q_room(&Port->QInRemote);  // other sides port queue room
#endif
    if ((QOutCount > 0) && (QLanRoom > 50))  // have data, other side has room
    {
      TraceStr("Data to Send");
      if (QOutCount > QLanRoom)  // more data than room
           ToMove = QLanRoom;       // limit
      else ToMove = QOutCount;

      do
      {
        if (tx_used > (MAX_TX_SPACE-50))  // if our tx-pkt is near full or null
        {
           buf = port_setup_outpkt(pm, &tx_used);  // allocate a new one
           if (buf == NULL)
             return 0;  // no more output packet space available, so all done
           port_set = 0xff;  // flag it as not setup.
        }
        if (port_set != pm->last_round_robin)   // our port index not setup
        {
          buf[tx_used++] = RK_PORT_SET;
          buf[tx_used++] = (BYTE) pm->last_round_robin;
          port_set = pm->last_round_robin;
        }

        // make sure we have emough room for data, limit if we don't
        if (ToMove > ((MAX_TX_SPACE-1) - tx_used) )
        {
          ThisMove = (MAX_TX_SPACE-1) - tx_used;
          ToMove -= ThisMove;
        }
        else
        {
          ThisMove = ToMove;
          ToMove = 0;
        }
        buf[tx_used++] = RK_DATA_BLK;           // set header sub-type
        *((WORD *)(&buf[tx_used])) = ThisMove;   // set header data size
        tx_used += 2;
        q_get(&Port->QOut, &buf[tx_used], ThisMove);
        tx_used += ThisMove;

        // keep our own copy of remote qin indexes
#ifdef NEW_Q
        // bump our tx-buffer count based on WORD modulo arithmetic
        Port->nPutRemote += ((WORD)ThisMove);
#else
        q_putted(&Port->QInRemote, ((short)ThisMove));
#endif
      } while (ToMove > 0);  // keep using packets if more to send
    }  // if data sent

    ++pm->last_round_robin;
    if (pm->last_round_robin >= pm->num_ports)
      pm->last_round_robin = 0;
  }


  if (tx_used < (MAX_TX_SPACE+1000))  // then we allocated a packet prior
  {                              // and need to send it
    if (hdlc_send_outpkt(pm->hd, tx_used, pm->hd->dest_addr)) // send it out!
    {
      TraceErr("Err-hdlc_send1");
    }
  }

  //TraceStr( "EndPoll");

  return 0;
}

/*--------------------------------------------------------------------------
 port_state_handler - handle states other than normal data flowage.
   Called at scanrate(1-20ms) times per second from service routine.
|--------------------------------------------------------------------------*/
void port_state_handler(PortMan *pm)
{
  int inic;

  if (pm->old_state != pm->state)
  {
    pm->old_state = pm->state;
    pm->state_timer = 0;
  }

  pm->timer_base += ((WORD) Driver.Tick100usBase);  // 100us base units(typical:100)
  if (pm->timer_base < 98)  // less than 9.8ms
  {
    // we want to run roughly 100 ticks per second
    return;
  }
  pm->timer_base = 0;

  switch(pm->state)
  {
    case ST_INIT:
      // if we are server, then wait for query back.

//pm->state_timer = 0;
//break;

      if (pm->Status & S_SERVER)
      {
        if (pm->state_timer == 600) // 6 seconds
        {
          pm->ownership_timer = 0;
          TraceStr( "Send Query");
          // find box out on network, use ADMIN pkt
          // do the query on all nic-segments
          for (inic=0; inic<VS1000_MAX_NICS; inic++)
          {
            if (Driver.nics[inic].Open)  // if nic-card open for use
            {
              // send a passive query(don't try to assume ownership
              if (admin_send_query_id(&Driver.nics[inic], pm->hd->dest_addr,
                                      0, 0) != 0)
              {
                TraceErr( "Err1E");
              }
            }
          }
        }
        else if (pm->state_timer == 1800) // 18 seconds
        {
          // try a broadcast to cut through switches.
          TraceStr( "Send Br.Query");
          // find box out on network, use ADMIN pkt
          // do the query on all nic-segments
          for (inic=0; inic<VS1000_MAX_NICS; inic++)
          {
            if (Driver.nics[inic].Open)  // if nic-card open for use
            {
              // send a passive query(don't try to assume ownership
              if (admin_send_query_id(&Driver.nics[inic], broadcast_addr,
                                      0, 0) != 0)
              {
                TraceErr( "Err1E");
              }
            }
          }
        }
        else if (pm->state_timer > 2400)  // 24 sec, give up start over
          pm->state_timer = 0;
      }
    break;

    case ST_GET_OWNERSHIP:
      // if we are server, then wait for query back.
      if (pm->Status & S_SERVER)
      {
        // Increment when in ST_GET_OWNERSHIP state for backup server.
        ++pm->load_timer;
        if (pm->state_timer == 10) // 100ms
        {
          TraceStr( "Send Query Owner");
          // find box out on network, use ADMIN pkt
          // do the query on all nic-segments
          for (inic=0; inic<VS1000_MAX_NICS; inic++)
          {
            if (Driver.nics[inic].Open)  // if nic-card open for use
            {
              // BUGFIX(8-26-98), this was only sending it out on
              // the nic card assigned to pm.
              //)if (admin_send_query_id(pm->nic, pm->hd->dest_addr,
              if (admin_send_query_id(&Driver.nics[inic], pm->hd->dest_addr,
                                      1, (BYTE) pm->unique_id) != 0)
              {
                TraceErr( "Err1G");
              }
            }
          }
        }
        else if (pm->state_timer > 600) // 6 seconds
        {
          // SAFE GUARD ADDED DUE to SCREWED UP OWNERSHIP STATE MACHINE
          // kpb, 8-25-98, make sure we don't spend forever in this state.
          pm->ownership_timer += 6;
          if (pm->ownership_timer > (60 * 15))  // 15 minutes
          {
            pm->state = ST_INIT;
            pm->load_timer = 0;
          }
          pm->state_timer = 0;
        }
        // 8-26-98
        // NOTICE, we are not reseting state to INIT after a while,
        // this is a problem!
      }
    break;

    case ST_SENDCODE:  // download main driver code to box
      if (pm->state_timer == 0)
      {
        ++pm->total_loads;
        pm->code_cnt = 0;  // start upload
        send_code(pm);
      }
      else if (pm->state_timer == 1000)  // 10 seconds since init
      {
        TraceErr("Upload Retry");
        ++pm->total_loads;
        pm->code_cnt = 0;  // start upload
        send_code(pm);
      }
      else if (pm->state_timer == 2000)  // 20 seconds since init
      {
        TraceErr("Upload Retry");
        ++pm->total_loads;
        pm->code_cnt = 0;  // start upload
        send_code(pm);
      }
      else if (pm->state_timer == 3000)   // fail it out, start over with init
      {
        TraceErr("Upload Fail");
        pm->state = ST_INIT;
        pm->load_timer = 0;
      }
      else if (pm->code_state == 1)  // signal port poll code to send next chunk
      {
        TraceStr("Upload, next chk.");
        if (pm->code_cnt < Driver.MicroCodeSize)
        {
          if (send_code(pm) == 0)  // success
            pm->code_state = 0;
        }
        else  // all done
        {
          TraceStr("Code Upload Done.");
          if (send_go(pm) == 0)
          {
            ++pm->good_loads;
            pm->code_cnt = 0;
            pm->state = ST_GET_OWNERSHIP;
          }
        }
      }
    break;

    case ST_CONNECT:
      if (pm->state_timer == 0)
         port_connect_ask(pm->hd);
      else if (pm->state_timer == 1000)  // 10 seconds
         port_connect_ask(pm->hd);
      else if (pm->state_timer == 2000)  // 20 seconds
      {
        pm->state = ST_INIT;  // fall back
        pm->load_timer = 0;
      }
    break;

    default:
      TraceErr("Err-PState!");
      pm->state = ST_INIT;
      pm->load_timer = 0;
    break;
  }
  ++pm->state_timer;
}

/*--------------------------------------------------------------------------
 port_handle_outpkt - check if we have at least 50 bytes in outpkt, if
  not get a new one.  If no new one avail, return non-zero.
|--------------------------------------------------------------------------*/
int port_handle_outpkt(PortMan *pm, BYTE **buf, int *tx_used, int *port_set)
{
  if (*tx_used > (MAX_TX_SPACE-50))  // if our tx-pkt is near full or null
  {
     *buf = port_setup_outpkt(pm, tx_used);
     if (*buf == NULL)
       return 1;  // no more output packet space available, so all done
     *port_set = 0xff;
  }
  if (*port_set != pm->last_round_robin)
  {
    // since we have a new pkt, we need to
    (*buf)[(*tx_used)++] = RK_PORT_SET;
    (*buf)[(*tx_used)++] = (BYTE) pm->last_round_robin;
    *port_set = pm->last_round_robin;
  }
  return 0;  // current pkt has plenty of room(at least 50 bytes)
}

/*--------------------------------------------------------------------------
 port_setup_outpkt - setup an outgoing packet if one is available, if previously
   filled one out then we ship it off out the nic card.
|--------------------------------------------------------------------------*/
BYTE *port_setup_outpkt(PortMan *pm, int *tx_used)
{
  BYTE *buf;

  if (*tx_used != (MAX_TX_SPACE+1000))  // then we allocated a packet prior
  {                              // and need to send it
    if (hdlc_send_outpkt(pm->hd, *tx_used, pm->hd->dest_addr)) // send it out!
    {
      TraceErr("send err");
    }
  }
  if (hdlc_get_outpkt(pm->hd, &buf) == 0)  // no error, got a output packet
  {
    TraceStr("NPkt2");
    *tx_used = 0;  // have a new empty output packet allocated
    return buf;  // all done
  }
  else
  {
    TraceStr("NPktDone2");
    *tx_used = MAX_TX_SPACE+1000;  // indicate no pkt allocated
    return NULL;  // all done
  }
}

/*--------------------------------------------------------------------------
port_load_pkt - got a admin boot load packet: ACK back from code download pkt.
|--------------------------------------------------------------------------*/
void port_load_pkt(PortMan *pm, BYTE *pkt)
{
  if (pm->state != ST_SENDCODE)  // not expected at this time, lets reset it.
  {
    TraceErr("BootLoad not at SENDCODE!");
    Tprintf("state=%d", pm->state);
    // other details????
    pm->state = ST_INIT;
    pm->load_timer = 0;
    //pm->hd->state = ST_HDLC_INIT;
    return;
  }

  if (Driver.MicroCodeSize == 0)
  {
    TraceErr("Bad MC");
    return;
  }

  if (check_ack_code(pm,pkt) != 0)
  {
    TraceErr("Bad Ack");
    return;
  }
  TraceStr("Good Ack!");

  // send more data
  if (pm->code_cnt < Driver.MicroCodeSize)
    pm->code_cnt += 1000;
  pm->code_state = 1;  // signal port poll code to send next chunk
}

#if NEW_QUERY_HANDLER
/*--------------------------------------------------------------------------
port_query_reply - got a ADMIN query reply back, server sends out
  query-id request on init and when setup is entered, box sends back 
  id(which tells us if code is loaded.)   A query reply is ignored in
  states other that ST_INIT and ST_GET_OWNERSHIP
|--------------------------------------------------------------------------*/
void port_query_reply(PortMan *pm, BYTE *pkt)
{
  int unit_available  = 0;
  int unit_needs_code = 0;
  int unit_needs_reset = 0;

  if (!mac_match(pkt, pm->hd->dest_addr))
  {
    TraceErr("Reply MAC bad!");
    return;
  }

  // ignore if not ST_INIT or ST_GET_OWNERSHIP
  if ((pm->state != ST_INIT) && (pm->state != ST_GET_OWNERSHIP)) 
  {
    return;
  }

  if (pkt[7] >= VS1000_MAX_NICS)  // if invalid nic-index
  {
    TraceErr("Nic Index Reply!");
    return;
  }

  // when we get the query packet, we stash the nic-card index
  // into part of the receive buffer that is unused(pkt[7]).
  // see if this matches what our port-manager nic_index is,
  // if not, then we switched nic cards and need to update some
  // things.
  if (pm->nic_index != (int)(pkt[7]))  // changed nic cards
  {
    TraceErr("Nic Changed!");
    pm->nic_index = (int)(pkt[7]);   // set nic_index
    pm->nic = &Driver.nics[pm->nic_index];  // changed nic cards
    pm->hd->nic = pm->nic;  // update the hdlc nic ptr
  }
#define Q_DRIVER_RUNNING 1
#define Q_NOT_OWNER      2
#define Q_ABANDONED      4

  // we are NOT owner(2H), and main app-driver running(1H), be careful
  if ((pkt[6] & Q_DRIVER_RUNNING) && (pkt[6] & Q_NOT_OWNER))
  {
    // if not owner timeout, (4H=ABANDONED) then leave alone!
    // some other server is actively using it.
    if ((pkt[6] & Q_ABANDONED) == 0) 
    {
      Trace1("ReplyID, Not Ours. [%x]", pkt[6]);
        pm->load_timer = 0;
      pm->state = ST_INIT;
      pm->load_timer = 0;
      return;
    }
    // else its abandoned, so we can take ownership.
    unit_available  = 1;
    unit_needs_reset = 1;
  }
  else
  {
    // we are owner or main-driver not running yet
    unit_available  = 1;
  }
  if ((pkt[6] & Q_DRIVER_RUNNING) == 0)
  {
    unit_needs_code = 1;
  }

  if (pm->Status & S_NEED_CODE_UPDATE)
  {
    unit_needs_reset = 1;
    unit_needs_code  = 1;
  }

  // ok to take ownership(no owner)
  TraceStr("ReplyID, Unit Available");
  if (pm->state == ST_INIT)
  {
    if ((pm->backup_server == 0) ||
        (pm->load_timer >= (pm->backup_timer*6000)) )
    {
      if (pm->backup_server == 0)
        { TraceStr("Pri. make owner"); }
      else
        { TraceStr("2nd. make owner"); }
      pm->state = ST_GET_OWNERSHIP;
      // this will cause the state machine to issue a query trying to
      // obtain ownership
      unit_needs_reset = 1;
    }
    else
    {
      if (pm->load_timer >= (pm->backup_timer*6000))
      {
        TraceStr("2nd, make owner");
        pm->state = ST_GET_OWNERSHIP;
        // this will cause the state machine to issue a query trying to
        // obtain ownership
      }
    }
  }
  else if (pm->state == ST_GET_OWNERSHIP)
  {
    TraceStr("ReplyID in GET_OWNERSHIP");

      // Is this the primary server or has the backup timer expired?
    if ((pm->backup_server == 0) && (pm->load_timer >= (pm->backup_timer*6000))
    {  
      // we are NOT owner(2H), and main app-driver running(1H), be careful
      if ((pkt[6] & 3) == 3)
      {
        if (pkt[6] & 4)  // Owner has timed out - force reload
        {
          // force a reset of box on driver-load(this bit is set in 
          // port_init) so we load up some fresh microcode.
          admin_send_reset(pm->nic, pm->hd->dest_addr);
          TraceStr("Abandoned, ReSet");
        }
      }
      else if ((pkt[6] & 1) == 0) // code is not downloaded, so download it.
      {
        // Make sure that we are the owner?
        if (pkt[6] & 2)  // 2h=not owner bit
        {
          TraceStr("GET_OWNERSHIP: No App - Not Owner!");
          pm->state = ST_INIT;
          pm->load_timer = 0;
          return;
        }
        TraceStr("GET_OWNERSHIP: Download");
        pm->Status &= ~S_NEED_CODE_UPDATE;
        pm->state = ST_SENDCODE;
      }
      else  // code is downloaded - we are the owner
      {  
        if (pm->Status & S_NEED_CODE_UPDATE)
        {
          // force a reset of box on driver-load(this bit is set in 
          // port_init) and set S_NEED_CODE_UPDATE so we load up some 
          // fresh microcode.
          admin_send_reset(pm->nic, pm->hd->dest_addr);
          TraceStr("ReplyID, ReLoad");
          pm->Status &= ~S_NEED_CODE_UPDATE;
        }
        else
        {
          TraceStr("ReplyID, GoToConnect");
          port_resync_all(pm);
          //pm->state = ST_ACTIVE;
          pm->state = ST_CONNECT;
        }
      }
    }
  }
}
#else

/*--------------------------------------------------------------------------
port_query_reply - got a ADMIN query reply back, server sends out
  query-id request on init and when setup is entered, box sends back 
  id(which tells us if code is loaded.)   A query reply is ignored in
  states other that ST_INIT and ST_GET_OWNERSHIP
|--------------------------------------------------------------------------*/
void port_query_reply(PortMan *pm, BYTE *pkt)
{
  if (!mac_match(pkt, pm->hd->dest_addr))
  {
    TraceErr("Reply MAC bad!");
    return;
  }

  // ignore if not ST_INIT or ST_GET_OWNERSHIP
  if ((pm->state != ST_INIT) && (pm->state != ST_GET_OWNERSHIP)) 
  {
    return;
  }

  if (pkt[7] >= VS1000_MAX_NICS)  // if invalid nic-index
  {
    TraceErr("Nic Index Reply!");
    return;
  }

  // when we get the query packet, we stash the nic-card index
  // into part of the receive buffer that is unused(pkt[7]).
  // see if this matches what our port-manager nic_index is,
  // if not, then we switched nic cards and need to update some
  // things.
  if (pm->nic_index != (int)(pkt[7]))  // changed nic cards
  {
    TraceErr("Nic Changed!");
    pm->nic_index = (int)(pkt[7]);   // set nic_index
    pm->nic = &Driver.nics[pm->nic_index];  // changed nic cards
    pm->hd->nic = pm->nic;  // update the hdlc nic ptr
  }

  // we are NOT owner(2H), and main app-driver running(1H), be careful
  if ((pkt[6] & 3) == 3)
  {
    // if not owner timeout, (4H=ABANDONED) then leave alone!
    // some other server is actively using it.
    if ((pkt[6] & 4) == 0) 
    {
     Trace1("ReplyID, Not Ours. [%x]", pkt[6]);
        pm->load_timer = 0;
     pm->state = ST_INIT;
      return;
    }
  }

  if (pm->state == ST_INIT)
  {  
   // ok to take ownership(no owner)
   pm->state = ST_GET_OWNERSHIP;
   if(pm->backup_server == 0)
   {
     Trace1("ReplyID, Primary Server - Unit Available [%x]", pkt[6]);
   }
   else
   {
     Trace1("ReplyID, Backup Server - Unit Available [%x]", pkt[6]);
   }
  }
  else if (pm->state == ST_GET_OWNERSHIP)
  {
   Trace1("ReplyID, GET_OWNERSHIP [%x]", pkt[6]);
    // Is this the primary server or has the backup timer expired?
    if((pm->backup_server == 0) || 
     (pm->load_timer >= (pm->backup_timer*6000)))
   {
     // we are NOT owner(2H), and main app-driver running(1H), be careful
     if ((pkt[6] & 3) == 3)
     {
       if (pkt[6] & 4)  // Owner has timed out - force reload
     {
       // force a reset of box on driver-load(this bit is set in
       // port_init) so we load up some fresh microcode.
       admin_send_reset(pm->nic, pm->hd->dest_addr);
       TraceStr("ReplyID, ReLoad");
     }
     else
     {
       TraceStr("GET_OWNERSHIP: App Running - Not Owner!");
       pm->state = ST_INIT;
          pm->load_timer = 0;
       return;
     }
     }
      else if ((pkt[6] & 1) == 0) // code is not downloaded, so download it.
      {
     // Make sure that we are the owner?
        if (pkt[6] & 2)  // 2h=not owner bit
     {
       TraceStr("GET_OWNERSHIP: No App - Not Owner!");
       pm->state = ST_INIT;
          pm->load_timer = 0;
       return;
     }
        TraceStr("GET_OWNERSHIP: Download");
        pm->Status &= ~S_NEED_CODE_UPDATE;
        pm->state = ST_SENDCODE;
      }
      else  // code is downloaded - we are the owner
     {
     if (pm->Status & S_NEED_CODE_UPDATE)
     {
       // force a reset of box on driver-load(this bit is set in
       // port_init) and set S_NEED_CODE_UPDATE so we load up some
       // fresh microcode.
       admin_send_reset(pm->nic, pm->hd->dest_addr);
       TraceStr("ReplyID, ReLoad");
          pm->Status &= ~S_NEED_CODE_UPDATE;
     }
     else
     {
       TraceStr("ReplyID, GoToConnect");
       port_resync_all(pm);
       //pm->state = ST_ACTIVE;
       pm->state = ST_CONNECT;
     }
     }
   }
  }
}
#endif

/*--------------------------------------------------------------------------
| port_connect_reply - Reply to server connection request, we return our
    MAC address, and do a re-sync operation.
|--------------------------------------------------------------------------*/
int port_connect_reply(Hdlc *hd)
{
  BYTE rkt_header[8];

  TraceStr( "Connect Reply");
  rkt_header[0] = RK_CONNECT_REPLY;
  memcpy(&rkt_header[1], hd->nic->address,6);
  hdlc_send_control(hd, rkt_header, 7,
                    NULL, 0,   // ptr to data to send
                    hd->dest_addr); // MAC address to send to
  hdlc_resync(hd);
  return 0;
}

/*--------------------------------------------------------------------------
| port_connect_ask - Ask box to initiate a connection.  We send out our
    MAC address, and do a resync.
|--------------------------------------------------------------------------*/
int port_connect_ask(Hdlc *hd)
{
  BYTE rkt_header[8];

  TraceStr( "Connect Ask");
  rkt_header[0] = RK_CONNECT_ASK;
  memcpy(&rkt_header[1], hd->nic->address,6);

  hdlc_send_control(hd, rkt_header, 7,
                    NULL, 0,   // ptr to data to send
                    hd->dest_addr); // MAC address to send to
  hdlc_resync(hd);
  return 0;
}

/*------------------------------------------------------------------
 PortSetBaudRate - Set the desired baud rate.  Return non-zero on error.
|-------------------------------------------------------------------*/
int PortSetBaudRate(SerPort *p,
                    ULONG desired_baud,
                    USHORT SetHardware,
                    DWORD  clock_freq,
                    DWORD  clk_prescaler)
{
  ULONG diff;
  ULONG act_baud;
  ULONG percent_error;
  ULONG div;
  ULONG base_clock_rate;

  base_clock_rate = ((clock_freq/16) / ((clk_prescaler & 0xf)+1));

  // calculate the divisor for our hardware register.
  // this is really just div = clk/desired_baud -1.  but we do some
  // work to minimize round-off error.
  if (desired_baud <= 0) desired_baud = 1;  // guard against div 0

  div =  ((base_clock_rate+(desired_baud>>1)) / desired_baud) - 1;
  if (div > 8191)  // overflow hardware divide register
    div = 8191;

  // this is really just (clk) / (div+1) but we do some
  // work to minimize round-off error.
  act_baud = (base_clock_rate+((div+1)>>1)) / (div+1);

  if (desired_baud > act_baud)
    diff = desired_baud - act_baud;
  else
    diff = act_baud - desired_baud;

  percent_error = (diff * 100) / desired_baud;
  if (percent_error > 5)
    return (int) percent_error;

  if (SetHardware)
  {
    p->change_flags |= CHG_BAUDRATE;
    //---- OLD p->out_flags |= SC_BAUDRATE_CHANGE;   // tells what needs changing to remote
    p->baudrate = desired_baud;
  }
  return 0;
}

/*---------------------------------------------------------------------------
| check_ack_code - upload code, given ack packet, check for good status.
|---------------------------------------------------------------------------*/
int check_ack_code(PortMan *pm, BYTE *pkt)
{
  int stat;
  int snd;

  TraceStr("CodeChk");
  stat = eth_device_reply(UPLOAD_COMMAND,
                          0x00010000L + pm->code_cnt,
                          &snd,
                          NULL,
                          pkt);
  return stat;
}
                  
/*---------------------------------------------------------------------------
| send_go - send boot loader command to start execution of uploaded driver
   at 1000:0 in memory.
|---------------------------------------------------------------------------*/
int send_go(PortMan *pm)
{
  int stat;
  BYTE *buf;
  WORD io[4];
  BYTE *tx_base;

  TraceStr("GoSend");

  hdlc_get_ctl_outpkt(pm->hd, &buf);
  if (buf == NULL)
    return 1;
  tx_base = buf - 20;  // backup to start of pkt

  io[0] = 0x1000;  // segment to go at
  io[1] = 0;  // offset to go at

  // send more code, loading at 10000H location in mem.
  // first just transfer data to an outgoing packet buffer
  stat = ioctl_device(IOCTL_COMMAND,
                      (BYTE *) io,
                      buf,
                      12,  // 12 = go command
                      4);  // num bytes of data
  // setup header
  tx_base[14] = ASYNC_PRODUCT_HEADER_ID;  // comtrol packet type = driver management, any product.
  tx_base[15] = 0;     // conc. index field
  tx_base[16] = 1;     // admin
  *((WORD *)&tx_base[17]) = 40;
  tx_base[19] = 1;     // ADMIN packet type, 1=boot-loader, 3=id-reply

  // send it.
  stat = hdlc_send_raw(pm->hd, 60, NULL);
  return 0;
}

/*---------------------------------------------------------------------------
| send_code - upload code.
|---------------------------------------------------------------------------*/
int send_code(PortMan *pm)
{
  int stat;
  BYTE *buf;
  BYTE *tx_base;
  long snd;

  TraceStr("CodeSend");

  // send more data
  if (pm->code_cnt < Driver.MicroCodeSize)
  {
    if ((Driver.MicroCodeSize - pm->code_cnt) > 1000)
      snd = 1000;
    else
      snd = Driver.MicroCodeSize - pm->code_cnt;

    hdlc_get_ctl_outpkt(pm->hd, &buf);
    if (buf == NULL)
    {
      TraceErr("CodeSend Err1A");
      return 1;
    }
    tx_base = buf - 20;  // backup to start of pkt

    // send more code, loading at 10000H location in mem.
    // first just transfer data to an outgoing packet buffer
    stat = ioctl_device(UPLOAD_COMMAND,
                        &Driver.MicroCodeImage[pm->code_cnt],
                        buf,
                        0x00010000L + pm->code_cnt,  // offset into memory
                        snd);
    // setup header
    tx_base[14] = ASYNC_PRODUCT_HEADER_ID;  // comtrol packet type = driver management, any product.
    tx_base[15] = 0;     // conc. index field
    tx_base[16] = 1;     // admin
    *((WORD *)&tx_base[17]) = snd+20;
    tx_base[19] = 1;     // ADMIN packet type, 1=boot-loader, 3=id-reply

    // send it.
    stat = hdlc_send_raw(pm->hd, snd+40, NULL);
  }
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\port.h ===
// port.h - serial port stuff
// 5-13-99 - enable RTS toggling for VS
// 3-20-98 add NEW_Q stuff, turned off for now - kpb

// following defines the port queue sizes for in/out going data between
// box and us.  See Qin, Qout structs in SerPort structs.
#define  IN_BUF_SIZE 2000  // must match box code, and be even #
#define OUT_BUF_SIZE 2000  // must match box code, and be even #

// uncomment this for new-q tracking code
#define NEW_Q

#ifdef NEW_Q
// following is less the rocketport-hardware buffer in the box
#define REMOTE_IN_BUF_SIZE (2000 - 256)
#endif

#define PORTS_MAX_PORTS_PER_DEVICE 64

//-------- sub-packet type byte header defines for type ASYNC_FRAME
#define RK_QIN_STATUS       0x60  // qin status report
#define RK_DATA_BLK         0x61  // data block
#define RK_PORT_SET         0x62  // set the port num to work with
#define RK_CONTROL_SET      0x63  // config the hardware
#define RK_MCR_SET          0x64  // change on modem control reg.
#define RK_MSR_SET          0x65  // change on modem status reg.
#define RK_ACTION_SET       0x66  // new actions, such as flush.
#define RK_ACTION_ACK       0x67  // response to actions, such as flush.
#define RK_BAUD_SET         0x70  // set the baud rate
#define RK_SPECIAL_CHAR_SET 0x71  // xon,xoff, err-replace, event-match
#define RK_ESR_SET          0x72  // set error status register.

#define RK_CONNECT_CHECK    0xfd  // server packet to check link is working
#define RK_CONNECT_REPLY    0xfe  // reply from RK_CONNECT_ASK
#define RK_CONNECT_ASK      0xff  // broadcast from server to get report from boxes

//------ old ssci.h stuff
#define TRUE 1
#define FALSE 0

//#define RX_HIWATER 512                 /* sw input flow ctl high water mark */
//#define RX_LOWATER 256                 /* sw input flow ctl low water mark */

#define OFF      0
#define ON       1
#define NOCHANGE 2

//Status
/* Open type and TX and RX identifier flags (unsigned int) */
#define COM_OPEN     0x0001            /* device open */
#define COM_TX       0x0002            /* transmit */
#define COM_RX       0x0004            /* receive */

typedef struct
{
  BYTE  rx_xon;  // xon  sent by us to resume rx flow, default to 11H
  BYTE  rx_xoff; // xoff sent by us to halt rx flow, default to 13H
  BYTE  tx_xon;  // xon  rec. by us to resume tx flow, default to 11H
  BYTE  tx_xoff; // xoff rec. by us to halt tx flow, default to 13H
  BYTE error; // in NT, option to replace error-chars with this char
  BYTE event; // in NT, can specify a event-char to match and notify
} Special_Chars;

// for NT, we want to keep this DWORD aligned, so NT and DOS see same struct
typedef struct
{
  //WORD  dev;      // handle index to com port, same as COM#(# part)
  //WORD  LanIndex; // index of port number to LAN
  WORD  Status;     // we use as internal status indicator

  WORD control_settings;   // parity, stopbits, databits, flowcontrol
  WORD old_control_settings;   // used to detect change
  DWORD baudrate;
  DWORD old_baudrate; // used to detect change
  WORD mcr_value;  // modem control register state
  WORD old_mcr_value;  // used to detect change

  WORD change_flags; // tells what might have changed and needs transfer to remote

  WORD msr_value;  // modem status register state
  WORD old_msr_value;  // used to detect change

  WORD action_reg;  // action(one-shot) functions:flush, etc.

  WORD esr_reg;  // error status register state(framing err, parity err,,)
                   // one shot style register(resets on read)

  // The following Q structures are in perspective of the LAN.
  // So QOut is the Que for data which is destined for the remote
  // client over the LAN.  QIn is data we received from the LAN.
  Queue QOut;
  Queue QIn;
#ifdef NEW_Q
  // How much data can we send over to the remote?
  // new method which can include hardware tx buffer space and
  // does not rely on set queue sizes.
  WORD nPutRemote; // tx data we sent to remote, Modulo 0x10000.
  WORD nGetRemote; // tx data remote cleared out, Modulo 0x10000.
                   // this value is sent to us as an update.
  WORD nGetLocal;  // tx data we cleared out, Modulo 0x10000.
                   // we send back as an update.
#else
  // How much data can we send over to the remote?  We can calculate
  // this by maintaining a mirror image of its Q data structure.
  // We maintain the Q.Put index, and the remote side sends us its
  // actual Q.Get value when it changes.  Then when we want to
  // calculate the room left in the remote queue(this includes anything
  // in transit.) we just do the normal queue arithmetic.
  // there is no actual data buffer used in this queue structure.
  Queue QInRemote;
#endif

  WORD remote_status;
  Special_Chars sp_chars;  // special chars struct: xon, xoff..
  Special_Chars last_sp_chars;  // used to detect when we need to send
} SerPort;



//----- change_flags bit assignments
// tells what has changed and needs transfer to remote
#define CHG_SP_CHARS       0x0001
#define CHG_BAUDRATE       0x0002

//----- Mirror Register bit flags, these are associated with fields in
// the SerPort struct, and get mirrored back/forth to the box to transfer
// state of the port.
// values for Status(SerPort)
#define S_OPENED           0x0001
#define S_UPDATE_ROOM      0x0002
#define S_NEED_CODE_UPDATE 0x0800

// control_settings, control settings
#define SC_STOPBITS_MASK  0x0001
#define SC_STOPBITS_1     0x0000
#define SC_STOPBITS_2     0x0001

#define SC_DATABITS_MASK  0x0002
#define SC_DATABITS_7     0x0002
#define SC_DATABITS_8     0x0000

#define SC_PARITY_MASK    0x000c
#define SC_PARITY_NONE    0x0000
#define SC_PARITY_EVEN    0x0004
#define SC_PARITY_ODD     0x0008

#define SC_FLOW_RTS_MASK   0x0070
#define SC_FLOW_RTS_NONE   0x0000
#define SC_FLOW_RTS_AUTO   0x0010
#define SC_FLOW_RTS_RS485  0x0020  // rts turn on to transmit
#define SC_FLOW_RTS_ARS485 0x0040  // rts turn off to transmit(auto-rocketport)

#define SC_FLOW_CTS_MASK  0x0080
#define SC_FLOW_CTS_NONE  0x0000
#define SC_FLOW_CTS_AUTO  0x0080

#define SC_FLOW_DTR_MASK  0x0100
#define SC_FLOW_DTR_NONE  0x0000
#define SC_FLOW_DTR_AUTO  0x0100

#define SC_FLOW_DSR_MASK  0x0200
#define SC_FLOW_DSR_NONE  0x0000
#define SC_FLOW_DSR_AUTO  0x0200

#define SC_FLOW_CD_MASK   0x0400
#define SC_FLOW_CD_NONE   0x0000
#define SC_FLOW_CD_AUTO   0x0400

#define SC_FLOW_XON_TX_AUTO  0x0800
#define SC_FLOW_XON_RX_AUTO  0x1000

#define SC_NULL_STRIP      0x2000

// mcr_value, settings(modem control reg.)
#define MCR_RTS_SET_MASK   0x0001
#define MCR_RTS_SET_ON     0x0001
#define MCR_RTS_SET_OFF    0x0000

#define MCR_DTR_SET_MASK   0x0002
#define MCR_DTR_SET_ON     0x0002
#define MCR_DTR_SET_OFF    0x0000

// loop in rocketport asic chip
#define MCR_LOOP_SET_MASK  0x0004
#define MCR_LOOP_SET_ON    0x0004
#define MCR_LOOP_SET_OFF   0x0000

#define MCR_BREAK_SET_MASK  0x0008
#define MCR_BREAK_SET_ON    0x0008
#define MCR_BREAK_SET_OFF   0x0000

// msr_value, settings(modem status reg.)
#define MSR_TX_FLOWED_OFF   0x0001
#define MSR_CD_ON           0x0008
#define MSR_DSR_ON          0x0010
#define MSR_CTS_ON          0x0020
#define MSR_RING_ON         0x0040
#define MSR_BREAK_ON        0x0080

//#define MSR_TX_FLOW_OFF_DTR  0x0040
//#define MSR_TX_FLOW_OFF_XOFF 0x0080

//-- action control register bit flags(server event out to device)
#define ACT_FLUSH_INPUT    0x0001
#define ACT_FLUSH_OUTPUT   0x0002
#define ACT_SET_TX_XOFF    0x0004
#define ACT_CLEAR_TX_XOFF  0x0008
#define ACT_SEND_RX_XON    0x0010
#define ACT_SEND_RX_XOFF   0x0020
#define ACT_MODEM_RESET    0x0040

//-- error status register bit flags
#define ESR_FRAME_ERROR    0x0001
#define ESR_PARITY_ERROR   0x0002
#define ESR_OVERFLOW_ERROR 0x0004
#define ESR_BREAK_ERROR    0x0008

//-- event control register bit flags(device event reported to server)

#define ST_INIT          0
#define ST_GET_OWNERSHIP 1
#define ST_SENDCODE      2
#define ST_CONNECT       3
#define ST_ACTIVE        4

// following for trace or dump messages, make public for other mods as well.
char *port_state_str[];

typedef struct {
  Nic *nic;    // ptr to our NIC card handler
  Hdlc *hd;    // ptr to our HDLC struct handler
  SerPort *sp[PORTS_MAX_PORTS_PER_DEVICE]; // ptr to list of our sp objects(num_ports worth)
  int unique_id;  // unique id assigned to this device
  int backup_server;  // 1=this is a backup server,0=primary server
  int backup_timer;   // 1=backup server timer used to detect how long to 
					  // wait before attempting to acquire the box
  int load_timer;  // our load_timer, incr. every time in port_poll compared
				   // against backup_timer for when to load box 
  int nic_index;  // index of nic card
  int num_ports;  // num ports on this box
  //int sp_index;   // index into total SerPort array
  int state;      // state for state-machine
  int old_state;  // old state, used to detect state changes and reset timer
  WORD state_timer;  // our state_timer, incr. every time in port_poll
  WORD Status;  // misc. bit flags
  int last_round_robin;  // used to cycle service of ports evenly
  ULONG code_cnt;        // used to upload code(marks position in upload data)
  WORD code_state;       // 1=signals port poll code to send next chunk
  WORD reload_errors;    // count of ialive failures
  WORD timer_base;       // used to time port_state_handler
  WORD total_loads;		// statistics
  WORD good_loads;      // statistics
  WORD ownership_timer;  // check timer due to hosed up ownership logic
} PortMan;  // port manager

// values for Status(PortMan)
#define S_SERVER           0x0001
#define S_CHECK_LINK       0x0002
#define S_NEED_CODE_UPDATE 0x0800

void port_state_handler(PortMan *pm);
int port_set_new_mac_addr(PortMan *pm, BYTE *box_addr);

int portman_init(Hdlc *hd,
                 PortMan *pm,
                 int num_ports,
                 int unique_id,
                 int backup_server, 
                 int backup_timer,
                 BYTE *box_addr);
int port_init(SerPort *sp);
int port_close(SerPort *sp);
int port_poll(PortMan *pm);
void port_debug_scr(PortMan *pm, char *outbuf);
int portman_close(PortMan *pm);

void PortFlushTx(SerPort *p);
void PortFlushRx(SerPort *p);

int PortSetBaudRate(SerPort *p,
                    ULONG desired_baud,
                    USHORT SetHardware,
                    DWORD  clock_freq,
                    DWORD  clk_prescaler);

WORD PortGetTxCntRemote(SerPort *p);

#define PortGetTxCnt(p) (q_count(&p->QOut))
// int PortGetTxCnt(SerPort *p)
// { return q_count(&p->QOut); }
#define PortGetTxRoom(p) (q_room(&p->QOut))

#define PortGetRxCnt(p) (q_count(&p->QIn))
//  return q_count(&p->QIn);

#define pIsTxFlowedOff(p) ((p)->msr_value & MSR_TX_FLOWED_OFF)

#define pEnLocalLoopback(p) \
    { (p)->mcr_value |= MCR_LOOP_SET_MASK; }

#define pDisLocalLoopback(p) \
    { (p)->mcr_value &= ~MCR_LOOP_SET_MASK; }

#define pSetBreak(p) \
    { (p)->mcr_value |= MCR_BREAK_SET_ON; }

#define pClrBreak(p) \
    { (p)->mcr_value &= ~MCR_BREAK_SET_ON; }

#define pSetDTR(p) \
  {(p)->mcr_value |= MCR_DTR_SET_ON;}

#define pClrDTR(p) \
  {(p)->mcr_value &= ~MCR_DTR_SET_ON;}
   
#define pSetRTS(p) \
  {(p)->mcr_value |= MCR_RTS_SET_ON;}

#define pClrRTS(p) \
  {(p)->mcr_value &= ~MCR_RTS_SET_ON;}
 
#define pEnRTSToggleLow(p) \
  { (p)->control_settings &= ~SC_FLOW_RTS_MASK; \
    (p)->control_settings |=  SC_FLOW_RTS_ARS485; }

#define pEnRTSToggleHigh(p) \
  { (p)->control_settings &= ~SC_FLOW_RTS_MASK; \
    (p)->control_settings |=  SC_FLOW_RTS_RS485; }

#define pEnDTRFlowCtl(p) \
  { (p)->control_settings &= ~SC_FLOW_DTR_AUTO; \
    (p)->control_settings |=  SC_FLOW_DTR_AUTO; }

#define pDisDTRFlowCtl(p) \
  { (p)->control_settings &= ~SC_FLOW_DTR_AUTO; }

#define pEnCDFlowCtl(p) \
  { (p)->control_settings |= SC_FLOW_CD_AUTO; }

#define pDisCDFlowCtl(p) \
  { (p)->control_settings &= ~SC_FLOW_CD_AUTO; }

#define pEnDSRFlowCtl(p) \
  { (p)->control_settings |= SC_FLOW_DSR_AUTO; }

#define pDisDSRFlowCtl(p) \
  { (p)->control_settings &= ~SC_FLOW_DSR_AUTO; }

#define pEnRTSFlowCtl(p) \
  { (p)->control_settings &= ~SC_FLOW_RTS_MASK; \
    (p)->control_settings |=  SC_FLOW_RTS_AUTO; \
    (p)->mcr_value |= MCR_RTS_SET_ON; }

#define pDisRTSFlowCtl(p) \
  { (p)->control_settings &= ~SC_FLOW_RTS_MASK; }

#define pDisRTSToggle(p) \
  { (p)->control_settings &= ~SC_FLOW_RTS_MASK; }

#define pEnCTSFlowCtl(p) \
  { (p)->control_settings |= SC_FLOW_CTS_AUTO; }

#define pDisCTSFlowCtl(p) \
  { (p)->control_settings &= ~SC_FLOW_CTS_AUTO; }

#define pEnNullStrip(p) \
  { (p)->control_settings |= SC_NULL_STRIP; }

#define pDisNullStrip(p) \
  { (p)->control_settings &= ~SC_NULL_STRIP; }

#define pSetXOFFChar(p,c) \
   { (p)->sp_chars.rx_xoff = (c); \
     (p)->sp_chars.tx_xoff = (c); \
     (p)->change_flags |= CHG_SP_CHARS; }

#define pSetXONChar(p,c) \
   { (p)->sp_chars.rx_xon = (c); \
     (p)->sp_chars.tx_xon = (c); \
     (p)->change_flags |= CHG_SP_CHARS; }

#define pSetTxXOFFChar(p,c) \
   { (p)->sp_chars.tx_xoff = (c); \
     (p)->change_flags |= CHG_SP_CHARS; }

#define pSetTxXONChar(p,c) \
   { (p)->sp_chars.tx_xon = (c); \
     (p)->change_flags |= CHG_SP_CHARS; }

#define pSetRxXOFFChar(p,c) \
   { (p)->sp_chars.rx_xoff = (c); \
     (p)->change_flags |= CHG_SP_CHARS; }

#define pSetRxXONChar(p,c) \
   { (p)->sp_chars.rx_xon = (c); \
     (p)->change_flags |= CHG_SP_CHARS; }

#define pSetErrorChar(p,c) \
   { (p)->sp_chars.error = (c); \
     (p)->change_flags |= CHG_SP_CHARS; }

#define pSetEventChar(p,c) \
   { (p)->sp_chars.event = (c); \
     (p)->change_flags |= CHG_SP_CHARS; }

#define pEnRxSoftFlowCtl(p) \
  { (p)->control_settings |= SC_FLOW_XON_RX_AUTO; }
  
#define pDisRxSoftFlowCtl(p) \
  { (p)->control_settings &= ~SC_FLOW_XON_RX_AUTO; }
 
#define pEnTxSoftFlowCtl(p) \
  { (p)->control_settings |= SC_FLOW_XON_TX_AUTO; }
  
#define pDisTxSoftFlowCtl(p) \
  { (p)->control_settings &= ~SC_FLOW_XON_TX_AUTO; }

#define pSetStop2(p) \
  { (p)->control_settings |= SC_STOPBITS_2; }

#define pSetStop1(p) \
  { (p)->control_settings &= ~SC_STOPBITS_2; }

#define pSetOddParity(p) \
  { (p)->control_settings &= ~SC_PARITY_MASK; \
    (p)->control_settings |=  SC_PARITY_ODD; }

#define pSetEvenParity(p) \
  { (p)->control_settings &= ~SC_PARITY_MASK; \
    (p)->control_settings |=  SC_PARITY_EVEN; }

#define pDisParity(p) \
  { (p)->control_settings &= ~SC_PARITY_MASK; }

#define pSetData8(p) \
  { (p)->control_settings &= ~SC_DATABITS_7; }

#define pSetData7(p) \
  { (p)->control_settings |= SC_DATABITS_7; }

//--- action_reg macros
#define pModemReset(p) \
  { (p)->action_reg |= ACT_MODEM_RESET; }

#define pFlushInput(p) \
  { (p)->action_reg |= ACT_FLUSH_INPUT; }

#define pFlushOutput(p) \
  { (p)->action_reg |= ACT_FLUSH_OUTPUT; }

#define pOverrideClearXoff(p) \
  { (p)->action_reg |= ACT_CLEAR_TX_XOFF; }

#define pOverrideSetXoff(p) \
  { (p)->action_reg |= ACT_SET_TX_XOFF; }


//------- questionable stuff, untidy, thrown in to make compile
//Status
/* Open type and TX and RX identifier flags (unsigned int) */
#define COM_OPEN     0x0001            /* device open */
#define COM_TX       0x0002            /* transmit */
#define COM_RX       0x0004            /* receive */

//Status
/* Flow control flags (unsigned int) */
#define COM_FLOW_NONE  0x0000
#define COM_FLOW_IS    0x0008          /* input software flow control */
#define COM_FLOW_IH    0x0010          /* input hardware flow control */
#define COM_FLOW_OS    0x0020          /* output software flow control */
#define COM_FLOW_OH    0x0040          /* output hardware flow control */
#define COM_FLOW_OXANY 0x0080          /* restart output on any Rx char */
#define COM_RXFLOW_ON  0x0100          /* Rx data flow is ON */
#define COM_TXFLOW_ON  0x0200          /* Tx data flow is ON */

//Status ... State flags
#define COM_REQUEST_BREAK 0x0400

/* Modem control flags (unsigned char) */
#define COM_MDM_RTS   0x02             /* request to send */
#define COM_MDM_DTR   0x04             /* data terminal ready */
#define COM_MDM_CD    CD_ACT           /* carrier detect (0x08) */
#define COM_MDM_DSR   DSR_ACT          /* data set ready (0x10) */
#define COM_MDM_CTS   CTS_ACT          /* clear to send (0x20) */

/* Stop bit flags (unsigned char) */
#define COM_STOPBIT_1  0x01            /* 1 stop bit */
#define COM_STOPBIT_2  0x02            /* 2 stop bits */

/* Data bit flags (unsigned char) */
#define COM_DATABIT_7  0x01            /* 7 data bits */
#define COM_DATABIT_8  0x02            /* 8 data bits */

/* Parity flags (unsigned char) */
#define COM_PAR_NONE   0x00            /* no parity */
#define COM_PAR_EVEN   0x02            /* even parity */
#define COM_PAR_ODD    0x01            /* odd parity */

/* Detection enable flags (unsigned int) */
#define COM_DEN_NONE     0         /* no event detection enabled */
#define COM_DEN_MDM      0x0001    /* enable modem control change detection */
#define COM_DEN_RDA      0x0002    /* enable Rx data available detection */

/*---- 20-2FH Direct - Channel Status Reg. */
#define CTS_ACT   0x20        /* CTS input asserted */
#define DSR_ACT   0x10        /* DSR input asserted */
#define CD_ACT    0x08        /* CD input asserted */
#define TXFIFOMT  0x04        /* Tx FIFO is empty */
#define TXSHRMT   0x02        /* Tx shift register is empty */
#define RDA       0x01        /* Rx data available */
#define DRAINED (TXFIFOMT | TXSHRMT)  /* indicates Tx is drained */
#define STATMODE  0x8000      /* status mode enable bit */
#define RXFOVERFL 0x2000      /* receive FIFO overflow */
#define RX2MATCH  0x1000      /* receive compare byte 2 match */
#define RX1MATCH  0x0800      /* receive compare byte 1 match */
#define RXBREAK   0x0400      /* received BREAK */
#define RXFRAME   0x0200      /* received framing error */
#define RXPARITY  0x0100      /* received parity error */
#define STATERROR (RXBREAK | RXFRAME | RXPARITY)

/* channel data register stat mode status byte (high byte of word read) */
#define STMBREAK   0x08        /* BREAK */
#define STMFRAME   0x04        /* framing error */
#define STMRCVROVR 0x02        /* receiver over run error */
#define STMPARITY  0x01        /* parity error */
#define STMERROR   (STMBREAK | STMFRAME | STMPARITY)
#define STMBREAKH   0x800      /* BREAK */
#define STMFRAMEH   0x400      /* framing error */
#define STMRCVROVRH 0x200      /* receiver over run error */
#define STMPARITYH  0x100      /* parity error */
#define STMERRORH   (STMBREAKH | STMFRAMEH | STMPARITYH)

#define CTS_ACT   0x20        /* CTS input asserted */
#define DSR_ACT   0x10        /* DSR input asserted */
#define CD_ACT    0x08        /* CD input asserted */
#define TXFIFOMT  0x04        /* Tx FIFO is empty */
#define TXSHRMT   0x02        /* Tx shift register is empty */
#define RDA       0x01        /* Rx data available */
#define DRAINED (TXFIFOMT | TXSHRMT)  /* indicates Tx is drained */

/* interrupt ID register */
#define RXF_TRIG  0x20        /* Rx FIFO trigger level interrupt */
#define TXFIFO_MT 0x10        /* Tx FIFO empty interrupt */
#define SRC_INT   0x08        /* special receive condition interrupt */
#define DELTA_CD  0x04        /* CD change interrupt */
#define DELTA_CTS 0x02        /* CTS change interrupt */
#define DELTA_DSR 0x01        /* DSR change interrupt */
//------- END questionable stuff, untidy, thrown in to make compile


#define DEF_VS_PRESCALER 0x14 /* div 5 prescale, max 460800 baud(NO 50baud!) */
#define DEF_VS_CLOCKRATE 36864000

#define DEF_RHUB_PRESCALER  0x14
#define DEF_RHUB_CLOCKRATE 18432000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\rocklog.h ===
//File Name: rocklog.mc
//Constant definitions for the I/O error code log values.

#ifndef _ROCKLOG_
#define _ROCKLOG_

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SERIAL_ERROR_CODE       0x6
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: SERIAL_RP_INIT_FAIL
//
// MessageText:
//
//  The RocketPort or RocketModem could not be initialized with the current settings.
//
#define SERIAL_RP_INIT_FAIL              ((NTSTATUS)0x80060001L)

//
// MessageId: SERIAL_RP_INIT_PASS
//
// MessageText:
//
//  The RocketPort/RocketModem driver has successfully initialized its hardware.
//
#define SERIAL_RP_INIT_PASS              ((NTSTATUS)0x40060002L)

//
// MessageId: SERIAL_NO_SYMLINK_CREATED
//
// MessageText:
//
//  Unable to create the symbolic link for %2.
//
#define SERIAL_NO_SYMLINK_CREATED        ((NTSTATUS)0x80060003L)

//
// MessageId: SERIAL_NO_DEVICE_MAP_CREATED
//
// MessageText:
//
//  Unable to create the device map entry for %2.
//
#define SERIAL_NO_DEVICE_MAP_CREATED     ((NTSTATUS)0x80060004L)

//
// MessageId: SERIAL_NO_DEVICE_MAP_DELETED
//
// MessageText:
//
//  Unable to delete the device map entry for %2.
//
#define SERIAL_NO_DEVICE_MAP_DELETED     ((NTSTATUS)0x80060005L)

//
// MessageId: SERIAL_UNREPORTED_IRQL_CONFLICT
//
// MessageText:
//
//  Another driver on the system, which did not report its resources, has already claimed interrupt %3 used by %2.
//
#define SERIAL_UNREPORTED_IRQL_CONFLICT  ((NTSTATUS)0xC0060006L)

//
// MessageId: SERIAL_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Not enough memory was available to allocate internal storage needed for %2.
//
#define SERIAL_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC0060007L)

//
// MessageId: SERIAL_NO_PARAMETERS_INFO
//
// MessageText:
//
//  No Parameters subkey was found for user defined data.
//
#define SERIAL_NO_PARAMETERS_INFO        ((NTSTATUS)0xC0060008L)

//
// MessageId: SERIAL_UNABLE_TO_ACCESS_CONFIG
//
// MessageText:
//
//  Specific user configuration data is unretrievable.
//
#define SERIAL_UNABLE_TO_ACCESS_CONFIG   ((NTSTATUS)0xC0060009L)

//
// MessageId: SERIAL_UNKNOWN_BUS
//
// MessageText:
//
//  The bus type for %2 is not recognizable.
//
#define SERIAL_UNKNOWN_BUS               ((NTSTATUS)0xC006000AL)

//
// MessageId: SERIAL_BUS_NOT_PRESENT
//
// MessageText:
//
//  The bus type for %2 is not available on this computer.
//
#define SERIAL_BUS_NOT_PRESENT           ((NTSTATUS)0xC006000BL)

//
// MessageId: SERIAL_INVALID_USER_CONFIG
//
// MessageText:
//
//  User configuration for parameter %2 must have %3.
//
#define SERIAL_INVALID_USER_CONFIG       ((NTSTATUS)0xC006000CL)

//
// MessageId: SERIAL_RP_RESOURCE_CONFLICT
//
// MessageText:
//
//  A resource conflict was detected, the RocketPort/RocketModem driver will not load.
//
#define SERIAL_RP_RESOURCE_CONFLICT      ((NTSTATUS)0xC006000DL)

//
// MessageId: SERIAL_RP_HARDWARE_FAIL
//
// MessageText:
//
//  The RocketPort/RocketModem driver could not initialize its hardware, the driver will not be loaded.
//
#define SERIAL_RP_HARDWARE_FAIL          ((NTSTATUS)0xC006000EL)

//
// MessageId: SERIAL_DEVICEOBJECT_FAILED
//
// MessageText:
//
//  The Device Object for the RocketPort or RocketModem could not be created, the driver will not load.
//
#define SERIAL_DEVICEOBJECT_FAILED       ((NTSTATUS)0xC006000FL)

//
// MessageId: SERIAL_CUSTOM_ERROR_MESSAGE
//
// MessageText:
//
//  %2
//
#define SERIAL_CUSTOM_ERROR_MESSAGE      ((NTSTATUS)0xC0060010L)

//
// MessageId: SERIAL_CUSTOM_INFO_MESSAGE
//
// MessageText:
//
//  %2
//
#define SERIAL_CUSTOM_INFO_MESSAGE       ((NTSTATUS)0x40060011L)

//
// MessageId: SERIAL_NT50_INIT_PASS
//
// MessageText:
//
//  The RocketPort/RocketModem driver has successfully installed.
//
#define SERIAL_NT50_INIT_PASS            ((NTSTATUS)0x40060012L)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\read.c ===
/*-------------------------------------------------------------------
| read.c -
1-22-99 - add missing IoReleaseCancelSpinLock(oldIrql) to CompleteRead().
  Error introduced after V3.23.  kpb
1-18-99 - adjust VS timeout settings., take out some old #ifdef's. kpb.
3-23-98 - adjust VS so we have minimum per-character timeout value to
  compensate for vs networking.
3-04-98 Beef up synch locks with isr service routine(blue-screens on MP systems). kpb.
3-04-98 Take out data move from inter-character timer processing - kpb.
 9-22-97 V1.16 - add check to avoid crash on modem detection.
Copyright 1993-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

// #define TIMEOUT_TRACING
// #define TESTING_READ 1

//--- local funcs
VOID SerialCancelCurrentRead(PDEVICE_OBJECT DeviceObject, PIRP Irp);

BOOLEAN SerialGrabReadFromIsr(PSERIAL_DEVICE_EXTENSION Extension);

/*************************************************************************
Routine Description:
    This is the dispatch routine for reading.  It validates the parameters
    for the read request and if all is ok then it places the request
    on the work queue.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request
Return Value:
    If the io is zero length then it will return STATUS_SUCCESS,
    otherwise this routine will return the status returned by
    the actual start read routine.
*************************************************************************/
NTSTATUS
SerialRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    NTSTATUS Status;
    BOOLEAN acceptingIRPs;

    acceptingIRPs = SerialIRPPrologue(extension);

   if (acceptingIRPs == FALSE) {
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
      SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
      return STATUS_NO_SUCH_DEVICE;
   };

   if (extension->DeviceType == DEV_BOARD)
   {
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
      SerialCompleteRequest (extension, Irp, IO_NO_INCREMENT);
      return STATUS_NOT_SUPPORTED;
   };

    ExtTrace1(extension,D_Ioctl,"Read Start Len:%d",
            IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length);

    if (extension->ErrorWord)
    {
      if (SerialCompleteIfError( DeviceObject, Irp ) != STATUS_SUCCESS)
      {
        ExtTrace(extension,D_Ioctl,"ErrSet!");
        return STATUS_CANCELLED;
      }
    }

    Irp->IoStatus.Information = 0L;

    // If this is a zero length read then we are already done.
    if (IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length)
    {
        // Put the read on the queue so that we can
        // process it when our previous reads are done.
        ++extension->rec_packets;
        Status = SerialStartOrQueue(
                   extension,
                   Irp,
                   &extension->ReadQueue,
                   &extension->CurrentReadIrp,
                   SerialStartRead
                   );
        if  (Status == STATUS_PENDING)
        {
          ExtTrace(extension,D_Ioctl, " ,PENDING");
        }
        else
        {
          ExtTrace1(extension,D_Ioctl,"Read Return Status:%d",Status);
        }

        return Status;
    }
    else
    {
        // Nothing to do, return success
        Irp->IoStatus.Status = STATUS_SUCCESS;
    
        SerialCompleteRequest(extension, Irp, 0);

        return STATUS_SUCCESS;
    }
}

/*************************************************************************
Routine Description:
    This routine is used to start off any read.  It initializes
    the Iostatus fields of the irp.  It will set up any timers
    that are used to control the read.  It will attempt to complete
    the read from data already in the interrupt buffer.  If the
    read can be completed quickly it will start off another if
    necessary.
Arguments:
    Extension - Simply a pointer to the serial device extension.
Return Value:
    This routine will return the status of the first read
    irp.  This is useful in that if we have a read that can
    complete right away (AND there had been nothing in the
    queue before it) the read could return SUCCESS and the
    application won't have to do a wait.
*************************************************************************/
NTSTATUS
SerialStartRead(
    IN PSERIAL_DEVICE_EXTENSION Extension
    )
{
    PIRP newIrp;
    KIRQL oldIrql;
    KIRQL controlIrql;

    BOOLEAN returnWithWhatsPresent;
    BOOLEAN os2ssreturn;
    BOOLEAN crunchDownToOne;
    BOOLEAN useTotalTimer;
    BOOLEAN useIntervalTimer;

    ULONG multiplierVal;
    ULONG constantVal;

    LARGE_INTEGER totalTime;

    SERIAL_TIMEOUTS timeoutsForIrp;

    BOOLEAN setFirstStatus = FALSE;
    NTSTATUS firstStatus;

    do
    {
            Extension->NumberNeededForRead =
                IoGetCurrentIrpStackLocation(Extension->CurrentReadIrp)
                    ->Parameters.Read.Length;

            // Calculate the timeout value needed for the
            // request.  Note that the values stored in the
            // timeout record are in milliseconds.

            useTotalTimer = FALSE;
            returnWithWhatsPresent = FALSE;
            os2ssreturn = FALSE;
            crunchDownToOne = FALSE;
            useIntervalTimer = FALSE;

            // Always initialize the timer objects so that the
            // completion code can tell when it attempts to
            // cancel the timers whether the timers had ever
            // been set.

            KeInitializeTimer(&Extension->ReadRequestTotalTimer);
            KeInitializeTimer(&Extension->ReadRequestIntervalTimer);

            // We get the *current* timeout values to use for timing
            // this read.

            KeAcquireSpinLock(&Extension->ControlLock, &controlIrql);

            timeoutsForIrp = Extension->Timeouts;

            KeReleaseSpinLock(&Extension->ControlLock, controlIrql);

            // Calculate the interval timeout for the read.

            if (timeoutsForIrp.ReadIntervalTimeout &&
                (timeoutsForIrp.ReadIntervalTimeout !=
                 MAXULONG))
            {
                useIntervalTimer = TRUE;
                Extension->IntervalTime.QuadPart =
                    UInt32x32To64(
                        timeoutsForIrp.ReadIntervalTimeout,
                        10000
                        );
#ifdef S_VS
                // if they are using a per-character timeout of less
                // than 100ms, then change it to 100ms due to possible
                // network latencies.
                if (Extension->IntervalTime.QuadPart < (10000 * 100))
                {
                  ExtTrace(Extension,D_Ioctl,"Adjust mintime");

                  Extension->IntervalTime.QuadPart = (10000 * 100);
                }
#endif

                if (Extension->IntervalTime.QuadPart >=
                    Extension->CutOverAmount.QuadPart) {

                    Extension->IntervalTimeToUse =
                        &Extension->LongIntervalAmount;

                } else {

                    Extension->IntervalTimeToUse =
                        &Extension->ShortIntervalAmount;

                }
            }

            if (timeoutsForIrp.ReadIntervalTimeout == MAXULONG)
            {
                // We need to do special return quickly stuff here.
                // 1) If both constant and multiplier are
                //    0 then we return immediately with whatever
                //    we've got, even if it was zero.
                // 2) If constant and multiplier are not MAXULONG
                //    then return immediately if any characters
                //    are present, but if nothing is there, then
                //    use the timeouts as specified.
                // 3) If multiplier is MAXULONG then do as in
                //    "2" but return when the first character
                //    arrives.

                if (!timeoutsForIrp.ReadTotalTimeoutConstant &&
                    !timeoutsForIrp.ReadTotalTimeoutMultiplier)
                {
                    returnWithWhatsPresent = TRUE;

                }
                else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                            &&
                           (timeoutsForIrp.ReadTotalTimeoutMultiplier
                            != MAXULONG))
               {

                    useTotalTimer = TRUE;
                    os2ssreturn = TRUE;
                    multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;

                }
                else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                            &&
                           (timeoutsForIrp.ReadTotalTimeoutMultiplier
                            == MAXULONG))
                {
                    useTotalTimer = TRUE;
                    os2ssreturn = TRUE;
                    crunchDownToOne = TRUE;
                    multiplierVal = 0;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;
                }
            }
            else
            {
                // If both the multiplier and the constant are
                // zero then don't do any total timeout processing.

                if (timeoutsForIrp.ReadTotalTimeoutMultiplier ||
                    timeoutsForIrp.ReadTotalTimeoutConstant) {

                    // We have some timer values to calculate.

                    useTotalTimer = TRUE;
                    multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;
                }
            }

            if (useTotalTimer)
            {
                totalTime.QuadPart = ((LONGLONG)(UInt32x32To64(
                                          Extension->NumberNeededForRead,
                                          multiplierVal
                                          )
                                          + constantVal))
                                      ;
#ifdef S_VS
                if (totalTime.QuadPart < 50)
                {
                  totalTime.QuadPart = 50;  // limit to a minimum of 50ms timeout
                }
#endif
                totalTime.QuadPart *= -10000;
            }


            // Move any data in the interrupt buffer to the user buffer.
            // Try to satisfy the current read irp.

            // Use spinlock so a purge will not cause problems.
            KeAcquireSpinLock(&Extension->ControlLock, &controlIrql);

            // Move the data from the host side buffer to the user buffer
            // This is the "first" move so assign CountOnLastRead

            Extension->CountOnLastRead = SerialGetCharsFromIntBuffer(Extension);

            // Init the timeout flag
            Extension->ReadByIsr = 0;

            // See if we have any cause to return immediately.
            if (returnWithWhatsPresent || (!Extension->NumberNeededForRead) ||
                (os2ssreturn && Extension->CurrentReadIrp->IoStatus.Information))
            {
                // We got all we needed for this read.

                KeReleaseSpinLock(&Extension->ControlLock, controlIrql);

#ifdef TRACE_PORT
    if (Extension->TraceOptions)
    {
      if (Extension->TraceOptions & 1)  // event tracing
      {
        ExtTrace1(Extension,D_Read,"Immed. Read Done, size:%d",
                 Extension->CurrentReadIrp->IoStatus.Information);

        // dump data into the trace buffer in a hex or ascii dump format
        TraceDump(Extension,
                  Extension->CurrentReadIrp->AssociatedIrp.SystemBuffer,
                  Extension->CurrentReadIrp->IoStatus.Information, 0);
      }
      else if (Extension->TraceOptions & 2)  // trace input data
      {
        TracePut(
                 Extension->CurrentReadIrp->AssociatedIrp.SystemBuffer,
                 Extension->CurrentReadIrp->IoStatus.Information);
      }
    }
#endif

                Extension->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;
                if (!setFirstStatus)
                {
                    firstStatus = STATUS_SUCCESS;
                    setFirstStatus = TRUE;
                }
            }
            else  // not return with what we have
            {
                MyKdPrint(D_Read,("Read Pending\n"))

                // The irp may go under control of the isr.
                // Initialize the reference count

                SERIAL_INIT_REFERENCE(Extension->CurrentReadIrp);

                IoAcquireCancelSpinLock(&oldIrql);

                // We need to see if this irp should be canceled.
                if (Extension->CurrentReadIrp->Cancel)
                {
                    IoReleaseCancelSpinLock(oldIrql);

                    KeReleaseSpinLock(&Extension->ControlLock, controlIrql);

                    Extension->CurrentReadIrp->IoStatus.Status =
                        STATUS_CANCELLED;

                    Extension->CurrentReadIrp->IoStatus.Information = 0;

                    if (!setFirstStatus)
                    {
                        firstStatus = STATUS_CANCELLED;
                        setFirstStatus = TRUE;
                    }

                }
                else
                {
                    // If we are supposed to crunch the read down to
                    // one character, then update the read length
                    // in the irp and truncate the number needed for
                    // read down to one. Note that if we are doing
                    // this crunching, then the information must be
                    // zero (or we would have completed above) and
                    // the number needed for the read must still be
                    // equal to the read length.
                    //

                    if (crunchDownToOne)
                    {
                        Extension->NumberNeededForRead = 1;

                        IoGetCurrentIrpStackLocation(
                            Extension->CurrentReadIrp
                            )->Parameters.Read.Length = 1;
                    }

                    // Is this irp complete?
                    if (Extension->NumberNeededForRead)
                    {
                        // The irp isn't complete, the ISR or timeout
                        // will start the completion routines and
                        // invoke this code again to finish.

                        // Total supervisory read time.
                        if (useTotalTimer)
                        {
                            SERIAL_SET_REFERENCE(
                                Extension->CurrentReadIrp,
                                SERIAL_REF_TOTAL_TIMER
                                );

                            // Start off the total timer
                            KeSetTimer(
                                &Extension->ReadRequestTotalTimer,
                                totalTime,
                                &Extension->TotalReadTimeoutDpc
                                );
                        }

   // Inter-character timer
                        if(useIntervalTimer)
                        {
                            SERIAL_SET_REFERENCE(
                                Extension->CurrentReadIrp,
                                SERIAL_REF_INT_TIMER
                                );

                            KeQuerySystemTime(
                                &Extension->LastReadTime
                                );

                            KeSetTimer(
                                &Extension->ReadRequestIntervalTimer,
                                *Extension->IntervalTimeToUse,
                                &Extension->IntervalReadTimeoutDpc
                                );
                        }

                        SERIAL_SET_REFERENCE(Extension->CurrentReadIrp,
                                             SERIAL_REF_CANCEL);

                        IoMarkIrpPending(Extension->CurrentReadIrp);
                        IoSetCancelRoutine(
                            Extension->CurrentReadIrp,
                            SerialCancelCurrentRead
                            );

                        SERIAL_SET_REFERENCE(Extension->CurrentReadIrp,
                                             SERIAL_REF_ISR);
                        // tell ISR to complete it.
                        Extension->ReadPending = TRUE;

                        IoReleaseCancelSpinLock(oldIrql);
                        KeReleaseSpinLock(&Extension->ControlLock, controlIrql);

                        if (!setFirstStatus)
                        {
                            firstStatus = STATUS_PENDING;
                        }

                        return firstStatus;

                    }
                    else
                    {

                        IoReleaseCancelSpinLock(oldIrql);
                        KeReleaseSpinLock(&Extension->ControlLock,controlIrql);
                        Extension->CurrentReadIrp->IoStatus.Status =
                            STATUS_SUCCESS;

                        if (!setFirstStatus) {

                            firstStatus = STATUS_SUCCESS;
                            setFirstStatus = TRUE;
                        }
                    }  // irp not complete
                }  // not canceled
            }  // not return with what we have

            // The current irp is complete, try to get another one.
            SerialGetNextIrp(
                &Extension->CurrentReadIrp,
                &Extension->ReadQueue,
                &newIrp,
                TRUE,
                Extension
                );

    } while (newIrp);

    return firstStatus;

}

/*------------------------------------------------------------------------
 trace_read_data - used to trace completion of read irp.
|------------------------------------------------------------------------*/
void trace_read_data(PSERIAL_DEVICE_EXTENSION extension)
{

  if (extension->TraceOptions & 1)  // event tracing
  {
    ExtTrace3(extension,D_Read,"Pend. Read Done, size:%d [%d %d]",
             extension->CurrentReadIrp->IoStatus.Information,
             extension->RxQ.QPut, extension->RxQ.QGet);

    // dump data into the trace buffer in a hex or ascii dump format
    TraceDump(extension,
              extension->CurrentReadIrp->AssociatedIrp.SystemBuffer,
              extension->CurrentReadIrp->IoStatus.Information, 0);
  }
  else if (extension->TraceOptions & 2)  // trace input data
  {
    TracePut(
             extension->CurrentReadIrp->AssociatedIrp.SystemBuffer,
             extension->CurrentReadIrp->IoStatus.Information);
  }
}

/***************************************************************************
Routine Description:
    This routine is merely used to complete any read that
    ended up being used by the Isr.  It assumes that the
    status and the information fields of the irp are already
    correctly filled in.
Arguments:
    Dpc - Not Used.
    DeferredContext - Really points to the device extension.
    SystemContext1 - Not Used.
    SystemContext2 - Not Used.
Return Value:
    None.
***************************************************************************/
VOID
SerialCompleteRead(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{
    PSERIAL_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

#ifdef TRACE_PORT
    if (extension->TraceOptions)
    {
      ExtTrace(extension,D_Read,"Read Complete");
      trace_read_data(extension);
    }
#endif

    IoAcquireCancelSpinLock(&oldIrql);

    // check that we haven't been canceled by a timeout
    // fix for the semaphores
    if (extension->CurrentReadIrp != NULL)
    {

      // Don't allow the ISR to complete this IRP
      extension->ReadPending = FALSE;

      // Indicate to the interval timer that the read has completed.
      // The interval timer dpc can be lurking in some DPC queue.
      extension->CountOnLastRead = SERIAL_COMPLETE_READ_COMPLETE;

    
      SerialTryToCompleteCurrent(
        extension,
        NULL,
        oldIrql,
        STATUS_SUCCESS,
        &extension->CurrentReadIrp,
        &extension->ReadQueue,
        &extension->ReadRequestIntervalTimer,
        &extension->ReadRequestTotalTimer,
        SerialStartRead,
        SerialGetNextIrp,
        SERIAL_REF_ISR
        );
    }
    else
    {
      IoReleaseCancelSpinLock(oldIrql);
    }
#ifdef TESTING_READ
        MyKdPrint(D_Read,("Complete Read!"))
#endif

}

/****************************************************************************
Routine Description:
    This routine is used to cancel the current read.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP to be canceled.
Return Value:
    None.
****************************************************************************/
VOID
SerialCancelCurrentRead(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;

    // Indicate to the interval timer that the read has encountered a cancel.
    // The interval timer dpc can be lurking in some DPC queue.
    extension->CountOnLastRead = SERIAL_COMPLETE_READ_CANCEL;
    extension->ReadPending = FALSE;
    SERIAL_CLEAR_REFERENCE(extension->CurrentReadIrp, SERIAL_REF_ISR);

    if (extension->TraceOptions)
    {
      ExtTrace(extension,D_Read,"Cancel Read");
      trace_read_data(extension);
    }

    SerialTryToCompleteCurrent(
        extension,
        SerialGrabReadFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &extension->CurrentReadIrp,
        &extension->ReadQueue,
        &extension->ReadRequestIntervalTimer,
        &extension->ReadRequestTotalTimer,
        SerialStartRead,
        SerialGetNextIrp,
        SERIAL_REF_CANCEL
        );
}

/*------------------------------------------------------------------
Routine Description:
    This routine is used to complete a read because its total
    timer has expired.
Arguments:
    Dpc - Not Used.
    DeferredContext - Really points to the device extension.
    SystemContext1 - Not Used.
    SystemContext2 - Not Used.
Return Value:
    None.
|------------------------------------------------------------------*/
VOID
SerialReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{
    PSERIAL_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

#ifdef TESTING_READ
    MyKdPrint(D_Read,("\n[Read Timeout!]\n"))
    MyKdPrint(D_Read,("Read Wanted, len:%ld \n", extension->debug_ul1))
    MyKdPrint(D_Read,("Read, Got:%ld, Immed:%d readpen:%d\n", 
        extension->CurrentReadIrp->IoStatus.Information,
        extension->debug_ul2,
        extension->ReadPending))
    MyKdPrint(D_Read,("Read Left, NNFR:%ld\n", extension->NumberNeededForRead))
    KdBreakPoint();
#endif

    if (extension->TraceOptions)
    {
      ExtTrace(extension,D_Read,"Rd-Total Timeout");
      trace_read_data(extension);
    }

    IoAcquireCancelSpinLock(&oldIrql);

    // Indicate to the interval timer that the read has completed
    // due to total timeout.
    // The interval timer dpc can be lurking in some DPC queue.
    extension->CountOnLastRead = SERIAL_COMPLETE_READ_TOTAL;

    SerialTryToCompleteCurrent(
        extension,
        SerialGrabReadFromIsr,
        oldIrql,
        STATUS_TIMEOUT,
        &extension->CurrentReadIrp,
        &extension->ReadQueue,
        &extension->ReadRequestIntervalTimer,
        &extension->ReadRequestTotalTimer,
        SerialStartRead,
        SerialGetNextIrp,
        SERIAL_REF_TOTAL_TIMER
        );
}

/*------------------------------------------------------------------
Routine Description:
    This routine is used timeout the request if the time between
    characters exceed the interval time.  A global is kept in
    the device extension that records the count of characters read
    the last the last time this routine was invoked (This dpc
    will resubmit the timer if the count has changed).  If the
    count has not changed then this routine will attempt to complete
    the irp.  Note the special case of the last count being zero.
    The timer isn't really in effect until the first character is read.
Arguments:
    Dpc - Not Used.
    DeferredContext - Really points to the device extension.
    SystemContext1 - Not Used.
    SystemContext2 - Not Used.
Return Value:
    None.
|------------------------------------------------------------------*/
VOID
SerialIntervalReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{
    PSERIAL_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;
#if 0
    KIRQL controlIrql;
#endif

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

#ifdef TIMEOUT_TRACING
    ExtTrace3(extension,D_Read,"RIT, amnt:%d [%d %d]",
             extension->CurrentReadIrp->IoStatus.Information,
             extension->RxQ.QPut, extension->RxQ.QGet);
#endif
    IoAcquireCancelSpinLock(&oldIrql);

    if (extension->CountOnLastRead == SERIAL_COMPLETE_READ_TOTAL)
    {
#ifdef TIMEOUT_TRACING
      if (extension->TraceOptions)
      {
        ExtTrace(extension,D_Read,"Interv. Complete Total");
        trace_read_data(extension);
      }
#endif

        // The total timer has fired, try to complete.
        SerialTryToCompleteCurrent(
            extension,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_TIMEOUT,
            &extension->CurrentReadIrp,
            &extension->ReadQueue,
            &extension->ReadRequestIntervalTimer,
            &extension->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp,
            SERIAL_REF_INT_TIMER
            );

    }
    else if (extension->CountOnLastRead == SERIAL_COMPLETE_READ_COMPLETE)
    {
        ExtTrace(extension,D_Read," Rd Timeout, Complete");
#ifdef TRACE_PORT
        if (extension->TraceOptions)
          { trace_read_data(extension); }
#endif
        // The regular completion routine has been called, try to complete.
        SerialTryToCompleteCurrent(
            extension,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_SUCCESS,
            &extension->CurrentReadIrp,
            &extension->ReadQueue,
            &extension->ReadRequestIntervalTimer,
            &extension->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp,
            SERIAL_REF_INT_TIMER
            );

    }
    else if (extension->CountOnLastRead == SERIAL_COMPLETE_READ_CANCEL)
    {
        ExtTrace(extension,D_Read,"Rd Timeout, Cancel");
#ifdef TRACE_PORT
        if (extension->TraceOptions)
          { trace_read_data(extension); }
#endif
        // The cancel read routine has been called, try to complete.
        SerialTryToCompleteCurrent(
            extension,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_CANCELLED,
            &extension->CurrentReadIrp,
            &extension->ReadQueue,
            &extension->ReadRequestIntervalTimer,
            &extension->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp,
            SERIAL_REF_INT_TIMER
            );

    }
    else if (extension->CountOnLastRead || extension->ReadByIsr)
    {
        //
 // Check on Interval Timeouts.
        //

        // As we come back to this routine we will compare the current time
        // to the "last" time.  If the difference is larger than the
        // interval requested by the user, time out the request.
        // If the ISR has read in any more characters, resubmit the timer.

        if(extension->ReadByIsr)
        {
           // Something was placed in the system side buffer by the ISR

           // Init for resubmitted timeout
           extension->ReadByIsr = 0;

#if 0

/*----------
  This is bad news, the ISR moves data from the que to the user IRP buffer,
  if we do it here we have a nasty time-consuming contention issue.
  There is no good reason to do the move here, take it out.
----------*/
           KeAcquireSpinLock(&extension->ControlLock,&controlIrql);

           // Move the chars to the user buffer
/*----------
isr code calls this routine also, the extension->ReadPending is the
mechanism to control access(Two SerialGetCharsFromIntBuffer() calls
 at same time.) kpb
----------*/
           extension->CountOnLastRead |=
              SerialGetCharsFromIntBuffer(extension);

           KeReleaseSpinLock(&extension->ControlLock,controlIrql);
 #endif
   
           // Save off the "last" time something was read.
           KeQuerySystemTime(
               &extension->LastReadTime
               );
#ifdef TRACE_TICK_DEBUG
           ExtTrace(extension,D_Read," Resubmit(new chars)");
#endif
   
           // Resubmit the timer
           KeSetTimer(
               &extension->ReadRequestIntervalTimer,
               *extension->IntervalTimeToUse,
               &extension->IntervalReadTimeoutDpc
               );

           IoReleaseCancelSpinLock(oldIrql);

           // Allow the ISR to complete this IRP
       }
       else
       {
           // The timer fired but nothing was in the interrupt buffer.
           // Characters have been read previously, so check time interval

           LARGE_INTEGER currentTime;

           KeQuerySystemTime(
               &currentTime
               );
            if ((currentTime.QuadPart - extension->LastReadTime.QuadPart) >=
                extension->IntervalTime.QuadPart)
           {
              ExtTrace(extension,D_Read,"RIT Timeout");
#ifdef TRACE_PORT
               if (extension->TraceOptions)
                 { trace_read_data(extension); }
#endif
               // No characters read in the interval time, kill this read.
               SerialTryToCompleteCurrent(
                   extension,
                   SerialGrabReadFromIsr,
                   oldIrql,
                   STATUS_TIMEOUT,
                   &extension->CurrentReadIrp,
                   &extension->ReadQueue,
                   &extension->ReadRequestIntervalTimer,
                   &extension->ReadRequestTotalTimer,
                   SerialStartRead,
                   SerialGetNextIrp,
                   SERIAL_REF_INT_TIMER
                   );
   
           }
           else
           {
#ifdef TRACE_TICK_DEBUG
               // The timer fired but the interval time has not
               // been exceeded, resubmit the timer
               ExtTrace(extension,D_Read," Resubmit");
#endif
               KeSetTimer(
                   &extension->ReadRequestIntervalTimer,
                   *extension->IntervalTimeToUse,
                   &extension->IntervalReadTimeoutDpc
                   );

               IoReleaseCancelSpinLock(oldIrql);

#ifdef TIMEOUT_TRACING
               ExtTrace(extension,D_Read," No data, Resubmit.");
#endif

               // Allow the ISR to complete this IRP
           }
       }
   }
   else
   {
      // No characters have been read yet, so just resubmit the timeout.

      KeSetTimer(
          &extension->ReadRequestIntervalTimer,
          *extension->IntervalTimeToUse,
          &extension->IntervalReadTimeoutDpc
          );

      IoReleaseCancelSpinLock(oldIrql);

#ifdef TIMEOUT_TRACING
      ExtTrace(extension,D_Read," No data A, Resubmit.");
#endif
   }
}

/*------------------------------------------------------------------
  SerialGrabReadFromIsr - Take back the read packet from the ISR by
   reseting ReadPending flag in extension.  Need to use a sync with
   isr/timer routine to avoid contention in multiprocessor environments.

   Called from sync routine or with timer spinlock held.

  App - Can set ReadPending to give read-irp handling to the ISR without
    syncing to ISR.
  ISR - Can reset ReadPending to give read-irp handling back to app-time.

  If App wants to grab control of read-irp handling back from ISR, then
  it must sync-up with the isr/timer routine which has control.
|-------------------------------------------------------------------*/
BOOLEAN SerialGrabReadFromIsr(PSERIAL_DEVICE_EXTENSION Extension)
{
  Extension->ReadPending = FALSE;
  SERIAL_CLEAR_REFERENCE(Extension->CurrentReadIrp, SERIAL_REF_ISR);
  return FALSE;
}

/*------------------------------------------------------------------
Routine Description:
    This routine is used to copy any characters out of the interrupt
    buffer into the users buffer.  It will be reading values that
    are updated with the ISR but this is safe since this value is
    only decremented by synchronization routines.
Arguments:
    Extension - A pointer to the device extension.
Return Value:
    The number of characters that were copied into the user
    buffer.
|-------------------------------------------------------------------*/
ULONG SerialGetCharsFromIntBuffer(PSERIAL_DEVICE_EXTENSION Extension)
{
   LONG RxCount;
   LONG WrapCount = 0L;

   // See how much data we have in RxBuf (host-side buffer)
   // RxCount signed here for buffer wrap testing
   RxCount = q_count(&Extension->RxQ);

   // Check for a zero count in RxBuf
   if (RxCount == 0)
      return 0L;

   // Send back only as much as the application asked for...
   // RxCount unsigned here (will always be positive at this point)
   if (Extension->NumberNeededForRead < (ULONG)RxCount)
      RxCount = Extension->NumberNeededForRead;

   // Check for a buffer wrap 
   WrapCount = q_room_get_till_wrap(&Extension->RxQ);
   if (RxCount > WrapCount)  // wrap is required
   {
      // RtlMoveMemory(
      memcpy(
         (PUCHAR)(Extension->CurrentReadIrp->AssociatedIrp.SystemBuffer) + 
         Extension->CurrentReadIrp->IoStatus.Information,
         Extension->RxQ.QBase + Extension->RxQ.QGet,
         WrapCount);

      // RtlMoveMemory(
      memcpy(
         (PUCHAR)(Extension->CurrentReadIrp->AssociatedIrp.SystemBuffer) + 
         Extension->CurrentReadIrp->IoStatus.Information + WrapCount,
         Extension->RxQ.QBase,
         RxCount - WrapCount);
   }
   else //--- single move ok
   {
      // RtlMoveMemory(
      memcpy(
         (PUCHAR)(Extension->CurrentReadIrp->AssociatedIrp.SystemBuffer) + 
         Extension->CurrentReadIrp->IoStatus.Information,
         Extension->RxQ.QBase + Extension->RxQ.QGet,
         RxCount);
   }
   // Update host side buffer ptrs
   Extension->RxQ.QGet = (Extension->RxQ.QGet + RxCount) % Extension->RxQ.QSize;
   Extension->CurrentReadIrp->IoStatus.Information += RxCount;
   Extension->NumberNeededForRead -= RxCount;

   return RxCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\rcktioct.h ===
// Following are private I/O control codes for the rocket port
#define IOCTL_RCKT_GET_STATS \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_CHECK \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x801,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_CLR_STATS \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x802,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_ISR_CNT \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x803,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_MONALL \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x804,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_RCKT_SET_LOOPBACK_ON \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x805,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_SET_LOOPBACK_OFF \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x806,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_RCKT_SET_TOGGLE_LOW \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x807,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_CLEAR_TOGGLE_LOW \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x808,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_RCKT_SET_MODEM_RESET_OLD \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x809,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_CLEAR_MODEM_RESET_OLD \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x80a,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_GET_RCKTMDM_INFO_OLD \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x80b,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_SEND_MODEM_ROW_OLD \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x80c,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_SET_MODEM_RESET \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x80d,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_CLEAR_MODEM_RESET \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x80e,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_SEND_MODEM_ROW \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x80f,METHOD_BUFFERED,FILE_ANY_ACCESS)


//----- following struct is for passing info back to a manager/debugger.
typedef struct {
  USHORT  struct_size;   // our struct size for version control
  USHORT  status;        // return status
  char  port_name[12]; // COM#
  ULONG handle;       // handle, alternate to port_name
  char  reserved[20]; // room for extra growth

  char data[1000];    // general data area
} Tracer;

typedef struct {
    LONG receiveFifo;
    LONG transmitFifo;
    LONG receiveBytes;
    LONG transmitBytes;
    LONG parityErrors;
    LONG framingErrors;
    LONG overrunSoftware;
    LONG overrunHardware;
} PortStats;

typedef struct {
    ULONG trace_info;
    ULONG int_counter;
    ULONG WriteDpc_counter;
    ULONG Timer_counter;
    ULONG Poll_counter;
} Global_Track;

// following is a structure for a port which the driver will return
// information on.  The driver will return this information for every
// port(assume ptr to an array of up to 128 port_mon_structs) in one
// call to the driver.  Will query driver every X seconds for this
// data to generate statistics on port.  The structure list is terminated
// by a structure with port_name[0] = 0.
typedef struct
{
  char  port_name[12];  // port name(0=end of port list),("."=not assigned)
  ULONG sent_bytes;     // total number of sent bytes
  ULONG rec_bytes;      // total number of receive bytes

  USHORT sent_packets;   // number of write() packets
  USHORT rec_packets;    // number of read() packets

  USHORT overrun_errors; // receive over-run errors
  USHORT framing_errors; // receive framing errors

  USHORT parity_errors;  // receive parity errors
  USHORT status_flags;   // opened/close, flow-ctrl, out/in pin signals, etc

  USHORT function_bits;  // bits set on to indicate function call
  USHORT spare1;         // some room for expansion(& stay on 4x boundary)
} PortMon;


typedef struct
{
  ULONG struct_type;
  ULONG struct_size;
  ULONG num_structs;
  ULONG var1;  // reserve
} PortMonBase;

typedef struct
{
  char  port_name[12];  // port name(0=end of port list),("."=not assigned)
} PortMonNames;


typedef struct
{
  ULONG sent_bytes;     // total number of sent bytes
  ULONG rec_bytes;      // total number of receive bytes

  USHORT sent_packets;   // number of write() packets
  USHORT rec_packets;    // number of read() packets

  USHORT overrun_errors; // receive over-run errors
  USHORT framing_errors; // receive framing errors

  USHORT parity_errors;  // receive parity errors
  USHORT status_flags;   // opened/close, flow-ctrl, out/in pin signals, etc
} PortMonStatus;


// following are structures that are used to query the driver for information
// about RocketModem boards installed in the system.  this information is
// primarily used by the user program used to manually reset the hardware on
// the newer generation RocketModem boards.  [jl] 980308
typedef struct
{
  ULONG num_rktmdm_ports;   // 0 if != rocketmodem, >0 = # ports (4 or 8)
  char port_names[8][16];   // array of port names assigned to this board
} RktBoardInfo;

typedef struct
{
  ULONG         struct_size;
  ULONG         rm_country_code; // RocketModem country code
  ULONG         rm_settle_time;  // RocketModem settle time
  RktBoardInfo  rm_board_cfg[4];
} RocketModemConfig;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\ssci.h ===
/*-------------------------------------------------------------------
  ssci.h - Whole slew of macros for talking to RocketPort hardware.
Copyright 1993-96 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
//#include "ntddk.h"
//#include <conio.h> i hate includes of includes

#define CHANPTR_T CHANNEL_T *
#define ULONGPTR_T unsigned long *
#define CTL_SIZE 4                  /* max number of controllers in system */

typedef PUCHAR BIOA_T;              /* byte I/O address */
typedef PUSHORT WIOA_T;             /* word I/O address */
typedef PULONG DWIOA_T;             /* double word I/O address */

#define _CDECL

#define TRUE 1
#define FALSE 0

#define MCODE1_SIZE 72              /* number of bytes in microcode array */
#define MCODE1REG_SIZE 52           /* number bytes in microcode reg array */
#define AIOP_CTL_SIZE 4             /* max number AIOPs per controller */
#define CHAN_AIOP_SIZE 8            /* max number channels per AIOP */
// #define NULLDEV -1                  /* identifies non-existant device */
// #define NULLCTL -1                  /* identifies non-existant controller */
// #define NULLCTLPTR (CONTROLLER_T *)0 /* identifies non-existant controller */
// #define NULLAIOP -1                 /* identifies non-existant AIOP */
// #define NULLCHAN -1                 /* identifies non-existant channel */
#define MAXTX_SIZE 250           /* max number of bytes allowed in Tx FIFO */

#define CHANINT_EN 0x0100           /* flags to enable/disable channel ints */

/*
	the revision field is used to extend	the PCI device identifications...
*/
#define	PCI_REVISION_RMODEM_SOC	0x00
#define	PCI_REVISION_RMODEM_II	0x01

/* Controller ID numbers */
// #define CTLID_NULL  -1              /* no controller exists */
#define CTLID_0001  0x0001          /* controller release 1 */

/* PCI Defines(have moved to opstr.h) */

/* AIOP ID numbers, identifies AIOP type implementing channel */
#define AIOPID_NULL -1              /* no AIOP or channel exists */
#define AIOPID_0001 0x0001          /* AIOP release 1 */

#define RX_HIWATER 512                 /* sw input flow ctl high water mark */
#define RX_LOWATER 256                 /* sw input flow ctl low water mark */

#define OFF      0
#define ON       1
#define NOCHANGE 2

/* Error flags for RocketPort */
#define ERR_PARITY 0x01          /* parity error */

//Status
/* Open type and TX and RX identifier flags (unsigned int) */
#define COM_OPEN     0x0001            /* device open */
#define COM_TX       0x0002            /* transmit */
#define COM_RX       0x0004            /* receive */

//Status
/* Flow control flags (unsigned int) */
#define COM_FLOW_NONE  0x0000
#define COM_FLOW_IS    0x0008          /* input software flow control */
#define COM_FLOW_IH    0x0010          /* input hardware flow control */
#define COM_FLOW_OS    0x0020          /* output software flow control */
#define COM_FLOW_OH    0x0040          /* output hardware flow control */
#define COM_FLOW_OXANY 0x0080          /* restart output on any Rx char */
#define COM_RXFLOW_ON  0x0100          /* Rx data flow is ON */
#define COM_TXFLOW_ON  0x0200          /* Tx data flow is ON */

//Status ... State flags
#define COM_REQUEST_BREAK 0x0400

/* Modem control flags (unsigned char) */
#define COM_MDM_RTS   0x02             /* request to send */
#define COM_MDM_DTR   0x04             /* data terminal ready */
#define COM_MDM_CD    CD_ACT           /* carrier detect (0x08) */
#define COM_MDM_DSR   DSR_ACT          /* data set ready (0x10) */
#define COM_MDM_CTS   CTS_ACT          /* clear to send (0x20) */

/* Stop bit flags (unsigned char) */
#define COM_STOPBIT_1  0x01            /* 1 stop bit */
#define COM_STOPBIT_2  0x02            /* 2 stop bits */

/* Data bit flags (unsigned char) */
#define COM_DATABIT_7  0x01            /* 7 data bits */
#define COM_DATABIT_8  0x02            /* 8 data bits */

/* Parity flags (unsigned char) */
#define COM_PAR_NONE   0x00            /* no parity */
#define COM_PAR_EVEN   0x02            /* even parity */
#define COM_PAR_ODD    0x01            /* odd parity */

/* Detection enable flags (unsigned int) */
#define COM_DEN_NONE     0         /* no event detection enabled */
#define COM_DEN_MDM      0x0001    /* enable modem control change detection */
#define COM_DEN_RDA      0x0002    /* enable Rx data available detection */

// Driver controller information
#define DEV_SIZE 128                 /* maximum number devices */
#define SPANOFMUDBAC             0x04        // 4 bytes    
#define SPANOFAIOP               0x40        // 64 bytes

#ifdef COMMENT_OUT
/* Configuration information for all controllers */
typedef struct
{
   int Irq;                            /* IRQ number */
   int NumCtl;                         /* number of controllers in system */
//   int NumDev;                         /* number of devices in the system */
//   int InterruptingCtl;                /* indicates the ctl that interrupts */
   int FirstISA;                       /* first isa so know where to start mudbacks */
   CFCTL_T CfCtl[CTL_SIZE];
} CF_T;
#endif

/* Controller level information structure */
/* The interrupt strobe bit of MUDBAC register 2 is never stored in Reg2
   because it is write only */
typedef struct
{
   int CtlID;                       /* controller ID */
   //int CtlNum;                      /* controller number */
   INTERFACE_TYPE BusType;          /* PCIBus or Isa  */
   unsigned char PCI_Slot;
   unsigned char BusNumber;
   USHORT PCI1;
   WIOA_T PCI1IO;                   /* I/O address for Pci register */
   BIOA_T MBaseIO;                  /* I/O address for MUDBAC */
   BIOA_T MReg1IO;                  /* I/O address for MUDBAC register 1 */
   BIOA_T MReg2IO;                  /* I/O address for MUDBAC register 2 */
   BIOA_T MReg3IO;                  /* I/O address for MUDBAC register 3 */
   unsigned char MReg2;             /* copy of MUDBAC register 2 */
   unsigned char MReg3;             /* copy of MUDBAC register 3 */
   int NumAiop;                     /* number of AIOPs on the controller */
   WIOA_T AiopIO[AIOP_CTL_SIZE];    /* AIOP's base I/O address */
   BIOA_T AiopIntChanIO[AIOP_CTL_SIZE]; /* AIOP's Int Chan Reg I/O add */
   int AiopID[AIOP_CTL_SIZE];       /* AIOP ID, or -1 if no AIOP exists */
   int AiopNumChan[AIOP_CTL_SIZE];  /* number of channels in AIOP */

   BYTE PortsPerAiop;   // normally 8, but rplus this is 4
   BYTE ClkPrescaler;
   ULONG ClkRate;
   int PCI_DevID;
   int PCI_RevID;		// due to odd PCI controller design, must use RevID to extend device IDs...
   int PCI_SVID;
   int PCI_SID;

} CONTROLLER_T;


/* Channel level information structure */
typedef struct
{
   /* Channel, AIOP, and controller identifiers */
   CONTROLLER_T *CtlP;          /* ptr to controller information structure */
   int AiopNum;                 /* AIOP number on the controller */
   int  ChanID;                 /* channel ID - indentifies type of AIOP */
   int ChanNum;                 /* channel within AIOP */

   /* Maximum number bytes allowed in Tx FIFO */
   int TxSize;

   /* AIOP's global direct register addresses */
   BIOA_T  Cmd;                  /* AIOP's Command register */
   BIOA_T  IntChan;              /* AIOP's Interrupt channel register */
   BIOA_T  IntMask;              /* AIOP's Interrupt mask register */
   DWIOA_T  IndexAddr;           /* AIOP's Index Register */
   WIOA_T  IndexData;            /* AIOP's Index Register Data */

   /* Channel's direct register addresses */
   WIOA_T  TxRxData;             /* Transmit and Receive register address */
   WIOA_T  ChanStat;             /* Channel Status register address */
   WIOA_T  TxRxCount;            /* Tx and Rx FIFO count register address */
   BIOA_T  IntID;                /* Interrupt ID register address */

   /* Channel indirect register addresses */
   unsigned int TxFIFO;         /* transmit FIFO */
   unsigned int TxFIFOPtrs;     /* transmit FIFO out and in ptrs */
   unsigned int RxFIFO;         /* receive FIFO */
   unsigned int RxFIFOPtrs;     /* receive FIFO out and in ptrs */
   unsigned int TxPrioCnt;      /* transmit priority count */
   unsigned int TxPrioPtr;      /* transmit priority ptr */
   unsigned int TxPrioBuf;      /* transmit priority buffer */

   /* Copy of channel's microcode */
   unsigned char MCode[MCODE1REG_SIZE]; /* channel's microcode registers */

   /* Control register save values */
   unsigned char BaudDiv[4];       /* baud rate divisor for channel */
   unsigned char TxControl[4];     /* transmit control register vals */
   unsigned char RxControl[4];     /* receive control register vals */
   unsigned char TxEnables[4];     /* transmit processor enable vals */
   unsigned char TxCompare[4];     /* transmit compare values 1 & 2 */
   unsigned char TxReplace1[4];    /* transmit replace value 1 - bytes 1 & 2 */
   unsigned char TxReplace2[4];    /* transmit replace value 2 */
} CHANNEL_T;

//--------------------------- Function prototypes
int sInitController(CONTROLLER_T *CtlP,
                    //int CtlNum,
                    BIOA_T MudbacIO,
                    BIOA_T *AiopIOList,
                    unsigned int *PhyAiopIOList,
                    int AiopIOListSize,
                    int IRQNum,
                    unsigned char Frequency,
                    int PeriodicOnly,
                    int BusType,
                    int prescaler);
int _CDECL sReadAiopID(BIOA_T io);
int _CDECL sReadAiopNumChan(WIOA_T io);
int _CDECL sInitChan(CONTROLLER_T *CtlP,
                     CHANPTR_T ChP,
                     int AiopNum,
                     int ChanNum);
unsigned char _CDECL sGetRxErrStatus(CHANPTR_T ChP);
void _CDECL sSetParity(CHANPTR_T ChP,int Parity);
void _CDECL sStopRxProcessor(CHANPTR_T ChP);
void _CDECL sStopSWInFlowCtl(CHANPTR_T ChP);
void _CDECL sFlushRxFIFO(CHANPTR_T ChP);
void _CDECL sFlushTxFIFO(CHANPTR_T ChP);
int _CDECL sFlushTxPriorityBuf(CHANPTR_T ChP,unsigned char *Data);
unsigned char _CDECL sGetTxPriorityCnt(CHANPTR_T ChP);
int _CDECL sReadRxBlk(CHANPTR_T ChP,unsigned char *Buffer,int Count);
ULONG _CDECL sWriteTxBlk(CHANPTR_T ChP,PUCHAR Buffer,ULONG Count);
int _CDECL sWriteTxPrioBlk(CHANPTR_T ChP,unsigned char *Buffer,int Count);
int _CDECL sWriteTxPrioByte(CHANPTR_T ChP,unsigned char Data);
void _CDECL sEnInterrupts(CHANPTR_T ChP,unsigned int Flags);
void _CDECL sDisInterrupts(CHANPTR_T ChP,unsigned int Flags);
void _CDECL sReadMicrocode(CHANPTR_T ChP,char *Buffer,int Count);
int sSetBaudRate(CHANNEL_T *ChP,
                 ULONG desired_baud,
                 USHORT SetHardware);
void sChanOutWI(CHANNEL_T *ChP, USHORT RegNum, ULONG  val);
void sModemReset(CHANNEL_T *ChP, int on);
void sModemWriteROW(CHANNEL_T *ChP, USHORT CountryCode);
void sModemWriteDelay(CHANNEL_T *ChP,char *string, int length);
void sModemWrite(CHANNEL_T *ChP,char *string,int length);
void sModemSpeakerEnable(CHANNEL_T *ChP);
int  sModemRead(CHANNEL_T *ChP,char *string,int length,int poll_retries);
int  sModemReadChoice(CHANNEL_T *ChP,char *string0,int length0,char *string1,int length1,int poll_retries);
int  sTxFIFOReady(CHANNEL_T *ChP);
int  sTxFIFOStatus(CHANNEL_T *ChP);
int  sRxFIFOReady(CHANNEL_T *ChP);


/*-------------------------------------------------------------------
Function: sClrBreak
Purpose:  Stop sending a transmit BREAK signal
Call:     sClrBreak(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sClrBreak(CHP) \
{ \
   (CHP)->TxControl[3] &= ~SETBREAK; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sClrDTR
Purpose:  Clr the DTR output
Call:     sClrDTR(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sClrDTR(CHP) \
{ \
   (CHP)->TxControl[3] &= ~SET_DTR; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sClrNextInBitMap
Purpose:  Clear the bit within a bit map of the next number needing service.
Call:     sGetNextInBitMap(BitMap,Number)
          unsigned char BitMap; The bit map.  Since this is a macro, the
                   variable holding the bit map can be passed directly, rather
                   than a pointer to the variable.
          int Number; Next number needing service.  This is the same number
                      returned from the preceeding call to sGetNextInBitMap().
Return:   void
Comments: This function should be called immediately after calling
          sGetNextInBitMap().

---------------------------------------------------------------------*/
//#define sClrNextInBitMap(BITMAP,NUMBER) (BITMAP) &= sBitMapClrTbl[NUMBER]

/*-------------------------------------------------------------------
Function: sClrRTS
Purpose:  Clr the RTS output
Call:     sClrRTS(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sClrRTS(CHP) \
{ \
   (CHP)->TxControl[3] &= ~SET_RTS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sClrTxXOFF
Purpose:  Clear any existing transmit software flow control off condition
Call:     sClrTxXOFF(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sClrTxXOFF(CHP) \
{ \
   sOutB((PUCHAR)(CHP)->Cmd,(unsigned char)(TXOVERIDE | (CHP)->ChanNum)); \
   sOutB((PUCHAR)(CHP)->Cmd,(unsigned char)(CHP)->ChanNum); \
}

/*-------------------------------------------------------------------
Function: sPCIControllerEOI
Purpose:  Strobe the PCI End Of Interrupt bit.
Call:     sPCIControllerEOI(CtlP)
          CONTROLLER_T *CtlP; Ptr to controller structure
Return:   void
---------------------------------------------------------------------*/
//#define sPCIControllerEOI(CTLP) sOutB(((BIOA_T)(CTLP)->AiopIO[0]+_PCI_INT_FUNC),(unsigned char)(PCI_STROBE));
#define sPCIControllerEOI(CTLP) sOutW((CTLP)->PCI1IO, \
                                      (USHORT)((CTLP)->PCI1 | PCI_STROBE))

/*-------------------------------------------------------------------
Function: sControllerEOI
Purpose:  Strobe the MUDBAC's End Of Interrupt bit.
Call:     sControllerEOI(CtlP)
          CONTROLLER_T *CtlP; Ptr to controller structure
Return:   void
---------------------------------------------------------------------*/
#define sControllerEOI(CTLP) sOutB((PUCHAR)(CTLP)->MReg2IO,(unsigned char)((CTLP)->MReg2 | INT_STROB))

/*-------------------------------------------------------------------
Function: sDisAiop
Purpose:  Disable I/O access to an AIOP
Call:     sDisAiop(CltP)
          CONTROLLER_T *CtlP; Ptr to controller structure
          int AiopNum; Number of AIOP on controller
Return:   void
---------------------------------------------------------------------*/
#define sDisAiop(CTLP,AIOPNUM) \
{ \
   (CTLP)->MReg3 &= (~(1 << (AIOPNUM))); \
   sOutB((CTLP)->MReg3IO,(CTLP)->MReg3); \
}

/*-------------------------------------------------------------------
Function: sDisCTSFlowCtl
Purpose:  Disable output flow control using CTS
Call:     sDisCTSFlowCtl(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sDisCTSFlowCtl(CHP) \
{ \
   (CHP)->TxControl[2] &= ~CTSFC_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sDisGlobalInt
Purpose:  Disable global interrupts for a controller
Call:     sDisGlobalInt(CtlP)
          CONTROLLER_T *CtlP; Ptr to controller structure
Return:   void
---------------------------------------------------------------------*/
#define sDisGlobalInt(CTLP) \
{ \
   (CTLP)->MReg2 &= ~INTR_EN; \
   sOutB((CTLP)->MReg2IO,(CTLP)->MReg2); \
}

/*-------------------------------------------------------------------
Function: sDisIXANY
Purpose:  Disable IXANY Software Flow Control
Call:     sDisIXANY(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sDisIXANY(CHP) \
{ \
   (CHP)->MCode[IXANY_DATA] = IXANY_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IXANY_OUT]); \
}

/*-------------------------------------------------------------------
Function: sDisLocalLoopback
Purpose:  Disable local loopback of transmit to receive
Call:     sDisLocalLoopback(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sDisLocalLoopback(CHP) \
{ \
   (CHP)->TxControl[3] &= ~LOCALLOOP; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: DisParity
Purpose:  Disable parity
Call:     sDisParity(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: Function sSetParity() can be used in place of functions sEnParity(),
          sDisParity(), sSetOddParity(), and sSetEvenParity().
---------------------------------------------------------------------*/
#define sDisParity(CHP) \
{ \
   (CHP)->TxControl[2] &= ~PARITY_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sDisRTSFlowCtl
Purpose:  Disable input flow control using RTS
Call:     sDisRTSFlowCtl(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sDisRTSFlowCtl(CHP) \
{ \
   (CHP)->RxControl[2] &= ~RTSFC_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->RxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sDisRTSToggle
Purpose:  Disable RTS toggle
Call:     sDisRTSToggle(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sDisRTSToggle(CHP) \
{ \
   (CHP)->TxControl[2] &= ~RTSTOG_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sDisRxCompare1
Purpose:  Disable Rx compare byte 1
Call:     sDisRxCompare1(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: This function is used to disable Rx replace 1, Rx ignore 1,
          and Rx compare and interrupt 1.
---------------------------------------------------------------------*/
#define sDisRxCompare1(CHP) \
{ \
   (CHP)->MCode[RXCMP1_DATA] = RXCMP1_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMP1_OUT]); \
   (CHP)->MCode[IGREP1_DATA] = IG_REP1_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGREP1_OUT]); \
   (CHP)->MCode[INTCMP1_DATA] = INTCMP1_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[INTCMP1_OUT]); \
}

/*-------------------------------------------------------------------
Function: sDisRxCompare0
Purpose:  Disable Rx compare byte 0
Call:     sDisRxCompare0(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: This function is used to disable Rx ignore 0,
---------------------------------------------------------------------*/
#define sDisRxCompare0(CHP) \
{ \
   (CHP)->MCode[IGNORE0_DATA] = IGNORE0_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGNORE0_OUT]); \
}

/*-------------------------------------------------------------------
Function: sDisRxCompare2
Purpose:  Disable Rx compare byte 2
Call:     sDisRxCompare2(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: This function is used to disable Rx replace 2, Rx ignore 2,
          and Rx compare and interrupt 2.
---------------------------------------------------------------------*/
#define sDisRxCompare2(CHP) \
{ \
   (CHP)->MCode[RXCMP2_DATA] = RXCMP2_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMP2_OUT]); \
   (CHP)->MCode[IGREP2_DATA] = IG_REP2_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGREP2_OUT]); \
   (CHP)->MCode[INTCMP2_DATA] = INTCMP2_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[INTCMP2_OUT]); \
}

/*-------------------------------------------------------------------
Function: sDisRxFIFO
Purpose:  Disable Rx FIFO
Call:     sDisRxFIFO(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sDisRxFIFO(CHP) \
{ \
   (CHP)->MCode[RXFIFO_DATA] = RXFIFO_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXFIFO_OUT]); \
}

/*-------------------------------------------------------------------
Function: sDisRxStatusMode
Purpose:  Disable the Rx status mode
Call:     sDisRxStatusMode(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: This takes the channel out of the receive status mode.  All
          subsequent reads of receive data using sReadRxWord() will return
          two data bytes.
---------------------------------------------------------------------*/
#define sDisRxStatusMode(CHP) sOutW((CHP)->ChanStat,0)

/*-------------------------------------------------------------------
Function: sDisTransmit
Purpose:  Disable transmit
Call:     sDisTransmit(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
          This disables movement of Tx data from the Tx FIFO into the 1 byte
          Tx buffer.  Therefore there could be up to a 2 byte latency
          between the time sDisTransmit() is called and the transmit buffer
          and transmit shift register going completely empty.
---------------------------------------------------------------------*/
#define sDisTransmit(CHP) \
{ \
   (CHP)->TxControl[3] &= ~TX_ENABLE; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sDisTxCompare1
Purpose:  Disable Tx compare byte 1
Call:     sDisTxCompare1(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: This function is used to disable Tx replace 1 with 1, Tx replace
          1 with 2, and Tx ignore 1.
---------------------------------------------------------------------*/
#define sDisTxCompare1(CHP) \
{ \
   (CHP)->TxEnables[2] &= ~COMP1_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxEnables[0]); \
}

/*-------------------------------------------------------------------
Function: sDisTxCompare2
Purpose:  Disable Tx compare byte 2
Call:     sDisTxCompare2(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: This function is used to disable Tx replace 2 with 1 and Tx ignore 2.
---------------------------------------------------------------------*/
#define sDisTxCompare2(CHP) \
{ \
   (CHP)->TxEnables[2] &= ~COMP2_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxEnables[0]); \
}

/*-------------------------------------------------------------------
Function: sDisTxSoftFlowCtl
Purpose:  Disable Tx Software Flow Control
Call:     sDisTxSoftFlowCtl(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sDisTxSoftFlowCtl(CHP) \
{ \
   (CHP)->MCode[TXSWFC_DATA] = TXSWFC_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[TXSWFC_OUT]); \
}

/*-------------------------------------------------------------------
Function: sEnAiop
Purpose:  Enable I/O access to an AIOP
Call:     sEnAiop(CltP)
          CONTROLLER_T *CtlP; Ptr to controller structure
          int AiopNum; Number of AIOP on controller
Return:   void
---------------------------------------------------------------------*/
#define sEnAiop(CTLP,AIOPNUM) \
{ \
   (CTLP)->MReg3 |= (1 << (AIOPNUM)); \
   sOutB((CTLP)->MReg3IO,(CTLP)->MReg3); \
}

/*-------------------------------------------------------------------
Function: sEnCTSFlowCtl
Purpose:  Enable output flow control using CTS
Call:     sEnCTSFlowCtl(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sEnCTSFlowCtl(CHP) \
{ \
   (CHP)->TxControl[2] |= CTSFC_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
 sIsCTSFlowCtlEnabled(CHP) -
|---------------------------------------------------------------------*/
#define sIsCTSFlowCtlEnabled(CHP) \
  { ((CHP)->TxControl[2] & CTSFC_EN) }

/*-------------------------------------------------------------------
Function: sDisGlobalIntPCI
Purpose:  Disable global interrupts for a controller
Call:     sDisGlobalIntPCI(CtlP)
          CONTROLLER_T *CtlP; Ptr to controller structure
Return:   void
---------------------------------------------------------------------*/
#define sDisGlobalIntPCI(CTLP) \
{ \
   (CTLP)->PCI1 &= ~INTR_EN_PCI; \
   sOutW((WIOA_T)CtlP->PCI1IO,(USHORT)CtlP->PCI1); \
}

/*-------------------------------------------------------------------
Function: sEnGlobalIntPCI
Purpose:  Enable global interrupts for a controller
Call:     sEnGlobalInt(CtlP)
          CONTROLLER_T *CtlP; Ptr to controller structure
Return:   void
---------------------------------------------------------------------*/
#define sEnGlobalIntPCI(CTLP) \
{ \
   (CTLP)->PCI1 |= INTR_EN_PCI; \
   sOutW(CtlP->PCI1IO,(USHORT)CtlP->PCI1); \
}

/*-------------------------------------------------------------------
Function: sEnGlobalInt
Purpose:  Enable global interrupts for a controller
Call:     sEnGlobalInt(CtlP)
          CONTROLLER_T *CtlP; Ptr to controller structure
Return:   void
---------------------------------------------------------------------*/
#define sEnGlobalInt(CTLP) \
{ \
   (CTLP)->MReg2 |= INTR_EN; \
   sOutB((CTLP)->MReg2IO,(CTLP)->MReg2); \
}

/*-------------------------------------------------------------------
Function: sEnIXANY
Purpose:  Enable IXANY Software Flow Control
Call:     sEnIXANY(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sEnIXANY(CHP) \
{ \
   (CHP)->MCode[IXANY_DATA] = IXANY_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IXANY_OUT]); \
}

/*-------------------------------------------------------------------
Function: sEnLocalLoopback
Purpose:  Enable local loopback of transmit to receive
Call:     sEnLocalLoopback(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sEnLocalLoopback(CHP) \
{ \
   (CHP)->TxControl[3] |= LOCALLOOP; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: EnParity
Purpose:  Enable parity
Call:     sEnParity(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: Function sSetParity() can be used in place of functions sEnParity(),
          sDisParity(), sSetOddParity(), and sSetEvenParity().

Warnings: Before enabling parity odd or even parity should be chosen using
          functions sSetOddParity() or sSetEvenParity().
---------------------------------------------------------------------*/
#define sEnParity(CHP) \
{ \
   (CHP)->TxControl[2] |= PARITY_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sEnRTSFlowCtl
Purpose:  Enable input flow control using RTS
Call:     sEnRTSFlowCtl(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Warnings: RTS toggle and the RTS output will be both be cleared by this
          function.  The original state of RTS toggle and RTS output will
          not be preserved after a subsequent call to sDisRTSFlowCtl().
---------------------------------------------------------------------*/
#define sEnRTSFlowCtl(CHP) \
{ \
   (CHP)->TxControl[2] &= ~RTSTOG_EN; \
   (CHP)->TxControl[3] &= ~SET_RTS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
   (CHP)->RxControl[2] |= RTSFC_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->RxControl[0]); \
}

/*-------------------------------------------------------------------
 sIsRTSFlowCtlEnabled
---------------------------------------------------------------------*/
#define sIsRTSFlowCtlEnabled(CHP) \
   { ((CHP)->TxControl[2] & RTSTOG_EN) }

/*-------------------------------------------------------------------
Function: sEnRTSToggle
Purpose:  Enable RTS toggle
Call:     sEnRTSToggle(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: This function will disable RTS flow control and clear the RTS
          line to allow operation of RTS toggle.
---------------------------------------------------------------------*/
#define sEnRTSToggle(CHP) \
{ \
   (CHP)->RxControl[2] &= ~RTSFC_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->RxControl[0]); \
   (CHP)->TxControl[2] |= RTSTOG_EN; \
   (CHP)->TxControl[3] &= ~SET_RTS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sEnRxFIFO
Purpose:  Enable Rx FIFO
Call:     sEnRxFIFO(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sEnRxFIFO(CHP) \
{ \
   (CHP)->MCode[RXFIFO_DATA] = RXFIFO_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXFIFO_OUT]); \
}

/*-------------------------------------------------------------------
Function: sEnRxIgnore0
Purpose:  Enable compare of Rx data with compare byte #1 and ignore (discard)
          that byte if a match is found.
Call:     sEnRxIgnore0(ChP,CmpByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Rx data byte with
Return:   void
Comments: This function enables comparison of the receive data byte
          with CmpByte.  The comparison is done after the receive data
          byte has been masked (see sSetRxMask()).  If a match is found the
          receive data byte is ignored (discarded).

          Rx ignore 0 can be disabled with sDisRxCompare0().
---------------------------------------------------------------------*/
#define sEnRxIgnore0(CHP,CMPBYTE) \
{ \
   (CHP)->MCode[RXCMPVAL0_DATA] = (CMPBYTE); \
   (CHP)->MCode[IGNORE0_DATA] = IGNORE0_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGNORE0_OUT]); \
}

/*-------------------------------------------------------------------
Function: sEnRxIgnore1
Purpose:  Enable compare of Rx data with compare byte #1 and ignore (discard)
          that byte if a match is found.
Call:     sEnRxIgnore1(ChP,CmpByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Rx data byte with
Return:   void
Comments: This function enables comparison of the receive data byte
          with CmpByte.  The comparison is done after the receive data
          byte has been masked (see sSetRxMask()).  If a match is found the
          receive data byte is ignored (discarded).

          Rx ignore 1 can be disabled with sDisRxCompare1().
---------------------------------------------------------------------*/
#define sEnRxIgnore1(CHP,CMPBYTE) \
{ \
   (CHP)->MCode[RXCMPVAL1_DATA] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMPVAL1_OUT]); \
   (CHP)->MCode[RXCMP1_DATA] = RXCMP1_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMP1_OUT]); \
   (CHP)->MCode[INTCMP1_DATA] = INTCMP1_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[INTCMP1_OUT]); \
   (CHP)->MCode[IGREP1_DATA] = IGNORE1_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGREP1_OUT]); \
}

/*-------------------------------------------------------------------
Function: sEnRxIgnore2
Purpose:  Enable compare of Rx data with compare byte #2 and ignore (discard)
          that byte if a match is found.
Call:     sEnRxIgnore2(ChP,CmpByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Rx data byte with
Return:   void
Comments: This function enables comparison of the receive data byte
          with CmpByte.  The comparison is done after the receive data
          byte has been masked (see sSetRxMask()).  If a match is found the
          receive data byte is ignored (discarded).

          Rx ignore 2 can be disabled with sDisRxCompare2().
---------------------------------------------------------------------*/
#define sEnRxIgnore2(CHP,CMPBYTE) \
{ \
   (CHP)->MCode[RXCMPVAL2_DATA] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMPVAL2_OUT]); \
   (CHP)->MCode[RXCMP2_DATA] = RXCMP2_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMP2_OUT]); \
   (CHP)->MCode[INTCMP2_DATA] = INTCMP2_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[INTCMP2_OUT]); \
   (CHP)->MCode[IGREP2_DATA] = IGNORE2_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGREP2_OUT]); \
}


/*-------------------------------------------------------------------
Function: sEnRxIntCompare1
Purpose:  Enable compare of Rx data with compare byte #1 and interrupt
          if a match is found.
Call:     sEnRxIntCompare1(ChP,CmpByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Rx data byte with
Return:   void
Comments: This function enables comparison of the receive data byte
          with CmpByte.  The comparison is done after the receive data
          byte has been masked (see sSetRxMask()).  If a match is found an
          interrupt is generated after adding the data byte to the receive
          FIFO.

          Rx compare interrupt 1 can be disabled with sDisRxCompare1().

Warnings: Before an interrupt will be generated SRC interrupts must be
          enabled (see sEnInterrupts()).
---------------------------------------------------------------------*/
#define sEnRxIntCompare1(CHP,CMPBYTE) \
{ \
   (CHP)->MCode[RXCMPVAL1_DATA] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMPVAL1_OUT]); \
   (CHP)->MCode[RXCMP1_DATA] = RXCMP1_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMP1_OUT]); \
   (CHP)->MCode[IGREP1_DATA] = IG_REP1_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGREP1_OUT]); \
   (CHP)->MCode[INTCMP1_DATA] = INTCMP1_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[INTCMP1_OUT]); \
}

/*-------------------------------------------------------------------
Function: sEnRxIntCompare2
Purpose:  Enable compare of Rx data with compare byte #2 and interrupt
          if a match is found.
Call:     sEnRxIntCompare2(ChP,CmpByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Rx data byte with
Return:   void
Comments: This function enables comparison of the receive data byte
          with CmpByte.  The comparison is done after the receive data
          byte has been masked (see sSetRxMask()).  If a match is found an
          interrupt is generated after adding the data byte to the receive
          FIFO.

          Rx compare interrupt 2 can be disabled with sDisRxCompare2().

Warnings: Before an interrupt will be generated SRC interrupts must be
          enabled (see sEnInterrupts()).
---------------------------------------------------------------------*/
#define sEnRxIntCompare2(CHP,CMPBYTE) \
{ \
   (CHP)->MCode[RXCMPVAL2_DATA] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMPVAL2_OUT]); \
   (CHP)->MCode[RXCMP2_DATA] = RXCMP2_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMP2_OUT]); \
   (CHP)->MCode[IGREP2_DATA] = IG_REP2_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGREP2_OUT]); \
   (CHP)->MCode[INTCMP2_DATA] = INTCMP2_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[INTCMP2_OUT]); \
}

/*-------------------------------------------------------------------
Function: sEnRxProcessor
Purpose:  Enable the receive processor
Call:     sEnRxProcessor(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: This function is used to start the receive processor.  When
          the channel is in the reset state the receive processor is not
          running.  This is done to prevent the receive processor from
          executing invalid microcode instructions prior to the
          downloading of the microcode.

Warnings: This function must be called after valid microcode has been
          downloaded to the AIOP, and it must not be called before the
          microcode has been downloaded.
---------------------------------------------------------------------*/
#define sEnRxProcessor(CHP) \
{ \
   (CHP)->RxControl[2] |= RXPROC_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->RxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sEnRxReplace1
Purpose:  Enable compare of Rx data with compare byte #1 and replacement
          with a single byte if a match is found.
Call:     sEnRxReplace1(ChP,CmpByte,ReplByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Rx data byte with
          unsigned char ReplByte; Byte to replace Rx data byte with if
                                  a match is found on the compare.
Return:   void
Comments: This function enables comparison of the receive data byte
          with CmpByte.  The comparison is done after the receive data
          byte has been masked (see sSetRxMask()).  If a match is found
          the receive data byte is replaced by ReplByte.

          Rx replace 1 can be disabled with sDisRxCompare1().
---------------------------------------------------------------------*/
#define sEnRxReplace1(CHP,CMPBYTE,REPLBYTE) \
{ \
   (CHP)->MCode[RXCMPVAL1_DATA] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMPVAL1_OUT]); \
   (CHP)->MCode[RXREPL1_DATA] = (REPLBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXREPL1_OUT]); \
   (CHP)->MCode[RXCMP1_DATA] = RXCMP1_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMP1_OUT]); \
   (CHP)->MCode[INTCMP1_DATA] = INTCMP1_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[INTCMP1_OUT]); \
   (CHP)->MCode[IGREP1_DATA] = REPLACE1_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGREP1_OUT]); \
}

/*-------------------------------------------------------------------
Function: sEnRxReplace2
Purpose:  Enable compare of Rx data with compare byte #2 and replacement
          with a single byte if a match is found.
Call:     sEnRxReplace2(ChP,CmpByte,ReplByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Rx data byte with
          unsigned char ReplByte; Byte to replace Rx data byte with if
                                  a match is found on the compare.
Return:   void
Comments: This function enables comparison of the receive data byte
          with CmpByte.  The comparison is done after the receive data
          byte has been masked (see sSetRxMask()).  If a match is found
          the receive data byte is replaced by ReplByte.

          Rx replace 2 can be disabled with sDisRxCompare2().
---------------------------------------------------------------------*/
#define sEnRxReplace2(CHP,CMPBYTE,REPLBYTE) \
{ \
   (CHP)->MCode[RXCMPVAL2_DATA] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMPVAL2_OUT]); \
   (CHP)->MCode[RXREPL2_DATA] = (REPLBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXREPL2_OUT]); \
   (CHP)->MCode[RXCMP2_DATA] = RXCMP2_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMP2_OUT]); \
   (CHP)->MCode[INTCMP2_DATA] = INTCMP2_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[INTCMP2_OUT]); \
   (CHP)->MCode[IGREP2_DATA] = REPLACE2_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGREP2_OUT]); \
}

/*-------------------------------------------------------------------
Function: sEnRxStatusMode
Purpose:  Enable the Rx status mode
Call:     sEnRxStatusMode(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: This places the channel in the receive status mode.  All subsequent
          reads of receive data using sReadRxWord() will return a data byte
          in the low word and a status byte in the high word.
---------------------------------------------------------------------*/
#define sEnRxStatusMode(CHP) sOutW((CHP)->ChanStat,STATMODE)

/*-------------------------------------------------------------------
Function: sEnTransmit
Purpose:  Enable transmit
Call:     sEnTransmit(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sEnTransmit(CHP) \
{ \
   (CHP)->TxControl[3] |= TX_ENABLE; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sEnTxIgnore1
Purpose:  Enable compare of Tx data with compare byte #1 and ignore (do not
          transmit) that byte if a match is found.
Call:     sEnTxIgnore1(ChP,CmpByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Tx data byte with
Return:   void
Comments: This function enables comparison of the transmit data byte
          with CmpByte.  If a match is found the transmit data byte
          is ignored, that is, it is not transmitted.

          Tx ignore 1 can be disabled with sDisTxCompare1().
---------------------------------------------------------------------*/
#define sEnTxIgnore1(CHP,CMPBYTE) \
{ \
   (CHP)->TxCompare[2] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxCompare[0]); \
   (CHP)->TxEnables[2] &= ~REP1W2_EN; \
   (CHP)->TxEnables[2] |= (COMP1_EN | IGN1_EN); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxEnables[0]); \
}

/*-------------------------------------------------------------------
Function: sEnTxIgnore2
Purpose:  Enable compare of Tx data with compare byte #2 and ignore (do not
          transmit) that byte if a match is found.
Call:     sEnTxIgnore2(ChP,CmpByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Tx data byte with
Return:   void
Comments: This function enables comparison of the transmit data byte
          with CmpByte.  If a match is found the transmit data byte
          is ignored, that is, it is not transmitted.

          Tx ignore 2 can be disabled with sDisTxCompare2().
---------------------------------------------------------------------*/
#define sEnTxIgnore2(CHP,CMPBYTE) \
{ \
   (CHP)->TxCompare[3] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxCompare[0]); \
   (CHP)->TxEnables[2] |= (COMP2_EN | IGN2_EN); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxEnables[0]); \
}

/*-------------------------------------------------------------------
Function: sEnTxReplace1With1
Purpose:  Enable compare of Tx data with compare byte #1 and replacement
          with a single byte if a match is found.
Call:     sEnTxReplace1With1(ChP,CmpByte,ReplByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Tx data byte with
          unsigned char ReplByte; Byte to replace Tx data byte with if
                                  a match is found on the compare.
Return:   void
Comments: This function enables comparison of the transmit data byte
          with CmpByte.  If a match is found the transmit data byte
          is replaced by ReplByte.

          Tx replace 1 with 1 can be disabled with sDisTxCompare1().
---------------------------------------------------------------------*/
#define sEnTxReplace1With1(CHP,CMPBYTE,REPLBYTE) \
{ \
   (CHP)->TxCompare[2] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxCompare[0]); \
   (CHP)->TxReplace1[2] = (REPLBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxReplace1[0]); \
   (CHP)->TxEnables[2] &= ~(REP1W2_EN | IGN1_EN); \
   (CHP)->TxEnables[2] |= COMP1_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxEnables[0]); \
}

/*-------------------------------------------------------------------
Function: sEnTxReplace1With2
Purpose:  Enable compare of Tx data with compare byte #1 and replacement
          with two bytes if a match is found.
Call:     sEnTxReplace1With2(ChP,CmpByte,ReplByte1,ReplByte2)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Tx data byte with
          unsigned char ReplByte1; First byte to replace Tx data byte with if
                                  a match is found on the compare.
          unsigned char ReplByte2; Second byte to replace Tx data byte with
                                  if a match is found on the compare.
Return:   void
Comments: This function enables comparison of the transmit data byte
          with CmpByte.  If a match is found the transmit data byte
          is replaced by bytes ReplByte1 and ReplByte2.  ReplByte1 will
          be transmitted first, ReplByte2 second.

          Tx replace 1 with 2 can be disabled with sDisTxCompare1().
---------------------------------------------------------------------*/
#define sEnTxReplace1With2(CHP,CMPBYTE,REPLBYTE1,REPLBYTE2) \
{ \
   (CHP)->TxCompare[2] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxCompare[0]); \
   (CHP)->TxReplace1[2] = (REPLBYTE1); \
   (CHP)->TxReplace1[3] = (REPLBYTE2); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxReplace1[0]); \
   (CHP)->TxEnables[2] &= ~IGN1_EN; \
   (CHP)->TxEnables[2] |= (COMP1_EN | REP1W2_EN); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxEnables[0]); \
}

/*-------------------------------------------------------------------
Function: sEnTxReplace2With1
Purpose:  Enable compare of Tx data with compare byte #2 and replacement
          with a single byte if a match is found.
Call:     sEnTxReplace2With1(ChP,CmpByte,ReplByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Tx data byte with
          unsigned char ReplByte; Byte to replace Tx data byte with if
                                  a match is found on the compare.
Return:   void
Comments: This function enables comparison of the transmit data byte
          with CmpByte.  If a match is found the transmit data byte
          is replaced by ReplByte.

          Tx replace 2 with 1 can be disabled with sDisTxCompare2().
---------------------------------------------------------------------*/
#define sEnTxReplace2With1(CHP,CMPBYTE,REPLBYTE) \
{ \
   (CHP)->TxCompare[3] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxCompare[0]); \
   (CHP)->TxReplace2[2] = (REPLBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxReplace2[0]); \
   (CHP)->TxEnables[2] &= ~IGN2_EN; \
   (CHP)->TxEnables[2] |= COMP2_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxEnables[0]); \
}

/*-------------------------------------------------------------------
Function: sEnTxSoftFlowCtl
Purpose:  Enable Tx Software Flow Control
Call:     sEnTxSoftFlowCtl(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sEnTxSoftFlowCtl(CHP) \
{ \
   (CHP)->MCode[TXSWFC_DATA] = TXSWFC_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[TXSWFC_OUT]); \
}

/*-------------------------------------------------------------------
  sIsTxSoftFlowCtlEnabled -
---------------------------------------------------------------------*/
#define sIsTxSoftFlowCtlEnabled(CHP) \
  ((CHP)->MCode[TXSWFC_DATA] == TXSWFC_EN)

/*-------------------------------------------------------------------
Function: sGetAiopID
Purpose:  Get the AIOP ID
Call:     sGetAiopID(CtlP,AiopNum)
          CONTROLLER_T *CtlP; Ptr to controller structure
          int AiopNum;
Return:   int: The AIOP ID if the AIOP exists, AIOPID_NULL if the
               AIOP does not exist.
Comments: The AIOP ID uniquely identifies the type of AIOP.
---------------------------------------------------------------------*/
#define sGetAiopID(CTLP,AIOPNUM) (CTLP)->AiopID[AIOPNUM]

/*-------------------------------------------------------------------
Function: sGetAiopIntStatus
Purpose:  Get the AIOP interrupt status
Call:     sGetAiopIntStatus(CtlP,AiopNum)
          CONTROLLER_T *CtlP; Ptr to controller structure
          int AiopNum; AIOP number
Return:   unsigned char: The AIOP interrupt status.  Bits 0 through 7
                         represent channels 0 through 7 respectively.  If a
                         bit is set that channel is interrupting.
---------------------------------------------------------------------*/
#define sGetAiopIntStatus(CTLP,AIOPNUM) sInB((CTLP)->AiopIntChanIO[AIOPNUM])

/*-------------------------------------------------------------------
Function: sGetAiopNumChan
Purpose:  Get the number of channels supported by an AIOP
Call:     sGetAiopNumChan(CtlP,AiopNum)
          CONTROLLER_T *CtlP; Ptr to controller structure
          int AiopNum; AIOP number
Return:   int: The number of channels supported by the AIOP
---------------------------------------------------------------------*/
#define sGetAiopNumChan(CTLP,AIOPNUM) (CTLP)->AiopNumChan[AIOPNUM]

/*-------------------------------------------------------------------
Function: sGetChanIntID
Purpose:  Get a channel's interrupt identification byte
Call:     sGetChanIntID(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   unsigned char: The channel interrupt ID.  Can be any
             combination of the following flags:
                RXF_TRIG:     Rx FIFO trigger level interrupt
                TXFIFO_MT:    Tx FIFO empty interrupt
                SRC_INT:      Special receive condition interrupt
                DELTA_CD:     CD change interrupt
                DELTA_CTS:    CTS change interrupt
                DELTA_DSR:    DSR change interrupt
---------------------------------------------------------------------*/
#define sGetChanIntID(CHP) (sInB((CHP)->IntID) & (RXF_TRIG | TXFIFO_MT | SRC_INT | DELTA_CD | DELTA_CTS | DELTA_DSR))

/*-------------------------------------------------------------------
Function: sGetChanNum
Purpose:  Get the number of a channel within an AIOP
Call:     sGetChanNum(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   int: Channel number within AIOP, or NULLCHAN if channel does
               not exist.
---------------------------------------------------------------------*/
#define sGetChanNum(CHP) (CHP)->ChanNum

/*-------------------------------------------------------------------
Function: sGetChanStatus
Purpose:  Get the channel status
Call:     sGetChanStatus(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   unsigned int: The channel status.  Can be any combination of
             the following flags:
                LOW BYTE FLAGS
                CTS_ACT:      CTS input asserted
                DSR_ACT:      DSR input asserted
                CD_ACT:       CD input asserted
                TXFIFOMT:     Tx FIFO is empty
                TXSHRMT:      Tx shift register is empty
                RDA:          Rx data available

                HIGH BYTE FLAGS
                STATMODE:     status mode enable bit
                RXFOVERFL:    receive FIFO overflow
                RX2MATCH:     receive compare byte 2 match
                RX1MATCH:     receive compare byte 1 match
                RXBREAK:      received BREAK
                RXFRAME:      received framing error
                RXPARITY:     received parity error
Warnings: This function will clear the high byte flags in the Channel
          Status Register.
---------------------------------------------------------------------*/
#define sGetChanStatus(CHP) sInW((CHP)->ChanStat)

/*-------------------------------------------------------------------
Function: sGetChanStatusLo
Purpose:  Get the low byte only of the channel status
Call:     sGetChanStatusLo(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   unsigned char: The channel status low byte.  Can be any combination
             of the following flags:
                CTS_ACT:      CTS input asserted
                DSR_ACT:      DSR input asserted
                CD_ACT:       CD input asserted
                TXFIFOMT:     Tx FIFO is empty
                TXSHRMT:      Tx shift register is empty
                RDA:          Rx data available
---------------------------------------------------------------------*/
#define sGetChanStatusLo(CHP) sInB((BIOA_T)(CHP)->ChanStat)

/*-------------------------------------------------------------------
Function: sGetControllerID
Purpose:  Get the controller ID
Call:     sGetControllerID(CtlP)
          CONTROLLER_T *CtlP; Ptr to controller structure
Return:   int: The controller ID if the controller exists, CTLID_NULL if
               the controller does not exist.
Comments: The controller ID uniquely identifies the type of controller.
---------------------------------------------------------------------*/
#define sGetControllerID(CTLP) (CTLP)->CtlID

/*-------------------------------------------------------------------
Function: sPCIGetControllerIntStatus
Purpose:  Get the controller interrupt status
Call:     sPCIGetControllerIntStatus(CtlP)
          CONTROLLER_T *CtlP; Ptr to controller structure
Return:   unsigned char: The controller interrupt status in the lower 4
                         bits and bit 4.  Bits 0 through 3 represent AIOP's 0
                         through 3 respectively.  Bit 4 is set if the  int
			 was generated from periodic.  If a bit is set that
                         AIOP is interrupting. 
---------------------------------------------------------------------*/
#define sPCIGetControllerIntStatus(CTLP) \
        ((sInW((CTLP)->PCI1IO) >> 8) & 0x1f)

/*-------------------------------------------------------------------
Function: sGetControllerIntStatus
Purpose:  Get the controller interrupt status
Call:     sGetControllerIntStatus(CtlP)
          CONTROLLER_T *CtlP; Ptr to controller structure
Return:   unsigned char: The controller interrupt status in the lower 4
                         bits.  Bits 0 through 3 represent AIOP's 0
                         through 3 respectively.  If a bit is set that
                         AIOP is interrupting.  Bits 4 through 7 will
                         always be cleared.
---------------------------------------------------------------------*/
#define sGetControllerIntStatus(CTLP) (sInB((CTLP)->MReg1IO) & 0x0f)

/*-------------------------------------------------------------------
Function: sGetControllerNumAiop
Purpose:  Get the number of AIOPs on a controller
Call:     sGetControllerNumAiop(CtlP)
          CONTROLLER_T *CtlP; Ptr to controller structure
Return:   int: The number of AIOPs on the controller.
---------------------------------------------------------------------*/
//#define sGetControllerNumAiop(CTLP) (CTLP)->NumAiop

/*-------------------------------------------------------------------
Function: sGetDevMap
Purpose:  Get an entry in the device map.
Call:     sGetDevMap(Ctl,Aiop,Chan)
          int Ctl; Controller number
          int Aiop; Aiop number within a controller
          int Chan; Channel number within an Aiop
Return:   int: The device number that Ctl, Aiop, and Chan map to, or NULLDEV
               if the device does not exist.
Comments: The device map is used to convert controller number, AIOP number,
          and channel number into a device number.

---------------------------------------------------------------------*/
#define sGetDevMap(CTL,AIOP,CHAN) sDevMapTbl[CTL][AIOP][CHAN]

/*-------------------------------------------------------------------
Function: sGetModemStatus
Purpose:  Get the modem status
Call:     sGetModemStatus(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   unsigned char: Modem status using flags CD_ACT, DSR_ACT, and
                         CTS_ACT.
---------------------------------------------------------------------*/
#define sGetModemStatus(CHP) (unsigned char)(sInB((BIOA_T)(CHP)->ChanStat) & (CD_ACT | DSR_ACT | CTS_ACT))

/*-------------------------------------------------------------------
Function: sGetRPlusModemRI
Purpose:  Get the modem status(DSR on upper unused ports have RI signal)
          CHANPTR_T ChP; Ptr to channel structure
Return:   unsigned char: Modem status using flags DSR_ACT signifying
          RI signal.
---------------------------------------------------------------------*/
#define sGetRPlusModemRI(CHP) (unsigned char)(sInB((BIOA_T)(CHP)->ChanStat+8) & (DSR_ACT))

/*-------------------------------------------------------------------
Function: sGetNextInBitMap
Purpose:  Get the next number needing service from a bit map.
Call:     sGetNextInBitMap(BitMap)
          unsigned char BitMap; The bit map.  Each bit set identifies an
                        entity that needs service.
Return:   int: The next number needing service, or -1 if nothing needs
               service.  If the bit map represents AIOPs or channels,
               NULLAIOP or NULLCHAN respectively are the return values if
               nothing needs service.
Comments: Immediately after calling sGetNextInBitMap(), sClrNextInBitMap()
          must be called to clear the bit of the number just returned.
---------------------------------------------------------------------*/
//#define sGetNextInBitMap(BITMAP) sBitMapToLowTbl[BITMAP]

/*-------------------------------------------------------------------
Function: sGetRxCnt
Purpose:  Get the number of data bytes in the Rx FIFO
Call:     sGetRxCnt(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   int: The number of data bytes in the Rx FIFO.
Comments: Byte read of count register is required to obtain Rx count.
---------------------------------------------------------------------*/
#define sGetRxCnt(CHP) sInW((CHP)->TxRxCount)

/*-------------------------------------------------------------------
Function: sGetRxStatus
Purpose:  Get a channel's receive status
Call:     sGetRxStatus(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   unsigned char: Receive status: 0 if no data is available, or the
                         RDA (Receive Data Available) flag if data is
                         available.
---------------------------------------------------------------------*/
#define sGetRxStatus(CHP) (sInB((BIOA_T)(CHP)->ChanStat) & RDA)

/*-------------------------------------------------------------------
Function: sGetTxCnt
Purpose:  Get the number of data bytes in the Tx FIFO
Call:     sGetTxCnt(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   unsigned char: The number of data bytes in the Tx FIFO.
Comments: Byte read of count register is required to obtain Tx count.
---------------------------------------------------------------------*/
#define sGetTxCnt(CHP) sInB((BIOA_T)(CHP)->TxRxCount)

/*-------------------------------------------------------------------
Function: sGetTxRxDataIO
Purpose:  Get the I/O address of a channel's TxRx Data register
Call:     sGetTxRxDataIO(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   WIOA_T: I/O address of a channel's TxRx Data register
---------------------------------------------------------------------*/
#define sGetTxRxDataIO(CHP) (CHP)->TxRxData

/*-------------------------------------------------------------------
Function: sGetTxSize
Purpose:  Get the maximum number of bytes allowed in a channel's Tx FIFO.
Call:     sGetTxSize(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   int: The maximum number of bytes allowed in the Tx FIFO.
---------------------------------------------------------------------*/
#define sGetTxSize(CHP) (CHP)->TxSize

/*-------------------------------------------------------------------
Function: sGetTxStatus
Purpose:  Get a channels transmit status
Call:     sGetTxStatus(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   unsigned char: Transmit status, can be 0 or any combination of the
             following flags:
                TXFIFOMT: Tx FIFO is empty
                TXSHRMT:  Tx shift register is empty
Comments: If the transmitter is completely drained the return value will
          be (TXFIFOMT | TXSHRMT).
---------------------------------------------------------------------*/
#define sGetTxStatus(CHP) (unsigned char)(sInB((BIOA_T)(CHP)->ChanStat) & (TXFIFOMT | TXSHRMT))

/*-------------------------------------------------------------------
Function: sInB
Purpose:  Read a byte from I/O space
Call:     sInB(io)
          BIOA_T io; I/O address to read from
Return:   unsigned char
---------------------------------------------------------------------*/
#define sInB(IO) READ_PORT_UCHAR(IO)


/*-------------------------------------------------------------------
Function: sInStrW
Purpose:  Read a string of words from I/O space
Call:     sInStrW(io,Buffer,Count)
          WIOA_T io: The I/O address to read from
          unsigned int *Buffer; Ptr to buffer for data read
          int Count; Number of words to read
Return:   void
Warnings: Buffer must be large enough to hold Count words.

          Watch out for macro side effects, the caller's Buffer and Count
          may be modified, depending how the macro is coded.
---------------------------------------------------------------------*/
#define sInStrW(IO,BUFFER,COUNT) READ_PORT_BUFFER_USHORT(IO,BUFFER,COUNT)

/*-------------------------------------------------------------------
Function: sInW
Purpose:  Read a word from I/O space
Call:     sInW(io)
          WIOA_T io; I/O address to read from
Return:   unsigned int
---------------------------------------------------------------------*/
#define sInW(IO) READ_PORT_USHORT(IO)

/*-------------------------------------------------------------------
Function: sOutB
Purpose:  Write a byte to I/O space
Call:     sOutB(io,Value)
          unsigned int io; I/O address to write to
          unsigned char Value; Value to write
Return:   void
---------------------------------------------------------------------*/
#define sOutB(IO,VAL) WRITE_PORT_UCHAR(IO,VAL)


/*-------------------------------------------------------------------
Function: sOutDW
Purpose:  Write a double word to I/O space
Call:     sOutDW(io,Value)
          unsigned int io; I/O address to write to
          unsigned long Value; Value to write
Return:   void
---------------------------------------------------------------------*/
#define sOutDW(IO,VAL) WRITE_PORT_ULONG(IO,VAL)

/*-------------------------------------------------------------------
Function: sOutStrW
Purpose:  Write a string of words to I/O space
Call:     sOutStrW(io,Buffer,Count)
          WIOA_T io: The I/O address to write to
          unsigned int far *Buffer; Ptr to buffer containing write data
          int Count; Number of words to write
Return:   void
Warnings: Watch out for macro side effects, the caller's Buffer and Count
          may be modified, depending how the macro is coded.
---------------------------------------------------------------------*/
#define sOutStrW(IO,BUFFER,COUNT) WRITE_PORT_BUFFER_USHORT(IO,BUFFER,COUNT)

/*-------------------------------------------------------------------
Function: sOutW
Purpose:  Write a word to I/O space
Call:     sOutW(io,Value)
          WIOA_T io; I/O address to write to
          unsigned int Value; Value to write
Return:   void
---------------------------------------------------------------------*/
#define sOutW(IO,VAL) WRITE_PORT_USHORT(IO,VAL)

/*-------------------------------------------------------------------
Function: sReadRxByte
Purpose:  Read a receive data byte from a channel.
Call:     sReadRxByte(io)
          BIOA_T io; Channel receive register I/O address.  This can
                    be obtained with sGetTxRxDataIO().
Return:   unsigned char: The receive data byte
---------------------------------------------------------------------*/
#define sReadRxByte(IO) sInB(IO)

/*-------------------------------------------------------------------
Function: sReadRxWord
Purpose:  Read two receive data bytes from a channel with a single word read
          is not in Rx Status Mode.  Read a data byte and a status byte if
          in Rx Status Mode.
Call:     sReadRxWord(io)
          WIOA_T io; Channel receive register I/O address.  This can
                    be obtained with sGetTxRxDataIO().
Return:   unsigned int: The two receive data bytes if not in Rx Status Mode.
             In this case the first data byte read is placed in the low byte,
             the second data byte read in the high byte.

             A data byte and a status byte if in Rx Status Mode.  In this case
             the data is placed in the low byte and the status in the high
             byte.  The status can be any of the following flags:
                STMBREAK:   Break
                STMFRAME:   Framing error
                STMRCVROVR: Receiver over run error
                STMPARITY:  Parity error
             The flag STMERROR is defined as (STMBREAK | STMFRAME | STMPARITY)
---------------------------------------------------------------------*/
#define sReadRxWord(IO) sInW(IO)

/*-------------------------------------------------------------------
Function: sResetAiop
Purpose:  Reset the AIOP
Call:     sResetAiop(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sResetAiop(CHP) \
{ \
   sOutB((CHP)->Cmd,RESET_ALL); \
   sOutB((CHP)->Cmd,0x0); \
}

/*-------------------------------------------------------------------
Function: sResetUART
Purpose:  Reset the channel's UART
Call:     sResetUART(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: The two sInB() instructions provide a delay >= 400nS.
---------------------------------------------------------------------*/
#define sResetUART(CHP) \
{ \
   sOutB((CHP)->Cmd,(UCHAR)(RESETUART | (CHP)->ChanNum)); \
   sOutB((CHP)->Cmd,(unsigned char)(CHP)->ChanNum); \
   sInB((CHP)->IntChan); \
   sInB((CHP)->IntChan); \
}

/*-------------------------------------------------------------------
Function: sSendBreak
Purpose:  Send a transmit BREAK signal
Call:     sSendBreak(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sSendBreak(CHP) \
{ \
   (CHP)->TxControl[3] |= SETBREAK; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sSetBSChar
Purpose:  Set the BS (backspace) character
Call:     sSetBSChar(ChP,Ch)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Ch; The value to set the backspace character to
Return:   void
---------------------------------------------------------------------*/
#define sSetBSChar(CHP,CH) \
{ \
   (CHP)->BS1_DATA = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->BS1_OUT); \
   (CHP)->BS2_DATA = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->BS2_OUT); \
}

/*-------------------------------------------------------------------
Function: sSetData7
Purpose:  Set data bits to 7
Call:     sSetData7(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sSetData7(CHP) \
{ \
   (CHP)->TxControl[2] &= ~DATA8BIT; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sSetData8
Purpose:  Set data bits to 8
Call:     sSetData8(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sSetData8(CHP) \
{ \
   (CHP)->TxControl[2] |= DATA8BIT; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sSetDevMap
Purpose:  Set an entry in the device map.
Call:     sSetDevMap(Ctl,Aiop,Chan,Dev)
          int Ctl; Controller number
          int Aiop; Aiop number within a controller
          int Chan; Channel number within an Aiop
          int Dev; The device number that Ctl, Aiop, and Chan map to.
Return:   void
Comments: The device map is used to convert controller number, AIOP number,
          and channel number into a device number.  Function sSetDevMap()
          is used to initialize entries within the device map when the
          mapping is first established.
---------------------------------------------------------------------*/
#define sSetDevMap(CTL,AIOP,CHAN,DEV) sDevMapTbl[CTL][AIOP][CHAN] = (DEV)

/*-------------------------------------------------------------------
Function: sSetDTR
Purpose:  Set the DTR output
Call:     sSetDTR(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sSetDTR(CHP) \
{ \
   (CHP)->TxControl[3] |= SET_DTR; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sSetEOFChar
Purpose:  Set the EOF (end of file) character
Call:     sSetBSChar(ChP,Ch)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Ch; The value to set the EOF character to
Return:   void
---------------------------------------------------------------------*/
#define sSetEOFChar(CHP,CH) \
{ \
   (CHP)->MCode[EOF_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[EOF_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetEraseChar
Purpose:  Set Erase character
Call:     sSetEraseChar(ChP,Ch)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Ch; The value to set the erase character to
Return:   void
---------------------------------------------------------------------*/
#define sSetEraseChar(CHP,CH) \
{ \
   (CHP)->MCode[ERASE_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[ERASE_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetESCChar
Purpose:  Set the ESC (escape) character
Call:     sSetESCChar(ChP,Ch)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Ch; The value to set the ESC character to
Return:   void
---------------------------------------------------------------------*/
#define sSetESCChar(CHP,CH) \
{ \
   (CHP)->MCode[ESC_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[ESC_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetEvenParity
Purpose:  Set even parity
Call:     sSetEvenParity(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: Function sSetParity() can be used in place of functions sEnParity(),
          sDisParity(), sSetOddParity(), and sSetEvenParity().

Warnings: This function has no effect unless parity is enabled with function
          sEnParity().
---------------------------------------------------------------------*/
#define sSetEvenParity(CHP) \
{ \
   (CHP)->TxControl[2] |= EVEN_PAR; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sSetErrorIgn
Purpose:  Set Error processing to ignore errored characters
Call:     sSetErrorIgn(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sSetErrorIgn(CHP) \
{ \
   (CHP)->MCode[ERROR_DATA] = (IGNORE_ER); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[ERROR_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetErrorNorm
Purpose:  Set Error processing to treat errored character as normal
`         characters, no error processing is done.
Call:     sSetErrorNorm(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sSetErrorNorm(CHP) \
{ \
   (CHP)->MCode[ERROR_DATA] = (NORMAL_ER); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[ERROR_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetErrorRepl
Purpose:  Set Error processing to replace errored characters with NULL
Call:     sSetErrorRepl(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sSetErrorRepl(CHP) \
{ \
   (CHP)->MCode[ERROR_DATA] = (REPLACE_ER); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[ERROR_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetKILLChar
Purpose:  Set the KILL character
Call:     sSetKILLChar(ChP,Ch)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Ch; The value to set the KILL character to
Return:   void
---------------------------------------------------------------------*/
#define sSetKILLChar(CHP,CH) \
{ \
   (CHP)->MCode[KILL1_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[KILL1_OUT]); \
   (CHP)->MCode[KILL2_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[KILL2_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetNLChar
Purpose:  Set the NL (new line) character
Call:     sSetNLChar(ChP,Ch)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Ch; The value to set the NL character to
Return:   void
---------------------------------------------------------------------*/
#define sSetNLChar(CHP,CH) \
{ \
   (CHP)->MCode[NEWLINE1_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[NEWLINE1_OUT]); \
   (CHP)->MCode[NEWLINE2_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[NEWLINE2_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetOddParity
Purpose:  Set odd parity
Call:     sSetOddParity(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: Function sSetParity() can be used in place of functions sEnParity(),
          sDisParity(), sSetOddParity(), and sSetEvenParity().

Warnings: This function has no effect unless parity is enabled with function
          sEnParity().
---------------------------------------------------------------------*/
#define sSetOddParity(CHP) \
{ \
   (CHP)->TxControl[2] &= ~EVEN_PAR; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sSetRTS
Purpose:  Set the RTS output
Call:     sSetRTS(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sSetRTS(CHP) \
{ \
   (CHP)->TxControl[3] |= SET_RTS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sSetRxCmpVal0
Purpose:  Set Rx Compare Value 0 to a new value without changing the state
          of the enable or disable instructions.
Call:     sSetRxCmpVal0(ChP,CmpByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Rx data byte with
Return:   void
Comments: This function only sets the value of CmpByte. It can be used to
          dynamically set the compare byte while the compare is active.
          It does not enable the compare or ignore functions.
---------------------------------------------------------------------*/
#define sSetRxCmpVal0(CHP,CMPBYTE) \
{ \
   (CHP)->MCode[RXCMPVAL0_DATA] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGNORE0_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetRxCmpVal1
Purpose:  Set Rx Compare Value 1 to a new value without changing the state
          of the enable or disable instructions.
Call:     sSetRxCmpVal1(ChP,CmpByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Rx data byte with
Return:   void
Comments: This function only sets the value of CmpByte. It can be used to
          dynamically set the compare byte while the compare is active.
          It does not enable the compare or ignore functions.
---------------------------------------------------------------------*/
#define sSetRxCmpVal1(CHP,CMPBYTE) \
{ \
   (CHP)->MCode[RXCMPVAL1_DATA] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMPVAL1_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetRxCmpVal2
Purpose:  Set Rx Compare Value 2 to a new value without changing the state
          of the enable or disable instructions.
Call:     sSetRxCmpVal2(ChP,CmpByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Rx data byte with
Return:   void
Comments: This function only sets the value of CmpByte. It can be used to
          dynamically set the compare byte while the compare is active.
          It does not enable the compare or ignore functions.
---------------------------------------------------------------------*/
#define sSetRxCmpVal2(CHP,CMPBYTE) \
{ \
   (CHP)->MCode[RXCMPVAL2_DATA] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMPVAL2_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetRxMask
Purpose:  Set the Rx mask value
Call:     sSetRxMask(ChP,Ch)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Ch; The value to set the Rx mask to
Return:   void
---------------------------------------------------------------------*/
#define sSetRxMask(CHP,CH) \
{ \
   (CHP)->MCode[RXMASK_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXMASK_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetRxTrigger
Purpose:  Set the Rx FIFO trigger level
Call:     sSetRxProcessor(ChP,Level)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Level; Number of characters in Rx FIFO at which the
             interrupt will be generated.  Can be any of the following flags:

             TRIG_NO:   no trigger
             TRIG_1:    1 character in FIFO
             TRIG_1_2:  FIFO 1/2 full
             TRIG_7_8:  FIFO 7/8 full
Return:   void
Comments: An interrupt will be generated when the trigger level is reached
          only if function sEnInterrupt() has been called with flag
          RXINT_EN set.  The RXF_TRIG flag in the Interrupt Idenfification
          register will be set whenever the trigger level is reached
          regardless of the setting of RXINT_EN.
---------------------------------------------------------------------*/
#define sSetRxTrigger(CHP,LEVEL) \
{ \
   (CHP)->RxControl[2] &= ~TRIG_MASK; \
   (CHP)->RxControl[2] |= LEVEL; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->RxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sSetTxSize
Purpose:  Set the maximum number of bytes allowed in a channel's Tx FIFO.
Call:     sSetTxSize(ChP,TxSize)
          CHANPTR_T ChP; Ptr to channel structure
          int TxSize; Maximum number of bytes allowed in Tx FIFO.
Return:   void
---------------------------------------------------------------------*/
#define sSetTxSize(CHP,TXSIZE) (CHP)->TxSize = (TXSIZE)

/*-------------------------------------------------------------------
Function: sSetSPChar
Purpose:  Set the SP (space) character
Call:     sSetSPChar(ChP,Ch)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Ch; The value to set the SP character to
Return:   void
---------------------------------------------------------------------*/
#define sSetSPChar(CHP,CH) \
{ \
   (CHP)->MCode[SPACE_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[SPACE_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetStop1
Purpose:  Set stop bits to 1
Call:     sSetStop1(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sSetStop1(CHP) \
{ \
   (CHP)->TxControl[2] &= ~STOP2; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sSetStop2
Purpose:  Set stop bits to 2
Call:     sSetStop2(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sSetStop2(CHP) \
{ \
   (CHP)->TxControl[2] |= STOP2; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sSetTxXOFFChar
Purpose:  Set the Tx XOFF flow control character
Call:     sSetTxXOFFChar(ChP,Ch)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Ch; The value to set the Tx XOFF character to
Return:   void
---------------------------------------------------------------------*/
#define sSetTxXOFFChar(CHP,CH) \
{ \
   (CHP)->MCode[TXXOFFVAL_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[TXXOFFVAL_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetTxXONChar
Purpose:  Set the Tx XON flow control character
Call:     sSetTxXONChar(ChP,Ch)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Ch; The value to set the Tx XON character to
Return:   void
---------------------------------------------------------------------*/
#define sSetTxXONChar(CHP,CH) \
{ \
   (CHP)->MCode[TXXONVAL_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[TXXONVAL_OUT]); \
}

/*-------------------------------------------------------------------
Function: sStartRxProcessor
Purpose:  Start a channel's receive processor
Call:     sStartRxProcessor(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: This function is used to start a Rx processor after it was
          stopped with sStopRxProcessor() or sStopSWInFlowCtl().  It
          will restart both the Rx processor and software input flow control.
---------------------------------------------------------------------*/
#define sStartRxProcessor(CHP) sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[0])

/*-------------------------------------------------------------------
Function: sWriteTxByte
Purpose:  Write a transmit data byte to a channel.
          BIOA_T io: Channel transmit register I/O address.  This can
                           be obtained with sGetTxRxDataIO().
          unsigned char Data; The transmit data byte.
Return:   void
Warnings: This function writes the data byte without checking to see if
          sMaxTxSize is exceeded in the Tx FIFO.
---------------------------------------------------------------------*/
#define sWriteTxByte(IO,DATA) sOutB(IO,DATA)

/*-------------------------------------------------------------------
Function: sWriteTxWord
Purpose:  Write two transmit data bytes to a channel with a single word write
Call:     sWriteTxWord(io,Data)
          WIOA_T io: Channel transmit register I/O address.  This can
                           be obtained with sGetTxRxDataIO().
          unsigned int Data; The two transmit data bytes.  The low byte
             will be transmitted first, then the high byte.
Return:   void
---------------------------------------------------------------------*/
#define sWriteTxWord(IO,DATA) sOutW(IO,DATA)


//----- global vars
extern unsigned char MasterMCode1[];
extern unsigned char MCode1Reg[];
extern CONTROLLER_T sController[];
extern unsigned char sIRQMap[16];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\ssci.c ===
/*-------------------------------------------------------------------
| ssci.c - low level interface routines to rocketport hardware.

 03-16-98, add sModemSendROW for RocketModem - jl
 02-05-98, add sModemReset for RocketModem - jl
 10-22-96, add ReadAiopID to PCI case as hardware verification. - kpb

Copyright 1993-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

#define  ONE_SECOND     10
#define  TWO_SECONDS    (2 * ONE_SECOND)
#define  THREE_SECONDS  (3 * ONE_SECOND)
#define  FOUR_SECONDS   (4 * ONE_SECOND)
#define  FIVE_SECONDS   (5 * ONE_SECOND)
#define  TENTH_SECOND   (ONE_SECOND / 10)
#define  HALF_SECOND    (ONE_SECOND / 2)

// #define  DUMPDATA 1
#ifdef DUMPDATA
// in case of changed responses from modem, the following allows
// the unrecognized responses to be dumped to log...
void  DumpResponseByte(char buffer);
char  DumpArray[512];
int   DumpIndex = 0;
#endif

#ifdef PPC
// #define INTEL_ORDER 1
#endif

#ifdef ALPHA
#define INTEL_ORDER 1
#define WORD_ALIGN 1
#endif

#ifdef i386
#define INTEL_ORDER 1
#endif

#ifdef MIPS
// #define INTEL_ORDER 1
#endif

/* Master copy of AIOP microcode.  Organized as DWORDs.  The 1st word of each
   DWORD holds the microcode index, the second word holds the microcode
   data. */
unsigned char MasterMCode1[MCODE1_SIZE] =
{
/* indl  indh  dlo   dhi */
   0x00, 0x09, 0xf6, 0x82,
   0x02, 0x09, 0x86, 0xfb,
   0x04, 0x09, 0x00, 0x0a,
   0x06, 0x09, 0x01, 0x0a,
   0x08, 0x09, 0x8a, 0x13,
   0x0a, 0x09, 0xc5, 0x11,
   0x0c, 0x09, 0x86, 0x85,
   0x0e, 0x09, 0x20, 0x0a,
   0x10, 0x09, 0x21, 0x0a,
   0x12, 0x09, 0x41, 0xff,
   0x14, 0x09, 0x82, 0x00,
   0x16, 0x09, 0x82, 0x7b,
   0x18, 0x09, 0x8a, 0x7d,
   0x1a, 0x09, 0x88, 0x81,
   0x1c, 0x09, 0x86, 0x7a,
   0x1e, 0x09, 0x84, 0x81,
   0x20, 0x09, 0x82, 0x7c,
   0x22, 0x09, 0x0a, 0x0a 
};

/* Registers within microcode.  Organized as DWORDs.  The 1st word of each
   DWORD holds the microcode index of that register, the 2nd DWORD holds
   the current contents of that register. */
unsigned char MCode1Reg[MCODE1REG_SIZE] =
{
/* indl  indh  dlo   dhi */
   0x00, 0x09, 0xf6, 0x82,             /* 00: Stop Rx processor */
   0x08, 0x09, 0x8a, 0x13,             /* 04: Tx software flow control */
   0x0a, 0x09, 0xc5, 0x11,             /* 08: XON char */
   0x0c, 0x09, 0x86, 0x85,             /* 0c: XANY */
   0x12, 0x09, 0x41, 0xff,             /* 10: Rx mask char */
   0x14, 0x09, 0x82, 0x00,             /* 14: Compare/Ignore #0 */
   0x16, 0x09, 0x82, 0x7b,             /* 18: Compare #1 */
   0x18, 0x09, 0x8a, 0x7d,             /* 1c: Compare #2 */
   0x1a, 0x09, 0x88, 0x81,             /* 20: Interrupt #1 */
   0x1c, 0x09, 0x86, 0x7a,             /* 24: Ignore/Replace #1 */
   0x1e, 0x09, 0x84, 0x81,             /* 28: Interrupt #2 */
   0x20, 0x09, 0x82, 0x7c,             /* 2c: Ignore/Replace #2 */
   0x22, 0x09, 0x0a, 0x0a              /* 30: Rx FIFO Enable */
};

/* Controller structures */
/* IRQ number to MUDBAC register 2 mapping */
unsigned char sIRQMap[16] =
{
   0,0,0,0x10,0x20,0x30,0,0,0,0x40,0x50,0x60,0x70,0,0,0x80
};

//unsigned char sBitMapClrTbl[8] =
//   0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f

//unsigned char sBitMapSetTbl[8] =
//   0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80

/***************************************************************************
Function: sInitController
Purpose:  Initialization of controller global registers and controller
          structure.
Call:     **** This version of the call for all except Windows NT ****
          sInitController(CtlP,CtlNum,MudbacIO,AiopIOList,AiopIOListSize,
                          IRQNum,Frequency,PeriodicOnly)
Call:     **** This version of the call for Windows NT ***
          sInitController(CtlP,CtlNum,MudbacIO,AiopIOList,PhyAiopIOList,
          AiopIOListSize,IRQNum,Frequency,PeriodicOnly)
          CONTROLLER_T *CtlP; Ptr to controller structure
          int CtlNum; Controller number
          BIOA_T MudbacIO; Mudbac base I/O address.  For Win NT this
             is the TranslatedAddress returned by HalTranslateBusAddress().
          BIOA_T *AiopIOList; List of I/O addresses for each AIOP.
             This list must be in the order the AIOPs will be found on the
             controller.  Once an AIOP in the list is not found, it is
             assumed that there are no more AIOPs on the controller.
             For Win NT these are the TranslatedAddresses returned by
             HalTranslateBusAddress().
          unsigned int *PhyAiopIOList; List of physical I/O addresses for
             each AIOP, used by Win NT only.  These are the physical
             addresses corresponding to the TranslatedAddresses in
             AiopIOList.
          int AiopIOListSize; Number of addresses in AiopIOList
          int IRQNum; Interrupt Request number.  Can be any of the following:
                         0: Disable global interrupts
                         3: IRQ 3
                         4: IRQ 4
                         5: IRQ 5
                         9: IRQ 9
                         10: IRQ 10
                         11: IRQ 11
                         12: IRQ 12
                         15: IRQ 15
          unsigned char Frequency: A flag identifying the frequency
                   of the periodic interrupt, can be any one of the following:
                      FREQ_DIS - periodic interrupt disabled
                      FREQ_137HZ - 137 Hertz
                      FREQ_69HZ - 69 Hertz
                      FREQ_34HZ - 34 Hertz
                      FREQ_17HZ - 17 Hertz
                      FREQ_9HZ - 9 Hertz
                      FREQ_4HZ - 4 Hertz
                   If IRQNum is set to 0 the Frequency parameter is
                   overidden, it is forced to a value of FREQ_DIS.
          int PeriodicOnly: TRUE if all interrupts except the periodic
                               interrupt are to be blocked.
                            FALSE is both the periodic interrupt and
                               other channel interrupts are allowed.
                            If IRQNum is set to 0 the PeriodicOnly parameter is
                               overidden, it is forced to a value of FALSE.
Return:   int: 0 on success, errcode on failure

Comments: This function must be called immediately after sSetChannelDefaults()
          for each controller in the system.

          If periodic interrupts are to be disabled but AIOP interrupts
          are allowed, set Frequency to FREQ_DIS and PeriodicOnly to FALSE.

          If interrupts are to be completely disabled set IRQNum to 0.

          Setting Frequency to FREQ_DIS and PeriodicOnly to TRUE is an
          invalid combination.

          This function performs initialization of global interrupt modes,
          but it does not actually enable global interrupts.  To enable
          and disable global interrupts use functions sEnGlobalInt() and
          sDisGlobalInt().  Enabling of global interrupts is normally not
          done until all other initializations are complete.

          Even if interrupts are globally enabled, they must also be
          individually enabled for each channel that is to generate
          interrupts.
Warnings: No range checking on any of the parameters is done.

          No context switches are allowed while executing this function.

          After this function all AIOPs on the controller are disabled,
          they can be enabled with sEnAiop().
*/
int sInitController(CONTROLLER_T *CtlP,
//                    int CtlNum,
                    BIOA_T MudbacIO,
                    BIOA_T *AiopIOList,
                    unsigned int *PhyAiopIOList,
                    int AiopIOListSize,
                    int IRQNum,
                    unsigned char Frequency,
                    int PeriodicOnly,
                    int BusType,
                    int prescaler)
{
   // unsigned char MudbacID;             /* MUDBAC ID byte*/
   int i;
   BIOA_T io;                          /* an I/O address */
   unsigned int pio;                   /* physical I/O address for Win NT */
   WIOA_T IoIndexAddr;
   WIOA_T IoIndexData;
   // IoIndexAddr=(PUSHORT)((PUCHAR)io+_INDX_ADDR);
   // IoIndexData=(PUSHORT)((PUCHAR)io+_INDX_DATA);
      
   //CtlP->CtlNum = CtlNum;
   CtlP->BusType = BusType;
   CtlP->PortsPerAiop = 8;

   if (CtlP->BusType == Isa)
   {
     MyKdPrint(D_Ssci,("One ISA ROCKET \n"))
     CtlP->CtlID = CTLID_0001;        /* controller release 1 */
     if (AiopIOListSize == 0)
       AiopIOListSize = 32; // we figure out

     /* If we get here controller found, init MUDBAC and controller struct */
     CtlP->MBaseIO = MudbacIO;
     CtlP->MReg1IO = MudbacIO + 1;
     CtlP->MReg2IO = MudbacIO + 2;
     CtlP->MReg3IO = MudbacIO + 3;
     if (IRQNum > 15) IRQNum = 0;  // limit
     if (sIRQMap[IRQNum] == 0)     // interrupts globally disabled
     {
       MyKdPrint(D_Ssci,("No IRQ\n"))
       CtlP->MReg2 = 0;            // interrupt disable
       CtlP->MReg3 = 0;            // no periodic interrupts
     }
     else
     {
       MyKdPrint(D_Ssci,("IRQ used:%d\n",IRQNum))
       CtlP->MReg2 = sIRQMap[IRQNum];   // set IRQ number 
       CtlP->MReg3 = Frequency;         // set frequency 
       if(PeriodicOnly)                 // periodic interrupt only 
       {
         CtlP->MReg3 |= PERIODIC_ONLY;
       }
     }
     sOutB(CtlP->MReg2IO,CtlP->MReg2);
     sOutB(CtlP->MReg3IO,CtlP->MReg3);
     sControllerEOI(CtlP);               /* clear EOI if warm init */

     sDisGlobalInt(CtlP);
     MyKdPrint(D_Ssci,("Disabled ISA interrupts Mreg2:%x := %x\n",
                  CtlP->MReg2IO,CtlP->MReg2))

     /* Init AIOPs */
     CtlP->NumAiop = 0;

     for(i = 0;i < AiopIOListSize;i++)
     {
       io = AiopIOList[i];
       IoIndexAddr=(PUSHORT)(io+_INDX_ADDR);
       IoIndexData=(PUSHORT)(io+_INDX_DATA);
       pio = PhyAiopIOList[i];    /* io points to port, pio is the adrs */

       MyKdPrint(D_Ssci,("io=%xH  pio=%xH\n", (unsigned int)io,
            (unsigned int)pio))

       CtlP->AiopIO[i] = (WIOA_T)io;
       CtlP->AiopIntChanIO[i] = io + _INT_CHAN;

       MyKdPrint(D_Ssci,("Setup AIOP io, MReg2IO=%xH\n",
            (unsigned int)CtlP->MReg2IO))


       sOutB((CtlP->MReg2IO),(unsigned char)(CtlP->MReg2 | (i & 0x03))); /* AIOP index */
       sOutB(MudbacIO,(unsigned char)(pio >> 6)); /* set up AIOP I/O in MUDBAC */

       MyKdPrint(D_Ssci,("Enable AIOP\n"))

       sEnAiop(CtlP,i);                         /* enable the AIOP */

       MyKdPrint(D_Ssci,("Read AIOP ID\n"))

       CtlP->AiopID[i] = sReadAiopID(io);       /* read AIOP ID */

       if(CtlP->AiopID[i] == AIOPID_NULL)       /* if AIOP does not exist */
       {
         sDisAiop(CtlP,i);                     /* disable AIOP */
         break;                                /* done looking for AIOPs */
       }

       MyKdPrint(D_Ssci,("Read AIOP numchan\n"))
       CtlP->AiopNumChan[i] = sReadAiopNumChan((WIOA_T)io); /* num channels in AIOP */


       MyKdPrint(D_Ssci,("Setup Aiop Clk\n"))

       sOutW((WIOA_T)IoIndexAddr,_CLK_PRE);      /* clock prescaler */
       //sOutB((PUCHAR)IoIndexData,CLOCK_PRESC);
       sOutB((PUCHAR)IoIndexData, (BYTE)prescaler);
       CtlP->NumAiop++;                         /* bump count of AIOPs */

       MyKdPrint(D_Ssci,("Setup aiop done\n"))

       sDisAiop(CtlP,i);                        /* disable AIOP */
     }

     MyKdPrint(D_Ssci,("One ISA ROCKET with %d aiops\n",CtlP->NumAiop))

     if(CtlP->NumAiop == 0) {
       MyKdPrint(D_Error,("ISA NumAiop == 0\n"))
       return 1;  // error
     }
     return 0; // ok    // old:(CtlP->NumAiop);
   }  // end of ISA controller init
   else if(CtlP->BusType == PCIBus)
   {
     MyKdPrint(D_Ssci,("One PCI ROCKET \n"))
     //CtlP->CtlNum = CtlNum;
     CtlP->CtlID = CTLID_0001;           /* controller release 1 */
     MyKdPrint(D_Ssci,("Ctrl(%x) IrqNum: %x \n", CtlP, IRQNum))
     if(IRQNum == 0)            /* interrupts disabled for this controler*/
     {
       CtlP->PCI1 = 0x0008;     /* no periodic, interrupts disabled */
     }
     else
     {
       Frequency >>= 4;                /*Right shift 4 times to move 4:7 to  0:3 */
       CtlP->PCI1 |= Frequency;
       if(PeriodicOnly)                 /* periodic interrupt only */
       {
         CtlP->PCI1 |= PER_ONLY_PCI;
       }
     }

     CtlP->PCI1IO = (WIOA_T)((BIOA_T)AiopIOList[0] + _PCI_INT_FUNC);
     MyKdPrint(D_Ssci,("Setting PCI config reg with %x at %x\n",
                              CtlP->PCI1,CtlP->PCI1IO))    // move these calls to ssci.h
     sOutW(CtlP->PCI1IO,CtlP->PCI1);
////////////////////new/////////////////////
          ///CtlP->PortsPerAiop = 8;

      switch (CtlP->PCI_DevID)
      {
        case PCI_DEVICE_4Q:   // 4 Port Quadcable
        case PCI_DEVICE_4RJ:   // 4 Port RJ
          CtlP->PortsPerAiop = 4;

          break;
        case PCI_DEVICE_8RJ:   // 8 Port RJ
        case PCI_DEVICE_8O:   // 8 Port Octacable
        case PCI_DEVICE_8I:  // 8 Port interface
        case PCI_DEVICE_16I:  //16 Port interface
        case PCI_DEVICE_32I:  // 32 Port interface
        case PCI_DEVICE_SIEMENS8  :
        case PCI_DEVICE_SIEMENS16 :
          CtlP->PortsPerAiop = 8;
        break;

        case PCI_DEVICE_RMODEM6 :
          CtlP->PortsPerAiop = 6;
        break;

        case PCI_DEVICE_RMODEM4 :
          CtlP->PortsPerAiop = 4;
        break;

        case PCI_DEVICE_RPLUS4 :
        case PCI_DEVICE_RPLUS8 :
          CtlP->PortsPerAiop = 4;
        break;

        case PCI_DEVICE_RPLUS2 :
        case PCI_DEVICE_422RPLUS2 :
          CtlP->PortsPerAiop = 2;
        break;

        default:
          //Eprintf("Err,Bad PCI DevID:%d", CtlP->PCI_DevID);
        break;
      }  // switch
///////////////////////////////////////////

     /* Init AIOPs */
     CtlP->NumAiop = 0;
     for(i=0; i < AiopIOListSize; i++)
     {
       io = AiopIOList[i];
       CtlP->AiopIO[i] = (WIOA_T)io;
       CtlP->AiopIntChanIO[i] = (BIOA_T)io + _INT_CHAN;

       // 10-22-96, add this(only hardware-verification done) kpb.
       CtlP->AiopID[i] = sReadAiopID(io);       /* read AIOP ID */
       if(CtlP->AiopID[i] == AIOPID_NULL)       /* if AIOP does not exist */
       {
         break;                                /* done looking for AIOPs */
       }

///////old       CtlP->AiopNumChan[i] = sReadAiopNumChan((WIOA_T)io); /* num channels in AIOP */

      ////////////////////new///////////////////////
       CtlP->AiopNumChan[i] = CtlP->PortsPerAiop; /* num channels in AIOP */
      /////////////////////////////////////////////////////////////// 

       IoIndexAddr=(WIOA_T)((BIOA_T)io+_INDX_ADDR);
       IoIndexData=(WIOA_T)((BIOA_T)io+_INDX_DATA);
       sOutW((WIOA_T)IoIndexAddr,_CLK_PRE);      /* clock prescaler */

       sOutB((BIOA_T)IoIndexData, (BYTE)prescaler);
       CtlP->NumAiop++;                         /* bump count of AIOPs */
     }

     sDisGlobalIntPCI(CtlP);
     sPCIControllerEOI(CtlP);               /* clear EOI if warm init */
     
     MyKdPrint(D_Ssci,("One PCI ROCKET with %d aiops\n",CtlP->NumAiop))
     if(CtlP->NumAiop == 0) {
        MyKdPrint(D_Error,("PCI NumAiop == 0\n"))
        return 2;  // error
     }
     return 0;   // old:(CtlP->NumAiop);
  }  /*end of PCI rocket INIT */
  else { /* not PCI or ISA */
     MyKdPrint(D_Error,("Not ISA or PCI\n"))
     return 3; // old:(CTLID_NULL);
  }
  return 0;
}

/***************************************************************************
Function: sReadAiopID
Purpose:  Read the AIOP idenfication number directly from an AIOP.
Call:     sReadAiopID(io)
          BIOA_T io: AIOP base I/O address
Return:   int: Flag AIOPID_XXXX if a valid AIOP is found, where X
                 is replace by an identifying number.
          Flag AIOPID_NULL if no valid AIOP is found
Warnings: No context switches are allowed while executing this function.
-------------------------------------------------------------------------*/
int _CDECL sReadAiopID(BIOA_T io)
{
  unsigned char AiopID;               /* ID byte from AIOP */

  sOutB(io + _CMD_REG,RESET_ALL);     /* reset AIOP */
  sOutB(io + _CMD_REG,0x0);
  AiopID = sInB(io + _CHN_STAT0) & 0x07;
  if (AiopID == 0x06)                  /* AIOP release 1 */
    return(AIOPID_0001);
  else                                /* AIOP does not exist */
    return(AIOPID_NULL);
}

/***************************************************************************
Function: sReadAiopNumChan
Purpose:  Read the number of channels available in an AIOP directly from
          an AIOP.
Call:     sReadAiopNumChan(io)
          WIOA_T io: AIOP base I/O address
Return:   int: The number of channels available
Comments: The number of channels is determined by write/reads from identical
          offsets within the SRAM address spaces for channels 0 and 4.
          If the channel 4 space is mirrored to channel 0 it is a 4 channel
          AIOP, otherwise it is an 8 channel.
Warnings: No context switches are allowed while executing this function.
-------------------------------------------------------------------------*/
int _CDECL sReadAiopNumChan(WIOA_T io)
{
  unsigned int x;
  WIOA_T IoIndexAddr;
  WIOA_T IoIndexData;

  IoIndexAddr = (PUSHORT)((PUCHAR)io+_INDX_ADDR);
  IoIndexData = (PUSHORT)((PUCHAR)io+_INDX_DATA);
  sOutDW((DWIOA_T)IoIndexAddr, 0x12340000L); /* write to chan 0 SRAM */
  sOutW(IoIndexAddr,0);       /* read from SRAM, chan 0 */
  x = sInW(IoIndexData);
  sOutW(IoIndexAddr, 0x4000);  /* read from SRAM, chan 4 */
  if (x != sInW(IoIndexData))  /* if different must be 8 chan */
    return(8);
  else
    return(4);
}

/***************************************************************************
Function: sInitChan
Purpose:  Initialization of a channel and channel structure
Call:     sInitChan(CtlP,ChP,AiopNum,ChanNum)
          CONTROLLER_T *CtlP; Ptr to controller structure
          CHANPTR_T ChP; Ptr to channel structure
          int AiopNum; AIOP number within controller
          int ChanNum; Channel number within AIOP
Return:   int: TRUE if initialization succeeded, FALSE if it fails because channel
               number exceeds number of channels available in AIOP.
Comments: This function must be called before a channel can be used.
Warnings: No range checking on any of the parameters is done.

          No context switches are allowed while executing this function.
-------------------------------------------------------------------------*/
int _CDECL sInitChan(CONTROLLER_T *CtlP,
                     CHANPTR_T ChP,
                     int AiopNum,
                     int ChanNum)
{
   int i;
   WIOA_T AiopIO;
   WIOA_T ChIOOff;                      /* I/O offset of chan with AIOP */
   unsigned char *ChMCode;             /* channel copy of microcode */
   unsigned char *MasterMCode;         /* master copy of microcode */
   unsigned int ChOff;                 /* SRAM offset of channel within AIOP */
   static unsigned char MCode[4];      /* local copy of microcode double word*/
   WIOA_T AiopIndexAddr;

   if(ChanNum >= CtlP->AiopNumChan[AiopNum])
      return(FALSE);                   /* exceeds num chans in AIOP */

   /* Channel, AIOP, and controller identifiers */
   ChP->CtlP = CtlP;
   ChP->ChanID = CtlP->AiopID[AiopNum];
   ChP->AiopNum = AiopNum;
   ChP->ChanNum = ChanNum;

   /* Tx FIFO size */
   sSetTxSize(ChP,MAXTX_SIZE);

   /* Global direct addresses */
   AiopIO = CtlP->AiopIO[AiopNum];
   ChP->Cmd = (BIOA_T)AiopIO + _CMD_REG;
   ChP->IntChan = (BIOA_T)AiopIO + _INT_CHAN;
   ChP->IntMask = (BIOA_T)AiopIO + _INT_MASK;
   AiopIndexAddr=(WIOA_T)((BIOA_T)AiopIO+_INDX_ADDR);
   ChP->IndexAddr = (DWIOA_T)AiopIndexAddr;
   ChP->IndexData = (WIOA_T)((BIOA_T)AiopIO + _INDX_DATA);

   /* Channel direct addresses */
   ChIOOff = (WIOA_T)((BIOA_T)AiopIO + ChP->ChanNum * 2);
   ChP->TxRxData = (WIOA_T)((BIOA_T)ChIOOff + _TD0);
   ChP->ChanStat = (WIOA_T)((BIOA_T)ChIOOff + _CHN_STAT0);
   ChP->TxRxCount =(WIOA_T)((BIOA_T)ChIOOff + _FIFO_CNT0);
   ChP->IntID = (BIOA_T)AiopIO + ChP->ChanNum + _INT_ID0;


   /* Channel microcode initialization.  This writes a complete copy
      of the microcode into the SRAM. */
   MasterMCode = MasterMCode1;
   for(i = 0;i < MCODE1_SIZE; i+=4)
   {
      /* get low byte of index */
      MCode[0] = MasterMCode[i];
      /* get high byte of index */
      MCode[1] = MasterMCode[i+1] + 0x10 * ChanNum;
      /* get low microcode byte */
      MCode[2] = MasterMCode[i+2];
      /* get high microcode byte */
      MCode[3] = MasterMCode[i+3];
      sOutDW(ChP->IndexAddr,*((ULONGPTR_T)&MCode[0]));
   }

   /* Initialize SSCI copy of microcode registers.  This saves only the portion
      of the microcode that will be used as registers. */
   ChMCode = ChP->MCode;
   MasterMCode = MCode1Reg;
   for(i = 0;i < MCODE1REG_SIZE; i+=4)
   {
      /* low byte of index */
      ChMCode[i] = MasterMCode[i];
      /* high byte of index */
      ChMCode[i+1] = MasterMCode[i+1] + 0x10 * ChanNum;
      /* low microcode byte */
      ChMCode[i+2] = MasterMCode[i+2];
      /* high microcode byte */
      ChMCode[i+3] = MasterMCode[i+3];
   }


   /* Indexed registers */
   ChOff = (unsigned int)ChanNum * 0x1000;

   ChP->BaudDiv[0] = (unsigned char)(ChOff + _BAUD);
   ChP->BaudDiv[1] = (unsigned char)((ChOff + _BAUD) >> 8);
   //ChP->BaudDiv[2] = (unsigned char)BRD9600;
   //ChP->BaudDiv[3] = (unsigned char)(BRD9600 >> 8);
   // just default the baud register to something..
   ChP->BaudDiv[2] = (unsigned char)47;
   ChP->BaudDiv[3] = (unsigned char)(47 >> 8);
   sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->BaudDiv[0]);

   ChP->TxControl[0] = (unsigned char)(ChOff + _TX_CTRL);
   ChP->TxControl[1] = (unsigned char)((ChOff + _TX_CTRL) >> 8);
   ChP->TxControl[2] = 0;
   ChP->TxControl[3] = 0;
   sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->TxControl[0]);

   ChP->RxControl[0] = (unsigned char)(ChOff + _RX_CTRL);
   ChP->RxControl[1] = (unsigned char)((ChOff + _RX_CTRL) >> 8);
   ChP->RxControl[2] = 0;
   ChP->RxControl[3] = 0;
   sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->RxControl[0]);

   ChP->TxEnables[0] = (unsigned char)(ChOff + _TX_ENBLS);
   ChP->TxEnables[1] = (unsigned char)((ChOff + _TX_ENBLS) >> 8);
   ChP->TxEnables[2] = 0;
   ChP->TxEnables[3] = 0;
   sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->TxEnables[0]);

   ChP->TxCompare[0] = (unsigned char)(ChOff + _TXCMP1);
   ChP->TxCompare[1] = (unsigned char)((ChOff + _TXCMP1) >> 8);
   ChP->TxCompare[2] = 0;
   ChP->TxCompare[3] = 0;
   sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->TxCompare[0]);

   ChP->TxReplace1[0] = (unsigned char)(ChOff + _TXREP1B1);
   ChP->TxReplace1[1] = (unsigned char)((ChOff + _TXREP1B1) >> 8);
   ChP->TxReplace1[2] = 0;
   ChP->TxReplace1[3] = 0;
   sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->TxReplace1[0]);

   ChP->TxReplace2[0] = (unsigned char)(ChOff + _TXREP2);
   ChP->TxReplace2[1] = (unsigned char)((ChOff + _TXREP2) >> 8);
   ChP->TxReplace2[2] = 0;
   ChP->TxReplace2[3] = 0;
   sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->TxReplace2[0]);


   ChP->TxFIFOPtrs = ChOff + _TXF_OUTP;
   ChP->TxFIFO = ChOff + _TX_FIFO;

   sOutB(ChP->Cmd,(unsigned char)(ChanNum | RESTXFCNT)); /* apply reset Tx FIFO count */
   sOutB(ChP->Cmd,(unsigned char)ChanNum);  /* remove reset Tx FIFO count */
   sOutW((WIOA_T)ChP->IndexAddr,(USHORT)ChP->TxFIFOPtrs); /* clear Tx in/out ptrs */
   sOutW(ChP->IndexData,0);
   ChP->RxFIFOPtrs = ChOff + _RXF_OUTP;
   ChP->RxFIFO = ChOff + _RX_FIFO;

   sOutB(ChP->Cmd,(unsigned char)(ChanNum | RESRXFCNT)); /* apply reset Rx FIFO count */
   sOutB(ChP->Cmd,(unsigned char)ChanNum);  /* remove reset Rx FIFO count */
   sOutW((WIOA_T)ChP->IndexAddr,(USHORT)ChP->RxFIFOPtrs); /* clear Rx out ptr */
   sOutW(ChP->IndexData,0);
   sOutW((WIOA_T)ChP->IndexAddr,(USHORT)(ChP->RxFIFOPtrs + 2)); /* clear Rx in ptr */
   sOutW(ChP->IndexData,0);
   ChP->TxPrioCnt = ChOff + _TXP_CNT;
   sOutW((WIOA_T)ChP->IndexAddr,(USHORT)ChP->TxPrioCnt);
   sOutB((PUCHAR)ChP->IndexData,0);
   ChP->TxPrioPtr = ChOff + _TXP_PNTR;
   sOutW((WIOA_T)ChP->IndexAddr,(USHORT)ChP->TxPrioPtr);
   sOutB((PUCHAR)ChP->IndexData,0);
   ChP->TxPrioBuf = ChOff + _TXP_BUF;
   sEnRxProcessor(ChP);                /* start the Rx processor */

   return(TRUE);
}

/*****************************************************************************
Function: sGetRxErrStatus
Purpose:  Get a channel's receive error status
Call:     sGetRxErrStatus(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   unsigned char: Receive error status, can be 0 if there are no
                         errors or any combination of the following flags:
                             STMBREAK:   BREAK
                             STMFRAME:   framing error
                             STMRCVROVR: receiver over run error
                             STMPARITY:  parity error
Warnings: The channel must be in Rx Status Mode (see sEnRxStatusMode())
          before calling this function.

          No context switches are allowed while executing this function.
-------------------------------------------------------------------------*/
unsigned char _CDECL sGetRxErrStatus(CHANPTR_T ChP)
{
  unsigned int RxFIFOOut;             /* Rx FIFO out status ptr */

  sOutW((WIOA_T)ChP->IndexAddr, (USHORT)ChP->RxFIFOPtrs); /* get Rx FIFO out status ptr */
  RxFIFOOut = sInW(ChP->IndexData) * 2 + 1;
  sOutW((WIOA_T)ChP->IndexAddr, (USHORT)(ChP->RxFIFO + RxFIFOOut)); /* return the status */
  return(sInB((PUCHAR)ChP->IndexData) & (STMBREAK | STMFRAME | STMPARITY | STMRCVROVR));
}

/***************************************************************************
Function: sSetParity
Purpose:  Set parity to none, odd, or even.
Call:     sSetParity(ChP,Parity)
          CHANPTR_T ChP; Ptr to channel structure
          int Parity; Parity, can be one of the following:
                      0: no parity
                      1: odd parity
                      2: even parity
Return:   void
Comments: Function sSetParity() can be used in place of functions sEnParity(),
          sDisParity(), sSetOddParity(), and sSetEvenParity().
-------------------------------------------------------------------------*/
void _CDECL sSetParity(CHANPTR_T ChP,int Parity)
{
  if (Parity == 0)
  {
    ChP->TxControl[2] &= ~PARITY_EN;
  }
  else if (Parity == 1)
  {
    ChP->TxControl[2] |= PARITY_EN;

    ChP->TxControl[2]  &= ~EVEN_PAR;
  }
  else if (Parity == 2)
  {
    ChP->TxControl[2] |= (PARITY_EN | EVEN_PAR);
  }
  sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->TxControl[0]);
}

/***************************************************************************
Function: sStopRxProcessor
Purpose:  Stop the receive processor from processing a channel's microcode.
Call:     sStopRxProcessor(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: The receive processor can be started again with sStartRxProcessor().
          This function causes the receive processor to skip over the
          microcode for the stopped channel.  It does not stop it from
          processing other channels.
Warnings: No context switches are allowed while executing this function.

          Do not leave the receive processor stopped for more than one
          character time.

          After calling this function a delay of 4 uS is required to ensure
          that the receive processor is no longer processing microcode for
          this channel.
-------------------------------------------------------------------------*/
void _CDECL sStopRxProcessor(CHANPTR_T ChP)
{
  unsigned char MCode[4];             /* 1st two microcode bytes */

  MCode[0] = ChP->MCode[0];
  MCode[1] = ChP->MCode[1];
  MCode[3] = ChP->MCode[3];

  MCode[2] = 0x0a;            /* inc scan cnt inst to freeze Rx proc */
  sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&MCode[0]);
}

/***************************************************************************
Function: sStopSWInFlowCtl
Purpose:  Stop the receive processor from processing a channel's
          software input flow control microcode.
Call:     sStopSWInFlowCtl(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: The receive processor can be started again with sStartRxProcessor().
          This function causes the receive processor to skip over the
          software input flow control microcode for the stopped channel.
          It does not stop it from processing other channels.
Warnings: No context switches are allowed while executing this function.

          After calling this function a delay of 1 uS is required to ensure
          that the receive processor is no longer processing software input
          flow control microcode for this channel.
-------------------------------------------------------------------------*/
void _CDECL sStopSWInFlowCtl(CHANPTR_T ChP)
{
  unsigned char MCode[4];             /* 1st two microcode bytes */

  MCode[0] = ChP->MCode[0];
  MCode[1] = ChP->MCode[1];
  MCode[2] = ChP->MCode[2];

  MCode[3] = 0x0a;            /* inc scan cnt inst to freeze Rx proc */
  sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&MCode[0]);
}

/***************************************************************************
Function: sFlushRxFIFO
Purpose:  Flush the Rx FIFO
Call:     sFlushRxFIFO(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: To prevent data from being enqueued or dequeued in the Tx FIFO
          while it is being flushed the receive processor is stopped
          and the transmitter is disabled.  After these operations a
          4 uS delay is done before clearing the pointers to allow
          the receive processor to stop.  These items are handled inside
          this function.
Warnings: No context switches are allowed while executing this function.
-------------------------------------------------------------------------*/
void _CDECL sFlushRxFIFO(CHANPTR_T ChP)
{
  int i;
  unsigned char Ch;                   /* channel number within AIOP */
  int RxFIFOEnabled;                  /* TRUE if Rx FIFO enabled */

  if (sGetRxCnt(ChP) == 0)             /* Rx FIFO empty */
    return;                          /* don't need to flush */

  RxFIFOEnabled = FALSE;
  if (ChP->MCode[RXFIFO_DATA] == RXFIFO_EN) /* Rx FIFO is enabled */
  {
    RxFIFOEnabled = TRUE;
    sDisRxFIFO(ChP);                 /* disable it */
    for (i = 0;i < 2000/200;i++) /* delay 2 uS to allow proc to disable FIFO*/
      sInB(ChP->IntChan);
  }
  sGetChanStatus(ChP);          /* clear any pending Rx errors in chan stat */
  Ch = (unsigned char)sGetChanNum(ChP);
  sOutB(ChP->Cmd, (UCHAR)(Ch | RESRXFCNT));     /* apply reset Rx FIFO count */
  sOutB(ChP->Cmd,Ch);                 /* remove reset Rx FIFO count */
  sOutW((WIOA_T)ChP->IndexAddr, (USHORT)(ChP->RxFIFOPtrs)); /* clear Rx out ptr */
  sOutW(ChP->IndexData,0);
  sOutW((WIOA_T)ChP->IndexAddr, (USHORT)(ChP->RxFIFOPtrs + 2)); /* clear Rx in ptr */
  sOutW(ChP->IndexData, 0);
  if (RxFIFOEnabled)
    sEnRxFIFO(ChP);                  /* enable Rx FIFO */
}

/***************************************************************************
Function: sFlushTxFIFO
Purpose:  Flush the Tx FIFO
Call:     sFlushTxFIFO(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: To prevent data from being enqueued or dequeued in the Tx FIFO
          while it is being flushed the receive processor is stopped
          and the transmitter is disabled.  After these operations a
          4 uS delay is done before clearing the pointers to allow
          the receive processor to stop.  These items are handled inside
          this function.
Warnings: No context switches are allowed while executing this function.
-------------------------------------------------------------------------*/
void _CDECL sFlushTxFIFO(CHANPTR_T ChP)
{
  int i;
  unsigned char Ch;                   /* channel number within AIOP */
  int TxEnabled;                      /* TRUE if transmitter enabled */

  if (sGetTxCnt(ChP) == 0)             /* Tx FIFO empty */
    return;                          /* don't need to flush */

  TxEnabled = FALSE;
  if (ChP->TxControl[3] & TX_ENABLE)
  {
    TxEnabled = TRUE;
    sDisTransmit(ChP);               /* disable transmitter */
  }
  sStopRxProcessor(ChP);              /* stop Rx processor */
  for (i = 0;i < 4000/200;i++)         /* delay 4 uS to allow proc to stop */
    sInB(ChP->IntChan);
  Ch = (unsigned char)sGetChanNum(ChP);
  sOutB(ChP->Cmd,(UCHAR)(Ch | RESTXFCNT));     /* apply reset Tx FIFO count */
  sOutB(ChP->Cmd,Ch);                 /* remove reset Tx FIFO count */
  sOutW((WIOA_T)ChP->IndexAddr, (USHORT)(ChP->TxFIFOPtrs)); /* clear Tx in/out ptrs */
  sOutW(ChP->IndexData,0);
  if (TxEnabled)
    sEnTransmit(ChP);                /* enable transmitter */
  sStartRxProcessor(ChP);             /* restart Rx processor */
}

/***************************************************************************
Function: sFlushTxPriorityBuf
Purpose:  Flush the Tx priority buffer
Call:     sFlushTxPriorityBuf(ChP,unsigned char *Data)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char *Data; Next data byte to be transmitted from the
             Tx priority buffer before the flush occurred, if any.  If
             the return value is TRUE a byte is returned in "Data," if
             the return value is FALSE nothing is returned in "Data."
Return:   int: TRUE if there was data in the Tx priority buffer before
               the flush occurs.  In this case the next byte that would
               have been transmitted is returned in the "Data" parameter.
               FALSE if there was no data in the Tx priority buffer before
               the flush.
Comments: This flush returns the next byte in the priority buffer to
          allow that byte to be sent via sWriteTxByte() after all
          transmit flushing is complete.  This is done to allow pending
          XON and XOFF bytes to be transmitted regardless of the flush.
Warnings: No context switches are allowed while executing this function.
-------------------------------------------------------------------------*/
int _CDECL sFlushTxPriorityBuf(CHANPTR_T ChP,unsigned char *Data)
{
  unsigned int PrioState;       /* Tx prio buf status, count, and pointer */
  unsigned int BufOff;          /* Offset of next data byte in Tx prio buf */
  WIOA_T IndexAddr;
  WIOA_T IndexData;

  IndexAddr = (WIOA_T)ChP->IndexAddr;
  IndexData = (WIOA_T)ChP->IndexData;
  sDisTransmit(ChP);

  sOutW(IndexAddr, (USHORT)ChP->TxPrioCnt); /* get priority buf status */

  PrioState = sInW(IndexData);
  if (PrioState & PRI_PEND)            /* data in Tx prio buf */
  {
    BufOff = PrioState >> 8;   /* get offset of next data byte in buf */
    sOutW(IndexAddr,(USHORT)(ChP->TxPrioBuf + BufOff));
    *Data = sInB((BIOA_T)IndexData); /* return next data byte */
    sEnTransmit(ChP);
    return(TRUE);
  }

  sEnTransmit(ChP);                   /* no data in Tx prio buf */
  return(FALSE);
}

/***************************************************************************
Function: sGetTxPriorityCnt
Purpose:  Get the number of data bytes in the Tx priority buffer
Call:     sGetTxPriorityCnt(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   unsigned char: The number of data bytes in the Tx FIFO.
Warnings: No context switches are allowed while executing this function.
-------------------------------------------------------------------------*/
unsigned char _CDECL sGetTxPriorityCnt(CHANPTR_T ChP)
{
  unsigned char Cnt;

  sOutW((WIOA_T)ChP->IndexAddr, (USHORT)ChP->TxPrioCnt); /* get priority buf status */
  Cnt = sInB((BIOA_T)ChP->IndexData);
  if (Cnt & PRI_PEND)
    return(Cnt & 0x1f);              /* only lower 5 bits contain count */
  else
    return(0);
}


#ifndef INTEL_ORDER
/*---------------------------------------------------------------------
  sReadRxBlk - MIPS VERSION
|---------------------------------------------------------------------*/
int _CDECL sReadRxBlk(CHANPTR_T ChP,unsigned char *Buffer,int Count)
{
  int RetCount;
  int WordCount;

  int ByteCount = 0;
  unsigned short TempWord;

  RetCount = sGetRxCnt(ChP);          /* number bytes in Rx FIFO */

  /* are there pending chars? */
  if (RetCount <= 0)                   /* no data available */
    return(0x0);
  if (RetCount > Count)                /* only dequeue as much as requested */
    RetCount = Count;

  WordCount = RetCount >> 1;     /* compute count as words */
  while (WordCount--)
  {
    TempWord = sInW((WIOA_T)sGetTxRxDataIO(ChP));
    Buffer[ByteCount++] = TempWord & 0xff;
    Buffer[ByteCount++] = ( TempWord >> 8 ) & 0xff;
  }
  if (RetCount & 1)
  {
    Buffer[ByteCount++] = sInB( (BIOA_T)sGetTxRxDataIO(ChP));
  }

  return(RetCount);
}
#else   // NOT MIPS version
/*------------------------------------------------------------------------
Function: sReadRxBlk - X86 INTEL VERSION
Purpose:  Read a block of receive data from a channel
Call:     sReadRxBlk(ChP,Buffer,Count)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char *Buffer; Ptr to buffer for receive data
          int Count; Max number of bytes to read
Return:   int: Number of bytes actually read from the channel
Warnings: Buffer must be large enough to hold Count characters.

          This function must not be called when in Rx Status Mode.
-------------------------------------------------------------------------*/
int _CDECL sReadRxBlk(CHANPTR_T ChP,unsigned char *Buffer,int Count)
{
  int RetCount;
  int WordCount;
  USHORT UNALIGNED *WordP;
  WIOA_T io;

  RetCount = sGetRxCnt(ChP);          // number bytes in Rx FIFO 

  // are there pending chars?
  if (RetCount <= 0)                   // no data available
    return(0x0);
  if (RetCount > Count)                // only dequeue as much as requested
    RetCount = Count;


  WordCount = RetCount >> 1;          // compute count as words 
  WordP = (USHORT UNALIGNED *)Buffer;     // word ptr to buffer

  io = sGetTxRxDataIO(ChP);
#ifdef WORD_ALIGN
  while (WordCount--)
  {
    *WordP++ = sInW(io);
  }
#else
  sInStrW((PUSHORT)io, WordP, WordCount);
#endif

  if (RetCount & 1)                    // odd count 
  {
    Buffer[RetCount - 1] = sInB((PUCHAR)io); // read last byte
  }

  return(RetCount);
}
#endif  // INTEL X86 version


#ifndef INTEL_ORDER
/*---------------------------------------------------------------------
  sWriteTxBlk - MIPS VERSION
|---------------------------------------------------------------------*/
ULONG _CDECL sWriteTxBlk(CHANPTR_T ChP,PUCHAR Buffer,ULONG Count)
{
  ULONG RetCount;
  ULONG WordCount;
  unsigned short TempWordLo;
  unsigned short TempWordHi;
  int ByteCount = 0;

  RetCount = MAXTX_SIZE - (int)sGetTxCnt(ChP); /* open space in Tx FIFO*/
  if (RetCount <= 0)                   /* no space available */
    return(0x0);
  if (RetCount > Count)
    RetCount = Count;                /* only enqueue as much as requested */

  WordCount = RetCount >> 1 ;     /* compute count as words */
  while (WordCount--)
  {
    TempWordLo = Buffer[ByteCount++] & 0xff;
    TempWordHi = Buffer[ByteCount++];
    TempWordHi = (TempWordHi << 8) & 0xff00; /* shift to high byte */
    TempWordHi |= TempWordLo;
    sOutW((PUCHAR)sGetTxRxDataIO(ChP), TempWordHi);
  }

  if (RetCount & 1)
  {
    sOutB( (PUCHAR)sGetTxRxDataIO(ChP), Buffer[ByteCount++] );
  }

  return(RetCount);
}

#else // NOT MIPS
/*------------------------------------------------------------------------
Function: sWriteTxBlk
Purpose:  Write a block of transmit data to a channel
Call:     sWriteTxBlk(ChP,Buffer,Count)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char *Buffer; Ptr to buffer containing data to transmit
          int Count; Size of buffer in bytes
Return:   int: Number of bytes actually written to the channel
-------------------------------------------------------------------------*/
ULONG _CDECL sWriteTxBlk(CHANPTR_T ChP,PUCHAR Buffer,ULONG Count)
{
  ULONG RetCount;
  ULONG WordCount;
  USHORT UNALIGNED *WordP;
  WIOA_T io;

  // 250, restrict to WORD amounts (boundary access thing)
  RetCount = MAXTX_SIZE - sGetTxCnt(ChP);

  if (RetCount > Count)
  {
    RetCount = Count;                /* only enqueue as much as requested */

#ifdef WORD_ALIGN
    // try to keep aligned on WORD boundary
    //if (RetCount & 1)
    //{
    //  if (RetCount > 1)
    //    --RetCount;
    //}
#endif
  }

  if (RetCount <= 0)                   // no space or nothing to send
    return 0;

  WordCount = RetCount >> 1;          /* compute count as words */
  WordP = (PUSHORT)Buffer;            /* word ptr to buffer */
  io = sGetTxRxDataIO(ChP);

  /* Write the data */
#ifdef WORD_ALIGN
  while( WordCount-- )
  {
     sOutW(io, *WordP++);
  }
#else
  sOutStrW(io,WordP,WordCount);
#endif

  if (RetCount & 1)                    /* odd count */
  {
    WordP=WordP+WordCount;
    sOutB((PUCHAR)io, Buffer[RetCount - 1]); /* send last byte */
  }

  return(RetCount);
}
#endif


/*--------------------------------------------------------------------------
Function: sWriteTxPrioBlk
Purpose:  Write a block of priority transmit data to a channel
Call:     sWriteTxPrioBlk(ChP,Buffer,Count)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char *Buffer; Ptr to buffer containing data to transmit
          int Count; Size of buffer in bytes, TXP_SIZE bytes maximum.  If
                     Count > TXP_SIZE only TXP_SIZE bytes will be written.
Return:   int: Number of bytes actually written to the channel, 0 if none
               written.
Comments: The entire block of priority data is transmitted before any data
          in the Tx FIFO.
Warnings: No context switches are allowed while executing this function.
-------------------------------------------------------------------------*/
int _CDECL sWriteTxPrioBlk(CHANPTR_T ChP,unsigned char *Buffer,int Count)
{
  unsigned char DWBuf[4];                 /* buffer for double word writes */
  register DWIOA_T IndexAddr;
  int WordCount,i;
  unsigned int UNALIGNED *WordP;
  unsigned int *DWBufLoP;
  unsigned int *DWBufHiP;

  IndexAddr = ChP->IndexAddr;
  sOutW((WIOA_T)IndexAddr,(USHORT)ChP->TxPrioCnt);    /* get priority queue status */
  if (sInB((BIOA_T)ChP->IndexData) & PRI_PEND) /* priority queue busy */
    return(0);                            /* nothing sent */

  if (Count > TXP_SIZE)
    Count = TXP_SIZE;
  WordCount = Count >> 1;                 /* compute count as words */
  if (Count & 1)                          /* adjust for odd count */
    WordCount++;
  WordP = (unsigned int *)Buffer;         /* word ptr to buffer */

  DWBufLoP = (unsigned int *)&DWBuf[0];
  DWBufHiP = (unsigned int *)&DWBuf[2];
  *DWBufLoP = ChP->TxPrioBuf;             /* data byte address */
  for(i = 0;i < WordCount;i++)            /* write data to Tx prioity buf */
  {
    *DWBufHiP = WordP[i];                 /* data word value */
    sOutDW(IndexAddr,*(ULONGPTR_T)DWBuf); /* write it out */
    *DWBufLoP += 2;
  }

  *DWBufLoP = ChP->TxPrioCnt;             /* Tx priority count address */
  *DWBufHiP = PRI_PEND + Count;           /* indicate count bytes pending */
  sOutDW(IndexAddr, *(ULONGPTR_T)DWBuf);  /* write it out */
  return(Count);
}

/***************************************************************************
Function: sWriteTxPrioByte
Purpose:  Write a byte of priority transmit data to a channel
Call:     sWriteTxPrioByte(ChP,Data)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Data; The transmit data byte
Return:   int: 1 if the bytes is successfully written, otherwise 0.
Comments: The priority byte is transmitted before any data in the Tx FIFO.
Warnings: No context switches are allowed while executing this function.
-------------------------------------------------------------------------*/
int _CDECL sWriteTxPrioByte(CHANPTR_T ChP,unsigned char Data)
{
  unsigned char DWBuf[4];             /* buffer for double word writes */
  unsigned int UNALIGNED *WordPtr;
  register DWIOA_T IndexAddr;

  /* Don't write to prio buf unless guarenteed Tx FIFO is not empty because
     of bug in AIOP */
  if(sGetTxCnt(ChP) > 1)              /* write it to Tx priority buffer */
  {
    IndexAddr = ChP->IndexAddr;
    sOutW((WIOA_T)IndexAddr, (USHORT)ChP->TxPrioCnt); /* get priority buffer status */
    if (sInB((BIOA_T)ChP->IndexData) & PRI_PEND) /* priority buffer busy */
      return(0);                    /* nothing sent */

    WordPtr = (unsigned int *)(&DWBuf[0]);
    *WordPtr = ChP->TxPrioBuf;       /* data byte address */
    DWBuf[2] = Data;                 /* data byte value */
    sOutDW(IndexAddr, *((ULONGPTR_T)(&DWBuf[0]))); /* write it out */

    *WordPtr = ChP->TxPrioCnt;       /* Tx priority count address */
    DWBuf[2] = PRI_PEND + 1;         /* indicate 1 byte pending */
    DWBuf[3] = 0;                    /* priority buffer pointer */
    sOutDW(IndexAddr, *((ULONGPTR_T)(&DWBuf[0]))); /* write it out */
  }
  else                                /* write it to Tx FIFO */
  {
    sWriteTxByte((BIOA_T)sGetTxRxDataIO(ChP),Data);
  }
  return(1);                          /* 1 byte sent */
}

/***************************************************************************
Function: sEnInterrupts
Purpose:  Enable one or more interrupts for a channel
Call:     sEnInterrupts(ChP,Flags)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned int Flags: Interrupt enable flags, can be any combination
             of the following flags:
                TXINT_EN:   Interrupt on Tx FIFO empty
                RXINT_EN:   Interrupt on Rx FIFO at trigger level (see
                            sSetRxTrigger())
                SRCINT_EN:  Interrupt on SRC (Special Rx Condition)
                MCINT_EN:   Interrupt on modem input change
                CHANINT_EN: Allow channel interrupt signal to the AIOP's
                            Interrupt Channel Register.
Return:   void
Comments: If an interrupt enable flag is set in Flags, that interrupt will be
          enabled.  If an interrupt enable flag is not set in Flags, that
          interrupt will not be changed.  Interrupts can be disabled with
          function sDisInterrupts().

          This function sets the appropriate bit for the channel in the AIOP's
          Interrupt Mask Register if the CHANINT_EN flag is set.  This allows
          this channel's bit to be set in the AIOP's Interrupt Channel Register.

          Interrupts must also be globally enabled before channel interrupts
          will be passed on the the host.  This is done with function
          sEnGlobalInt().

          In some cases it may be desirable to disable interrupts globally but
          enable channel interrupts.  This would allow the global interrupt
          status register to be used to determine which AIOPs need service.
-------------------------------------------------------------------------*/
void _CDECL sEnInterrupts(CHANPTR_T ChP,unsigned int Flags)
{
  unsigned char Mask;                 /* Interrupt Mask Register */


  ChP->RxControl[2] |=
     ((unsigned char)Flags & (RXINT_EN | SRCINT_EN | MCINT_EN));

  sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->RxControl[0]);

  ChP->TxControl[2] |= ((unsigned char)Flags & TXINT_EN);

  sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->TxControl[0]);

  if(Flags & CHANINT_EN)
  {
    Mask = sInB(ChP->IntMask) | (1 << ChP->ChanNum);
    sOutB(ChP->IntMask,Mask);
  }
}

/***************************************************************************
Function: sDisInterrupts
Purpose:  Disable one or more interrupts for a channel
Call:     sDisInterrupts(ChP,Flags)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned int Flags: Interrupt flags, can be any combination
             of the following flags:
                TXINT_EN:   Interrupt on Tx FIFO empty
                RXINT_EN:   Interrupt on Rx FIFO at trigger level (see
                            sSetRxTrigger())
                SRCINT_EN:  Interrupt on SRC (Special Rx Condition)
                MCINT_EN:   Interrupt on modem input change
                CHANINT_EN: Disable channel interrupt signal to the
                            AIOP's Interrupt Channel Register.
Return:   void
Comments: If an interrupt flag is set in Flags, that interrupt will be
          disabled.  If an interrupt flag is not set in Flags, that
          interrupt will not be changed.  Interrupts can be enabled with
          function sEnInterrupts().

          This function clears the appropriate bit for the channel in the AIOP's
          Interrupt Mask Register if the CHANINT_EN flag is set.  This blocks
          this channel's bit from being set in the AIOP's Interrupt Channel
          Register.
-------------------------------------------------------------------------*/
void _CDECL sDisInterrupts(CHANPTR_T ChP,unsigned int Flags)
{
  unsigned char Mask;                 /* Interrupt Mask Register */

  ChP->RxControl[2] &=
        ~((unsigned char)Flags & (RXINT_EN | SRCINT_EN | MCINT_EN));
  sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->RxControl[0]);
  ChP->TxControl[2] &= ~((unsigned char)Flags & TXINT_EN);
  sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->TxControl[0]);

  if(Flags & CHANINT_EN)
  {
    Mask = sInB(ChP->IntMask) & (~(1 << ChP->ChanNum));
    sOutB(ChP->IntMask,Mask);
  }
}

/***************************************************************************
Function: sReadMicrocode
Purpose:  Read the microcode directly from a channel
Call:     sReadMicrocode(ChP,Buffer,Count)
          CHANPTR_T ChP; Ptr to channel structure
          char *Buffer; Ptr to buffer for microcode
          int Count; Number of bytes to read
Return:   void
Warnings: Buffer must be large enough to hold Count bytes.
-------------------------------------------------------------------------*/
void _CDECL sReadMicrocode(CHANPTR_T ChP,char *Buffer,int Count)
{
  WIOA_T IndexAddr;
  BIOA_T IndexData;
  unsigned int McodeOff;

  IndexAddr = (WIOA_T)ChP->IndexAddr;
  IndexData = (BIOA_T)ChP->IndexData;
  McodeOff = MCODE_ADDR + (unsigned int)sGetChanNum(ChP) * 0x1000;

  while(Count-- > 0)
  {
    sOutW(IndexAddr,(USHORT)(McodeOff++));
    *Buffer++ = sInB((BIOA_T)IndexData);
  }
}


/*------------------------------------------------------------------
 sSetBaudRate - Set the desired baud rate.  Return non-zero on error.
|-------------------------------------------------------------------*/
int sSetBaudRate(CHANNEL_T *ChP,
                 ULONG desired_baud,
                 USHORT SetHardware)
{
  ULONG diff;
  ULONG act_baud;
  ULONG percent_error;
  ULONG div;
  ULONG base_clock_rate;
  ULONG clock_freq = ChP->CtlP->ClkRate;
  ULONG clk_prescaler = (ULONG)ChP->CtlP->ClkPrescaler;

  base_clock_rate = ((clock_freq/16) / ((clk_prescaler & 0xf)+1));

  ///////////////////////////////////////
  // calculate the divisor for our hardware register.
  // this is really just div = clk/desired_baud -1.  but we do some
  // work to minimize round-off error.
  if (desired_baud <= 0)
    desired_baud = 1;  // guard against div 0

  div =  ((base_clock_rate+(desired_baud>>1)) / desired_baud) - 1;
  if (div > 8191)  // overflow hardware divide register
    div = 8191;

  // this is really just (clk) / (div+1) but we do some
     // work to minimize round-off error.
  act_baud = (base_clock_rate+((div+1)>>1)) / (div+1);

  if (desired_baud > act_baud)
    diff = desired_baud - act_baud;
  else
    diff = act_baud - desired_baud;

  percent_error = (diff * 100) / desired_baud;
  if (percent_error > 5)
    return (int) percent_error;

  if (SetHardware)
  {
    sChanOutWI(ChP, _BAUD, div);
  }
  return 0;

}

/*------------------------------------------------------------------
Function: sChanOutWI
Purpose:  Write an Indirect Register on the Rocket Port Board
Call:     sChanOutWI(CHANNEL_T *ChP, WORD RegNum,  WORD val)
          CHANPTR_T ChP; Ptr to channel structure
          WORD RegNum;   Indirect Register Number to Write
          WORD val;      Value to Write.
Return:   void
Comments: This is a little slower than using macros but far less ugly
          and error prone.  Macros should only be used where speed is
          imperative.
|-------------------------------------------------------------------*/
void sChanOutWI(CHANNEL_T *ChP, USHORT RegNum, ULONG  val)
{
  UCHAR m[4];
  USHORT ChOff;

   ChOff = ChP->ChanNum * 0x1000;   // change this to look up table
             // see about speeding this up:
   m[0] = (unsigned char)(ChOff + RegNum);
   m[1] = (unsigned char)((ChOff + RegNum) >> 8);
   m[2] = (unsigned char) val;
   m[3] = (unsigned char)(val >> 8);
   sOutDW(ChP->IndexAddr,*(ULONG *)&m[0]);
}

/*------------------------------------------------------------------
Function: sModemReset
Purpose:  Set or clear reset state on second generation RocketModem
Call:     sModemReset(CHANNEL_T *ChP, int on)
          CHANNEL_T *ChP; Ptr to channel structure
          int on;         on!=0 to enable reset; on=0 to clear reset
Return:   void
Comments: The newer RocketModem boards power up in a reset state.
          This routine is used to clear the board from reset state or
          re-enable a reset state.  Called from the driver during
          initialization to clear the reset and via an ioctl to
          manually reset the board.  [jl] 980206
BUGBUG: this code violates io-resource handling under NT and will
  probably break running on ALPHA machines due to bypassing NT's
  io-mapping scheme(i.e. should not be doing AiopIO[1] = AiopIO[0] +..)
  Also, this driver is probably not calling IoResource calls to claim
  this IO space properly(could result in conflicting hardware.)
|-------------------------------------------------------------------*/
void sModemReset(CHANNEL_T *ChP, int on)
{
  CONTROLLER_T *CtlP;
  WIOA_T    addr;
  BYTE    val;

  CtlP = ChP->CtlP;

  if (CtlP->BusType == Isa)
  {
    // ensure second aiop CS is enabled.  there will be no physical
    // aiop to enable, but the CS (which ususally goes to an aiop
    // is routed to a latch, which latches the RESET signal.  we
    // have to also ensure that the mudback-Isa bus controller
    // aiopic io-addr has been configured for the proper address
    // space.  since the rocketmodem Isa product is limited to
    // eight ports, we know that the second aiop will be configured
    // 400h above the first eight port aiop chip...
     val = sInB(CtlP->MBaseIO + 3);

    // read in, see if aiop[1] enabled...
    if ((CtlP->AiopIO[1] != (PUSHORT)((unsigned int)(CtlP->AiopIO[0]) + 0x400)) ||
        ((val & 2) == 0))
    {
      // cr second aiop chip not enabled. Isa board alias
       CtlP->AiopIO[1] = (PUSHORT)((unsigned int)(CtlP->AiopIO[0]) + 0x400);

      // tell mudback where to position the base-io of the aiopic...
       val = sInB(CtlP->MBaseIO + 2); // read in irq, aiop-io reg
       sOutB(CtlP->MBaseIO + 2, (BYTE)((val & 0xfc) | (1 & 0x03))); //aiop index

      // setup aiop i/o in mudbac...
       sOutB(CtlP->MBaseIO, (BYTE)((unsigned int)CtlP->AiopIO[1] >> 6));
     }
    sEnAiop(CtlP,1);      //  enable the (un)AIOP
   }
  else if (CtlP->BusType == PCIBus)
  {
    // PCI bus RocketModem reset...
    // we reference where the second AIOP would be, if there were one,..
     CtlP->AiopIO[1] = (PUSHORT)((unsigned int)CtlP->AiopIO[0] + 0x40);
   }

  // the latch has 3-pin mux which determines which latch the
  // data gets routed to.  these pins are hooked to the first
  // three address lines.  the fourth address line (8h) is used
  // as the data line.
   addr = CtlP->AiopIO[1];

  // adjust reset state...
   sOutB(((PUCHAR)(addr) + ChP->ChanNum + (on ? 0 : 8)), 0);

  // disable the aiop; must disable to prevent chip select from getting hit
  // with continuous pulses (causing reset to occur).

  // additionally it seems that a read of some other address is required
  // before the disable or the first channel on the board goes back into the
  // reset state.  there's nothing special about ChP->IntChan...a read of
  // any port would probably work...
   sInB(ChP->IntChan);

  if (CtlP->BusType == Isa)
  {
    sDisAiop(CtlP, 1);
  }
}

/*------------------------------------------------------------------
Function: sModemWriteROW
Purpose:  Send the "Rest of World" configuration string to the
          RocketModem port.
Call:     sModemSendROW(CHANNEL_T *ChP, USHORT CountryCode)
          CHANNEL_T *ChP;     Ptr to channel structure
          USHORT CountryCode; Country to configure the modem for
Return:   void
Comments: The ROW "SocketModem" RocketModem boards can compensate for
          the differences in various internation phone systems.  This
          function sends the appropriate configuration string based
          upon a registry setting specified by the user. [jl] 980316

          Modem should be hard reset before calling this function. Otherwise,
          use AT modem reset commands...
|-------------------------------------------------------------------*/
void sModemWriteROW(CHANNEL_T *ChP, USHORT CountryCode)
{
    CONTROLLER_T *CtlP = ChP->CtlP;
    char *ModemConfigString = {"AT*NCxxZ\r"};
    int   max;

    MyKdPrint(D_Init,("sModemWriteROW: %x, %x\n",(unsigned long)ChP,CountryCode)) // DEBUG

    if (CountryCode == ROW_NA) {
        MyKdPrint(D_Init,("ROW Write, North America\n"))
        return;
    }
/*
    create the country config string...
*/
    ModemConfigString[5] = '0' + (CountryCode / 10);
    ModemConfigString[6] = '0' + (CountryCode % 10);
    MyKdPrint(D_Init,("ROW Write, Chan:%d, Cfg:%s\n", ChP->ChanNum, ModemConfigString))

    time_stall(10); // TUNE       
    
    sFlushTxFIFO(ChP);     
    sFlushRxFIFO(ChP);     

    sSetBaudRate(ChP,9600,TRUE);
    sSetData8(ChP);

    sClrTxXOFF(ChP);
  
    sEnRTSFlowCtl(ChP);
    sEnCTSFlowCtl(ChP);
 
    if (sGetChanStatus(ChP) & STATMODE) {
        sDisRxStatusMode(ChP);
    }

    sGetChanIntID(ChP);

    sEnRxFIFO(ChP);     
    sEnTransmit(ChP);
        
    sSetRTS(ChP);
/*
    spin while port readies...
*/
    time_stall(10);

    sModemWriteDelay(ChP,ModemConfigString,strlen(ModemConfigString));

    (void) sModemRead(ChP,"OK",sizeof("OK\r") - 1,10);
   
    time_stall(1);

    sFlushRxFIFO(ChP);

    sClrRTS(ChP);
}

/*------------------------------------------------------------------
Function: sModemSpeakerEnable
Purpose:  Enable RocketModemII board speaker
Call:     sModemSpeakerEnable(CHANNEL_T *ChP)
          CHANNEL_T *ChP; Ptr to channel structure
Return:   void
Comments: Called from the driver during initialization to 
          enable the board speaker.
|-------------------------------------------------------------------*/
void sModemSpeakerEnable(CHANNEL_T *ChP)
{
    CONTROLLER_T *CtlP;
    WIOA_T    addr;
    BYTE    val;

    CtlP = ChP->CtlP;
/*
    PCI bus RocketModem reset...
*/
    if (CtlP->BusType != PCIBus)
        return;
/*
    we reference where the second AIOP would be,..
*/
    CtlP->AiopIO[1] = (PUSHORT)((unsigned int)CtlP->AiopIO[0] + 0x40);
/*
    the latch has 3-pin mux which determines which latch the
    data gets routed to.  these pins are hooked to the first
    three address lines.  the fourth address line (8h) is used
    as the data line...
*/
    addr = CtlP->AiopIO[1];
/*
    following is hack to enable the speaker (PCI cards only). we don't want
    to construct an extension and related storage for a speaker, so we'll
    just piggyback the enable of the speaker onto another channel...
*/
    sOutB(((PUCHAR)(addr) + 7 + 8), 0);
}

/*------------------------------------------------------------------
Function: sModemWriteDelay
Purpose:  Send a string to the RocketModem port, pausing for each character
     to clear the FIFO.
Call:     sModemSendROW(CHANNEL_T *ChP, char *string,int length)
     CHANNEL_T *ChP;     Ptr to channel structure
     char *string;       String to write
     int  length         Length of string, not including any trailing null
Return:   void
Comments: Output characters one at a time
|-------------------------------------------------------------------*/

void 
sModemWriteDelay(CHANNEL_T *ChP,char *string,int length)
{
    int   index,count;
    unsigned char  buffer[2];

    sFlushTxFIFO(ChP);
    sFlushRxFIFO(ChP);

    if (
    (length <= 0) 
    || 
    (string == (char *)NULL)
    )
        return;

    index = 0;
    count = 0;

    while (length--) {
        while (count = (int)sGetTxCnt(ChP)) {
/*
    byte or bytes in transmit FIFO. wait a while. adjust interval...
*/
            ms_time_stall(10 * count);
/*
    no change? assume FIFO stuck, bail out of loop...
*/
            if (count == (int)sGetTxCnt(ChP)) {
                break;
            }
        }
/*
    transmit FIFO probably available. put a byte in it, pause a moment...
*/
        sWriteTxByte((BIOA_T)sGetTxRxDataIO(ChP),(unsigned char)string[index]);

        ++index;
    }
}

/********************************************************************

   send string to modem...

*********************************************************************/
void 
sModemWrite(CHANNEL_T *ChP, char *string, int length)
{
    if (
    (length <= 0) 
    || 
    (string == (char *)NULL)
    )
        return;

    sWriteTxBlk(ChP, (unsigned char *)string, length);
}

/********************************************************************

   look for match on a particular character string...

********************************************************************/
int sModemRead(CHANNEL_T *ChP, char *string,int length, int poll_retries)
{
    unsigned char    buffer;
    long    count;
    int     arg_index;
    int     read_retries;
    WIOA_T  io;
    unsigned int   fifo_data;

#ifdef DUMPDATA
    DumpIndex = 0; 
#endif
/*
    bail if board not installed...
*/
    fifo_data = (unsigned int)sGetRxCnt(ChP);
/*
    see if board installed and functioning. if not, architecture returns
    bad value. if so, stonewall on read...
*/
    if (fifo_data > (unsigned int)RXFIFO_SIZE)
    return(-1);
   
    io = sGetTxRxDataIO(ChP);

    poll_retries *= 10;

    buffer = (char)0;

    arg_index = 0;
/*
    search until we see a match on the argument characters, or we run out of data...
*/
    do {
        while (sGetRxCnt(ChP) > 0) {
            buffer = sReadRxByte((PUCHAR)io);

#ifdef DUMPDATA
            DumpResponseByte(buffer);
#endif
/*
    force response to upper case, since responses are different depending on
    whether the modem was loaded already or not...
*/
            if (buffer >= 'a')
                buffer ^= 0x20;

            if (string[arg_index] == buffer) {
                ++arg_index;
/*
    see if we're done. if so, bail with good return code...
*/
                if (arg_index == length) {
                    time_stall(TENTH_SECOND);
#ifdef DUMPDATA
                    while (sGetRxCnt(ChP) > 0) {
                        buffer = sReadRxByte((PUCHAR)io);
                        DumpResponseByte(buffer);
                    }
                    MyKdPrint(D_Init,("sModemRead: %x [%s]\n",(unsigned long)ChP,DumpArray))
#endif
                    sFlushRxFIFO(ChP);
                    return(0);
                }
            }
            else {
                arg_index = 0;
            }
        }

        ms_time_stall(10);
    } while (poll_retries-- > 0);

#ifdef DUMPDATA
    MyKdPrint(D_Init,("sModemRead: %x [%s]\n",(unsigned long)ChP,DumpArray))
#endif

    return(-1);
}

/********************************************************************

   look for match on two possibilities...

********************************************************************/
int sModemReadChoice(CHANNEL_T *ChP,
    char *string0,
    int length0,
    char *string1,
    int length1,
    int poll_retries)
{
    char    buffer;
    long    count;
    int     arg_index0;
    int     arg_index1;
    char    *ptr;
    WIOA_T  io;
    unsigned int   fifo_data;

#ifdef DUMPDATA
    DumpIndex = 0;
#endif
    MyKdPrint(D_Init,("sModemReadChoice: %x\n",(unsigned long)ChP))

    poll_retries *= 10;
/*
    bail if board not installed...
*/
    fifo_data = (unsigned int)sGetRxCnt(ChP);
/*
    see if board installed and functioning. if not, architecture returns
    likely -1. if so, stonewall on read...
*/
    if (fifo_data > (unsigned int)RXFIFO_SIZE)
        return(-1);

    io = sGetTxRxDataIO(ChP);

    buffer = (char)0;

    arg_index0 = 0;
    arg_index1 = 0;
/*
    first, we discard characters until we see a match on the argument characters, 
    or we run out of data...
*/
    do {
        while (sGetRxCnt(ChP) > 0) {
            buffer = sReadRxByte((PUCHAR)io);

#ifdef DUMPDATA
            DumpResponseByte(buffer);
#endif
/*
    force response to upper case, since responses can be different depending on 
    whether the modem was loaded already or not...
*/
            if (buffer >= 'a')
                buffer ^= 0x20;
/*
    check first argument...
*/
            if (string0[arg_index0] == buffer) {
                ++arg_index0;
/*
    see if we're done matching on string 0...
*/
                if (arg_index0 >= length0) {
                    time_stall(TENTH_SECOND);

#ifdef DUMPDATA
                    while (sGetRxCnt(ChP) > 0) {
                        buffer = sReadRxByte((PUCHAR)io);
                        DumpResponseByte(buffer);
                    }
                    MyKdPrint(D_Init,("sModemReadChoice: %x\r\n[%s]\n",(unsigned long)ChP,DumpArray))
#endif
                    sFlushRxFIFO(ChP);
                    return(0);
                }
            }
            else {
                arg_index0 = 0;
            }
/*
    check argument 1...
*/
            if (string1[arg_index1] == buffer) {
                ++arg_index1;
/*
    see if we're done matching on string 1...
*/
                if (arg_index1 >= length1) {
                    time_stall(TENTH_SECOND);

#ifdef DUMPDATA
                    while (sGetRxCnt(ChP) > 0) {
                        buffer = sReadRxByte((PUCHAR)io);
                        DumpResponseByte(buffer);
                    }
                    MyKdPrint(D_Init,("sModemReadChoice: %x\r\n[%s]\n",(unsigned long)ChP,DumpArray))
#endif
                    sFlushRxFIFO(ChP);
                    return(1);
                }
            }
            else {
                arg_index1 = 0;
            }
        }

        ms_time_stall(10);

    } while (poll_retries-- > 0);
/*
    no match...
*/
#ifdef DUMPDATA
    MyKdPrint(D_Init,("sModemReadChoice: %x\r\n[%s]\n",(unsigned long)ChP,DumpArray))
#endif

    sFlushRxFIFO(ChP);

    return(-1);
}

/********************************************************************

   check transmit FIFO...

*********************************************************************/
int sTxFIFOStatus(CHANNEL_T *ChP)
{
    unsigned int fifo_size;
/*
    see if board installed and functioning. if not, architecture returns
    bad count. if so, stonewall on fifo ready...
*/
    fifo_size = (unsigned int)sGetTxCnt(ChP);

    if (fifo_size > (unsigned int)TXFIFO_SIZE)
        return(MAXTX_SIZE);

    if (MAXTX_SIZE <= (unsigned int)sGetTxCnt(ChP))
        return(MAXTX_SIZE);
/*
    return number of data bytes in FIFO...
*/
    return(sGetTxCnt(ChP));
}

/********************************************************************

  check available space in transmit FIFO. there's two checks here:
  one for whether the FIFO is present;
  one for whether the FIFO is full...

*********************************************************************/
int sTxFIFOReady(CHANNEL_T *ChP)
{
    unsigned int   fifo_size;
/*
    see if board installed and functioning. if not, architecture likely returns
    a bad value. if so, stonewall on fifo ready...
*/
    fifo_size = (unsigned int)sGetTxCnt(ChP);

    if (fifo_size > (unsigned int)TXFIFO_SIZE)
        return(0);
/*
    if number of data bytes currently in FIFO is greater than the
    available space, return busy for now...
*/
    if (sGetTxCnt(ChP) >= MAXTX_SIZE)
        return(0);
/*
    return (size of FIFO - number of data bytes in FIFO)...
*/
    return(MAXTX_SIZE - sGetTxCnt(ChP));
}

/********************************************************************

  discard pending data in receive FIFO. pull in data until data
  runs out or count goes to zero...

*********************************************************************/
int sRxFIFOReady(CHANNEL_T *ChP)
{
    unsigned char   buffer;
    int     retries;
    WIOA_T  io;
    unsigned int  count;

    count = (unsigned int)sGetRxCnt(ChP);

    if (count > (unsigned int)RXFIFO_SIZE)
        return(-1);

    if (!count)
        return(0);

    retries = 20;

    io = sGetTxRxDataIO(ChP);

    do {
        count = RXFIFO_SIZE + 2;            // set to size of FIFO + slop...

        while (
        (sGetRxCnt(ChP)) 
        && 
        (count--)
        ) {
            buffer = sReadRxByte((PUCHAR)io);
        }
/*
    if receive FIFO is now empty, bail out. if it was full, though,
    pause a moment and then check to see if it has refilled -
    if it has, flush that, and then check again. what we're trying to do
    here is empty the FIFO, and still detect a run-on condition...
*/
        if (count)
            return(0);

        ms_time_stall(10);

    } while (--retries);
/*
    receive FIFO didn't empty, though we gave it several chances...
*/
    return(-1);
}

#ifdef DUMPDATA

/********************************************************************

   dump responses to log...

********************************************************************/
void DumpResponseByte(char buffer)
{
    if (DumpIndex < sizeof(DumpArray) - 2) {
        switch (buffer) {
            case '\n': {
                DumpArray[DumpIndex++] = '\\';
                DumpArray[DumpIndex++] = 'n';
                break;
            }

            case '\r': {
                DumpArray[DumpIndex++] = '\\';
                DumpArray[DumpIndex++] = 'r';
                break;
            }

            case '\t': {
                DumpArray[DumpIndex++] = '\\';
                DumpArray[DumpIndex++] = 't';
                break;
            }

            case '\0': {
                DumpArray[DumpIndex++] = '\\';
                DumpArray[DumpIndex++] = '0';
                break;
            }

            default: {
                if (buffer < ' ') {
                    DumpArray[DumpIndex++] = '?';    
                }
                else {
                    DumpArray[DumpIndex++] = buffer;
                }
            }
        }

        DumpArray[DumpIndex] = 0;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\read.h ===
//---- read.h

NTSTATUS
SerialRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialStartRead(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

VOID
SerialCompleteRead(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialCancelCurrentRead(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

VOID
SerialReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialIntervalReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

ULONG
SerialGetCharsFromIntBuffer(
    PSERIAL_DEVICE_EXTENSION Extension
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\utils.c ===
/*-------------------------------------------------------------------
| utils.c -
    This module contains code that perform queueing and completion
    manipulation on requests.
1-21-99  fix tick count [#] on peer traces. kpb.
11-24-98 Minor adjustment to purge to when WaitOnTx selected. kpb.
6-01-98 Add modem reset/row routines (generic for VS and Rkt)
3-18-98 Add time_stall function for modem settle time after reset clear - jl
3-04-98 Add synch. routine back in to synch up to isr service routine. kpb.
7-10-97 Adjust SerialPurgeTxBuffers to not purge tx-hardware buffer
  as per MS driver.  Now we only purge it if it is flowed-off.

Copyright 1993-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

//-- local funcs
BOOLEAN SerialPurgeRxBuffers(IN PVOID Context);
BOOLEAN SerialPurgeTxBuffers(IN PVOID Context, int always);
NTSTATUS SerialStartFlush(IN PSERIAL_DEVICE_EXTENSION Extension);

static char *szParameters = {"\\Parameters"};

/*----------------------------------------------------------------------------
 SyncUp - sync up to either the IRQ or Timer-DPC.  If an Interrupt is
  used, then we must use KeSynchronizeExecution(), if a timer-dpc is used
  then we 
|----------------------------------------------------------------------------*/
VOID SyncUp(IN PKINTERRUPT IntObj,
            IN PKSPIN_LOCK SpinLock,
            IN PKSYNCHRONIZE_ROUTINE SyncProc,
            IN PVOID Context)
{
 KIRQL OldIrql;

  if (IntObj != NULL)
  {
    KeSynchronizeExecution(IntObj, SyncProc, Context);
  }
  else // assume spinlock, using timer
  {
    KeAcquireSpinLock(SpinLock, &OldIrql);
    SyncProc(Context);
    KeReleaseSpinLock(SpinLock, OldIrql );
  }
}

/*--------------------------------------------------------------------------
 SerialKillAllReadsOrWrites -
    This function is used to cancel all queued and the current irps
    for reads or for writes.
Arguments:
    DeviceObject - A pointer to the serial device object.
    QueueToClean - A pointer to the queue which we're going to clean out.
    CurrentOpIrp - Pointer to a pointer to the current irp.
Return Value:
    None.
|--------------------------------------------------------------------------*/
VOID
SerialKillAllReadsOrWrites(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLIST_ENTRY QueueToClean,
    IN PIRP *CurrentOpIrp
    )
{

  KIRQL cancelIrql;
  PDRIVER_CANCEL cancelRoutine;

  // We acquire the cancel spin lock.  This will prevent the
  // irps from moving around.
  IoAcquireCancelSpinLock(&cancelIrql);

  // Clean the list from back to front.
  while (!IsListEmpty(QueueToClean))
  {
    PIRP currentLastIrp = CONTAINING_RECORD(
                              QueueToClean->Blink,
                              IRP,
                              Tail.Overlay.ListEntry
                              );

    RemoveEntryList(QueueToClean->Blink);

    cancelRoutine = currentLastIrp->CancelRoutine;
    currentLastIrp->CancelIrql = cancelIrql;
    currentLastIrp->CancelRoutine = NULL;
    currentLastIrp->Cancel = TRUE;

    cancelRoutine( DeviceObject, currentLastIrp );

    IoAcquireCancelSpinLock(&cancelIrql);

  }

  // The queue is clean.  Now go after the current if it's there.
  if (*CurrentOpIrp)
  {
    cancelRoutine = (*CurrentOpIrp)->CancelRoutine;
    (*CurrentOpIrp)->Cancel = TRUE;

    // If the current irp is not in a cancelable state
    // then it *will* try to enter one and the above
    // assignment will kill it.  If it already is in
    // a cancelable state then the following will kill it.

    if (cancelRoutine)
    {
      (*CurrentOpIrp)->CancelRoutine = NULL;
      (*CurrentOpIrp)->CancelIrql = cancelIrql;

      // This irp is already in a cancelable state.  We simply
      // mark it as canceled and call the cancel routine for it.

      cancelRoutine( DeviceObject, *CurrentOpIrp );
    }
    else
    {
        IoReleaseCancelSpinLock(cancelIrql);
    }
  }
  else
  {
      IoReleaseCancelSpinLock(cancelIrql);
  }
}


/*--------------------------------------------------------------------------
 SerialGetNextIrp -
    This function is used to make the head of the particular
    queue the current irp.  It also completes the what
    was the old current irp if desired.
Arguments:
    CurrentOpIrp - Pointer to a pointer to the currently active
                   irp for the particular work list.  Note that
                   this item is not actually part of the list.
    QueueToProcess - The list to pull the new item off of.
    NextIrp - The next Irp to process.  Note that CurrentOpIrp
              will be set to this value under protection of the
              cancel spin lock.  However, if *NextIrp is NULL when
              this routine returns, it is not necessaryly true the
              what is pointed to by CurrentOpIrp will also be NULL.
              The reason for this is that if the queue is empty
              when we hold the cancel spin lock, a new irp may come
              in immediately after we release the lock.
    CompleteCurrent - If TRUE then this routine will complete the
                      irp pointed to by the pointer argument
                      CurrentOpIrp.
Return Value: None.
|--------------------------------------------------------------------------*/
VOID
SerialGetNextIrp(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent,
    IN PSERIAL_DEVICE_EXTENSION extension
    )
{
  PIRP oldIrp;
  KIRQL oldIrql;

  IoAcquireCancelSpinLock(&oldIrql);

  oldIrp = *CurrentOpIrp;

  if (oldIrp) {
    if (CompleteCurrent)
    {
      MyAssert(!oldIrp->CancelRoutine);
    }
  }

  // Check to see if there is a new irp to start up.
  if (!IsListEmpty(QueueToProcess))
  {
    PLIST_ENTRY headOfList;

    headOfList = RemoveHeadList(QueueToProcess);

    *CurrentOpIrp = CONTAINING_RECORD(
                        headOfList,
                        IRP,
                        Tail.Overlay.ListEntry
                        );

    IoSetCancelRoutine( *CurrentOpIrp, NULL );
  }
  else
  {
    *CurrentOpIrp = NULL;
  }

  *NextIrp = *CurrentOpIrp;
  IoReleaseCancelSpinLock(oldIrql);

  if (CompleteCurrent)
  {
    if (oldIrp) {
      SerialCompleteRequest(extension, oldIrp, IO_SERIAL_INCREMENT);
    }
  }
}


/*--------------------------------------------------------------------------
SerialTryToCompleteCurrent -
    This routine attempts to kill all of the reasons there are
    references on the current read/write.  If everything can be killed
    it will complete this read/write and try to start another.
    NOTE: This routine assumes that it is called with the cancel
          spinlock held.
Arguments:
    Extension - Simply a pointer to the device extension.
    SynchRoutine - A routine that will synchronize with the isr
                   and attempt to remove the knowledge of the
                   current irp from the isr.  NOTE: This pointer
                   can be null.
    IrqlForRelease - This routine is called with the cancel spinlock held.
                     This is the irql that was current when the cancel
                     spinlock was acquired.
    StatusToUse - The irp's status field will be set to this value, if
                  this routine can complete the irp.
Return Value:
    None.
|--------------------------------------------------------------------------*/
VOID
SerialTryToCompleteCurrent(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
    IN KIRQL IrqlForRelease,
    IN NTSTATUS StatusToUse,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess OPTIONAL,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL,
    IN PSERIAL_START_ROUTINE Starter OPTIONAL,
    IN PSERIAL_GET_NEXT_ROUTINE GetNextIrp OPTIONAL,
    IN LONG RefType
    )
{
 KIRQL OldIrql;

  // We can decrement the reference to "remove" the fact
  // that the caller no longer will be accessing this irp.

  SERIAL_CLEAR_REFERENCE(*CurrentOpIrp, RefType);

  if (SynchRoutine)
  {
#ifdef USE_SYNC_LOCKS
    if (Driver.InterruptObject != NULL)
    {
      KeSynchronizeExecution(Driver.InterruptObject, SynchRoutine, Extension);
    }
    else // assume spinlock, using timer dpc
    {
      KeAcquireSpinLock(&Driver.TimerLock, &OldIrql);
      SynchRoutine(Extension);
      KeReleaseSpinLock(&Driver.TimerLock, OldIrql );
    }
#else
    SynchRoutine(Extension);
#endif
  }

  // Try to run down all other references to this irp.
  SerialRundownIrpRefs(
      CurrentOpIrp,
      IntervalTimer,
      TotalTimer
      );

  // See if the ref count is zero after trying to kill everybody else.
  if (!SERIAL_REFERENCE_COUNT(*CurrentOpIrp))
  {
    PIRP newIrp;
    // The ref count was zero so we should complete this request.
    // The following call will also cause the current irp to be completed.
    (*CurrentOpIrp)->IoStatus.Status = StatusToUse;

    if (StatusToUse == STATUS_CANCELLED)
    {
      (*CurrentOpIrp)->IoStatus.Information = 0;
    }

    if (GetNextIrp)
    {
      IoReleaseCancelSpinLock(IrqlForRelease);

      GetNextIrp(
          CurrentOpIrp,
          QueueToProcess,
          &newIrp,
          TRUE,
          Extension
          );

      if (newIrp) {
        Starter(Extension);
      }
    }
    else
    {
      PIRP oldIrp = *CurrentOpIrp;

      // There was no get next routine.  We will simply complete
      // the irp.  We should make sure that we null out the
      // pointer to the pointer to this irp.

      *CurrentOpIrp = NULL;

      IoReleaseCancelSpinLock(IrqlForRelease);

      SerialCompleteRequest(Extension, oldIrp, IO_SERIAL_INCREMENT);
    }
  }
  else
  {
      IoReleaseCancelSpinLock(IrqlForRelease);
  }
}

/*--------------------------------------------------------------------------
 SerialRundownIrpRefs -
    This routine runs through the various items that *could*
    have a reference to the current read/write.  It try's to kill
    the reason.  If it does succeed in killing the reason it
    will decrement the reference count on the irp.
    NOTE: This routine assumes that it is called with the cancel
          spin lock held.
Arguments:
    CurrentOpIrp - Pointer to a pointer to current irp for the
                   particular operation.
    IntervalTimer - Pointer to the interval timer for the operation.
                    NOTE: This could be null.
    TotalTimer - Pointer to the total timer for the operation.
                 NOTE: This could be null.
Return Value:
    None.
|--------------------------------------------------------------------------*/
VOID
SerialRundownIrpRefs(
    IN PIRP *CurrentOpIrp,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL
    )
{
  // This routine is called with the cancel spin lock held
  // so we know only one thread of execution can be in here
  // at one time.
  // First we see if there is still a cancel routine.  If
  // so then we can decrement the count by one.
  if ((*CurrentOpIrp)->CancelRoutine)
  {
    SERIAL_CLEAR_REFERENCE(*CurrentOpIrp, SERIAL_REF_CANCEL);
    IoSetCancelRoutine(
        *CurrentOpIrp,
        NULL
        );
  }
  if (IntervalTimer)
  {
    // Try to cancel the operations interval timer.  If the operation
    // returns true then the timer did have a reference to the
    // irp.  Since we've canceled this timer that reference is
    // no longer valid and we can decrement the reference count.
    // If the cancel returns false then this means either of two things:
    // a) The timer has already fired.
    // b) There never was an interval timer.
    // In the case of "b" there is no need to decrement the reference
    // count since the "timer" never had a reference to it.
    // In the case of "a", then the timer itself will be coming
    // along and decrement it's reference.  Note that the caller
    // of this routine might actually be the this timer, but it
    // has already decremented the reference.

    if (KeCancelTimer(IntervalTimer))
    {
        SERIAL_CLEAR_REFERENCE(*CurrentOpIrp,SERIAL_REF_INT_TIMER);
    }
  }

  if (TotalTimer)
  {
    // Try to cancel the operations total timer.  If the operation
    // returns true then the timer did have a reference to the
    // irp.  Since we've canceled this timer that reference is
    // no longer valid and we can decrement the reference count.
    // If the cancel returns false then this means either of two things:
    // a) The timer has already fired.
    // b) There never was an total timer.
    // In the case of "b" there is no need to decrement the reference
    // count since the "timer" never had a reference to it.
    // In the case of "a", then the timer itself will be coming
    // along and decrement it's reference.  Note that the caller
    // of this routine might actually be the this timer, but it
    // has already decremented the reference.

    if (KeCancelTimer(TotalTimer))
    {
        SERIAL_CLEAR_REFERENCE(*CurrentOpIrp,SERIAL_REF_TOTAL_TIMER);
    }
  }
}

/*--------------------------------------------------------------------------
 SerialStartOrQueue -
    This routine is used to either start or queue any requst
    that can be queued in the driver.
Arguments:
    Extension - Points to the serial device extension.
    Irp - The irp to either queue or start.  In either
          case the irp will be marked pending.
    QueueToExamine - The queue the irp will be place on if there
                     is already an operation in progress.
    CurrentOpIrp - Pointer to a pointer to the irp the is current
                   for the queue.  The pointer pointed to will be
                   set with to Irp if what CurrentOpIrp points to
                   is NULL.
    Starter - The routine to call if the queue is empty.
Return Value:
    This routine will return STATUS_PENDING if the queue is
    not empty.  Otherwise, it will return the status returned
    from the starter routine (or cancel, if the cancel bit is
    on in the irp).
|--------------------------------------------------------------------------*/
NTSTATUS
SerialStartOrQueue(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PSERIAL_START_ROUTINE Starter
    )
{
  KIRQL oldIrql;

  IoAcquireCancelSpinLock(&oldIrql);

  // If this is a write irp then take the amount of characters
  // to write and add it to the count of characters to write.
  if (IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_WRITE)
  {
    Extension->TotalCharsQueued +=
        IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length;

  } else if ((IoGetCurrentIrpStackLocation(Irp)->MajorFunction
              == IRP_MJ_DEVICE_CONTROL) &&
             ((IoGetCurrentIrpStackLocation(Irp)
               ->Parameters.DeviceIoControl.IoControlCode ==
               IOCTL_SERIAL_IMMEDIATE_CHAR) ||
              (IoGetCurrentIrpStackLocation(Irp)
               ->Parameters.DeviceIoControl.IoControlCode ==
               IOCTL_SERIAL_XOFF_COUNTER)))
  {
      Extension->TotalCharsQueued++;  // immediate char
  }

  if ((IsListEmpty(QueueToExamine)) && !(*CurrentOpIrp))
  {
    // There was no current operation.  Mark this one as
    // current and start it up.
    *CurrentOpIrp = Irp;

    IoReleaseCancelSpinLock(oldIrql);

    return Starter(Extension);
  }
  else
  {
    // We don't know how long the irp will be in the
    // queue.  So we need to handle cancel.
    if (Irp->Cancel)
    {
      IoReleaseCancelSpinLock(oldIrql);

      Irp->IoStatus.Status = STATUS_CANCELLED;

      SerialCompleteRequest(Extension, Irp, 0);

      return STATUS_CANCELLED;

    }
    else
    {

      Irp->IoStatus.Status = STATUS_PENDING;
      IoMarkIrpPending(Irp);

      InsertTailList(
          QueueToExamine,
          &Irp->Tail.Overlay.ListEntry
          );

      IoSetCancelRoutine( Irp, SerialCancelQueued );

      IoReleaseCancelSpinLock(oldIrql);

      return STATUS_PENDING;
    }
  }
}

/*--------------------------------------------------------------------------
 SerialCancelQueued -
    This routine is used to cancel Irps that currently reside on
    a queue.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP to be canceled.
Return Value:
    None.
|--------------------------------------------------------------------------*/
VOID
SerialCancelQueued(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
  PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
  PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

  Irp->IoStatus.Status = STATUS_CANCELLED;
  Irp->IoStatus.Information = 0;

  RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

  // If this is a write irp then take the amount of characters
  // to write and subtract it from the count of characters to write.
  if (irpSp->MajorFunction == IRP_MJ_WRITE)
  {
    extension->TotalCharsQueued -= irpSp->Parameters.Write.Length;
  }
  else if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL)
  {
    // If it's an immediate then we need to decrement the
    // count of chars queued.  If it's a resize then we
    // need to deallocate the pool that we're passing on
    // to the "resizing" routine.
    if ((irpSp->Parameters.DeviceIoControl.IoControlCode ==
         IOCTL_SERIAL_IMMEDIATE_CHAR) ||
        (irpSp->Parameters.DeviceIoControl.IoControlCode ==
         IOCTL_SERIAL_XOFF_COUNTER))
    {
      extension->TotalCharsQueued--;
    }

#ifdef COMMENT_OUT
//#ifdef DYNAMICQUEUE // Dynamic transmit queue size
    else if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
               IOCTL_SERIAL_SET_QUEUE_SIZE)
    {
      // We shoved the pointer to the memory into the
      // the type 3 buffer pointer which we KNOW we
      // never use.
      MyAssert(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

      our_free(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

      irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    }
#endif //DYNAMICQUEUE

  }

  IoReleaseCancelSpinLock(Irp->CancelIrql);

  SerialCompleteRequest(extension, Irp, IO_SERIAL_INCREMENT);
}

/*--------------------------------------------------------------------------
Routine Description:
    If the current irp is not an IOCTL_SERIAL_GET_COMMSTATUS request and
    there is an error and the application requested abort on errors,
    then cancel the irp.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP to test.
Return Value:
    STATUS_SUCCESS or STATUS_CANCELLED.
|--------------------------------------------------------------------------*/
NTSTATUS
SerialCompleteIfError(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
  PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
  NTSTATUS status = STATUS_SUCCESS;

  if ((extension->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) &&
      extension->ErrorWord)
  {

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    // There is a current error in the driver.  No requests should
    // come through except for the GET_COMMSTATUS.

    if ((irpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL) ||
        (irpSp->Parameters.DeviceIoControl.IoControlCode !=
         IOCTL_SERIAL_GET_COMMSTATUS))
    {
      status = STATUS_CANCELLED;
      Irp->IoStatus.Status = STATUS_CANCELLED;
      Irp->IoStatus.Information = 0;

      SerialCompleteRequest(extension, Irp, 0);
    }
  }
  return status;
}


/*--------------------------------------------------------------------------
Routine Description:
    This routine is invoked at dpc level to in response to
    a comm error.  All comm errors kill all read and writes
Arguments:
    Dpc - Not Used.
    DeferredContext - Really points to the device object.
    SystemContext1 - Not Used.
    SystemContext2 - Not Used.
Return Value:
    None.
|--------------------------------------------------------------------------*/
VOID
SerialCommError(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{

  PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;

  UNREFERENCED_PARAMETER(Dpc);
  UNREFERENCED_PARAMETER(SystemContext1);
  UNREFERENCED_PARAMETER(SystemContext2);

  SerialKillAllReadsOrWrites(
      Extension->DeviceObject,
      &Extension->WriteQueue,
      &Extension->CurrentWriteIrp
      );

  SerialKillAllReadsOrWrites(
      Extension->DeviceObject,
      &Extension->ReadQueue,
      &Extension->CurrentReadIrp
      );

}

/*--------------------------------------------------------------------------
Routine Description:
    This is the dispatch routine for flush.  Flushing works by placing
    this request in the write queue.  When this request reaches the
    front of the write queue we simply complete it since this implies
    that all previous writes have completed.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request
Return Value:
    Could return status success, cancelled, or pending.
|--------------------------------------------------------------------------*/
NTSTATUS SerialFlush(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
  PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;

  ExtTrace(Extension,D_Ioctl,("Flush"))

  Irp->IoStatus.Information = 0L;

  if (SerialIRPPrologue(Extension) == TRUE)
  {
    if (Extension->ErrorWord)
    {
      if (SerialCompleteIfError( DeviceObject, Irp ) != STATUS_SUCCESS)
      {
        return STATUS_CANCELLED;
      }
    }

    return SerialStartOrQueue(
             Extension,
             Irp,
             &Extension->WriteQueue,
             &Extension->CurrentWriteIrp,
             SerialStartFlush
             );
  }
  else
  {
    Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
    return STATUS_NO_SUCH_DEVICE;
  }

}

/*--------------------------------------------------------------------------
Routine Description:
    This routine is called if there were no writes in the queue.
    The flush became the current write because there was nothing
    in the queue.  Note however that does not mean there is
    nothing in the queue now!  So, we will start off the write
    that might follow us.
Arguments:
    Extension - Points to the serial device extension
Return Value:
    This will always return STATUS_SUCCESS.
|--------------------------------------------------------------------------*/
NTSTATUS SerialStartFlush(IN PSERIAL_DEVICE_EXTENSION Extension)
{
  PIRP NewIrp;

  Extension->CurrentWriteIrp->IoStatus.Status = STATUS_SUCCESS;

  // The following call will actually complete the flush.

  SerialGetNextWrite(
      &Extension->CurrentWriteIrp,
      &Extension->WriteQueue,
      &NewIrp,
      TRUE,
      Extension
      );

  if (NewIrp)
  {
    MyAssert(NewIrp == Extension->CurrentWriteIrp);
    SerialStartWrite(Extension);
  }

  return STATUS_SUCCESS;

}

/*--------------------------------------------------------------------------
 SerialStartPurge -
Routine Description:
    Depending on the mask in the current irp, purge the interrupt
    buffer, the read queue, or the write queue, or all of the above.
Arguments:
    Extension - Pointer to the device extension.
Return Value:
    Will return STATUS_SUCCESS always.  This is reasonable
    since the DPC completion code that calls this routine doesn't
    care and the purge request always goes through to completion
    once it's started.
|--------------------------------------------------------------------------*/
NTSTATUS SerialStartPurge(IN PSERIAL_DEVICE_EXTENSION Extension)
{
  PIRP NewIrp;
  do
  {
    ULONG Mask;
    Mask = *((ULONG *)
           (Extension->CurrentPurgeIrp->AssociatedIrp.SystemBuffer));

    if (Mask & SERIAL_PURGE_RXABORT)
    {
      SerialKillAllReadsOrWrites(
          Extension->DeviceObject,
          &Extension->ReadQueue,
          &Extension->CurrentReadIrp
          );
    }

    if (Mask & SERIAL_PURGE_RXCLEAR)
    {
      KIRQL OldIrql;
      // Flush the Rocket Tx FIFO
      KeAcquireSpinLock(
          &Extension->ControlLock,
          &OldIrql
          );

//    KeSynchronizeExecution(
//          Driver.Interrupt,
//          SerialPurgeRxBuffers,
//          Extension
//          );
      SerialPurgeRxBuffers(Extension);

      KeReleaseSpinLock(
          &Extension->ControlLock,
          OldIrql
          );
    }

    if (Mask & SERIAL_PURGE_TXABORT)
    {
      SerialKillAllReadsOrWrites(
          Extension->DeviceObject,
          &Extension->WriteQueue,
          &Extension->CurrentWriteIrp
          );
      SerialKillAllReadsOrWrites(
          Extension->DeviceObject,
          &Extension->WriteQueue,
          &Extension->CurrentXoffIrp
          );

      if (Extension->port_config->WaitOnTx)
      {
        // if they have this option set, then
        // really do a purge of tx hardware buffer.
        SerialPurgeTxBuffers(Extension, 1);
      }

    }

    if (Mask & SERIAL_PURGE_TXCLEAR)
    {
      KIRQL OldIrql;

      // Flush the Rocket Rx FIFO and the system side buffer
      // Note that we do this under protection of the
      // the drivers control lock so that we don't hose
      // the pointers if there is currently a read that
      // is reading out of the buffer.
      KeAcquireSpinLock(&Extension->ControlLock, &OldIrql);

//    KeSynchronizeExecution(
//         Driver.Interrupt,
//         SerialPurgeTxBuffers,
//         Extension
//         );
      if (Extension->port_config->WaitOnTx)
        SerialPurgeTxBuffers(Extension, 1);  // force
      else
        SerialPurgeTxBuffers(Extension, 0);  // only if flowed off

      KeReleaseSpinLock(&Extension->ControlLock, OldIrql);
    }

    Extension->CurrentPurgeIrp->IoStatus.Status = STATUS_SUCCESS;
    Extension->CurrentPurgeIrp->IoStatus.Information = 0;

    SerialGetNextIrp(
        &Extension->CurrentPurgeIrp,
        &Extension->PurgeQueue,
        &NewIrp,
        TRUE,
        Extension
        );

  } while (NewIrp);

  return STATUS_SUCCESS;
}

/*--------------------------------------------------------------------------
Routine Description:
    Flushes out the Rx data pipe: Rocket Rx FIFO, Host side Rx buffer
    NOTE: This routine is being called from KeSynchronizeExecution.
Arguments:
    Context - Really a pointer to the device extension.
|--------------------------------------------------------------------------*/
BOOLEAN SerialPurgeRxBuffers(IN PVOID Context)
{
  PSERIAL_DEVICE_EXTENSION Extension = Context;

  q_flush(&Extension->RxQ);        // flush our rx buffer

#ifdef S_VS
  PortFlushRx(Extension->Port);    // flush rx hardware
#else
  sFlushRxFIFO(Extension->ChP);
  //Extension->RxQ.QPut = Extension->RxQ.QGet = 0;
#endif

  return FALSE;
}

/*--------------------------------------------------------------------------
Routine Description:
    Flushes the Rocket Tx FIFO
    NOTE: This routine is being called from KeSynchronizeExecution(not).
Arguments:
    Context - Really a pointer to the device extension.
|--------------------------------------------------------------------------*/
BOOLEAN SerialPurgeTxBuffers(IN PVOID Context, int always)
{
  PSERIAL_DEVICE_EXTENSION Extension = Context;

/* The stock com-port driver does not purge its hardware queue,
   but just ignores TXCLEAR.  Since we do flow-control in hardware
   buffer and have a larger buffer, we will purge it only if it
   is "stuck" or flowed off.

   This hopefully provides a somewhat compatible and useful match.

   We shouldn't need to check for EV_TXEMPTY here, as the ISR will
   take care of this.
 */

#ifdef S_VS
  // check for tx-flowed off condition
  if ((Extension->Port->msr_value & MSR_TX_FLOWED_OFF) || always)
    PortFlushTx(Extension->Port);    // flush tx hardware
#else
  {
    int TxCount;
    ULONG wstat;

    if (always)
    {
      sFlushTxFIFO(Extension->ChP);
    }
    else
    {
      wstat = sGetChanStatusLo(Extension->ChP);

      // check for tx-flowed off condition
      if ((wstat & (TXFIFOMT | TXSHRMT)) == TXSHRMT)
      {
        wstat = sGetChanStatusLo(Extension->ChP);
        if ((wstat & (TXFIFOMT | TXSHRMT)) == TXSHRMT)
        {
          TxCount = sGetTxCnt(Extension->ChP);
          ExtTrace1(Extension,D_Ioctl,"Purge %d bytes from Hardware.", TxCount);
          sFlushTxFIFO(Extension->ChP);
        }
      }
    }
  }
#endif

  return FALSE;
}

/*--------------------------------------------------------------------------
Routine Description:
    This routine is used to query the end of file information on
    the opened serial port.  Any other file information request
    is retured with an invalid parameter.
    This routine always returns an end of file of 0.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request
Return Value:
    The function value is the final status of the call
|--------------------------------------------------------------------------*/
NTSTATUS
SerialQueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
  // The status that gets returned to the caller and
  // set in the Irp.

  NTSTATUS Status;
  BOOLEAN acceptingIRPs;

  // The current stack location.  This contains all of the
  // information we need to process this particular request.

  PIO_STACK_LOCATION IrpSp;

  UNREFERENCED_PARAMETER(DeviceObject);

  acceptingIRPs = SerialIRPPrologue((PSERIAL_DEVICE_EXTENSION)DeviceObject->
             DeviceExtension);

  if (acceptingIRPs == FALSE)
  {
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
    SerialCompleteRequest((PSERIAL_DEVICE_EXTENSION)DeviceObject->
      DeviceExtension, Irp, IO_NO_INCREMENT);
    return STATUS_NO_SUCH_DEVICE;
  }

  if (SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS)
  {
    return STATUS_CANCELLED;
  }
  IrpSp = IoGetCurrentIrpStackLocation(Irp);
  Irp->IoStatus.Information = 0L;
  Status = STATUS_SUCCESS;
  if (IrpSp->Parameters.QueryFile.FileInformationClass ==
      FileStandardInformation)
  {
    PFILE_STANDARD_INFORMATION Buf = Irp->AssociatedIrp.SystemBuffer;
    Buf->AllocationSize = RtlConvertUlongToLargeInteger(0ul);
    Buf->EndOfFile = Buf->AllocationSize;
    Buf->NumberOfLinks = 0;
    Buf->DeletePending = FALSE;
    Buf->Directory = FALSE;
    Irp->IoStatus.Information = sizeof(FILE_STANDARD_INFORMATION);
  }
  else if (IrpSp->Parameters.QueryFile.FileInformationClass ==
           FilePositionInformation)
  {
    ((PFILE_POSITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer)->
      CurrentByteOffset = RtlConvertUlongToLargeInteger(0ul);
    Irp->IoStatus.Information = sizeof(FILE_POSITION_INFORMATION);
  }
  else
  {
    Status = STATUS_INVALID_PARAMETER;
  }

  Irp->IoStatus.Status = Status;
  SerialCompleteRequest((PSERIAL_DEVICE_EXTENSION)DeviceObject->
       DeviceExtension, Irp, 0);

  return Status;

}

/*--------------------------------------------------------------------------
Routine Description:
    This routine is used to set the end of file information on
    the opened serial port.  Any other file information request
    is retured with an invalid parameter.
    This routine always ignores the actual end of file since
    the query information code always returns an end of file of 0.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request
Return Value:
The function value is the final status of the call
|--------------------------------------------------------------------------*/
NTSTATUS
SerialSetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
  // The status that gets returned to the caller and
  // set in the Irp.
  NTSTATUS Status;
  BOOLEAN acceptingIRPs;

  UNREFERENCED_PARAMETER(DeviceObject);

  acceptingIRPs = SerialIRPPrologue((PSERIAL_DEVICE_EXTENSION)DeviceObject->
             DeviceExtension);

  if (acceptingIRPs == FALSE)
  {
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
    SerialCompleteRequest((PSERIAL_DEVICE_EXTENSION)DeviceObject->
      DeviceExtension, Irp, IO_NO_INCREMENT);
    return STATUS_NO_SUCH_DEVICE;
  }

  if (SerialCompleteIfError( DeviceObject, Irp ) != STATUS_SUCCESS)
  {
    return STATUS_CANCELLED;
  }

  Irp->IoStatus.Information = 0L;

  if ((IoGetCurrentIrpStackLocation(Irp)->
          Parameters.SetFile.FileInformationClass ==
       FileEndOfFileInformation) ||
      (IoGetCurrentIrpStackLocation(Irp)->
          Parameters.SetFile.FileInformationClass ==
       FileAllocationInformation))
  {
    Status = STATUS_SUCCESS;
  }
  else
  {
    Status = STATUS_INVALID_PARAMETER;
  }

  Irp->IoStatus.Status = Status;

  SerialCompleteRequest((PSERIAL_DEVICE_EXTENSION)DeviceObject->
    DeviceExtension, Irp, 0);

  return Status;
}

/*--------------------------------------------------------------------------
 UToC1 -  Simple convert from NT-Unicode string to c-string.
  !!!!!!!Uses a statically(static prefix) allocated buffer!!!!!
  This means that it is NOT re-entrant.  Which means only one thread can
  use this call at a time.  Also, a thread could get in trouble if it
  tried to use it twice recursively(calling a function that uses this,
  which calls a function which uses this.)  Since these translator functions
  are used mainly during driver initialization and teardown, we do not have
  to worry about multiple callers at that time.  Any calls which may be
  time sliced(port-calls) should not use this routine due to possible
  time-slice conflict with another thread.  It should allocate a variable
  on the stack and use UToCStr().
|--------------------------------------------------------------------------*/
OUT PCHAR UToC1(IN PUNICODE_STRING ustr)
{
  // we make it a ULONG to avoid alignment problems(gives ULONG alignment).
  static char cstr[140];

  return UToCStr(cstr, ustr, sizeof(cstr));
}

/*--------------------------------------------------------------------------
 UToCStr -
  Purpose:  Convert a Unicode string to c-string.  Used to easily convert
    given a simple char buffer.
  Parameters:
   Buffer - Working buffer to set up the c-string AND ansi_string struct in.
   u_str  - unicode string structure.
   BufferSize - number of bytes in Buffer which we can use.

  Return:  pointer to our c-string on success, NULL on err.
|--------------------------------------------------------------------------*/
OUT PCHAR UToCStr(
         IN OUT PCHAR Buffer,
         IN PUNICODE_STRING ustr,
         IN int BufferSize)
{
  // assume unicode structure over Buffer.
  ANSI_STRING astr;

  astr.Buffer = Buffer;
  astr.Length = 0;
  astr.MaximumLength = BufferSize - 1;

  if (RtlUnicodeStringToAnsiString(&astr,ustr,FALSE) == STATUS_SUCCESS)
    return Buffer; // ok

  MyKdPrint(D_Init,("Bad UToCStr!\n"))
  Buffer[0] = 0;
  return Buffer;
}

/*--------------------------------------------------------------------------
 CToU1 -  Simple convert from c-string to NT-Unicode string.
  !!!!!!!Uses a statically(static prefix) allocated buffer!!!!!
  This means that it is NOT re-entrant.  Which means only one thread can
  use this call at a time.  Also, a thread could get in trouble if it
  tried to use it twice recursively(calling a function that uses this,
  which calls a function which uses this.)  Since these translator functions
  are used mainly during driver initialization and teardown, we do not have
  to worry about multiple callers at that time.  Any calls which may be
  time sliced(port-calls) should not use this routine due to possible
  time-slice conflict with another thread.  It should allocate a variable
  on the stack and use CToUStr().
|--------------------------------------------------------------------------*/
OUT PUNICODE_STRING CToU1(IN const char *c_str)
{
  // we make it a ULONG to avoid alignment problems(gives ULONG alignment).
  static USTR_160 ubuf;  // equal to 160 normal chars length

  return CToUStr(
          (PUNICODE_STRING) &ubuf, // where unicode struct & string gets put
          c_str,                   // our c-string we wish to convert
          sizeof(ubuf));
}

/*--------------------------------------------------------------------------
 CToU2 -  Simple convert from c-string to NT-Unicode string.
  !!!!!!!Uses a statically(static prefix) allocated buffer!!!!!
  This means that it is NOT re-entrant.  Which means only one thread can
  use this call at a time.  Also, a thread could get in trouble if it
  tried to use it twice recursively(calling a function that uses this,
  which calls a function which uses this.)  Since these translator functions
  are used mainly during driver initialization and teardown, we do not have
  to worry about multiple callers at that time.  Any calls which may be
  time sliced(port-calls) should not use this routine due to possible
  time-slice conflict with another thread.  It should allocate a variable
  on the stack and use CToUStr().
|--------------------------------------------------------------------------*/
OUT PUNICODE_STRING CToU2(IN const char *c_str)
{
  // we make it a ULONG to avoid alignment problems(gives ULONG alignment).
  static USTR_160 ubuf;  // equal to 160 normal chars length

  return CToUStr(
          (PUNICODE_STRING) &ubuf, // where unicode struct & string gets put
          c_str,                   // our c-string we wish to convert
          sizeof(ubuf));
}

/*--------------------------------------------------------------------------
  Function: CToUStr
  Purpose:  Convert a c-style null-terminated char[] string to a Unicode string
  Parameters:
   Buffer - Working buffer to set up the unicode structure AND 
     unicode_string in.
   c_str  - normal c-style string.
   BufferSize - number of bytes in Buffer which we can use.

  Return:  pointer to our converted UNICODE_STRING on success, NULL on err.
|-------------------------------------------------------------------------*/
OUT PUNICODE_STRING CToUStr(
         OUT PUNICODE_STRING Buffer,
         IN const char * c_str,
         IN int BufferSize)
{
  // assume unicode structure followed by wchar Buffer.
  USTR_40 *us = (USTR_40 *)Buffer;
  ANSI_STRING astr; // ansi structure, temporary go between

  RtlInitAnsiString(&astr, c_str);  // c-str to ansi-string struct

  // configure the unicode string to: point the buffer ptr to the wstr.
  us->ustr.Buffer = us->wstr;
  us->ustr.Length = 0;
  us->ustr.MaximumLength = BufferSize - sizeof(UNICODE_STRING);

  // now translate from ansi-c-struct-str to unicode-struct-str
  if (RtlAnsiStringToUnicodeString(&us->ustr,&astr,FALSE) == STATUS_SUCCESS)
     return (PUNICODE_STRING) us; // ok - return ptr

  MyKdPrint(D_Init,("Bad CToUStr!\n"))
  return NULL;   // error
}

/*--------------------------------------------------------------------------
  Function: WStrToCStr
  Purpose:  Convert a wide-string to byte-c-style string.
    Assume wstr is null-terminated.
|-------------------------------------------------------------------------*/
VOID WStrToCStr(OUT PCHAR c_str, IN PWCHAR w_str, int max_size)
{
  int i = 0;

  // assume unicode structure followed by wchar Buffer.
  while ((*w_str != 0) && (i < (max_size-1)))
  {
    *c_str = (CHAR) *w_str;
    ++c_str;
    ++w_str;
    ++i;
  }
  *c_str = 0;
}

/*--------------------------------------------------------------------------
  get_reg_value -
|-------------------------------------------------------------------------*/
int get_reg_value(
                  IN HANDLE keyHandle,
                  OUT PVOID outptr,
                  IN PCHAR val_name,
                  int max_size)
{
  NTSTATUS status = STATUS_SUCCESS;
  char tmparr[80];
  PKEY_VALUE_PARTIAL_INFORMATION parInfo =
    (PKEY_VALUE_PARTIAL_INFORMATION) &tmparr[0];
  int stat = 0;
  ULONG length = 0;
  USTR_40 ubuf;  // equal to 40 normal chars length
  PUNICODE_STRING ustr;

  ustr = CToUStr(
         (PUNICODE_STRING) &ubuf, // where unicode struct & string gets put
         val_name,                   // our c-string we wish to convert
         sizeof(ubuf));
  if (ustr == NULL)
    return 3;  // err

  status = ZwQueryValueKey (keyHandle,
                            ustr,  // input reg key name
                            KeyValuePartialInformation,
                            parInfo,
                            sizeof(tmparr) -2,
                            &length);

  if (NT_SUCCESS(status))
  {
    if (parInfo->Type == REG_SZ)
    {
      tmparr[length] = 0;  // null terminate it.
      tmparr[length+1] = 0;  // null terminate it.
      WStrToCStr((PCHAR) outptr, (PWCHAR)&parInfo->Data[0], max_size);
    }
    else if (parInfo->Type == REG_DWORD)
    {
      *((ULONG *)outptr) = *((ULONG *) &parInfo->Data[0]);
    }
    else
    {
      stat = 1;
      MyKdPrint(D_Error,("regStrErr56!\n"))
    }
  }
  else
  {
    stat = 2;
    MyKdPrint(D_Error,("regStrErr57!\n"))
  }

  return stat;
}

#if DBG
/*-----------------------------------------------------------------------
 MyAssertMessage - Our Assertion error message.  We do our own assert
  because the normal DDK ASSERT() macro only works or reports under
  checked build of NT OS.
|-----------------------------------------------------------------------*/
void MyAssertMessage(char *filename, int line)
{
  MyKdPrint(D_Init,("ASSERT FAILED!!! File %s, line %d !!!!\n", filename, line))

#ifdef COMMENT_OUT
  char str[40];
  strcpy(str, "FAIL:");
  strcat(str, filename);
  strcat(str, " ln:%d ");
  mess1(str, line);
#endif
}
#endif

/*-----------------------------------------------------------------------
 EvLog - EvLog an event to NT's event log.
|-----------------------------------------------------------------------*/
void EvLog(char *mess)
{
  static USTR_160 ubuf;  // our own private buffer(static)
  UNICODE_STRING *u;
  NTSTATUS event_type;


  if (mess == NULL)
  {
    MyKdPrint(D_Init,("EvLog Err1!\n"))
    return;
  }
  if ((mess[0] == 'E') && (mess[1] == 'r'))  // "Error..."
    event_type = SERIAL_CUSTOM_ERROR_MESSAGE;
  else if ((mess[0] == 'W') && (mess[1] == 'a'))  // "Warning..."
    event_type = SERIAL_CUSTOM_ERROR_MESSAGE;
  else
    event_type = SERIAL_CUSTOM_INFO_MESSAGE;
 
  u = CToUStr(
         (PUNICODE_STRING) &ubuf, // where unicode struct & string gets put
         mess,                    // our c-string we wish to convert
         sizeof(ubuf));

  if (u==NULL)
  {
    MyKdPrint(D_Init,("EvLog Err2!\n"))
    return;
  }

  // MyKdPrint(D_Init,("EvLog Size:%d, messsize:%d!\n",u->Length, strlen(mess) ))

  EventLog(Driver.GlobalDriverObject,
           STATUS_SUCCESS,
           event_type,  // red"stop" or blue"i"..
           u->Length + sizeof(WCHAR),
           u->Buffer);
}


/*-------------------------------------------------------------------
| our_ultoa -
|--------------------------------------------------------------------*/
char * our_ultoa(unsigned long u, char* s, int radix)
{
  long pow, prevpow;
  int digit;
  char* p;

  if ( (radix < 2) || (36 < radix) )
  {
     *s = 0;
    return s;
  }

  if (u == 0)
  {
    s[0] = '0';
    s[1] = 0;    
    return s;
  }

  p = s;

  for (prevpow=0, pow=1; (u >= (unsigned long)pow) && (prevpow < pow);  pow *= radix)
    prevpow=pow;

  pow = prevpow;

  while (pow != 0)      
  {
    digit = u/pow;

    *p = (digit <= 9) ? ('0'+digit) : ( ('a'-10)+digit);
    p++;

    u -= digit*pow;
    pow /= radix;
  }

  *p = 0;
  return s;
}

/*-------------------------------------------------------------------
| our_ltoa -
|--------------------------------------------------------------------*/
char * our_ltoa(long value, char* s, int radix)
{
  unsigned long u;
  long pow, prevpow;
  int digit;
  char* p;

  if ( (radix < 2) || (36 < radix) )
  {
     *s = 0;
    return s;
  }

  if (value == 0)
  {
    s[0] = '0';
    s[1] = 0;    
    return s;
  }

  p = s;

  if ( (radix == 10) && (value < 0) )
  {
    *p++ = '-';
    value = -value;
  }

  *(long*)&u = value;
  
  for (prevpow=0, pow=1; (u >= (unsigned long)pow) && (prevpow < pow);  pow *= radix)
    prevpow=pow;

  pow = prevpow;

  while (pow != 0)      
  {
    digit = u/pow;

    *p = (digit <= 9) ? ('0'+digit) : ( ('a'-10)+digit);
    p++;

    u -= digit*pow;
    pow /= radix;
  }

  *p = 0;
  return s;
}

/*-------------------------------------------------------------------
| our_assert -
|--------------------------------------------------------------------*/
void our_assert(int id, int line)
{
  Tprintf("Assert %d line:%d!", id, line);
}

/*-------------------------------------------------------------------
| TTprintf - Trace printf with prefix.  Dump trace messages to debug port.
    With TRACE_PORT turned on, this allows us to use a spare port for
    tracing another.
|--------------------------------------------------------------------*/
void __cdecl TTprintf(char *leadstr, const char *format, ...)
{
#ifdef TRACE_PORT
#endif
  char  temp[120];
  va_list  Next;
  int sCount, ls;

  ls = strlen(leadstr);
  memcpy(temp, leadstr, ls);
  temp[ls++] = ' ';

  va_start(Next, format);
  our_vsnprintf(&temp[ls], 78, format, Next);
  sCount = strlen(temp);

  temp[sCount++] = '[';
  our_ultoa( (long) Driver.PollCnt, &temp[sCount], 10);
  sCount += strlen(&temp[sCount]);
  temp[sCount++] = ']';

  temp[sCount++] = 0xd;
  temp[sCount++] = 0xa;
  temp[sCount] = 0;

  TracePut(temp, sCount);

  // dump out to normal nt debug console
  DbgPrint(temp);
}

/*-------------------------------------------------------------------
| Tprintf - Trace printf.  Dump trace messages to debug port.
    With TRACE_PORT turned on, this allows us to use a spare port for
    tracing another.
|--------------------------------------------------------------------*/
void __cdecl Tprintf(const char *format, ...)
{
#ifdef TRACE_PORT
#endif
  char  temp[100];
  va_list  Next;
  int sCount;

  va_start(Next, format);
  our_vsnprintf(temp, 78, format, Next);

  sCount = strlen(temp);
  temp[sCount++] = '[';
  our_ultoa( (long) Driver.PollCnt, &temp[sCount], 10);
  sCount += strlen(&temp[sCount]);
  temp[sCount++] = ']';

  temp[sCount++] = 0xd;
  temp[sCount++] = 0xa;
  temp[sCount] = 0;

  TracePut(temp, sCount);

  // dump out to normal nt debug console
  DbgPrint(temp);
}

/*-------------------------------------------------------------------
| OurTrace - Trace, put data into debug ports buffer.
|--------------------------------------------------------------------*/
void OurTrace(char *leadstr, char *newdata)
{
  char  temp[86];
  int ls, ds;
  ls = strlen(leadstr);
  if (ls > 20)
    ls = 20;
  ds = strlen(newdata);
  if (ds > 60)
    ds = 60;
  memcpy(temp, leadstr, ls);
  temp[ls++] = ' ';
  memcpy(&temp[ls], newdata, ds);
  ds += ls;
  temp[ds++] = 0xd;
  temp[ds++] = 0xa;
  temp[ds] = 0;

  TracePut(temp, ds);

  // dump out to normal nt debug console
  DbgPrint(temp);
}

/*-------------------------------------------------------------------
| TraceDump - Trace, put data into debug ports buffer.
|--------------------------------------------------------------------*/
void TraceDump(PSERIAL_DEVICE_EXTENSION ext, char *newdata, int sCount, int style)
{
 int len,i,j;
 char trace_buf[50];

  len = sCount;
  j = 0;
  trace_buf[j++] = ' ';
  trace_buf[j++] = 'D';
  trace_buf[j++] = 'A';
  trace_buf[j++] = 'T';
  trace_buf[j++] = 'A';
  trace_buf[j++] = ':';
  // dump data into the trace buffer in a hex or ascii dump format
  if (len > 32) len = 32;
  for (i=0; i<len; i++)
  {
    trace_buf[j] = (CHAR) newdata[i];
    if ((trace_buf[j] < 0x20) || (trace_buf[j] > 0x80))
      trace_buf[j] = '.';
    ++j;
  }
  trace_buf[j++] = 0xd;
  trace_buf[j++] = 0xa;
  trace_buf[j] = 0;

  TracePut(trace_buf, j);
}

/*-------------------------------------------------------------------
| TracePut - Trace, put data into debug ports buffer.
|--------------------------------------------------------------------*/
void TracePut(char *newdata, int sCount)
{
#ifdef TRACE_PORT
//  int RxFree,i;
  KIRQL controlIrql;
//  PSERIAL_DEVICE_EXTENSION extension;

  // drop this into our debug queue...

  //----- THIS COMES BACK AS DISPATCH_LEVEL OR PASSIVE LEVEL, is it
  //----- SAFE FOR SPINLOCK TO HAVE BOTH ??????
  //-- YES, SpinLocks meant for calling when <= DISPATCH_LEVEL
#if DBG
  if ((KeGetCurrentIrql() != DISPATCH_LEVEL) &&
      (KeGetCurrentIrql() != PASSIVE_LEVEL))
  {
    MyKdPrint(D_Error, ("BAD IRQL:%d ", KeGetCurrentIrql(), newdata))
    return;
  }
#endif

  if (sCount == 0)
    sCount = strlen(newdata);

  KeAcquireSpinLock(&Driver.DebugLock, &controlIrql);
  q_put(&Driver.DebugQ, (BYTE *) newdata, sCount);
  KeReleaseSpinLock(&Driver.DebugLock, controlIrql);
#endif
}

/*-------------------------------------------------------------------
| Dprintf -
|--------------------------------------------------------------------*/
void __cdecl Dprintf(const char *format, ...)
{
  char  temp[100];
  va_list  Next;

  va_start(Next, format);
  our_vsnprintf(temp, 100, format, Next);

  // EvLog(temp);

  // dump out to normal nt debug console
  DbgPrint(temp);
  DbgPrint("\n");
}

/*-------------------------------------------------------------------
| Sprintf -
|--------------------------------------------------------------------*/
void __cdecl Sprintf(char *dest, const char *format, ...)
{
  va_list Next;

  va_start(Next, format);
  our_vsnprintf(dest, 80, format, Next);
}

/*-------------------------------------------------------------------
| Eprintf -
|--------------------------------------------------------------------*/
void __cdecl Eprintf(const char *format, ...)
{
  char  temp[80];
  va_list  Next;

  va_start(Next, format);
  our_vsnprintf(temp, 79, format, Next);

  if (KeGetCurrentIrql() == PASSIVE_LEVEL) {
    EvLog(temp);
  }
  strcat(temp, "\n");
  DbgPrint(temp);
}

/*-------------------------------------------------------------------
| our_vsnprintf -
|--------------------------------------------------------------------*/
int __cdecl our_vsnprintf(char *buffer, size_t Limit, const char *format, va_list Next)
{
#ifndef BOOL
#define BOOL int
#endif
  int   InitLimit = Limit;  // Limit at entry point
  BOOL  bMore;    // Loop control
  int    Width;    // Optional width
  int   Precision;    // Optional precision
  char  *str;      // String
  char  strbuf[36];    // Constructed string
  int    len;      // Length of string
  int    nLeadingZeros;  // Number of leading zeros required
  int    nPad;      // Number of pad characters required
  char  cPad;      // Current pad character ('0' or ' ')
  char  *sPrefix;    // Prefix string
  unsigned long val;    // Value of current number
  BOOL  bLeftJustify;    // Justification
  BOOL  bPlusSign;    // Show plus sign?
  BOOL  bBlankSign;    // Blank for positives?
  BOOL  bZeroPrefix;    // Want 0x for hex, 0 for octal?
  BOOL  bIsShort;    // TRUE if short
  BOOL  bIsLong;    // TRUE if long

#define PUTONE(c) if (Limit) { --Limit; *buffer++ = c; } else c;

#define  fLeftJustify  (1 << 0)
#define fPlusSign  (1 << 1)
#define fZeroPad  (1 << 2)
#define fBlankSign  (1 << 3)
#define fPrefixOX  (1 << 4)

#define fIsShort  (1 << 5)
#define fIsLong    (1 << 6)

  if (Limit == 0)
    return -1;
  Limit--;      // Leave room for terminating NULL

  while (*format != '\0')
  {
    // Everything but '%' is copied to buffer
    if (*format != '%')
      // '%' gets special handling here
      PUTONE(*format++)
    else
    {
      // Set default flags, etc
      Width = 0;
      Precision = -1;
      cPad = ' ';
      bLeftJustify = FALSE;
      bPlusSign = FALSE;
      bBlankSign = FALSE;
      bZeroPrefix = FALSE;
      bIsShort = FALSE;
      bIsLong = FALSE;
      sPrefix = "";
        
      format++;
      bMore = TRUE;
      while (bMore)
      {
        // optional flags
        switch (*format)
        {
          case '-':  bLeftJustify = TRUE; format++; break;
          case '+':  bPlusSign = TRUE; format++; break;
          case '0':  cPad = '0'; format++; break;
          case ' ':  bBlankSign = TRUE; format++; break;
          case '#':  bZeroPrefix = TRUE; format++; break;
          default:   bMore = FALSE;
        }
      }

      // optional width
      if (*format == '*')
      {
        Width = (int) va_arg(Next, int);
        format++;
      }
      else if (our_isdigit(*format))
      {
        while (our_isdigit(*format))
        {
          Width *= 10;
          Width += (*format++) - '0';
        }
      }

      // optional precision
      if (*format == '.')
      {
        format++;
        Precision = 0;
        if (*format == '*')
        {
          Precision = (int) va_arg(Next, int);
          format++;
        }
        else while (our_isdigit(*format))
        {
          Precision *= 10;
          Precision += (*format++) - '0';
        }
      }

      // optional size
      switch (*format)
      {
        case 'h':  bIsShort = TRUE; format++; break;
        case 'l':  bIsLong = TRUE;  format++; break;
      }

      // All controls are completed, dispatch on the conversion character
      switch (*format++)
      {
        case 'd':
        case 'i':
          if (bIsLong)    // Signed long int
            our_ltoa( (long) va_arg(Next, long), strbuf, 10);
          else      // Signed int
            our_ltoa( (long) va_arg(Next, int), strbuf, 10);
            //    _itoa( (int) va_arg(Next, int), strbuf, 10);

          if (strbuf[0] == '-')
            sPrefix = "-";
          else
          {
            if (bPlusSign)
              sPrefix = "+";
            else if (bBlankSign)
              sPrefix = " ";
          }
          goto EmitNumber;


        case 'u':
          if (bIsLong)    // Unsigned long int
            our_ultoa( (long) va_arg(Next, long), strbuf, 10);
          else      // Unsigned int
            our_ultoa( (long) (int) va_arg(Next, int), strbuf, 10);
          goto EmitNumber;
      
        // set sPrefix for these...
        case 'o':
          if (bZeroPrefix)
            sPrefix = "0";

          if (bIsLong)
            val = (long) va_arg(Next, long);
          else
            val = (int) va_arg(Next, int);
      
          our_ultoa(val, strbuf, 8);
          if (val == 0)
            sPrefix = "";
          goto EmitNumber;

        case 'x':
        case 'X':
          if (bZeroPrefix)
            sPrefix = "0x";

          if (bIsLong)
            val = (unsigned long) va_arg(Next, long);
          else
            val = (unsigned int) va_arg(Next, int);
      
          our_ultoa(val, strbuf, 16);
          if (val == 0)
            sPrefix = "";
          goto EmitNumber;

        case 'c':
          strbuf[0] = (char) va_arg(Next, char);
          str = strbuf;
          len = 1;
          goto EmitString;

        case 's':
          str = (char *) va_arg(Next, char*);
          len =  strlen(str);
          if (Precision != -1 &&
              Precision < len)
            len = Precision;
          goto EmitString;

        case 'n':
        case 'p':
          break;
      
        case '%':
          strbuf[0] = '%';
          str = strbuf;
          len = 1;
          goto EmitString;
          break;

        case 'f':
        case 'e':
        case 'E':
        case 'g':
        case 'G':
          str = "<float format not supported>";
          len =  strlen(str);
          goto EmitString;

        default:
          str = "<bad format character>";
          len =  strlen(str);
          goto EmitString;
      }


EmitNumber:
      if (Precision == -1)
        Precision = 1;
      str = strbuf;
      if (*str == '-')
        str++;    // if negative, already have prefix
      len =  strlen(str);

      nLeadingZeros = Precision - len;
      if (nLeadingZeros < 0)
        nLeadingZeros = 0;

      nPad = Width - (len + nLeadingZeros +  strlen(sPrefix));
      if (nPad < 0)
        nPad = 0;

      if (nPad && !bLeftJustify)
      {
        // Left padding required
        while (nPad--)
        {
          PUTONE(cPad);
        }
        nPad = 0;    // Indicate padding completed
      }
        
      while (*sPrefix != '\0')
        PUTONE(*sPrefix++);

      while (nLeadingZeros-- > 0)
        PUTONE('0');

      while (len-- > 0)
      {
        PUTONE(*str++);
      }
        
      if (nPad)
      {
        // Right padding required
        while (nPad--)
          PUTONE(' ');
      }

      goto Done;


EmitString:
      // Here we have the string ready to emit.  Handle padding, etc.
      if (Width > len)
        nPad = Width - len;
      else
        nPad = 0;

      if (nPad && !bLeftJustify)
      {
        // Left padding required
        while (nPad--)
          PUTONE(cPad);
      }

      while (len-- > 0)
        PUTONE(*str++);

      if (nPad)
      {
        // Right padding required
        while (nPad--)
          PUTONE(' ');
      }

Done:  ;
    }
  }

  *buffer = '\0';
  return InitLimit - Limit - 1;    // Don't count terminating NULL
}

/*-------------------------------------------------------------------
| our_isdigit - 
|--------------------------------------------------------------------*/
int our_isdigit(char c)
{
  if ((c >= '0') && (c <= '9'))
    return 1;
  return 0;
}

/*-----------------------------------------------------------------
 listfind - find matching string in list.  List is null terminated.
|------------------------------------------------------------------*/
int listfind(char *str, char **list)
{
 int i=0;

  for (i=0; list[i] != NULL; i++)
  {
    if (my_lstricmp(str, list[i]) == 0)  // match
      return i;
  }
  return -1;
}

/*-----------------------------------------------------------------
 getnum - get a number.  Hex or Dec.
|------------------------------------------------------------------*/
int getnum(char *str, int *index)
{
  int i,val;
  int ch_i;

  *index = 0;
  ch_i = 0;
  while (*str == ' ')
  {
    ++str;
    ++ch_i;
  }

  if ((*str == '0') && (my_toupper(str[1]) == 'X'))
  {
    str += 2;
    ch_i += 2;
    val = (int) gethint(str,&i);
    if (i==0)
      return 0;
  }
  else
  {
    val = getint(str,&i);
    if (i==0)
      return 0;
  }
  ch_i += i;
  *index = ch_i;  // num bytes consumed
  return val;
}

/*-----------------------------------------------------------------
 getnumbers - get numbers from string, comma or space delimited.
   return number of integers read.
|------------------------------------------------------------------*/
int getnumbers(char *str, long *nums, int max_nums, int hex_flag)
{
// int stat;
  int i,j, num_cnt;
  ULONG *wnums = (ULONG *)nums;

  i = 0;
  num_cnt = 0;
  while (num_cnt < max_nums)
  {
    while ((str[i] == ' ') || (str[i] == ',') || (str[i] == ':'))
      ++i;
    if (hex_flag)
      wnums[num_cnt] = gethint(&str[i],  &j);
    else
      nums[num_cnt] = getint(&str[i],  &j);
    i += j;
    if (j == 0) return num_cnt;
    else ++num_cnt;
  }
  return num_cnt;
}

/*-----------------------------------------------------------------
 my_lstricmp -
|------------------------------------------------------------------*/
int my_lstricmp(char *str1, char *str2)
{
  if ((str1 == NULL) || (str2 == NULL))
    return 1;  // not a match

  if ((*str1 == 0) || (*str2 == 0))
    return 1;  // not a match

  while ( (my_toupper(*str1) == my_toupper(*str2)) && 
          (*str1 != 0)  && (*str2 != 0))
  {
   ++str1;
   ++str2;
  }
  if ((*str1 == 0) && (*str2 == 0))
    return 0;  // ok match

  return 1;  // no match
}

/*-----------------------------------------------------------------
 my_sub_lstricmp -
|------------------------------------------------------------------*/
int my_sub_lstricmp(const char *name, const char *codeline)
{
  int c;

  if ((name == NULL) || (codeline == NULL))
    return 1;  // not a match

  if ((*name == 0) || (*codeline == 0))
    return 1;  // not a match

  while ( (my_toupper(*name) == my_toupper(*codeline)) && 
          (*name != 0)  && (*codeline != 0))
  {
   ++name;
   ++codeline;
  }

  // return if either is at end of string
  if (*name == 0)
  {
    c = my_toupper(*codeline);
    if ((c <= 'Z') && (c >= 'A'))
      return 1;  // not a match
    if (c == '_')
      return 1;  // not a match

    return 0;  // ok match
  }
  return 1;  // no match
}

/*------------------------------------------------------------------------
| getstr - grab a text string parameter off a command line.
|-----------------------------------------------------------------------*/
int getstr(char *deststr, char *textptr, int *countptr, int max_size)
{
//  int number;
  int tempcount, i;

  *deststr = 0;

  tempcount = 0;
  while ((*textptr == ' ') || (*textptr == ','))
  {
    ++textptr;
    ++tempcount;
  }

  i = 0;
  while ((*textptr != 0) && (*textptr != ' ') && (*textptr != ',') &&
         (i < max_size) )
  {
    *deststr++ = *textptr;
    ++textptr;
    ++tempcount;
    ++i;
  }
  *deststr = 0;

  *countptr = tempcount;
  return 0;
}

/*------------------------------------------------------------------------
| getint -
|-----------------------------------------------------------------------*/
int getint(char *textptr, int *countptr)
{
  int number;
  int tempcount;
  int negate = 0;
  int digit_cnt = 0;

  tempcount = 0;
  number = 0;
  while (*textptr == 0x20)
  {
    ++textptr;
    ++tempcount;
  }

  if (*textptr == '-')
  {
    ++textptr;
    ++tempcount;
    negate = 1;
  }

  while ( ((*textptr >= 0x30) && (*textptr <= 0x39)) )
  {
    number = (number * 10) + ( *textptr & 0x0f);
    ++textptr;
    ++tempcount;
    ++digit_cnt;
  }

  if (digit_cnt == 0)
  {
    tempcount = 0;
    number = 0;
  }

  if (countptr)
    *countptr = tempcount;

  if (negate)
    return (-number);
  return number;
} /* getint */

/*------------------------------------------------------------------------
| gethint - for finding hex words.
|-----------------------------------------------------------------------*/
unsigned int gethint(char *bufptr, int *countptr)
{
  unsigned int count;
  unsigned char temphex;
  unsigned int number;
  int digit_cnt = 0;

  number = 0;
  count = 0;

  while (*bufptr == 0x20)
  {
    ++bufptr;
    ++count;
  }

  while ( ((*bufptr >= 0x30) && (*bufptr <= 0x39))
                                  ||
          ((my_toupper(*bufptr) >= 0x41) && (my_toupper(*bufptr) <= 0x46)) )
  {
    if (*bufptr > 0x39)
      temphex = (my_toupper(*bufptr) & 0x0f) + 9;
    else
      temphex = *bufptr & 0x0f;
    number = (number * 16) + temphex;
    ++bufptr;
    ++count;
    ++digit_cnt;
  }

  if (digit_cnt == 0)
  {
    count = 0;
    number = 0;
  }

  if (countptr)
    *countptr = count;

  return number;
} /* gethint */

/*-----------------------------------------------------------------
 my_toupper - to upper case
|------------------------------------------------------------------*/
int my_toupper(int c)
{
  if ((c >= 'a') && (c <= 'z'))
    return ((c-'a') + 'A');
  else return c;
}

/*----------------------------------------------------------------------------
| hextoa -
|----------------------------------------------------------------------------*/
void hextoa(char *str, unsigned int v, int places)
{
  while (places > 0)
  {
    --places;
    if ((v & 0xf) < 0xa)
      str[places] = '0' + (v & 0xf);
    else
      str[places] = 'A' + (v & 0xf) - 0xa;
    v >>= 4;
  }
}

//#define DUMP_MEM
#if DBG
#define TRACK_MEM
#endif
/*----------------------------------------------------------------------------
| our_free -
|----------------------------------------------------------------------------*/
void our_free(PVOID ptr, char *str)
{
#ifdef TRACK_MEM
  ULONG size;
  BYTE *bptr;

  if (ptr == NULL)
  {
    MyKdPrint(D_Error, ("MemFree Null Error\n"))
    //Tprintf("ERR,MemNull Err!");
    return;
  }
  bptr = ptr;
  bptr -= 16;
  if (*((DWORD *)bptr) != 0x1111)  // frame it with something we can check
  {
    MyKdPrint(D_Error, ("MemFree Frame Error\n"))
    //Tprintf("ERR, MemFree Frame!");
  }
  bptr += 4;
  size = *((DWORD *)bptr); // frame it with something we can check
  bptr -= 4;

  Driver.mem_alloced -= size;  // track how much memory we are using
#ifdef DUMP_MEM
  MyKdPrint(D_Init, ("Free:%x(%d),%s, [T:%d]\n",bptr, size, str, Driver.mem_alloced))
  //Tprintf("Free:%x(%d),%s, [T:%d]",bptr, size, str, Driver.mem_alloced);
#endif
  ExFreePool(bptr);
#else
  ExFreePool(ptr);
#endif
}

/*----------------------------------------------------------------------------
| our_locked_alloc -
|----------------------------------------------------------------------------*/
PVOID our_locked_alloc(ULONG size, char *str)
{
 BYTE *bptr;

#ifdef TRACK_MEM
  int i;
  size += 16;
#endif

  bptr = ExAllocatePool(NonPagedPool, size);
  if (bptr == NULL)
  {
    MyKdPrint(D_Error, ("MemCreate Fail\n"))
    //Tprintf("ERR, MemCreate Error!");
    return NULL;
  }
  RtlZeroMemory(bptr, size);

#ifdef TRACK_MEM

#ifdef DUMP_MEM
  MyKdPrint(D_Init, ("Alloc:%x(%d),%s\n",bptr, size, str))
  //Tprintf("Alloc:%x(%d),%s",bptr, size, str);
#endif


  *((DWORD *)bptr) = 0x1111;      // frame it with something we can check
  bptr += 4;
  *((DWORD *)bptr) = size;
  bptr += 4;
  for (i=0; i<4; i++)  // copy the name
  {
    bptr[i] = str[i];
    if (str[i] == 0)
      break;
  }
  bptr += 8;
#endif

  Driver.mem_alloced += size;  // track how much memory we are using
  return bptr;
}

#ifdef S_VS
/*----------------------------------------------------------------------
 mac_cmp - compare two 6-byte mac addresses, return -1 if mac1 < ma2,
  0 if mac1==mac2, 1 if mac1 > mac2.
|----------------------------------------------------------------------*/
int mac_cmp(UCHAR *mac1, UCHAR *mac2)
{
 int i;
  for (i=0; i<6; i++)
  {
    if (mac1[i] != mac2[i])
    {
      if (mac1[i] < mac2[i])
        return -1;
      else
        return  1;
    }
  }
  return  0;  // same
}
#endif

/*----------------------------------------------------------------------
 time_stall -
|----------------------------------------------------------------------*/
void time_stall(int tenth_secs)
{
  int i;
  LARGE_INTEGER WaitTime; // Actual time req'd for buffer to drain

  // set wait-time to .1 second.(-1000 000 = relative(-), 100-ns units)
  WaitTime.QuadPart = -1000000L * tenth_secs;
  KeDelayExecutionThread(KernelMode,FALSE,&WaitTime);

#if 0
  // this is wasteing resources, see new version above
  // wait .4 seconds for response
  for (i=0; i<tenth_secs; i++)
  {
    // set wait-time to .1 second.(-1000 000 = relative(-), 100-ns units)
    //WaitTime = RtlConvertLongToLargeInteger(-1000000L);
    // set wait-time to .1 second.(-1000 000 = relative(-), 100-ns units)
    WaitTime.QuadPart = -1000000L;
    KeDelayExecutionThread(KernelMode,FALSE,&WaitTime);
  }
#endif
}


/*----------------------------------------------------------------------
 ms_time_stall -
|----------------------------------------------------------------------*/
void ms_time_stall(int millisecs)
{
  int i;
  LARGE_INTEGER WaitTime; // Actual time req'd for buffer to drain

  // set wait-time to .001 second.(-10000 = relative(-), 100-ns units)
  WaitTime.QuadPart = -10000L * millisecs;
  KeDelayExecutionThread(KernelMode,FALSE,&WaitTime);
}


/*----------------------------------------------------------------------
 str_to_wstr_dup - allocate wchar string and convert from char to wchar.
|----------------------------------------------------------------------*/
WCHAR *str_to_wstr_dup(char *str, int alloc_space)
{
  WCHAR *wstr;
  WCHAR *wtmpstr;
  int siz;
  siz = (strlen(str) * 2) + 4;

  wstr = ExAllocatePool (alloc_space, siz);
  if ( wstr ) {
    RtlZeroMemory(wstr, siz);
    wtmpstr = wstr;
    while (*str != 0)
    {
      *wtmpstr = (WCHAR) *str;
      ++wtmpstr;
      ++str;
    }
  }
  return wstr;
}
 
/*----------------------------------------------------------------------
  NumDevices - return number of devices in device linked list.
|----------------------------------------------------------------------*/
int NumDevices(void)
{
  PSERIAL_DEVICE_EXTENSION board_ext = NULL;
  int num_devices;

  num_devices = 0;
  while (board_ext != NULL)
  {
    board_ext = board_ext->board_ext;
    ++num_devices;
  }
  return num_devices;
}

/*----------------------------------------------------------------------
  NumPorts - return number of ports for a device based on the actual
    number of Object extensions linked to our device.
    board_ext - board/device to return number of ports, or NULL for
      a count of all ports for all boards.
|----------------------------------------------------------------------*/
int NumPorts(PSERIAL_DEVICE_EXTENSION board_ext)
{
  int num_devices;
  PSERIAL_DEVICE_EXTENSION port_ext;
  int all_devices = 0;

  if (board_ext == NULL)
  {
    all_devices = 1;
    board_ext = Driver.board_ext;
  }

  num_devices = 0;
  while (board_ext != NULL)
  {
    port_ext = board_ext->port_ext;
    while (port_ext != NULL)
    {
      port_ext = port_ext->port_ext;
      ++num_devices;
    }
    if (all_devices)
      board_ext = board_ext->board_ext;  // next
    else
      board_ext = NULL;  // only the one
  }

  return num_devices;
}

/*----------------------------------------------------------------------
  BoardExtToNumber - generate a board number based on the position
    in linked list with head Driver.board_ext.  Used for NT4.0 driver
    install to report a board number.
|----------------------------------------------------------------------*/
int BoardExtToNumber(PSERIAL_DEVICE_EXTENSION board_ext)
{
  PSERIAL_DEVICE_EXTENSION ext;
  int board_num;

  if (board_ext == NULL)
    return 0;

  // walk list of boards to determine which "board number" we are
  board_num = 0;
  ext = Driver.board_ext;
  while (ext != NULL)
  {
    if (board_ext == ext)
    {
      return board_num;
    }
    ext = ext->board_ext;
    ++board_num;
  }

  return 0;  // return first board index as default.
}

/*----------------------------------------------------------------------
  PortExtToIndex - Given a port extension, return the index into
   the devices or drivers ports.
  driver_flag - if set, then return in relation to driver, otherwise
    return port index in relation to parent device.
|----------------------------------------------------------------------*/
int PortExtToIndex(PSERIAL_DEVICE_EXTENSION port_ext,
             int driver_flag)
{
  PSERIAL_DEVICE_EXTENSION b_ext;
  PSERIAL_DEVICE_EXTENSION p_ext;
  int port_num;

  if (port_ext == NULL)
    return 0;

  // walk list of boards & ports
  port_num = 0;
  b_ext = Driver.board_ext;
  while (b_ext != NULL)
  {
    if (!driver_flag)
      port_num = 0;
    p_ext = b_ext->port_ext;
    while (p_ext != NULL)
    {
      if (p_ext == port_ext)
        return port_num;
      p_ext = p_ext->port_ext;
      ++port_num;
    }
    b_ext = b_ext->board_ext;
  }

  // walk list of boards & pdo ports
  port_num = 0;
  b_ext = Driver.board_ext;
  while (b_ext != NULL)
  {
    if (!driver_flag)
      port_num = 0;
    p_ext = b_ext->port_pdo_ext;
    while (p_ext != NULL)
    {
      if (p_ext == port_ext)
        return port_num;
      p_ext = p_ext->port_ext;
      ++port_num;
    }
    b_ext = b_ext->board_ext;
  }
  MyKdPrint(D_Error,("PortExtErr5!\n"))
  return 0;  // return 0(same as first port) if not found
}

/*----------------------------------------------------------------------------
| find_ext_by_name - Given name("COM5"), find the extension structure
|----------------------------------------------------------------------------*/
PSERIAL_DEVICE_EXTENSION find_ext_by_name(char *name, int *dev_num)
{
  int Dev;
  PSERIAL_DEVICE_EXTENSION ext;
  PSERIAL_DEVICE_EXTENSION board_ext;

  board_ext = Driver.board_ext;
  while (board_ext)
  {
    ext = board_ext->port_ext;
    Dev = 0;
    while (ext)
    {
      if (my_lstricmp(name, ext->SymbolicLinkName) == 0)
      {
        if (dev_num != NULL)
          *dev_num = Dev;
        return ext;
      }
      ++Dev;
      ext = ext->port_ext;  // next in chain
    }  // while port extension
    board_ext = board_ext->board_ext;  // next in chain
  }  // while board extension
  return NULL;
}

/*----------------------------------------------------------------------------
| is_board_in_use - Given Board extension, determine if anyone is using it.
    (If any ports associated with it are open.)
|----------------------------------------------------------------------------*/
int is_board_in_use(PSERIAL_DEVICE_EXTENSION board_ext)
{
  PSERIAL_DEVICE_EXTENSION port_ext;
  int in_use = 0;
#ifdef S_VS
  int i;
  Hdlc *hd;
#endif

  if (board_ext == NULL)
    return 0;

#ifdef S_VS
  hd = board_ext->hd;
  if ( hd ) {
    for( i=0; i<2; i++ ) {
      if ( (hd->TxCtlPackets[i]) &&
           (hd->TxCtlPackets[i]->ProtocolReserved[1]) ) {
        in_use = 1;
      }
    }
    for( i=0; i<HDLC_TX_PKT_QUEUE_SIZE; i++ ) {
      if ( (hd->TxPackets[i]) &&
           (hd->TxPackets[i]->ProtocolReserved[1]) ) {
        in_use = 1;
      }
    }
  }
#endif

  port_ext = board_ext->port_ext;
  while((in_use == 0) && (port_ext != NULL)) {
    if (port_ext->DeviceIsOpen) {
      in_use = 1;
    }
#ifdef S_VS
    hd = port_ext->hd;
    if ( hd ) {
      for( i=0; i<2; i++ ) {
        if ( (hd->TxCtlPackets[i]) &&
             (hd->TxCtlPackets[i]->ProtocolReserved[1]) ) {
          in_use = 1;
        }
      }
      for( i=0; i<HDLC_TX_PKT_QUEUE_SIZE; i++ ) {
        if ( (hd->TxPackets[i]) &&
             (hd->TxPackets[i]->ProtocolReserved[1]) ) {
          in_use = 1;
        }
      }
    }
#endif
    port_ext = port_ext->port_ext;
  }
  return in_use; // not in use.
}

/*----------------------------------------------------------------------------
| find_ext_by_index - Given device X and port Y, find the extension structure
    If port_num is -1, then a board ext is assumed to be looked for.
|----------------------------------------------------------------------------*/
PSERIAL_DEVICE_EXTENSION find_ext_by_index(int dev_num, int port_num)
{
  PSERIAL_DEVICE_EXTENSION ext;
  PSERIAL_DEVICE_EXTENSION board_ext;
  int bn;
  int pn;

  bn = -1;
  pn = -1;

  board_ext = Driver.board_ext;
  while ( (board_ext) && (bn < dev_num) )
  {
    bn++;
    if (bn == dev_num) {
      ext = board_ext->port_ext;
      if (port_num == -1)
        return board_ext;  // they wanted a board ext.
      while (ext)
      {
        pn++;
        if (pn == port_num)
          return ext;
        else
          ext = ext->port_ext;          // next in port chain
      }
    }
    board_ext = board_ext->board_ext;   // next in device chain
  }
  return NULL;
}

/*----------------------------------------------------------------------------
| ModemReset - wrappers around hardware routines to put SocketModems into or
| clear SocketModems from reset state.
|----------------------------------------------------------------------------*/
void ModemReset(PSERIAL_DEVICE_EXTENSION ext, int on)
{
#ifdef S_RK
  sModemReset(ext->ChP, on);
#else
  if (on == 1)
  {
    // put the modem into reset state (firmware will pull it out of reset
    // automatically)
    ext->Port->action_reg |= ACT_MODEM_RESET;
  }
  else
  {
    // don't need to do anything to clear a modem from reset on the vs
  }
#endif
}

/*-----------------------------------------------------------------
  our_enum_key - Enumerate a registry key, handle misc stuff.
|------------------------------------------------------------------*/
int our_enum_key(IN HANDLE handle,
                 IN int index,
                 IN CHAR *buffer,
                 IN ULONG max_buffer_size,
                 OUT PCHAR *retdataptr)
{
  NTSTATUS status;
  PKEY_BASIC_INFORMATION KeyInfo;
  ULONG actuallyReturned;
  
  KeyInfo = (PKEY_BASIC_INFORMATION) buffer;
  max_buffer_size -= 8;  // subtract off some space for nulling end, slop, etc.

  // return a pointer to the start of data.
  *retdataptr = ((PCHAR)(&KeyInfo->Name[0]));

  // Pad the name returned with 2 wchar zeros.
  RtlZeroMemory( ((PUCHAR)(&KeyInfo->Name[0])), sizeof(WCHAR)*2);

  status = ZwEnumerateKey(handle,
                          index,
                          KeyBasicInformation,
                          KeyInfo,
                          max_buffer_size,
                          &actuallyReturned);

  if (status == STATUS_NO_MORE_ENTRIES)
  {
     //MyKdPrint(D_Init, ("Done.\n"))
     return 1;  // err, done
  }
  if (status != STATUS_SUCCESS)
  {
    MyKdPrint(D_Error, ("Err3G\n"))
    return 2;  // err
  }

  if (KeyInfo->NameLength > max_buffer_size)  // check limits
      KeyInfo->NameLength = max_buffer_size;

  // Pad the name returned with 2 wchar zeros.
  RtlZeroMemory( ((PUCHAR)(&KeyInfo->Name[0]))+KeyInfo->NameLength,
                 sizeof(WCHAR)*2);

  return 0;  // ok, done
}

/*-----------------------------------------------------------------
  our_enum_value - Enumerate a registry value, handle misc stuff.
|------------------------------------------------------------------*/
int our_enum_value(IN HANDLE handle,
                   IN int index,
                   IN CHAR *buffer,
                   IN ULONG max_buffer_size,
                   OUT PULONG type,
                   OUT PCHAR *retdataptr,
                   OUT PCHAR sz_retname)
{
  NTSTATUS status;
  PKEY_VALUE_FULL_INFORMATION KeyValueInfo;
  //PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
  ULONG actuallyReturned;
  ULONG i;

  KeyValueInfo = (PKEY_VALUE_FULL_INFORMATION) buffer;
  max_buffer_size -= 8;  // subtract off some space for nulling end, slop, etc.

  // Pad the name returned with 2 wchar zeros.
  RtlZeroMemory( ((PUCHAR)(&KeyValueInfo->Name[0])), sizeof(WCHAR)*2);

  // return a pointer to the start of data.
  *retdataptr = ((PCHAR)(&KeyValueInfo->Name[0]));
  *sz_retname = 0;

  status = ZwEnumerateValueKey(handle,
                          index,
                          KeyValueFullInformation,
                          KeyValueInfo,
                          max_buffer_size,
                          &actuallyReturned);

  if (status == STATUS_NO_MORE_ENTRIES)
  {
    //MyKdPrint(D_Init, ("Done.\n"))
    return 1;  // err, done
  }
  if (status != STATUS_SUCCESS)
  {
    MyKdPrint(D_Init, ("Err3H\n"))
    return 2;  // err
  }

  if (KeyValueInfo->NameLength < 80)  // limit to 40 char entries
  {
    for (i=0; i<(KeyValueInfo->NameLength/2); i++)
    {
      sz_retname[i] = (CHAR)KeyValueInfo->Name[i];
    }
    sz_retname[i] = 0;
  }

  *retdataptr = ((PCHAR) KeyValueInfo) + KeyValueInfo->DataOffset;

  // Pad the data returned with 2 wchar zeros.
  RtlZeroMemory( (PUCHAR)(*retdataptr + KeyValueInfo->DataLength),
                 sizeof(WCHAR)*2);
  if (type != NULL)
    *type = KeyValueInfo->Type;
  return 0;  // ok, done
}

/*-----------------------------------------------------------------
  our_query_value - get data from an entry in the registry.
    We give a generic buffer space(and size), and the routine passes
    back a ptr (into this generic buffer space where the data
    is read into.
|------------------------------------------------------------------*/
int our_query_value(IN HANDLE Handle,
                    IN char *key_name, 
                    IN CHAR *buffer,
                    IN ULONG max_buffer_size,
                    OUT PULONG type,
                    OUT PCHAR *retdataptr)
{
  NTSTATUS status;
  PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
  ULONG length;
  OUT USTR_40 ubuf;  // about 90 bytes on stack

  if (strlen(key_name) > 38)
  {
    MyKdPrint(D_Error, ("Err, KeyValue Len!\n"))
    return 2;
  }

  // convert our name to unicode;
  CToUStr(
         (PUNICODE_STRING) &ubuf, // where unicode struct & string gets put
         key_name,                // our c-string we wish to convert
         sizeof(ubuf));

  KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
  max_buffer_size -= 8;  // subtract off some space for nulling end, slop, etc.

  // return a pointer to the start of data.
  *retdataptr = ((PCHAR)(&KeyValueInfo->Data[0]));

  // Pad the name returned with 2 wchar zeros.
  RtlZeroMemory( ((PUCHAR)(&KeyValueInfo->Data[0])), sizeof(WCHAR)*2);

  status = ZwQueryValueKey (Handle,
                            (PUNICODE_STRING) &ubuf,  // input reg key name
                            KeyValuePartialInformation,
                            KeyValueInfo,
                            max_buffer_size,
                            &length);

  if (status != STATUS_SUCCESS)
  {
    //MyKdPrint(D_Init, ("No Value\n"))
    return 1;  // err
  }

  if (KeyValueInfo->DataLength > max_buffer_size)
    KeyValueInfo->DataLength = max_buffer_size;

  // Pad the data returned with a null,null.
  RtlZeroMemory( ((PUCHAR)(&KeyValueInfo->Data[0]))+KeyValueInfo->DataLength,
                 sizeof(WCHAR)*2);
  if (type != NULL)
    *type = KeyValueInfo->Type;
  return 0; // ok
}

/*-----------------------------------------------------------------
  our_set_value - get data from an entry in the registry.
|------------------------------------------------------------------*/
int our_set_value(IN HANDLE Handle,
                    IN char *key_name,
                    IN PVOID pValue,
                    IN ULONG value_size,
                    IN ULONG value_type)
{
  NTSTATUS status;
  PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
  ULONG length;
  OUT USTR_40 ubuf_name;  // about 90 bytes on stack
  OUT USTR_40 ubuf_val;  // about 90 bytes on stack

  if (strlen(key_name) > 38)
  {
    MyKdPrint(D_Error, ("Err, KeyValue Len!\n"))
    return 2;
  }

  // convert our name to unicode;
  CToUStr(
         (PUNICODE_STRING) &ubuf_name, // where unicode struct & string gets put
         key_name,                // our c-string we wish to convert
         sizeof(ubuf_name));

  if (value_type == REG_SZ)
  {
    // convert our value to unicode;
    CToUStr(
         (PUNICODE_STRING) &ubuf_val, // where unicode struct & string gets put
         (char *)pValue,                // our c-string we wish to convert
         sizeof(ubuf_val));
    MyKdPrint(D_Init, ("set_value reg_sz %s=%s\n",
         key_name, (char *)pValue))

    pValue  = (PVOID)ubuf_val.ustr.Buffer;
    value_size = ubuf_val.ustr.Length;
  }

  status = ZwSetValueKey (Handle,
                        (PUNICODE_STRING) &ubuf_name,
                        0,  // type optional
                        value_type,
                        pValue,
                        value_size);

  if (status != STATUS_SUCCESS)
  {
    MyKdPrint(D_Error, ("Error setting reg %\n",key_name))
    return 1;  // err
  }

  return 0; // ok
}

/*-----------------------------------------------------------------
  our_open_key - Make sure *pHandle is initialized to NULL, because
    this routine auto-closes the handle with ZwClose().
|------------------------------------------------------------------*/
int our_open_key(OUT PHANDLE phandle,
                 IN OPTIONAL HANDLE relative_key_handle,
                 IN char *regkeyname,
                 IN ULONG attribs)
{
  OBJECT_ATTRIBUTES objAttribs;
  NTSTATUS status;
  OUT USTR_160 ubuf;  // about 340 bytes on the stack

  if (strlen(regkeyname) > 158)
  {
    MyKdPrint(D_Error, ("Err, Key Len!\n"))
    return 2;
  }

  // convert our name to unicode;
  CToUStr(
         (PUNICODE_STRING) &ubuf, // where unicode struct & string gets put
         regkeyname,              // our c-string we wish to convert
         sizeof(ubuf));

  // if previously open, then close it up.
  if (*phandle != NULL)
  {
    ZwClose(*phandle);
    *phandle = NULL;
  }
  InitializeObjectAttributes(&objAttribs,
                              (PUNICODE_STRING) &ubuf,
                              OBJ_CASE_INSENSITIVE,
                              relative_key_handle,  // root dir relative handle
                              NULL);  // security desc

  status = ZwOpenKey(phandle,
                     attribs,
                     &objAttribs);

  if ((status != STATUS_SUCCESS) && (attribs == KEY_ALL_ACCESS))
  {
    MyKdPrint(D_Error, ("OpenKey,Try to Create %s, status 0x%x\n", regkeyname,status))
    status = ZwCreateKey(phandle,
                         attribs, //KEY_ALL_ACCESS, etc
                         &objAttribs,
                         0,  // index, optional
                         NULL,  // ptr to unicode string, class
                         REG_OPTION_NON_VOLATILE,
                         NULL);  // disposition, tells if created

    if (status == STATUS_SUCCESS)
    {
      // try to open the original key again.
      status = ZwOpenKey(phandle,
                         attribs,
                         &objAttribs);
    }
    else
    {
      MyKdPrint(D_Error, ("OpenKey,Error Creating %s\n", regkeyname))
    }
  }

  if (status != STATUS_SUCCESS)
  {
    MyKdPrint(D_Error, ("OpenKey,Error Opening %s, status 0x%x\n", regkeyname,status))
    //MyKdPrint(D_Init, ("Failed ZwOpenKey\n"))
    *phandle = NULL;  // make sure null if not open
    return 1;
  }

  return 0;
}

/*-----------------------------------------------------------------
  our_open_device_reg -
|------------------------------------------------------------------*/
int our_open_device_reg(OUT HANDLE *pHandle,
                        IN PSERIAL_DEVICE_EXTENSION dev_ext,
                        IN ULONG RegOpenRights)
{
  NTSTATUS status;
  HANDLE DriverHandle = NULL;
  HANDLE DevHandle = NULL;
#if TRY_NEW_NT50
  // PLUGPLAY_REGKEY_DRIVER opens up the control\class\{guid}\node
  // PLUGPLAY_REGKEY_DEVICE opens up the enum\enum-type\node\Device Parameters
  status = IoOpenDeviceRegistryKey(dev_ext->Pdo,
                                   PLUGPLAY_REGKEY_DRIVER,
                                   RegOpenRights, pHandle);
  if (status != STATUS_SUCCESS)
  {
    //MyKdPrint(D_Init, ("Failed ZwOpenKey\n"))
    *phandle = NULL;  // make sure null if not open
    return 1;
  }
#else
  {
    int j, stat;
    char dev_str[60];
    char tmpstr[200];
    OBJECT_ATTRIBUTES objAttribs;

    MyKdPrint(D_Init, ("our_open_device_reg\n"))
#if NT50
    if (dev_ext->config->szNt50DevObjName[0] == 0)
    {
      MyKdPrint(D_Error, ("Error, device options Pnp key!\n"))
      *pHandle = NULL;
      return 1;  // err
    }
    Sprintf(dev_str, "%s\\%s",
            szParameters, dev_ext->config->szNt50DevObjName);
#else
    j = BoardExtToNumber(dev_ext);
    Sprintf(dev_str, "%s\\Device%d", szParameters, BoardExtToNumber(dev_ext));
#endif

    // force a creation of "Parameters" if not exist
    stat = our_open_driver_reg(&DriverHandle,
                               KEY_ALL_ACCESS);
    if (stat)
    {
      MyKdPrint(D_Error, ("Err4b!\n"))
      *pHandle = NULL;
      return 1;
    }
    ZwClose(DriverHandle);
    DriverHandle = NULL;

	MyKdPrint(D_Init, ("Driver.OptionRegPath: %s\n", dev_str))

    stat = MakeRegPath(dev_str);  // this forms Driver.OptionRegPath
    if (stat) {
      *pHandle = NULL;
      return 1;
    }

    UToCStr(tmpstr, &Driver.OptionRegPath, sizeof(tmpstr));

    stat = our_open_key(pHandle,
                        NULL,
                        tmpstr,
                        RegOpenRights);

    if (stat != 0)
    {
      MyKdPrint(D_Error, ("Err3e\n"))
      *pHandle = NULL;  // make sure null if not open
      return 1;
    }
  }
#endif
  return 0;
}

/*-----------------------------------------------------------------
  our_open_driver_reg -
|------------------------------------------------------------------*/
int our_open_driver_reg(OUT HANDLE *pHandle,
                        IN ULONG RegOpenRights)
{
  NTSTATUS status;
  int j, stat;
  OBJECT_ATTRIBUTES objAttribs;
  char tmpstr[200];

  stat = MakeRegPath(szParameters);  // this forms Driver.OptionRegPath
  if ( stat ) {
    *pHandle = NULL;  // make sure null if not open
    return 1;
  }

  UToCStr(tmpstr, &Driver.OptionRegPath, sizeof(tmpstr));

  stat = our_open_key(pHandle,
               NULL,
               tmpstr,
               RegOpenRights);

  if (stat != 0)
  {
    MyKdPrint(D_Error, ("Failed ZwOpenKey %s\n",tmpstr))
    *pHandle = NULL;  // make sure null if not open
    return 1;
  }
  return 0;
}

/*----------------------------------------------------------------------------
| ModemSpeakerEnable - wrappers around hardware routines to enable the 
| RocketModemII speaker...
|----------------------------------------------------------------------------*/
void ModemSpeakerEnable(PSERIAL_DEVICE_EXTENSION ext)
{
    MyKdPrint(D_Init,("ModemSpeakerEnable: %x\n",(unsigned long)ext))
#ifdef S_RK
    sModemSpeakerEnable(ext->ChP);
#endif
}

/*----------------------------------------------------------------------------
| ModemWriteROW - wrappers around hardware routines to send ROW config
| commands to SocketModems.
|----------------------------------------------------------------------------*/
void ModemWriteROW(PSERIAL_DEVICE_EXTENSION ext,USHORT CountryCode)
{
  int count;
  char *ModemConfigString;

  MyKdPrint(D_Init,("ModemWriteROW: %x, %x\n",(unsigned long)ext,CountryCode)) // DEBUG
  time_stall(10);   // DEBUG

#ifdef S_RK

  sModemWriteROW(ext->ChP,CountryCode);

#else
  {
  // fix so compiles, 1-18-99 kpb
  static char *ModemConfigString = {"AT*NCxxZ\r"};

  if (CountryCode == 0) {
    // bad country code, skip the write and let modem use power-on default
    MyKdPrint(D_Init,("Undefined ROW Write\n"))
    return;
  }

  if (CountryCode == ROW_NA) {
    MyKdPrint(D_Init,("ROW Write, North America\n"))
    return;
  }

  // create the country config string
  ModemConfigString[5] = '0' + (CountryCode / 10);
  ModemConfigString[6] = '0' + (CountryCode % 10);

  PortFlushTx(ext->Port);     /* we just reset, so a flush shouldn't matter */
  q_put(&ext->Port->QOut, ModemConfigString, strlen(ModemConfigString));
  }

#endif
}

#ifdef S_RK
/********************************************************************

   wrappers around hardware routines to send strings to modems...

*********************************************************************/
void 
ModemWrite(PSERIAL_DEVICE_EXTENSION ext,char *string,int length)
{
    sModemWrite(ext->ChP,string,length);
}

/********************************************************************

   wrappers around hardware routines to send strings to modems...

*********************************************************************/
int 
ModemRead(PSERIAL_DEVICE_EXTENSION ext,
    char *string,int length,
    int poll_retries)
{
    return(sModemRead(ext->ChP,string,length,poll_retries));
}

/********************************************************************

   wrappers around hardware routines to send strings to modems...

*********************************************************************/
int 
ModemReadChoice(PSERIAL_DEVICE_EXTENSION ext,
    char *s0,int len0,
    char *s1,int len1,
    int poll_retries)
{
    return(sModemReadChoice(ext->ChP,s0,len0,s1,len1,poll_retries));
}

/********************************************************************

   wrappers around hardware routines to send strings to modems, one
    byte at a time...

*********************************************************************/
void    
ModemWriteDelay(PSERIAL_DEVICE_EXTENSION ext,
    char *string,int length)
{
    sModemWriteDelay(ext->ChP,string,length);
}

/********************************************************************

   wrappers around hardware routines to check FIFO status...

*********************************************************************/
int 
RxFIFOReady(PSERIAL_DEVICE_EXTENSION ext)
{
    return(sRxFIFOReady(ext->ChP));
}

int 
TxFIFOReady(PSERIAL_DEVICE_EXTENSION ext)
{
    return(sTxFIFOReady(ext->ChP));
}

int 
TxFIFOStatus(PSERIAL_DEVICE_EXTENSION ext)
{
    return(sTxFIFOStatus(ext->ChP));
}


/********************************************************************

   wrappers around hardware routines to prepare modem ports for IO...

*********************************************************************/
void 
ModemIOReady(PSERIAL_DEVICE_EXTENSION ext,int speed)
{
    if (sSetBaudRate(ext->ChP,speed,FALSE)) {
        MyKdPrint(D_Init,("Unable to set baud rate to %d\n",speed))
        return;
    }
    sFlushTxFIFO(ext->ChP);
    sFlushRxFIFO(ext->ChP);

    ext->BaudRate = speed;
    sSetBaudRate(ext->ChP,ext->BaudRate,TRUE);

    sSetData8(ext->ChP);
    sSetParity(ext->ChP,0);   // No Parity
    sSetRxMask(ext->ChP,0xff);

    sClrTxXOFF(ext->ChP)            /* destroy any pending stuff */

    sEnRTSFlowCtl(ext->ChP);
    sEnCTSFlowCtl(ext->ChP);

    if (sGetChanStatus(ext->ChP) & STATMODE) {
        sDisRxStatusMode(ext->ChP);
    }

    sGetChanIntID(ext->ChP);

    sEnRxFIFO(ext->ChP);
    sEnTransmit(ext->ChP);      /* enable transmitter if not already enabled */

    sSetDTR(ext->ChP);
    sSetRTS(ext->ChP);
}

/********************************************************************

   wrappers around hardware routines to shut down modem ports for now...

*********************************************************************/
void 
ModemUnReady(PSERIAL_DEVICE_EXTENSION ext)
{
    sFlushTxFIFO(ext->ChP);
    sFlushRxFIFO(ext->ChP);

    sSetData8(ext->ChP);
    sSetParity(ext->ChP,0);
    sSetRxMask(ext->ChP,0xff);

    ext->BaudRate = 9600;
    sSetBaudRate(ext->ChP,ext->BaudRate,TRUE);

    sClrTxXOFF(ext->ChP)      // destroy any pending stuff

    if (sGetChanStatus(ext->ChP) & STATMODE) {
        sDisRxStatusMode(ext->ChP);
    }

    sGetChanIntID(ext->ChP);

    sDisRTSFlowCtl(ext->ChP);
    sDisCTSFlowCtl(ext->ChP);
 
    sClrRTS(ext->ChP);
    sClrDTR(ext->ChP);

    time_stall(1);    // wait for port to quiet...
}
#endif  // S_RK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\waitmask.c ===
/*-------------------------------------------------------------------
| waitmask.c -

3-30-99 - fix cancel event operation(race-condition) to avoid
  potential bug-check on queued eventwait cancel.
11-24-98 - update event kdprint debug messages - kpb
Copyright 1993-99 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

/*------------------------------------------------------------------
 SerialCancelWait - (setup in ioctl.c currently, 3-28-98, kpb)
    This routine is used to cancel a irp that is waiting on a comm event.
|-------------------------------------------------------------------*/
VOID SerialCancelWait(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)

{
  PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;

  MyKdPrint(D_Ioctl,("CancelWait\n"))
  // take out, 3-30-99, kpb... Extension->IrpMaskLocation = NULL;
  if (Extension->CurrentWaitIrp)
  {
    PIRP Irp_tmp;

    MyKdPrint(D_Ioctl,("Cancel a Wait\n"))

    //***** add, 3-30-99, kpb, cause crash on read thread in dos box without
    // grab from ISR timer or interrupt routine.
    SyncUp(Driver.InterruptObject,
           &Driver.TimerLock,
           SerialGrabWaitFromIsr,
           Extension);
    //***** end add, 3-30-99

    // ExtTrace(Extension,D_Ioctl, "Cancel Event");
    Extension->CurrentWaitIrp->IoStatus.Information = 0;
    Extension->CurrentWaitIrp->IoStatus.Status = STATUS_CANCELLED;

    Irp_tmp = Extension->CurrentWaitIrp;
    IoSetCancelRoutine(Irp_tmp, NULL);  // add 9-15-97, kpb
    Extension->CurrentWaitIrp = 0;
    IoReleaseCancelSpinLock(Irp->CancelIrql);
    SerialCompleteRequest(Extension, Irp_tmp, IO_SERIAL_INCREMENT);
  }
  else
  {
    IoReleaseCancelSpinLock(Irp->CancelIrql);
    ExtTrace(Extension,D_Ioctl, "Err Cancel Event!");
    MyKdPrint(D_Ioctl,("No Wait to Cancel\n"))
  }
}

/*------------------------------------------------------------------
 SerialCompleteWait - called by isr.c via CommWaitDpc.  It nulls out
   IrpMaskLocation to signal control passed back to us.
|-------------------------------------------------------------------*/
VOID SerialCompleteWait(IN PKDPC Dpc,IN PVOID DeferredContext,
                        IN PVOID SystemContext1, IN PVOID SystemContext2)
{
    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;
    PIRP Irp_tmp;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

   MyKdPrint(D_Ioctl,("Complete Wait\n"))
   IoAcquireCancelSpinLock(&OldIrql);

   if (Extension->CurrentWaitIrp != 0)
   {
    MyKdPrint(D_Ioctl,("Complete a Wait\n"))
    ExtTrace2(Extension,D_Ioctl, "Event Done Got:%xH Mask:%xH",
              *(ULONG *) Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer,
              Extension->IsrWaitMask);

     Extension->WaitIsISRs = 0;
     Extension->IrpMaskLocation = &Extension->DummyIrpMaskLoc;

     // caller sets the ULONG bit flags indicating event at .SystemBuffer
     //*(ULONG *)Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer = 0;
     Extension->CurrentWaitIrp->IoStatus.Status = STATUS_SUCCESS;
     Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
     Irp_tmp = Extension->CurrentWaitIrp;
     IoSetCancelRoutine(Irp_tmp, NULL);  // add 9-15-97, kpb
     Extension->CurrentWaitIrp = 0;
     IoReleaseCancelSpinLock(OldIrql);
     SerialCompleteRequest(Extension, Irp_tmp, IO_SERIAL_INCREMENT);
   }
   else
   {
     MyKdPrint(D_Ioctl,("No wait to complete\n"))
     IoReleaseCancelSpinLock(OldIrql);
   }
}

/*------------------------------------------------------------------
  SerialGrabWaitFromIsr - Take back the wait packet from the ISR by
   reseting IrpMaskLocation in extension.  Need to use a sync with
   isr/timer routine to avoid contention in multiprocessor environments.

   Called from sync routine or with timer spinlock held.

  App - Can set IrpMaskLocation to give read-irp handling to the ISR without
    syncing to ISR.
  ISR - Can reset ReadPending to give wait-irp handling back to app-time.

  If App wants to grab control of read-irp handling back from ISR, then
  it must sync-up with the isr/timer routine which has control.
|-------------------------------------------------------------------*/
BOOLEAN SerialGrabWaitFromIsr(PSERIAL_DEVICE_EXTENSION Extension)
{
  Extension->WaitIsISRs = 0;
  Extension->IrpMaskLocation = &Extension->DummyIrpMaskLoc;
  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\utils.h ===
//----- utils.h

VOID SyncUp(IN PKINTERRUPT IntObj,
            IN PKSPIN_LOCK SpinLock,
            IN PKSYNCHRONIZE_ROUTINE SyncProc,
            IN PVOID Context);

VOID
SerialKillAllReadsOrWrites(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLIST_ENTRY QueueToClean,
    IN PIRP *CurrentOpIrp
    );

VOID
SerialGetNextIrp(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent,
    IN PSERIAL_DEVICE_EXTENSION extension
    );

VOID
SerialTryToCompleteCurrent(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
    IN KIRQL IrqlForRelease,
    IN NTSTATUS StatusToUse,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess OPTIONAL,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL,
    IN PSERIAL_START_ROUTINE Starter OPTIONAL,
    IN PSERIAL_GET_NEXT_ROUTINE GetNextIrp OPTIONAL,
    IN LONG RefType
    );

VOID
SerialRundownIrpRefs(
    IN PIRP *CurrentOpIrp,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL
    );

NTSTATUS
SerialStartOrQueue(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PSERIAL_START_ROUTINE Starter
    );

VOID
SerialCancelQueued(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
SerialCompleteIfError(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

//--- error.h
VOID
SerialCommError(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

//--- flush.h

NTSTATUS SerialFlush(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS SerialStartFlush(IN PSERIAL_DEVICE_EXTENSION Extension);

//---- purge.h
NTSTATUS SerialStartPurge(IN PSERIAL_DEVICE_EXTENSION Extension);

//---- qsfile.h

NTSTATUS
SerialQueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialSetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//----  routines to deal with unicode bloat

//----  typedefs to convienently allocate uniccode struct and buffer
typedef struct {
  UNICODE_STRING ustr;
  WCHAR wstr[240];
} USTR_240;

typedef struct {
  UNICODE_STRING ustr;
  WCHAR wstr[160];
} USTR_160;

typedef struct {
  UNICODE_STRING ustr;
  WCHAR wstr[80];
} USTR_80;

typedef struct {
  UNICODE_STRING ustr;
  WCHAR wstr[40];
} USTR_40;

OUT PCHAR UToC1(IN PUNICODE_STRING ustr);

OUT PCHAR UToCStr(
         IN OUT PCHAR Buffer,
         IN PUNICODE_STRING ustr,
         IN int BufferSize);

OUT PUNICODE_STRING CToU1(IN const char *c_str);

OUT PUNICODE_STRING CToU2(IN const char *c_str);

OUT PUNICODE_STRING CToUStr(
         OUT PUNICODE_STRING Buffer,
         IN const char * c_str,
         IN int BufferSize);

VOID WStrToCStr(OUT PCHAR c_str, IN PWCHAR w_str, int max_size);
int get_reg_value(
                  IN HANDLE keyHandle,
                  OUT PVOID outptr,
                  IN PCHAR val_name,
                  int max_size);

void OurTrace(char *leadstr, char *newdata);
void TraceDump(PSERIAL_DEVICE_EXTENSION ext, char *newdata, int sCount, int style);
void TracePut(char *newdata, int sCount);
int __cdecl our_vsnprintf(char *buffer, size_t Limit, const char *format, va_list Next);
void __cdecl TTprintf(char *leadstr, const char *format, ...);
void __cdecl Tprintf(const char *format, ...);
void __cdecl Sprintf(char *dest, const char *format, ...);
void __cdecl Dprintf(const char *format, ...);
void __cdecl Eprintf(const char *format, ...);
void MyAssertMessage(char *filename, int line);
void EvLog(char *mess);
char *our_ultoa(unsigned long u, char* s, int radix);
char *our_ltoa(long value, char* s, int radix);

int listfind(char *str, char **list);
int our_isdigit(char c);
int getnumbers(char *str, long *nums, int max_nums, int hex_flag);
int getstr(char *deststr, char *textptr, int *countptr, int max_size);
int my_lstricmp(char *str1, char *str2);
int getint(char *textptr, int *countptr);
int getnum(char *str, int *index);
int my_sub_lstricmp(const char *name, const char *codeline);
unsigned int gethint(char *bufptr, int *countptr);
int my_toupper(int c);
void hextoa(char *str, unsigned int v, int places);
void our_free(PVOID ptr, char *str);
PVOID our_locked_alloc(ULONG size, char *str);
void our_assert(int id, int line);

int mac_cmp(UCHAR *mac1, UCHAR *mac2);
void time_stall(int tenth_secs);
void ms_time_stall(int millisecs);
WCHAR *str_to_wstr_dup(char *str, int alloc_space);
int BoardExtToNumber(PSERIAL_DEVICE_EXTENSION board_ext);
int NumDevices(void);
int NumPorts(PSERIAL_DEVICE_EXTENSION board_ext);
int PortExtToIndex(PSERIAL_DEVICE_EXTENSION port_ext,
             int driver_flag);
int is_board_in_use(PSERIAL_DEVICE_EXTENSION board_ext);
PSERIAL_DEVICE_EXTENSION find_ext_by_name(char *name, int *dev_num);
PSERIAL_DEVICE_EXTENSION find_ext_by_index(int dev_num, int port_num);
int our_open_key(OUT PHANDLE phandle,
                 IN OPTIONAL HANDLE relative_key_handle,
                 IN char *regkeyname,
                 IN ULONG attribs);
int our_enum_key(IN HANDLE handle,
                 IN int index,
                 IN CHAR *buffer,
                 IN ULONG max_buffer_size,
                 OUT PCHAR *retdataptr);
int our_query_value(IN HANDLE Handle,
                    IN char *key_name, 
                    IN CHAR *buffer,
                    IN ULONG max_buffer_size,
                    OUT PULONG type,
                    OUT PCHAR *retdataptr);
int our_enum_value(IN HANDLE handle,
                   IN int index,
                   IN CHAR *buffer,
                   IN ULONG max_buffer_size,
                   OUT PULONG type,
                   OUT PCHAR *retdataptr,
                   OUT PCHAR sz_retname);
int our_set_value(IN HANDLE Handle,
                    IN char *key_name,
                    IN PVOID pValue,
                    IN ULONG value_size,
                    IN ULONG value_type);
int our_open_device_reg(OUT HANDLE *pHandle,
                        IN PSERIAL_DEVICE_EXTENSION dev_ext,
                        IN ULONG RegOpenRights);
int our_open_driver_reg(OUT HANDLE *pHandle,
                        IN ULONG RegOpenRights);
#define our_close_key(handle) \
  { if (handle) {ZwClose(handle); handle = NULL;} }

void ModemReset(PSERIAL_DEVICE_EXTENSION ext, int on);
void ModemSpeakerEnable(PSERIAL_DEVICE_EXTENSION ext);
void ModemWriteROW(PSERIAL_DEVICE_EXTENSION ext, USHORT CountryCode);
void ModemWrite(PSERIAL_DEVICE_EXTENSION ext,char *string,int length);
void ModemWriteDelay(PSERIAL_DEVICE_EXTENSION ext,char *string,int length);
void ModemIOReady(PSERIAL_DEVICE_EXTENSION ext,int speed);
void ModemUnReady(PSERIAL_DEVICE_EXTENSION ext);
int  ModemRead(PSERIAL_DEVICE_EXTENSION ext,char *s0,int len0,int poll_retries);
int  ModemReadChoice(PSERIAL_DEVICE_EXTENSION ext,char *s0,int len0,char *s1,int len1,int poll_retries);
int  TxFIFOReady(PSERIAL_DEVICE_EXTENSION ext);   
int  TxFIFOStatus(PSERIAL_DEVICE_EXTENSION ext);
int  RxFIFOReady(PSERIAL_DEVICE_EXTENSION ext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\wmi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    serial driver.

Environment:

    Kernel mode

Revision History :
--*/

#include "precomp.h"
#include <wmistr.h>

NTSTATUS
SerialSystemControlDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS
SerialTossWMIRequest(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex);
NTSTATUS
SerialSetWmiDataItem(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex, IN ULONG InstanceIndex,
                     IN ULONG DataItemId,
                     IN ULONG BufferSize, IN PUCHAR PBuffer);
NTSTATUS
SerialSetWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                      IN ULONG GuidIndex, IN ULONG InstanceIndex,
                      IN ULONG BufferSize,
                      IN PUCHAR PBuffer);
NTSTATUS
SerialQueryWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                        IN ULONG GuidIndex, 
                        IN ULONG InstanceIndex,
                        IN ULONG InstanceCount,
                        IN OUT PULONG InstanceLengthArray,
                        IN ULONG OutBufferSize,
                        OUT PUCHAR PBuffer);
NTSTATUS
SerialQueryWmiRegInfo(IN PDEVICE_OBJECT PDevObj, OUT PULONG PRegFlags,
                      OUT PUNICODE_STRING PInstanceName,
                      OUT PUNICODE_STRING *PRegistryPath,
                      OUT PUNICODE_STRING MofResourceName,
                      OUT PDEVICE_OBJECT *Pdo);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESRP0, SerialSystemControlDispatch)
#pragma alloc_text(PAGESRP0, SerialTossWMIRequest)
#pragma alloc_text(PAGESRP0, SerialSetWmiDataItem)
#pragma alloc_text(PAGESRP0, SerialSetWmiDataBlock)
#pragma alloc_text(PAGESRP0, SerialQueryWmiDataBlock)
#pragma alloc_text(PAGESRP0, SerialQueryWmiRegInfo)
#endif


NTSTATUS
SerialSystemControlDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;
    PSERIAL_DEVICE_EXTENSION pDevExt
      = (PSERIAL_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    PAGED_CODE();

    status = WmiSystemControl(   &pDevExt->WmiLibInfo,
                                 DeviceObject, 
                                 Irp,
                                 &disposition);
    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            IoCompleteRequest(Irp, IO_NO_INCREMENT);                
            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(pDevExt->LowerDeviceObject, Irp);
            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(pDevExt->LowerDeviceObject, Irp);
            break;
        }        
    }
    
    return(status);

}


#define WMI_SERIAL_PORT_NAME_INFORMATION 0
#define WMI_SERIAL_PORT_COMM_INFORMATION 1
#define WMI_SERIAL_PORT_HW_INFORMATION   2
#define WMI_SERIAL_PORT_PERF_INFORMATION 3

GUID SerialPortNameGuid = SERIAL_PORT_WMI_NAME_GUID;
GUID SerialPortCommGuid = SERIAL_PORT_WMI_COMM_GUID;
GUID SerialPortHWGuid = SERIAL_PORT_WMI_HW_GUID;
GUID SerailPortPerfGuid = SERIAL_PORT_WMI_PERF_GUID;

WMIGUIDREGINFO SerialWmiGuidList[4] =
{
    { &SerialPortNameGuid, 1, 0 },
    { &SerialPortCommGuid, 1, 0 },
    { &SerialPortHWGuid, 1, 0 },
    { &SerailPortPerfGuid, 1, 0 }
};

//
// WMI System Call back functions
//



NTSTATUS
SerialTossWMIRequest(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex)
{
   PSERIAL_DEVICE_EXTENSION pDevExt;
   NTSTATUS status;

   PAGED_CODE();

   pDevExt = (PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension;

   switch (GuidIndex) {

   case WMI_SERIAL_PORT_NAME_INFORMATION:
   case WMI_SERIAL_PORT_COMM_INFORMATION:
   case WMI_SERIAL_PORT_HW_INFORMATION:
   case WMI_SERIAL_PORT_PERF_INFORMATION:
      status = STATUS_INVALID_DEVICE_REQUEST;
      break;

   default:
      status = STATUS_WMI_GUID_NOT_FOUND;
      break;
   }

   status = WmiCompleteRequest(PDevObj, PIrp,
                                 status, 0, IO_NO_INCREMENT);

   return status;
}


NTSTATUS
SerialSetWmiDataItem(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex, IN ULONG InstanceIndex,
                     IN ULONG DataItemId,
                     IN ULONG BufferSize, IN PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    PBuffer has the new values for the data item


Return Value:

    status

--*/
{
   PAGED_CODE();

   //
   // Toss this request -- we don't support anything for it
   //

   return SerialTossWMIRequest(PDevObj, PIrp, GuidIndex);
}


NTSTATUS
SerialSetWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                      IN ULONG GuidIndex, IN ULONG InstanceIndex,
                      IN ULONG BufferSize,
                      IN PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    BufferSize has the size of the data block passed

    PBuffer has the new values for the data block


Return Value:

    status

--*/
{
   PAGED_CODE();

   //
   // Toss this request -- we don't support anything for it
   //

   return SerialTossWMIRequest(PDevObj, PIrp, GuidIndex);
}


NTSTATUS
SerialQueryWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                        IN ULONG GuidIndex, 
                        IN ULONG InstanceIndex,
                        IN ULONG InstanceCount,
                        IN OUT PULONG InstanceLengthArray,
                        IN ULONG OutBufferSize,
                        OUT PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instnaces expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.        
            
    BufferAvail on has the maximum size available to write the data
        block.

    PBuffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    NTSTATUS status;
    ULONG size = 0;
    PSERIAL_DEVICE_EXTENSION pDevExt
       = (PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension;

    PAGED_CODE();

    switch (GuidIndex) {
    case WMI_SERIAL_PORT_NAME_INFORMATION:
       size = pDevExt->WmiIdentifier.Length;

       if (OutBufferSize < (size + sizeof(USHORT))) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

       if (pDevExt->WmiIdentifier.Buffer == NULL) {
           status = STATUS_INSUFFICIENT_RESOURCES;
           break;
        }

        //
        // First, copy the string over containing our identifier
        //

        *(USHORT *)PBuffer = (USHORT)size;
        (UCHAR *)PBuffer += sizeof(USHORT);

        RtlCopyMemory(PBuffer, pDevExt->WmiIdentifier.Buffer, size);

        //
        // Increment total size to include the WORD containing our len
        //

        size += sizeof(USHORT);
        *InstanceLengthArray = size;
                
        status = STATUS_SUCCESS;

        break;

    case WMI_SERIAL_PORT_COMM_INFORMATION: 
       size = sizeof(SERIAL_WMI_COMM_DATA);

       if (OutBufferSize < size) {
          status = STATUS_BUFFER_TOO_SMALL;
          break;
        }

        *InstanceLengthArray = size;
        *(PSERIAL_WMI_COMM_DATA)PBuffer = pDevExt->WmiCommData;

        status = STATUS_SUCCESS;

        break;

    case WMI_SERIAL_PORT_HW_INFORMATION:
       size = sizeof(SERIAL_WMI_HW_DATA);

       if (OutBufferSize < size) {
          status = STATUS_BUFFER_TOO_SMALL;
          break;
       }

       *InstanceLengthArray = size;
       *(PSERIAL_WMI_HW_DATA)PBuffer = pDevExt->WmiHwData;

       status = STATUS_SUCCESS;

       break;

    case WMI_SERIAL_PORT_PERF_INFORMATION: 
      size = sizeof(SERIAL_WMI_PERF_DATA);

      if (OutBufferSize < size) {
         status = STATUS_BUFFER_TOO_SMALL;
         break;
      }

      *InstanceLengthArray = size;
      *(PSERIAL_WMI_PERF_DATA)PBuffer = pDevExt->WmiPerfData;

      status = STATUS_SUCCESS;

      break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest( PDevObj, PIrp,
                                  status, size, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
SerialQueryWmiRegInfo(IN PDEVICE_OBJECT PDevObj, OUT PULONG PRegFlags,
                      OUT PUNICODE_STRING PInstanceName,
                      OUT PUNICODE_STRING *PRegistryPath,
                      OUT PUNICODE_STRING MofResourceName,
                      OUT PDEVICE_OBJECT *Pdo)
                                                  
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered. 
            
    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.               

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is 
        required
                
    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.
                
    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in 
        *RegFlags.

Return Value:

    status

--*/
{
   PSERIAL_DEVICE_EXTENSION pDevExt
       = (PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension;
   
   PAGED_CODE();

   *PRegFlags = WMIREG_FLAG_INSTANCE_PDO;
   *PRegistryPath = &Driver.RegPath;
   //*PRegistryPath = &SerialGlobals.RegistryPath;
   *Pdo = pDevExt->Pdo;

   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\write.c ===
/*-------------------------------------------------------------------
| write.c -
 1-22-99 - add missing IoReleaseCancelSpinLock() to CompleteWrite(),
   missing since 1-18-99 changes. kpb.
 1-18-99 - Adjust sync lock for write packets to avoid bugchecks with
  wait on tx option. kpb
 9-25-98 - bugfix, immediate write could drop 1 byte due to faulty
   txport buffer check.
Copyright 1993-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

/************************************************************************
Routine Description:
    This is the dispatch routine for write.  It validates the parameters
    for the write request and if all is ok then it places the request
    on the work queue.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request
Return Value:
    If the io is zero length then it will return STATUS_SUCCESS,
    otherwise this routine will return STATUS_PENDING.
************************************************************************/
NTSTATUS
SerialWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    NTSTATUS Status;
    BOOLEAN acceptingIRPs;

    acceptingIRPs = SerialIRPPrologue(Extension);

    if (acceptingIRPs == FALSE) {
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
      SerialCompleteRequest(Extension, Irp, IO_NO_INCREMENT);
      return STATUS_NO_SUCH_DEVICE;
   }

   if (Extension->DeviceType == DEV_BOARD)
   {
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
      SerialCompleteRequest (Extension, Irp, IO_NO_INCREMENT);
      return STATUS_NOT_SUPPORTED;
   };

#ifdef TRACE_PORT
    if (Extension->TraceOptions)
    {
      if (Extension->TraceOptions & 1)  // trace messages
      {
        Tprintf("Write, Len:%d",
          (ULONG) IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length);

        // dump data into the trace buffer in a hex or ascii dump format
        TraceDump(Extension,
                  Irp->AssociatedIrp.SystemBuffer,
                  IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length,0);
      }
      else if (Extension->TraceOptions & 4)  // trace output data
      {
        TracePut(
                 Irp->AssociatedIrp.SystemBuffer,
                 IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length);
      }
    }
#endif

    if (Extension->ErrorWord)
    {
      if (SerialCompleteIfError( DeviceObject, Irp ) != STATUS_SUCCESS)
      {
        ExtTrace(Extension,D_Error, " ErrorSet!");
        return STATUS_CANCELLED;
      }
    }

    Irp->IoStatus.Information = 0L;

    // Quick check for a zero length write.  If it is zero length
    // then we are already done!
    if (IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length)
    {
//------ 10-22-96, start code addition to speed up 1-byte writes
#define WRT_LEN (IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length)

#ifdef S_VS
  // vs1000 code
      if (!Extension->port_config->WaitOnTx)  // have to let ISR handle physical end detect
      {
      if (WRT_LEN < OUT_BUF_SIZE)
      {
         // ISR is locked out since it only handles IRP's queued up
         // any other contention problems?
        //extension->lock_out_other_tasks = 1;
        if ((Extension->CurrentWriteIrp == NULL)  // no current write
            && (IsListEmpty(&Extension->WriteQueue)))  // no queued up output data
        {
          // if room in hardware
          // bug: kpb, 9-22-98
          //if ( (ULONG)(OUT_BUF_SIZE-PortGetTxCnt(Extension->Port)) >= WRT_LEN)
          if ( (ULONG)(PortGetTxRoom(Extension->Port)) > WRT_LEN)
          {

                             // Send it all ,WriteTxBlk will chk fifo
            q_put(&Extension->Port->QOut,
                        (PUCHAR)(Irp->AssociatedIrp.SystemBuffer),
                        WRT_LEN);
            Extension->ISR_Flags |= TX_NOT_EMPTY;  // use to detect fifo empty
            Extension->OurStats.TransmittedCount += WRT_LEN;
            ++Extension->sent_packets;
            Irp->IoStatus.Information = WRT_LEN;
            ExtTrace(Extension,D_Ioctl, " ,IMMED. WRITE");

            Irp->IoStatus.Status = STATUS_SUCCESS;
            SerialCompleteRequest(Extension, Irp, 0);
            return STATUS_SUCCESS;
          }
        }
      } // if (WRT_LEN < OUT_BUF_SIZE)
      } // if (!Extension->port_config->WaitOnTx)
#else
  // rocketport code
      if (!Extension->port_config->WaitOnTx)  // have to let ISR handle physical end detect
      {
      if (WRT_LEN <= MAXTX_SIZE)
      {
         // ISR is locked out since it only handles IRP's queued up
        if ((Extension->CurrentWriteIrp == NULL)  // no current write
            && (IsListEmpty(&Extension->WriteQueue)))  // no queued up output data
        {
          // if room in hardware
          if ( (ULONG)(MAXTX_SIZE-sGetTxCnt(Extension->ChP)) >= WRT_LEN)
          {
            if (Extension->Option & OPTION_RS485_SOFTWARE_TOGGLE)
            {
              if ((Extension->DTRRTSStatus & SERIAL_RTS_STATE) == 0)
              {
                sSetRTS(Extension->ChP);
                Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
              }
            }
                             // Send it all ,WriteTxBlk will chk fifo
            sWriteTxBlk(Extension->ChP,
                        (PUCHAR)(Irp->AssociatedIrp.SystemBuffer),
                        WRT_LEN);
            Extension->ISR_Flags |= TX_NOT_EMPTY;  // use to detect fifo empty
            Extension->OurStats.TransmittedCount += WRT_LEN;
            ++Extension->sent_packets;
            Irp->IoStatus.Information = WRT_LEN;
            ExtTrace(Extension,D_Ioctl, " ,IMMED. WRITE");

            ++Extension->sent_packets;
            Irp->IoStatus.Status = STATUS_SUCCESS;
            SerialCompleteRequest(Extension, Irp, 0);
            return STATUS_SUCCESS;
          }
        }
      } // if (WRT_LEN <= MAXTX_SIZE)
      } // if (!Extension->port_config->WaitOnTx)
#endif  // rocketport code

//------ 10-22-96, end  code addition to speed up 1-byte writes

        // Put the write on the queue so that we can
        // process it when our previous writes are done.
        ++Extension->sent_packets;

        Status = SerialStartOrQueue(
                   Extension,
                   Irp,
                   &Extension->WriteQueue,
                   &Extension->CurrentWriteIrp,
                   SerialStartWrite
                   );
        if  (Status == STATUS_PENDING)
        {
          ExtTrace(Extension,D_Ioctl, " ,PENDING");
        }
        return Status;
    }
    else   // if (IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length)
    {
        Irp->IoStatus.Status = STATUS_SUCCESS;

        SerialCompleteRequest(Extension, Irp, 0 );

        return STATUS_SUCCESS;
    }
}


/***************************************************************************
Routine Description:
    This routine is used to start off any write.  It initializes
    the Iostatus fields of the irp.  It will set up any timers
    that are used to control the write.
Arguments:
    Extension - Points to the serial device extension
Return Value:
    This routine will return STATUS_PENDING for all writes
    other than those that we find are cancelled.
***************************************************************************/
NTSTATUS
SerialStartWrite(
    IN PSERIAL_DEVICE_EXTENSION Extension
    )
{
    PIRP NewIrp;
    KIRQL OldIrql;
    LARGE_INTEGER TotalTime;
    BOOLEAN UseATimer;
    SERIAL_TIMEOUTS Timeouts;
    BOOLEAN SetFirstStatus = FALSE;
    NTSTATUS FirstStatus;

    do {
        // If there is an xoff counter then complete it.

#ifdef REMOVED   // Will not suppor Xoff Counter IRP
        IoAcquireCancelSpinLock(&OldIrql);

        // We see if there is a actually an Xoff counter irp.
        // If there is, we put the write irp back on the head
        // of the write list.  We then kill the xoff counter.
        // The xoff counter killing code will actually make the
        // xoff counter back into the current write irp, and
        // in the course of completing the xoff (which is now
        // the current write) we will restart this irp.

        if(Extension->CurrentXoffIrp)
        {
            if (SERIAL_REFERENCE_COUNT(Extension->CurrentXoffIrp)) {
            {
                // The reference count is non-zero.  This implies that
                // the xoff irp has not made it through the completion
                // path yet.  We will increment the reference count
                // and attempt to complete it ourseleves.

                SERIAL_SET_REFERENCE(
                    Extension->CurrentXoffIrp,
                    SERIAL_REF_XOFF_REF
                    );

                //
                // The following call will actually release the
                // cancel spin lock.
                //

                SerialTryToCompleteCurrent(
                    Extension,
                    SerialGrabXoffFromIsr,
                    OldIrql,
                    STATUS_SERIAL_MORE_WRITES,
                    &Extension->CurrentXoffIrp,
                    NULL,
                    NULL,
                    &Extension->XoffCountTimer,
                    NULL,
                    NULL,
                    SERIAL_REF_XOFF_REF
                    );

            } else {

                //
                // The irp is well on its way to being finished.
                // We can let the regular completion code do the
                // work.  Just release the spin lock.
                //

                IoReleaseCancelSpinLock(OldIrql);

            }

        }
        else
        {
            IoReleaseCancelSpinLock(OldIrql);
        }
#endif //REMOVED

        UseATimer = FALSE;

        // Calculate the timeout value needed for the
        // request.  Note that the values stored in the
        // timeout record are in milliseconds.  Note that
        // if the timeout values are zero then we won't start
        // the timer.

        KeAcquireSpinLock( &Extension->ControlLock, &OldIrql );

        Timeouts = Extension->Timeouts;

        KeReleaseSpinLock( &Extension->ControlLock, OldIrql );

        if (Timeouts.WriteTotalTimeoutConstant ||
            Timeouts.WriteTotalTimeoutMultiplier)
        {
            PIO_STACK_LOCATION IrpSp = 
                 IoGetCurrentIrpStackLocation(Extension->CurrentWriteIrp);
            UseATimer = TRUE;
            TotalTime.QuadPart =
                ((LONGLONG)((UInt32x32To64(
                                 (IrpSp->MajorFunction == IRP_MJ_WRITE)?
                                     (IrpSp->Parameters.Write.Length):
                                     (1),
                                 Timeouts.WriteTotalTimeoutMultiplier
                                 )
                                 + Timeouts.WriteTotalTimeoutConstant)))
                * -10000;
        }

        // The irp may be going to the isr shortly.  Now
        // is a good time to initialize its reference counts.

        SERIAL_INIT_REFERENCE(Extension->CurrentWriteIrp);

        // We need to see if this irp should be canceled.

        IoAcquireCancelSpinLock(&OldIrql);

        if (Extension->CurrentWriteIrp->Cancel)
        {
            IoReleaseCancelSpinLock(OldIrql);
            ExtTrace(Extension,D_Ioctl, " (write canceled)");
            Extension->CurrentWriteIrp->IoStatus.Status = STATUS_CANCELLED;
            if (!SetFirstStatus)
            {
                FirstStatus = STATUS_CANCELLED;
                SetFirstStatus = TRUE;
            }
        }
        else
        {
            if(!SetFirstStatus)
            {
                // If we haven't set our first status, then
                // this is the only irp that could have possibly
                // not been on the queue.  (It could have been
                // on the queue if this routine is being invoked
                // from the completion routine.)  Since this
                // irp might never have been on the queue we
                // should mark it as pending.

                IoMarkIrpPending(Extension->CurrentWriteIrp);
                SetFirstStatus = TRUE;
                FirstStatus = STATUS_PENDING;

            }

            // We give the irp to to the isr to write out.
            // We set a cancel routine that knows how to
            // grab the current write away from the isr.
            // Since the cancel routine has an implicit reference
            // to this irp up the reference count.

            IoSetCancelRoutine(
                Extension->CurrentWriteIrp,
                SerialCancelCurrentWrite
                );

            SERIAL_SET_REFERENCE(
                Extension->CurrentWriteIrp,
                SERIAL_REF_CANCEL
                );

            if(UseATimer)
            {
                //ExtTrace(Extension,D_Ioctl, " (total timer used)");
                KeSetTimer(
                    &Extension->WriteRequestTotalTimer,
                    TotalTime,
                    &Extension->TotalWriteTimeoutDpc
                    );

                // This timer now has a reference to the irp.
                SERIAL_SET_REFERENCE(
                    Extension->CurrentWriteIrp,
                    SERIAL_REF_TOTAL_TIMER
                    );
            }
#ifdef NEW_WRITE_SYNC_LOCK
            // write some data now
            SyncUp(Driver.InterruptObject,
               &Driver.TimerLock,
               SerialGiveWriteToIsr,
               Extension);
#else
            SerialGiveWriteToIsr(Extension);
#endif
            IoReleaseCancelSpinLock(OldIrql);
            break;
        }

        // Well the write was canceled before we could start it up.
        // Try to get another.

        SerialGetNextWrite(
            &Extension->CurrentWriteIrp,
            &Extension->WriteQueue,
            &NewIrp,
            TRUE,
            Extension
            );
    } while (NewIrp);

    return FirstStatus;
}

/****************************************************************************
Routine Description:
    This routine completes the old write as well as getting
    a pointer to the next write.
    The reason that we have have pointers to the current write
    queue as well as the current write irp is so that this
    routine may be used in the common completion code for
    read and write.
Arguments:
    CurrentOpIrp - Pointer to the pointer that points to the
                   current write irp.
    QueueToProcess - Pointer to the write queue.
    NewIrp - A pointer to a pointer to the irp that will be the
             current irp.  Note that this could end up pointing
             to a null pointer.  This does NOT necessaryly mean
             that there is no current write.  What could occur
             is that while the cancel lock is held the write
             queue ended up being empty, but as soon as we release
             the cancel spin lock a new irp came in from
             SerialStartWrite.
    CompleteCurrent - Flag indicates whether the CurrentOpIrp should
                      be completed.
Return Value:
    None.
****************************************************************************/
VOID
SerialGetNextWrite(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent,
    PSERIAL_DEVICE_EXTENSION Extension
    )
{
//    LARGE_INTEGER charTime; // 100 ns ticks per char, related to baud rate
//    LARGE_INTEGER WaitTime; // Actual time req'd for buffer to drain

//    PSERIAL_DEVICE_EXTENSION Extension = CONTAINING_RECORD(
//                                             QueueToProcess,
 //                                            SERIAL_DEVICE_EXTENSION,
 //                                            WriteQueue
//                                             );

    do {
        // We could be completing a flush.

        if (IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction
            == IRP_MJ_WRITE)
        {  //------- normal write block
            KIRQL OldIrql;

            // assert that our TotalCharsQueued var is not screwed up.
            MyAssert(Extension->TotalCharsQueued >=
                   (IoGetCurrentIrpStackLocation(*CurrentOpIrp)
                    ->Parameters.Write.Length));

            IoAcquireCancelSpinLock(&OldIrql);

            // increment our character count
            Extension->TotalCharsQueued -=
                IoGetCurrentIrpStackLocation(*CurrentOpIrp)
                ->Parameters.Write.Length;

            IoReleaseCancelSpinLock(OldIrql);

        }
        else if (IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction
                   == IRP_MJ_DEVICE_CONTROL)
        {   //------- xoffcounter nonsense
            KIRQL OldIrql;
            PIRP Irp;
            PSERIAL_XOFF_COUNTER Xc;

            IoAcquireCancelSpinLock(&OldIrql);

            Irp = *CurrentOpIrp;
            Xc = Irp->AssociatedIrp.SystemBuffer;

            //
            // We should never have a xoff counter when we
            // get to this point.
            //

            ASSERT(!Extension->CurrentXoffIrp);

            //
            // We absolutely shouldn't have a cancel routine
            // at this point.
            //

            ASSERT(!Irp->CancelRoutine);

            // If CurrentXoffIrp is not equal to null, this
            // implies that this is the "second" time around
            // for this irp, which implies that we should really
            // be completing it this time.


            //
            // This could only be a xoff counter masquerading as
            // a write irp.
            //

            Extension->TotalCharsQueued--;

            //
            // Check to see of the xoff irp has been set with success.
            // This means that the write completed normally.  If that
            // is the case, and it hasn't been set to cancel in the
            // meanwhile, then go on and make it the CurrentXoffIrp.
            //

            if (Irp->IoStatus.Status != STATUS_SUCCESS) {

                //
                // Oh well, we can just finish it off.
                //
                NOTHING;

            } else if (Irp->Cancel) {

                Irp->IoStatus.Status = STATUS_CANCELLED;

            } else {

                //
                // Give it a new cancel routine, and increment the
                // reference count because the cancel routine has
                // a reference to it.
                //

                IoSetCancelRoutine(
                    Irp,
                    SerialCancelCurrentXoff
                    );

                SERIAL_SET_REFERENCE(
                    Irp,
                    SERIAL_REF_CANCEL
                    );

                //
                // We don't want to complete the current irp now.  This
                // will now get completed by the Xoff counter code.
                //

                CompleteCurrent = FALSE;

                //
                // Give the counter to the isr.
                //

                Extension->CurrentXoffIrp = Irp;
                //KeSynchronizeExecution(
                //    Driver.Interrupt,
                //    SerialGiveXoffToIsr,
                //    Extension
                //    );
                SerialGiveXoffToIsr(Extension);

                //
                // Start the timer for the counter and increment
                // the reference count since the timer has a
                // reference to the irp.
                //

                if(Xc->Timeout) 
                {
                  LARGE_INTEGER delta;
                  delta.QuadPart = -((LONGLONG)UInt32x32To64(
                                                     1000,
                                                     Xc->Timeout
                                                     ));

                  KeSetTimer(
                        &Extension->XoffCountTimer,
                        delta,
                        &Extension->XoffCountTimeoutDpc
                        );
                  SERIAL_SET_REFERENCE(Irp,SERIAL_REF_TOTAL_TIMER);
                }  // timeout
              }
              IoReleaseCancelSpinLock(OldIrql);
            }

        //
        // Note that the following call will (probably) also cause
        // the current irp to be completed.
        //

        SerialGetNextIrp(
            CurrentOpIrp,
            QueueToProcess,
            NewIrp,
            CompleteCurrent,
            Extension
            );

        if (!*NewIrp) {

            KIRQL OldIrql;

            IoAcquireCancelSpinLock(&OldIrql);
            //KeSynchronizeExecution(
            //    Extension->Interrupt,
            //    SerialProcessEmptyTransmit,
            //    Extension
            //    );
            //SerialProcessEmptyTransmit();
            IoReleaseCancelSpinLock(OldIrql);

            break;

        }
        else if (IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction ==
                                                 IRP_MJ_FLUSH_BUFFERS )
        {  //------ flush operation
           // If flush, wait for Tx FIFO to empty before completing
           ExtTrace(Extension,D_Ioctl, "(end flush write)");
#ifdef S_RK
#ifdef COMMENT_OUT
  (took this out 9-22-97 - kpb)
           // Calculate 100ns ticks to delay for each character
           // Negate for call to KeDelay...
           charTime = RtlLargeIntegerNegate(SerialGetCharTime(Extension));

           // While Tx FIFO and Tx Shift Register aren't empty
           while ( (sGetChanStatusLo(Extension->ChP) & DRAINED) != DRAINED )
           {  WaitTime = RtlExtendedIntegerMultiply(charTime,
                                                    sGetTxCnt(Extension->ChP)
                                                    );
              KeDelayExecutionThread(KernelMode,FALSE,&WaitTime);
           }
#endif
#endif
            //
            // If we encounter a flush request we just want to get
            // the next irp and complete the flush.
            //
            // Note that if NewIrp is non-null then it is also
            // equal to CurrentWriteIrp.
            //

            ASSERT((*NewIrp) == (*CurrentOpIrp));
            (*NewIrp)->IoStatus.Status = STATUS_SUCCESS;
        }   
        else {

            break;

        }
    } while (TRUE);
}


/********************************************************************
Routine Description:
    This routine is merely used to complete any write.  It
    assumes that the status and the information fields of
    the irp are already correctly filled in.
Arguments:
    Dpc - Not Used.
    DeferredContext - Really points to the device extension.
    SystemContext1 - Not Used.
    SystemContext2 - Not Used.
Return Value:
    None.
*********************************************************************/
VOID
SerialCompleteWrite(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{
    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    // make sure no one else grabbed it first, since ISR will
    // set this flag to 2 to indicate it is ours to end.
    if (Extension->WriteBelongsToIsr == 2)
    {
      Extension->WriteBelongsToIsr = 0;
      SerialTryToCompleteCurrent(
        Extension,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &Extension->CurrentWriteIrp,
        &Extension->WriteQueue,
        NULL,
        &Extension->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite,
        SERIAL_REF_ISR
        );
    }
    else
    {
      IoReleaseCancelSpinLock(OldIrql);
    }
}

/******************************************************************************
Routine Description:
    Try to start off the write by slipping it in behind
    a transmit immediate char, or if that isn't available
    and the transmit holding register is empty, "tickle"
    the UART into interrupting with a transmit buffer
    empty.
    NOTE: This routine is called by KeSynchronizeExecution.
    NOTE: This routine assumes that it is called with the
          cancel spin lock held.
Arguments:
    Context - Really a pointer to the device extension.
Return Value:
    This routine always returns FALSE.
******************************************************************************/
BOOLEAN
SerialGiveWriteToIsr(
    IN PVOID Context
    )
{
  PSERIAL_DEVICE_EXTENSION Extension = Context;
  ULONG wCount;
  ULONG room;
  ULONG write_cnt;
  ULONG OurWriteLength;

  // The current stack location.  This contains all of the
  // information we need to process this particular request.

  PIO_STACK_LOCATION IrpSp;

  IrpSp = IoGetCurrentIrpStackLocation(Extension->CurrentWriteIrp);

  // We might have a xoff counter request masquerading as a
  // write.  The length of these requests will always be one
  // and we can get a pointer to the actual character from
  // the data supplied by the user.

  if (IrpSp->MajorFunction == IRP_MJ_WRITE)
  {
    //------ start code addition to avoid tx-lag, see if we can start
    // sending data to hardware immediately

    OurWriteLength = IrpSp->Parameters.Write.Length;
    write_cnt = 0;  // use this as a flag as well if we will write() now.
    if ((IsListEmpty(&Extension->WriteQueue)))  // no queued up output data
    {
      // the startwrite routine added CurrentWriteIrp which is us,
      // so we are the only Write Irp in existence.  This is important
      // so that isr.c is not trying to serve up off our irp que too.

      //// [bug, 3-28-98, kpb] room = sGetTxCnt(Extension->ChP);
#ifdef S_RK
      room = (ULONG)(MAXTX_SIZE-sGetTxCnt(Extension->ChP));
#else
      room = (ULONG) PortGetTxRoom(Extension->Port);
#endif
      if (room > 10)  // we have room in the hardware
      {
        // at this point we have some non-trivial amount of space in
        // the hardware buffer to put some data.
        write_cnt = IrpSp->Parameters.Write.Length;
      }

      if (write_cnt)  // we are going to write() now
      {
#ifdef S_RK
        // toggle rts if needed
        if (Extension->Option & OPTION_RS485_SOFTWARE_TOGGLE)
        {
          if ((Extension->DTRRTSStatus & SERIAL_RTS_STATE) == 0)
          {
            sSetRTS(Extension->ChP);
            Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
          }
        }
                         // Send as much as possible,WriteTxBlk will chk fifo
        wCount = sWriteTxBlk(Extension->ChP,
                    (PUCHAR)(Extension->CurrentWriteIrp->AssociatedIrp.SystemBuffer),
                    write_cnt);
#else

                             // Send it all ,WriteTxBlk will chk fifo
        if (write_cnt > room)  // limit to what we have space for
             wCount = room;
        else wCount = write_cnt;
        q_put(&Extension->Port->QOut,
              (PUCHAR)(Extension->CurrentWriteIrp->AssociatedIrp.SystemBuffer),
                       wCount);
#endif
        Extension->OurStats.TransmittedCount += wCount;
        Extension->CurrentWriteIrp->IoStatus.Information += wCount;

        // following used to detect fifo empty, semaphore
        // which passes control to the ISR routine.
        OurWriteLength = (IrpSp->Parameters.Write.Length - wCount);
        Extension->ISR_Flags |= TX_NOT_EMPTY;  
        // and gives this write to ISR
        ExtTrace(Extension,D_Ioctl, " , Immed Part Write");
      }  // write() it out
    }  // no queue write packets


    //------ 1-08-98, end code addition to avoid tx-lag
    //add irp to queue, give isr.c the write irp to finish
    Extension->WriteLength = OurWriteLength;
    if (Extension->port_config->WaitOnTx)
    {
      // then definitely let ISR finish it, ISR must wait for tx-fifo to drain
      Extension->WriteBelongsToIsr = 1;
    }
    else
    {
      if (OurWriteLength == 0)
      {
        // its done, finish it off
        Extension->WriteBelongsToIsr = 2;
        KeInsertQueueDpc( &Extension->CompleteWriteDpc, NULL, NULL );
      }
      else
        Extension->WriteBelongsToIsr = 1;
    }
  }
  else
  {
    // !!!!! WHAT is a xoff counter????
    // An xoff-counter is something the virtual 16450 uart driver uses
    // to send an xoff, it sends an xoff and also starts a timer for
    // what purpose I am not sure.  Tried some code where it just sends
    // an xoff without the timer, this seemed to work ok, but the sent
    // xoff should be synced up with the other outgoing data packets in
    // the order received from the app.

      //It's an xoff counter......
      Extension->WriteLength = 1;
      Extension->WriteCurrentChar =
          ((PUCHAR)Extension->CurrentWriteIrp->AssociatedIrp.SystemBuffer) +
          FIELD_OFFSET(SERIAL_XOFF_COUNTER, XoffChar);
  }

//endwr:

  // The isr now has a reference to the irp.
  SERIAL_SET_REFERENCE(
        Extension->CurrentWriteIrp,
        SERIAL_REF_ISR
        );

  return FALSE;
}

/****************************************************************************
Routine Description:
    This routine is used to cancel the current write.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP to be canceled.
Return Value:
    None.
*****************************************************************************/
VOID
SerialCancelCurrentWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;

    ExtTrace(Extension,D_Ioctl, "(cancel cur-write)");
    SerialTryToCompleteCurrent(
        Extension,
        SerialGrabWriteFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &Extension->CurrentWriteIrp,
        &Extension->WriteQueue,
        NULL,
        &Extension->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite,
        SERIAL_REF_CANCEL
        );
}


/***************************************************************************
Routine Description:
    This routine will try to timeout the current write.
Arguments:
    Dpc - Not Used.
    DeferredContext - Really points to the device extension.
    SystemContext1 - Not Used.
    SystemContext2 - Not Used.
Return Value:
    None.
***************************************************************************/
VOID
SerialWriteTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{
    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    ExtTrace(Extension,D_Ioctl, "(write-timeout)");
    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        Extension,
        SerialGrabWriteFromIsr,
        OldIrql,
        STATUS_TIMEOUT,
        &Extension->CurrentWriteIrp,
        &Extension->WriteQueue,
        NULL,
        &Extension->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite,
        SERIAL_REF_TOTAL_TIMER
        );
}

/***************************************************************************
Routine Description:
    This routine is used to grab the current irp, which could be timing
    out or canceling, from the ISR
    NOTE: This routine is being called from KeSynchronizeExecution.
    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.
Arguments:
    Context - Really a pointer to the device extension.
Return Value:
    Always false.
***************************************************************************/
BOOLEAN
SerialGrabWriteFromIsr(
    IN PVOID Context
    )
{
    PSERIAL_DEVICE_EXTENSION Extension = Context;
#ifdef NEW_WAIT
    ULONG in_q;
#endif

#ifdef NEW_WAIT
    if (Extension->WriteBelongsToIsr != 0)
    {
        // isr owns irp, or it is has queued dpc to complete it.
        // reset this flag to take back from the isr.
        Extension->WriteBelongsToIsr = 0;

        // We could have an xoff counter masquerading as a
        // write irp.  If so, don't update the write length.

        if (IoGetCurrentIrpStackLocation(Extension->CurrentWriteIrp)
            ->MajorFunction != IRP_MJ_WRITE)
        {
            Extension->CurrentWriteIrp->IoStatus.Information = 0;
        }
        else
        {
           SERIAL_CLEAR_REFERENCE(Extension->CurrentWriteIrp,
                                  SERIAL_REF_ISR);

           Extension->WriteLength = 0;
           if (Extension->port_config->WaitOnTx)
           {
             // want to report how many characters are "stuck", or did
             // not really make it out the port if a timeout occurs.
#ifdef S_RK
             in_q = sGetTxCnt(Extension->ChP);
#else
             //  may have add in box cout too?
             in_q = PortGetTxCnt(Extension->Port);
#endif
             if (Extension->CurrentWriteIrp->IoStatus.Information >= in_q)
               Extension->CurrentWriteIrp->IoStatus.Information -= in_q;
           }
        }
    }
#else
    // Check if the write length is non-zero.  If it is non-zero
    // then the ISR still owns the irp. We calculate the the number
    // of characters written and update the information field of the
    // irp with the characters written.  We then clear the write length
    // the isr sees.
    if (Extension->WriteLength)
    {
        // We could have an xoff counter masquerading as a
        // write irp.  If so, don't update the write length.

        if (IoGetCurrentIrpStackLocation(Extension->CurrentWriteIrp)
            ->MajorFunction == IRP_MJ_WRITE)
        {
            Extension->CurrentWriteIrp->IoStatus.Information =
                IoGetCurrentIrpStackLocation(
                    Extension->CurrentWriteIrp
                    )->Parameters.Write.Length -
                Extension->WriteLength;
        }
        else
        {
            Extension->CurrentWriteIrp->IoStatus.Information = 0;
        }

        SERIAL_CLEAR_REFERENCE(Extension->CurrentWriteIrp,
                               SERIAL_REF_ISR);

        Extension->WriteLength = 0;

    }
#endif

    return FALSE;
}

// Xoff Counter code: UNUSED
/*-----------------------------------------------------------------
SerialGrabXoffFromIsr -
Routine Description:
    This routine is used to grab an xoff counter irp from the
    isr when it is no longer masquerading as a write irp.  This
    routine is called by the cancel and timeout code for the
    xoff counter ioctl.
    NOTE: This routine is being called from KeSynchronizeExecution.
    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.
Arguments:
    Context - Really a pointer to the device extension.
Return Value:
    Always false.
|-----------------------------------------------------------------*/
BOOLEAN
SerialGrabXoffFromIsr(
    IN PVOID Context
    )
{
    PSERIAL_DEVICE_EXTENSION Extension = Context;

    if (Extension->CountSinceXoff) {

        //
        // This is only non-zero when there actually is a Xoff ioctl
        // counting down.
        //

        Extension->CountSinceXoff = 0;

        //
        // We decrement the count since the isr no longer owns
        // the irp.
        //

        SERIAL_CLEAR_REFERENCE(
            Extension->CurrentXoffIrp,
            SERIAL_REF_ISR
            );

    }

    return FALSE;
}

/******************************************************************************
Routine Description:
    This routine is merely used to truely complete an xoff counter irp.  It
    assumes that the status and the information fields of the irp are
    already correctly filled in.
Arguments:
    Dpc - Not Used.
    DeferredContext - Really points to the device extension.
    SystemContext1 - Not Used.
    SystemContext2 - Not Used.
Return Value:
    None.
******************************************************************************/
VOID
SerialCompleteXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{

    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        Extension,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &Extension->CurrentXoffIrp,
        NULL,
        NULL,
        &Extension->XoffCountTimer,
        NULL,
        NULL,
        SERIAL_REF_ISR
        );

}


/*------------------------------------------------------------------
Routine Description:
    This routine is merely used to truely complete an xoff counter irp,
    if its timer has run out.
Arguments:
    Dpc - Not Used.
    DeferredContext - Really points to the device extension.
    SystemContext1 - Not Used.
    SystemContext2 - Not Used.
Return Value:
    None.
-------------------------------------------------------------------*/
VOID
SerialTimeoutXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{

    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        Extension,
        SerialGrabXoffFromIsr,
        OldIrql,
        STATUS_SERIAL_COUNTER_TIMEOUT,
        &Extension->CurrentXoffIrp,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        SERIAL_REF_TOTAL_TIMER
        );

}

/*---------------------------------------------------------------
Routine Description:
    This routine is used to cancel the current write.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP to be canceled.
Return Value:
    None.
----------------------------------------------------------------*/
VOID
SerialCancelCurrentXoff(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;

    SerialTryToCompleteCurrent(
        Extension,
        SerialGrabXoffFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &Extension->CurrentXoffIrp,
        NULL,
        NULL,
        &Extension->XoffCountTimer,
        NULL,
        NULL,
        SERIAL_REF_CANCEL
        );
}

/*------------------------------------------------------------------------
Routine Description:
    This routine starts off the xoff counter.  It merely
    has to set the xoff count and increment the reference
    count to denote that the isr has a reference to the irp.
    NOTE: This routine is called by KeSynchronizeExecution.
    NOTE: This routine assumes that it is called with the
          cancel spin lock held.
Arguments:
    Context - Really a pointer to the device extension.
Return Value:
    This routine always returns FALSE.
------------------------------------------------------------------------*/
BOOLEAN
SerialGiveXoffToIsr(
    IN PVOID Context
    )
{

    PSERIAL_DEVICE_EXTENSION Extension = Context;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PSERIAL_XOFF_COUNTER Xc =
        Extension->CurrentXoffIrp->AssociatedIrp.SystemBuffer;

    Extension->CountSinceXoff = Xc->Counter;

    // The isr now has a reference to the irp.
    SERIAL_SET_REFERENCE(
        Extension->CurrentXoffIrp,
        SERIAL_REF_ISR
        );

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\wmi.h ===
// wmi.h

#define SERIAL_WMI_PARITY_NONE  0U
#define SERIAL_WMI_PARITY_ODD   1U
#define SERIAL_WMI_PARITY_EVEN  2U
#define SERIAL_WMI_PARITY_SPACE 3U
#define SERIAL_WMI_PARITY_MARK  4U

#define SERIAL_WMI_STOP_1   0U
#define SERIAL_WMI_STOP_1_5 1U
#define SERIAL_WMI_STOP_2   2U

#define SERIAL_WMI_INTTYPE_LATCHED 0U
#define SERIAL_WMI_INTTYPE_LEVEL   1U

typedef struct _SERIAL_WMI_COMM_DATA {
   //
   // Name -- inside struct
   //

   //
   // Baud rate
   //

   UINT32 BaudRate;

   //
   // BitsPerByte;
   //

   UINT32 BitsPerByte;

   //
   // Parity -- see SERIAL_WMI_PARITY_XXXX
   //

   UINT32 Parity;

   //
   // Parity Enabled
   //

   BOOLEAN ParityCheckEnable;

   //
   // Stop Bits - see SERIAL_WMI_STOP_XXXX
   //

   UINT32 StopBits;

   //
   // XOff Character
   //

   UINT32 XoffCharacter;

   //
   // Xoff Xmit Threshold
   //

   UINT32 XoffXmitThreshold;

   //
   // XOn Character
   //

   UINT32 XonCharacter;

   //
   // XonXmit Threshold
   //

   UINT32 XonXmitThreshold;

   //
   // Maximum Baud Rate
   //

   UINT32 MaximumBaudRate;

   //
   // Maximum Output Buffer Size
   //

   UINT32 MaximumOutputBufferSize;

   //
   // Support 16-bit mode (NOT!)
   //

   BOOLEAN Support16BitMode;

   //
   // Support DTRDSR
   //

   BOOLEAN SupportDTRDSR;

   //
   // Support Interval Timeouts
   //

   BOOLEAN SupportIntervalTimeouts;

   //
   // Support parity check
   //

   BOOLEAN SupportParityCheck;

   //
   // Support RTS CTS
   //

   BOOLEAN SupportRTSCTS;

   //
   // Support XOnXOff
   //

   BOOLEAN SupportXonXoff;

   //
   // Support Settable Baud Rate
   //

   BOOLEAN SettableBaudRate;

   //
   // Settable Data Bits
   //

   BOOLEAN SettableDataBits;

   //
   // Settable Flow Control
   //

   BOOLEAN SettableFlowControl;

   //
   // Settable Parity
   //

   BOOLEAN SettableParity;

   //
   // Settable Parity Check
   //

   BOOLEAN SettableParityCheck;

   //
   // Settable Stop Bits
   //

   BOOLEAN SettableStopBits;

   //
   // Is Busy
   //

   BOOLEAN IsBusy;

} SERIAL_WMI_COMM_DATA, *PSERIAL_WMI_COMM_DATA;

typedef struct _SERIAL_WMI_HW_DATA {
   //
   // IRQ Number
   //

   UINT32 IrqNumber;

   //
   // IRQ Vector;
   //

   UINT32 IrqVector;

   //
   // IRQ Level
   //

   UINT32 IrqLevel;

   //
   // IRQ Affinity Mask
   //

   UINT32 IrqAffinityMask;

   //
   // Interrupt Type
   //

   UINT32 InterruptType;

   //
   // Base IO Addr
   //

   ULONG_PTR BaseIOAddress;

} SERIAL_WMI_HW_DATA, *PSERIAL_WMI_HW_DATA;


typedef struct _SERIAL_WMI_PERF_DATA {

   //
   // Bytes received in current session
   //

   UINT32 ReceivedCount;

   //
   // Bytes transmitted in current session
   //

   UINT32 TransmittedCount;

   //
   // Framing errors in current session
   //

   UINT32 FrameErrorCount;

   //
   // Serial overrun errors in current session
   //

   UINT32 SerialOverrunErrorCount;

   //
   // Buffer overrun errors in current session
   //

   UINT32 BufferOverrunErrorCount;

   //
   // Parity errors in current session
   //

   UINT32 ParityErrorCount;
} SERIAL_WMI_PERF_DATA, *PSERIAL_WMI_PERF_DATA;


#define SERIAL_WMI_GUID_LIST_SIZE 4

extern WMIGUIDREGINFO SerialWmiGuidList[SERIAL_WMI_GUID_LIST_SIZE];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\write.h ===
//--- write.h

NTSTATUS
SerialWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialStartWrite(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

VOID
SerialGetNextWrite(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent,
    PSERIAL_DEVICE_EXTENSION Extension
    );

VOID
SerialCompleteWrite(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );


BOOLEAN
SerialGiveWriteToIsr(
    IN PVOID Context
    );

VOID
SerialCancelCurrentWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

VOID
SerialWriteTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

BOOLEAN
SerialGrabWriteFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGrabXoffFromIsr(
    IN PVOID Context
    );

VOID
SerialCompleteXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialTimeoutXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialCancelCurrentXoff(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
SerialGiveXoffToIsr(
    IN PVOID Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\driver\waitmask.h ===
//---- waitmask.h

NTSTATUS
SerialStartMask(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

BOOLEAN
SerialGrabWaitFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGiveWaitToIsr(
    IN PVOID Context
    );

BOOLEAN
SerialFinishOldWait(
    IN PVOID Context
    );

VOID
SerialCancelWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SerialCompleteWait(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\infs\makefile.inc ===
_LNG=$(LANGUAGE)
_INX=.
STAMP=stampinf -f $@ -d date -v 4.34.0.0

$(O)\netctmrk.inf: $(_INX)\netctmrk.inx $(_LNG)\netctmrk.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@   
    $(STAMP)          
    
$(O)\mdmctm1.inf: $(_INX)\mdmctm1.inx $(_LNG)\mdmctm1.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)          

$(O)\ctmaport.inf: $(_INX)\ctmaport.inx $(_LNG)\ctmaport.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\addwiz.h ===
// addwiz.h

int DoAddWizPropPages(HWND hwndOwner);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\addwiz.c ===
/*-------------------------------------------------------------------
| addwiz.c - Add Device Wizard.
11-24-98 - zero out psh struct to ensure deterministic propsheet behavior. kpb
|--------------------------------------------------------------------*/
#include "precomp.h"

// testing!!!
#define ROCKETMODEM_PCI4_SUPPORT 1

static void set_field(HWND hDlg, WORD id);
static void get_field(HWND hDlg, WORD id);
//static int PaintIcon(HWND hWnd);

#ifdef NT50
// nt50 build does not link with this, so I made my own
#define strupr(s) my_strupr(s)
#endif
static void my_strupr(char *str);

static int FillDevicePropSheets(PROPSHEETPAGE *psp, LPARAM our_params);
static int InvalidMacAddress = 1;

#ifdef S_RK
  #define NUM_DEVPROP_SHEETS 7
  const LPSTR idWizIntro    = MAKEINTRESOURCE(IDD_ADD_WIZ_INTRO);
  const LPSTR idWizBus      = MAKEINTRESOURCE(IDD_ADD_WIZ_BUSTYPE);
  const LPSTR idWizModel    = MAKEINTRESOURCE(IDD_ADD_WIZ_BOARD);
  const LPSTR idWizNumPorts = MAKEINTRESOURCE(IDD_ADD_WIZ_NUMPORTS);
  const LPSTR idWizIoBase   = MAKEINTRESOURCE(IDD_ADD_WIZ_BASEIO);
  const LPSTR idWizCountry  = MAKEINTRESOURCE(IDD_ADD_WIZ_COUNTRY);
  const LPSTR idWizDone     = MAKEINTRESOURCE(IDD_ADD_WIZ_DONE);
#else
  #define NUM_DEVPROP_SHEETS 7
  const LPSTR idWizIntro    = MAKEINTRESOURCE(IDD_ADD_WIZ_INTRO);
  const LPSTR idWizDevice   = MAKEINTRESOURCE(IDD_ADD_WIZ_DEVICE);
  const LPSTR idWizNumPorts = MAKEINTRESOURCE(IDD_ADD_WIZ_NUMPORTS);
  const LPSTR idWizMac      = MAKEINTRESOURCE(IDD_ADD_WIZ_MAC);
  const LPSTR idWizCountry  = MAKEINTRESOURCE(IDD_ADD_WIZ_COUNTRY);
  const LPSTR idWizBackup   = MAKEINTRESOURCE(IDD_ADD_WIZ_BACKUP);
  const LPSTR idWizDone     = MAKEINTRESOURCE(IDD_ADD_WIZ_DONE);
#endif

  BOOL WINAPI WizIntroPropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);
  BOOL WINAPI WizBusPropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);
  BOOL WINAPI WizModelPropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);
  BOOL WINAPI WizNumPortsPropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);
  BOOL WINAPI WizIoBasePropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);
  BOOL WINAPI WizCountryPropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);
  BOOL WINAPI WizDonePropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);

  // vs specific prototypes:
  BOOL WINAPI WizDevicePropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);
  BOOL WINAPI WizNumPortsPropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);
  BOOL WINAPI WizMacPropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);
  BOOL WINAPI WizBackupPropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);

/*------------------------------------------------------------------------
| FillDevicePropSheets - Setup pages for driver level property sheets.
|------------------------------------------------------------------------*/
static int FillDevicePropSheets(PROPSHEETPAGE *psp, LPARAM our_params)
{
  INT pi;
  static TCHAR title[20];

  load_str( glob_hinst, TITLESTR, title, CharSizeOf(title) );
  memset(psp, 0, sizeof(*psp) * NUM_DEVPROP_SHEETS);

  pi = 0;

  // Intro wizard page
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = idWizIntro;
  psp[pi].pfnDlgProc = WizIntroPropSheet;
  psp[pi].pszTitle = title;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;

#ifdef S_RK
  // BusType wizard page
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = idWizBus;
  psp[pi].pfnDlgProc = WizBusPropSheet;
  psp[pi].pszTitle = title;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;
#endif

#ifdef S_RK
  // RocketPort/RocketModem Model wizard page
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = idWizModel;
  psp[pi].pfnDlgProc = WizModelPropSheet;
  psp[pi].pszTitle = title;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;
#else
  // VS1000/VS2000/RocketPort Serial Hub wizard page
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = idWizDevice;
  psp[pi].pfnDlgProc = WizDevicePropSheet;
  psp[pi].pszTitle = title;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;
#endif

  // NumPorts wizard page
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = idWizNumPorts;
  psp[pi].pfnDlgProc = WizNumPortsPropSheet;
  psp[pi].pszTitle = title;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;

#ifdef S_RK
  // BaseIoAddress wizard page
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = idWizIoBase;
  psp[pi].pfnDlgProc = WizIoBasePropSheet;
  psp[pi].pszTitle = title;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;
#endif
  // RowCountryCode wizard page
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = idWizCountry;
  psp[pi].pfnDlgProc = WizCountryPropSheet;
  psp[pi].pszTitle = title;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;

#ifdef S_VS
  // MacAddress wizard page
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = idWizMac;
  psp[pi].pfnDlgProc = WizMacPropSheet;
  psp[pi].pszTitle = title;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;
#endif

#ifdef S_VS
  // BackupServer wizard page
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = idWizBackup;
  psp[pi].pfnDlgProc = WizBackupPropSheet;
  psp[pi].pszTitle = title;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;
#endif

  // Done wizard page
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = idWizDone;
  psp[pi].pfnDlgProc = WizDonePropSheet;
  psp[pi].pszTitle = title;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;

  return 0;
}

/*------------------------------------------------------------------------
| DoAddWizPropPages - Main driver level property sheet for NT4.0
|------------------------------------------------------------------------*/
int DoAddWizPropPages(HWND hwndOwner)
{
  PROPSHEETPAGE psp[NUM_DEVPROP_SHEETS];
  PROPSHEETHEADER psh;
  OUR_INFO *our_params;
  INT stat;
  AddWiz_Config *aw_info;
#ifdef S_RK
  INT i, j;
  static WORD preferred_addresses[] = {0x180, 0x100, 0x140, 0x1c0,
                                       0x200, 0x240, 0x280, 0x2c0,
                                       0x300, 0x340, 0x380, 0x3c0, 0};
#endif

  our_params = glob_info;  // temporary kludge, unless we don't need re-entrantancy

  // init our add_wiz struct
  aw_info = glob_add_wiz;
  memset(aw_info, 0, sizeof(*aw_info));

  // set some defaults
  aw_info->CountryIdx = 0;
#ifdef S_RK
  aw_info->NumPorts = 8;
  strcpy(aw_info->BoardType, szRocketPort);
  aw_info->IoAddress = 0;   // next we'll try to pick a logical default address
  for (i = 0; (preferred_addresses[i] != 0) && (aw_info->IoAddress == 0); i++)
  {
    aw_info->IoAddress = preferred_addresses[i];    // our assumption
    for (j = 0; (j < glob_info->device_selected) && (aw_info->IoAddress != 0); j++)
    {
      if (wi->dev[j].IoAddress == preferred_addresses[i])
        // not available, so undo this default
        aw_info->IoAddress = 0;
    }
  }
#else
  aw_info->NumPorts = 16;
  strcpy(aw_info->BoardType, szSerialHub);    // first in list
  memset(aw_info->MacAddr, 0, sizeof(aw_info->MacAddr));
  aw_info->BackupServer = 0;
  aw_info->BackupTimer = 2;
#endif

  //Fill out the PROPSHEETPAGE data structure for the Client Area Shape
  //sheet
  FillDevicePropSheets(&psp[0], (LPARAM)our_params);

  //Fill out the PROPSHEETHEADER
  memset(&psh, 0, sizeof(PROPSHEETHEADER));  // add fix 11-24-98
  psh.dwSize = sizeof(PROPSHEETHEADER);
  psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;
  psh.hwndParent = hwndOwner;
  psh.hInstance = glob_hinst;
  psh.pszIcon = "";
  psh.pszCaption = (LPSTR)"Add Device Wizard";
  psh.nPages = NUM_DEVPROP_SHEETS;
  psh.ppsp = (LPCPROPSHEETPAGE) &psp;

  //And finally display the dialog with the property sheets.

  stat = PropertySheet(&psh);

  if (aw_info->finished)
    return 0;  // ok
  else
    return 1;  // canceled out
}

/*----------------------------------------------------------
 WizIntroPropSheet -
|-------------------------------------------------------------*/
BOOL WINAPI WizIntroPropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);

    return TRUE;  // No need for us to set the focus.

    case WM_PAINT:
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_HELP :
          our_help(&wi->ip, IDD_ADD_WIZ_INTRO);
        break;

        case PSN_SETACTIVE:
          PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
        break;

        case PSN_WIZNEXT:
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

        default :
        return FALSE;
      }

    default :
    return FALSE;
  }
}

#ifdef S_RK
/*----------------------------------------------------------
 WizBusPropSheet -
|-------------------------------------------------------------*/
BOOL WINAPI WizBusPropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);

    return TRUE;  // No need for us to set the focus.

    case WM_PAINT:
#if 0
      PaintIcon(hDlg);
#endif
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_HELP :
          our_help(&wi->ip, IDD_ADD_WIZ_BUSTYPE);
        break;

        case PSN_SETACTIVE:
          set_field(hDlg, IDC_WIZ_ISA);
          set_field(hDlg, IDC_WIZ_PCI);

          PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
        break;

        case PSN_WIZNEXT:
          get_field(hDlg, IDC_WIZ_ISA);
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

        default :
        return FALSE;
      }

    default :
    return FALSE;
  }
}
#endif

#ifdef S_RK
/*----------------------------------------------------------
 WizModelPropSheet -
|-------------------------------------------------------------*/
BOOL WINAPI WizModelPropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
 
    return TRUE;  // No need for us to set the focus.

    case WM_PAINT:
#if 0
      PaintIcon(hDlg);
#endif
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_SETACTIVE:
          set_field(hDlg, IDC_WIZ_CBOX_BOARD);
          PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
        break;

        case PSN_HELP :
          our_help(&wi->ip, IDD_ADD_WIZ_BOARD);
        break;

        case PSN_WIZNEXT:
          get_field(hDlg, IDC_WIZ_CBOX_BOARD);
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

        default :
        return FALSE;
      }

    default :
    return FALSE;
  }
}
#endif

#ifdef S_VS
/*----------------------------------------------------------
 WizDevicePropSheet -
|-------------------------------------------------------------*/
BOOL WINAPI WizDevicePropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
 
    return TRUE;  // No need for us to set the focus.

    case WM_PAINT:
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_SETACTIVE:
          set_field(hDlg, IDC_WIZ_CBOX_DEVICE);
          PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
        break;

        case PSN_HELP :
          our_help(&wi->ip, IDD_ADD_WIZ_DEVICE);
        break;

        case PSN_WIZNEXT:
          get_field(hDlg, IDC_WIZ_CBOX_DEVICE);
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

        default :
        return FALSE;
      }

    default :
    return FALSE;
  }
}
#endif

/*----------------------------------------------------------
 WizNumPortsPropSheet -
|-------------------------------------------------------------*/
BOOL WINAPI WizNumPortsPropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  AddWiz_Config *aw;
  aw = glob_add_wiz;

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
 
    return TRUE;  // No need for us to set the focus.

    case WM_PAINT:
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_SETACTIVE:
          set_field(hDlg, IDC_WIZ_CBOX_NUMPORTS);
          PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
        break;

        case PSN_HELP :
          our_help(&wi->ip, IDD_ADD_WIZ_NUMPORTS);
        break;

        case PSN_WIZNEXT:
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          get_field(hDlg, IDC_WIZ_CBOX_NUMPORTS);

#ifdef S_RK
          if (!aw->IsIsa) {
            // PCI
            if (!aw->IsModemDev) {
              // not a RocketModem, so we're done
              PropSheet_SetCurSelByID(((NMHDR *)lParam)->hwndFrom, idWizDone);
              // tell sheet not to handle advance -- we overrode it
              SetWindowLong(hDlg, DWL_MSGRESULT, -1);
            }
            else
            {
              // new PCI RocketModem, so prompt for country
              PropSheet_SetCurSelByID(((NMHDR *)lParam)->hwndFrom, idWizCountry);
              // tell sheet not to handle advance -- we overrode it
              SetWindowLong(hDlg, DWL_MSGRESULT, -1);
            }
          }
#else
  #ifdef VS2000_ROW_SUPPORT
          if (!aw->IsModemDev)
          {
  #endif
            // not a VS2000 - and/or - no ROW support; skip over Country page
            PropSheet_SetCurSelByID(((NMHDR *)lParam)->hwndFrom, idWizMac);
            // tell sheet not to handle advance -- we overrode it
            SetWindowLong(hDlg, DWL_MSGRESULT, -1);
  #ifdef VS2000_ROW_SUPPORT
          }
  #endif
#endif
        return TRUE;

        default :
        return FALSE;
      }

    default :
    return FALSE;
  }
}

#ifdef S_RK
/*----------------------------------------------------------
 WizIoBasePropSheet -
|-------------------------------------------------------------*/
BOOL WINAPI WizIoBasePropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  AddWiz_Config *aw;
  aw = glob_add_wiz;

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
 
    return TRUE;  // No need for us to set the focus.

    case WM_PAINT:
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_SETACTIVE:
          set_field(hDlg, IDC_WIZ_CBOX_IOADDR);
          PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
        break;

        case PSN_HELP :
          our_help(&wi->ip, IDD_ADD_WIZ_BASEIO);
        break;

        case PSN_WIZNEXT:
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          get_field(hDlg, IDC_WIZ_CBOX_IOADDR);

          if (!aw->IsModemDev) {
            PropSheet_SetCurSelByID(((NMHDR *)lParam)->hwndFrom, idWizDone);
            // tell sheet not to handle advance -- we overrode it
            SetWindowLong(hDlg, DWL_MSGRESULT, -1);
          }
        return TRUE;

        default :
        return FALSE;
      }

    default :
    return FALSE;
  }
}
#endif

/*----------------------------------------------------------
 WizCountryPropSheet -
|-------------------------------------------------------------*/
BOOL WINAPI WizCountryPropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  AddWiz_Config *aw;
  aw = glob_add_wiz;

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
 
    return TRUE;  // No need for us to set the focus.

    case WM_PAINT:
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_SETACTIVE:
          set_field(hDlg, IDC_WIZ_CBOX_COUNTRY);
          PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
        break;

        case PSN_HELP :
          our_help(&wi->ip, IDD_ADD_WIZ_COUNTRY);
        break;

        case PSN_WIZBACK:
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);

          if (aw->IsIsa == 0)
          {
            // PCI RocketModem: back up to numports dialog instead of ioaddr
            PropSheet_SetCurSelByID(((NMHDR *)lParam)->hwndFrom, idWizNumPorts);
            // tell sheet not to handle advance -- we overrode it
            SetWindowLong(hDlg, DWL_MSGRESULT, -1);
          }
        return TRUE;

        case PSN_WIZNEXT:
          get_field(hDlg, IDC_WIZ_CBOX_COUNTRY);
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

        default :
        return FALSE;
      }

    default :
    return FALSE;
  }
}

#ifdef S_VS
/*----------------------------------------------------------
 WizMacPropSheet -
|-------------------------------------------------------------*/
BOOL WINAPI WizMacPropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  AddWiz_Config *aw;
  aw = glob_add_wiz;

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
 
    return TRUE;  // No need for us to set the focus.

    case WM_PAINT:
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_SETACTIVE:
          set_field(hDlg, IDC_WIZ_CBOX_MAC);
          PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
        break;

        case PSN_HELP :
          our_help(&wi->ip, IDD_ADD_WIZ_MAC);
        break;

        case PSN_WIZBACK:
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);

#ifdef VS2000_ROW_SUPPORT
          if (!aw->IsModemDev)
          {
#endif
            // not a VS2000 - and/or - no ROW support; skip over Country page
            PropSheet_SetCurSelByID(((NMHDR *)lParam)->hwndFrom, idWizNumPorts);
            // tell sheet not to handle advance -- we overrode it
            SetWindowLong(hDlg, DWL_MSGRESULT, -1);
#ifdef VS2000_ROW_SUPPORT
          }
#endif
        break;

        case PSN_WIZNEXT:
          get_field(hDlg, IDC_WIZ_CBOX_MAC);
          if (InvalidMacAddress == 1)
            // don't allow advance to next field
            SetWindowLong(hDlg, DWL_MSGRESULT, -1);
          else
            SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

        default :
        return FALSE;
      }

    default :
    return FALSE;
  }
}
#endif

#ifdef S_VS
/*----------------------------------------------------------
 WizBackupPropSheet -
|-------------------------------------------------------------*/
BOOL WINAPI WizBackupPropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  char tmpstr[60];
  WORD uCmd;
  HWND hwnd;
  AddWiz_Config *aw;
  aw = glob_add_wiz;

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
 
    return TRUE;  // No need for us to set the focus.

    case WM_PAINT:
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_COMMAND:
      uCmd = HIWORD(wParam);

      switch (LOWORD(wParam))
      {
        case IDC_WIZ_BACKUP_YES:
        case IDC_WIZ_BACKUP_NO:
          //--- enable or disable backup-timer field depending on backup server[]
          hwnd = GetDlgItem(hDlg, IDC_WIZ_CBOX_BACKUPTIME);
          if (IsDlgButtonChecked(hDlg, IDC_WIZ_BACKUP_YES))
            EnableWindow(hwnd,1);
          else EnableWindow(hwnd,0);
        break;
      }
    break;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_SETACTIVE:
          set_field(hDlg, IDC_WIZ_BACKUP_YES);
          set_field(hDlg, IDC_WIZ_CBOX_BACKUPTIME);
          //--- enable or disable backup-timer field depending on backup server[]
          hwnd = GetDlgItem(hDlg, IDC_WIZ_CBOX_BACKUPTIME);
          if (IsDlgButtonChecked(hDlg, IDC_WIZ_BACKUP_YES))
            EnableWindow(hwnd,1);
          else EnableWindow(hwnd,0);
          PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
        break;

        case PSN_HELP :
          our_help(&wi->ip, IDD_ADD_WIZ_BACKUP);
        break;

        case PSN_WIZNEXT:
          get_field(hDlg, IDC_WIZ_BACKUP_YES);
          get_field(hDlg, IDC_WIZ_CBOX_BACKUPTIME);
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

        default :
        return FALSE;
      }

    default :
    return FALSE;
  }
}
#endif

/*----------------------------------------------------------
 WizDonePropSheet -
|-------------------------------------------------------------*/
BOOL WINAPI WizDonePropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  AddWiz_Config *aw;
  aw = glob_add_wiz;

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
 
    return TRUE;  // No need for us to set the focus.

    case WM_PAINT:
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_SETACTIVE:
          PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
        break;

        case PSN_HELP :
          our_help(&wi->ip, IDD_ADD_WIZ_DONE);
        break;

#ifdef S_RK
        case PSN_WIZBACK:
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          if (!aw->IsModemDev)
          {
            if (!aw->IsIsa)
            {
              // back up to the numports dialog
              PropSheet_SetCurSelByID(((NMHDR *)lParam)->hwndFrom, idWizNumPorts);
              // tell sheet not to handle advance -- we overrode it
              SetWindowLong(hDlg, DWL_MSGRESULT, -1);
            }
            else
            {
              // back up to the base io dialog
              PropSheet_SetCurSelByID(((NMHDR *)lParam)->hwndFrom, idWizIoBase);
              // tell sheet not to handle advance -- we overrode it
              SetWindowLong(hDlg, DWL_MSGRESULT, -1);
            }
          }
        return TRUE;
#endif

        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
          aw->finished = 1;

          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

        default :
        return FALSE;
      }

    default :
    return FALSE;
  }
}

#ifdef S_VS
/*----------------------------------------------------------
 set_mac_field -
|------------------------------------------------------------*/
static int set_mac_field(HWND hDlg, WORD id)
{
  HWND hwnd;
  char tmpstr[60];
  int stat;
  int i;
  int addr_used, nbytes, found;
  BYTE *macbuf;
  BYTE *mac;

  AddWiz_Config *aw;
  aw = glob_add_wiz;

  //------------------ fill in mac addr selection
  hwnd = GetDlgItem(hDlg, id);
  SendMessage(hwnd, CB_RESETCONTENT, 0, 0);

  // alloc 8byte mac-address fields(2 times as many as could be configured)
  found = 0;
  nbytes = 0;
  macbuf = our_get_ping_list(&stat, &nbytes);

  if (stat == 0)
  {
    for (i=0; i<nbytes/8; i++)
    {
      mac = &macbuf[i*8];
      //if (mac_match(mac, aw->MacAddr))
      //  found = 1;
      //mess("macgot:%s",macbuf);

      format_mac_addr(tmpstr, mac);

      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) tmpstr);
    }
  }
  
  addr_used = 1;
  
  if ( (mac_match(aw->MacAddr, broadcast_addr)) ||
       (mac_match(aw->MacAddr, mac_zero_addr)) )
    addr_used = 0;
  
  if (addr_used)
  {
    mac = &aw->MacAddr[0];
    format_mac_addr(tmpstr, mac);
  
    if (!found)  // configured mac-addr not in list yet
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) tmpstr);
  }
  else
  {
    memset(aw->MacAddr, 0, 6);
    strcpy(tmpstr, "00 C0 4E # # #");
  }
  // set the text in the window
  SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "00 C0 4E # # #");
  SendMessage(hwnd, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)(char far *) tmpstr);

  return 0;
}
#endif

/*-------------------------------------------------------------------
| get_field - Run when a selection is changed.
|--------------------------------------------------------------------*/
static void get_field(HWND hDlg, WORD id)
{
  char tmpstr[60];
  int i;

  AddWiz_Config *aw;
  aw = glob_add_wiz;

  switch (id)
  {
#ifdef S_RK
    case IDC_WIZ_ISA:
    case IDC_WIZ_PCI:
      if (IsDlgButtonChecked(hDlg, IDC_WIZ_ISA))
        aw->IsIsa = 1;
      else aw->IsIsa = 0;
    break;
#endif

#ifdef S_RK
    case IDC_WIZ_CBOX_BOARD:
      GetDlgItemText(hDlg, id, aw->BoardType, sizeof(aw->BoardType));

      aw->IsModemDev = 0;

      if (!strcmp(aw->BoardType, szRocketModem))
        aw->IsModemDev = TYPE_RM_VS2000;
      else if (!strcmp(aw->BoardType, szRocketModemII))
        aw->IsModemDev = TYPE_RMII;
      else if (!strcmp(aw->BoardType, szRocketModem_i))
        aw->IsModemDev = TYPE_RM_i;

    break;
#endif

#ifdef S_VS
    case IDC_WIZ_CBOX_DEVICE:
      GetDlgItemText(hDlg, id, aw->BoardType, sizeof(aw->BoardType));
      if (!strcmp(aw->BoardType, szSerialHub))
      {
        aw->IsHub = 1;
        aw->IsModemDev = 0;
      }
      else
      {
        aw->IsHub = 0;
        if (!strcmp(aw->BoardType, szVS2000))
          aw->IsModemDev = TYPE_RM_VS2000;
        else
          aw->IsModemDev = 0;
      }
    break;
#endif

#ifdef S_RK
    case IDC_WIZ_CBOX_IOADDR:
      GetDlgItemText(hDlg, id, tmpstr, 58);
      aw->IoAddress = gethint(tmpstr, &i);
    break;
#endif

    case IDC_WIZ_CBOX_NUMPORTS:
      GetDlgItemText(hDlg, id, tmpstr, 58);
      aw->NumPorts = getint(tmpstr, &i);
    break;

    case IDC_WIZ_CBOX_COUNTRY:
      GetDlgItemText(hDlg, id, tmpstr, 58);
      aw->CountryIdx = 0;

      if (aw->IsModemDev == TYPE_RM_VS2000) {

        for (
        i = 0; 
        i < NUM_ROW_COUNTRIES; 
        i++
        ) {

          if (!strcmp(tmpstr, RowInfo[i].RowCountryName)) {
            aw->CountryIdx = i;
            aw->CountryCode = RowInfo[i].RowCountryCode;
            break;
          }
        }
      }
      else if (aw->IsModemDev == TYPE_RM_i) {

        for (
        i = 0; 
        i < NUM_CTR_ROW_COUNTRIES; 
        i++
        ) {

          if (!strcmp(tmpstr, CTRRowInfo[i].RowCountryName)) {
            aw->CountryIdx = i;
            aw->CountryCode = CTRRowInfo[i].RowCountryCode;
            break;
          }
        }
      }
      else if (aw->IsModemDev) {
        aw->CountryIdx = 0;
        aw->CountryCode = RowInfo[0].RowCountryCode;
      }
    break;

#ifdef S_VS
    case IDC_WIZ_CBOX_MAC:
          // get_mac_field() is shared and is in devprop.c
      InvalidMacAddress = get_mac_field(hDlg, id, aw->MacAddr);
    break;

    case IDC_WIZ_BACKUP_NO:
    case IDC_WIZ_BACKUP_YES:
      if (IsDlgButtonChecked(hDlg, IDC_WIZ_BACKUP_YES))
        aw->BackupServer = 1;
      else aw->BackupServer = 0;
    break;

    case IDC_WIZ_CBOX_BACKUPTIME:
      //------------------ get the backup timer value
      GetDlgItemText(hDlg, id, tmpstr, 19);
      if (sscanf(tmpstr, "%ld", &i) == 1)
        aw->BackupTimer = i;

      if (aw->BackupTimer < 2)
        aw->BackupTimer = 2;
    break;
#endif

  }
}

/*----------------------------------------------------------
 set_field -
|------------------------------------------------------------*/
static void set_field(HWND hDlg, WORD id)
{
  HWND hwnd;
  char tmpstr[60];
  int i;
#ifdef S_RK
  int j;
  BOOL is_avail;
  WORD baseaddr;
  static WORD hex_addresses[] = {0x100, 0x140, 0x180, 0x1c0,
                                 0x200, 0x240, 0x280, 0x2c0,
                                 0x300, 0x340, 0x380, 0x3c0, 0};
#endif

  AddWiz_Config *aw;
  aw = glob_add_wiz;

  switch(id)
  {
#ifdef S_RK
    case IDC_WIZ_ISA:
      SendDlgItemMessage(hDlg, IDC_WIZ_ISA, BM_SETCHECK, aw->IsIsa, 0);
      SendDlgItemMessage(hDlg, IDC_WIZ_PCI, BM_SETCHECK, 1 - aw->IsIsa, 0);
    break;
#endif

#ifdef S_RK
    case IDC_WIZ_CBOX_BOARD:
      //------------------ fill in board type (model) selection
      hwnd = GetDlgItem(hDlg, id);
      SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
      if (aw->IsIsa) {
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szRocketPort);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szRocketPort485);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szRocketModem);
      }
      else
      {
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szRocketPort);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szRocketPortPlus);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szRocketModemII);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szRocketModem_i);
      }
      // make sure there's a default
      SendMessage(hwnd, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)(char far *) "R");
      // now try to select the last device chosen by user.  it may not be valid
      // if the user switched from ISA to PCI (for example) and the choice
      // isn't available on the new bus.
      SendMessage(hwnd, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)(char far *) aw->BoardType);
    break;
#endif

#ifdef S_VS
    case IDC_WIZ_CBOX_DEVICE:
      //------------------ fill in board type (model) selection
      hwnd = GetDlgItem(hDlg, id);
      SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szVS1000);
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szVS2000);
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szSerialHub);
      // make sure there's a default
      SendMessage(hwnd, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)(char far *) aw->BoardType);
    break;
#endif

#ifdef S_RK
    case IDC_WIZ_CBOX_IOADDR:
      //------------------ fill in io base address selection
      hwnd = GetDlgItem(hDlg, id);
      SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
      for (i = 0; hex_addresses[i] != 0; i++)
      {
        baseaddr = hex_addresses[i];
        // see if this base address already chosen by another card
        is_avail = TRUE;  // our assumption
        for (j = 0; (j < glob_info->device_selected) && (is_avail); j++)
        {
          if (wi->dev[j].IoAddress == baseaddr)
            is_avail = FALSE;
        }
        if (is_avail)
        {
          wsprintf(tmpstr, "%x Hex", baseaddr);
          if (baseaddr == 0x180)
            strcat(tmpstr, " (default)");
          SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)tmpstr);
        }
      }
      // now make the previous choice the default choice
      if (aw->IoAddress == 0x180)
        wsprintf(tmpstr, "%x hex (default)", aw->IoAddress);
      else
        wsprintf(tmpstr, "%x hex", aw->IoAddress);
      SendMessage(hwnd, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)(char far *) tmpstr);
    break;
#endif

    case IDC_WIZ_CBOX_NUMPORTS:
      //------------------ fill in numports selection
      hwnd = GetDlgItem(hDlg, id);
      SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
#ifdef S_RK
      if ((aw->IsModemDev) && (aw->IsIsa == 0))
      {
        // PCI RocketModem can be 4 or 6 ports
# ifdef ROCKETMODEM_PCI4_SUPPORT
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP4);
# endif
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP6);
        // default the number of ports for the pci rocketmodem to 6
        aw->NumPorts = 6;
      }
      else
      {
        // all other boards follow this logic:
        if (strstr(aw->BoardType, szRocketPortPlus))
        {
          // Rocketport Plus available in a 2-port version
          SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP2);
        }
        if (!strstr(aw->BoardType, szRocketPort485))
        {
          // all except Rocketport 485 available in a 4-port version
          SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP4);
        }
        // all RocketPort variations available in an 8-port version
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP8);
        if (strlen(aw->BoardType) == strlen(szRocketPort))
        {
          // only standard boards available in 16 & 32 port versions
          SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP16);
          SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP32);
        }
      }
      wsprintf(tmpstr, "%d", aw->NumPorts);
      SendMessage(hwnd, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)(char far *) tmpstr);
#else  // S_VS
      if (aw->IsModemDev)
      {
        // VS2000 only available in 8 port configuration
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP8);
        // default the number of ports for the VS2000 to 8
        aw->NumPorts = 8;
      }
      else if (aw->IsHub)
      {
        // SerialHub available in 4 (not yet) and 8 port configuration
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP4);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP8);
        // default the number of ports for the Serial Hub to 8
        aw->NumPorts = 8;
      }
      else
      {
        // we must have a VS1000 or VS1000/VS1100 combo
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP16);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP32);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP48);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP64);
        // default the number of ports for the VS1000 to 16
        aw->NumPorts = 16;
      }
      wsprintf(tmpstr, "%d", aw->NumPorts);
      SendMessage(hwnd, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)(char far *) tmpstr);
#endif  // S_VS
    break;

    case IDC_WIZ_CBOX_COUNTRY:
      //------------------ fill in country selection
      hwnd = GetDlgItem(hDlg, id);
      SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
      if (aw->IsModemDev == TYPE_RM_VS2000) {

        for (
        i = 0; 
        i < NUM_ROW_COUNTRIES; 
        ++i
        ) {
          SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(RowInfo[i].RowCountryName));
        }

        SendMessage(
          hwnd, 
          CB_SELECTSTRING, 
          (WPARAM)-1,
          (LPARAM)(RowInfo[aw->CountryIdx].RowCountryName));
      }
      else if (aw->IsModemDev == TYPE_RM_i) {
      
        for (
        i = 0; 
        i < NUM_CTR_ROW_COUNTRIES; 
        ++i
        ) {
          SendMessage(
            hwnd, 
            CB_ADDSTRING, 
            0, 
            (LPARAM)(CTRRowInfo[i].RowCountryName));
        }

        SendMessage(
          hwnd, 
          CB_SELECTSTRING, 
          (WPARAM)-1,
          (LPARAM)(CTRRowInfo[aw->CountryIdx].RowCountryName));
      } 
      else if (aw->IsModemDev) {

        SendMessage(
          hwnd, 
          CB_ADDSTRING, 
          0, 
          (LPARAM)(RowInfo[0].RowCountryName));

        SendMessage(
          hwnd, 
          CB_SELECTSTRING, 
          (WPARAM)-1,
          (LPARAM)(RowInfo[0].RowCountryName));
      }
    break;

#ifdef S_VS
    case IDC_WIZ_CBOX_MAC:
      set_mac_field(hDlg, id);
    break;

    case IDC_WIZ_BACKUP_YES:
    case IDC_WIZ_BACKUP_NO:
      SendDlgItemMessage(hDlg, IDC_WIZ_BACKUP_YES, BM_SETCHECK,
                         aw->BackupServer, 0);
      SendDlgItemMessage(hDlg, IDC_WIZ_BACKUP_NO,  BM_SETCHECK,
                         1 - aw->BackupServer, 0);
    break;

    case IDC_WIZ_CBOX_BACKUPTIME:
      //------------------ fill in backup timer selection
      hwnd = GetDlgItem(hDlg, IDC_WIZ_CBOX_BACKUPTIME);
      SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "2 min");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "5 min");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "10 min");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "30 min");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "60 min");

      if (aw->BackupTimer < 2)
        aw->BackupTimer = 2; // 2 minutes, no less

      wsprintf(tmpstr, "%d min", aw->BackupTimer);
      SetDlgItemText(hDlg, IDC_WIZ_CBOX_BACKUPTIME, tmpstr);
    break;
#endif
  }
}
#if 0
/*---------------------------------------------------------------------------
  PaintIcon - Paints the Icon in the property sheet.
|---------------------------------------------------------------------------*/
static int PaintIcon(HWND hWnd)
{
//   int status;
   HBITMAP      hBitMap;
   HGDIOBJ      hGdiObj;
   HDC          hDC, hMemDC ;
   PAINTSTRUCT  ps ;
   RECT spot, main;  // left, top, right, bottom
   static int cnt = 0;

  GetWindowRect(GetDlgItem(hWnd, IDB_HELP), &spot);
  GetWindowRect(hWnd, &main);
#ifdef COMMENT_OUT
  rect = &right;
  mess("hlp r:%d l:%d b:%d t:%d",
       rect->right, rect->left, rect->bottom, rect->top);
#endif
  spot.left -= main.left;
  spot.top -= main.top;

  spot.left += 5;
  spot.top  += 20; // spacing

   // load bitmap and display it

   hDC = BeginPaint( hWnd, &ps ) ;
   if (NULL != (hMemDC = CreateCompatibleDC( hDC )))
   {
      hBitMap = LoadBitmap(glob_hinst,
                           MAKEINTRESOURCE(BMP_SMALL_LOGO));

      hGdiObj = SelectObject(hMemDC, hBitMap);

      BitBlt( hDC, spot.left, spot.top, 100, 100, hMemDC, 0, 0, SRCCOPY ) ;
      //StretchBlt( hDC, 5, 5, 600,100, hMemDC, 0, 0, 446, 85, SRCCOPY ) ;
      DeleteObject( SelectObject( hMemDC, hGdiObj ) ) ;
      DeleteDC( hMemDC ) ;
   }
   EndPaint( hWnd, &ps ) ;
 return 0;
}
#endif

/*-------------------------------------------------------------------
| my_strupr -
|--------------------------------------------------------------------*/
static void my_strupr(char *str)
{
  while (*str != 0)
  {
    *str = (char) toupper(*str);
    ++str;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\commrkt.h ===
/*-----------------------------------------------------------------------------
 COMMRKT.H - Windows 3.1 COMM.DRV driver for RocketPort
             Prototypes for exported functions

This include file is only needed if you are running the RocketPort
Windows 3.1 driver(commrkt.drv, vcdrkt.vxd) and need to access ports above
COM9.  The driver contains additional functions(see below) which allow
you to open com-ports greater than COM9.

If you want the macros below to translate all standard Windows calls to
rocket calls(functions prefixed with a "rkt"), then define the following:
#define NEED_OVER_COM9
This will cause the macros defined below to take effect which will replace
the standard Windows comm-port function calls with the "rkt" function calls.

The rocket library commands will only work with the RocketPort ports,
the OpenComm() call will fail for the standard com ports(COM1,2).

The supplied commdrv.lib import library must then be linked in.
the actual functions are contained in the driver file called commrkt.drv
which is actually the Dynamic Link Library with these functions.

This solution is only available with the Windows 3.1 driver, and will not
work with any of our other Windows drivers.  If you move to Win95 or NT
environment we would suggest that you use the 32-bit programming model
to overcome the COM9 limitation associated with the 16-bit Windows API.
For Windows95 an alternative is to install the Windows 3.1 driver,
which will work in a compatibility mode for 16-bit applications.

Company: Comtrol Corporation
-----------------------------------------------------------------------------*/
#ifdef __cplusplus
extern "C" {
#endif 

/* Controller initialization error codes.  OpenComm() and rktOpenComm()
   can both return these if the controller initialization fails on the
   first open the system attempts. */
#define IER_INIFILE   -20   /* Driver problem reading ROCKETPT.INI file */
#define IER_CTLINIT   -21   /* Controller hardware initialization error */
#define IER_CHANINIT  -22   /* Channel hardware initialization error */
#define IER_DEVSIZE   -23   /* Invalid number of devices found */
#define IER_CTLSIZE   -24   /* Invalid number of controllers found */
#define IER_NOINTHND  -25   /* Could not install interrupt handler */
#define IER_NOINT     -26   /* Interrupts are not occuring */

// the following may be switched on to access over COM9 limitation
// in 16-bit Windows, when used with the RocketPort Windows 3.1
// driver.  These are not available in the W95/WFW311/NT Comtrol
// Drivers.  The actual library functions exist in the "commrkt.drv"
// file(part of our driver.)  This is really just a dynamic link library,
// and the "commrkt.lib" is just an import library which tells the linker
// & compiler where to find these calls at runtime.
// These macros change every standard Windows Comm-API call in our program
// to the rkt##### special library call.

#ifdef NEED_OVER_COM9
#define BuildCommDCB     rktBuildCommDCB
#define ClearCommBreak   rktClearCommBreak
#define CloseComm        rktCloseComm
#define EnableCommNotification rktEnableCommNotification
#define EscapeCommFunction rktEscapeCommFunction
#define FlushComm        rktFlushComm
#define GetCommError     rktGetCommError
#define GetCommState     rktGetCommState
#define GetCommEventMask rktGetCommEventMask
#define OpenComm         rktOpenComm
#define ReadComm         rktReadComm
#define SetCommBreak     rktSetCommBreak
#define SetCommEventMask rktSetCommEventMask
#define SetCommState     rktSetCommState
#define TransmitCommChar rktTransmitCommChar
#define WriteComm        rktWriteComm
#endif

#ifndef _CDECL
#define _CDECL FAR PASCAL
#endif

int _CDECL rktBuildCommDCB(LPCSTR,DCB far *);
int _CDECL rktClearCommBreak(int);
int _CDECL rktCloseComm(int);
BOOL _CDECL rktEnableCommNotification(int,HWND,int,int);
LONG _CDECL rktEscapeCommFunction(int,int);
int _CDECL rktFlushComm(int,int);
int _CDECL rktGetCommError(int,COMSTAT far *);
int _CDECL rktGetCommState(int,DCB far *);
WORD _CDECL rktGetCommEventMask(int,int);
int _CDECL rktOpenComm(LPCSTR,UINT,UINT);
int _CDECL rktReadComm(int,void far *,int);
int _CDECL rktSetCommBreak(int);
UINT far * _CDECL rktSetCommEventMask(int,UINT);
int _CDECL rktSetCommState(DCB far *);
int _CDECL rktTransmitCommChar(int,char);
int _CDECL rktWriteComm(int,void far *,int);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\comutils.h ===
#ifdef __cplusplus
extern "C" {
#endif
// comtutil.h

// ioctl.h
// product_id codes
#define PRODUCT_UNKNOWN 0
#define NT_VS1000       1
#define NT_ROCKET       2
#define NT_RPSHSI			3

//---------------
// we setup our structure arrays with one of these things at the
// foot of the array as a standard header.  When we request data
// from the driver, this tells the driver what structure type and
// size follows.
typedef struct
{
  ULONG struct_type;
  ULONG struct_size;
  ULONG num_structs;
  ULONG var1;  // reserve
} PortMonBase;

typedef struct
{
  DWORD PlatformId;    // ioctl_open() will set this up.
  ULONG ctl_code;      // ioctl_open() will set this up.
  HANDLE hcom;         // handle to driver for ioctl calls.  ioctl_open sets up.
  TCHAR *driver_name;   // ioctl_open() will set this up.
  int product_id;  // ioctl_open() will set this up.

  PortMonBase *pm_base;  // base ptr to data buffer header
                         // application needs to set this up prior to call.

  int buf_size;   // byte size of buffer data to send/rec to/from driver
                  // application needs to set this up prior to call.

  int ret_bytes;   // number of bytes returned from call into driver.
                  // includes size of pmn header
} IoctlSetup;

//#define IOCTL_DEVSTAT     9  // device/link status(not used anymore)
#define IOCTL_PORTNAMES  10  // name array [12] bytes
#define IOCTL_PORTSTATUS 11  // port stats, array
#define IOCTL_DEBUGLOG   13  // driver debug log
#define IOCTL_OPTION     14  // option setup
#define IOCTL_MACLIST    15  // mac-scan list
#define IOCTL_NICSTAT    16  // nic status
#define IOCTL_DEVICESTAT 17  // device/link status
#define IOCTL_KICK_START 18  // get system going
#define IOCTL_PORT_RESET 19  // port reset -- mkm --

//---------------
// we get the port names from the driver once at startup.
typedef struct
{
  char  port_name[12];  // port name(0=end of port list),("."=not assigned)
} PortMonNames;

//---------------
// this is the raw data we continually get from from the driver.
typedef struct
{
  DWORD TxTotal;     // total number of sent bytes
  DWORD RxTotal;      // total number of receive bytes

  WORD TxPkts;   // number of write() packets
  WORD RxPkts;    // number of read() packets

  WORD overrun_errors; // receive over-run errors
  WORD framing_errors; // receive framing errors

  WORD  parity_errors;  // receive parity errors
  WORD status_flags;  // opened/close, flow-ctrl, out/in pin signals, etc
} PortMonStatus;


int APIENTRY ioctl_call(IoctlSetup *ioctl_setup);
int APIENTRY ioctl_open(IoctlSetup *ioctl_setup, int product_id);
#define ioctl_close(_ioctl_setup) \
  { if ((_ioctl_setup)->hcom != NULL) \
      CloseHandle((_ioctl_setup)->hcom); }

// reg.h

int APIENTRY reg_key_exists(HKEY handle, const TCHAR * keystr);
int APIENTRY reg_create_key(HKEY handle, const TCHAR * keystr);
int APIENTRY reg_set_str(HKEY handle,
                         const TCHAR * child_key,
                         const TCHAR * str_id,
                         const char *src,
                         int str_type);  // REG_SZ, REG_EXPAND_SZ
int APIENTRY reg_set_dword_del(HKEY handle,
                               const TCHAR * child_key,
                               const TCHAR * str_id,
                               DWORD new_value,
                               DWORD del_value);
int APIENTRY reg_delete_key(HKEY handle,
                            const TCHAR * child_key,
                            const TCHAR * str_id);
int APIENTRY reg_delete_value(HKEY handle,
                              const TCHAR * child_key,
                              const TCHAR * str_id);
int APIENTRY reg_set_dword(HKEY handle,
                           const TCHAR * child_key,
                           const TCHAR * str_id,
                           DWORD new_value);
int APIENTRY reg_get_str(HKEY handle,
                         const TCHAR * child_key,
                         const TCHAR * str_id,
                         char *dest,
                         int str_len);
int APIENTRY reg_get_dword(HKEY handle,
                           const TCHAR * child_key,
                           const TCHAR * str_id,
                           DWORD *dest);
int APIENTRY reg_open_key(HKEY handle,
                          HKEY *new_handle,
                          const TCHAR *keystr,
                          DWORD attribs);  // KEY_READ, KEY_ALL_ACCESS

#define reg_close_key(handle) \
  { if (handle) {RegCloseKey(handle); handle = NULL;} }
//----- setuppm.h
int APIENTRY make_progman_group(char **list,char *dest_dir);
int APIENTRY delete_progman_group(char **list, char *dest_dir);

//---- cutil.h

#define D_Error 0x00001
#define D_Warn  0x00002
#define D_Init  0x00004
#define D_Test  0x00008

#if DBG
extern int DebugLevel;
#define DbgPrintf(_Mask_,_Msg_) \
  { if (_Mask_ & DebugLevel) { OurDbgPrintf _Msg_;} }
#define DbgPrint(s) OutputDebugString(s)
#else
#define DbgPrintf(_Mask_,_Msg_)
#define DbgPrint(s)
#endif

void APIENTRY ascii_string(unsigned char *str);
void APIENTRY normalize_string(char *str);
int APIENTRY getstr(char *instr, char *outstr, int max_size);
int APIENTRY getnumbers(char *str, int *nums, int max_nums);
int APIENTRY listfind(char *str, char **list);
int APIENTRY my_lstricmp(char *str1, char *str2);
int APIENTRY my_substr_lstricmp(char far *str1, char far *str2);
int APIENTRY getint(char *textptr, int *countptr);
unsigned int APIENTRY gethint(char *bufptr, int *countptr);
int APIENTRY my_toupper(int c);
int APIENTRY my_lstrimatch(char *find_str, char *str_to_search);
void APIENTRY OurDbgPrintf(TCHAR *format, ...);

// ourfile.h

typedef struct {
  HANDLE  hfile;
  ULONG dwDesiredAccess;
  ULONG dwCreation;
  int flags; // 1h = eof, 2=error
} OUR_FILE;

void APIENTRY our_remove(TCHAR *name);
OUR_FILE * APIENTRY our_fopen(TCHAR *name, char *attr);
void APIENTRY our_fclose(OUR_FILE *fp);
int APIENTRY our_feof(OUR_FILE *fp);
int APIENTRY our_ferror(OUR_FILE *fp);
unsigned int APIENTRY our_fseek(OUR_FILE *fp, int pos, int relative);
void APIENTRY our_fputs(char *str, OUR_FILE *fp);
char * APIENTRY our_fgets(char *str, int maxlen, OUR_FILE *fp);
int APIENTRY our_fwrite(void *buffer, int size, int count, OUR_FILE *fp);
int APIENTRY our_fread(void *buffer, int size, int count, OUR_FILE *fp);


#ifdef __cplusplus
}
#endif
#ifdef __cplusplus
// ttywin.h

/* text window memory */
#define TROWS 35
#define TCOLS 86

class TTYwin {
  public:
  HWND hwnd;        // handle of our port window
  HFONT hfont;
  TCHAR text_buf[TROWS+2][TCOLS+3];
  int screen_update_flag;  // need to update the screen.
  int display_cur_row;
  int cur_row;
  int cur_col;
  int scr_size_x;
  int scr_size_y;
  int show_crlf;
  int caret_on;
  unsigned long text_color;
  HBRUSH hbrush_window;  // for painting background

  TTYwin();
  ~TTYwin();
  void TTYwin::init(HWND owner_hwnd);
  void TTYwin::set_color(int color_rgb);
  void TTYwin::set_size(int x, int y);
  void TTYwin::show_caret(int on);
  void TTYwin::mess_str(TCHAR *str, int len=0);
  void TTYwin::update_screen(int all_flag);
  void TTYwin::mess_line(TCHAR *str, int line_num);
  void TTYwin::mess_num(int num);
  void TTYwin::clear_scr(void);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\devprop.h ===
// devprop.h

int DoDevicePropPages(HWND hwndOwner);
void format_mac_addr(char *outstr, unsigned char *address);
int get_mac_field(HWND hDlg, WORD id, BYTE *MacAddr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\dripick.c ===
/*-------------------------------------------------------------------
| dripick.c - Driver Device Pick(main screen).
|--------------------------------------------------------------------*/
#include "precomp.h"

static BOOL FAR PASCAL on_command(HWND hDlg, UINT message,
                              WPARAM wParam, LPARAM lParam);
static int setup_buttons(HWND hDlg);
static void set_main_dlg_info(HWND hDlg);
static int do_tv_notify(HWND hDlg, UINT message,
                              WPARAM wParam, LPARAM lParam);
HIMAGELIST hTreeImage = NULL;

HBITMAP hbmBoard; 
HBITMAP hbmPort; 
HBITMAP hbmBoardMask; 
HBITMAP hbmPortMask; 

/*----------------------------------------------------------
 DevicePickSheet - Dlg window procedure for add on Advanced sheet.
|-------------------------------------------------------------*/
BOOL WINAPI DevicePickSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO * OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);
  UINT stat;
  static int first_time = 1;
  Port_Config *ps;

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);

      DbgPrintf(D_Init, ("Dripick:Init 9\n"))
      if (glob_hwnd == NULL)
        glob_hwnd = hDlg;

      if (wi->NumDevices == 0)
      {
        EnableWindow(GetDlgItem(hDlg, IDB_REMOVE),0);
        EnableWindow(GetDlgItem(hDlg, IDB_PROPERTIES),0);
      }

      set_main_dlg_info(hDlg);
      SetFocus(GetDlgItem(hDlg, IDC_LBOX_DEVICE));
#if (defined(NT50))
  // if nt50  then get rid of <add> and <remove>
  // buttons
     
    ShowWindow(GetDlgItem(hDlg, IDB_ADD), SW_HIDE);
    ShowWindow(GetDlgItem(hDlg, IDB_REMOVE), SW_HIDE);

#endif

    return TRUE;  // No need for us to set the focus.

    case PSM_QUERYSIBLINGS :
    {
      switch (HIWORD(wParam))
      {
        case QUERYSIB_GET_OUR_PROPS :
          // grab updated info from controls(don't have any)

          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          return TRUE;
        break;

        default :
        return FALSE;
      }
    }

    case WM_COMMAND :
        on_command(hDlg, uMessage, wParam, lParam);
    return FALSE;

    case WM_PAINT:
      if (first_time)
      {
        first_time = 0;
        if (wi->NumDevices == 0)  // bring up wizard
        {
          PostMessage(hDlg, WM_COMMAND, IDB_ADD, 0);  // bring up add wiz
        }
#if (defined(NT50) && defined(S_VS))
        // they need to configure the mac-address...
        if (mac_match(wi->dev[0].MacAddr, mac_zero_addr))
          PostMessage(hDlg, WM_COMMAND, IDB_PROPERTIES, 0);  // bring up VS device sheet
#endif
      }
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :

      switch (((NMHDR *)lParam)->code)
      {
        //case TVN_STARTLABELEDIT:   no such thing
        //  DgbPrint(D_Test, ("start label edit"))
        //return FALSE;

        case TVN_ENDLABELEDIT:
        {
          TV_ITEM *item;
          item = &((TV_DISPINFO *)lParam)->item;

          // 80H bit used to mark tree item as a Device(not port)
          glob_info->device_selected = (item->lParam & 0x7f);
          glob_info->port_selected = (item->lParam >> 8);

          if (item->lParam & 0x80)  // a board is selected
               glob_info->selected = BOARD_SELECTED;
          else glob_info->selected = PORT_SELECTED;

          if (item->pszText != NULL)
          {
            int bad_label = 0;

            // on a board(we should trap start-of-edit!)
            if (glob_info->selected == BOARD_SELECTED)
            {
              if (strlen(item->pszText) > 59)  // limit to 59 chars
                item->pszText[60] = 0;
              strcpy(wi->dev[glob_info->device_selected].Name, item->pszText);
  DbgPrintf(D_Error,(TEXT("device label:%s\n"), item->pszText));
            }
            else
            {
              // copy over new name
              if ((strlen(item->pszText) > 10) ||
                  (strlen(item->pszText) == 0))
              {
                bad_label = 1; // don't keep the text, to long
              }
              _tcsupr(item->pszText);

              if (_tcsncmp(item->pszText, "COM", 3) != 0)
                bad_label = 2;
              else if (strlen(item->pszText) < 4)
                bad_label = 3;
              else if (!isdigit(item->pszText[3]))
                bad_label = 4;

              if (bad_label)
              {
                DbgPrintf(D_Error, (TEXT("Bad COM name, err%d"), bad_label))

                stat = our_message(&wi->ip,RcStr((MSGSTR+2)),MB_OK);
                return 0;  // don't keep the text, to long
              }
              ps = &wi->dev[glob_info->device_selected].ports[glob_info->port_selected];

              strcpy(ps->Name, item->pszText);
#if 0
              validate_port_name(ps, 1);  // if not valid, make it so

              DbgPrintf(D_Error,(TEXT("port label:%s\n"), item->pszText));

              if (wi->dev[glob_info->device_selected].NumPorts > 
                          (glob_info->port_selected+1))
              {
                set_main_dlg_info(hDlg);
                stat = our_message(&wi->ip,
"Rename in ascending order all remaining ports on this device?",MB_YESNO);
                if (stat == IDYES)
                {
                  rename_ascending(glob_info->device_selected,
                                   glob_info->port_selected);
                }
              }
#endif
            }
            set_main_dlg_info(hDlg);

            return 1;  // keep the text
          }
        }
        break;

        case TVN_SELCHANGED :
          {
          // selection change in the tree view, update buttons accordingly
          NM_TREEVIEW *nmtv;
          TV_ITEM *item;
          nmtv = (NM_TREEVIEW *) lParam;
          item = &nmtv->itemNew;

          // 80H bit used to mark tree item as a Device(not port)
          glob_info->device_selected = (item->lParam & 0x7f);
          glob_info->port_selected = (item->lParam >> 8);

          if (item->lParam & 0x80)  // a board is selected
               glob_info->selected = BOARD_SELECTED;
          else glob_info->selected = PORT_SELECTED;

          setup_buttons(hDlg);
          }
        break;

        case PSN_HELP :
          our_help(&wi->ip, IDD_MAIN_DLG);
        break;

        case PSN_QUERYCANCEL :
          // request that the other sheets gather up any changes.
          PropSheet_QuerySiblings(GetParent(hDlg),
                                  (WPARAM) (QUERYSIB_GET_OUR_PROPS << 16),
                                  0);

          if (allow_exit(1))  // request cancel
          {
            // the DWL_MSGRESULT field must be *FALSE* to tell QueryCancel
            // that an exit is acceptable.  The function result must be
            // *TRUE* to acknowledge that we handled the message.
            SetWindowLong(hDlg, DWL_MSGRESULT, FALSE); // allow cancel
            return TRUE;
          }
          else
          {
            // the DWL_MSGRESULT field must be *TRUE* to tell QueryCancel
            // that we don't want an exit.  The function result must be
            // *TRUE* to acknowledge that we handled the message.
            SetWindowLong(hDlg, DWL_MSGRESULT, TRUE); // don't allow cancel
            return TRUE;
          }
        break;

        case PSN_APPLY :
            // request that the other sheets gather up any changes.
            PropSheet_QuerySiblings(GetParent(hDlg),
                                    (WPARAM) (QUERYSIB_GET_OUR_PROPS << 16),
                                    0);
            if (!wi->DriverExitDone)
            {
            // now see if anything changed that needs saving
            if (allow_exit(0))  // request ok to save and exit
            {
              wi->DriverExitDone = 1;  // prevents other pages doing this
              // do the install/save of config params if not canceling..
#ifdef NT50
              our_nt50_exit();  // ok, quit
#else
              our_exit();  // nt40 exit
#endif
              SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
              //wi->SaveOnExit = 1;
            }
            else
            {
              SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            }
            }
            return TRUE;

        default :
            return FALSE;
      }

    default :
        return FALSE;
  }
}

#define YBITMAP 16
#define XBITMAP 16
//#define XBITMAP 24

/*-------------------------------------------------------------------
| set_main_dlg_info - Run to setup the various field selections.
  ran at start and when any changes are made.  Smart IO-selections
  which exclude themselves from double choose.
|--------------------------------------------------------------------*/
static void set_main_dlg_info(HWND hDlg)
{
 int i,j,bd;
 HWND hwnd;
 char tmpstr[80];
 Device_Config *dev;
 int first_time = 0;

 int dev_select = glob_info->device_selected;
 int port_select = glob_info->port_selected;
 int selected = glob_info->selected;

  //------------------ fill in the device selection window
  hwnd = GetDlgItem(hDlg, IDC_LBOX_DEVICE);

  {
    TV_ITEM tvItem;
    HTREEITEM tvSelectHandle;
    TV_INSERTSTRUCT tvIns;

    if (hTreeImage == NULL)
    {
      hTreeImage = ImageList_Create(XBITMAP,YBITMAP, TRUE, 2, 2);
#ifdef S_VS
      i = ImageList_AddMasked (hTreeImage, LoadBitmap(glob_hinst,
//                         MAKEINTRESOURCE(BMP_VS_BOX)), RGB(128,128,128));
                         MAKEINTRESOURCE(BMP_VS_BOX)), RGB(255,255,255));
#else
      i = ImageList_AddMasked (hTreeImage, LoadBitmap(glob_hinst,
                         MAKEINTRESOURCE(BMP_BOARDS)), RGB(0,128,128));
#endif

      ImageList_AddMasked (hTreeImage, LoadBitmap(glob_hinst,
                         MAKEINTRESOURCE(BMP_PORTSM)), RGB(0,128,128));

      glob_info->device_selected = 0;
      glob_info->port_selected = 0;
      glob_info->selected = BOARD_SELECTED;

      dev_select = glob_info->device_selected;
      port_select = glob_info->port_selected;
      selected = glob_info->selected;

      first_time = 1;
    }

    TreeView_DeleteAllItems(hwnd);

    TreeView_SetImageList(hwnd, hTreeImage, TVSIL_NORMAL);

    for (bd=0; bd< wi->NumDevices; bd++)
    {
      dev = &wi->dev[bd];

      tvItem.pszText = dev->Name;
      tvItem.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
      tvItem.iImage         = 0;
      tvItem.iSelectedImage = 0;
      tvItem.lParam         = bd | 0x80;

      tvIns.hParent         = TVGN_ROOT;
      tvIns.hInsertAfter    = TVGN_ROOT;
      tvIns.item            = tvItem;

      // And insert the item, returning its handle
      dev->tvHandle = TreeView_InsertItem ( hwnd, &tvIns );

      if ((selected == BOARD_SELECTED) && (dev_select == bd))
        tvSelectHandle = dev->tvHandle;

      if (tvSelectHandle == NULL)  // make sure it selects something
        tvSelectHandle = dev->tvHandle;

      for (j=0; j< wi->dev[bd].NumPorts; j++)
      {
#ifdef INDEXED_PORT_NAMES
        // generate the port name based on StartComIndex
        wsprintf(dev->ports[j].Name, "COM%d", dev->StartComIndex + j);
#endif

        tvItem.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
        tvItem.iImage         = 1;
        tvItem.iSelectedImage = 1;
        tvItem.pszText = dev->ports[j].Name;
        tvItem.lParam  = bd | (j<<8);

        // Fill out the TV_INSERTSTRUCT
        tvIns.hInsertAfter    = NULL;
        tvIns.hParent         = dev->tvHandle;
        tvIns.item            = tvItem;
        // And insert the item, returning its handle
        dev->ports[j].tvHandle = TreeView_InsertItem ( hwnd, &tvIns );

        if ((selected == PORT_SELECTED) && (port_select == j) &&
            (dev_select == bd))
          tvSelectHandle = dev->ports[j].tvHandle;
      }
    }

    // make sure all devices are expanded, showing their ports.
    for (bd=0; bd< wi->NumDevices; bd++)
    {
      dev = &wi->dev[bd];
      TreeView_Expand ( hwnd, dev->tvHandle, TVE_EXPAND);
    }

    if (wi->NumDevices > 0)
    {
      if (!first_time)
        TreeView_SelectItem(hwnd, tvSelectHandle);
    }
  }

  setup_buttons(hwnd);
}

/*-----------------------------------------------------------------------------
| on_command -
|-----------------------------------------------------------------------------*/
BOOL FAR PASCAL on_command(HWND hDlg, UINT message,
                              WPARAM wParam, LPARAM lParam)
{
 WORD uCmd;
 int i,j, stat;

#ifdef WIN32
  uCmd = HIWORD(wParam);
#else
  uCmd = HIWORD(lParam);
#endif

  switch (LOWORD(wParam))
  {
    case IDC_LBOX_DEVICE:
      if (uCmd == CBN_DBLCLK)
      {
        // this doesn't work
        if (glob_info->selected == BOARD_SELECTED)
             DoDevicePropPages(hDlg);
        else DoPortPropPages(hDlg, glob_info->device_selected, glob_info->port_selected);
        break;
      }

      //if (uCmd != CBN_SELCHANGE) break;
    break;

// for nt50 we don't have a remove or add button
#if ( (!defined(NT50)) )
    case IDB_REMOVE:
      if (wi->NumDevices < 1)
      {
        MessageBox(hDlg,"Use the Network Control Panel applet to remove this software.",
                   "Error",MB_OK|MB_ICONSTOP);
        break;
      }

#ifdef S_RK
      // force them to remove ISA boards in order
      i = glob_info->device_selected;
      if (wi->dev[i].IoAddress >= 0x100)  // isa board
      {
        ++i;
        for (; i<wi->NumDevices; i++)
        {
          if (wi->dev[i].IoAddress >= 0x100)  // isa board
          {
            MessageBox(hDlg,"You have to remove the last ISA board in the list first.",
                      "Error",MB_OK|MB_ICONSTOP);
            i = 100;  // don't let them remove
          }
        }

        if (i>=100)  // don't let them remove
          break;
      }
#endif

      // delete the device node
      j = 0;
      for (i=0; i<wi->NumDevices; i++)
      {
        if (i != glob_info->device_selected)
        {
          if (i != j)
            memcpy(&wi->dev[j], &wi->dev[i], sizeof(Device_Config));
          ++j;
        }
      }
      if (wi->NumDevices > 0)
        --wi->NumDevices;
      if (glob_info->device_selected > 0)
        --glob_info->device_selected;

      glob_info->selected = BOARD_SELECTED;

      if (wi->NumDevices == 0)
      {
        EnableWindow(GetDlgItem(hDlg, IDB_REMOVE),0);
        EnableWindow(GetDlgItem(hDlg, IDB_PROPERTIES),0);
      }
      set_main_dlg_info(hDlg);
    break;

    case IDB_ADD:
      {
        Device_Config *dev;
        /////////char tmpstr[80];
        if (wi->NumDevices == MAX_NUM_DEVICES)
        {
          wi->NumDevices = MAX_NUM_DEVICES;
          our_message(&wi->ip,RcStr((MSGSTR+3)),MB_OK);
          break;  // bail
        }
        dev = &wi->dev[wi->NumDevices];

        glob_info->device_selected = wi->NumDevices; // point to new one

        // clear out all ports config
        memset(dev->ports, 0, sizeof(Port_Config) * MAX_NUM_PORTS_PER_DEVICE);  // clear our structure

        ++wi->NumDevices;

        stat = DoAddWizPropPages(hDlg);  // add wizard sheet

        if (stat != 0)  // they canceled or didn't finish
        {
          if (wi->NumDevices > 0)  // error, so remove
            --wi->NumDevices;
          break;  // cancelled, so bail
        }

        if (wi->NumDevices == 0)  // shouldn't happen, but just in case
          break;

        if (glob_info->device_selected >= wi->NumDevices)
          glob_info->device_selected = wi->NumDevices - 1;

        // transfer the data from the wizard buffer to the new device buffer
        strncpy(dev->ModelName, glob_add_wiz->BoardType, sizeof(dev->ModelName));
        dev->ModemDevice = glob_add_wiz->IsModemDev;
        wi->ModemCountry = glob_add_wiz->CountryCode;
        dev->NumPorts = glob_add_wiz->NumPorts;
#ifdef S_RK
        dev->IoAddress = glob_add_wiz->IoAddress;
        if (!glob_add_wiz->IsIsa)
          dev->IoAddress = 1;
        wsprintf(dev->Name, "Rocket #%d", wi->NumDevices);
#else
        dev->HubDevice = glob_add_wiz->IsHub;
        dev->BackupServer = glob_add_wiz->BackupServer;
        dev->BackupTimer = glob_add_wiz->BackupTimer;
        memcpy(&dev->MacAddr, &glob_add_wiz->MacAddr, sizeof(dev->MacAddr));
        if (dev->HubDevice)
          wsprintf(dev->Name, "Rocket Serial Hub #%d", wi->NumDevices);
        else if (dev->ModemDevice)
          wsprintf(dev->Name, "VS2000 #%d", wi->NumDevices);
        else
          wsprintf(dev->Name, "VS1000 #%d", wi->NumDevices);
#endif
        {
          char tmpstr[20];
          // pick com-port names
          FormANewComPortName(tmpstr, NULL);
          for (i=0; i<dev->NumPorts; i++)
          {
            strcpy(dev->ports[i].Name, tmpstr);
            BumpPortName(tmpstr);
          }
        }

        //validate_device(dev, 1);

        if (dev->ModemDevice)
        {
          // lets turn on the RING emulation option on the ports
          for (i=0; i<dev->NumPorts; i++)
            dev->ports[i].RingEmulate = 1;
        }

        // now show it.
        if (DoDevicePropPages(hDlg) != 0)  // if they cancel out
        {
          if (wi->NumDevices > 0)  // error, so remove
            --wi->NumDevices;
        }

        if (wi->NumDevices != 0)
        {
          EnableWindow(GetDlgItem(hDlg, IDB_REMOVE),1);
          EnableWindow(GetDlgItem(hDlg, IDB_PROPERTIES),1);
        }

        set_main_dlg_info(hDlg);
      }
    break;
#endif

    case IDB_PROPERTIES:
      if (wi->NumDevices == 0)
        break;

      if (glob_info->device_selected >= wi->NumDevices)
        glob_info->device_selected = wi->NumDevices - 1;

      if (glob_info->selected == BOARD_SELECTED)
        DoDevicePropPages(hDlg);
      else
        DoPortPropPages(hDlg, glob_info->device_selected, glob_info->port_selected);
      set_main_dlg_info(hDlg);
      SetFocus(GetDlgItem(hDlg, IDC_LBOX_DEVICE));
    break;

  }
  return TRUE;
}

/*---------------------------------------------------------------------------
  setup_buttons - Enable or Disable buttons depending on circumstances.
|---------------------------------------------------------------------------*/
static int setup_buttons(HWND hDlg)
{
  if (glob_info->selected == BOARD_SELECTED)  // on a board
  {
    EnableWindow(GetDlgItem(hDlg, IDB_PROPERTIES),1);
    EnableWindow(GetDlgItem(hDlg, IDB_REMOVE),1);  // enable remove
    if (wi->NumDevices < MAX_NUM_DEVICES)
         EnableWindow(GetDlgItem(hDlg, IDB_ADD),1);
    else EnableWindow(GetDlgItem(hDlg, IDB_ADD),0);
  }
  else  // on a port
  {
    EnableWindow(GetDlgItem(hDlg, IDB_PROPERTIES),1);
    EnableWindow(GetDlgItem(hDlg, IDB_REMOVE),0);  // disable remove
    EnableWindow(GetDlgItem(hDlg, IDB_ADD),0);     // disable add
  }

  if (wi->NumDevices == 0)  // special case
  {
    EnableWindow(GetDlgItem(hDlg, IDB_REMOVE),0);
    EnableWindow(GetDlgItem(hDlg, IDB_PROPERTIES),0);
    EnableWindow(GetDlgItem(hDlg, IDB_ADD),1);     // enable add
  }
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\driprop.c ===
/*-------------------------------------------------------------------
| driprop.c - Driver level Properties Sheet.
|--------------------------------------------------------------------*/
#include "precomp.h"

static void set_field(HWND hDlg, WORD id);
static void get_field(HWND hDlg, WORD id);
static void context_menu(void);

static Driver_Config *adv_org_wi = NULL;  // original info, use to detect changes

/*----------------------------------------------------------
 AdvDriverSheet - Dlg window procedure for add on Advanced sheet.
|-------------------------------------------------------------*/
BOOL WINAPI AdvDriverSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
 OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
#ifdef NT50
      glob_hwnd = hDlg;
#endif
      if (adv_org_wi == NULL)
        adv_org_wi =  (Driver_Config *) calloc(1,sizeof(Driver_Config));

      memcpy(adv_org_wi, wi, sizeof(*wi));  // save copy of original

      set_field(hDlg, IDC_VERBOSE);
      set_field(hDlg, IDC_GLOBAL485);
      set_field(hDlg, IDC_CBOX_SCAN_RATE);
#ifdef NT50
#if ALLOW_NO_PNP_PORTS
      set_field(hDlg, IDC_PNP_PORTS);
#else
      // hide this option for now.
      ShowWindow(GetDlgItem(hDlg, IDC_PNP_PORTS), SW_HIDE);
#endif
#endif
    return TRUE;  // No need for us to set the focus.

    case PSM_QUERYSIBLINGS :
    {
      switch (HIWORD(wParam))
      {
        case QUERYSIB_GET_OUR_PROPS :
          // grab updated info from controls(don't have any)

          get_field(hDlg, IDC_VERBOSE);
          get_field(hDlg, IDC_GLOBAL485);
          get_field(hDlg, IDC_CBOX_SCAN_RATE);
#ifdef NT50
#if ALLOW_NO_PNP_PORTS
          get_field(hDlg, IDC_PNP_PORTS);
#endif
#endif

          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          return TRUE;
        break;

        default :
        return FALSE;
      }
    }

    case WM_COMMAND:
      switch (LOWORD(wParam))
      {
        case IDB_DEF:
          wi->VerboseLog = 0;
          wi->ScanRate = 0;
          wi->GlobalRS485 = 0;
#ifdef NT50
          wi->NoPnpPorts = 0;
#endif
 
          set_field(hDlg, IDC_VERBOSE);
          set_field(hDlg, IDC_GLOBAL485);
          set_field(hDlg, IDC_CBOX_SCAN_RATE);
#ifdef NT50
#if ALLOW_NO_PNP_PORTS
          set_field(hDlg, IDC_PNP_PORTS);
#endif
#endif
        break;

        case IDM_ADVANCED_MODEM_INF:
          //mess(&wi->ip, "1.) modem inf");
          update_modem_inf(1);
        break;

        case IDM_PM:             // Try out the add pm group dde stuff
          setup_make_progman_group(0);
        break;
      }
    return FALSE;

    case WM_PAINT:
        //
    return FALSE;

    case WM_CONTEXTMENU:     // right-click
      context_menu();
    break;

    case WM_HELP:            // question mark thing
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_KILLACTIVE :
          // we're losing focus to another page...
          // make sure we update the Global485 variable here.
          get_field(hDlg, IDC_GLOBAL485);
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          return FALSE;  // allow focus change
        break;

        case PSN_HELP :
          our_help(&wi->ip, WIN_NT);
        break;

        case PSN_QUERYCANCEL :
          // request that the other sheets gather up any changes.
          PropSheet_QuerySiblings(GetParent(hDlg),
                                  (WPARAM) (QUERYSIB_GET_OUR_PROPS << 16),
                                  0);

          if (allow_exit(1))  // request cancel
          {
            // the DWL_MSGRESULT field must be *FALSE* to tell QueryCancel
            // that an exit is acceptable.  The function result must be
            // *TRUE* to acknowledge that we handled the message.
            SetWindowLong(hDlg, DWL_MSGRESULT, FALSE); // allow cancel
            return TRUE;
          }
          else
          {
            // the DWL_MSGRESULT field must be *TRUE* to tell QueryCancel
            // that we don't want an exit.  The function result must be
            // *TRUE* to acknowledge that we handled the message.
            SetWindowLong(hDlg, DWL_MSGRESULT, TRUE); // don't allow cancel
            return TRUE;
          }
        break;

        case PSN_APPLY :
            // request that the other sheets gather up any changes.
            PropSheet_QuerySiblings(GetParent(hDlg),
                                    (WPARAM) (QUERYSIB_GET_OUR_PROPS << 16),
                                    0);

            if (!wi->DriverExitDone)
            {
            // now see if anything changed that needs saving
            if (allow_exit(0))  // request ok to save and exit
            {
              wi->DriverExitDone = 1;  // prevents other pages doing this
              // do the install/save of config params if not canceling..
#ifdef NT50
              our_nt50_exit();  // ok, quit
#else
              our_exit();  // nt40 exit
#endif
              SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
              //wi->SaveOnExit = 1;
            }
            else
            {
              SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            }
            }
          return TRUE;

        default :
        return FALSE;
      }  // switch ->code
    break;  // case wmnotify

    default :
    // return FALSE;
    break;
  }  // switch(uMessage)
  return FALSE;
}

/*----------------------------------------------------------------------------
| scr_to_cur -  Our window screen pos to windows absolute cursor position.
|-----------------------------------------------------------------------------*/
static void scr_to_cur(HWND hwnd, POINT *pt)
{
 RECT rec;
 int cx, cy;

  GetWindowRect(hwnd, &rec);
  cx = GetSystemMetrics(SM_CXFRAME);
  cy = GetSystemMetrics(SM_CYCAPTION) + (cx-1);
  pt->x += (rec.left + cx);
  pt->y += ( rec.top + cy);
}

/*----------------------------------------------------------
 context_menu -
|------------------------------------------------------------*/
static void context_menu(void)
{
  HMENU hpop_menu;
  POINT scr_pt;
  int stat;
  scr_pt.x = 200;
  scr_pt.y = 200;

  hpop_menu = CreatePopupMenu();
  if (hpop_menu == NULL)
  {
    mess(&wi->ip, "Error from CreatePopMenu");
    return;
  }

  
#ifndef NT50
  AppendMenu(hpop_menu,  0, IDM_ADVANCED_MODEM_INF, "Update RAS modem.inf");
#endif
  AppendMenu(hpop_menu,  0, 0x11, "Run Wcom Test Terminal");
  AppendMenu(hpop_menu,  0, 0x12, "Run Portman Program");
  AppendMenu(hpop_menu,  0, 0x10, "Run Peer tracer");
  if (setup_utils_exist())
  {
    AppendMenu(hpop_menu,  0, IDM_PM, "Add Program Manager Menu Selections");
  }

  //scr_to_cur(glob_hwnd, &scr_pt);
  GetCursorPos(&scr_pt);
#if 0
  stat = TrackPopupMenu(hpop_menu,
                     0, /* flags */
                     //TPM_NONOTIFY, /* flags */
                     scr_pt.x, scr_pt.y, /* x,y */
                     0, /* 0 reserved */
                     glob_hwnd,
                     NULL);
#endif

  stat = TrackPopupMenuEx(hpop_menu,
                     TPM_NONOTIFY | TPM_RETURNCMD, /* flags */
                     scr_pt.x, scr_pt.y, /* x,y */
                     //0, /* 0 reserved */
                     glob_hwnd,
                     NULL);
  if (stat == IDM_ADVANCED_MODEM_INF)
  {
    update_modem_inf(1);
  }
  else if (stat == IDM_PM)
  {
    stat = make_progman_group(progman_list_nt, wi->ip.dest_dir);
  }
  else if (stat == 0x10)
  {
    GetSystemDirectory(gtmpstr,144);
    
    strcat(gtmpstr, "\\");
    strcat(gtmpstr, OurAppDir);
    SetCurrentDirectory(gtmpstr);
    strcat(gtmpstr, "\\peer.exe");
    WinExec(gtmpstr, SW_RESTORE);
  }
  else if (stat == 0x11)
  {
    GetSystemDirectory(gtmpstr,144);
    strcat(gtmpstr, "\\");
    strcat(gtmpstr, OurAppDir);
    SetCurrentDirectory(gtmpstr);
    strcat(gtmpstr, "\\wcom32.exe");
    WinExec(gtmpstr, SW_RESTORE);
  }
  else if (stat == 0x12)
  {
    GetSystemDirectory(gtmpstr,144);
    strcat(gtmpstr, "\\");
    strcat(gtmpstr, OurAppDir);
    SetCurrentDirectory(gtmpstr);
    strcat(gtmpstr, "\\portmon.exe");
    WinExec(gtmpstr, SW_RESTORE);
  }


  DestroyMenu(hpop_menu);
}

/*----------------------------------------------------------
 get_field -
|------------------------------------------------------------*/
static void get_field(HWND hDlg, WORD id)
{

  char tmpstr[60];
  UINT stat;
  INT val;

  //if (our_device_index >= wi->NumDevices)
  //  our_device_index = 0;
  //pc = &wi->dev[our_device_index].ports[our_port_index];

  switch(id)
  {
    case IDC_VERBOSE :
      //------------------ fill in "verbose event logging" option
      if (IsDlgButtonChecked(hDlg, id))
           wi->VerboseLog = 1;
      else wi->VerboseLog = 0;
    break;

    case IDC_PNP_PORTS :
#if ALLOW_NO_PNP_PORTS
  // don't allow them to change this here for now...
      if (IsDlgButtonChecked(hDlg, id))
           wi->NoPnpPorts = 1;
      else wi->NoPnpPorts = 0;
#endif
    break;

    case IDC_GLOBAL485 :
      if (IsDlgButtonChecked(hDlg, id))
        wi->GlobalRS485 = 1;
      else
        wi->GlobalRS485 = 0;
    break;

    case IDC_CBOX_SCAN_RATE :
      //------------------------- check scan_rate edit field
      GetDlgItemText(hDlg, id, tmpstr, 59);
      stat= sscanf(tmpstr,"%d",&val);
      if ((stat == 1) && (val >= 0))
      {
        wi->ScanRate = (int) val;
        //wsprintf(tmpstr, "scan:%d", wi->ScanRate);
        //P_TRACE(tmpstr);
      }
    break;
  }
}

/*----------------------------------------------------------
 set_field -
|------------------------------------------------------------*/
static void set_field(HWND hDlg, WORD id)
{
  HWND hwnd;
  char tmpstr[80];


  //if (our_device_index >= wi->NumDevices)
  //  our_device_index = 0;
  //pc = &wi->dev[our_device_index].ports[our_port_index];

  switch(id)
  {
    case IDC_VERBOSE :
      //------------------ fill in "verbose log" option
      SendDlgItemMessage(hDlg, id, BM_SETCHECK, wi->VerboseLog, 0);
    break;

    case IDC_GLOBAL485 :
      //------------------ fill in "global rs485" option
      SendDlgItemMessage(hDlg, id, BM_SETCHECK, wi->GlobalRS485, 0);
    break;

#if ALLOW_NO_PNP_PORTS
    case IDC_PNP_PORTS :
      SendDlgItemMessage(hDlg, id, BM_SETCHECK, wi->NoPnpPorts, 0);
    break;
#endif

    case IDC_CBOX_SCAN_RATE :
      hwnd = GetDlgItem(hDlg, IDC_CBOX_SCAN_RATE);
      SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "1");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "2");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "4");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) RcStr(MSGSTR+21));
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "20");

      if (wi->ScanRate < 0) wi->ScanRate = 0;
      if ((wi->ScanRate == 0) || (wi->ScanRate == 10))
        lstrcpy(tmpstr,RcStr(MSGSTR+21));
      else wsprintf(tmpstr,"%d",wi->ScanRate);
      SetDlgItemText(hDlg, IDC_CBOX_SCAN_RATE, tmpstr);
    break;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\dripick.h ===
// dripick.h

BOOL FAR PASCAL main_dlg_proc(HWND hDlg, UINT message,
                              WPARAM wParam, LPARAM lParam);

BOOL WINAPI DevicePickSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\nt40.h ===
int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
				   LPSTR lpCmdLine, int nCmdShow);
LRESULT FAR PASCAL  MainWndProc(HWND hwnd, UINT message,
						WPARAM wParam, LPARAM lParam);
int DoDriverPropPages(HWND hwndOwner);

// globals vars -
int do_progman_add;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\devprop.c ===
/*-------------------------------------------------------------------
| devprop.c - Device Properties Sheet.

 5-26-99 - fix picking inappropriate starting com-port index.
 2-02-99 - fix port rename problem, where it would skip over old port-names,
  also take out port-name from selection if owned by other drivers.
|--------------------------------------------------------------------*/
#include "precomp.h"

#define D_Level 0x20
// use a current and previous reading to measure the advance, or
// calculated value.  Drop occassional rollover case.
#define NORM_COUNTER(calc,curr,prev,last) \
{ \
  if ((curr) > (prev)) \
    calc = (last) + ((curr) - (prev)); \
  else \
    calc = (last); \
}

//#define  STATE_DISPLAY  1
#ifdef STATE_DISPLAY

#define STATE_CHANGE(newstate) \
{ \
  mess(&wi->ip, \
   "Currstate %s\nNewstate %s\n", \
   statestrings[pDstatus->verbose_advise_state], \
   statestrings[(newstate)]); \
  pDstatus->verbose_advise_state = (newstate); \
}
#else

#define STATE_CHANGE(newstate) \
{ \
  pDstatus->verbose_advise_state = (newstate); \
}
#endif

static void set_field(HWND hDlg, WORD id);
static void get_field(HWND hDlg, WORD id);
static int PaintIcon(HWND hWnd);
static int PaintLogo(HWND hWnd);

static int set_mac_field(HWND hDlg, WORD id);
static int set_io_addr_field(HWND hDlg, WORD id);

#define  MAX_DEVPROP_SHEETS 2

typedef struct
{
  int x;
  int y;
} POINT2D;

static int PaintRockers(HWND hWnd, int brd);
static int poly_border(POINT2D *pts, POINT2D *ends, int lines);
static void draw_but(HDC hDC, int x, int y, int cx, int cy, int but_in);

static int num_active_devprop_sheets = 1;  // always at least one

#ifdef S_VS

typedef struct {
  unsigned char  mac[6];
  unsigned char  flags;
  unsigned char  nic_index;
}DRIVER_MAC_STATUS;

typedef struct {
   ULONG struct_size;
   ULONG num_ports;
   ULONG total_loads;
   ULONG good_loads;
   ULONG backup_server;
   ULONG state;
   ULONG iframes_sent;
   ULONG rawframes_sent;  // was send_rawframes
   ULONG ctlframes_sent;  // was send_ctlframes
   ULONG iframes_resent;  // was pkt_resends
   ULONG iframes_outofseq;  // was ErrBadIndex
   ULONG frames_rcvd;    // was: rec_pkts
   ULONG nic_index;
   unsigned char dest_addr[6];
} PROBE_DEVICE_STRUCT;

typedef struct {
  ULONG struct_size;
  ULONG Open;
  ULONG pkt_sent;
  ULONG pkt_rcvd_ours;
  ULONG pkt_rcvd_not_ours;
  char NicName[64];
  unsigned char address[6];
} PROBE_NIC_STRUCT;

typedef struct {
  int   verbose_advise_state;  // index into big advise string
  int   vsl_detected;  // number of vs's found from broadcast ping
  int   vsl_available; // number of vs's available found from broadcast ping
  BYTE  vsl_load_status;  // flags info come back from broadcast query replys
  BYTE  vsl_device_status_found;  // 1=driver found matching VS config.
  BYTE  vsl_nic_status_found;  // 1=driver found NIC config.
  BYTE  vsl_driver_found;  // 1=we can talk to driver, 0=driver not loaded
  BYTE  vsl_ping_device_found;  // 1=we found it during a ping
  BYTE  vsl_mac_list_found;  // 1=ping delivered a list of macs on network

   PROBE_NIC_STRUCT curr_nic;
   PROBE_NIC_STRUCT prev_nic;
   PROBE_NIC_STRUCT calc_nic;
   PROBE_NIC_STRUCT temp_nic;
   PROBE_DEVICE_STRUCT curr_dev;
   PROBE_DEVICE_STRUCT prev_dev;
   PROBE_DEVICE_STRUCT calc_dev;
   PROBE_DEVICE_STRUCT temp_dev;
} DSTATUS;

#define  FLAG_APPL_RUNNING  0x01
#define  FLAG_NOT_OWNER    0x02
#define  FLAG_OWNER_TIMEOUT  0x04

static void set_status_field(HWND hDlg,WORD id,DSTATUS *pDstatus);
static void check_traffic_activity(DSTATUS *pDstatus);
static void get_status(DSTATUS *pDstatus,int reset);
static BYTE *ping_devices(DSTATUS *pDstatus, int *nBytes);
static void build_advisor_display(HWND hDlg,DSTATUS *pDstatus,int reset);

char *vslink_state_table[] = {      // 27 May BF
  "Init",
  "InitOwn",
  "SendCode",
  "Connect",
  "Active",
  "Invalid",
};

#define  VSL_STATE_INIT     0
#define  VSL_STATE_INITOWN  1
#define  VSL_STATE_SENDCODE 2
#define  VSL_STATE_CONNECT  3
#define  VSL_STATE_ACTIVE   4

// these values are used in port.c in the driver:
//#define ST_INIT          0
//#define ST_GET_OWNERSHIP 1
//#define ST_SENDCODE      2
//#define ST_CONNECT       3
//#define ST_ACTIVE        4

#define  NIC_STATE_INVALID  0
#define  NIC_STATE_CLOSED  1
#define  NIC_STATE_OPEN    2
#define  NIC_STATE_UNDEFINED  3

#define STATE_not_init          0
#define STATE_driver_not_avail  1
#define STATE_nic_not_avail     2
#define STATE_no_vslinks_avail  3
#define STATE_vslink_not_avail  4
#define STATE_not_configured    5
#define STATE_not_owner         6
#define STATE_vslink_not_ready  7
#define STATE_ok_no_traffic     8
#define STATE_ok                9
#define STATE_poor_link        10
#define STATE_reset            11
//#define STATE_network_not_avail

#if 0
char *AdvisoryString[] = {        // 27 May BF
/* 1 */  "Device is active and OK.",
/* 2 */  "No data traffic exchanged since last inquiry.",
#endif

char *AdvisoryString[] = {        // 27 May BF
"Uninitialized.",

"The driver is not running.  If you just installed the driver \
you will need to exit the program before the driver starts.",

"Unable to find a Network Interface Controller (NIC) card.",

"Can't detect any Comtrol devices. Check Ethernet connectors and insure \
device is powered on.",

"Can't detect device with specified MAC address on any network. Verify MAC \
address of unit, check Ethernet connectors and insure device is powered on.",

"Device with specified MAC address was detected, but isn't configured for \
this server. Return to 'Device Setup' dialog, configure, save configuration, \
and restart server.",

"Device detected and is configured for this server, but is not yet assigned \
to this server.",

"Device detected, initializing.",

"Device is active and OK, no data traffic exchanged since last inquiry.",

"Device is active and OK.",

"Poor connection to device. Check connectors, cabling, and insure proper LAN \
termination.",

"Counts reset.",
};

static int dstatus_initialized = 0;
static DSTATUS glob_dstatus;

#endif

int FillDevicePropSheets(PROPSHEETPAGE *psp, LPARAM our_params);
BOOL WINAPI DevicePropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam);

BOOL WINAPI StatusPropSheet(      // 27 May BF
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam);

/*------------------------------------------------------------------------
| FillDevicePropSheets - Setup pages for driver level property sheets.
|------------------------------------------------------------------------*/
int FillDevicePropSheets(PROPSHEETPAGE *psp, LPARAM our_params)
{
  INT pi;
  static TCHAR devsetstr[40], devadvstr[40];

  memset(psp, 0, sizeof(*psp) * MAX_DEVPROP_SHEETS);

  pi = 0;

  // prop device sheet.
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
#ifdef S_VS
  psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_VS_DEVICE_SETUP);
#else
  psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_DEVICE_SETUP);
#endif
  psp[pi].pfnDlgProc = DevicePropSheet;
  load_str( glob_hinst, (TITLESTR+1), devsetstr, CharSizeOf(devsetstr) );
  psp[pi].pszTitle = devsetstr;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;
  num_active_devprop_sheets = 1;

#ifdef S_VS
  // prop status sheet.
  psp[pi].dwSize    = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags   = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags   = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance   = glob_hinst;
  psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_STATUS);
  psp[pi].pfnDlgProc  = StatusPropSheet;
  load_str( glob_hinst, (TITLESTR+2), devadvstr, CharSizeOf(devadvstr) );
  psp[pi].pszTitle    = devadvstr;
  psp[pi].lParam    = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;
  ++num_active_devprop_sheets;
#endif

  return 0;
}

/*------------------------------------------------------------------------
| DoDevicePropPages - Main driver level property sheet for NT4.0
|------------------------------------------------------------------------*/
int DoDevicePropPages(HWND hwndOwner)
{
    PROPSHEETPAGE psp[MAX_DEVPROP_SHEETS];
    PROPSHEETHEADER psh;
    OUR_INFO *our_params;
    INT stat;
    static TCHAR devpropstr[40];

    our_params = glob_info;  // temporary kludge, unless we don't need re-entrantancy 

    //Fill out the PROPSHEETPAGE data structure for the Client Area Shape
    //sheet
    FillDevicePropSheets(&psp[0], (LPARAM)our_params);

    //Fill out the PROPSHEETHEADER
    memset(&psh, 0, sizeof(PROPSHEETHEADER));

    psh.dwSize = sizeof(PROPSHEETHEADER);
    //psh.dwFlags = PSH_USEICONID | PSH_PROPSHEETPAGE;
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndOwner;
    psh.hInstance = glob_hinst;
    psh.pszIcon = "";
    load_str( glob_hinst, (TITLESTR+9), devpropstr, CharSizeOf(devpropstr) );
    psh.pszCaption = devpropstr;
    psh.nPages = num_active_devprop_sheets;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;
#ifdef S_VS
    if (!dstatus_initialized)
    {
      dstatus_initialized = 1;
      memset(&glob_dstatus, 0, sizeof(glob_dstatus));
      //establish a base point for packet stats...
      get_status(&glob_dstatus,0);
    }
#endif
    //And finally display the dialog with the property sheets.

    stat = PropertySheet(&psh);
  return 0;
}

/*----------------------------------------------------------
 DevicePropSheet - Dlg window procedure for add on Advanced sheet.
|-------------------------------------------------------------*/
BOOL WINAPI DevicePropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);
  //UINT stat;
  WORD uCmd;
  HWND hwnd;

  switch(uMessage)
  {

    case WM_INITDIALOG :
        OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
        // save in case of cancel
        //memcpy(&org_dev, &wi->dev[glob_info->device_selected], sizeof(org_dev));

        set_field(hDlg, IDC_EB_NAME);
#ifdef S_VS
        set_field(hDlg, IDC_CBOX_NUMPORTS);
#endif
        set_field(hDlg, IDC_CBOX_SC);
#ifdef S_VS
        set_field(hDlg, IDC_CBOX_MACADDR);
        set_field(hDlg, IDC_BACKUP_SERVER);
        set_field(hDlg, IDC_BACKUP_TIMER);
#else
#if (defined(NT50) && defined(S_RK))
  // if nt50 and rocketport then get rid of io-address field as
  // nt takes care of io-allocation for us.
        ShowWindow(GetDlgItem(hDlg, IDC_CBOX_IOADDR), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDL_ISA_BUS_LABEL), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDL_BASE_ADDR_LABEL), SW_HIDE);
#endif

        set_field(hDlg, IDC_CBOX_IOADDR);
        set_field(hDlg, IDC_LBL_SUMMARY1);
        set_field(hDlg, IDC_LBL_SUMMARY2);
#endif
    return TRUE;  // No need for us to set the focus.

    case WM_COMMAND:
      uCmd = HIWORD(wParam);

      switch (LOWORD(wParam))
      {
        case IDC_BACKUP_SERVER:
          //--- enable or disable backup-timer field depending on backup server[]
          hwnd = GetDlgItem(hDlg, IDC_BACKUP_TIMER);
          if (IsDlgButtonChecked(hDlg, IDC_BACKUP_SERVER))
            EnableWindow(hwnd,1);
          else EnableWindow(hwnd,0);
        break;

#ifdef S_RK
#if (!defined(NT50))
        case IDC_CBOX_IOADDR:
          if (uCmd == CBN_SELCHANGE)
          {
            get_field(hDlg, IDC_CBOX_IOADDR);

            PaintRockers(hDlg, glob_info->device_selected);
          }
        break;
#endif
#endif
      }
    return FALSE;

    case WM_PAINT:
      PaintIcon(hDlg);
#ifdef S_RK
      PaintLogo(GetDlgItem(hDlg, IDC_RKT_LOGO));
#else
      PaintLogo(GetDlgItem(hDlg, IDC_VS_LOGO));
#endif
#ifdef S_RK
#if (!defined(NT50))
      PaintRockers(hDlg, glob_info->device_selected);
#endif
#endif
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_HELP :
#ifdef S_VS
          our_help(&wi->ip, IDD_VS_DEVICE_SETUP);
#else
          our_help(&wi->ip, IDD_DEVICE_SETUP);
#endif
        break;

        case PSN_APPLY :
          get_field(hDlg, IDC_EB_NAME);
          get_field(hDlg, IDC_CBOX_SC);
#ifdef S_VS
          get_field(hDlg, IDC_CBOX_NUMPORTS);
          get_field(hDlg, IDC_CBOX_MACADDR);
          get_field(hDlg, IDC_BACKUP_SERVER);
          get_field(hDlg, IDC_BACKUP_TIMER);
#else
          get_field(hDlg, IDC_CBOX_IOADDR);
#endif
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          return TRUE;

        default :
          return FALSE;
      }
    break;

    default :
    //  return FALSE;
	  break;
  }
  return FALSE;
}

/*----------------------------------------------------------
 set_field -
|------------------------------------------------------------*/
static void set_field(HWND hDlg, WORD id)
{
  HWND hwnd;
  char tmpstr[60];
  Device_Config *dev;
  int i;

  dev = &wi->dev[glob_info->device_selected];

  switch(id)
  {
    case IDC_EB_NAME:
      SetDlgItemText(hDlg, id, dev->Name);
    break;

    case IDC_LBL_SUMMARY1:
      wsprintf(tmpstr, "%s - %d  ",
               dev->ModelName,
               dev->NumPorts);
      if (dev->IoAddress == 1)
        strcat(tmpstr, "PCI");
      else
        strcat(tmpstr, "ISA");
      SetDlgItemText(hDlg, id, tmpstr);
    break;

    case IDC_LBL_SUMMARY2:
      strcpy(tmpstr,"");

      if (dev->ModemDevice == TYPE_RM_VS2000) {

        for (
        i = 0; 
        i < NUM_ROW_COUNTRIES; 
        i++
        ) {
          if (wi->ModemCountry == RowInfo[i].RowCountryCode)  
            break;
        }
        wsprintf(
          tmpstr, 
          "Configured for: %s",
          (i == NUM_ROW_COUNTRIES) ? RowInfo[0].RowCountryName : RowInfo[i].RowCountryName);
      }
      else if (dev->ModemDevice == TYPE_RM_i) {

        strcpy(tmpstr,CTRRowInfo[0].RowCountryName);  // default 

        for (
        i = 0; 
        i < NUM_CTR_ROW_COUNTRIES; 
        i++
        ) {
          if (wi->ModemCountry == CTRRowInfo[i].RowCountryCode)  
            break;
        }
        wsprintf(
          tmpstr, 
          "Configured for: %s",
          (i == NUM_CTR_ROW_COUNTRIES) ? CTRRowInfo[0].RowCountryName : CTRRowInfo[i].RowCountryName);
      }
      else if (dev->ModemDevice) {

        wsprintf(
          tmpstr, 
          "Configured for: %s",
          RowInfo[0].RowCountryName);
      }

      SetDlgItemText(hDlg, id, tmpstr);
    break;

#ifdef S_VS
    case IDC_CBOX_NUMPORTS:
      hwnd = GetDlgItem(hDlg, id);
      if (dev->ModemDevice)
      {
DbgPrintf(D_Test, ("vs2000 fill\n"))
        // VS2000 only available in 8 port configuration
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP8);
      }
      else if (dev->HubDevice)
      {
DbgPrintf(D_Test, ("hubdev fill\n"))
        // SerialHub available in 4 (not yet) and 8 port configuration
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP4);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP8);
        // default the number of ports for the Serial Hub to 8
      }
      else
      {
DbgPrintf(D_Test, ("vs fill\n"))
        // we must have a VS1000 or VS1000/VS1100 combo
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP16);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP32);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP48);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP64);
      }
      wsprintf(tmpstr, "%d", dev->NumPorts);
      SendMessage(hwnd, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)(char far *) tmpstr);
    break;
#endif

#ifdef S_VS
    case IDC_CBOX_MACADDR:
      set_mac_field(hDlg, id);
    break;
#endif

    case IDC_CBOX_SC:
      //---------------------- setup starting com port

      hwnd = GetDlgItem(hDlg, IDC_CBOX_SC);
      {
        int foundName = 0;
        int pi = 0;
        SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
        for (i=1; i<1024; i++)
        {
          wsprintf(tmpstr,"COM%d", i);
          if ((!IsPortNameInSetupUse(tmpstr)) &&  // not ours already
              (IsPortNameInRegUse(tmpstr) == 1))  // not ours in registry
          {
            // someone elses name, don't put in our list
          }
          else
          {
            SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM) tmpstr);

            if ((foundName == 0) &&(_tcsicmp(tmpstr, dev->ports[0].Name) == 0))
            {
               foundName = pi;
            }
            ++pi;
          }
        }
        SendMessage(hwnd, CB_SETCURSEL, foundName, (LPARAM)0);

        // this was setting "COM300" from list instead of "COM3" for some reason
        // under NT2000, So go back to index way.   kpb, 5-26-99
        //SendMessage(hwnd, CB_SELECTSTRING, 0, (LPARAM)dev->ports[0].Name);
      }

    break;

    case IDC_BACKUP_SERVER:
      //------------------ fill in "BackupServer" option
      SendDlgItemMessage(hDlg, IDC_BACKUP_SERVER, BM_SETCHECK, dev->BackupServer, 0);
       //--- enable or disable backup-timer field depending on backup server[]
      hwnd = GetDlgItem(hDlg, IDC_BACKUP_TIMER);
      if (IsDlgButtonChecked(hDlg, IDC_BACKUP_SERVER))
        EnableWindow(hwnd,1);
      else EnableWindow(hwnd,0);
    break;

    case IDC_BACKUP_TIMER:
      //------------------ fill in backup timer selection
      hwnd = GetDlgItem(hDlg, IDC_BACKUP_TIMER);
      SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "2 min");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "5 min");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "10 min");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "30 min");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "60 min");

      if (dev->BackupTimer < 2) dev->BackupTimer = 2; // 2 minute, no less

      wsprintf(tmpstr, "%d min", dev->BackupTimer);
      SetDlgItemText(hDlg, IDC_BACKUP_TIMER, tmpstr);
    break;

    case IDC_CBOX_IOADDR:
      set_io_addr_field(hDlg, id);
    break;
  }
}

/*-------------------------------------------------------------------
| get_field -
|--------------------------------------------------------------------*/
static void get_field(HWND hDlg, WORD id)
{
  char tmpstr[60];
  Device_Config *dev;
  int stat, i, chk;
  int val;

  dev = &wi->dev[glob_info->device_selected];

  switch (id)
  {
    case IDC_EB_NAME:
      GetDlgItemText(hDlg, IDC_EB_NAME, dev->Name, 59);
    break;

#ifdef S_VS
    case IDC_CBOX_NUMPORTS:
    {
      int bad = 0;
      GetDlgItemText(hDlg, id, tmpstr, 19);
      stat= sscanf(tmpstr,"%ld",&val);

      if ((stat == 1) && (val >= 0))
      {
        if (val == 4)
          dev->NumPorts = (int) val;
        else if (val == 8)
          dev->NumPorts = (int) val;
        else if (val == 16)
          dev->NumPorts = (int) val;
        else if (val == 32)
          dev->NumPorts = (int) val;
        else if (val == 48)
          dev->NumPorts = (int) val;
        else if (val == 64)
          dev->NumPorts = (int) val;
        else
         bad = 1;
      }
      else
      {
        bad = 1;
        dev->NumPorts = 16;
      }

      if (bad)
      {
        our_message(&wi->ip,RcStr(MSGSTR),MB_OK);
        //ret_stat = 1;
      }
    }
    break;
#endif

#ifdef S_VS
    case IDC_CBOX_MACADDR:
      get_mac_field(hDlg, id, dev->MacAddr);
    break;
#endif

    case IDC_CBOX_SC:
      GetDlgItemText(hDlg, id, tmpstr, 58);
      if (_tcsicmp(tmpstr, dev->ports[0].Name) != 0) //changed
      {
        //StartComIndex = getint(&tmpstr[3], &i);  // COM# num
        for (i=0; i<dev->NumPorts; i++)
        {
          strcpy(dev->ports[i].Name, tmpstr);  // put in new name
          BumpPortName(tmpstr);

          // if its not our name already
          if (!IsPortNameInSetupUse(tmpstr))
          {
            chk = 0;
            // keep picking new name if this name is already
            // owned based on the names exported in the registry.
            while ((IsPortNameInRegUse(tmpstr) == 1) && (chk < 1024))
            {
              BumpPortName(tmpstr);
              ++chk;
            }
          }
        }
      }
    break;

    case IDC_BACKUP_SERVER:
      //------------------ get the backup server chk box.
      if (IsDlgButtonChecked(hDlg, IDC_BACKUP_SERVER))
           dev->BackupServer = 1;
      else dev->BackupServer = 0;

    break;

    case IDC_BACKUP_TIMER:
      //------------------ get the backup timer value
      //bad = 0;
      GetDlgItemText(hDlg, id, tmpstr, 19);
      stat= sscanf(tmpstr,"%ld",&val);
      if (stat == 1)
        dev->BackupTimer = val;

      if (dev->BackupTimer < 2)
        dev->BackupTimer = 2;
    break;

    case IDC_CBOX_IOADDR:
      //------------------ get the io-address
      GetDlgItemText(hDlg, IDC_CBOX_IOADDR, tmpstr, 19);
      if (tmpstr[0] == 'N')       // Not Available (PCI)
        dev->IoAddress = 1;
      else
      {
        stat= sscanf(tmpstr,"%lx",&val);
    
        if ((stat == 1) && (val >= 2))
        {
          dev->IoAddress = val;
        }
      }
    break;
  }
}

/*----------------------------------------------------------
 set_io_addr_field -
|------------------------------------------------------------*/
static int set_io_addr_field(HWND hDlg, WORD id)
{
  int io_pick, i, v;
  WORD lo;
  BOOL is_avail;
  static WORD hex_addresses[] = {0x100, 0x140, 0x180, 0x1c0,
                                 0x200, 0x240, 0x280, 0x2c0,
                                 0x300, 0x340, 0x380, 0x3c0, 0};
  HWND hwnd;
  char tmpstr[60];
  Device_Config *dev;

  dev = &wi->dev[glob_info->device_selected];


  //------------------ fill io-address
  hwnd = GetDlgItem(hDlg, IDC_CBOX_IOADDR);
  SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
  io_pick = 0;

  if (dev->IoAddress == 1)  // pci
  {
    io_pick = 1;

    strcpy(tmpstr, "N/A");
    SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM) tmpstr);
    SendMessage(hwnd, CB_SELECTSTRING, (WPARAM) -1, (LPARAM)(char far *) tmpstr);
  }
  else
  {
    for (i=0; hex_addresses[i] != 0; i++)
    {
      lo = hex_addresses[i];
      if (dev->IoAddress == lo)
      {
        io_pick = i;
      }

      // decide whether the current address is already in use or is available
      is_avail = TRUE;    // assume true unless we find otherwise
      for (v = 0; v < wi->NumDevices; v++)
      {
        if ((wi->dev[v].IoAddress == lo) &&
            (v != glob_info->device_selected))
        {
          is_avail = FALSE;
          break;
        }
      }

      if (is_avail)
      {
        wsprintf(tmpstr,"%x Hex",lo);
        if (lo == 0x180)
          strcat(tmpstr," Default");
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM) tmpstr);

        // if this was the user's choice from the wizard, highlight it
        if (lo == dev->IoAddress)
          SendMessage(hwnd, CB_SELECTSTRING, (WPARAM) -1, (LPARAM)(char far *) tmpstr);
      }
    }
  }

  // control whether the io base address combo box is enabled or disabled
  if (wi->dev[glob_info->device_selected].IoAddress == 1)
    EnableWindow(hwnd, 0);
  else
    EnableWindow(hwnd, 1);

  return 0;
}

#ifdef S_VS
/*----------------------------------------------------------
 set_mac_field -
|------------------------------------------------------------*/
static int set_mac_field(HWND hDlg, WORD id)
{
  HWND hwnd;
  char tmpstr[60];
  Device_Config *dev;
  int i;
  int addr_used, nbytes;
  BYTE *macbuf;
  BYTE *mac;

  dev = &wi->dev[glob_info->device_selected];

  //------------------ fill in mac addr selection
  hwnd = GetDlgItem(hDlg, id);
  SendMessage(hwnd, CB_RESETCONTENT, 0, 0);

    // ping the devices to get mac list to display, also collect
    // info for device advisor
  macbuf = ping_devices(&glob_dstatus, &nbytes);
  if ((macbuf != NULL) && (nbytes != 0))
  {
    for (i=0; i<nbytes/8; i++)
    {
      mac = &macbuf[i*8];
      format_mac_addr(tmpstr, mac);

      if (mac[6] & FLAG_APPL_RUNNING)
      {
        if (mac[6] & FLAG_NOT_OWNER)
        {
          strcat(tmpstr, " (used)");
        }
        else
        {
          if (!mac_match(mac, dev->MacAddr))
          {
            // why are devices saying we are owner when our server is
            // not configured for them??? this must be a bug in box?
            strcat(tmpstr, " (Used)"); 
          }
          else strcat(tmpstr, " (ours)");
        }
      }
      else
      {
        // just leave it blank
        // strcat(tmpstr, " (free)");
      }
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) tmpstr);
    }

  }
  
  addr_used = 1;
  
  if ( (mac_match(dev->MacAddr, broadcast_addr)) ||
       (mac_match(dev->MacAddr, mac_zero_addr)) )
    addr_used = 0;
  
  if (addr_used)
  {
    mac = &dev->MacAddr[0];
    format_mac_addr(tmpstr, mac);
  }
  else
  {
    memset(dev->MacAddr, 0, 6);
    strcpy(tmpstr, "00 C0 4E # # #");
  }
  // set the text in the window
  SetDlgItemText(hDlg, IDC_CBOX_MACADDR, tmpstr);
  SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "00 C0 4E # # #");

  DbgPrintf(D_Level,(TEXT("END set_macfield\n")));

  return 0;
}

/*----------------------------------------------------------
 get_mac_field -
|------------------------------------------------------------*/
int get_mac_field(HWND hDlg, WORD id, BYTE *MacAddr)
{
 int mac_nums[6];
 int stat,i;
 char tmpstr[64];
 Device_Config *dev;
 int bad;
 int ret_stat = 0;

 if (glob_info->device_selected >= wi->NumDevices)
     glob_info->device_selected = 0;
 dev = &wi->dev[glob_info->device_selected];

 bad = 0;
  GetDlgItemText(hDlg, id, tmpstr, 20);
  {
    stat = sscanf(tmpstr, "%x %x %x %x %x %x",
              &mac_nums[0], &mac_nums[1], &mac_nums[2],
              &mac_nums[3], &mac_nums[4], &mac_nums[5]);
    if (stat == 6)
    {
      for (i=0; i<6; i++)
      {
        if (mac_nums[0] > 0xff)
          bad = 1;
      }
      if (!bad)
      {
        MacAddr[0] = mac_nums[0];
        MacAddr[1] = mac_nums[1];
        MacAddr[2] = mac_nums[2];
        MacAddr[3] = mac_nums[3];
        MacAddr[4] = mac_nums[4];
        MacAddr[5] = mac_nums[5];
        if (mac_match(broadcast_addr, dev->MacAddr))
        {
          memset(dev->MacAddr,0,6);  // all zeros = auto
        }
      }
      else
        bad = 1;
    }
    else
      bad = 1;
  }  // not autodetect

  if (bad)
  {
    our_message(&wi->ip,RcStr((MSGSTR+1)),MB_OK);
    memset(MacAddr,0,6);  // all zeros = auto
    ret_stat = 1;
  }
  return ret_stat;
}
#endif

#ifdef S_RK
/*---------------------------------------------------------------------------
  PaintRockers - Paints the Rocker Switches
|---------------------------------------------------------------------------*/
static int PaintRockers(HWND hWnd, int brd)
{
  HDC hDC;
  //POINT2D pts[18];
  //POINT2D epts[6];
  //HBRUSH hbrush;
  RECT rect;
  int x,y,cx,cy, sw_i, top;
  int sw_size = 8;
  int sw_space = 2;
  //int num_hi = 2;
  int but_in;
  int sw_on[8];
  int i;
  //static HPEN hpens = NULL;
  //static HPEN hpenh = NULL;
  //static HBRUSH hbrushf = NULL;
  int base_x = 300;
  int base_y = 120;
  char tmpstr[40];

  int x_cell_size;
  int y_cell_size;
  int brd_index;
  int io_address;

  RECT spot, main;  // left, top, right, bottom

  i = glob_info->device_selected;
  if (wi->dev[i].IoAddress < 0x100)  // not isa board
    return 1;  // err, no switches

  // figure out the rocker address
  brd_index = 0;
  io_address = 0;
  for (i=0; i<wi->NumDevices; i++)
  {
    if (wi->dev[i].IoAddress >= 0x100)  // isa board
    {
      if (brd_index == 0)
      {
        io_address = wi->dev[i].IoAddress;
      }
      if (i == glob_info->device_selected)
        break;
      ++brd_index;
    }
  }
  io_address += (brd_index * 0x400);  // example: 180H, 580H, ..

  hDC = GetDC(hWnd);

  // position to the left of the io-address field
  GetWindowRect(GetDlgItem(hWnd, IDC_CBOX_IOADDR), &spot);
  GetWindowRect(hWnd, &main);
  spot.right -= main.left;
  spot.top -= main.top;
  base_x = spot.right + 25;
  base_y = spot.top;

  x_cell_size = sw_size + sw_space;
  y_cell_size = sw_size + sw_space;

  // calculate which switch is on.
  io_address += 0x40;  // go from 180 to 1c0(rockers set mudbac address)
  io_address >>= 6;  // kill 40H worth(rocker sw1 starts at 40h)
  for (i=0; i<8; i++)
  {
    if (io_address & 1)
         sw_on[i] = 0;
    else sw_on[i] = 1;
    io_address >>= 1;  // to next bit
  }

  // erase background and draw border of rockers
  x = base_x - (sw_space*3);
  y = base_y - ((sw_size + sw_space) * 2);
  cx = ((sw_size + sw_space) * 9);
  cy = ((sw_size + sw_space) * 6);
  draw_but(hDC, x,y,cx,cy, 2);

  // draw the rockers
  // top and left border, poly_border will calculate line endpts to draw
  SelectObject(hDC, GetStockObject(NULL_BRUSH));
  for (sw_i = 0; sw_i < 8; ++sw_i)  // rocker switches
  {
    for (top = 0; top < 2; ++top)  // top = 1 if at top of rocker
    {
    if (top)
    {
      // draw the switch(as a popped up button)
      but_in = 0;
      y = base_y;
      if (!sw_on[sw_i])
        y += ((sw_size + sw_space));
      cx = sw_size;
      cy = sw_size;
    }
    else
    {
      // draw the slot(as a pushed in button hole)
      but_in = 1;
      x = base_x + ((sw_size + sw_space) * sw_i);
      y = base_y + ((sw_size + sw_space) * top);
      cx = sw_size;
      cy = (sw_size * 2) + sw_space;
    }

    draw_but(hDC, x,y,cx,cy, but_in);

  }  // top

  // draw the rocker switch number
  rect.left = x;
  rect.right = x + 6;
  rect.top = base_y + ((sw_size + sw_space) * 2);
  rect.bottom = rect.top + 14;
  SetBkMode(hDC,TRANSPARENT);
  SetTextColor(hDC,GetSysColor(COLOR_BTNTEXT));
  wsprintf(tmpstr, "%d", sw_i+1);
  DrawText(hDC, tmpstr, strlen(tmpstr), &rect,
           DT_CENTER | DT_VCENTER | DT_WORDBREAK);
  }  // sw_i

  // draw the "ON"
  rect.left = base_x;
  rect.right = base_x + 18;
  rect.top = base_y - (sw_size + sw_space) - 6;
  rect.bottom = rect.top + 14;
  SetBkMode(hDC,TRANSPARENT);
  SetTextColor(hDC,GetSysColor(COLOR_BTNTEXT));
  DrawText(hDC, "ON", 2, &rect,
           DT_CENTER | DT_VCENTER | DT_WORDBREAK);

  ReleaseDC(hWnd, hDC);

  return 0;
}

/*----------------------------------------------------------
 draw_but - draw a button
|------------------------------------------------------------*/
static void draw_but(HDC hDC, int x, int y, int cx, int cy, int but_in)
{
  static HPEN hpens = NULL;
  static HPEN hpenh = NULL;
  static HBRUSH hbrushf = NULL;
  POINT2D pts[18];
  POINT2D epts[6];
  int num_hi = 2;  // number of highlight lines.

  epts[0].x = x;
  epts[0].y = y+cy;
  epts[1].x = x;
  epts[1].y = y;
  epts[2].x = x+cx;
  epts[2].y = y;
  epts[3].x = x+cx;
  epts[3].y = y+cy;

  // setup some pens to use
  if (hpens == NULL)
  {
    hpens = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNSHADOW));
    hpenh = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNHILIGHT));
    hbrushf = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
  }

  if (but_in & 2) // fill background, black outline(special kludge case)
  {
    SelectObject(hDC, hbrushf);
    SelectObject(hDC, GetStockObject(BLACK_PEN));
    Polyline(hDC, (POINT *)&epts[0], 4);
    but_in &= 1;
  }
  SelectObject(hDC, GetStockObject(NULL_BRUSH));

  poly_border(pts, epts, num_hi);  // calculate endpts
    if (but_in)
       SelectObject(hDC, GetStockObject(BLACK_PEN)); // pushed in look
  else SelectObject(hDC, GetStockObject(WHITE_PEN));
  Polyline(hDC, (POINT *)&pts[0], num_hi*3);

  if (num_hi > 1)
  {    // draw the middle shade inbetween hilite lines
    if (but_in)
         SelectObject(hDC, hpens); // pushed in look, shadow on top
    else SelectObject(hDC, hpenh); // hilite on top
    Polyline(hDC, (POINT *)&pts[num_hi*3-3], 3);
  }

  // bottom and right border
  SelectObject(hDC, GetStockObject(NULL_BRUSH));
  epts[1].x = x+cx;
  epts[1].y = y+cy;

  poly_border(pts, epts, num_hi);  // calc bottom line endpts
  if (but_in)
       SelectObject(hDC, GetStockObject(WHITE_PEN));  // pushed out look
  else SelectObject(hDC, GetStockObject(BLACK_PEN));
  Polyline(hDC, (POINT *)&pts[0], num_hi*3);

  if (num_hi > 1)
  {
    if (but_in)
         SelectObject(hDC, hpenh); // pushed out look
    else SelectObject(hDC, hpens);
    Polyline(hDC, (POINT *)&pts[num_hi*3-3], 3);
  }
}

/*----------------------------------------------------------
 poly_border - fill in pnts to shadow or highlight a button
   using one polyline call.
    ends[] - ctrl pnts, 3 for box(top & left) or (bottom & right)
|------------------------------------------------------------*/
static int poly_border(POINT2D *pts, POINT2D *ends, int lines)
{
  int li;
  int pi,j;
  static POINT2D top[3] = {{1,-1}, {1,1}, {-1,1}};
  static POINT2D bot[3] = {{1,-1}, {-1,-1}, {-1,1}};
  POINT2D *adj;

  if (ends[1].x == ends[0].x)
       adj = top;
  else adj = bot;

  pi = 0;
  li = 0;
  while (li < lines)
  {
    for (j=0; j<3; j++)
    {
      pts[pi].x = ends[j].x + (li * adj[j].x);
      pts[pi].y = ends[j].y + (li * adj[j].y);
      ++pi;
    }
    if ((lines & 1) == 0)  // odd
    {
      ++li;
      for (j=2; j>=0; j--)
      {
        pts[pi].x = ends[j].x + (li * adj[j].x);
        pts[pi].y = ends[j].y + (li * adj[j].y);
        ++pi;
      }
    }
    ++li;
  }
  return pi;
}
#endif

/*---------------------------------------------------------------------------
  PaintIcon - Paints the Icon in the property sheet.
|---------------------------------------------------------------------------*/
static int PaintIcon(HWND hWnd)
{
//   int status;
   HBITMAP      hBitMap;
   HGDIOBJ      hGdiObj;
   HDC          hDC, hMemDC ;
   PAINTSTRUCT  ps ;
   RECT spot, main;  // left, top, right, bottom

  GetWindowRect(GetDlgItem(hWnd, IDB_HELP), &spot);
  GetWindowRect(hWnd, &main);
#ifdef COMMENT_OUT
  rect = &right;
  mess("hlp r:%d l:%d b:%d t:%d",
       rect->right, rect->left, rect->bottom, rect->top);
#endif
  spot.left -= main.left;
  spot.top -= main.top;

  spot.left += 5;
  spot.top  += 20; // spacing

   // load bitmap and display it

   hDC = BeginPaint( hWnd, &ps ) ;
   if (NULL != (hMemDC = CreateCompatibleDC( hDC )))
   {
      hBitMap = LoadBitmap(glob_hinst,
                           MAKEINTRESOURCE(BMP_SMALL_LOGO));

      hGdiObj = SelectObject(hMemDC, hBitMap);

      BitBlt( hDC, spot.left, spot.top, 100, 100, hMemDC, 0, 0, SRCCOPY ) ;
      //StretchBlt( hDC, 5, 5, 600,100, hMemDC, 0, 0, 446, 85, SRCCOPY ) ;
      DeleteObject( SelectObject( hMemDC, hGdiObj ) ) ;
      DeleteDC( hMemDC ) ;
   }
   EndPaint( hWnd, &ps ) ;
 return 0;
}

/*---------------------------------------------------------------------------
  PaintLogo - Paints the logo bitmap in the device property sheet
|---------------------------------------------------------------------------*/
static int PaintLogo(HWND hWnd)
{
   HBITMAP      hBitMap;
   HGDIOBJ      hGdiObj;
   HDC          hDC, hMemDC;
   PAINTSTRUCT  ps;
   BITMAP       bm;
   RECT         r;
   POINT        pt;

   // load bitmap and display it
   hDC = BeginPaint( hWnd, &ps ) ;
   GetClientRect(hWnd, &r);
   if (NULL != (hMemDC = CreateCompatibleDC( hDC )))
   {
#ifdef S_RK
      if (wi->dev[glob_info->device_selected].ModemDevice == TYPE_RM_VS2000)
        hBitMap = LoadBitmap(glob_hinst, MAKEINTRESOURCE(BMP_RKTMODEM_LOGO));
      else if (wi->dev[glob_info->device_selected].ModemDevice == TYPE_RMII)
        hBitMap = LoadBitmap(glob_hinst, MAKEINTRESOURCE(BMP_RKTMODEMII_LOGO));
      else if (wi->dev[glob_info->device_selected].ModemDevice == TYPE_RM_i)
        hBitMap = LoadBitmap(glob_hinst, MAKEINTRESOURCE(BMP_RKTMODEM_INTL_LOGO));
      else
        hBitMap = LoadBitmap(glob_hinst, MAKEINTRESOURCE(BMP_RKTPORT_LOGO));
#else
      if (wi->dev[glob_info->device_selected].HubDevice == 1)
        hBitMap = LoadBitmap(glob_hinst, MAKEINTRESOURCE(BMP_RKTHUB_LOGO));
      else
        hBitMap = LoadBitmap(glob_hinst, MAKEINTRESOURCE(BMP_VS_FULL_LOGO));
#endif

      hGdiObj = SelectObject(hMemDC, hBitMap);
      GetObject(hBitMap, sizeof(BITMAP), (PSTR) &bm);
      pt.x = r.right - r.left + 1;
      pt.y = r.bottom - r.top + 1;
      StretchBlt( hDC, 0, 0, pt.x, pt.y, hMemDC, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY );
      DeleteObject( SelectObject( hMemDC, hGdiObj ) ) ;
      DeleteDC( hMemDC ) ;
   }
   EndPaint( hWnd, &ps ) ;
 return 0;
}

#ifdef S_VS
/*------------------------------------------------------------------------
 StatusPropSheet -
  dialogue window procedure for add-on device status sheet...
|------------------------------------------------------------------------*/
BOOL WINAPI 
StatusPropSheet(
  IN HWND   hDlg,
    IN UINT   uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
  OUR_INFO *OurProps;
  WORD  uCmd;
  
  OurProps = (OUR_INFO *)GetWindowLong(hDlg,DWL_USER);

  switch (uMessage) {

    case WM_INITDIALOG: {

      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;

      SetWindowLong(hDlg,DWL_USER,(LONG)OurProps);

      return TRUE;
    }
    case WM_COMMAND: {
      uCmd = HIWORD(wParam);

      switch (LOWORD(wParam)) {

        //check for reset button pushed...
        case IDB_STAT_RESET: { 
            
          build_advisor_display(hDlg,&glob_dstatus,1);

          return(TRUE);
        }

        //check for refresh button pushed...
        case IDB_REFRESH: { 

          build_advisor_display(hDlg,&glob_dstatus,0);

          return(TRUE);
        }
      }
      return FALSE;
    } 
    case WM_PAINT: {

      PaintIcon(hDlg);

      return FALSE;
    }
    case WM_HELP: {

      our_context_help(lParam);

      return FALSE;
    }
    case WM_NOTIFY : {

      switch (((NMHDR *)lParam)->code){
        case PSN_HELP : {
          our_help(&wi->ip, IDD_STATUS);
          break;
        }

        case PSN_SETACTIVE : {
          build_advisor_display(hDlg,&glob_dstatus,0);
          return TRUE;
        }
        default : {
          return FALSE;
        }
      }
      break;
    }
    default : {
      return FALSE;
    }
  }
}

/*------------------------------------------------------------------------
  build_advisor_display -
|------------------------------------------------------------------------*/
static void build_advisor_display(HWND hDlg,DSTATUS *pDstatus,int reset)
{
  int nBytes;
  int do_ping;

  get_status(pDstatus,reset);

  if ((pDstatus->vsl_device_status_found) &&
      (pDstatus->calc_dev.state == VSL_STATE_ACTIVE))
  {
    // no need for ping, since our driver is not configured for
    // the mac address we think it is, or our driver says it is
    // running like a champ.
    do_ping = 0;
  }
  else
  {
    // the device is inactive, so do ping, see if we can see it on
    // network.
    do_ping = 1;
  }

  if (do_ping)
  {
    // ping returns -1 if bad, 0 if MAC not found, 1 if found...
    ping_devices(pDstatus, &nBytes);
  }

  set_status_field(hDlg,IDC_ST_PM_LOADS,pDstatus);
  set_status_field(hDlg,IDC_ST_STATE,pDstatus);
  set_status_field(hDlg,IDC_ST_NIC_DVC_NAME,pDstatus);
  set_status_field(hDlg,IDC_ST_NIC_MAC,pDstatus);
  set_status_field(hDlg,IDC_ST_NIC_PKT_SENT,pDstatus);
  set_status_field(hDlg,IDC_ST_NIC_PKT_RCVD_OURS,pDstatus);
  set_status_field(hDlg,IDC_ST_NIC_PKT_RCVD_NOT_OURS,pDstatus);

  set_status_field(hDlg,IDC_ST_VSL_MAC,pDstatus);
  set_status_field(hDlg,IDC_ST_VSL_DETECTED,pDstatus);
  set_status_field(hDlg,IDC_ST_VSL_STATE,pDstatus);
  set_status_field(hDlg,IDC_ST_VSL_IFRAMES_SENT,pDstatus);
  set_status_field(hDlg,IDC_ST_VSL_IFRAMES_RCVD,pDstatus);
  set_status_field(hDlg,IDC_ST_VSL_IFRAMES_RESENT,pDstatus);
  set_status_field(hDlg,IDC_ST_VSL_IFRAMES_OUTOFSEQ,pDstatus);
}

/*------------------------------------------------------------------------
  set_status_field -
|------------------------------------------------------------------------*/
static void 
set_status_field(HWND hDlg,WORD id,DSTATUS *pDstatus)
{
  char  tmpstr[100];
  Device_Config *vs;
  unsigned int  total;
  PROBE_NIC_STRUCT *d_nic    = &pDstatus->calc_nic;
  PROBE_DEVICE_STRUCT *d_dev = &pDstatus->calc_dev;

  tmpstr[0] = 0;
  vs = &wi->dev[glob_info->device_selected];
  switch(id) {

    case IDC_EB_NAME:
      SetDlgItemText(hDlg,id,vs->Name);
    break;

    case IDC_ST_STATE:
      SetDlgItemText(
        hDlg,
        id,
        (LPCTSTR)(AdvisoryString[pDstatus->verbose_advise_state]));
    break;

    case IDC_ST_NIC_DVC_NAME:
      if (pDstatus->vsl_nic_status_found)  // 1=driver found nic status.
        strcpy(tmpstr,d_nic->NicName);
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_NIC_MAC:
      if (pDstatus->vsl_nic_status_found)  // 1=driver found nic status.
        format_mac_addr(tmpstr, d_nic->address);
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_VSL_MAC:
      format_mac_addr(tmpstr, vs->MacAddr);
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_VSL_DETECTED:
      if (pDstatus->vsl_mac_list_found)
      {
        wsprintf(tmpstr,
           "%d/%d",
           pDstatus->vsl_detected,
           pDstatus->vsl_available);
      }
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_VSL_STATE:
      if (pDstatus->vsl_device_status_found)  // 1=driver found matching VS config.
      {
        if (d_dev->state < 5)
          strcpy(tmpstr, vslink_state_table[d_dev->state]);
      }
      else
      {
        // indicate to the user that our mac-address has not been
        // saved off and transferred to the driver
        strcpy(tmpstr, "Not Configured");
      }

      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_VSL_IFRAMES_SENT:
      if (pDstatus->vsl_device_status_found)  // 1=driver found matching VS config.
      {
        //count = 0;
        total = d_dev->iframes_sent;
        total += d_dev->ctlframes_sent;
        wsprintf(tmpstr,"%d",total);
      }
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_VSL_IFRAMES_RESENT:
      if (pDstatus->vsl_device_status_found)  // 1=driver found matching VS config.
      {
        wsprintf(tmpstr,"%d",d_dev->iframes_resent);
      }
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_VSL_IFRAMES_RCVD:
      if (pDstatus->vsl_device_status_found)  // 1=driver found matching VS config.
      {
        wsprintf(tmpstr,"%d",d_dev->frames_rcvd);
      }
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_VSL_IFRAMES_OUTOFSEQ:
      if (pDstatus->vsl_device_status_found)  // 1=driver found matching VS config.
      {
        wsprintf(tmpstr,"%d",d_dev->iframes_outofseq);
      }
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_NIC_PKT_SENT:
      if (pDstatus->vsl_nic_status_found)  // 1=driver found nic status.
        wsprintf(tmpstr,"%d",d_nic->pkt_sent);
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_NIC_PKT_RCVD_OURS:
      if (pDstatus->vsl_nic_status_found)  // 1=driver found nic status.
        wsprintf(tmpstr,"%d",d_nic->pkt_rcvd_ours);
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_NIC_PKT_RCVD_NOT_OURS:
      if (pDstatus->vsl_nic_status_found)  // 1=driver found nic status.
        wsprintf(tmpstr,"%d",d_nic->pkt_rcvd_not_ours);
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_PM_LOADS:
      tmpstr[0] = 0;
      if (pDstatus->vsl_device_status_found)  // 1=driver found matching VS config.
      {
        wsprintf(tmpstr, "%d/%d",
           d_dev->good_loads,
           d_dev->total_loads);
      }
      SetDlgItemText(hDlg,id,tmpstr);
    break;
  }  // end of switch
}  // end proc

#define  IOCTL_STAT_BUFSIZE  500
/*------------------------------------------------------------------------
  get_status - query the driver for device network statistics and
    associated nic card network statistics.  These stats are kept
    as overflow/wrapping DWORD counters in driver, we do some math
    on current and previous values read to determine calculated values.
|------------------------------------------------------------------------*/
static void get_status(DSTATUS *pDstatus,int reset)
{
  Device_Config *vs;
  PROBE_NIC_STRUCT    *curr_nic = &pDstatus->curr_nic;
  PROBE_NIC_STRUCT    *prev_nic = &pDstatus->prev_nic;
  PROBE_NIC_STRUCT    *calc_nic = &pDstatus->calc_nic;
  PROBE_NIC_STRUCT    *temp_nic = &pDstatus->temp_nic;

  PROBE_DEVICE_STRUCT *curr_dev = &pDstatus->curr_dev;
  PROBE_DEVICE_STRUCT *prev_dev = &pDstatus->prev_dev;
  PROBE_DEVICE_STRUCT *calc_dev = &pDstatus->calc_dev;
  PROBE_DEVICE_STRUCT *temp_dev = &pDstatus->temp_dev;
  int    rc;
  BYTE  *pIoctlStatusBuf,
      *pNicStatBuf;
  IoctlSetup  ioctl_setup;
  int    product_id;

DbgPrintf(D_Level,(TEXT("get_status\n")));

  product_id = NT_VS1000;
  vs = &wi->dev[glob_info->device_selected];

  STATE_CHANGE(STATE_not_init);

     //open path for ioctl to retrieve device status list. make sure path
     //exists first...
  memset(&ioctl_setup,0,sizeof(IoctlSetup));

  rc = ioctl_open(&ioctl_setup,product_id); 

  if (rc != 0)
  { 
    pDstatus->vsl_driver_found = 0;  // 1=we can talk to driver, 0=driver not loaded
    pDstatus->vsl_device_status_found = 0;  // 1=driver found matching VS config.
    pDstatus->vsl_nic_status_found = 0;  // 1=driver found nic status.
    DbgPrintf(D_Error,(TEXT("Err1A\n")));
    //error. could not talk to driver. bail...
    STATE_CHANGE(STATE_driver_not_avail);
    return;   
  }

  //alloc space for all NIC and VSlink status reports...
  pIoctlStatusBuf = calloc(1,IOCTL_STAT_BUFSIZE);
  memset(pIoctlStatusBuf,0,IOCTL_STAT_BUFSIZE);

  pNicStatBuf = &pIoctlStatusBuf[sizeof(PortMonBase)];

    // tell the driver which device we want to query by sending
    // the mac-address as the id.
  memcpy(pNicStatBuf,vs->MacAddr,sizeof(vs->MacAddr));

    //see if we need to signal driver to reset statistics...
    // no, don't reset the driver statistics!
  pNicStatBuf[sizeof(vs->MacAddr)] = 0;
    //pNicStatBuf[sizeof(vs->MacAddr)] = (reset) ? 1 : 0;

  //adjust size of status buffer down by length of ioctl control block...
  ioctl_setup.buf_size = IOCTL_STAT_BUFSIZE;

  //store --> to status buffer into ioctl control block...
  ioctl_setup.pm_base = (PortMonBase *) pIoctlStatusBuf;
  ioctl_setup.pm_base->struct_type = IOCTL_DEVICESTAT;
  ioctl_setup.pm_base->struct_size = IOCTL_STAT_BUFSIZE - sizeof(PortMonBase);
  ioctl_setup.pm_base->num_structs = 0;
  ioctl_setup.pm_base->var1 = 0;

    // update prev_dev to curr_dev before getting new values
  memcpy(prev_dev, curr_dev, sizeof(*prev_dev));

  rc = ioctl_call(&ioctl_setup);  // get device status

  if (rc) {
    pDstatus->vsl_device_status_found = 0;  // 1=driver found matching VS config.
    DbgPrintf(D_Test, ("probe, dev not found\n"))
    ioctl_close(&ioctl_setup);
    DbgPrintf(D_Error,(TEXT("Err1B\n")));
    memset(calc_nic, 0, sizeof(curr_nic));
    //STATE_CHANGE(STATE_driver_not_avail);
    STATE_CHANGE(STATE_not_configured);
    free(pIoctlStatusBuf);
    return;  // failed ioctl call
  }
  pDstatus->vsl_device_status_found = 1;  // 1=driver found matching VS config.
  DbgPrintf(D_Test, ("probe, dev found\n"))

    // copy over our new device info
  memcpy(curr_dev, pNicStatBuf, sizeof(*curr_dev));
  if (curr_dev->struct_size != sizeof(*curr_dev))
  {
    DbgPrintf(D_Level, (TEXT("dev bad size:%d\n"), curr_dev->struct_size));
  }

    // save calculated values temporarily in temp_dev
  memcpy(temp_dev, calc_dev, sizeof(*temp_dev));
    // update calc_dev from curr_dev, just copy over
  memcpy(calc_dev, curr_dev, sizeof(*calc_dev));

    // use a current and previous reading to measure the advance, or
    // calculated value which is put in calc value.
  NORM_COUNTER(calc_dev->iframes_sent, curr_dev->iframes_sent,
               prev_dev->iframes_sent, temp_dev->iframes_sent);
  NORM_COUNTER(calc_dev->ctlframes_sent, curr_dev->ctlframes_sent,
               prev_dev->ctlframes_sent, temp_dev->ctlframes_sent);
  NORM_COUNTER(calc_dev->rawframes_sent, curr_dev->rawframes_sent,
               prev_dev->rawframes_sent, temp_dev->rawframes_sent);
  NORM_COUNTER(calc_dev->iframes_resent, curr_dev->iframes_resent,
               prev_dev->iframes_resent, temp_dev->iframes_resent);
  NORM_COUNTER(calc_dev->frames_rcvd, curr_dev->frames_rcvd,
               prev_dev->frames_rcvd, temp_dev->frames_rcvd);
  NORM_COUNTER(calc_dev->iframes_outofseq, curr_dev->iframes_outofseq,
               prev_dev->iframes_outofseq, temp_dev->iframes_outofseq);

  DbgPrintf(D_Level, (TEXT("iframes_sent - ca:%d cu:%d pr:%d te:%d\n"),
                       calc_dev->iframes_sent, curr_dev->iframes_sent,
                       prev_dev->iframes_sent, temp_dev->iframes_sent));

  DbgPrintf(D_Level, (TEXT("iframes_sent - ca:%d cu:%d pr:%d te:%d\n"),
                   calc_dev->ctlframes_sent, curr_dev->ctlframes_sent,
                   prev_dev->ctlframes_sent, temp_dev->ctlframes_sent));

  DbgPrintf(D_Level, (TEXT("frames_rcvd - ca:%d cu:%d pr:%d te:%d\n"),
                   calc_dev->frames_rcvd, curr_dev->frames_rcvd,
                   prev_dev->frames_rcvd, temp_dev->frames_rcvd));

  if (curr_dev->nic_index != 0)
  {
    DbgPrintf(D_Level, (TEXT("nic index:%d\n"), curr_dev->nic_index));
  }

    // tell driver which nic card we want to probe info on
  *((BYTE *)pNicStatBuf) = (BYTE) curr_dev->nic_index;
  *((BYTE *)pNicStatBuf+1) = 0;
  ioctl_setup.pm_base->struct_type = IOCTL_NICSTAT;
  ioctl_setup.pm_base->struct_size = IOCTL_STAT_BUFSIZE - sizeof(PortMonBase);
  ioctl_setup.pm_base->num_structs = 0;

    // update prev_dev to curr_dev before calculation
  memcpy(prev_nic, curr_nic, sizeof(*prev_nic));

  rc = ioctl_call(&ioctl_setup);  // get NIC and board status...

  if (rc) {
    pDstatus->vsl_nic_status_found = 0;  // 1=driver found nic status.
    ioctl_close(&ioctl_setup);
    DbgPrintf(D_Error, (TEXT("nic not avail\n")));
    STATE_CHANGE(STATE_nic_not_avail);
    free(pIoctlStatusBuf);
    return;  // failed ioctl call
  }
  pDstatus->vsl_nic_status_found = 1;  // 1=driver found nic status.

    // copy over our new device info
  memcpy(curr_nic, pNicStatBuf, sizeof(*curr_nic));
  if (curr_nic->struct_size != sizeof(*curr_nic))
  {
    DbgPrintf(D_Error, (TEXT("nic bad size:%d\n"), curr_nic->struct_size));
  }

    // save calculated values temporarily in temp_nic
  memcpy(temp_nic, calc_nic, sizeof(*temp_nic));
    // update calc_nic from curr_dev
  memcpy(calc_nic, curr_nic, sizeof(*calc_nic));

    // use a current and previous reading to measure the advance, or
    // calculated value which is put in calc value.
  NORM_COUNTER(calc_nic->pkt_sent, curr_nic->pkt_sent,
               prev_nic->pkt_sent, temp_nic->pkt_sent);
  NORM_COUNTER(calc_nic->pkt_rcvd_ours, curr_nic->pkt_rcvd_ours,
               prev_nic->pkt_rcvd_ours, temp_nic->pkt_rcvd_ours);
  NORM_COUNTER(calc_nic->pkt_rcvd_not_ours, curr_nic->pkt_rcvd_not_ours,
               prev_nic->pkt_rcvd_not_ours, temp_nic->pkt_rcvd_not_ours);

  DbgPrintf(D_Level, (TEXT("pkt_sent - ca:%d cu:%d pr:%d te:%d\n"),
                 calc_nic->pkt_sent, curr_nic->pkt_sent,
                 prev_nic->pkt_sent, temp_nic->pkt_sent));
  DbgPrintf(D_Level, (TEXT("pkt_rcvd_ours - ca:%d cu:%d pr:%d te:%d\n"),
                 calc_nic->pkt_rcvd_ours, curr_nic->pkt_rcvd_ours,
                 prev_nic->pkt_rcvd_ours, temp_nic->pkt_rcvd_ours));
  DbgPrintf(D_Level, (TEXT("pkt_rcvd_not_ours - ca:%d cu:%d pr:%d te:%d\n"),
                 calc_nic->pkt_rcvd_not_ours, curr_nic->pkt_rcvd_not_ours,
                 prev_nic->pkt_rcvd_not_ours, temp_nic->pkt_rcvd_not_ours));

  if (reset) {
    DbgPrintf(D_Level, (TEXT("Reset NicStats\n")));
    calc_dev->iframes_sent = 0;
    calc_dev->ctlframes_sent = 0;
    calc_dev->rawframes_sent = 0;
    calc_dev->iframes_resent = 0;
    calc_dev->frames_rcvd = 0;
    calc_dev->iframes_outofseq = 0;

    calc_nic->pkt_sent = 0;
    calc_nic->pkt_rcvd_ours = 0;
    calc_nic->pkt_rcvd_not_ours = 0;

    ioctl_close(&ioctl_setup);
    STATE_CHANGE(STATE_reset);
    free(pIoctlStatusBuf);
    return;
  }

    //check state of NIC card...
  if (!pDstatus->curr_nic.Open)
  {
    ioctl_close(&ioctl_setup);
    DbgPrintf(D_Level, (TEXT("Nic Not Open\n")));
    memset(calc_nic, 0, sizeof(curr_nic));
    STATE_CHANGE(STATE_nic_not_avail);
    //STATE_CHANGE(STATE_network_not_avail);
    free(pIoctlStatusBuf);
    return;
  }

  switch (curr_dev->state)
  {
    case VSL_STATE_INIT:
      if (pDstatus->vsl_detected) // if some devices found in ping mac list
      {
        if (pDstatus->vsl_ping_device_found)  // if our mac found in pinged list
        {
          if ((pDstatus->vsl_load_status & FLAG_NOT_OWNER) == FLAG_NOT_OWNER) {
            STATE_CHANGE(STATE_not_owner);
          }
          else if ((pDstatus->vsl_load_status & FLAG_APPL_RUNNING) == 0) {
            STATE_CHANGE(STATE_vslink_not_ready);
          }
        }
        else  // not found in list
        {
          STATE_CHANGE(STATE_vslink_not_avail);
        }
      }
      else  // none found in ping
      {
        STATE_CHANGE(STATE_no_vslinks_avail);
      }
    break;

    case VSL_STATE_ACTIVE:
      STATE_CHANGE(STATE_ok_no_traffic);
      check_traffic_activity(pDstatus);
    break; // end of state_active

    case VSL_STATE_INITOWN: 
    case VSL_STATE_SENDCODE: 
    case VSL_STATE_CONNECT:
    default:
      STATE_CHANGE(STATE_vslink_not_ready);
    break;
  } // end of switch on state

  ioctl_close(&ioctl_setup);
  free(pIoctlStatusBuf);

  DbgPrintf(D_Level, (TEXT("get_status done\n")));
  return;
}

/*------------------------------------------------------------------------
  check_traffic_activity -
    check activity on NIC, network, & VS-Link device...
|------------------------------------------------------------------------*/
static void check_traffic_activity(DSTATUS *pDstatus)
{ 
   PROBE_NIC_STRUCT    *curr_nic = &pDstatus->curr_nic;
   PROBE_NIC_STRUCT    *prev_nic = &pDstatus->prev_nic;
   PROBE_NIC_STRUCT    *calc_nic = &pDstatus->calc_nic;
   PROBE_DEVICE_STRUCT *curr_dev = &pDstatus->curr_dev;
   PROBE_DEVICE_STRUCT *prev_dev = &pDstatus->prev_dev;
   PROBE_DEVICE_STRUCT *calc_dev = &pDstatus->calc_dev;

   ULONG percent_dropped;

   // don't divide by zero
   if ((curr_dev->iframes_outofseq + curr_dev->frames_rcvd) > 0)
     percent_dropped = ((curr_dev->iframes_outofseq * 100) / 
             (curr_dev->iframes_outofseq + curr_dev->frames_rcvd) > 2);
   else
     percent_dropped = 0;

  /*
  iframes_sent are hdlc protocol data packets;
  ctlframes_sent are hdlc protocol control packets;
  rawframes_sent are write remote, read trace query, go, and upload 
    binary command packets;
  iframes_resent are data packets retransmitted.
  iframes_outofseq are data packets received out of order.
  */

  DbgPrintf(D_Level, (TEXT("Check Traffic\n")));

  if ((curr_dev->iframes_sent + curr_dev->ctlframes_sent) ==
      (prev_dev->iframes_sent + prev_dev->ctlframes_sent)) { 
    // no sent packets to the higher levels in the VS-Link recently...
    STATE_CHANGE(STATE_ok_no_traffic);

    // no send traffic - see if we've any recent receive traffic for
    // delivery to higher levels...
    if (curr_dev->frames_rcvd == prev_dev->frames_rcvd)  
      STATE_CHANGE(STATE_ok_no_traffic);
  }
  else if (curr_dev->frames_rcvd == prev_dev->frames_rcvd) { 
    // we've recently received any VS-Link packets for delivery to higher levels...
    STATE_CHANGE(STATE_ok_no_traffic);
  }
  else {
    //connection appears ok so far. dig in deeper...
    STATE_CHANGE(STATE_ok);
  }

  DbgPrintf(D_Level, (TEXT("Check Traffic 2\n")));

  //evaluate link integrity. see if we're retransmitting packets to this
  //VS-Link...
  if (curr_dev->iframes_resent != prev_dev->iframes_resent) {
    STATE_CHANGE(STATE_poor_link);
  }
  else if ((curr_nic->pkt_rcvd_not_ours != prev_nic->pkt_rcvd_not_ours) &&
           (curr_nic->pkt_rcvd_ours == prev_nic->pkt_rcvd_ours)) {
    // all we're getting are packets that we're passing onto some 
    //other driver. we should be getting responses from the VS-Links...
    STATE_CHANGE(STATE_poor_link);
  }
  else if (curr_dev->iframes_outofseq != prev_dev->iframes_outofseq) { 
    // we've received VS-Link packets out-of-sequence since last click...
    STATE_CHANGE(STATE_poor_link);
  }
  else if ((curr_dev->iframes_outofseq) &&
           (percent_dropped > 0)) {
    // received 2% or more of VS-Link packets out-of-sequence (value per BF)...
    STATE_CHANGE(STATE_poor_link);
  }
  DbgPrintf(D_Level, (TEXT("Check Traffic Done\n")));
}

/*------------------------------------------------------------------------
 ping_devices -
  ping for all active VS-Link devices, collect info for device advisor.
  Return NULL or to list of mac-addresses.
|------------------------------------------------------------------------*/
static BYTE *ping_devices(DSTATUS *pDstatus, int *nBytes)
{
  Device_Config *vs;
  int    rc,
      nbytes;
  BYTE  *MacBuf;
  int    product_id;
  int    index;
  DRIVER_MAC_STATUS  *pMacStatus;

  product_id = NT_VS1000;
  pDstatus->vsl_ping_device_found = 0;

  DbgPrintf(D_Level, (TEXT("Ping Devices\n")));

  vs = &wi->dev[glob_info->device_selected];

  MacBuf = our_get_ping_list(&rc, &nbytes);
  pMacStatus = (DRIVER_MAC_STATUS  *) MacBuf;
  if (rc) {
    nbytes = 0;
    *nBytes = 0;
    pDstatus->vsl_mac_list_found = 0;
    DbgPrintf(D_Error, (TEXT("Err Mac List1\n")));
    return NULL;  // failed ioctl call
  }

  //are there any VS-Link MAC addresses out on the network?...
  pDstatus->vsl_available  = 0;
  pDstatus->vsl_load_status = 0;
  pDstatus->vsl_detected = (nbytes / sizeof(DRIVER_MAC_STATUS));
  pDstatus->vsl_mac_list_found = 1;

  rc = 0;

  if ((nbytes / sizeof(DRIVER_MAC_STATUS)) == 0) {
    DbgPrintf(D_Level, (TEXT("Zero Mac List\n")));
    *nBytes = 0;
    return NULL;  // failed ioctl call
  }

  *nBytes = nbytes;  // return number of bytes of mac list read

  // ok; is our target one of them?...
  for (index = 0; 
       index < (nbytes / (int)sizeof(DRIVER_MAC_STATUS)); 
       index++)
  {
      // generate count of available VS-Links for loading at this time...
    if ( ((pMacStatus->flags & FLAG_APPL_RUNNING) == 0) ||
         (pMacStatus->flags & FLAG_OWNER_TIMEOUT) )         
      ++pDstatus->vsl_available;

      //target MAC matches?...
    if (mac_match(pMacStatus->mac,vs->MacAddr))
    {
      //ok; save its load status...
      pDstatus->vsl_load_status = pMacStatus->flags;
      pDstatus->vsl_ping_device_found = 1;
      rc = 1;
    }
      ++pMacStatus;
  }  // end of for loop

  return MacBuf;
}
#endif

/*------------------------------------------------------------------------
 format_mac_addr -
|------------------------------------------------------------------------*/
void format_mac_addr(char *outstr, unsigned char *address)
{
  wsprintf(outstr,
         "%02X %02X %02X %02X %02X %02X",
         address[0],
         address[1],
         address[2],
         address[3],
         address[4],
         address[5]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\driprop.h ===
// driprop.h

BOOL WINAPI AdvDriverSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\nt40.c ===
/*------------------------------------------------------------------------
| nt40.c - nt4.0 non-pnp setup.exe code - WinMain, etc.
12-11-98 - use szAppTitle(.rc str) instead of aptitle for prop sheet title.
|------------------------------------------------------------------------*/
#include "precomp.h"

/*----------------------- local vars ---------------------------------*/
static int unattended_flag = 0;
static int test_mode = 0;
static HMENU hMenuMain;

int do_progman_add = 0;

static int auto_install(void);

// for nt4.0, we are a .EXE, so we need a WinMain...
/*------------------------------------------------------------------------
| WinMain - Main program entry for NT4.0 EXE setup program.
|------------------------------------------------------------------------*/
int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
				   LPSTR lpCmdLine, int nCmdShow)
{
  MSG      msg;
  WNDCLASS  wc;
  HWND hwnd;
  HACCEL  hAccel;
  char *buf;
  int i, stat;


#if DBG
   DebugLevel |= (D_Test | D_Error) ;
#endif

   glob_hinst = hInstance;  // ptr to dll hinstance

   if (hPrevInstance)	// Other instances of app running?
   {
     MessageBox(0,"Program is already running!","",MB_OK);
     return 0;
   }

  InitCommonControls();   // Initialize the common control library.

  if (setup_init())
  {
     return 0;
  } 


  buf = lpCmdLine;
  i=0;
  while ((*buf != 0) && (i < 80))
  {
    if ((*buf == '-') || (*buf == '/'))
    {
      ++buf;
      ++i;
      switch(toupper(*buf++))
      {
        case 'A':  // auto-install
          unattended_flag = 1;
        break;
        //return stat;

        case 'H':  // help
          our_help(&wi->ip, WIN_NT);
        return 0;

        case 'P':  // add program manager group
          do_progman_add = 1;  // add progman group
        break;

        case 'N':
          wi->install_style = INS_SIMPLE;  // default to original nt4.0 style
        break;

        case 'R':  // remove driver and files
          //        stat = our_message(&wi->ip,
          //"Would you like this setup program to remove this driver and related files?",
          // MB_YESNO);
          //  if (stat == IDYES)
          if (toupper(*buf)  == 'A')
            remove_driver(1);
          else
            remove_driver(0);
        return 0;

        case 'T':  // test mode, run only to test ui
          test_mode = 1;
        break;
        case 'Z':  // test mode, run only to test
          if (toupper(*buf)  == 'I')
            setup_service(OUR_INSTALL_START, OUR_SERVICE);  // do a remove on the service
          else
            setup_service(OUR_REMOVE, OUR_SERVICE);  // do a remove on the service
        return 0;

        case '?':  // our help
                  stat = our_message(&wi->ip,
"options>SETUP /options\n \
  A - auto install routine\n \
  P - add  program manager group\n \
  N - no inf file, simple install\n \
  H - display driver help info\n \
  R - remove driver(should do from control-panel first)",
 MB_OK);
        return 0;

      }  // switch
    }  // if (option)
    ++i;
    ++buf;
  }  // while options

   if (unattended_flag)
   {
     unattended_add_port_entries(&wi->ip,
                                 8, // num_entries
                                 5); // start_port:com5
     stat = auto_install();
     return stat;
   }

   if (!hPrevInstance)	// Other instances of app running?
   {
     // MAIN WINDOW
     wc.style       = CS_HREDRAW | CS_VREDRAW;	// Class style(s).
     wc.lpfnWndProc = MainWndProc;
     wc.cbClsExtra  = 0;	// No per-class extra data.
     wc.cbWndExtra  = 0;	// No per-window extra data.
     wc.hInstance   = hInstance;	// Application that owns the class.
     wc.hIcon       = LoadIcon(hInstance, "SETUPICON");
     wc.hCursor     = LoadCursor(NULL, IDC_ARROW);
     wc.hbrBackground = (HBRUSH) (COLOR_APPWORKSPACE + 1);
     wc.lpszMenuName  = NULL;  // Name of menu resource in .RC file.
     wc.lpszClassName = szAppName; // Name used in call to CreateWindow.
     RegisterClass(&wc);
   }
   hMenuMain = LoadMenu (glob_hinst, "MAIN_MENU");

   hAccel = LoadAccelerators (glob_hinst, "SetupAccel") ;

	/* Create a main window for this application instance.  */
   hwnd = CreateWindowEx(
                WS_EX_CONTEXTHELP,  // gives question mark help thing
		szAppName,          // See RegisterClass() call.
                                   // Text for window title bar.
                 szAppTitle,
    WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_CLIPCHILDREN,
//                 WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,  // Window style.
//                 CW_USEDEFAULT, CW_USEDEFAULT, // Def. horz, vert pos.
                 0,0, // Def. horz, vert pos.
                 300, 200, // Default width, height
//                 455, 435, // Default width, height
                 NULL,      // No Parent Window
                 hMenuMain,     // Use the window class menu.
                 hInstance, // This instance owns this window.
                 NULL);     // Pointer not needed.

   //ShowWindow (hwnd, nCmdShow);
   //UpdateWindow (hwnd);

             // Enter the modified message loop
  while (GetMessage(&msg, NULL, 0, 0))
  {
    if (!TranslateAccelerator (hwnd, hAccel, &msg))
    {
      if (glob_hDlg == 0 || !IsDialogMessage(glob_hDlg, &msg))
      {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
      }
    }
  }
  return msg.wParam;
}

/*------------------------------------------------------------------------
| MainWndProc - Main Window Proc.
|------------------------------------------------------------------------*/
LRESULT FAR PASCAL MainWndProc(HWND hwnd, UINT message,
						WPARAM wParam, LPARAM lParam)
{
 HDC hdc;
 PAINTSTRUCT ps;
 int stat;
 int QuitFlag = 0;

  switch (message)
  {
    case WM_CREATE: // Initialize Global vars

      glob_hwnd = hwnd;

      wi->NumDevices = 0;

      get_nt_config(wi); // Read the configuration information from the registry.
      copy_setup_init();  // make a copy of config data for change detection

      validate_config(1);  // validate and auto-fixup if config hosed

      // src_dir should always equal dest_dir since
      // INF copies files over files in NT.  Otherwise they
      // are running setup.exe before doing network install
      if (my_lstricmp(wi->ip.src_dir, wi->ip.dest_dir) != 0)
      {
        if (wi->ip.major_ver < 5)  // NT5.0 does not support 4.0 network inf files
        {
          if (wi->install_style != INS_SIMPLE)
          {
            // if they didn't explicitly ask for a non-adapter install
            // then: ask them(if allowed), or tell them about the control
            // panel/network to install correctly.
#ifdef ALLOW_NON_NET_INSTALL
            stat = our_message(&wi->ip,
              "Would you like to install this software?",
              MB_YESNO);

            if (stat != IDYES)
            {
              stat = our_message(&wi->ip,
"Would you like to view the help information?",MB_YESNO);
              if (stat == IDYES)
                our_help(&wi->ip, WIN_NT);
              QuitFlag = 1;
              PostQuitMessage(0);  // end the setup program.
            }
            wi->install_style = INS_SIMPLE;  // non-network adapter install
            do_progman_add = 1;   // force full install
#else
            if (!test_mode)  // test mode to allow us to continue(for programmers)
            {
              stat = our_message(&wi->ip,
"The software should be added as a network adapter in the control panel. \
Would you like to view the help information?",MB_YESNO);
              if (stat == IDYES)
                our_help(&wi->ip, WIN_NT);
              QuitFlag = 1;
              PostQuitMessage(0);  // end the setup program.
            }
#endif
          }
        }  // not nt5.0 or above

        if (wi->nt_reg_flags & 1)  // not installed(missing important reg entries)
        {
          wi->install_style = INS_SIMPLE;
          // do full install since we are not running out of cur dir.
          do_progman_add = 1; 
        }
        else  // is installed, but running setup somewhere besides rocket dir
        {
          // just update the thing.
          wi->install_style = INS_SIMPLE;
          // do full install since we are not running out of cur dir.
          do_progman_add = 1; 
        }
      }

      // if registry not setup correctly, and not asking for a simple
      // install, then tell them the registry is screwed up.
      if ( (wi->nt_reg_flags & 1) && (!(wi->install_style == INS_SIMPLE)))
      {
        stat = our_message(&wi->ip,
"Some Registry entries are missing for this Software, You may need to \
reinstall it from the Control Panel, Network applet.  Are you sure you \
want to continue?", MB_YESNO);
        if (stat != IDYES) {
          QuitFlag = 1;
          PostQuitMessage(0);  // end the setup program.
        }
      }

      // the NT install INF file copys files to our install directory,
      // so the following check is not good indicator if it is "reinstall"

      if (my_lstricmp(wi->ip.src_dir, wi->ip.dest_dir) != 0)
        do_progman_add = 1;

      //----- fire up the main level of property sheets.
      if (!QuitFlag)
        // eliminate the flash of showing and erasing the property sheet
        DoDriverPropPages(hwnd);  // in nt40.c

      // end the program.
      PostQuitMessage(0);  // end the setup program.
    return 0;
  
    case WM_SETFOCUS:
      SetFocus(glob_hDlg);
    return 0;

    case WM_COMMAND:	// message: command from application menu

      switch(wParam)
      {
        case IDM_F1:
          our_help(&wi->ip, WIN_NT);
        break;

        case IDM_ADVANCED_MODEM_INF:
          update_modem_inf(1);
        break;

        case IDM_PM:             // Try out the add pm group dde stuff

          stat = make_progman_group(progman_list_nt, wi->ip.dest_dir);
          if (stat)
          {
            our_message(&wi->ip,"Error setting up Program group",MB_OK);
            return 0;
          }
        break;

#ifdef COMMENT_OUT
        case IDM_ADVANCED:
          DialogBox(glob_hinst,
             MAKEINTRESOURCE(IDD_DRIVER_OPTIONS),
             hwnd,
             adv_driver_setup_dlg_proc);
        break;

        case IDM_EDIT_README:   // edit readme.txt
          strcpy(gtmpstr, "notepad.exe ");
          strcat(gtmpstr, wi->ip.src_dir);
          strcat(gtmpstr,"\\readme.txt");
          WinExec(gtmpstr, SW_RESTORE);
        break;
#endif

        return 0;

        case IDM_HELP:
          our_help(&wi->ip, WIN_NT);
        return 0;

        case IDM_HELPABOUT:
          strcpy(gtmpstr, szAppTitle);
          //strcpy(gtmpstr, aptitle);
          wsprintf(&gtmpstr[strlen(gtmpstr)],
                   " Version %s\nCopyright (c) 1995-97 Comtrol Corp.",
                   VERSION_STRING);
          MessageBox(hwnd, gtmpstr, "About",MB_OK);
        return 0;
     }
    break;

    case WM_SIZE:
      //frame_width = LOWORD(lParam);
      //frame_height = HIWORD(lParam);
    break; // have to let default have this too!

    case WM_PAINT:
      // PaintMainBMP(hwnd);
      hdc = BeginPaint(hwnd, &ps);
      EndPaint(hwnd, &ps);
      return 0;

    case WM_HELP:            // question mark thing
      our_context_help(lParam);
    break;

    case WM_SYSCOMMAND:
      if ((wParam & 0xfff0) == SC_CLOSE)
      {
        if (allow_exit(1) == 0)  // ok, quit
        {
        }
        else
        {
          return 0;  // we handled this, don't exit app.
        }
      }
      
    break;

    case WM_QUIT:
    case WM_DESTROY:  // message: window being destroyed
      PostQuitMessage(0);
    return 0 ;

    default:
    break;
  }
  return DefWindowProc(hwnd, message, wParam, lParam);
}

/*------------------------------------------------------------------------
| auto_install - No prompt default installation, for automated installs.
|------------------------------------------------------------------------*/
static int auto_install(void)
{
 //int stat;

  wi->ip.prompting_off = 1;  // turn our_message() prompting off.

  get_nt_config(wi);  // get configured io-addresses, irq, etc

  copy_setup_init();  // make a copy of config data for change detection

  // if 0 dev-nodes setup, add 1 for the user.
  if (wi->NumDevices == 0)
  {
    ++wi->NumDevices;
    validate_device(&wi->dev[0], 1);
  }

  do_install();
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\nt50.c ===
/*-----------------------------------------------------------------------
| nt50.c - NT5.0 specific code for VSLinkA/RocketPort Windows Install
  Program.

   This compiles into a DLL library which is installed(via INF) into
   the SYSTEM directory.  The INF file also hooks us into the system
   as a property page associated with the device.  Also, our co-installer
   DLL calls into us as well to perform configuration tasks(initial
   install, un-install).

   The .NumDevices option is used to save the number of Devices in
   our configuration.  Under NT50, we don't use it as such.  This setup
   dll only concerns itself with 1 device, and lets NT5.0 OS handle
   the list of devices.  So NumDevices always gets set to 1 under NT5.0
   even if we have more than one device which our driver is controlling.

11-24-98 - add some code toward clean up of files after uninstall, kpb.

Copyright 1998. Comtrol(TM) Corporation.
|-----------------------------------------------------------------------*/
#include "precomp.h"
#include <msports.h>

#define D_Level 0x40

static int write_config(int clear_it);
static int FindPortNodes(void);
static int read_config(void);
static int get_pnp_devicedesc(TCHAR *name);
static int nt5_get_pnp_dev_id(int *id);
static void uninstall_device(void);

int get_device_name(void);
int do_nt50_install(void);

BOOL WINAPI ClassInsProc(
      int func_num,     // our function to carry out.
      LPVOID our_info);  // points to our data struct

static int get_pnp_setup_info(void);
static int get_device_property(char *ret_name, int max_size);
static int get_pnp_isa_address(void);

static void test_config(void);

// following can be turned on to provide a User Interface during the
// install time of the driver.  Only problem is that NT5.0 fires up
// the driver first, and are ports
//#define TRY_UI 1
#ifdef TRY_UI
int DoCLassPropPages(HWND hwndOwner);
int FillClassPropertySheets(PROPSHEETPAGE *psp, LPARAM our_params);
BOOL WINAPI ClassSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam);
#endif

//#define DO_SHOWIT
#ifdef DO_SHOWIT
#define ShowMess(s) OutputDebugString(s);
static void show_install_info(OUR_INFO *pi);
static void show_debug_info(OUR_INFO *pi,
                           ULONG dev_id,
                           TCHAR *desc_str);

static int DumpPnpTree(void);
static void show_tree_node(DEVINST devInst,
                           ULONG dev_id,
                           TCHAR *desc_str);
static void show_tree_node_reg(DEVINST devInst,
                               TCHAR *key_name);

static TCHAR *spdrp_names[] = {
TEXT("DEVICEDESC"),
TEXT("HARDWAREID"),
TEXT("COMPATIBLEIDS"),
TEXT("NTDEVICEPATHS"),
TEXT("SERVICE"),
TEXT("CONFIGURATION"),  // x5
TEXT("CONFIGURATIONVECTOR"),
TEXT("CLASS"),
TEXT("CLASSGUID"),
TEXT("DRIVER"),
TEXT("CONFIGFLAGS"),  // xA
TEXT("MFG"),
TEXT("FRIENDLYNAME"),
TEXT("LOCATION_INFORMATION"),
TEXT("PHYSICAL_DEVICE_OBJECT_NAME"),
TEXT("CAPABILITIES"),
TEXT("UI_NUMBER"),  // x10
TEXT("UPPERFILTERS"),
TEXT("LOWERFILTERS"),
TEXT("BUSTYPEGUID"),  // x13
TEXT("LEGACYBUSTYPE"),
TEXT("BUSNUMBER"),
TEXT("invalid")};

static TCHAR *cm_drp_names[] = {
TEXT("DEVICEDESC"), // DeviceDesc REG_SZ property (RW)
TEXT("HARDWAREID"), // HardwareID REG_MULTI_SZ property (RW)
TEXT("COMPATIBLEIDS"), // CompatibleIDs REG_MULTI_SZ property (RW)
TEXT("NTDEVICEPATHS"), // Unsupported, DO NOT USE
TEXT("SERVICE"), // Service REG_SZ property (RW)
TEXT("CONFIGURATION"), // Configuration REG_RESOURCE_LIST property (R)
TEXT("CONFIGURATIONVECTOR"), // ConfigurationVector REG_RESOURCE_REQUIREMENTS_LIST property (R)
TEXT("CLASS"), // Class REG_SZ property (RW)
TEXT("CLASSGUID"), // ClassGUID REG_SZ property (RW)
TEXT("DRIVER"), // Driver REG_SZ property (RW)
TEXT("CONFIGFLAGS"), // ConfigFlags REG_DWORD property (RW)
TEXT("MFG"), // Mfg REG_SZ property (RW)
TEXT("FRIENDLYNAME"), // 0x0d FriendlyName REG_SZ property (RW)
TEXT("LOCATION_INFORMATION"), // LocationInformation REG_SZ property (RW)
TEXT("PHYSICAL_DEVICE_OBJECT_NAME"), // PhysicalDeviceObjectName REG_SZ property (R)
TEXT("CAPABILITIES"), // 0x10 Capabilities REG_DWORD property (R)
TEXT("UI_NUMBER"), // UiNumber REG_DWORD property (R)
TEXT("UPPERFILTERS"), // UpperFilters REG_MULTI_SZ property (RW)
TEXT("LOWERFILTERS"), // LowerFilters REG_MULTI_SZ property (RW)
TEXT("BUSTYPEGUID"), // Bus Type Guid, GUID, (R)
TEXT("LEGACYBUSTYPE"), // Legacy bus type, INTERFACE_TYPE, (R)
TEXT("BUSNUMBER"), // x16 Bus Number, DWORD, (R)
TEXT("invalid")};

// these are under Control\Class\Guid\Node
static TCHAR *dev_node_key_names[] = {
TEXT("ProviderName"),
TEXT("MatchingDeviceId"),
TEXT("DriverDesc"),
TEXT("InfPath"),
TEXT("InfSection"),
TEXT("isa_board_index"),
NULL};

static TCHAR glob_ourstr[4000];
/*----------------------------------------------------------
 show_install_info - show all the driver install info.
|------------------------------------------------------------*/
static void show_install_info(OUR_INFO *pi)
{
 int i;

  //if (MessageBox( GetFocus(), TEXT("Want Info?"), TEXT("aclass"), MB_YESNO | MB_ICONINFORMATION ) ==
  //   IDYES)
  {
    ShowMess(TEXT("**SPDRP****"));
    glob_ourstr[0] = 0;
    for (i=0; i<(SPDRP_MAXIMUM_PROPERTY-1); i++)
    {
      show_debug_info(pi, i, spdrp_names[i]);
    }
    ShowMess(glob_ourstr);
    //MessageBox( GetFocus(), glob_ourstr, TEXT("aclass"), MB_OK | MB_ICONINFORMATION );
  }
}

/*----------------------------------------------------------
 show_debug_info -
|------------------------------------------------------------*/
static void show_debug_info(OUR_INFO *pi,
                           ULONG dev_id,
                           TCHAR *desc_str)
{
 static TCHAR tmpstr[500];
 static TCHAR showstr[500];
 TCHAR smstr[40];
 ULONG RegType;
 ULONG ReqSize,i;
 unsigned char *b_ptr;
 int stat;

  showstr[0] = 0;

  RegType = 0;
  ReqSize = 0;
  stat = SetupDiGetDeviceRegistryProperty(pi->DeviceInfoSet,
                                   pi->DeviceInfoData,
                                   dev_id,
                                   &RegType,  // reg data type
                                   (PBYTE)tmpstr,
                                   sizeof(tmpstr),
                                   &ReqSize);  // size thing

  if (stat == FALSE)
  {
    stat = GetLastError();
    if (stat == 13)
    {
      return;  // don't display this
    }
    wsprintf(showstr, TEXT("Error:%d[%xH] ReqSize:%d"), stat, stat, ReqSize);
  }
  else if (RegType == REG_SZ)
  {
    wsprintf(showstr, TEXT("SZ:%s"), tmpstr);
  }
  else if (RegType == REG_DWORD)
  {
    wsprintf(showstr, TEXT("Dword:%xH"), *((ULONG *) tmpstr));
  }
  else if (RegType == REG_EXPAND_SZ)
  {
    wsprintf(showstr, TEXT("EXP_SZ:%s"), tmpstr);
  }
  else if (RegType == REG_MULTI_SZ)
  {
    wsprintf(showstr, TEXT("MULTI_SZ:%s"), tmpstr);
  }
  else if (RegType == REG_BINARY)
  {
    lstrcpy(showstr, TEXT("BIN:"));
    b_ptr = (unsigned char *)tmpstr;
    for (i=0; i<ReqSize; i++)
    {
      if ((b_ptr[i] >= 0x20) && (b_ptr[i] < 0x80))
        wsprintf(smstr, TEXT("%c"), b_ptr[i]);
      else
        wsprintf(smstr, TEXT("<%x>"), b_ptr[i]);
      lstrcat(showstr, smstr);
      if (i > 200) break;
    }
  }
  else
  {
    wsprintf(showstr, TEXT("BadType:%xH"), RegType);
  }
  if (lstrlen(showstr) > 200)
    showstr[200] = 0;

  if (lstrlen(glob_ourstr) < 3700)
  {
    lstrcat(glob_ourstr, desc_str);
    lstrcat(glob_ourstr, TEXT(" - "));
    lstrcat(glob_ourstr, showstr);
    lstrcat(glob_ourstr, TEXT("\n"));
  }
}

/*-----------------------------------------------------------------------------
| DumpPnpTree - Dump the pnp tree devnodes.
|-----------------------------------------------------------------------------*/
static int DumpPnpTree(void)
{
  DEVINST     devInst;
  DEVINST     devInstNext;
  CONFIGRET   cr;
  ULONG       walkDone = 0;
  ULONG       len;
  static CHAR buf[800];
  HKEY hKey;
  int  di,pi;
  ULONG val_type;

#if DBG
  //DebugBreak();
#endif

  //cr = CM_Locate_DevNode(&devInst, NULL, 0);

  // Get Root DevNode
  //
  cr = CM_Locate_DevNode(&devInst, NULL, 0);

  if (cr != CR_SUCCESS)
  {
    return 1;  // err
  }

  // Do a depth first search for the DevNode with a matching parameter
  while (!walkDone)
  {
    cr = CR_SUCCESS;
    glob_ourstr[0] = 0;
    lstrcat(glob_ourstr,TEXT("-CM_DRP-----"));
    for (di=CM_DRP_MIN; di<CM_DRP_MAX; di++)
    {
      show_tree_node(devInst, di, cm_drp_names[di-CM_DRP_MIN]);
    }

    lstrcat(glob_ourstr,TEXT("-KEYS--"));
    di = 0;
    while (dev_node_key_names[di] != NULL)
    {
      show_tree_node_reg(devInst, dev_node_key_names[di]);
      ++di;
    }
    ShowMess(glob_ourstr);

#if 0
    // Get the DriverName value
    //
    buf[0] = 0;
    len = sizeof(buf);
    cr = CM_Get_DevNode_Registry_Property(devInst,
              CM_DRP_CLASS, NULL, buf, &len, 0);
    if (cr == CR_SUCCESS && strcmp("Ports", buf) == 0)
    {
      //P_TRACE("Ports");
      // grab the "MatchingDeviceId"
      cr = CM_Open_DevNode_Key(
           devInst,
           KEY_READ,    // IN  REGSAM         samDesired,
           0,           // IN  ULONG          ulHardwareProfile,
           RegDisposition_OpenExisting,
           &hKey,       //OUT PHKEY          phkDevice,
           CM_REGISTRY_SOFTWARE); // IN  ULONG          ulFlags

      if (cr == CR_SUCCESS)
      {
        buf[0] = 0;
        len = sizeof(buf);
        cr = RegQueryValueEx(hKey,
                    TEXT("MatchingDeviceId"),
                    0,
                    &val_type,
                    (PBYTE) buf,
                    &len);
        if (cr != ERROR_SUCCESS)
        {
          buf[0] = 0;
        }

        RegCloseKey(hKey);
      }  // if openreg
    } // if "Ports"
#endif

    // This DevNode didn't match, go down a level to the first child.
    //
    cr = CM_Get_Child(&devInstNext,
                      devInst,
                      0);

    if (cr == CR_SUCCESS)
    {
        devInst = devInstNext;
        continue;
    }

    // Can't go down any further, go across to the next sibling.  If
    // there are no more siblings, go back up until there is a sibling.
    // If we can't go up any further, we're back at the root and we're
    // done.
    //
    for (;;)
    {
      cr = CM_Get_Sibling(&devInstNext,
                          devInst,
                          0);
      
      if (cr == CR_SUCCESS)
      {
          devInst = devInstNext;
          break;
      }

      cr = CM_Get_Parent(&devInstNext,
                         devInst,
                         0);

      if (cr == CR_SUCCESS)
      {
          devInst = devInstNext;
      }
      else
      {
          walkDone = 1;
          break;
      }
    } // for (;;)
  } // while (!walkDone)

  return 2;  // done;
}

/*----------------------------------------------------------
 show_tree_node -
|------------------------------------------------------------*/
static void show_tree_node(DEVINST devInst,
                           ULONG dev_id,
                           TCHAR *desc_str)
{
 CONFIGRET   cr;
 static TCHAR tmpstr[500];
 static TCHAR showstr[500];
 TCHAR smstr[40];
 ULONG RegType;
 ULONG ReqSize,i;
 unsigned char *b_ptr;
 int stat;

  showstr[0] = 0;

  RegType = 0;
  ReqSize = 0;
  cr = CM_Get_DevNode_Registry_Property(devInst,
            dev_id, &RegType, tmpstr, &ReqSize, 0);

  if (cr != CR_SUCCESS)
  {
    stat = GetLastError();
    if (stat == 997)
    {
      return;  // don't display this
    }
    wsprintf(showstr, TEXT("Error:%d[%xH] ReqSize:%d"), stat, stat, ReqSize);
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else if (RegType == REG_SZ)
  {
    wsprintf(showstr, TEXT("SZ:%s"), tmpstr);
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else if (RegType == REG_DWORD)
  {
    wsprintf(showstr, TEXT("Dword:%xH"), *((ULONG *) tmpstr));
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else if (RegType == REG_EXPAND_SZ)
  {
    wsprintf(showstr, TEXT("EXP_SZ:%s"), tmpstr);
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else if (RegType == REG_MULTI_SZ)
  {
    wsprintf(showstr, TEXT("MULTI_SZ:%s"), tmpstr);
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else if (RegType == REG_BINARY)
  {
    lstrcpy(showstr, TEXT("BIN:"));
    b_ptr = (unsigned char *)tmpstr;
    for (i=0; i<ReqSize; i++)
    {
      if ((b_ptr[i] >= 0x20) && (b_ptr[i] < 0x80))
        wsprintf(smstr, TEXT("%c"), b_ptr[i]);
      else
        wsprintf(smstr, TEXT("<%x>"), b_ptr[i]);
      lstrcat(showstr, smstr);
      if (i > 200) break;
    }
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else
  {
    wsprintf(showstr, TEXT("BadType:%xH"), RegType);
    //MessageBox( GetFocus(), tmpstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  if (lstrlen(showstr) > 200)
    showstr[200] = 0;

  if (lstrlen(glob_ourstr) < 3700)
  {
    lstrcat(glob_ourstr, desc_str);
    lstrcat(glob_ourstr, TEXT(" - "));
    lstrcat(glob_ourstr, showstr);
    lstrcat(glob_ourstr, TEXT("\n"));
  }
}

/*----------------------------------------------------------
 show_tree_node_reg -
|------------------------------------------------------------*/
static void show_tree_node_reg(DEVINST devInst,
                               TCHAR *key_name)
{
 CONFIGRET   cr;
 static TCHAR tmpstr[500];
 static TCHAR showstr[500];
 TCHAR smstr[40];
 ULONG RegType;
 ULONG ReqSize,i;
 unsigned char *b_ptr;
 int stat;
 TCHAR *desc_str = key_name;
 HKEY hKey;

  showstr[0] = 0;

  cr = CM_Open_DevNode_Key(
       devInst,
       KEY_READ,    // IN  REGSAM         samDesired,
       0,           // IN  ULONG          ulHardwareProfile,
       RegDisposition_OpenExisting,
       &hKey,       //OUT PHKEY          phkDevice,
       CM_REGISTRY_SOFTWARE); // IN  ULONG          ulFlags

  if (cr == CR_SUCCESS)
  {
    RegType = 0;
    ReqSize = 0;

    tmpstr[0] = 0;
    ReqSize = sizeof(tmpstr);
    cr = RegQueryValueEx(hKey,
                key_name,
                0,
                &RegType,
                (PBYTE) tmpstr,
                &ReqSize);
    if (cr != ERROR_SUCCESS)
    {
      tmpstr[0] = 0;
    }

    RegCloseKey(hKey);
  }  // if openreg
  else
  {
    tmpstr[0] = 0;
    ShowMess(TEXT("**Error Opening Key!\n"));
  }

  if (cr != CR_SUCCESS)
  {
    stat = GetLastError();
    //if (stat == 997)
    //{
    //  return;  // don't display this
    //}
    wsprintf(showstr, TEXT("Error:%d[%xH] ReqSize:%d"), stat, stat, ReqSize);
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else if (RegType == REG_SZ)
  {
    wsprintf(showstr, TEXT("SZ:%s"), tmpstr);
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else if (RegType == REG_DWORD)
  {
    wsprintf(showstr, TEXT("Dword:%xH"), *((ULONG *) tmpstr));
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else if (RegType == REG_EXPAND_SZ)
  {
    wsprintf(showstr, TEXT("EXP_SZ:%s"), tmpstr);
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else if (RegType == REG_MULTI_SZ)
  {
    wsprintf(showstr, TEXT("MULTI_SZ:%s"), tmpstr);
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else if (RegType == REG_BINARY)
  {
    lstrcpy(showstr, TEXT("BIN:"));
    b_ptr = (unsigned char *)tmpstr;
    for (i=0; i<ReqSize; i++)
    {
      if ((b_ptr[i] >= 0x20) && (b_ptr[i] < 0x80))
        wsprintf(smstr, TEXT("%c"), b_ptr[i]);
      else
        wsprintf(smstr, TEXT("<%x>"), b_ptr[i]);
      lstrcat(showstr, smstr);
      if (i > 200) break;
    }
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else
  {
    wsprintf(showstr, TEXT("BadType:%xH"), RegType);
    //MessageBox( GetFocus(), tmpstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  if (lstrlen(showstr) > 200)
    showstr[200] = 0;

  if (lstrlen(glob_ourstr) < 3700)
  {
    lstrcat(glob_ourstr, desc_str);
    lstrcat(glob_ourstr, TEXT(" - "));
    lstrcat(glob_ourstr, showstr);
    lstrcat(glob_ourstr, TEXT("\n"));
  }
}

#endif

// we are a DLL, so we need a LibMain...
/*----------------------------------------------------------
 LibMain -
|-------------------------------------------------------------*/
BOOL APIENTRY LibMain( HANDLE hDll, DWORD dwReason, LPVOID lpReserved )
{
    //DMess("LibMain");

    switch( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        glob_hinst = hDll;
        DisableThreadLibraryCalls((struct HINSTANCE__ *) hDll);
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_THREAD_ATTACH:
    default:
        break;
    }
    return TRUE;
}


/*----------------------------------------------------------
 DevicePropPage - DLL Entry Point from NT5.0 PnP manager to
   add property sheets.  Not the entry point for NT4.0,
   see nt40.c code WinMain().

    Exported Entry-point for adding additional device manager
    property
    sheet pages.  Registry specifies this routine under
    Control\Class\PortNode::EnumPropPage32="vssetup.dll,DevicePropPage"
    entry.  This entry-point gets called only when the Device
    Manager asks for additional property pages.

Arguments:
      LPVOID pinfo - points to PROPSHEETPAGE_REQUEST, see setupapi.h
      LPFNADDPROPSHEETPAGE pfnAdd - function ptr to call to add sheet.
      LPARAM lParam  - add sheet functions private data handle.

Return Value:
    TRUE on success
    FALSE if pages could not be added
|------------------------------------------------------------*/
BOOL WINAPI DevicePropPage(
      LPVOID pinfo,   // points to PROPSHEETPAGE_REQUEST, see setupapi.h
      LPFNADDPROPSHEETPAGE pfnAdd, // add sheet function
      LPARAM lParam)  // add sheet function data handle?
{
 PSP_PROPSHEETPAGE_REQUEST ppr = (PSP_PROPSHEETPAGE_REQUEST) pinfo;
 PROPSHEETPAGE   psp[NUM_DRIVER_SHEETS];
 HPROPSHEETPAGE  hpage[NUM_DRIVER_SHEETS];
 OUR_INFO *pi;
 int i;
 int stat;

  setup_init();  // build our main structs

  pi = glob_info;  // temporary kludge, unless we don't need re-entrantancy

    // copy the important port handles
  pi->DeviceInfoSet = ppr->DeviceInfoSet;
  pi->DeviceInfoData = ppr->DeviceInfoData;

#ifdef DO_SHOWIT
  if (MessageBox( GetFocus(), TEXT("Want Info?"), TEXT("aclass"), MB_YESNO | MB_ICONINFORMATION ) ==
     IDYES)
  {
    show_install_info(pi);
    DumpPnpTree();
  }
#endif

  //glob_hwnd = hDlg;

  wi->NumDevices = 0;

  // get the name that NT associates with this device, so we can
  // store and retrieve config information based on this also.

  stat = get_device_name();
  if (stat)
  {
    // something is seriously wrong if we can't get our device
    // name.  This is something NT uses as a name.
    DbgPrintf(D_Error, (TEXT("err5f\n")));
  }

  wi->NumDevices = 1;  // for pnp, devices are independent
  get_pnp_setup_info();  // read in pnp info
  get_pnp_devicedesc(wi->dev[0].Name);  // read in pnp description

  get_nt_config(wi);  // get configured vslink device settings.
  if (wi->dev[0].ModelName[0] == 0)
  {
#ifdef S_RK
    if ((wi->dev[0].HardwareId == PCI_DEVICE_RPLUS2) ||
        (wi->dev[0].HardwareId == PCI_DEVICE_422RPLUS2) ||
        (wi->dev[0].HardwareId == PCI_DEVICE_RPLUS4) ||
        (wi->dev[0].HardwareId == PCI_DEVICE_RPLUS8))
    {
      strcpy(wi->dev[0].ModelName, szRocketPortPlus);
    }
    else if ((wi->dev[0].HardwareId == ISA_DEVICE_RMODEM4) ||
             (wi->dev[0].HardwareId == ISA_DEVICE_RMODEM8) ||
             (wi->dev[0].HardwareId == PCI_DEVICE_RMODEM6) ||
             (wi->dev[0].HardwareId == PCI_DEVICE_RMODEM4))
    {
      strcpy(wi->dev[0].ModelName, szRocketModem);
    }
    else
    {
      strcpy(wi->dev[0].ModelName, szRocketPort);
    }
    //szRocketPort485
#endif

#ifdef S_VS
    if (wi->dev[0].HardwareId == NET_DEVICE_VS2000)
    {
      strcpy(wi->dev[0].ModelName, szVS2000);
    }
    else if ((wi->dev[0].HardwareId == NET_DEVICE_RHUB8) ||
        (wi->dev[0].HardwareId == NET_DEVICE_RHUB4))
    {
      strcpy(wi->dev[0].ModelName, szSerialHub);
    }
    else // if (wi->dev[0].HardwareId == NET_DEVICE_VS1000)
    {
      strcpy(wi->dev[0].ModelName, szVS1000);
    }
#endif

  }
  validate_config(1);

  //test_config();

  // if 0 dev-nodes setup, add 1 for the user.
  if (wi->NumDevices == 0)
  {
    ++wi->NumDevices;
    validate_device(&wi->dev[0], 1);
  }

  copy_setup_init();  // make a copy of config data for change detection

  FillDriverPropertySheets(&psp[0], (LPARAM)pi);

  // allocate our "Setting" sheet
  for (i=0; i<NUM_DRIVER_SHEETS; i++)
  {
    hpage[i] = CreatePropertySheetPage(&psp[i]);
    if (!hpage[i])
    {
      DbgPrintf(D_Error,(TEXT("err1a\n")));
      return FALSE;
    }

    // add the thing in.
    if (!pfnAdd(hpage[i], lParam))
    {
      DbgPrintf(D_Error,(TEXT("err1b\n")));
      DestroyPropertySheetPage(hpage[i]);  // error, dump it
      return FALSE;
    }
  }
 return TRUE;
}

/*------------------------------------------------------------------------
| ClassInsProc - Class Install entry for NT5.0 setup of driver.
    The co-class installer file(ctmasetp.dll,..) gets called at inital
    setup time, and calls us to bring up an initial user interface,
    or to handle other items.
|------------------------------------------------------------------------*/
BOOL WINAPI ClassInsProc(
      int func_num,     // our function to carry out.
      LPVOID our_info)  // points to our data struct
{
  int stat;
  //TCHAR tmpstr[200];
  typedef struct {
    ULONG size;
    HDEVINFO         DeviceInfoSet;  // a plug & play context handle
    PSP_DEVINFO_DATA DeviceInfoData; // a plug & play context handle
  } CLASS_OUR_INFO;
  CLASS_OUR_INFO *ci;
  OUR_INFO *pi;
  int i;

  switch (func_num)
  {
    case 0x40:  // RocketPort Class Install time.
    case 0x41:  // RocketPort Class Install time, quite install
    case 0x80:  // VS Class Install time.
    case 0x81:  // VS Class Install time, quite install
#if 0
    // don't pop up user interface on install, just use defaults
    // as best we can for now.

      ci = (CLASS_OUR_INFO *) our_info;
      setup_init();  // build our main structs

      pi = glob_info;  // temporary kludge, unless we don't need re-entrantancy

      // copy the important port handles
      pi->DeviceInfoSet = ci->DeviceInfoSet;
      pi->DeviceInfoData = ci->DeviceInfoData;

      //glob_hwnd = hDlg;
      wi->NumDevices = 1;

      // get the name that NT associates with this device, so we can
      // store and retrieve config information based on this also.
      stat = get_device_name();
      {
        get_pnp_setup_info();
        get_nt_config(wi);  // get configured vslink device settings.
        //validate_config();
      }
      if (stat)
      {
        // something is seriously wrong if we can't get our device
        // name.  This is something NT uses as a name.
        DbgPrintf(D_Error,(TEXT("err5f\n")));
      }

      // if 0 dev-nodes setup, add 1 for the user.
      if (wi->NumDevices == 0)
      {
        ++wi->NumDevices;
        validate_device(&wi->dev[0], 1);
      }

      copy_setup_init();  // make a copy of config data for change detection

      validate_config(1);  // make sure port names are setup

      if ((func_num & 1) == 0) // normal
      {
        DoDriverPropPages(GetFocus());  // in nt40.c
        // force it to save things off(probably should disable
        // cancel button, instead of this kludge).
        do_nt50_install();
      }
      else  // quite
      {
        wi->ip.prompting_off = 1;  // turn our_message() prompting off.
        do_nt50_install();
      }
#endif
    break;

    case 0x42:  // UnInstall RocketPort Device time.
    case 0x82:  // UnInstall VS Device time.
      DbgPrintf(D_Test, (TEXT("uninstall time\n")));

      ci = (CLASS_OUR_INFO *) our_info;
      setup_init();  // build our main structs

      pi = glob_info;  // temporary kludge, unless we don't need re-entrantancy
      // copy the important port handles
      pi->DeviceInfoSet = ci->DeviceInfoSet;
      pi->DeviceInfoData = ci->DeviceInfoData;
      wi->NumDevices = 1;

      // get the name that NT associates with this device, so we can
      // store and retrieve config information based on this also.
      stat = get_device_name();
      if (stat == 0)
      {
        get_pnp_setup_info();
        //get_nt_config(wi);  // get configured vslink device settings.
        //validate_config();
        uninstall_device();
      }
    break;

    default:
      return 1;  // error, bad func_num
    break;
  }  // switch

  return 0;
}

/*-----------------------------------------------------------------------------
| get_pnp_setup_info - 
|-----------------------------------------------------------------------------*/
static int get_pnp_setup_info(void)
{
 static TCHAR tmpstr[600];
 TCHAR *ptr;
 int stat;
 int Hardware_ID = 0;

  // grab the board type information.  Tells us what type of
  // board we have
  stat = get_device_property(tmpstr, 580);
  if (stat != 0)
    return 1;
  DbgPrintf(D_Level, (TEXT("dev_prop:%s\n"), tmpstr) );

  // Find out what the PnP manager thinks my NT Hardware ID is
  // "CtmPort0000" for RocketPort port,
  // "CtmVPort0000" for VS port,
  // "CtmRK1002" for isa-board rocketport,
  // "CtmRM1002" for isa-board rocketmodem,
  // "CtmVS1003" for VS1000
  // for pci we are getting a multi-wstring, 400 bytes long with
  //  "PCI\VEN_11FE&DEV_0003&SUBSYS00000...",0,"PCI\VEN.."

  stat = HdwIDStrToID(&Hardware_ID, tmpstr);
  if (stat)
  {
    DbgPrintf(D_Error, (TEXT("Err, Unknown pnpid:%s\n"), tmpstr))
  }

  stat = id_to_num_ports(Hardware_ID);

  if ((Hardware_ID & 0xfff) == 0)  // marked as pci
    wi->dev[0].IoAddress = 1;  // indicate to setup prog it is a PCI board

  if (Hardware_ID & 0x1000)  // marked as isa
    get_pnp_isa_address();

  // correct number of ports setting if it doesn't match
  //if (wi->dev[0].NumPorts != stat)
  //{
  //  DbgPrintf(D_Level, (TEXT("Correct NumPorts!\n")));
    wi->dev[0].NumPorts = stat;
  //}

  wi->dev[0].HardwareId = Hardware_ID;

  // check for HubDevice, ModemDevice, etc.
  if (IsHubDevice(Hardware_ID))
    wi->dev[0].HubDevice = 1;

  if (IsModemDevice(Hardware_ID))
    wi->dev[0].ModemDevice = 1;

  DbgPrintf(D_Level, (TEXT("Num Ports:%d\n"),stat));

  return 0;
}

/*-----------------------------------------------------------------------------
| get_device_property - return "rckt1003", or whatever, see INF file for
   selections.  For PCI this returns a long multi-sz string.
|-----------------------------------------------------------------------------*/
static int get_device_property(char *ret_name, int max_size)
{
  int stat, i,j;
  ULONG RegType;
  ULONG ReqSize;

  ret_name[0] = 0;
  stat = SetupDiGetDeviceRegistryProperty(glob_info->DeviceInfoSet,
                                 glob_info->DeviceInfoData,
                                 SPDRP_HARDWAREID,
                                 &RegType,  // reg data type
                                 (PBYTE)ret_name,
                                 max_size,
                                 &ReqSize);  // size thing
  if (stat == FALSE)
  {
    return 1;  // err
  }
  if ((RegType != REG_MULTI_SZ) && (RegType != REG_SZ))
  {
    return 2;  // err
    // error
  }

  return 0;  // ok
}

/*-----------------------------------------------------------------------------
| our_nt50_exit - return 1 if not allowing to exit.  return 0 if ok to exit.
|-----------------------------------------------------------------------------*/
int our_nt50_exit(void)
{
 int stat;

 OUR_INFO *pi;
 DWORD  DataSize;
 DWORD DataType;
 DWORD dstat;
 DWORD Val;
 HKEY   hkey;

  pi = glob_info;  // temporary kludge, unless we don't need re-entrantancy
  {
    stat = do_nt50_install();

    if (wi->NeedReset)
      our_message(&wi->ip,RcStr((MSGSTR+4)), MB_OK);

    write_config(1);  // clear out msports claims
    write_config(0);  // reclaim any new changed port names
  }
  return 0; 
}

/*-----------------------------------------------------------------------------
| get_device_name - return name in wi->ip.szNt50DevObjName[], ret 0 on success.
   Pnp puts config data into a registry node associated with the device.
   We put a lot of our config information into a related registry node.
   This related node is derived by and index saved and read from the pnp-node.
   So the first device added we assign a index of 0, and get a derived name
   of "Device0".  The 2nd device we add to the system sees the first, and
   saves an index value of 1, to get a associated device name of "Device1".

   The driver actually writes these index values out to the registry, not
   the setup program.   This is because the driver fires up before setup
   has a chance to run.
|-----------------------------------------------------------------------------*/
int get_device_name(void)
{
  int i;
  int stat;

  i = 0;
  stat = nt5_get_pnp_dev_id(&i);
  if (stat)
  {
    DbgPrintf(D_Test,(TEXT("failed to get pnp id\n")))
  }
  wsprintf(wi->ip.szNt50DevObjName, "Device%d", i);

  DbgPrintf(D_Test,(TEXT("pnp idstr:%s\n"), wi->ip.szNt50DevObjName))

  return 0;  // ok
}

/*-----------------------------------------------------------------------------
| nt5_get_pnp_dev_id - Get pnp device ID.  Pnp can have devices come and go
   dynamically, so a simple list of devices does not work. This is because
   we are no longer in charge of the master list.  We just get called
   from ths OS, which handles half of the installation.  This approximates
   a simple list of devices by reading a unique "Device#" number which the
   driver creates and stores in the software key:
   Driver:
     Upon startup, reads Pnp_Software_Reg_Area\CtmNodeID
     if (not exist)
     {
       derive unique device id number by enumerating
         Service\Rocketport\Parameters\"Device#" key entries.
       Add this key entry and also save number off as CtmNodeID.
     }
     Read in its device configuration from 
         Service\Rocketport\Parameters\"Device#" key.
   Setup Config Program:
     Upon startup, reads Pnp_Software_Reg_Area\CtmNodeID
     for its "Device#" to use in reading reg config area:
         Service\Rocketport\Parameters\"Device#" key entries.

Note on pnp registr areas:

  Hardware key is something like:
    HKLM\CurrentControlSet\Enum\Root\MultiPortSerial\0000   ; ISA or net device
    or 
    HKLM\CurrentControlSet\Enum\VEN_11FE&DEV......\0000   ; PCI device
    or (vs driver bus enumerated port entry):
    HKLM\CurrentControlSet\Enum\CtmvPort\RDevice\10&Port000 ; enumerated port

  Software key is something like:
    HKLM\CurrentControlSet\Control\Class\{50906CB8-....}\0000   ; MPS
    or for a port:
    HKLM\CurrentControlSet\Control\Class\{4D36E978-....}\0000   ; PORTS

  The hardware key is a reg. tree structure which reflects the hardware
  configuration.  The software key is more of a flat reg. structure
  which reflects the devices in the system.  Software area uses GUID
  names to catagorize and name types of hardware.

  The Hardware keys are hidden by default in the NT5 registry.
  Use a tool called PNPREG.EXE /U to Unlock this area, then regedit
  will see beyond enum.  PNPREG /L will lock(hide) it.

  The hardware key contains a link to the software key.
|-----------------------------------------------------------------------------*/
static int nt5_get_pnp_dev_id(int *id)
{
 HKEY hkey;
 int stat;
 DWORD id_dword;

  stat = nt5_open_dev_key(&hkey);
  if (stat)
  {
    *id = 0;
    return 1;
  }
  stat = reg_get_dword(hkey, "", "CtmNodeId", &id_dword);
  reg_close_key(hkey);
  if (stat)
  {
    // it should have been there, the driver should set this up to
    // a unique index value.  But if not, we use 0.
    *id = 0;
    return 2;
  }
  // return the unique index value which is used to derive the
  // registry configuration area "Device#".
  *id = (int) id_dword;

  return 0;
}

/*-----------------------------------------------------------------------------
| nt5_open_dev_key -
|-----------------------------------------------------------------------------*/
int nt5_open_dev_key(HKEY *hkey)
{
  CONFIGRET   cr;

  cr = CM_Open_DevNode_Key(
           glob_info->DeviceInfoData->DevInst,
           KEY_ALL_ACCESS,
           0,           
           RegDisposition_OpenExisting,
           hkey,       
           CM_REGISTRY_SOFTWARE); // _SOFTWARE worked!(under CLASS)
           //CM_REGISTRY_HARDWARE); // _HARDWARE no open!
           //CM_REGISTRY_CONFIG); // _CONFIG wrote under HardwareConfig

  if (cr != CR_SUCCESS)
  {
    DbgPrintf(D_Error,(TEXT("nt50 pnp reg open fail:%d\n"), GetLastError()));
    *hkey = NULL;
    return 1;
  }
  return 0;
}

#if DBG
/*-----------------------------------------------------------------------------
| read_config - Save the config for the device  Just a test.
|-----------------------------------------------------------------------------*/
static int read_config(void)
{
int stat;

 DWORD  DataSize;
 DWORD DataType;
 DWORD Err;
 DWORD Val;
 HKEY   hkey;
  DEVINST     devInst;
  CONFIGRET   cr;


static char *szNumPorts = {"NumPorts"};
static char *szTestVal = {"TestVal"};
  stat = 0;

  DbgPrintf(D_Test,(TEXT("read config\n")));
  if((hkey = SetupDiOpenDevRegKey(glob_info->DeviceInfoSet,
                                  glob_info->DeviceInfoData,
                                  DICS_FLAG_GLOBAL,
                                  0,
                                  DIREG_DEV,
                                  //DIREG_DRV,
                                  KEY_READ)) == INVALID_HANDLE_VALUE) {
      DbgPrintf(D_Error,(TEXT("DI open fail:%xH\n"), GetLastError()));
      stat = 1;
  }
  if (stat == 0)
  {
    DataSize = sizeof(DWORD);   // max size of return str
    Err = RegQueryValueEx(hkey, szNumPorts, NULL, &DataType,
                        (BYTE *) &Val, &DataSize);
    if (Err != ERROR_SUCCESS)
    {
        DbgPrintf(D_Error,(TEXT("OpenDevReg fail\n")));
        Val = 0;
    }
    DbgPrintf(D_Test,(TEXT("NumPorts=%d\n"), Val));
    RegCloseKey(hkey);
  }

  DbgPrintf(D_Test,(TEXT("write config\n")));
  stat = 0;
  if((hkey = SetupDiOpenDevRegKey(glob_info->DeviceInfoSet,
                                  glob_info->DeviceInfoData,
                                  DICS_FLAG_GLOBAL,
                                  0,
                                  DIREG_DEV,
                                  //DIREG_DRV,
                                  //KEY_ALL_ACCESS)) == INVALID_HANDLE_VALUE) {
                                  KEY_WRITE)) == INVALID_HANDLE_VALUE) {
      DbgPrintf(D_Error,(TEXT("DI write open fail:%xH\n"), GetLastError()));
      stat = 1;
  }
  if (stat == 0)
  {
    stat = reg_set_dword(hkey, "", szTestVal, 0x1234);
    if (stat)
    {
      DbgPrintf(D_Error,(TEXT("write val fail\n")));
    }
    RegCloseKey(hkey);
  }

  devInst = glob_info->DeviceInfoData->DevInst;
  if (devInst == 0)
  {
    DbgPrintf(D_Error,(TEXT("err6g\n")));
    return 1;  // err
  }

  cr = CM_Open_DevNode_Key(
           devInst,
           KEY_READ,    // IN  REGSAM         samDesired,
           0,           // IN  ULONG          ulHardwareProfile,
           RegDisposition_OpenExisting,
           &hkey,       //OUT PHKEY          phkDevice,
           //CM_REGISTRY_SOFTWARE); // _SOFTWARE worked!(under CLASS)
           CM_REGISTRY_HARDWARE); // _HARDWARE no open!
           //CM_REGISTRY_CONFIG); // _CONFIG wrote under HardwareConfig

  if (cr == CR_SUCCESS)
  {
    DataSize = sizeof(DWORD);   // max size of return str
    Err = RegQueryValueEx(hkey, szNumPorts, NULL, &DataType,
                        (BYTE *) &Val, &DataSize);
    if (Err != ERROR_SUCCESS)
    {
        DbgPrintf(D_Error,(TEXT("Reg query fail\n")));
        Val = 0;
    }
    DbgPrintf(D_Test,(TEXT("cr NumPorts=%d\n"), Val));
    RegCloseKey(hkey);
  }
  else
  {
    DbgPrintf(D_Error,(TEXT("CM open fail:%d\n"), GetLastError()));
  }

  cr = CM_Open_DevNode_Key(
           devInst,
           //KEY_ALL_ACCESS,
           KEY_WRITE,
           0,           
           RegDisposition_OpenExisting,
           &hkey,       
           //CM_REGISTRY_SOFTWARE); // _SOFTWARE worked!(under CLASS)
           CM_REGISTRY_HARDWARE); // _HARDWARE no open!
           //CM_REGISTRY_CONFIG); // _CONFIG wrote under HardwareConfig

  if (cr == CR_SUCCESS)
  {
    stat = reg_set_dword(hkey, "", szTestVal, 0x1234);
    if (stat)
    {
      DbgPrintf(D_Error,(TEXT("write val fail\n")));
    }
    else
    {
      DbgPrintf(D_Test,(TEXT("write val ok\n")));
    }
    RegCloseKey(hkey);
  }
  else
  {
    DbgPrintf(D_Error,(TEXT("CM write open fail:%d\n"), GetLastError()));
  }

  return 0;
}
#endif

/*-----------------------------------------------------------------------------
| get_pnp_devicedesc -
|-----------------------------------------------------------------------------*/
static int get_pnp_devicedesc(TCHAR *name)
{
 CONFIGRET cr;
 DWORD len;
  // Get the Device name
  len = 60;

  cr = CM_Get_DevNode_Registry_Property(glob_info->DeviceInfoData->DevInst,
            CM_DRP_DEVICEDESC,
            NULL,
            (PBYTE)name,
            &len,
            0);

  if (cr != CR_SUCCESS)
  {
    DbgPrintf(D_Error,(TEXT("err, no fr.name.\n")));
    return 2;  // err
  }
  DbgPrintf(D_Test, (TEXT("get friendlyname:%s\n"), name));
  return 0;  // ok
}

#if 0
/*-----------------------------------------------------------------------------
| set_pnp_devicedesc -
|-----------------------------------------------------------------------------*/
static int set_pnp_devicedesc(TCHAR *name)
{
 CONFIGRET cr;

  // Set the Device name

  cr = CM_Set_DevNode_Registry_Property(
          glob_info->DeviceInfoData->DevInst,
          CM_DRP_DEVICEDESC,
          (PBYTE)name,
          (lstrlen(name) + 1) * sizeof(TCHAR),
          0);

  if (cr != CR_SUCCESS)
  {
    DbgPrintf(D_Error,(TEXT("err3d\n")));
    return 2;  // err
  }
  return 0;  // ok
}
#endif

/*-----------------------------------------------------------------------------
| write_config - Save the config for the device - Set pnp port names so
   they match our configuration.  Also, try to keep MSPORTS.DLL com-port
   name database in sync with our stuff by detecting when our pnp comport
   name changes, and calling msports routines to free and claim port names.

   We call this routine once with clear_it SET, then call it again with
   it clear.  This is because we must clear ALL port claims from msports.dll
   (which holds a database in services\serial reg area) prior to re-claiming
   new port names.  This is because if we overlap, we run into trouble.
|-----------------------------------------------------------------------------*/
static int write_config(int clear_it)
{
 DEVINST devInst;
 Device_Config *dev;
 Port_Config *port;
 int  i,pi, str_i, stat;
 CONFIGRET cr;
 ULONG len;
 TCHAR buf[120];
 TCHAR curname[40];
 HKEY hKey;
 int port_index = 0;
 int port_i;
 ULONG val_type;
 HCOMDB hPort = NULL;

  FindPortNodes();  // fill in all port->hPnpNode

  for(i=0; i<wi->NumDevices; i++)   // Loop through all possible boards
  {
    dev = &wi->dev[i];
    for(pi=0; pi<dev->NumPorts; pi++)   // Loop through all ports
    {
      port = &dev->ports[pi];

      if (port->hPnpNode != 0) // have a DEVINST handle for it.
      {
        devInst = (DEVINST) port->hPnpNode;

        if (!clear_it)
        {
          len = sizeof(buf);
#ifdef S_RK
          wsprintf(buf, "Comtrol RocketPort %d (%s)", port_index, port->Name);
#else
          wsprintf(buf, "Comtrol VS Port %d (%s)", port_index, port->Name);
#endif
          cr = CM_Set_DevNode_Registry_Property(devInst,
                                        CM_DRP_FRIENDLYNAME,
                                        (PBYTE)buf,
                                        (lstrlen(buf) + 1) * sizeof(TCHAR),
                                        0);
          if (cr != CR_SUCCESS)
          {
            DbgPrintf(D_Error,(TEXT("err7d\n")));
          }
        }
        cr = CM_Open_DevNode_Key(
             devInst,
             KEY_ALL_ACCESS,   // IN  REGSAM         samDesired,
             0,           // IN  ULONG          ulHardwareProfile,
             RegDisposition_OpenExisting,
             &hKey,       //OUT PHKEY          phkDevice,
             CM_REGISTRY_HARDWARE); // IN  ULONG          ulFlags

        wsprintf(buf, "%s", port->Name);
        if (cr == CR_SUCCESS)
        {
          curname[0] = 0;
          len = sizeof(curname);
          cr = RegQueryValueEx(hKey,
                    TEXT("PortName"),
                    0,
                    &val_type,
                    (PBYTE) curname,
                    &len);
          if (cr != CR_SUCCESS)
          {
            DbgPrintf(D_Error,(TEXT("error reading portname\n")));
          }

          if (_tcsicmp(curname, buf) != 0)  // it's changed!
          {
            DbgPrintf(D_Test,(TEXT("com name from:%s, to %s\n"), curname, buf));
            if (hPort == NULL)
              cr = ComDBOpen(&hPort);
            if (hPort == NULL)
            {
              DbgPrintf(D_Error,(TEXT("err dbcom 1d\n")));
            }
            else
            {
              if (clear_it)
              {
                // clear out name
                port_i = ExtractNameNum(curname);
                if ((port_i > 0) && (port_i < 256))
                {
                  ComDBReleasePort(hPort, port_i);
                  DbgPrintf(D_Test,(TEXT("Free Old:%d\n"), port_i));
                }
              }
              else
              {
                port_i = ExtractNameNum(buf);
                if ((port_i > 0) && (port_i < 256))
                {
                  ComDBClaimPort(hPort, port_i, 1 /* force*/, NULL);
                  DbgPrintf(D_Test,(TEXT("Claim New:%d\n"), port_i));
                }
              }
            }
            if (!clear_it)
            {
              RegSetValueEx(hKey,
                          "PortName",
                          0,
                          REG_SZ,
                          (PBYTE) buf,
                          (lstrlen(buf) + 1) * sizeof(TCHAR) );
            }
          }  // not matched, com-port name changed
          RegCloseKey(hKey);
        }  // opened dev node key
        else {
          DbgPrintf(D_Error,(TEXT("err7e\n")));
             }
      } // if (port->hPnpNode != 0)
      else
      {
        DbgPrintf(D_Level,(TEXT("Bad Pnp Name Find\n")));
      }
      ++port_index;
    }  // for(pi=0; pi<dev->NumPorts; pi++)
  } // for(i=0; i<wi->NumDevices; i++)

  if (hPort != NULL)
    ComDBClose(hPort);

  return 0; 
}

/*------------------------------------------------------------------------
| uninstall_device - 
|------------------------------------------------------------------------*/
static void uninstall_device(void)
{

#ifdef DO_SHOWIT
  if (MessageBox( GetFocus(), TEXT("UNINSTALL, Want Info?"), TEXT("aclass"), MB_YESNO | MB_ICONINFORMATION ) ==
     IDYES)
  {
    show_install_info(glob_info);
    DumpPnpTree();
  }
#endif

  clear_nt_device(wi);

  //if (this_is_last_device)
  //  remove_driver(1);
}

/*-----------------------------------------------------------------------------
| FindPortNodes - Find the pnp tree devnodes which hold our port names.
    Put the handle into our port config struct for easy access.
    We start the search at our device node.
|-----------------------------------------------------------------------------*/
static int FindPortNodes(void)
{
  DEVINST     devInst;
  DEVINST     devInstNext;
  CONFIGRET   cr;
  ULONG       walkDone = 0;
  ULONG       len;
  CHAR buf[120];
  HKEY hKey;
  int  di,pi;
  int port_index;
  Device_Config *dev;
  Port_Config *port;
  ULONG val_type;

  // clear out all stale pnpnode handles before re-creating this list
  for(di=0; di<wi->NumDevices; di++)   // Loop through all possible boards
  {
    dev = &wi->dev[di];
    for(pi=0; pi<dev->NumPorts; pi++)   // Loop through all ports
    {
      dev->ports[pi].hPnpNode = 0;
    }
  }

#if 0
  // Get Root DevNode
  //
  cr = CM_Locate_DevNode(&devInst, NULL, 0);

  if (cr != CR_SUCCESS)
  {
    return 1;  // err
  }
#endif
  devInst = glob_info->DeviceInfoData->DevInst;
  if (devInst == 0)
  {
    DbgPrintf(D_Error,(TEXT("err6g\n")));
    return 1;  // err
  }

DbgPrintf(D_Level, (TEXT("search nodes\n")));

  cr = CM_Get_Child(&devInstNext,
                    devInst,
                    0);

  while (cr == CR_SUCCESS)
  {
    devInst = devInstNext;

    // Get the DriverName value
    //
    buf[0] = 0;
    len = sizeof(buf);
    cr = CM_Get_DevNode_Registry_Property(devInst,
              CM_DRP_CLASS, NULL, buf, &len, 0);
    if (cr == CR_SUCCESS && strcmp("Ports", buf) == 0)
    {
      // grab the "MatchingDeviceId"
      cr = CM_Open_DevNode_Key(
           devInst,
           KEY_READ,    // IN  REGSAM         samDesired,
           0,           // IN  ULONG          ulHardwareProfile,
           RegDisposition_OpenExisting,
           &hKey,       //OUT PHKEY          phkDevice,
           CM_REGISTRY_SOFTWARE); // IN  ULONG          ulFlags

      if (cr == CR_SUCCESS)
      {
        buf[0] = 0;
        len = sizeof(buf);
        cr = RegQueryValueEx(hKey,
                    TEXT("MatchingDeviceId"),
                    0,
                    &val_type,
                    (PBYTE) buf,
                    &len);
        if (cr != ERROR_SUCCESS)
        {
          buf[0] = 0;
        }
#ifdef S_RK
        if (strstr(buf, "ctmport") != NULL)  // found it
#else
        if (strstr(buf, "ctmvport") != NULL)  // found it
#endif
        {
          int k, dev_num;

          k = sscanf(&buf[8], "%d", &dev_num);
          if (k==1)
          {
            port_index = 0;
            // found a vs port node, so save a reference to this node
            // in our config struct for simple reference.
            //save_pnp_node(j, devInst);
            for(di=0; di<wi->NumDevices; di++)   // Loop through all possible boards
            {
              dev = &wi->dev[di];
              for(pi=0; pi<dev->NumPorts; pi++)   // Loop through all ports
              {
                port = &dev->ports[pi];
                if (port_index == dev_num) // found our matching index
                {
                  port->hPnpNode = (HANDLE) devInst;
                }
                ++port_index;
              }  // for pi
            }  // for di
          }  // if scanf
        }  // if strstr "ctmvport"

        RegCloseKey(hKey);
      }  // if openreg
    } // if "Ports"

    // Get next child
    cr = CM_Get_Sibling(&devInstNext,
                          devInst,
                          0);
  } // while (!cr_success)

  return 2;  // done;
}

/*-----------------------------------------------------------------------------
| do_nt50_install -
|-----------------------------------------------------------------------------*/
int do_nt50_install(void)
{
 int stat = 0;
 int do_remove = 0;
 int do_modem_inf = 0;
 static int in_here = 0;

  if (in_here)  // problem hitting OK button twice(sets off two of these)
    return 2;

  in_here = 1;

  if (wi->nt_reg_flags & 4) // initial install, no setupversion string found
  {
    if (setup_utils_exist())
    {
      setup_make_progman_group(1);  // 1=with prompt
    }
    wi->nt_reg_flags &= ~4;
  }

  if (!wi->ChangesMade)
    send_to_driver(0);  // evaluate if anything changed

  stat = send_to_driver(1);
  stat = set_nt_config(wi);
  in_here = 0;

  if (stat)
    return 1; // error

  return 0; // ok
}

/*----------------------------------------------------------------------------
| get_pnp_isa_address - 
|-----------------------------------------------------------------------------*/
static int get_pnp_isa_address(void)
{
  int IoBase;
  LOG_CONF LogConfig;
  RES_DES ResDes;
  IO_RESOURCE IoResource;
  //IRQ_RESOURCE IrqResource;
  CONFIGRET cr;
  int status;

  status = CM_Get_First_Log_Conf(&LogConfig,
             (DEVINST)(glob_info->DeviceInfoData->DevInst),
             ALLOC_LOG_CONF);
  //if (status != CR_SUCCESS)
  //  mess(&wi->ip, "No ALLOC lc %xH\n",status);

  if (status != CR_SUCCESS)
    return 1;

  // get the Io base port
  status = CM_Get_Next_Res_Des(&ResDes, LogConfig, ResType_IO, NULL, 0);
  if (status != CR_SUCCESS)
  {
    return 2;
  }

  cr = CM_Get_Res_Des_Data(ResDes, &IoResource, sizeof(IO_RESOURCE), 0);
  CM_Free_Res_Des_Handle(ResDes);

  if(cr != CR_SUCCESS)
  {
    return 3;
  }

  IoBase = (int)IoResource.IO_Header.IOD_Alloc_Base;
  //mess(&wi->ip, "OK 1c, Base:%xH\n", IoBase);

  if ((IoBase < 0x400) && (IoBase >= 0x100))
    wi->dev[0].IoAddress = IoBase;
  else
    wi->dev[0].IoAddress = 0;

  return 0;
}

#if 0
/*----------------------------------------------------------------------------
| test_config - See what we can do concerning the allocated IO resources.
|-----------------------------------------------------------------------------*/
static void test_config(void)
{
  int IoBase;
  LOG_CONF LogConfig;
  RES_DES ResDes;
  IO_RESOURCE IoResource;
  //IRQ_RESOURCE IrqResource;
  CONFIGRET cr;
  int status;

  //glob_ourstr[0] = 0;
  //lstrcat(glob_ourstr, "Test Config:\n");
//  mess(&wi->ip, "Test Config");

  status = CM_Get_First_Log_Conf(&LogConfig,
             (DEVINST)(glob_info->DeviceInfoData->DevInst),
             BOOT_LOG_CONF);
  if (status != CR_SUCCESS)
    mess(&wi->ip, "No BOOT lc %xH\n",status);
  else
    mess(&wi->ip, "Got BOOT lc\n");

  status = CM_Get_First_Log_Conf(&LogConfig,
             (DEVINST)(glob_info->DeviceInfoData->DevInst),
             FORCED_LOG_CONF);
  if (status != CR_SUCCESS)
    mess(&wi->ip, "No FORCED lc %xH\n",status);
  else
    mess(&wi->ip, "Got FORCED lc\n");

  status = CM_Get_First_Log_Conf(&LogConfig,
             (DEVINST)(glob_info->DeviceInfoData->DevInst),
             BASIC_LOG_CONF);
  if (status != CR_SUCCESS)
    mess(&wi->ip, "No BASIC lc %xH\n",status);
  else
    mess(&wi->ip, "Got BASIC lc\n");

  status = CM_Get_First_Log_Conf(&LogConfig,
             (DEVINST)(glob_info->DeviceInfoData->DevInst),
             FORCED_LOG_CONF);
  if (status != CR_SUCCESS)
    mess(&wi->ip, "No FORCED lc %xH\n",status);
  else
    mess(&wi->ip, "Got FORCED lc\n");

  status = CM_Get_First_Log_Conf(&LogConfig,
             (DEVINST)(glob_info->DeviceInfoData->DevInst),
             ALLOC_LOG_CONF);
  if (status != CR_SUCCESS)
    mess(&wi->ip, "No ALLOC lc %xH\n",status);
  else
    mess(&wi->ip, "Got ALLOC lc\n");

  if (status != CR_SUCCESS)
    return;
  //
  // First, get the Io base port
  //
  status = CM_Get_Next_Res_Des(&ResDes, LogConfig, ResType_IO, NULL, 0);
  if (status != CR_SUCCESS)
  {
    mess(&wi->ip, "Error 1b\n");
    return;
  }
  mess(&wi->ip, "OK 1b\n");

  cr = CM_Get_Res_Des_Data(ResDes, &IoResource, sizeof(IO_RESOURCE), 0);
  CM_Free_Res_Des_Handle(ResDes);

  if(cr != CR_SUCCESS)
  {
    mess(&wi->ip, "Error 1c\n");
    return;
  }

  IoBase = (int)IoResource.IO_Header.IOD_Alloc_Base;
  mess(&wi->ip, "OK 1c, Base:%xH\n", IoBase);

   //OldIrq = IrqResource.IRQ_Header.IRQD_Alloc_Num;

#if 0
  // We don't want to popup the configuration UI if the 'quiet install' flag is
  // set _and_ we already have a forced config (pre-install support).
  if (CM_Get_First_Log_Conf(&ForcedLogConf, glob_info->DeviceInfoData->DevInst, FORCED_LOG_CONF) == CR_SUCCESS)
  {
    CM_Free_Log_Conf_Handle(ForcedLogConf);

    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams))
    {
      if(FirstTime && (DeviceInstallParams.Flags & DI_QUIETINSTALL))
      {
        DisplayPropSheet = FALSE;
      }
    }
  }
#endif
}
#endif


#ifdef TRY_UI

#define MAX_NUM_CLASS_SHEETS 3

PROPSHEETPAGE class_psp[MAX_NUM_CLASS_SHEETS];
int num_class_pages = 0;

/*------------------------------------------------------------------------
| DoCLassPropPages - 
|------------------------------------------------------------------------*/
int DoCLassPropPages(HWND hwndOwner,
                     SP_PROPSHEETPAGE_REQUEST *propreq)
{
    PROPSHEETPAGE *psp;
    PROPSHEETHEADER psh;
    OUR_INFO * our_params;
    INT stat;
    //SP_PROPSHEETPAGE_REQUEST propreq;
    //typedef struct _SP_PROPSHEETPAGE_REQUEST {
    //DWORD            cbSize;
    //DWORD            PageRequested;
    //HDEVINFO         DeviceInfoSet;
    //PSP_DEVINFO_DATA DeviceInfoData;


    //Fill out the PROPSHEETPAGE data structure for the Background Color
    //sheet

//    our_params = glob_info;  // temporary kludge, unless we don't need re-entrantancy 
    psp = &class_psp[0];

    //Fill out the PROPSHEETPAGE data structure for the Client Area Shape
    //sheet
    FillClassPropertySheets(&psp[0], (LPARAM)our_params);
    ++num_class_pages;

    //Fill out the PROPSHEETHEADER

    //stat = DevicePropPage(
    //  (LPVOID) propreq,   // points to PROPSHEETPAGE_REQUEST, see setupapi.h
    //  (LPFNADDPROPSHEETPAGE) ClassAddPropPage, // add sheet function
    //  0)  // add sheet function data handle?

    memset(&psh, 0, sizeof(PROPSHEETHEADER));  // add fix 11-24-98

    psh.dwSize = sizeof(PROPSHEETHEADER);
    //psh.dwFlags = PSH_USEICONID | PSH_PROPSHEETPAGE;
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndOwner;
    psh.hInstance = glob_hinst;
    psh.pszIcon = TEXT("");
    psh.nPages = num_class_pages;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    //And finally display the dialog with the two property sheets.


    stat = PropertySheet(&psh);

//BOOL WINAPI DevicePropPage(
//      LPVOID pinfo,   // points to PROPSHEETPAGE_REQUEST, see setupapi.h
//      LPFNADDPROPSHEETPAGE pfnAdd, // add sheet function
//      LPARAM lParam)  // add sheet function data handle?

  return 0;
}

/*------------------------------------------------------------------------
| ClassAddPropPage - Call back function to add a prop page.
|------------------------------------------------------------------------*/
BOOL WINAPI ClassAddPropPage(HPROPSHEETPAGE hpage, LPARAM lparam)
{
  PropSheet_AddPage(lparam, hpage);
}

/*------------------------------------------------------------------------
| FillClassPropertySheets - Setup pages for driver level property sheets.
|------------------------------------------------------------------------*/
int FillClassPropertySheets(PROPSHEETPAGE *psp, LPARAM our_params)
{
  INT pi;
  static TCHAR titlestr[40];

  memset(psp, 0, sizeof(*psp) * NUM_CLASS_SHEETS);

  pi = 0;

  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP | PSH_NOAPPLYNOW;
  psp[pi].hInstance = glob_hinst;
//  psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_CLASS_DLG);
  psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_DRIVER_OPTIONS);
  psp[pi].pfnDlgProc = ClassSheet;
  load_str( glob_hinst, (TITLESTR+3), titlestr, CharSizeOf(titlestr) );
  psp[pi].pszTitle = TEXT("Setup");
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;

  return 0;
}

/*----------------------------------------------------------
 ClassSheet - Dlg window procedure for add on Advanced sheet.
|-------------------------------------------------------------*/
BOOL WINAPI ClassSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
 ////OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  switch(uMessage)
  {
    case WM_INITDIALOG :
      ////OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      ////SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
#ifdef NT50
      glob_hwnd = hDlg;
#endif
    stat = DevicePropPage(
      (LPVOID) propreq,   // points to PROPSHEETPAGE_REQUEST, see setupapi.h
      (LPFNADDPROPSHEETPAGE) ClassAddPropPage, // add sheet function
      0)  // add sheet function data handle?

      //set_field(hDlg, IDC_VERBOSE);
    return TRUE;  // No need for us to set the focus.

    case WM_COMMAND:
    return FALSE;

    case WM_PAINT:
    return FALSE;

    case WM_CONTEXTMENU:     // right-click
      //context_menu();
    break;

    case WM_HELP:            // question mark thing
      //our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_KILLACTIVE :
          // we're losing focus to another page...
          // make sure we update the Global485 variable here.
          //get_field(hDlg, IDC_GLOBAL485);
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          return FALSE;  // allow focus change
        break;

        case PSN_HELP :
          //our_help(&wi->ip, WIN_NT);
        break;

        case PSN_QUERYCANCEL :
            // the DWL_MSGRESULT field must be *FALSE* to tell QueryCancel
            // that an exit is acceptable.  The function result must be
            // *TRUE* to acknowledge that we handled the message.
            SetWindowLong(hDlg, DWL_MSGRESULT, FALSE); // allow cancel
            return TRUE;
        break;

        case PSN_APPLY :
              SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          return TRUE;

        default :
        return FALSE;
      }  // switch ->code
    break;  // case wmnotify

    default :
    return FALSE;
  }  // switch(uMessage)
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\nt50.h ===
BOOL WINAPI DevicePropPage(
      LPVOID pinfo,   // points to PROPSHEETPAGE_REQUEST, see setupapi.h
      LPFNADDPROPSHEETPAGE pfnAdd, // add sheet function
      LPARAM lParam);  // add sheet function data handle?
int our_nt50_exit(void);
int nt5_open_dev_key(HKEY *hkey);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\portprop.h ===
// portprop.h

int DoPortPropPages(HWND hwndOwner, int device, int port);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\ourver.h ===
#ifdef S_RK
  #define VER_PRODUCTNAME           "RocketPort RocketModem RocketModemII RocketModem i(TM) Series Async Adapters for the Microsoft Windows(TM) Operating System\0"
  #define VER_INTERNALNAME          "RocketPort"
  #define VER_PRODUCTVERSION_STR  "4.41"
  #define VER_PRODUCTVERSION      4,41
#else
  #define VER_PRODUCTNAME           "VS1000/VS2000, RocketPort Serial Hub for the Microsoft Windows(TM) Operating System\0"
  #define VER_INTERNALNAME          "VSLinkA"
  #define VER_PRODUCTVERSION_STR  "2.41"
  #define VER_PRODUCTVERSION       2,41
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\opstr.h ===
// opstr.h

//----- Pnp-ID Defines
/* PCI Defines */
#define PCI_VENDOR_ID           0x11fe
#define PCI_DEVICE_32I          0x0001
#define PCI_DEVICE_8I           0x0002
#define PCI_DEVICE_16I          0x0003
#define PCI_DEVICE_4Q           0x0004
#define PCI_DEVICE_8O           0x0005
#define PCI_DEVICE_8RJ          0x0006
#define PCI_DEVICE_4RJ          0x0007
#define PCI_DEVICE_SIEMENS8     0x0008
#define PCI_DEVICE_SIEMENS16    0x0009
#define PCI_DEVICE_RPLUS4       0x000a
#define PCI_DEVICE_RPLUS8       0x000b
#define PCI_DEVICE_RMODEM6      0x000c
#define PCI_DEVICE_RMODEM4      0x000d
#define PCI_DEVICE_RPLUS2       0x000e
#define PCI_DEVICE_422RPLUS2    0x000f

#define ISA_DEVICE_RPORT4       0x1001
#define ISA_DEVICE_RPORT8       0x1002
#define ISA_DEVICE_RPORT16      0x1003
#define ISA_DEVICE_RPORT32      0x1004
#define ISA_DEVICE_RMODEM4      0x2001
#define ISA_DEVICE_RMODEM8      0x2002
#define NET_DEVICE_VS1000       0x3001  // 16 to 64 port
#define NET_DEVICE_VS2000       0x3002  // 8 port
#define NET_DEVICE_RHUB8        0x3003
#define NET_DEVICE_RHUB4        0x3004

// ids for Our_Option.var_type
#define OP_T_DWORD  0
#define OP_T_STRING 1
#define OP_T_BOOL   2

// flags for Our_Option.flags
#define OP_F_VS             1
#define OP_F_RK             2
#define OP_F_VSRK           3
#define OP_F_SETUP_ONLY     8

typedef struct {
  const char * name;  // name of option see lists
  int id;     // unique id, also has bit which tells option type.
  WORD var_type;  // see OP_T_* types, 0=DWORD, 1=String, 2=BOOL
  WORD    flags;  // see OP_F_* types
} Our_Options;

// driver options
extern const char szVerboseLog[]   ;
extern const char szNumDevices[]   ;
extern const char szNoPnpPorts[]   ;
extern const char szScanRate[]     ;
extern const char szModemCountry[] ;
extern const char szGlobalRS485[]  ;

#define OP_VerboseLog    0x100
#define OP_NumDevices    0x101
#define OP_NoPnpPorts    0x102
#define OP_ScanRate      0x103
#define OP_ModemCountry  0x104
#define OP_GlobalRS485   0x105

// device options
//extern const char szStartComIndex[] ;
extern const char szNumPorts[]      ;
extern const char szMacAddr[]       ;
extern const char szBackupServer[]  ;
extern const char szBackupTimer[]   ;
extern const char szName[]          ;
extern const char szModelName[]     ;
extern const char szIoAddress[]     ;
extern const char szModemDevice[]   ;
extern const char szHubDevice[]     ;

//#define OP_StartComIndex   0x200
#define OP_NumPorts        0x201
#define OP_MacAddr         0x202
#define OP_BackupServer    0x203
#define OP_BackupTimer     0x204
#define OP_Name            0x205
#define OP_ModelName       0x206
#define OP_IoAddress       0x207
#define OP_ModemDevice     0x208
#define OP_HubDevice       0x209

// port options
extern const char szWaitOnTx[]      ;
extern const char szRS485Override[] ;
extern const char szRS485Low[]      ;
extern const char szTxCloseTime[]   ;
extern const char szLockBaud[]      ;
extern const char szMap2StopsTo1[]  ;
extern const char szMapCdToDsr[]    ;
extern const char szRingEmulate[]   ;
  	
#define OP_WaitOnTx         0x400
#define OP_RS485Override    0x401
#define OP_RS485Low         0x402
#define OP_TxCloseTime      0x403
#define OP_LockBaud         0x404
#define OP_Map2StopsTo1     0x405
#define OP_MapCdToDsr       0x406
#define OP_PortName         0x407
#define OP_RingEmulate      0x408

extern Our_Options driver_options[];
extern Our_Options device_options[];
extern Our_Options port_options[];

int HdwIDStrToID(int *Hardware_ID, char *idstr);
int id_to_num_ports(int id);
int IsHubDevice(int Hardware_ID);
int IsModemDevice(int Hardware_ID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\portprop.c ===
/*-------------------------------------------------------------------
| portprop.c - Port Properties Sheet.
|--------------------------------------------------------------------*/
#include "precomp.h"

#define D_Level 0x10
static void set_field(HWND hDlg, WORD id);
static void get_field(HWND hDlg, WORD id);
//static int PaintIcon(HWND hWnd);

#define MAX_PORTPROP_SHEETS       3
#define QUERYSIB_CLONE_PORT_PROPS 1
#define CLONEOPT_ALL              1   // clone to all ports
#define CLONEOPT_DEVICE           2   // clone to all ports on selected device
#define CLONEOPT_SELECT           3   // clone to selected ports (lParam = *list)

int FillPortPropSheets(PROPSHEETPAGE *psp, LPARAM our_params);
BOOL WINAPI PortPropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam);
BOOL WINAPI PortProp485Sheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam);
BOOL WINAPI PortPropModemSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam);

static int our_port_index   = 0;
static int our_device_index = 0;
static int num_active_portprop_sheets = 1;  // always at least one

/*------------------------------------------------------------------------
| FillPortPropSheets - Setup pages for driver level property sheets.
|------------------------------------------------------------------------*/
int FillPortPropSheets(PROPSHEETPAGE *psp, LPARAM our_params)
{
  INT pi;
  static TCHAR portsetstr[40], rs485str[40], modemstr[40];

  memset(psp, 0, sizeof(*psp) * MAX_PORTPROP_SHEETS);

  pi = 0;

  //----- main prop device sheet.
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_PORT_OPTIONS);
  psp[pi].pfnDlgProc = PortPropSheet;
  load_str( glob_hinst, (TITLESTR+4), portsetstr, CharSizeOf(portsetstr) );
  psp[pi].pszTitle = portsetstr;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;
  num_active_portprop_sheets = 1;

  //----- rs-485 prop device sheet.
  if (((strstr(wi->dev[glob_info->device_selected].ModelName, "485")) &&
       (our_port_index < 2)) ||
      (wi->GlobalRS485 == 1))
  {
    psp[pi].dwSize = sizeof(PROPSHEETPAGE);
    //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
    psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
    psp[pi].hInstance = glob_hinst;
    psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_PORT_485_OPTIONS);
    psp[pi].pfnDlgProc = PortProp485Sheet;
    load_str( glob_hinst, (TITLESTR+5), rs485str, CharSizeOf(rs485str) );
    psp[pi].pszTitle = rs485str;
    psp[pi].lParam = (LPARAM)our_params;
    psp[pi].pfnCallback = NULL;
    ++pi;
    ++num_active_portprop_sheets;
  }


  //----- modem prop device sheet.
  if (wi->dev[glob_info->device_selected].ModemDevice)
  {
    psp[pi].dwSize = sizeof(PROPSHEETPAGE);
    //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
    psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
    psp[pi].hInstance = glob_hinst;
    psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_PORT_MODEM_OPTIONS);
    psp[pi].pfnDlgProc = PortPropModemSheet;
    load_str( glob_hinst, (TITLESTR+6), modemstr, CharSizeOf(modemstr) );
    psp[pi].pszTitle = modemstr;
    psp[pi].lParam = (LPARAM)our_params;
    psp[pi].pfnCallback = NULL;
    ++pi;
    ++num_active_portprop_sheets;
  }

  return 0;
}

/*------------------------------------------------------------------------
| DoPortPropPages - Main driver level property sheet for NT4.0
|------------------------------------------------------------------------*/
int DoPortPropPages(HWND hwndOwner, int device, int port)
{
  PROPSHEETPAGE psp[MAX_PORTPROP_SHEETS];
  PROPSHEETHEADER psh;
  OUR_INFO *our_params;
  INT stat;
  Port_Config *pc;
  char title[40];

    wi->ChangesMade = 1;  // indicate changes made, as send_to_driver
                          // does not calculate this yet

    our_port_index   = port;
    our_device_index = device;

    pc = &wi->dev[our_device_index].ports[our_port_index];
    strcpy(title, pc->Name);
    strcat(title, RcStr(MSGSTR+29));

    our_params = glob_info;  // temporary kludge, unless we don't need re-entrantancy

    //Fill out the PROPSHEETPAGE data structure for the Client Area Shape
    //sheet
    FillPortPropSheets(&psp[0], (LPARAM)our_params);

    //Fill out the PROPSHEETHEADER
    memset(&psh, 0, sizeof(PROPSHEETHEADER));

    psh.dwSize = sizeof(PROPSHEETHEADER);
    //psh.dwFlags = PSH_USEICONID | PSH_PROPSHEETPAGE;
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndOwner;
    psh.hInstance = glob_hinst;
    psh.pszIcon = "";
    psh.pszCaption = (LPSTR) title; //"Port Properties";
    //psh.nPages = NUM_PORTPROP_SHEETS;
    psh.nPages = num_active_portprop_sheets;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    //And finally display the dialog with the property sheets.

    stat = PropertySheet(&psh);
  return 0;
}

/*----------------------------------------------------------
 context_menu -
|------------------------------------------------------------*/
static void context_menu(void)
{
  HMENU hpop_menu;
  POINT scr_pt;
  int stat;
  scr_pt.x = 200;
  scr_pt.y = 200;

  hpop_menu = CreatePopupMenu();
  if (hpop_menu == NULL)
  {
    mess(&wi->ip, "Error from CreatePopMenu");
    return;
  }
  //AppendMenu(hpop_menu,  0, 0x10, "Run Peer tracer");
  AppendMenu(hpop_menu,  0, 0x11, "Run Wcom Test Terminal");

  GetCursorPos(&scr_pt);

  stat = TrackPopupMenuEx(hpop_menu,
                     TPM_NONOTIFY | TPM_RETURNCMD, /* flags */
                     scr_pt.x, scr_pt.y, /* x,y */
                     //0, /* 0 reserved */
                     glob_hwnd,
                     NULL);

  GetSystemDirectory(gtmpstr,144);
  strcat(gtmpstr, "\\");
  strcat(gtmpstr, OurAppDir);
  SetCurrentDirectory(gtmpstr);

  if (stat == 0x11)
  {
    strcat(gtmpstr, "\\wcom32.exe \\\\.\\");
    strcat(gtmpstr, wi->dev[our_device_index].ports[our_port_index].Name);
  }
  WinExec(gtmpstr, SW_RESTORE);

  DestroyMenu(hpop_menu);
}

/*----------------------------------------------------------
 PortPropSheet - Dlg window procedure for add on Advanced sheet.
|-------------------------------------------------------------*/
BOOL WINAPI PortPropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
 OUR_INFO * OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);
 WORD uCmd;

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
 
      // save in case of cancel
      //memcpy(&org_pc, &wi->dev[our_device_index].ports[our_port_index],
      //  sizeof(org_pc));

      set_field(hDlg, IDC_PORT_LOCKBAUD     );
      set_field(hDlg, IDC_PORT_WAIT_ON_CLOSE);
      set_field(hDlg, IDC_PORT_WONTX        );
      set_field(hDlg, IDC_MAP_CDTODSR       );
      set_field(hDlg, IDC_MAP_2TO1          );
      set_field(hDlg, IDC_RING_EMULATE      );

                  //  Return TRUE to set focus to first control
    return TRUE;  // No need for us to set the focus.

    case PSM_QUERYSIBLINGS :
    {
      switch (HIWORD(wParam))
      {
        case QUERYSIB_CLONE_PORT_PROPS :
        {
          // low word of wParam is which ports to clone to...
          // currently we only support "all", but this is the place to add
          // other specific handling.
          int devnum;
          int portnum;
          Port_Config *srcport, *destport;

          #ifdef DEBUG
            char debugstr[80];
          #endif

          // make sure we have current values before cloning
          get_field(hDlg, IDC_PORT_LOCKBAUD     );
          get_field(hDlg, IDC_PORT_WAIT_ON_CLOSE);
          get_field(hDlg, IDC_PORT_WONTX        );
          get_field(hDlg, IDC_MAP_CDTODSR       );
          get_field(hDlg, IDC_MAP_2TO1          );
          get_field(hDlg, IDC_RING_EMULATE      );

          srcport = &wi->dev[our_device_index].ports[our_port_index];

          switch (LOWORD(wParam))
          {
            case CLONEOPT_ALL:
            {
              // apply the options on this page to all other ports
              for (devnum = 0; devnum < wi->NumDevices; devnum++)
              {
                for (portnum = 0; portnum < wi->dev[devnum].NumPorts; portnum++)
                {
                  destport = &wi->dev[devnum].ports[portnum];

                  // is it target different than the source?
                  if (destport != srcport)
                  {
                    // yep, so apply the source's options to the target
                    DbgPrintf(D_Level,
                       (TEXT("cloning general options from port %s to port %s\n"),
                       srcport->Name, destport->Name));

                    destport->LockBaud      = srcport->LockBaud;
                    destport->TxCloseTime   = srcport->TxCloseTime;
                    destport->WaitOnTx      = srcport->WaitOnTx;
                    destport->MapCdToDsr    = srcport->MapCdToDsr;
                    destport->Map2StopsTo1  = srcport->Map2StopsTo1;
                    destport->RingEmulate   = srcport->RingEmulate;
                  }
                }
              }
              break;
            }

            case CLONEOPT_DEVICE:
            {
              // apply the options on this page to all other ports on same device
              /* not yet implemented */
              break;
            }

            case CLONEOPT_SELECT:
            {
              // apply the options on this page to the list of selected ports
              // lParam is a pointer to a list of ports.
              /* not yet implemented */
              break;
            }

            default:
              // unknown clone option -- skip it
              break;
          }

          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          return TRUE;
          break;
        }

      default :
      return FALSE;
      }
    }

    case WM_COMMAND :
#ifdef WIN32
      uCmd = HIWORD(wParam);
#else
      uCmd = HIWORD(lParam);
#endif

      switch (LOWORD(wParam))
      {
        case IDB_DEF:  // actually the defaults button
        {
          Port_Config *pc;
          pc= &wi->dev[our_device_index].ports[our_port_index];
 
          //pc->options  = 0;

          pc->RingEmulate = 0;
          pc->MapCdToDsr = 0;
          pc->WaitOnTx = 0;
          pc->Map2StopsTo1 = 0;
          pc->LockBaud = 0;
          pc->TxCloseTime = 0;
          // should we be doing this?  they are on another page(kpb)
          pc->RS485Override = 0;
          pc->RS485Low = 0;

          set_field(hDlg, IDC_PORT_LOCKBAUD     );
          set_field(hDlg, IDC_PORT_WAIT_ON_CLOSE);
          set_field(hDlg, IDC_PORT_WONTX        );
          set_field(hDlg, IDC_MAP_CDTODSR       );
          set_field(hDlg, IDC_MAP_2TO1          );
          set_field(hDlg, IDC_RING_EMULATE      );
        }
        break;
      }
    return FALSE;

    case WM_PAINT:
#if 0
          PaintIcon(hDlg);
#endif
    return FALSE;

    case WM_HELP:            // question mark thing
      our_context_help(lParam);
    return FALSE;

    case WM_CONTEXTMENU:     // right-click
      context_menu();
    break;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_HELP :
          our_help(&wi->ip, IDD_PORT_OPTIONS);
        break;

        case PSN_APPLY :
 
          get_field(hDlg, IDC_PORT_LOCKBAUD     );
          get_field(hDlg, IDC_PORT_WAIT_ON_CLOSE);
          get_field(hDlg, IDC_PORT_WONTX        );
          get_field(hDlg, IDC_MAP_CDTODSR       );
          get_field(hDlg, IDC_MAP_2TO1          );
          get_field(hDlg, IDC_RING_EMULATE      );

          if (IsDlgButtonChecked(hDlg, IDC_CLONE))
          {
            PropSheet_QuerySiblings(GetParent(hDlg),
                                    (WPARAM)((QUERYSIB_CLONE_PORT_PROPS << 16) + CLONEOPT_ALL),
                                    0);
          }

          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          return TRUE;

        default :
        return FALSE;
      }
    break;

    default :
    // return FALSE;
	  break;
  }
  return FALSE;
}

/*----------------------------------------------------------
 PortProp485Sheet -
|-------------------------------------------------------------*/
BOOL WINAPI PortProp485Sheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
 OUR_INFO * OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);
 WORD uCmd;

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
  
      // save in case of cancel
      //memcpy(&org_pc, &wi->dev[our_device_index].ports[our_port_index],
      //  sizeof(org_pc));

      set_field(hDlg, IDC_PORT_RS485_TLOW   );
      set_field(hDlg, IDC_PORT_RS485_LOCK   );

                  //  Return TRUE to set focus to first control
    return TRUE;  // No need for us to set the focus.

    case PSM_QUERYSIBLINGS :
    {
      switch (HIWORD(wParam))
      {
        case QUERYSIB_CLONE_PORT_PROPS :
        {
          // low word of wParam is which ports to clone to...
          // currently we only support "all", but this is the place to add
          // other specific handling.
          int devnum;
          int portnum;
          Port_Config *srcport, *destport;

          #ifdef DEBUG
            char debugstr[80];
          #endif

          // make sure we have current values before cloning
          get_field(hDlg, IDC_PORT_RS485_TLOW   );
          get_field(hDlg, IDC_PORT_RS485_LOCK   );

          srcport = &wi->dev[our_device_index].ports[our_port_index];

          switch (LOWORD(wParam))
          {
            case CLONEOPT_ALL:
            {
              int maxport;

              // apply the options on this page to all other ports
              for (devnum = 0; devnum < wi->NumDevices; devnum++)
              {
                if ((strstr(wi->dev[devnum].ModelName, "485")) ||
                    (wi->GlobalRS485 == 1))
                {
                  // we're only going to apply RS485 settings to other
                  // 485 boards (unless the global RS485 flag is on)
                  if (wi->GlobalRS485 == 1)
                    maxport = wi->dev[devnum].NumPorts;
                  else
                    maxport = 2;
                  for (portnum = 0; portnum < maxport; portnum++)
                  {
                    destport = &wi->dev[devnum].ports[portnum];

                    // is it target different than the source?
                    if (destport != srcport)
                    {
                      // yep, so apply the source's options to the target
                      DbgPrintf(D_Level,
                       (TEXT("cloning rs-485 options from port %s to port %s\n"),
                       srcport->Name, destport->Name));

                      destport->RS485Low      = srcport->RS485Low;
                      destport->RS485Override = srcport->RS485Override;
                    }
                  }
                }
              }
              break;
            }

            case CLONEOPT_DEVICE:
            {
              // apply the options on this page to all other ports on same device
              /* not yet implemented */
              break;
            }

            case CLONEOPT_SELECT:
            {
              // apply the options on this page to the list of selected ports
              // lParam is a pointer to a list of ports.
              /* not yet implemented */
              break;
            }

            default:
              // unknown clone option -- skip it
              break;
          }

          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          return TRUE;
          break;
        }

      default :
      return FALSE;
      }
    }

    case WM_COMMAND :
#ifdef WIN32
      uCmd = HIWORD(wParam);
#else
      uCmd = HIWORD(lParam);
#endif

      switch (LOWORD(wParam))
      {
        case IDB_DEF:  // actually the defaults button
        {
          Port_Config *pc;
          pc= &wi->dev[our_device_index].ports[our_port_index];
          // pc->options  = 0;

          pc->RS485Override = 0;
          pc->RS485Low = 0;

          set_field(hDlg, IDC_PORT_RS485_TLOW   );
          set_field(hDlg, IDC_PORT_RS485_LOCK   );
        }
        break;
      }
    return FALSE;

    case WM_PAINT:
#if 0
      PaintIcon(hDlg);
#endif
    return FALSE;

    case WM_HELP:            // question mark thing
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_HELP :
          our_help(&wi->ip, IDD_PORT_485_OPTIONS);
        break;

        case PSN_APPLY :
          get_field(hDlg, IDC_PORT_RS485_TLOW   );
          get_field(hDlg, IDC_PORT_RS485_LOCK   );
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

        default :
        return FALSE;
      }
    default :
        return FALSE;
  }
}

/*----------------------------------------------------------
 request_modem_reset -
|-------------------------------------------------------------*/

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)
#define METHOD_BUFFERED                 0
#define FILE_ANY_ACCESS                 0
#define FILE_DEVICE_SERIAL_PORT         0x0000001b

#define IOCTL_RCKT_SET_MODEM_RESET \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x80d,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_CLEAR_MODEM_RESET \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x80e,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_SEND_MODEM_ROW \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x80f,METHOD_BUFFERED,FILE_ANY_ACCESS)

void request_modem_reset(int device_index, int port_index)
{
  HANDLE hDriver;     // file handle to driver device
  Port_Config *pc;    // config information about the port to reset
  ULONG retBytes;

  // attempt to open communications with the driver
  hDriver = CreateFile(szDriverDevice, GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE, 0,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
  if (hDriver != INVALID_HANDLE_VALUE)
  {
    // double-check that it is a modem device!
    if (wi->dev[device_index].ModemDevice)
    {
      pc = &wi->dev[device_index].ports[port_index];

      // send the ioctl to put the modem into the reset state
      DeviceIoControl(hDriver, IOCTL_RCKT_SET_MODEM_RESET,
                      pc->Name, sizeof(pc->Name),
                      pc->Name, sizeof(pc->Name),
                      &retBytes, 0);

      // delay briefly before pulling modem out of reset state
      Sleep(45);

      // send the ioctl to pull the modem out of reset state
      DeviceIoControl(hDriver, IOCTL_RCKT_CLEAR_MODEM_RESET,
                      pc->Name, sizeof(pc->Name),
                      pc->Name, sizeof(pc->Name),
                      &retBytes, 0);

      Sleep(65);

      // if country code is North America or invalid, we're done
      // if country code is default or invalid, we're done
      if (
      (wi->ModemCountry)
      &&
      ( (wi->dev[device_index].ModemDevice == TYPE_RM_VS2000)
        &&
        (wi->ModemCountry != RowInfo[0].RowCountryCode))
      ||
      ( (wi->dev[device_index].ModemDevice == TYPE_RM_i)
        &&
        (wi->ModemCountry != CTRRowInfo[0].RowCountryCode))
      ) {
        // wait for the modem to stablize before sending country code command
        // (about 4 seconds!)
        Sleep(4000);

        // send the ioctl to configure the country code
        DeviceIoControl(hDriver, IOCTL_RCKT_SEND_MODEM_ROW,
                        pc->Name, sizeof(pc->Name),
                        pc->Name, sizeof(pc->Name),
                        &retBytes, 0);

      }
    }

    // close communications with the driver
    CloseHandle(hDriver);
  }
}

/*----------------------------------------------------------
 PortPropModemSheet -
|-------------------------------------------------------------*/
BOOL WINAPI PortPropModemSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
 OUR_INFO * OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);
 WORD uCmd;

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
  
      // save in case of cancel
      //memcpy(&org_pc, &wi->dev[our_device_index].ports[our_port_index],
      //  sizeof(org_pc));

      if (wi->dev[our_device_index].ModemDevice)
      {
        // parent device for this port provides modems, enable reset button
        EnableWindow(GetDlgItem(hDlg, IDB_RESET), 1);
      }
      else
      {
        // parent device for this port has no modems, disable the reset button
        EnableWindow(GetDlgItem(hDlg, IDB_RESET), 0);
      }

                  //  Return TRUE to set focus to first control
    return TRUE;  // No need for us to set the focus.

    case WM_COMMAND :
#ifdef WIN32
      uCmd = HIWORD(wParam);
#else
      uCmd = HIWORD(lParam);
#endif

      switch (LOWORD(wParam))
      {
        case IDB_RESET:
          request_modem_reset(our_device_index, our_port_index);
        break;
      }
    return FALSE;

    case WM_PAINT:
#if 0
      PaintIcon(hDlg);
#endif
    return FALSE;

    case WM_HELP:            // question mark thing
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_HELP :
          our_help(&wi->ip, IDD_PORT_MODEM_OPTIONS);
        break;

        case PSN_APPLY :
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

        default :
        return FALSE;
      }
    default :
        return FALSE;
  }
}

/*-------------------------------------------------------------------
| get_field - Run when a selection is changed.
|--------------------------------------------------------------------*/
static void get_field(HWND hDlg, WORD id)
{
 char tmpstr[60];
 int i;
  Port_Config *pc;
//  HWND hwnd;

  pc= &wi->dev[our_device_index].ports[our_port_index];

  switch (id)
  {
    case IDC_PORT_LOCKBAUD:
      GetDlgItemText(hDlg, id, tmpstr, 58);
      pc->LockBaud = getint(tmpstr, &i);
    break;

    case IDC_PORT_WAIT_ON_CLOSE:
      GetDlgItemText(hDlg, id, tmpstr, 58);
      pc->TxCloseTime = getint(tmpstr, &i);
    break;

    case IDC_PORT_WONTX:
      if (IsDlgButtonChecked(hDlg, IDC_PORT_WONTX))
           pc->WaitOnTx = 1;
      else pc->WaitOnTx = 0;
    break;
    case IDC_PORT_RS485_TLOW:
      if (IsDlgButtonChecked(hDlg, IDC_PORT_RS485_TLOW))
           pc->RS485Low = 1;
      else pc->RS485Low = 0;
    break;
    case IDC_PORT_RS485_LOCK:
      if (IsDlgButtonChecked(hDlg, IDC_PORT_RS485_LOCK))
           pc->RS485Override = 1;
      else pc->RS485Override = 0;
    break;
    case IDC_MAP_CDTODSR:
      if (IsDlgButtonChecked(hDlg, IDC_MAP_CDTODSR))
           pc->MapCdToDsr = 1;
      else pc->MapCdToDsr = 0;
    break;
    case IDC_MAP_2TO1:
      if (IsDlgButtonChecked(hDlg, IDC_MAP_2TO1))
           pc->Map2StopsTo1 = 1;
      else pc->Map2StopsTo1 = 0;
    break;
    case IDC_RING_EMULATE :
      if (IsDlgButtonChecked(hDlg, IDC_RING_EMULATE))
           pc->RingEmulate = 1;
      else pc->RingEmulate = 0;
    break;
  }
}

/*----------------------------------------------------------
 set_field -
|------------------------------------------------------------*/
static void set_field(HWND hDlg, WORD id)
{
  HWND hwnd;
  char tmpstr[60];
  Port_Config *pc;

  if (our_device_index >= wi->NumDevices)
    our_device_index = 0;
  pc = &wi->dev[our_device_index].ports[our_port_index];

  //------------------ fill in name selection
  //SetDlgItemText(hDlg, IDC_, pc->Name);
  switch(id)
  {
    case IDC_PORT_LOCKBAUD:
      //------------------ fill in baud override selection
      hwnd = GetDlgItem(hDlg, IDC_PORT_LOCKBAUD);
      SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) RcStr(MSGSTR+22));
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "57600");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "115200");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "230400");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "460800");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "921600");
      wsprintf(tmpstr, "%d", pc->LockBaud);
      if (pc->LockBaud == 0)
        strcpy(tmpstr,RcStr(MSGSTR+22));
      SetDlgItemText(hDlg, IDC_PORT_LOCKBAUD, tmpstr);
    break;

    case IDC_PORT_RS485_LOCK:
      //------------------ fill in "rs485 override?" option
      SendDlgItemMessage(hDlg, IDC_PORT_RS485_LOCK, BM_SETCHECK,
        pc->RS485Override, 0);
    break;

    case IDC_MAP_CDTODSR:
      //------------------ fill in "map CD to DSR?" option
      SendDlgItemMessage(hDlg, IDC_MAP_CDTODSR, BM_SETCHECK,
        pc->MapCdToDsr, 0);
    break;

    case IDC_MAP_2TO1:
      //------------------ fill in "map 2 to 1 stops?" option
      SendDlgItemMessage(hDlg, IDC_MAP_2TO1, BM_SETCHECK,
        pc->Map2StopsTo1, 0);
    break;

    case IDC_PORT_RS485_TLOW:
      //------------------ fill in "rs485 toggle low?" option
      SendDlgItemMessage(hDlg, IDC_PORT_RS485_TLOW, BM_SETCHECK,
        pc->RS485Low, 0);
    break;

    case IDC_PORT_WONTX:
      //------------------ fill in "wait on tx?" option
      SendDlgItemMessage(hDlg, IDC_PORT_WONTX, BM_SETCHECK,
        pc->WaitOnTx, 0);
    break;

    case IDC_PORT_WAIT_ON_CLOSE:
      //------------------ fill in wait on tx close option
      hwnd = GetDlgItem(hDlg, IDC_PORT_WAIT_ON_CLOSE);
      SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) RcStr(MSGSTR+23));
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) RcStr(MSGSTR+24));
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) RcStr(MSGSTR+25));
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) RcStr(MSGSTR+26));
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) RcStr(MSGSTR+27));
      // no, need some better way to default this to 1 or 2 seconds
      //if (pc->TxCloseTime == 0)
      //   strcpy(tmpstr, "1 sec");  // 0 means to the driver same as 6-seconds
      wsprintf(tmpstr, "%d %s", pc->TxCloseTime, RcStr(MSGSTR+28));
      SetDlgItemText(hDlg, IDC_PORT_WAIT_ON_CLOSE, tmpstr);
    break;

    case IDC_RING_EMULATE:
      SendDlgItemMessage(hDlg, IDC_RING_EMULATE, BM_SETCHECK,
        pc->RingEmulate, 0);
    break;
  }
}

#if 0
/*---------------------------------------------------------------------------
  PaintIcon - Paints the Icon in the property sheet.
|---------------------------------------------------------------------------*/
static int PaintIcon(HWND hWnd)
{
//   int status;
   HBITMAP      hBitMap;
   HGDIOBJ      hGdiObj;
   HDC          hDC, hMemDC ;
   PAINTSTRUCT  ps ;
   RECT spot, main;  // left, top, right, bottom
   static int cnt = 0;

  GetWindowRect(GetDlgItem(hWnd, IDB_DEF), &spot);
  GetWindowRect(hWnd, &main);
#ifdef COMMENT_OUT
  rect = &right;
  mess("hlp r:%d l:%d b:%d t:%d",
       rect->right, rect->left, rect->bottom, rect->top);
#endif
  spot.left -= main.left;
  spot.top -= main.top;

  spot.left += 5;
  spot.top  += 20; // spacing

   // load bitmap and display it

   hDC = BeginPaint( hWnd, &ps ) ;
   if (NULL != (hMemDC = CreateCompatibleDC( hDC )))
   {
      hBitMap = LoadBitmap(glob_hinst,
                           MAKEINTRESOURCE(BMP_SMALL_LOGO));

      hGdiObj = SelectObject(hMemDC, hBitMap);

      BitBlt( hDC, spot.left, spot.top, 100, 100, hMemDC, 0, 0, SRCCOPY ) ;
      //StretchBlt( hDC, 5, 5, 600,100, hMemDC, 0, 0, 446, 85, SRCCOPY ) ;
      DeleteObject( SelectObject( hMemDC, hGdiObj ) ) ;
      DeleteDC( hMemDC ) ;
   }
   EndPaint( hWnd, &ps ) ;
 return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\precomp.h ===
/*** #include <windowsx.h> ***/
#define STRICT
#include <windows.h>
#include <stdio.h>
#include <direct.h>
#include <stdlib.h>
#include <malloc.h>
#include <ctype.h>
#include <tchar.h>
#include <string.h>
#include <setupapi.h>

//#include <comutils.h>
#include "comutils.h"
#include "setupu.h"
#include "ourver.h"
#include "setup.h"
#ifdef NT50
#include <cfgmgr32.h>
#include <htmlhelp.h>
#include "nt50.h"
#endif
#include "nt40.h"
#include "resource.h"
#include "rocku.h"
#include "devprop.h"
#include "dripick.h"
#include "driprop.h"
#include "portprop.h"
#include "addwiz.h"
#include "strings.h"
#include "opstr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\opstr.c ===
/*-----------------------------------------------------------------------
 opstr.c - Option Strings.  These are strings which define the options
  associated with the driver at the three levels: driver, device, port.
  This code is special, in that the source may be used for both driver
  and setup program, so consists only of the strings which can be shared
  in source code.

  This has expanded to other code which should be shared by
  both setup program and driver.

Copyright 1998 Comtrol(TM) Corporation.
|-----------------------------------------------------------------------*/
#include "precomp.h"

// driver options
const char szVerboseLog[]   = {"VerboseLog"};
const char szNumDevices[]   = {"NumDevices"};
const char szNoPnpPorts[]     = {"NoPnpPorts"};
const char szScanRate[]     = {"ScanRate"};
const char szModemCountry[] = {"ModemCountry"};
const char szGlobalRS485[]  = {"GlobalRS485Options"};

// device options
//const char szStartComIndex[] = {"StartComIndex"};
const char szNumPorts[]      = {"NumPorts"};
const char szMacAddr[]       = {"MacAddr"};
const char szBackupServer[]  = {"BackupServer"};
const char szBackupTimer[]   = {"BackupTimer"};
const char szName[]          = {"Name"};
const char szModelName[]     = {"ModelName"};
const char szIoAddress[]     = {"IoAddress"};
const char szModemDevice[]   = {"ModemDevice"};
const char szHubDevice[]     = {"HubDevice"};

// port options
const char szWaitOnTx[]      = {"WaitOnTx"};
const char szRS485Override[] = {"RS485Override"};
const char szRS485Low[]      = {"RS485Low"};
const char szTxCloseTime[]   = {"TxCloseTime"};
const char szLockBaud[]      = {"LockBaud"};
const char szMap2StopsTo1[]  = {"Map2StopsTo1"};
const char szMapCdToDsr[]    = {"MapCdToDsr"};
const char szRingEmulate[]    = {"RingEmulate"};

Our_Options driver_options[] = {
  // driver options
  {szVerboseLog,     OP_VerboseLog   , OP_T_DWORD, OP_F_VSRK},
  {szNumDevices,     OP_NumDevices   , OP_T_DWORD, OP_F_VSRK},
#ifdef NT50
  {szNoPnpPorts,       OP_NoPnpPorts     , OP_T_DWORD, OP_F_VSRK},
#endif
  {szScanRate,       OP_ScanRate     , OP_T_DWORD, OP_F_VSRK},
  {szModemCountry,   OP_ModemCountry , OP_T_DWORD, OP_F_VSRK},
  {szGlobalRS485,    OP_GlobalRS485  , OP_T_DWORD, OP_F_VSRK},
  {NULL,0,0,0}
};

Our_Options device_options[] = {
  // device options
//  {szStartComIndex,  OP_StartComIndex, OP_T_DWORD , OP_F_VSRK},
  {szNumPorts,       OP_NumPorts     , OP_T_DWORD , OP_F_VSRK},
#ifdef S_VS
  {szMacAddr,        OP_MacAddr      , OP_T_STRING, OP_F_VS},
  {szBackupServer,   OP_BackupServer , OP_T_DWORD , OP_F_VS},
  {szBackupTimer,    OP_BackupTimer  , OP_T_DWORD , OP_F_VS},
#endif
  {szName,           OP_Name         , OP_T_STRING, OP_F_VSRK},
  {szModelName,      OP_ModelName    , OP_T_STRING, OP_F_VSRK},
#ifdef S_RK
#ifndef NT50
  {szIoAddress,      OP_IoAddress    , OP_T_DWORD , OP_F_RK},
#endif
#endif
  {szModemDevice,    OP_ModemDevice  , OP_T_DWORD , OP_F_VSRK},
  {szHubDevice,      OP_HubDevice    , OP_T_DWORD , OP_F_VS},
  {NULL,0,0,0}
};

Our_Options port_options[] = {
  // port options
  {szWaitOnTx,       OP_WaitOnTx     , OP_T_DWORD,  OP_F_VSRK},
  {szRS485Override,  OP_RS485Override, OP_T_DWORD,  OP_F_VSRK},
  {szRS485Low,       OP_RS485Low     , OP_T_DWORD,  OP_F_VSRK},
  {szTxCloseTime,    OP_TxCloseTime  , OP_T_DWORD,  OP_F_VSRK},
  {szLockBaud,       OP_LockBaud     , OP_T_DWORD,  OP_F_VSRK},
  {szMap2StopsTo1,   OP_Map2StopsTo1 , OP_T_DWORD,  OP_F_VSRK},
  {szMapCdToDsr,     OP_MapCdToDsr   , OP_T_DWORD,  OP_F_VSRK},
  {szName,           OP_PortName     , OP_T_STRING, OP_F_VSRK},
  {szRingEmulate,    OP_RingEmulate  , OP_T_DWORD,  OP_F_VSRK},
  {NULL,0,0,0}
};

#define INFO_WANT_NUMPORTS        0
#define INFO_WANT_MODEM_DEVICE    1
#define INFO_WANT_HUB_DEVICE      2
#define INFO_WANT_PORTS_PER_AIOP  3
#define INFO_WANT_DEF_CLOCK_PRESC 4

static int IdToInfo(int id, int *ret_dword, int info_wanted);

/*-----------------------------------------------------------------
  IdToInfo -
|------------------------------------------------------------------*/
static int IdToInfo(int id, int *ret_val, int info_wanted)
{ 
 int num_ports = 8;
 int modem_device = 0;
 int hub_device = 0;
 int ret_stat = 0;  // ok
 
    switch (id)
    {
      case PCI_DEVICE_RPLUS2:
      case PCI_DEVICE_422RPLUS2:
        num_ports = 2;
      break;

      case PCI_DEVICE_RPLUS4:
        num_ports = 4;
      break;

      case PCI_DEVICE_4Q  :
        num_ports = 4;
      break;

      case PCI_DEVICE_RMODEM4:
        num_ports = 4;
        modem_device = 1;
      break;

      case PCI_DEVICE_8RJ :
        num_ports = 8;
      break;
      case PCI_DEVICE_4RJ :
        num_ports = 4;
      break;
      case PCI_DEVICE_8O  :
        num_ports = 8;
      break;
      case PCI_DEVICE_8I  :
        num_ports = 8;
      break;
      case PCI_DEVICE_RPLUS8:
        num_ports = 8;
      break;
      case PCI_DEVICE_SIEMENS8:
        num_ports = 8;
      break;

      case PCI_DEVICE_16I :
        num_ports = 16;
      break;
      case PCI_DEVICE_SIEMENS16:
        num_ports = 16;
      break;

      case PCI_DEVICE_32I :
        num_ports = 32;
      break;

      case PCI_DEVICE_RMODEM6 :
        num_ports = 6;
        modem_device = 1;
      break;

      case ISA_DEVICE_RPORT4:  // rocketport
        num_ports = 4;
      break;
      case ISA_DEVICE_RPORT8:
        num_ports = 8;
      break;
      case ISA_DEVICE_RPORT16:
        num_ports = 16;
      break;
      case ISA_DEVICE_RPORT32:
        num_ports = 32;
      break;

      case ISA_DEVICE_RMODEM4:  // rocketmodem isa
        num_ports = 4;
        modem_device = 1;
      break;
      case ISA_DEVICE_RMODEM8:  // rocketmodem isa
        num_ports = 8;
        modem_device = 1;
      break;
      case NET_DEVICE_VS1000:
        num_ports = 16;  // vs1000, base is 16, expandable
      break;
      case NET_DEVICE_VS2000:  // vs2000, base is 8?
        num_ports = 8;
        modem_device = 1;
      break;
      case NET_DEVICE_RHUB8:  // vshub-8 port
        num_ports = 8;
        hub_device = 1;
      break;
      case NET_DEVICE_RHUB4:  // vshub-4 port
        num_ports = 4;
        hub_device = 1;
      break;
      default:
        ret_stat = 1; // err, unknown device
      break;
    }

  switch (info_wanted)
  {
    case INFO_WANT_NUMPORTS:
      *ret_val = num_ports;
    break;

    case INFO_WANT_MODEM_DEVICE:
      *ret_val = modem_device;
    break;

    case INFO_WANT_HUB_DEVICE:
      *ret_val = hub_device;
    break;

#if 0
    case INFO_WANT_PORTS_PER_AIOP:
        if (PortsPerAiop > num_ports)
            PortsPerAiop = num_ports;
      *ret_val = PortsPerAiop;

    case INFO_WANT_DEF_CLOCK_PRESC:
      *ret_val = clk_prescaler;
    break;
#endif

    default:
      ret_stat = 2; // unkown info request
    break;
  }
  return ret_stat;
}

/*-----------------------------------------------------------------
  id_to_num_ports - pci model-id number used, rest come from NT5 .inf
    files.
|------------------------------------------------------------------*/
int id_to_num_ports(int id)
{ 
 int stat;
 int num_ports;

  stat = IdToInfo(id, &num_ports, INFO_WANT_NUMPORTS);
  return num_ports;
}

/*-----------------------------------------------------------------
  IsHubDevice -
|------------------------------------------------------------------*/
int IsHubDevice(int Hardware_ID)
{ 
 int stat;
 int ishub;

  stat = IdToInfo(Hardware_ID, &ishub, INFO_WANT_HUB_DEVICE);
  return ishub;
}

/*-----------------------------------------------------------------
  IsModemDevice -
|------------------------------------------------------------------*/
int IsModemDevice(int Hardware_ID)
{ 
 int stat;
 int ismodemdev;

  stat = IdToInfo(Hardware_ID, &ismodemdev, INFO_WANT_MODEM_DEVICE);
  return ismodemdev;
}

/*-----------------------------------------------------------------
  HdwIDStrToID - Parse the hardware ID string obtained by the WinNT
    Pnp system.
    This is broke if we ever get ID's starting digit >= HEX(A,B..)
|------------------------------------------------------------------*/
int HdwIDStrToID(int *Hardware_ID, char *idstr)
{ 
  char *s = idstr;
#define _IS_STR_DIGIT(c) ((c >= '0') && (c <= '9'))
#define _IS_STR_LET_D(c) ((c == 'D') || (c == 'd'))

  if (strlen(s) < 12)  // a isa hardware id
  {
    while ( (*s != 0) && (!_IS_STR_DIGIT(*s)) )  // find digit
      ++s;
  }
  else // a pci hardware id
  {
    while ( (*s != 0) && (!_IS_STR_LET_D(*s)) ) // find "DEV_
      ++s;
    if (*s != 0)
      ++s;  // pass up the 'D'
    while ( (*s != 0) && (!_IS_STR_DIGIT(*s)) )  // find digit
      ++s;
    // asume we found "DEV_000X"
  }

  if (*s == 0)
  {
    *Hardware_ID = 0;  // unknown
    return 1;  // err
  }

  *Hardware_ID = gethint(s, NULL);
  return 0;  // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\rocku.h ===
/* rocku.h */

int copy_files_nt(InstallPaths *ip);
int clear_nt_device(Driver_Config *wi);

int get_nt_config(Driver_Config *wi);
int set_nt_config(Driver_Config *wi);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SETUP.RC
//
#define IDD_DIALOG1                     101
#define SETUPICON_ALT                   102
#define IDD_ADD_WIZ_INTRO               104
#define IDD_ADD_WIZ_COUNTRY             105
#define IDD_ADD_WIZ_DONE                106
#define IDD_ADD_WIZ_NUMPORTS            107
#define IDD_PORT_MODEM_OPTIONS          108
#define IDD_ADD_WIZ_DEVICE              110
#define IDD_ADD_WIZ_MAC                 111
#define IDD_ADD_WIZ_BACKUP              112
#define IDM_CLOSE                       200
#define IDM_EXIT                        201
#define IDM_PM                          202
#define IDM_STATS                       203
#define IDM_EDIT_README                 204
#define IDM_ADVANCED                    205
#define IDM_HELP                        206
#define IDM_HELPABOUT                   207
#define IDM_ADVANCED_NAMES              208
#define IDM_ADVANCED_MODEM_INF          209
#define IDM_F1                          220
#define IDC_LBOX_DEVICE                 308
#define IDC_EB_NAME                     309
#define IDC_CBOX_NUMPORTS               311
#define IDC_CBOX_MACADDR                312
#define IDC_CBOX_IRQ                    313
#define IDC_CBOX_SC                     314
#define IDC_CBOX_TYPE                   315
#define IDC_BACKUP_SERVER               316
#define IDC_BACKUP_TIMER                317
#define IDC_CBOX_IOADDR                 318
#define IDC_USE_IRQ                     319
#define IDD_MAIN_DLG                    450
#define IDD_DRIVER_OPTIONS              451
#define IDD_DRIVER_OPTIONS_NT50         452
#define IDD_DEVICE_SETUP                453
#define IDD_VS_DEVICE_SETUP             454
#define IDD_PORTLIST_PICK               455
#define IDD_PORT_OPTIONS                456
#define IDD_PORT_485_OPTIONS            457
#define IDD_ADD_WIZ_BUSTYPE             458
#define IDD_ADD_WIZ_BOARD               459
#define IDD_ADD_WIZ_BASEIO              460
#define BMP_FULL_LOGO                   500
#define BMP_SMALL_LOGO                  501
#define BMP_BOARDS                      502
#define BMP_PORTSM                      503
#define BMP_VS_FULL_LOGO_NT50           504
#define BMP_VS_FULL_LOGO                505
#define BMP_VS_BOX                      506
#define BMP_COMTROL_LOGO                507
#define BMP_RKTMODEM_LOGO               508
#define BMP_RKTMODEMII_LOGO             509
#define BMP_RKTMODEM_INTL_LOGO          510
#define BMP_RKTPORT_LOGO                511
#define BMP_RKTHUB_LOGO                 512

#define TITLESTR  700
#define MSGSTR    710

#define IDC_PN3                         1004
#define IDC_PN2                         1005
#define IDC_PN1                         1006
#define IDC_GROUP                       1008
#define IDC_WIZ1_ISA                    1011
#define IDC_WIZ1_ISA2                   1012
#define IDC_WIZ_CBOX_COUNTRY            1012
#define IDC_WIZ_CBOX_NUMPORTS           1013
#define IDC_LBL_SUMMARY1                1014
#define IDC_LBL_SUMMARY2                1015
#define IDC_CLONE                       1016
#define IDD_STATUS                      1018
#define IDC_GLOBAL485                   1019
#define IDC_RKT_LOGO                    1020
#define IDC_VS_LOGO                     1021
#define IDC_WIZ_CBOX_MAC                1024
#define IDC_WIZ_DEVICE_SELECT           1025
#define IDC_WIZ_CBOX_DEVICE             1025
#define IDC_ST_STATE                    1026
#define IDC_ST_NIC_MAC                  1027
#define IDC_ST_NIC_DVC_NAME             1031
#define IDC_ST_VSL_STATE                1032
#define IDC_ST_VSL_MAC                  1033
#define IDC_ST_VSL_IFRAMES_RCVD         1036
#define IDC_ST_VSL_IFRAMES_SENT         1037
#define IDC_ST_NIC_PKT_RCVD_NOT_OURS    1038
#define IDC_ST_VSL_IFRAMES_RESENT       1039
#define IDC_ST_NIC_PKT_RCVD_OURS        1040
#define IDC_ST_NIC_PKT_SENT             1041
#define IDC_ST_VSL_IFRAMES_OUTOFSEQ     1042
#define IDC_ST_VSL_DETECTED             1043
#define IDC_ST_PM_LOADS                 1044
#define IDC_PS_PORT                     1046
#define IDC_WIZ_BACKUP_NO               1047
#define IDC_WIZ_BACKUP_YES              1048
#define IDC_WIZ_CBOX_BACKUPTIME         1049
#define IDC_CBOX_MAPBAUD                1084
#define IDC_CBOX_SCAN_RATE              1085
#define IDC_VERBOSE                     1086
#define IDC_PNP_PORTS                   1087
#define IDB_DEF                         1089
#define IDB_DONE                        1090
#define IDB_ADD                         1091
#define IDB_REMOVE                      1092
#define IDB_PROPERTIES                  1093
#define IDB_HELP                        1094
#define IDB_INSTALL                     1095
#define IDC_VERSION                     1096
#define IDM_OPTIONS                     1097
#define IDB_RESET                       1098
#define IDB_REFRESH                     1099
#define IDB_STAT_RESET                  1100
#define IDC_PORT_WONTX                  1150
#define IDC_PORT_RS485_TLOW             1151
#define IDC_PORT_RS485_LOCK             1152
#define IDC_PORT_WAIT_ON_CLOSE          1153
#define IDC_PORT_LOCKBAUD               1154
#define IDC_MAP_CDTODSR                 1155
#define IDC_MAP_2TO1                    1156
#define IDC_WIZ_ISA                     1180
#define IDC_WIZ_PCI                     1181
#define IDC_WIZ_BOARD_SELECT            1182
#define IDC_WIZ_CBOX_BOARD              1182
#define IDC_WIZ_CBOX_IOADDR             1183
#define IDC_RING_EMULATE                1184
#define IDS_INSTALL_GROUP               2500
#define IDS_AP_TITLE                    2501
#define IDS_MODEM_INF_ENTRY             2502
#define IDS_VS_INSTALL_GROUP            2503
#define IDS_VS_AP_TITLE                 2504
#define IDS_VS_MODEM_INF_ENTRY          2505
#define IDL_BASE_ADDR_LABEL             2506
#define IDL_ISA_BUS_LABEL               2507
#define IDC_STATIC                      -1
#define IDC_PN0                         -1
#define IDC_CONF                        -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1050
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\setup.c ===
/*-----------------------------------------------------------------------
| setup.c - VSLinkA/RocketPort Windows Install Program.
12-11-98 - use szAppTitle(.rc str) instead of aptitle for prop sheet title.
11-24-98 - zero out psh struct to ensure deterministic propsheet behavior. kpb
10-23-98 - in send_to_driver, fix ioctl_close() when inappropriate,
  caused crash on setup exit.
 9-25-98 - on nt4 uninstall, rename setup.exe to setupold.exe since
   we can't delete it.  This fixes backward compatibility problem.
Copyright 1998. Comtrol(TM) Corporation.
|-----------------------------------------------------------------------*/
#include "precomp.h"

#define D_Level 0x100

static int option_changed(char *value_str,
                   int *ret_chg_flag,
                   int *ret_unknown_flag,
                   Our_Options *option,
                   int device_index,
                   int port_index);
static int send_option(char *str_value,
                Our_Options *option,
                int device_index,
                int port_index,
                char *ioctl_buf,
                IoctlSetup *ioctl_setup);
static int auto_install(void);
int our_ioctl_call(IoctlSetup *ioctl_setup);
static int remove_old_infs(void);

int debug_flags = 1;
int prompting_off = 0; // turn our_message() prompting off for auto-install

/*----------------------- local vars ---------------------------------*/
static char *szSlash = {"\\"};

static char szInstallGroup[60];
static char szModemInfEntry[60];

#if DBG
static TCHAR *dbg_label = TEXT("DBG_VERSION");
#endif

char szAppTitle[60];
#ifdef S_VS
//----------- VSLinkA Specific Strings and variables
//char *aptitle = {"Comtrol Hardware Setup, Comtrol Corporation"};
char *szAppName = {"VS1000/VS2000/RocketPort Serial Hub"};
char *OurServiceName = {"VSLinka"};
char *OurDriverName = {"VSLinka.sys"};
char *OurAppDir = {"VSLink"};
#ifdef NT50
char *szSetup_hlp = {"vssetup.hlp"};
#else
char *szSetup_hlp = {"setup.hlp"};
#endif

char *progman_list_nt[] = {
  szInstallGroup,   //  "Comtrol VS Link",   // group Description
  "vslink.grp",        // group file name
#ifndef NT50
  "Comtrol Hardware Setup", // item 1
  "setup.exe",         // file 1
#endif
  "Test Terminal",     // item 2
  "wcom32.exe",        // file 2

  "Port Monitor",      // item 3
  "portmon.exe",       // file 3
  NULL};
#else
//----------- RocketPort Specific Strings and variables
//char *aptitle = {"RocketPort Setup, Comtrol Corporation"};
char *szAppName = {"RocketPort"};
char *OurServiceName = {"RocketPort"};
char *OurDriverName = {"rocket.sys"};
char *OurAppDir = {"Rocket"};
#ifdef NT50
char *szSetup_hlp = {"ctmasetp.chm"};
#else
char *szSetup_hlp = {"setup.hlp"};
#endif

char *progman_list_nt[] = {
  szInstallGroup,   //  "Comtrol RocketPort RocketModem",   // group Description
  "rocket.grp",        // group file name
#ifndef NT50
  "RocketPort Setup",  // item 1
  "setup.exe",       // file 1
#endif
  "Test Terminal",     // item 2
  "wcom32.exe",        // file 2

  "Port Monitor",      // item 3
  "portmon.exe",       // file 3
  NULL};
#endif

//	WinHelp array. commented out values are defined, but unused.
//	in alphabetical order...
//
const DWORD help_ids[] = {
IDB_ADD,      IDB_ADD,
IDB_DEF,      IDB_DEF,
//	IDB_DONE,IDB_DONE,
//	IDB_HELP,IDB_HELP,
//	IDB_INSTALL,IDB_INSTALL,
IDB_PROPERTIES,  IDB_PROPERTIES,
IDB_REFRESH,     IDB_REFRESH,
IDB_REMOVE,      IDB_REMOVE,
IDB_RESET,       IDB_RESET,
IDB_STAT_RESET,  IDB_STAT_RESET,
IDC_BACKUP_SERVER, IDC_BACKUP_SERVER,
IDC_BACKUP_TIMER,  IDC_BACKUP_TIMER,
IDC_CBOX_IOADDR,   IDC_CBOX_IOADDR,
//	IDC_CBOX_IRQ,IDC_CBOX_IRQ,
IDC_CBOX_MACADDR,  IDC_CBOX_MACADDR,
//	IDC_CBOX_MAPBAUD,IDC_CBOX_MAPBAUD,
IDC_CBOX_NUMPORTS, IDC_CBOX_NUMPORTS,
IDC_CBOX_SC,       IDC_CBOX_SC,
IDC_CBOX_SCAN_RATE,IDC_CBOX_SCAN_RATE,
//	IDC_CBOX_TYPE,IDC_CBOX_TYPE,
IDC_CLONE,         IDC_CLONE,
//	IDC_CONF,IDC_CONF,
IDC_EB_NAME,       IDC_EB_NAME,
IDC_GROUP,         IDC_GROUP,
IDC_LBL_SUMMARY1,  IDC_LBL_SUMMARY1,
IDC_LBL_SUMMARY2,  IDC_LBL_SUMMARY2,
IDC_LBOX_DEVICE,   IDC_LBOX_DEVICE,
IDC_MAP_2TO1,      IDC_MAP_2TO1,
IDC_MAP_CDTODSR,   IDC_MAP_CDTODSR,
IDC_RING_EMULATE, IDC_RING_EMULATE,
//	IDC_PN0,IDC_PN0,
//	IDC_PN1,IDC_PN1,
//	IDC_PN2,IDC_PN2,
//	IDC_PN3,IDC_PN3,
IDC_PNP_PORTS,      IDC_PNP_PORTS,
IDC_PORT_LOCKBAUD,  IDC_PORT_LOCKBAUD,
IDC_PORT_RS485_LOCK,IDC_PORT_RS485_LOCK,
IDC_PORT_RS485_TLOW,IDC_PORT_RS485_TLOW,
IDC_PORT_WAIT_ON_CLOSE,  IDC_PORT_WAIT_ON_CLOSE,
IDC_PORT_WONTX,     IDC_PORT_WONTX,
IDC_PS_PORT,        IDC_PS_PORT,
IDC_ST_NIC_DVC_NAME,IDC_ST_NIC_DVC_NAME,
IDC_ST_NIC_MAC,     IDC_ST_NIC_MAC,
IDC_ST_NIC_PKT_RCVD_NOT_OURS,  IDC_ST_NIC_PKT_RCVD_NOT_OURS,
IDC_ST_NIC_PKT_RCVD_OURS,      IDC_ST_NIC_PKT_RCVD_OURS,
IDC_ST_NIC_PKT_SENT,  IDC_ST_NIC_PKT_SENT,
IDC_ST_PM_LOADS,      IDC_ST_PM_LOADS,
IDC_ST_STATE,         IDC_ST_STATE,
IDC_ST_VSL_DETECTED,  IDC_ST_VSL_DETECTED,
IDC_ST_VSL_IFRAMES_OUTOFSEQ, IDC_ST_VSL_IFRAMES_OUTOFSEQ,
IDC_ST_VSL_IFRAMES_RCVD,     IDC_ST_VSL_IFRAMES_RCVD,
IDC_ST_VSL_IFRAMES_RESENT,   IDC_ST_VSL_IFRAMES_RESENT,
IDC_ST_VSL_IFRAMES_SENT,     IDC_ST_VSL_IFRAMES_SENT,
IDC_ST_VSL_MAC,    IDC_ST_VSL_MAC,
IDC_ST_VSL_STATE,  IDC_ST_VSL_STATE,
//	IDC_USE_IRQ,IDC_USE_IRQ,
IDC_VERBOSE,  IDC_VERBOSE,
IDC_VERSION,  IDC_VERSION,
//	IDC_WIZ1_ISA,IDC_WIZ1_ISA,
//	IDC_WIZ1_ISA2,IDC_WIZ1_ISA2,
IDC_WIZ_BOARD_SELECT,   IDC_WIZ_BOARD_SELECT,
IDC_WIZ_CBOX_COUNTRY,   IDC_WIZ_CBOX_COUNTRY,
IDC_WIZ_CBOX_IOADDR,    IDC_WIZ_CBOX_IOADDR,
IDC_WIZ_CBOX_NUMPORTS,  IDC_WIZ_CBOX_NUMPORTS,
IDC_WIZ_CBOX_MAC,       IDC_WIZ_CBOX_MAC,
IDC_WIZ_ISA,  IDC_WIZ_ISA,
IDC_WIZ_PCI,  IDC_WIZ_PCI,
//	IDC_ADD_WIZ1,IDC_ADD_WIZ1,
//	IDC_ADD_WIZ2,IDC_ADD_WIZ2,
//	IDC_ADD_WIZ3,IDC_ADD_WIZ3,
IDD_ADD_WIZ_BASEIO,  IDD_ADD_WIZ_BASEIO,
IDD_ADD_WIZ_BOARD,   IDD_ADD_WIZ_BOARD,
IDD_ADD_WIZ_BUSTYPE, IDD_ADD_WIZ_BUSTYPE,
IDD_ADD_WIZ_COUNTRY, IDD_ADD_WIZ_COUNTRY,
IDD_ADD_WIZ_DONE,    IDD_ADD_WIZ_DONE,
IDD_ADD_WIZ_INTRO,   IDD_ADD_WIZ_INTRO,
IDD_ADD_WIZ_NUMPORTS,IDD_ADD_WIZ_NUMPORTS,

IDD_ADD_WIZ_DEVICE, IDD_ADD_WIZ_DEVICE,
IDD_ADD_WIZ_MAC, IDD_ADD_WIZ_MAC,
IDD_ADD_WIZ_BACKUP, IDD_ADD_WIZ_BACKUP,

IDD_DEVICE_SETUP,    IDD_DEVICE_SETUP,
IDD_DIALOG1,         IDD_DIALOG1,
IDD_DRIVER_OPTIONS,  IDD_DRIVER_OPTIONS,
IDD_DRIVER_OPTIONS_NT50, IDD_DRIVER_OPTIONS_NT50,
IDD_MAIN_DLG,        IDD_MAIN_DLG,
IDD_PORT_485_OPTIONS,IDD_PORT_485_OPTIONS,
IDD_PORT_MODEM_OPTIONS, IDD_PORT_MODEM_OPTIONS,
IDD_PORT_OPTIONS,       IDD_PORT_OPTIONS,
//	IDD_PORTLIST_PICK,   IDD_PORTLIST_PICK,
//	IDD_PROPPAGE_MEDIUM,IDD_PROPPAGE_MEDIUM,
IDD_STATUS,IDD_STATUS,  IDD_STATUS,IDD_STATUS,
IDD_VS_DEVICE_SETUP,    IDD_VS_DEVICE_SETUP,
IDM_ADVANCED,           IDM_ADVANCED,
IDM_ADVANCED_MODEM_INF, IDM_ADVANCED_MODEM_INF,
IDM_ADVANCED_NAMES,     IDM_ADVANCED_NAMES,
IDC_GLOBAL485, IDC_GLOBAL485,
//	IDM_CLOSE,IDM_CLOSE,
//	IDM_EDIT_README,IDM_EDIT_README,
IDM_EXIT,   IDM_EXIT,
//	IDM_F1,IDM_F1,
//	IDM_HELP,IDM_HELP,
//	IDM_HELPABOUT,IDM_HELPABOUT,
//	IDM_OPTIONS,IDM_OPTIONS,
//	IDM_PM,IDM_PM,
//	IDM_STATS,IDM_STATS,
	0xffffffff, 0,
	0, 0};

/*--------------------------  Global Variables  ---------------------*/
TCHAR m_szRegSerialMap[] = TEXT( "Hardware\\DeviceMap\\SerialComm" );

unsigned char broadcast_addr[6] = {0xff,0xff,0xff,0xff,0xff,0xff};
unsigned char mac_zero_addr[6] = {0,0,0,0,0,0};
HWND glob_hwnd = NULL;
HINSTANCE glob_hinst = 0;     // current instance
char gtmpstr[250];
HWND  glob_hDlg = 0;

OUR_INFO *glob_info = NULL;   // global context handles and general baggage to carry.
AddWiz_Config *glob_add_wiz;  // transfer buffer from Add Device wizard

Driver_Config *wi;      // current info
Driver_Config *org_wi;  // original info, use to detect changes

/*------------------------------------------------------------------------
| FillDriverPropertySheets - Setup pages for driver level property sheets.
|------------------------------------------------------------------------*/
int FillDriverPropertySheets(PROPSHEETPAGE *psp, LPARAM our_params)
{
  INT pi;
  static TCHAR mainsetstr[40], optstr[40];

  memset(psp, 0, sizeof(*psp) * NUM_DRIVER_SHEETS);

  pi = 0;

  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP | PSH_NOAPPLYNOW;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_MAIN_DLG);
  psp[pi].pfnDlgProc = DevicePickSheet;
  load_str( glob_hinst, (TITLESTR+7), mainsetstr, CharSizeOf(mainsetstr) );
  psp[pi].pszTitle = mainsetstr;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;

  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP | PSH_NOAPPLYNOW;
  psp[pi].hInstance = glob_hinst;
#ifdef NT50
  psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_DRIVER_OPTIONS_NT50);
#else
  psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_DRIVER_OPTIONS);
#endif
  psp[pi].pfnDlgProc = AdvDriverSheet;
  load_str( glob_hinst, (TITLESTR+8), optstr, CharSizeOf(optstr) );
  psp[pi].pszTitle = optstr;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;

  return 0;
}

/*------------------------------------------------------------------------
| setup_init - Instantiate and setup our main structures.  Also, allocate
    space for a original config struct(org_wi) for later detection
    of changes made to master config copy(wi).
|------------------------------------------------------------------------*/
int setup_init(void)
{
 int size,i;

  //---- allocate global baggage struct
  glob_info = (OUR_INFO *) calloc(1,sizeof(OUR_INFO));

  //---- allocate global add wizard transfer buffer
  glob_add_wiz = (AddWiz_Config *) calloc(1, sizeof(AddWiz_Config));

  //---- allocate driver struct
  size = sizeof(Driver_Config);
  wi =  (Driver_Config *) calloc(1,size);
  memset(wi, 0, size);  // clear our structure

  org_wi =  (Driver_Config *) calloc(1,size);
  memset(wi, 0, size);  // clear our structure

  //---- allocate device structs
  size = sizeof(Device_Config) * MAX_NUM_DEVICES;
  wi->dev     =  (Device_Config *) calloc(1,size);
  memset(wi->dev, 0, size);  // clear our structure

  org_wi->dev     =  (Device_Config *) calloc(1,size);
  memset(org_wi->dev, 0, size);  // clear our structure

  //---- allocate port structs
  for (i=0; i<MAX_NUM_DEVICES; i++)
  {
    size = sizeof(Port_Config) * MAX_NUM_PORTS_PER_DEVICE;
    wi->dev[i].ports = (Port_Config *) calloc(1,size);
    memset(wi->dev[i].ports, 0, size);  // clear our structure

    org_wi->dev[i].ports = (Port_Config *) calloc(1,size);
    memset(org_wi->dev[i].ports, 0, size);  // clear our structure
  }

  wi->install_style = INS_NETWORK_INF;  // default to original nt4.0 style

#if defined(S_VS)
  if (load_str(glob_hinst, IDS_VS_INSTALL_GROUP, szInstallGroup, CharSizeOf(szInstallGroup)))
  {
    MessageBox(GetFocus(), "Error String Load", OurServiceName, MB_OK);
    return 1;
  }
  load_str(glob_hinst, IDS_VS_AP_TITLE, szAppTitle, CharSizeOf(szAppTitle));
  load_str(glob_hinst, IDS_VS_MODEM_INF_ENTRY, szModemInfEntry, CharSizeOf(szModemInfEntry));
#else
  if (load_str(glob_hinst, IDS_INSTALL_GROUP, szInstallGroup, CharSizeOf(szInstallGroup)))
  {
    MessageBox(GetFocus(), "Error String Load", OurServiceName, MB_OK);
    return 1;
  }
  load_str(glob_hinst, IDS_AP_TITLE, szAppTitle, CharSizeOf(szAppTitle));
  load_str(glob_hinst, IDS_MODEM_INF_ENTRY, szModemInfEntry, CharSizeOf(szModemInfEntry));
#endif

  // fill in InstallPaths structure : system info, directory names, etc.
  setup_install_info(&wi->ip,    // our InstallPaths structure to fill out.
                     glob_hinst,     // stuff to fill it out with...
                     OurServiceName,
                     OurDriverName,
                     szAppTitle,
                     OurAppDir);

  return 0;  // ok
}

/*------------------------------------------------------------------------
| copy_setup_init - Make a copy of our original config to detect changes
   in our master copy later.  This is a bit wasteful of memory, especially
   since we just create space for max. num devices and ports, but memory
   is cheap.
   Should call this after setup_init() allocates these config structs,
   and after we input/read the initial configuration from the registry.
|------------------------------------------------------------------------*/
int copy_setup_init(void)
{
 int i;
 int size;
 Device_Config *save_dev;
 Port_Config *save_port;

  //--- copy the driver configuration
  save_dev = org_wi->dev;  // retain, don't overwrite this with memcpy!
  memcpy(org_wi, wi, sizeof(*wi));  // save copy of original
  org_wi->dev = save_dev;  // restore our ptr to our device array

  for (i=0; i<MAX_NUM_DEVICES; i++)
  {
    //--- copy the device configuration array
    save_port = org_wi->dev[i].ports;  // retain, don't overwrite this with memcpy!
    memcpy(&org_wi->dev[i], &wi->dev[i], sizeof(Device_Config));  // save copy of original
    org_wi->dev[i].ports = save_port;  // restore our ptr to our device array

    size = sizeof(Port_Config) * MAX_NUM_PORTS_PER_DEVICE;

    //--- copy the port configuration array
    memcpy(org_wi->dev[i].ports, wi->dev[i].ports, size);  // save copy of original
  }

  return 0;  // ok
}

/*------------------------------------------------------------------------
| DoDriverPropPages - Main driver level property sheet for NT4.0
|------------------------------------------------------------------------*/
int DoDriverPropPages(HWND hwndOwner)
{
    PROPSHEETPAGE psp[NUM_DRIVER_SHEETS];
    PROPSHEETHEADER psh;
    OUR_INFO * our_params;
    INT stat;

    //Fill out the PROPSHEETPAGE data structure for the Background Color
    //sheet

    our_params = glob_info;  // temporary kludge, unless we don't need re-entrantancy 

    //Fill out the PROPSHEETPAGE data structure for the Client Area Shape
    //sheet
    FillDriverPropertySheets(&psp[0], (LPARAM)our_params);

    //Fill out the PROPSHEETHEADER

    memset(&psh, 0, sizeof(PROPSHEETHEADER));  // add fix 11-24-98
    psh.dwSize = sizeof(PROPSHEETHEADER);
    //psh.dwFlags = PSH_USEICONID | PSH_PROPSHEETPAGE;
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndOwner;
    psh.hInstance = glob_hinst;
    psh.pszIcon = "";
    //psh.pszCaption = (LPSTR) aptitle;  //"Driver Properties";
    psh.pszCaption = (LPSTR) szAppTitle;  //"Driver Properties";

    psh.nPages = NUM_DRIVER_SHEETS;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    //And finally display the dialog with the two property sheets.
  DbgPrintf(D_Init, ("Init 8\n"))

    stat = PropertySheet(&psh);

  return 0;
}

/*---------------------------------------------------------------------------
  our_context_help -
|---------------------------------------------------------------------------*/
void our_context_help(LPARAM lParam)
{
  LPHELPINFO lphi;
  HWND  helpWin;

  lphi = (LPHELPINFO) lParam;
  if ((lphi->iContextType == HELPINFO_MENUITEM) ||
      (lphi->iContextType == HELPINFO_WINDOW))
  {
    //wsprintf(gtmpstr, "id:%d", lphi->iCtrlId);
    //our_message(gtmpstr,MB_OK);

    //strcpy(gtmpstr, wi->ip.src_dir);
    //strcat(gtmpstr,szSlash);
    //strcat(gtmpstr,szSetup_hlp);
//    strcpy(gtmpstr, szSetup_hlp);
	  wsprintf(gtmpstr, "%s\\%s", wi->ip.src_dir, szSetup_hlp);
#ifdef NT50
	strcat(gtmpstr, "::/");
	strcat(gtmpstr, "resource.txt");
    helpWin = HtmlHelp((HWND) lphi->hItemHandle, gtmpstr,
             HH_TP_HELP_WM_HELP, (DWORD)help_ids);
	if (!helpWin) {

      DbgPrintf(D_Level, ("Failed to open WhatsThis help window\n"));
	}
#else
    WinHelp((HWND) lphi->hItemHandle, gtmpstr,
             HELP_WM_HELP, (DWORD)help_ids);
#endif
    //WinHelp((HWND) lphi->hItemHandle, szSetup_hlp,
    //        HELP_WM_HELP, (DWORD)  help_ids);
    //WinHelp(GetFocus(),szSetup_hlp, HELP_CONTEXT, lphi->iCtrlId);
  }

#ifdef COMMENT_OUT
  if (lphi->iContextType == HELPINFO_MENUITEM)
  {
    wsprintf(gtmpstr, "id:%d", lphi->iCtrlId);
    our_message(gtmpstr,MB_OK);

    i = 0;
    while ((help_ids[i*2] != lphi->iCtrlId) &&
           (help_ids[i*2] != 0xffffffff))
     ++i;
    if (help_ids[i*2] != 0xffffffff)
      WinHelp(GetFocus(),szSetup_hlp, HELP_CONTEXT, help_ids[i*2+1]);
    else WinHelp(GetFocus(),szSetup_hlp, HELP_CONTEXT, WIN_NT);
  }
  if (lphi->iContextType == HELPINFO_WINDOW)
  {
    wsprintf(gtmpstr, "id:%d", lphi->iCtrlId);
    our_message(gtmpstr,MB_OK);

    i = 0;
    while ((help_ids[i*2]  != lphi->iCtrlId) &&
           (help_ids[i*2] != 0xffffffff))
     ++i;
    if (help_ids[i*2] != 0xffffffff)
      WinHelp(GetFocus(),szSetup_hlp, HELP_CONTEXTPOPUP, help_ids[i*2+1]);
    else WinHelp(GetFocus(),szSetup_hlp, HELP_CONTEXT, WIN_NT);
  
    //WinHelp(GetFocus(),szSetup_hlp, HELP_CONTEXT, lphi->dwContextId);

    //WinHelp((HWND) lphi->hItemHandle, szSetup_hlp,
    //             HELP_WM_HELP, (DWORD)  help_ids);
  }
#endif
}

/*---------------------------------------------------------------------------
  remove_old_infs - A new common Comtrol modem inf file is called mdmctm1.inf,
    and replaces older individual ones called: mdmrckt.inf & mdmvsa1.inf.
    We must remove the older ones on install to clear out the older entries.
|---------------------------------------------------------------------------*/
static int remove_old_infs(void)
{
  static TCHAR *sz_inf = TEXT("\\inf\\");

  // delete the old inf\mdmrckt.inf file
  GetWindowsDirectory(wi->ip.dest_str,144);
  strcat(wi->ip.dest_str, sz_inf);
  strcat(wi->ip.dest_str, "mdmrckt.inf");
  DeleteFile(wi->ip.dest_str);

  // delete the old inf\mdmvsa1.inf file
  GetWindowsDirectory(wi->ip.dest_str,144);
  strcat(wi->ip.dest_str, sz_inf);
  strcat(wi->ip.dest_str, "mdmvsa1.inf");
  DeleteFile(wi->ip.dest_str);
  return 0; // ok
}

/*---------------------------------------------------------------------------
  remove_driver - clear out the driver from the system as much as possible.
|---------------------------------------------------------------------------*/
int remove_driver(int all)
{
 int stat,i;
 static char *delete_list[] = {
   "peer.exe",
   "peer.hlp",
   "portmon.exe",
   "portmon.hlp",
   "wcom32.exe",
   "wcom.hlp",
   //"setup.exe",  // since setup is running, a sharing violation prevents this
   "readme.txt",
   "history.txt",
#ifdef S_VS
   "vssetup.hlp",
   "vssetup.gid",
#else
   "rksetup.hlp",
   "rksetup.gid",
   "ctmmdmld.rm",
   "ctmmdmfw.rm",
#endif
   "wcom.gid",
   "portmon.gid",
   "calcs.dat",
   "ctmmdm35.inf",
   "portmon.vew",
   NULL};

   // delete the drivers\rocket.sys driver file
   GetSystemDirectory(wi->ip.dest_str,144);
   strcat(wi->ip.dest_str, "\\drivers\\");
   strcat(wi->ip.dest_str, wi->ip.szDriverName);
   DeleteFile(wi->ip.dest_str);

#ifdef S_VS
   // form "vslinka.bin", and delete the file from drivers dir
   // cut off .sys as "vslink."
   wi->ip.dest_str[strlen(wi->ip.dest_str) - 3] = 0; 
   strcat(wi->ip.dest_str, "bin");
   DeleteFile(wi->ip.dest_str);
#endif

   if (all)
   {
     // had some problems implementing, so the "all" is for
     // test right now.

     // delete most of the files in system32\ROCKET directory
     i = 0;
     while (delete_list[i] != NULL)
     {
       //wsprintf(tmpstr, "
       //MessageBox(0, s, "Debug", MB_OK);
       
       GetSystemDirectory(wi->ip.dest_str,144);
       strcat(wi->ip.dest_str, szSlash);
       strcat(wi->ip.dest_str, wi->ip.szAppDir);
       strcat(wi->ip.dest_str, szSlash);
       strcat(wi->ip.dest_str, delete_list[i]);
       DeleteFile(wi->ip.dest_str);
       ++i;
     }
#ifndef NT50
       // we can't just delete ourselves, so we rename ourselves
       // and that is good enough.
       GetSystemDirectory(wi->ip.dest_str,144);
       strcat(wi->ip.dest_str, szSlash);
       strcat(wi->ip.dest_str, wi->ip.szAppDir);
       strcat(wi->ip.dest_str, szSlash);
       strcpy(wi->ip.src_str, wi->ip.dest_str);
       strcat(wi->ip.dest_str, "setupold.exe");
       strcat(wi->ip.src_str, "setup.exe");
       stat = MoveFileEx(wi->ip.src_str, wi->ip.dest_str, MOVEFILE_REPLACE_EXISTING);
#endif
   }

   // kill our program manager
   stat = delete_progman_group(progman_list_nt, wi->ip.dest_dir);

   // remove some registry entries
   stat = remove_driver_reg_entries(wi->ip.szServiceName);

   setup_service(OUR_REMOVE, OUR_SERVICE);  // do a remove on the service
   return 0;
}

/*-----------------------------------------------------------------------------
| allow_exit - Performs 3 tasks:
  1.) If cancel selected: check to see if we allow the user to cancel
      out of the setup program.  If its an initial install, then force
      them to save it  off with an OK selection.
  2.) If cancel selected: Handle prompting to ask the user if they
      really want to cancel without saving.
  3.) If saving, make sure a valid save set is resident.  If not,
  do various things.

   RETURNS: true if we are allowing a cancel, false if we don't allow it.
|-----------------------------------------------------------------------------*/
int allow_exit(int want_to_cancel)
{
 int allow_it = 0;
 int stat;

  if (!wi->ChangesMade)
    send_to_driver(0);  // evaluate if anything changed(sets ChangesMade if true)

  if (want_to_cancel)  // they want to cancel out of the setup program
  {
    if ((do_progman_add)  // if initial add, don't let them decline
        && (wi->install_style == INS_NETWORK_INF))
    {
      our_message(&wi->ip,RcStr((MSGSTR+5)),MB_OK);
    }
    else
    {
#ifndef NT50
  // only prompt for nt40, I don't want the prompt for nt50...
      if (wi->ChangesMade)
      {
        stat = our_message(&wi->ip,"Quit without making changes?",MB_YESNO);
        if (stat == IDYES)
        {
          allow_it = 1;
        }
      }
      else
#endif
        allow_it = 1;
    }
  }
  else  // they pressed OK
  {
    if (wi->NumDevices == 0)  // all devices removed, hmmm...
    {
      if ((wi->nt_reg_flags & 2) || // missing linkage thing(did not install via network inf)
          (wi->install_style == INS_SIMPLE))
      {
  stat = our_message(&wi->ip,RcStr((MSGSTR+6)),MB_YESNO);
        if (stat == IDYES)
        {
          remove_driver(1);
          //PostQuitMessage(0);  // end the setup program.
          allow_it = 1;
        }
      }
      else
      {
#ifdef NT50
     our_message(&wi->ip,RcStr((MSGSTR+20)),MB_OK);
#else
     our_message(&wi->ip,RcStr((MSGSTR+7)),MB_OK);
#endif
      }
    }
    else
    {
#ifndef NT50
  // only prompt for nt40, I don't want the prompt for nt50...
  // maybe we should yank it out for 40 too.
      if (wi->ChangesMade)
      {
        stat = our_message(&wi->ip, "Save configuration changes and exit?", MB_YESNO);
        if (stat == IDYES)
        {
          allow_it = 1;
        }
      }
      else
#endif
          allow_it = 1;
    }
  }
  return allow_it;
}

/*-----------------------------------------------------------------------------
| our_exit - save/do install on exit if required.
|-----------------------------------------------------------------------------*/
void our_exit(void)
{
 int stat;
 static int did_exit = 0;

  // prop pages have independent action which under nt5.0 cause multiple
  // exit points, this did_exit thing prevents prompting and saving twice..
  if (did_exit)  
    return;

  {
    if (wi->NumDevices > 0)
    {
#ifndef NT50
      // only setup service for NT4.0 for now..
      stat = do_install();

      setup_service(OUR_RESTART, OUR_SERVICE);  // restart the service
#endif

      if (wi->NeedReset)
        our_message(&wi->ip,RcStr((MSGSTR+8)),MB_OK);
    }
#ifndef NT50
    else
      setup_service(OUR_REMOVE, OUR_SERVICE);  // do a remove on the service
#endif
  }
}

/*-----------------------------------------------------------------------------
| do_install -
|-----------------------------------------------------------------------------*/
int do_install(void)
{
 int stat = 0;
 int do_remove = 0;
 int do_modem_inf = 0;
 static int in_here = 0;

  if (in_here)  // problem hitting OK button twice(sets off two of these)
    return 2;

  in_here = 1;

#ifndef NT50
  if (do_progman_add)
  {
    if (wi->ip.major_ver == 3)  // for NT3.51
      do_modem_inf = 1;   // only do on initial install
  }
  if (do_progman_add)
  {
    // if no inf file, then copy over the files ourselves if initial
    // install.
    if (wi->install_style == INS_SIMPLE)
    {
      SetCursor(LoadCursor(NULL, IDC_WAIT));  // load hourglass cursor
      stat = copy_files_nt(&wi->ip);
      SetCursor(LoadCursor(NULL, IDC_ARROW));  // load arrow

      if (stat != 0)
           our_message(&wi->ip, "Error while copying files", MB_OK);
    }
    stat = setup_make_progman_group(0);  // no prompt

    remove_old_infs();  // kill any old modem infs
  }
#endif

  in_here = 0;

#ifndef NT50
  if (do_modem_inf)
    update_modem_inf(0);

  if (!do_progman_add)  // if initial add, don't let them decline
  {
    if (!wi->ChangesMade)
      send_to_driver(0);  // evaluate if anything changed
      // i'm getting tire of all these prompts(kb, 8-16-98)...
#if 0
    if (wi->ChangesMade)
    {
      strcpy(gtmpstr, "Setup will now save the new configuration.");
      if (our_message(&wi->ip, gtmpstr, MB_OKCANCEL) != IDOK)
        return 1;  // error
    }
#endif
  }

  if (do_progman_add)
  {
    if (wi->install_style == INS_SIMPLE)
    {
      strcpy(gtmpstr, "System32\\Drivers\\");
      strcat(gtmpstr, OurDriverName);
      stat = service_man(OurServiceName, OurDriverName, CHORE_INSTALL);
      //sprintf(gtmpstr, "Install service, result=%x", stat);
      //our_message(&wi->ip, gtmpstr, MB_OK);
    }
  }
#endif

  stat = send_to_driver(1);

  stat = set_nt_config(wi);

  // new, fire the thing up right away after saving options
  if (do_progman_add)
  {
    // try to start the service
//    setup_service(OUR_RESTART, OUR_DRIVER);  // restart the service
  }

  if (stat)
    return 1; // error

  return 0; // ok
}

/*-----------------------------------------------------------------------------
| setup_service - setup our service.  The service reads the scanrates of
   VS & RocketPort drivers on startup, and adjusts NT's tick based then.
   So we need to restart this service.
   flags: 1H = stop & remove, 2 = restart it, 4 = install & start
   which_service: 0=ctmservi common service task.  1=vs or rk driver.
|-----------------------------------------------------------------------------*/
int setup_service(int flags, int which_service)
{
 static char *Ctmservi_OurUserServiceName = {"ctmservi"};

 char OurUserServiceName[60];
 char OurUserServicePath[60];
//#define DEBUG_SERVICE_FUNC

 int installed = 0;
 int stat;

 if (which_service == 0)  // our common service
 {
   strcpy(OurUserServiceName, Ctmservi_OurUserServiceName);
   strcpy(OurUserServicePath, Ctmservi_OurUserServiceName);
   strcat(OurUserServicePath, ".exe");
 }
 else if (which_service == 1)  // rk or vs driver service
 {
   strcpy(OurUserServiceName, OurServiceName);  // driver
   strcpy(OurUserServicePath, OurDriverName);
 }

 DbgPrintf(D_Test, ("Service %s Flags:%xH\n", OurUserServiceName, flags))

 if (service_man(OurUserServiceName, OurUserServicePath,
     CHORE_IS_INSTALLED) == 0)  // it's installed
  {
    installed = 1;
    DbgPrintf(D_Test, (" Installed\n"))
  }
  else
  {
    DbgPrintf(D_Test, (" Not Installed\n"))
  }

  if (flags & 1)  // remove
  {
    DbgPrintf(D_Test, (" srv remove\n"))
    if (installed)
    {
      DbgPrintf(D_Test, (" srv remove a\n"))
      stat = service_man(OurUserServiceName, OurUserServicePath, CHORE_STOP);
      if (stat != 0)
      {
        DbgPrintf(D_Error, ("Error %d stopping service\n", stat))
      }
      DbgPrintf(D_Test, (" srv remove b\n"))
      stat = service_man(OurUserServiceName, OurUserServicePath, CHORE_REMOVE);
      if (stat != 0)
      {
        DbgPrintf(D_Error, ("Error %d removing service\n", stat))
      }
      installed = 0;
    }
  }

  if (flags & 2)  // restart it
  {
    DbgPrintf(D_Test, (" srv restart\n"))
    if (!installed)
    {
      DbgPrintf(D_Test, (" srv restart a\n"))
      flags |= 4;  // install & start it
    }
    else
    {
      DbgPrintf(D_Test, (" srv restart b\n"))
      stat = service_man(OurUserServiceName, OurUserServicePath, CHORE_STOP);
      if (stat != 0)
      {
        DbgPrintf(D_Error, ("Error %d stopping service\n", stat))
      }

      // the start was failing with a 1056 error(instance already running)
      Sleep(100L);

      stat = service_man(OurUserServiceName, OurUserServicePath, CHORE_START);
      if (stat != 0)
      {
        DbgPrintf(D_Error, ("Error %d starting service\n", stat))
      }
    }

  }

  if (flags & 4)  // install & start it
  {
    DbgPrintf(D_Test, (" srv install & start\n"))
    if (!installed)
    {
      DbgPrintf(D_Test, (" srv install & start a\n"))
      stat = service_man(OurUserServiceName, OurUserServicePath,
               CHORE_INSTALL_SERVICE);
      if (stat != 0)
      {
        DbgPrintf(D_Error, ("Error %d installing service\n", stat))
      }
      stat = service_man(OurUserServiceName, OurUserServicePath, CHORE_START);
      if (stat != 0)
      {
        DbgPrintf(D_Error, ("Error %d starting service\n", stat))
      }
    }
  }
  return 0;
}

/*-----------------------------------------------------------------------------
| setup_utils_exist - tells if utils like wcom32.exe, portmon.exe, rksetup.exe
    exist.  For NT5.0, embedded in OS we may not have utils.
|-----------------------------------------------------------------------------*/
int setup_utils_exist(void)
{
 ULONG dstat;

  strcpy(gtmpstr, wi->ip.dest_dir);
  // first installed file in list
  strcat(gtmpstr,"\\");
  strcat(gtmpstr,progman_list_nt[3]);
  dstat = GetFileAttributes(gtmpstr);
  if (dstat != 0xffffffff)  // it must exist
    return 1; // exists
  return 0; // does not exist
}

/*-----------------------------------------------------------------------------
| setup_make_progman_group -
|-----------------------------------------------------------------------------*/
int setup_make_progman_group(int prompt)
{
 int stat;
  if (prompt)
  {
    if (our_message(&wi->ip, RcStr((MSGSTR+9)), MB_YESNO) != IDYES)
      return 0;
  }

  stat = make_progman_group(progman_list_nt, wi->ip.dest_dir);

  if (stat)
  {
    our_message(&wi->ip,RcStr((MSGSTR+10)),MB_OK);
  }
  return stat;
}

/*-----------------------------------------------------------------------------
| update_modem_inf - query and update modem.inf file for rocketmodem entries.
|-----------------------------------------------------------------------------*/
int update_modem_inf(int ok_prompt)
{
 int stat;
 int do_it = 1;

  if (ok_prompt)
  {
    do_it = 0;
#ifdef S_VS
    strcpy(gtmpstr, RcStr((MSGSTR+11)));
#else
    strcpy(gtmpstr, RcStr((MSGSTR+12)));
#endif
    if (our_message(&wi->ip, gtmpstr, MB_OKCANCEL) == IDOK)
      do_it = 1;
  }

  if (do_it)
  {
#ifdef S_VS
    stat = modem_inf_change(&wi->ip, "VsLink\\ctmmdm35.inf", szModemInfEntry);
#else
    stat = modem_inf_change(&wi->ip, "Rocket\\ctmmdm35.inf", szModemInfEntry);
#endif

    if (stat)
    {
      our_message(&wi->ip,RcStr((MSGSTR+13)),MB_OK);
      return 1; // error
    }
    else
    {
      if (ok_prompt)
        our_message(&wi->ip,RcStr((MSGSTR+14)),MB_OK);
        return 1; // error
    }
  }
  return 0; // ok
}

#ifdef S_VS
/*-----------------------------------------------------------------------------
| get_mac_list - get mac address list from driver which polls network for
    boxes and returns us a list of mac-addresses(with 2-extra bytes of
    misc. bits of information.)
|-----------------------------------------------------------------------------*/
int get_mac_list(char *buf, int in_buf_size, int *ret_buf_size)
{
 IoctlSetup ioctl_setup;
 int product_id = NT_VS1000;
 int stat;

  memset(&ioctl_setup, 0 , sizeof(ioctl_setup));
  stat = ioctl_open(&ioctl_setup, product_id);  // just ensure we can open

  if (stat != 0) // error from ioctl
  {
    *ret_buf_size = 0;
    // could not talk to driver
    return 1;
  }

  ioctl_setup.buf_size = in_buf_size - sizeof(*ioctl_setup.pm_base);
  ioctl_setup.pm_base = (PortMonBase *) buf;
  ioctl_setup.pm_base->struct_type = IOCTL_MACLIST;  // get mac-address list

  stat = ioctl_call(&ioctl_setup);  // get names, number of ports
  if (stat)
  {
    ioctl_close(&ioctl_setup);
    *ret_buf_size = 0;
    return 0x100;  // failed ioctl call
  }
  ioctl_close(&ioctl_setup);
  *ret_buf_size = ioctl_setup.ret_bytes - sizeof(ioctl_setup.pm_base[0]);
  return 0; // ok
}

/*------------------------------------------------------------------------
 our_get_ping_list - cause the driver to do a broadcast ping on
   all devices, and obtain a list of returned mac-addresses and misc.
   query flag settings in an array.  We allocated buffer space and
   just leave it for program/os to clean up.
|------------------------------------------------------------------------*/
BYTE *our_get_ping_list(int *ret_stat, int *ret_bytes)
{
  static char *ioctl_buf = NULL;  // we alloc this once, then it remains
  BYTE *macbuf;
  //BYTE *mac;
  int found, nbytes, stat;

  if (ioctl_buf == NULL)
  {
    // alloc 8byte mac-address fields(2 times as many as could be configured)
    ioctl_buf = calloc(1, (MAX_NUM_DEVICES*8)*2);
  }
  memset(ioctl_buf, 0,  (MAX_NUM_DEVICES*8)*2);
  found = 0;
  nbytes = 0;
  macbuf = &ioctl_buf[sizeof(PortMonBase)];  // ptr past header

  // call to get mac-address list of boxes on network
  SetCursor(LoadCursor(NULL, IDC_WAIT));  // load hourglass cursor

  stat = get_mac_list(ioctl_buf, (MAX_NUM_DEVICES*8)*2, &nbytes);

  SetCursor(LoadCursor(NULL, IDC_ARROW));  // load arrow
  *ret_stat = stat;
  *ret_bytes = nbytes;
  return macbuf;
}

#endif

/*-----------------------------------------------------------------------------
| send_to_driver -
   send_to_driver - if set, then send it to driver.
     if not set, then just determine if changes were made
|-----------------------------------------------------------------------------*/
int send_to_driver(int send_it)
{
  char ioctl_buffer[200];
  char value_str[100];
  char *ioctl_buf;
  IoctlSetup ioctl_setup;
  Our_Options *options;
  int dev_i, stat;
  int op_i;
  int chg_flag;
  int unknown_value;
  int pi;
  int changes_found=0;
  int changes_need_reboot=0;
  Device_Config *dev;


   // for ioctl calls into driver
#ifdef S_VS
 int product_id = NT_VS1000;
#else
 int product_id = NT_ROCKET;
#endif

  if (send_it)
  {
    DbgPrintf(D_Level,(TEXT("send_to_driver\n")));
    memset(&ioctl_setup, 0 , sizeof(ioctl_setup));
    memset(&ioctl_buffer, 0 , sizeof(ioctl_buffer));
    stat = ioctl_open(&ioctl_setup, product_id);  // just ensure we can open

    if (stat != 0) // error from ioctl
    {
      // could not talk to driver
      DbgPrintf(D_Level,(TEXT("Driver Not Present\n")));
      wi->NeedReset = 1;
      return 1;
    }

    ioctl_setup.buf_size = sizeof(ioctl_buffer) - sizeof(*ioctl_setup.pm_base);
    ioctl_setup.pm_base = (PortMonBase *)ioctl_buffer;
    ioctl_setup.pm_base->struct_type = IOCTL_OPTION;  // set options
    ioctl_buf = (char *) &ioctl_setup.pm_base[1];  // ptr to past header(about 16 bytes)
  }

  options = driver_options;
  op_i = 0;
  while (options[op_i].name != NULL)
  {
    option_changed(value_str, &chg_flag, &unknown_value, &options[op_i],
                   0,0);

    if (chg_flag)
    {
      changes_found = 1;
      if (send_it)
      {
        stat = send_option(value_str,
                  &options[op_i],
                  0,
                  0,ioctl_buf, &ioctl_setup);
        if (stat != 0)
          changes_need_reboot = 1;
      }  // send_it
    }
    ++op_i;
  }

  DbgPrintf(D_Level,(TEXT("send_to_driver 1\n")));
  for(dev_i=0; dev_i<wi->NumDevices; dev_i++)   // Loop through all possible boards
  {
    dev = &wi->dev[dev_i];
    op_i = 0;
    options = device_options;
    while (options[op_i].name != NULL)
    {
      option_changed(value_str, &chg_flag, &unknown_value, &options[op_i],
                     dev_i,0);

      if (chg_flag)
      {
        changes_found = 1;
        if (send_it)
        {
          stat = send_option(value_str,
                  &options[op_i],
                  dev_i,
                  0,ioctl_buf, &ioctl_setup);
          if (stat != 0)
            changes_need_reboot = 1;
        }  // send_it
      }  // chg_flag
      ++op_i;
    }  // device strings

    for(pi=0; pi<dev->NumPorts; pi++)   // Loop through all possible boards
    {
      op_i = 0;
      options = port_options;
      while (options[op_i].name != NULL)
      {
        option_changed(value_str, &chg_flag, &unknown_value, &options[op_i],
                       dev_i, pi);

        if (chg_flag)
        {
          changes_found = 1;
  
          if (send_it)
          {
            stat = send_option(value_str,
                     &options[op_i],
                     dev_i,
                     pi, ioctl_buf, &ioctl_setup);
            if (stat != 0)
              changes_need_reboot = 1;
          }  // send_it
        }  // chg_flag
        ++op_i;
      }  // port strings
    }  // for pi=0; ..ports
  }   // for dev_i = num_devices

  if (changes_need_reboot)
    wi->NeedReset = 1;

  if (changes_found)
    wi->ChangesMade = 1;

  if (send_it)
  {
    ioctl_close(&ioctl_setup);
  }
  return 0;
}

/*-----------------------------------------------------------------------------
| send_option - send option over to driver.
|-----------------------------------------------------------------------------*/
static int send_option(char *value_str,
                Our_Options *option,
                int device_index,
                int port_index,
                char *ioctl_buf,
                IoctlSetup *ioctl_setup)
{
  char dev_name[80];
  int stat;

#if (defined(NT50))
  strcpy(dev_name, wi->ip.szNt50DevObjName);
#else
  wsprintf(dev_name, "%d", device_index);
#endif

  if (option->id & 0x100)  // its a driver option
  {
    wsprintf(ioctl_buf, "%s=%s", option->name, value_str);
  }
  else if (option->id & 0x200)  // its a device option
  {
    wsprintf(ioctl_buf, "device[%s].%s=%s",
            dev_name, option->name, value_str);
  }
  else if (option->id & 0x400)  // its a port option
  {
    wsprintf(ioctl_buf, "device[%s].port[%d].%s=%s",
        dev_name, port_index,
        option->name, value_str);
  }

  stat = our_ioctl_call(ioctl_setup);
  if (stat == 52)
  {
    //special return code indicating driver doesn't care or know about
    // this option(its setup only option.)
    stat = 0;  // change to ok.
  }
  return stat;

  //if (stat != 0)
  //    changes_need_reboot = 1;
}

/*-----------------------------------------------------------------------------
| option_changed - detect if an option changed, and format a new value
|-----------------------------------------------------------------------------*/
static int option_changed(char *value_str,
                   int *ret_chg_flag,
                   int *ret_unknown_flag,
                   Our_Options *option,
                   int device_index,
                   int port_index)
{
  int chg_flag = 0;
  int value = 0;
  int org_value = 0;
  int unknown_value = 0;
  Port_Config *port, *org_port;
  Device_Config *org_dev, *dev;

  dev = &wi->dev[device_index];
  org_dev = &org_wi->dev[device_index];

  port     = &dev->ports[port_index];
  org_port = &org_dev->ports[port_index];

  if (option->id & 0x300)  // port level option
  {
  }
  else if (option->id & 0x200)  // device level option
  {
  }
  else if (option->id & 0x100)  // driver level option
  {
  }
  *value_str = 0;

  switch(option->id)
  {
    //------ Driver Options ------
    case OP_VerboseLog:
      value = wi->VerboseLog;  org_value = org_wi->VerboseLog;
    break;
    case OP_NumDevices:
      value = wi->NumDevices;  org_value = org_wi->NumDevices;
    break;
#ifdef NT50
    case OP_NoPnpPorts:
      value = wi->NoPnpPorts;  org_value = org_wi->NoPnpPorts;
    break;
#endif
    case OP_ScanRate:
      value = wi->ScanRate;  org_value = org_wi->ScanRate;
    break;

    case OP_ModemCountry:
      value = wi->ModemCountry; org_value = org_wi->ModemCountry;
    break;
    case OP_GlobalRS485:
      value = wi->GlobalRS485; org_value = org_wi->GlobalRS485;
    break;

    //------ Device Options ------
#if 0  // don't send this to driver, make it go away
    case OP_StartComIndex  :
      value = dev->StartComIndex;  org_value = org_dev->StartComIndex;
    break;
#endif
    case OP_NumPorts        :
      value = dev->NumPorts;  org_value = org_dev->NumPorts;
    break;
    case OP_MacAddr         :
      if (!mac_match(dev->MacAddr, org_dev->MacAddr))
      {
        chg_flag = 1;
        wsprintf(value_str, "%x %x %x %x %x %x",
                 dev->MacAddr[0], dev->MacAddr[1], dev->MacAddr[2],
                 dev->MacAddr[3], dev->MacAddr[4], dev->MacAddr[5]);
      }
    break;

#ifdef S_VS
    case OP_BackupServer:
      value = dev->BackupServer;  org_value = org_dev->BackupServer;
    break;

    case OP_BackupTimer:
      value = dev->BackupTimer;  org_value = org_dev->BackupTimer;
    break;
#endif

    case OP_Name:
      if (strcmp(dev->Name, org_dev->Name) != 0)
      {
        chg_flag = 1;
        strcpy(value_str, dev->Name);
      }
    break;

    case OP_ModelName:
      if (strcmp(dev->ModelName, org_dev->ModelName) != 0)
      {
        chg_flag = 1;
        strcpy(value_str, dev->ModelName);
      }
    break;

#ifdef S_RK
    case OP_IoAddress:
      value = dev->IoAddress;  org_value = org_dev->IoAddress;
    break;
#endif

    case OP_ModemDevice:
      value = dev->ModemDevice;  org_value = org_dev->ModemDevice;
    break;

    case OP_HubDevice:
      value = dev->HubDevice;  org_value = org_dev->HubDevice;
    break;

    //------ Port Options ------
    case OP_WaitOnTx :
      value = port->WaitOnTx;
      org_value = org_port->WaitOnTx;
    break;
    case OP_RS485Override :
      value = port->RS485Override;
      org_value = org_port->RS485Override;
    break;
    case OP_RS485Low :
      value = port->RS485Low;
      org_value = org_port->RS485Low;
    break;
    case OP_TxCloseTime :
      value = port->TxCloseTime;  org_value = org_port->TxCloseTime;
    break;
    case OP_LockBaud :
      value = port->LockBaud;  org_value = org_port->LockBaud;
    break;
    case OP_Map2StopsTo1 :
      value = port->Map2StopsTo1;
      org_value = org_port->Map2StopsTo1;
    break;
    case OP_MapCdToDsr :
      value = port->MapCdToDsr;
      org_value = org_port->MapCdToDsr;
    break;
    case OP_RingEmulate :
      value = port->RingEmulate;
      org_value = org_port->RingEmulate;
    break;
    case OP_PortName :
      if (strcmp(port->Name, org_port->Name) != 0)
      {
        DbgPrintf(D_Test, ("chg port name:%s to %s\n",
             org_port->Name, port->Name))
        chg_flag = 1;
        strcpy(value_str, port->Name);
      }
    break;
    default:
      DbgPrintf(D_Error,(TEXT("Unknown Option %s ID:%x\n"),
                 option->name,
                 option->id));
      unknown_value = 1;
    break;
  }

  if ( (!unknown_value) &&
       (!(option->var_type == OP_T_STRING)) )
  {
    if (value != org_value)
    {
      chg_flag = 1;
      wsprintf(value_str, "%d", value);
    }
  }

  if (chg_flag)
  {
    DbgPrintf(D_Level,(TEXT("changed:%s\n"),option->name));
  }
  if (unknown_value)
  {
    DbgPrintf(D_Level,(TEXT("Unknown value:%s\n"),option->name));
  }
  *ret_chg_flag = chg_flag;
  *ret_unknown_flag = unknown_value;
  return 0;
}

/*-----------------------------------------------------------------------------
| our_ioctl_call - send our ascii option data to driver.  Driver will
   return 0 if successful, other values assume error, value of 52 if the 
   driver does not known what the option is.
|-----------------------------------------------------------------------------*/
int our_ioctl_call(IoctlSetup *ioctl_setup)
{
 int stat;
 char *pstr;

   stat = ioctl_call(ioctl_setup);
   if (stat)
   {
     return 0x100;  // failed ioctl call
   }

   //otherwise, driver returns "Option stat:#" with a decimal return code.
   pstr = (char *)&ioctl_setup->pm_base[1];  // find the return status value from the driver
   while ((*pstr != 0) && (*pstr != ':'))
     ++pstr;
   if (*pstr == ':')
   {
     ++pstr;
     stat = getint(pstr, NULL);  // atoi(), return driver code
     if (stat == 0)
     {
       //DbgPrintf(D_Level, (TEXT("ok ioctl\n")));
     }
     else
     {
       //DbgPrintf(D_Level, (TEXT("bad ioctl\n")));
     }
   }
   else
   {
     //DbgPrintf(D_Level, (TEXT("err ret on ioctl\n")));
     stat = 0x101;  // no return status given
   }

   return stat;
}

/*-----------------------------------------------------------------------------
| our_help -
|-----------------------------------------------------------------------------*/
int our_help(InstallPaths *ip, int index)
{
  strcpy(ip->tmpstr, ip->src_dir);
  strcat(ip->tmpstr,szSlash);
  strcat(ip->tmpstr,szSetup_hlp);

#ifdef NT50
  HtmlHelp(GetFocus(),ip->tmpstr, HH_HELP_CONTEXT, index);
#else
  WinHelp(GetFocus(),ip->tmpstr, HELP_CONTEXT, index);
#endif
  return 0;
}

/*-----------------------------------------------------------------
  validate_config -
|------------------------------------------------------------------*/
int validate_config(int auto_correct)
{
  int di, stat;
  Device_Config *dev;
  int invalid = 0;

  DbgPrintf(D_Level, ("validate_config\n"))
  for (di=0; di<wi->NumDevices; di++)
  {
    dev = &wi->dev[di];

    stat = validate_device(dev, 1);
    if (stat)
      invalid = 1;

  }
  return invalid;
}

/*-----------------------------------------------------------------------------
 validate_device - 
|-----------------------------------------------------------------------------*/
int validate_device(Device_Config *dev, int auto_correct)
{
 int invalid = 0;
 Port_Config *ps;
 int pi,stat;

  DbgPrintf(D_Level, ("validate_dev\n"))
  //----- verify the name is not blank
  if (dev->Name[0] == 0)
  {
    invalid = 1;
    if (auto_correct)
    {
#ifdef S_VS
      wsprintf(dev->Name, "VS #%d", wi->NumDevices+1);  // user designated name
#else
      wsprintf(dev->Name, "RK #%d", wi->NumDevices+1);  // user designated name
#endif
    }
  }

  //----- verify the number of ports is non-zero
  if (dev->NumPorts == 0)
  {
    invalid = 1;
    if (auto_correct)
    {
      dev->NumPorts = 8;  // 8 is common for rocketport
    }
  }

#ifdef S_RK
  //----- verify the number of ports is non-zero
  if (dev->IoAddress == 0)
  {
    invalid = 1;
    if (auto_correct)
    {
      if (dev->IoAddress == 0)
        dev->IoAddress = 1;  // setup for a pci-board
    }
  }
#endif

  if (wi->ModemCountry == 0)  // not valid
      wi->ModemCountry = mcNA;            // North America

#ifdef S_VS
  if (dev->BackupTimer < 2) dev->BackupTimer = 2; // 2 minute, no less
#endif

  for (pi=0; pi<dev->NumPorts; pi++)
  {
    ps = &dev->ports[pi];

    stat = validate_port(ps, auto_correct);
    if (stat)
      invalid = 1;
  }

  if (invalid)
  {
    DbgPrintf(D_Error, ("validate_dev:invalid config\n"))
  }

  return invalid;
}

/*-----------------------------------------------------------------------------
 validate_port - 
|-----------------------------------------------------------------------------*/
int validate_port(Port_Config *ps, int auto_correct)
{
 int invalid = 0;

  //DbgPrintf(D_Level, ("validate_port\n"))

  invalid = validate_port_name(ps, auto_correct);
  return invalid;
}

/*-----------------------------------------------------------------------------
 validate_port_name - 
|-----------------------------------------------------------------------------*/
int validate_port_name(Port_Config *ps, int auto_correct)
{
 int stat;
 int bad = 0;
 char oldname[26];
 int invalid = 0;

  //DbgPrintf(D_Level, ("validate_port_name 0\n"))
  stat = 0;
  //----- verify the name is unique
  if (ps->Name[0] == 0) {
    bad = 1;  // error, need a new name
  }

#if 0
  // take out due to tech. difficulties in the artificial intelligence area
  //DbgPrintf(D_Level, ("validate_port_name 1\n"))
  if (bad == 0)
  {
    stat = IsPortNameInSetupUse(ps->Name);
    if (stat > 1)
      bad = 2;  // error, more than one defined in our config
  }
  if (bad == 0)  // its ok, not in use
  {
    stat = IsPortNameInRegUse(ps->Name);
    if (stat == 2)  // in use, but by our driver, so ok
      stat = 0;
    if (stat != 0)
      bad = 3;  // error, more than one defined in our config
  }
#endif

  //DbgPrintf(D_Level, ("validate_port_name 2\n"))
  strcpy(oldname, ps->Name);
  if (bad != 0)  // need a new name, this one won't work
  {
    invalid = 1;
    if (auto_correct)
    {
      ps->Name[0] = 0;  // need this for newname func to work
      FormANewComPortName(ps->Name, NULL);
    }
    DbgPrintf(D_Level, (" New Name:%s Old:%s Code:%d\n", ps->Name, oldname, bad))
  }
  return invalid;
}

#if 0
/*-----------------------------------------------------------------------------
 rename_ascending - rename the rest of the ports on the board in
   ascending order.
|-----------------------------------------------------------------------------*/
void rename_ascending(int device_selected,
                      int port_selected)
{
  Device_Config *dev;
  Port_Config *ps;
  int i;
  char name[20];

   dev = &wi->dev[device_selected];
   ps = &dev->ports[port_selected];

   for (i=port_selected+1; i<dev->NumPorts; i++)
   {
     ps = &dev->ports[i];
     FormANewComPortName(name, dev->ports[port_selected-1].Name);
     strcpy(ps->Name, name);
     //validate_port_name(ps, 1);
   }
}
#endif

/*-----------------------------------------------------------------------------
  FormANewComPortName -
|-----------------------------------------------------------------------------*/
int FormANewComPortName(IN OUT TCHAR *szComName, IN TCHAR *szDefName)
{
  char try_name[25];
  int stat;
  char base_name[20];
  int num;
  //DbgPrintf(D_Level, ("Form a new name\n"))

   base_name[0] = 0;
   if (szDefName != NULL)
     strcpy(base_name, szDefName);
   else
     GetLastValidName(base_name);

   //DbgPrintf(D_Level, ("Base name:%s\n", base_name))

   num = ExtractNameNum(base_name);  // num = 3 if "COM3"
   if (num == 0)
     num = 3;
   else ++num;
   StripNameNum(base_name);

   if (base_name[0] == 0)
   {
     strcat(base_name, "COM");
   }

  stat = 2;
  while (stat != 0)
  {
    wsprintf(try_name, TEXT("%s%d"), base_name, num);
    //DbgPrintf(D_Level, ("try:%s\n", try_name))

    if (IsPortNameInSetupUse(try_name) != 0)
    {
       DbgPrintf(D_Level, (" SetupUse\n"))
       stat = 2;  // port in use by us
    }
    else
    {
      stat = IsPortNameInRegUse(try_name);
      if (stat)
      {
        if ( stat == 2 ) {
          stat = 0;
        } else {
          DbgPrintf(D_Level, (" InRegUse\n"))
        }
      }
    }
    if (stat == 0)
    {
      strcpy(szComName, try_name);
    }
    ++num;
  }
  //DbgPrintf(D_Level, ("End FormANewComPortName\n"))
  return 0;
}

/*-----------------------------------------------------------------------------
  GetLastValidName - Get a com-port name which makes sense to start naming
   things at.  So if our last com-port name is "COM45", then return this.
   Pick the Com-port with the highest number.
|-----------------------------------------------------------------------------*/
int GetLastValidName(IN OUT TCHAR *szComName)
{
 int di, pi;
 int last_di, last_pi;
 char tmpName[20];
 int num=0;

  for (di=0; di<wi->NumDevices; di++)
  {
    for (pi=0; pi<wi->dev[di].NumPorts; pi++)
    {
      strcpy(tmpName, wi->dev[di].ports[pi].Name);
      if (ExtractNameNum(tmpName) > num)
      {
        num = ExtractNameNum(tmpName);
        strcpy(szComName, wi->dev[di].ports[pi].Name);
        last_di = di;
        last_pi = pi;
      }
    }
  }
  if (num == 0)
    szComName[0] = 0;

  //DbgPrintf(D_Level, ("LastValidName:%s [%d.%d]\n", szComName, last_di, last_pi))
  return 0;
}

/*-----------------------------------------------------------------------------
  BumpPortName - Add 1 to the number of the comport name, so change "COM23"
    to "COM24".
|-----------------------------------------------------------------------------*/
int BumpPortName(IN OUT TCHAR *szComName)
{
  char tmpstr[25];
  int i;

  strcpy(tmpstr, szComName);
  i = ExtractNameNum(szComName);
  if (i< 1)
    i = 1;
  ++i;
  StripNameNum(tmpstr);
  wsprintf(szComName, "%s%d", tmpstr, i);
  return 0;
}

/*-----------------------------------------------------------------------------
  StripNameNum -
|-----------------------------------------------------------------------------*/
int StripNameNum(IN OUT TCHAR *szComName)
{
 char *pstr;

  pstr = szComName;
  while ((!isdigit(*pstr)) && (*pstr != 0))
  {
    pstr++;
  }
  *pstr = 0;  // null terminate at digit

  return 0;
}

/*-----------------------------------------------------------------------------
  ExtractNameNum -
|-----------------------------------------------------------------------------*/
int ExtractNameNum(IN TCHAR *szComName)
{
 int num;
 char *pstr;

   pstr = szComName;
   while ((!isdigit(*pstr)) && (*pstr != 0))
   {
     pstr++;
   }
   if (*pstr == 0)
     num = 0;
   else
     num = atoi(pstr);
   return num;
}

/*-----------------------------------------------------------------------------
  IsPortNameInSetupUse - Checks our setup info to see if com-port name is
    unique.
|-----------------------------------------------------------------------------*/
int IsPortNameInSetupUse(IN TCHAR *szComName)
{
 int di, pi;
 int times_in_use = 0;

  for (di=0; di<wi->NumDevices; di++)
  {
    for (pi=0; pi<wi->dev[di].NumPorts; pi++)
    {
      if (_tcsicmp(szComName, wi->dev[di].ports[pi].Name) == 0)
      {
        ++times_in_use;
#if DBG
        //if (times_in_use > 1)
        //  DbgPrintf(D_Level, (" %s InSetupUs:%d, [%d %d]\n",
        //     szComName, times_in_use, di, pi))
#endif
      }
    }
  }
  return times_in_use;
}

/*------------------------------------------------------------------------
  IsPortNameInRegUse - Checks registry area where com-ports typically export
    com-port names under NT.
    return 0=not in use, 1=in use by other driver,  2=in use by our driver.
|------------------------------------------------------------------------*/
int IsPortNameInRegUse(IN TCHAR *szComName)
{
  HKEY   hkey;
  int    i, nEntries;
  ULONG  dwSize, dwBufz;
  ULONG  dwType;
  TCHAR  szSerial[ 40 ];
  TCHAR  szCom[ 40 ];
  TCHAR  szDriver[8];

  _tcsncpy(szDriver, OurDriverName, 6);  // something to match to "vslink" or "rocket"
  szDriver[6] = 0;
  _tcsupr(szDriver);

                                     // "Hardware\\DeviceMap\\SerialComm"
  if( !RegOpenKeyEx( HKEY_LOCAL_MACHINE, m_szRegSerialMap,
                     0L, KEY_READ, &hkey ) )
  {
    dwBufz = sizeof( szSerial );
    dwSize = sizeof( szCom );
    nEntries = i = 0;

    while( !RegEnumValue( hkey, i++, szSerial, &dwBufz,
                          NULL, &dwType, (LPBYTE) szCom, &dwSize ) )
    {
      if (dwType != REG_SZ)
         continue;

      _tcsupr(szCom);
      _tcsupr(szSerial);
      if (_tcsicmp(szComName, szCom) == 0)
      {
        // compare 5 characters of the key name to our driver name
        if (_tcsstr(szSerial, szDriver) != NULL)
        {
          //DbgPrintf(D_Level, (" %s InRegUseUsOurs [%s,%s]\n", szComName,
          //  szSerial, szDriver))
          return 2; // in use, but probably ours
        }
        else
        {
          //DbgPrintf(D_Level, (" %s InRegUseUsNotOurs [%s,%s]\n", szComName,
          //  szSerial, szDriver))
          return 1;  // it's in use, someone elses driver
        }
      }
      ++nEntries;

      dwSize = sizeof( szCom );
      dwBufz = sizeof( szSerial );
    }

    RegCloseKey( hkey );
  }
  return 0;  // not in use
}

#ifdef LOG_MESS
/*------------------------------------------------------------------------
| log_mess -
|------------------------------------------------------------------------*/
void log_mess(char *str, HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  FILE *fp;
  int i;

  static struct {
    WORD value;
    char *string;
  }
  ddd[200] =
  {
    {WM_COMPACTING, "WM_COMPACTING"},
    {WM_WININICHANGE, "WM_WININICHANGE"},
    {WM_SYSCOLORCHANGE, "WM_SYSCOLORCHANGE"},
    {WM_QUERYNEWPALETTE, "WM_QUERYNEWPALETTE"},
    {WM_PALETTEISCHANGING, "WM_PALETTEISCHANGING"},
    {WM_PALETTECHANGED, "WM_PALETTECHANGED"},
    {WM_FONTCHANGE, "WM_FONTCHANGE"},
    {WM_SPOOLERSTATUS, "WM_SPOOLERSTATUS"},
    {WM_DEVMODECHANGE, "WM_DEVMODECHANGE"},
    {WM_TIMECHANGE, "WM_TIMECHANGE"},
    {WM_NULL, "WM_NULL"},
    {WM_USER, "WM_USER"},
    {WM_PENWINFIRST, "WM_PENWINFIRST"},
    {WM_PENWINLAST, "WM_PENWINLAST"},
#ifdef WIN16
    {WM_COALESCE_FIRST, "WM_COALESCE_FIRST"},
    {WM_COALESCE_LAST, "WM_COALESCE_LAST"},
#endif
    {WM_POWER, "WM_POWER"},
    {WM_QUERYENDSESSION, "WM_QUERYENDSESSION"},
    {WM_ENDSESSION, "WM_ENDSESSION"},
    {WM_QUIT, "WM_QUIT"},
#ifdef WIN16
    {WM_SYSTEMERROR, "WM_SYSTEMERROR"},
#endif
    {WM_CREATE, "WM_CREATE"},
    {WM_NCCREATE, "WM_NCCREATE"},
    {WM_DESTROY, "WM_DESTROY"},
    {WM_NCDESTROY, "WM_NCDESTROY"},
    {WM_SHOWWINDOW, "WM_SHOWWINDOW"},
    {WM_SETREDRAW, "WM_SETREDRAW"},
    {WM_ENABLE, "WM_ENABLE"},
    {WM_SETTEXT, "WM_SETTEXT"},
    {WM_GETTEXT, "WM_GETTEXT"},
    {WM_GETTEXTLENGTH, "WM_GETTEXTLENGTH"},
    {WM_WINDOWPOSCHANGING, "WM_WINDOWPOSCHANGING"},
    {WM_WINDOWPOSCHANGED, "WM_WINDOWPOSCHANGED"},
    {WM_MOVE, "WM_MOVE"},
    {WM_SIZE, "WM_SIZE"},
    {WM_QUERYOPEN, "WM_QUERYOPEN"},
    {WM_CLOSE, "WM_CLOSE"},
    {WM_GETMINMAXINFO, "WM_GETMINMAXINFO"},
    {WM_PAINT, "WM_PAINT"},
    {WM_ERASEBKGND, "WM_ERASEBKGND"},
    {WM_ICONERASEBKGND, "WM_ICONERASEBKGND"},
    {WM_NCPAINT, "WM_NCPAINT"},
    {WM_NCCALCSIZE, "WM_NCCALCSIZE"},
    {WM_NCHITTEST, "WM_NCHITTEST"},
    {WM_QUERYDRAGICON, "WM_QUERYDRAGICON"},
    {WM_DROPFILES, "WM_DROPFILES"},
    {WM_ACTIVATE, "WM_ACTIVATE"},
    {WM_ACTIVATEAPP, "WM_ACTIVATEAPP"},
    {WM_NCACTIVATE, "WM_NCACTIVATE"},
    {WM_SETFOCUS, "WM_SETFOCUS"},
    {WM_KILLFOCUS, "WM_KILLFOCUS"},
    {WM_KEYDOWN, "WM_KEYDOWN"},
    {WM_KEYUP, "WM_KEYUP"},
    {WM_CHAR, "WM_CHAR"},
    {WM_DEADCHAR, "WM_DEADCHAR"},
    {WM_SYSKEYDOWN, "WM_SYSKEYDOWN"},
    {WM_SYSKEYUP, "WM_SYSKEYUP"},
    {WM_SYSCHAR, "WM_SYSCHAR"},
    {WM_SYSDEADCHAR, "WM_SYSDEADCHAR"},
    {WM_KEYFIRST, "WM_KEYFIRST"},
    {WM_KEYLAST, "WM_KEYLAST"},
    {WM_MOUSEMOVE, "WM_MOUSEMOVE"},
    {WM_LBUTTONDOWN, "WM_LBUTTONDOWN"},
    {WM_LBUTTONUP, "WM_LBUTTONUP"},
    {WM_LBUTTONDBLCLK, "WM_LBUTTONDBLCLK"},
    {WM_RBUTTONDOWN, "WM_RBUTTONDOWN"},
    {WM_RBUTTONUP, "WM_RBUTTONUP"},
    {WM_RBUTTONDBLCLK, "WM_RBUTTONDBLCLK"},
    {WM_MBUTTONDOWN, "WM_MBUTTONDOWN"},
    {WM_MBUTTONUP, "WM_MBUTTONUP"},
    {WM_MBUTTONDBLCLK, "WM_MBUTTONDBLCLK"},
    {WM_MOUSEFIRST, "WM_MOUSEFIRST"},
    {WM_MOUSELAST, "WM_MOUSELAST"},
    {WM_NCMOUSEMOVE, "WM_NCMOUSEMOVE"},
    {WM_NCLBUTTONDOWN, "WM_NCLBUTTONDOWN"},
    {WM_NCLBUTTONUP, "WM_NCLBUTTONUP"},
    {WM_NCLBUTTONDBLCLK, "WM_NCLBUTTONDBLCLK"},
    {WM_NCRBUTTONDOWN, "WM_NCRBUTTONDOWN"},
    {WM_NCRBUTTONUP, "WM_NCRBUTTONUP"},
    {WM_NCRBUTTONDBLCLK, "WM_NCRBUTTONDBLCLK"},
    {WM_NCMBUTTONDOWN, "WM_NCMBUTTONDOWN"},
    {WM_NCMBUTTONUP, "WM_NCMBUTTONUP"},
    {WM_NCMBUTTONDBLCLK, "WM_NCMBUTTONDBLCLK"},
    {WM_MOUSEACTIVATE, "WM_MOUSEACTIVATE"},
    {WM_CANCELMODE, "WM_CANCELMODE"},
    {WM_TIMER, "WM_TIMER"},
    {WM_INITMENU, "WM_INITMENU"},
    {WM_INITMENUPOPUP, "WM_INITMENUPOPUP"},
    {WM_MENUSELECT, "WM_MENUSELECT"},
    {WM_MENUCHAR, "WM_MENUCHAR"},
    {WM_COMMAND, "WM_COMMAND"},
    {WM_HSCROLL, "WM_HSCROLL"},
    {WM_VSCROLL, "WM_VSCROLL"},
    {WM_CUT, "WM_CUT"},
    {WM_COPY, "WM_COPY"},
    {WM_PASTE, "WM_PASTE"},
    {WM_CLEAR, "WM_CLEAR"},
    {WM_UNDO, "WM_UNDO"},
    {WM_RENDERFORMAT, "WM_RENDERFORMAT"},
    {WM_RENDERALLFORMATS, "WM_RENDERALLFORMATS"},
    {WM_DESTROYCLIPBOARD, "WM_DESTROYCLIPBOARD"},
    {WM_DRAWCLIPBOARD, "WM_DRAWCLIPBOARD"},
    {WM_PAINTCLIPBOARD, "WM_PAINTCLIPBOARD"},
    {WM_SIZECLIPBOARD, "WM_SIZECLIPBOARD"},
    {WM_VSCROLLCLIPBOARD, "WM_VSCROLLCLIPBOARD"},
    {WM_HSCROLLCLIPBOARD, "WM_HSCROLLCLIPBOARD"},
    {WM_ASKCBFORMATNAME, "WM_ASKCBFORMATNAME"},
    {WM_CHANGECBCHAIN, "WM_CHANGECBCHAIN"},
    {WM_SETCURSOR, "WM_SETCURSOR"},
    {WM_SYSCOMMAND, "WM_SYSCOMMAND"},
    {WM_MDICREATE, "WM_MDICREATE"},
    {WM_MDIDESTROY, "WM_MDIDESTROY"},
    {WM_MDIACTIVATE, "WM_MDIACTIVATE"},
    {WM_MDIRESTORE, "WM_MDIRESTORE"},
    {WM_MDINEXT, "WM_MDINEXT"},
    {WM_MDIMAXIMIZE, "WM_MDIMAXIMIZE"},
    {WM_MDITILE, "WM_MDITILE"},
    {WM_MDICASCADE, "WM_MDICASCADE"},
    {WM_MDIICONARRANGE, "WM_MDIICONARRANGE"},
    {WM_MDIGETACTIVE, "WM_MDIGETACTIVE"},
    {WM_MDISETMENU, "WM_MDISETMENU"},
    {WM_CHILDACTIVATE, "WM_CHILDACTIVATE"},
    {WM_INITDIALOG, "WM_INITDIALOG"},
    {WM_NEXTDLGCTL, "WM_NEXTDLGCTL"},
    {WM_PARENTNOTIFY, "WM_PARENTNOTIFY"},
    {WM_ENTERIDLE, "WM_ENTERIDLE"},
    {WM_GETDLGCODE, "WM_GETDLGCODE"},
#ifdef WIN16
    {WM_CTLCOLOR, "WM_CTLCOLOR"},
#endif
    {WM_CTLCOLORMSGBOX, "WM_CTLCOLORMSGBOX"},
    {WM_CTLCOLOREDIT, "WM_CTLCOLOREDIT"},
    {WM_CTLCOLORLISTBOX, "WM_CTLCOLORLISTBOX"},
    {WM_CTLCOLORBTN, "WM_CTLCOLORBTN"},
    {WM_CTLCOLORDLG, "WM_CTLCOLORDLG"},
    {WM_CTLCOLORSCROLLBAR, "WM_CTLCOLORSCROLLBAR"},
    {WM_CTLCOLORSTATIC, "WM_CTLCOLORSTATIC"},

    {WM_SETFONT, "WM_SETFONT"},
    {WM_GETFONT, "WM_GETFONT"},
    {WM_DRAWITEM, "WM_DRAWITEM"},
    {WM_MEASUREITEM, "WM_MEASUREITEM"},
    {WM_DELETEITEM, "WM_DELETEITEM"},
    {0xfff0, "WM_?"}
};

  fp = fopen("log.tmp", "a");
  if (fp == NULL) return;
  i = 0;

  while (ddd[i].value != 0xfff0)
  {
    if (message == ddd[i].value) break;
    ++i;
  }

  if (ddd[i].value == 0xfff0)  /* not found */
  {
    if ((message >= WM_USER) && (message <= (WM_USER+0x100)))
      fprintf(fp, "%s,WM_USER+%x> ", str, message-WM_USER);
    else
      fprintf(fp, "%s,%s %x> ", str, ddd[i].string, message);
  }
  else
    fprintf(fp, "%s,%s> ", str, ddd[i].string);

  fprintf(fp, "h:%x, m:%x, w:%x, lh:%x ll:%x\n", hwnd, message, wParam,
                               HIWORD(lParam),  LOWORD(lParam));

  fclose(fp);
}

#endif

#ifndef S_VS
#ifndef S_RK
ERROR, makefile should define S_VS or S_RK
#endif
#endif

#ifdef S_VS
#ifdef S_RK
ERROR, makefile should define S_VS or S_RK
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\rocku.c ===
/*-----------------------------------------------------------------------
 rocku.c - Utils for setup program.  Get and Set registry settings.

11-05-97 V1.12, Add backup server fields to registry.

Copyright 1997,98 Comtrol(TM) Corporation.
|-----------------------------------------------------------------------*/
#include "precomp.h"

// had a problem with c-file stuff with DLL build, uncomment to ignore problem
//#define NO_CLIB_FILE_STUFF

static char *szSetupVer = {"SetupVersion"};

//---- port options:

static char *szParameters = {"Parameters"};
static char *szLinkage    = {"Linkage"};
static char *szSlash = {"\\"};
static char *szDeviceNode = {"Device%d"};
static char *szPortNode = {"Port%d"};

//static char gstr[200];

static int get_reg_option(int OptionVarType,
                          HKEY RegKey,
                          const char *szVarName,
                          char *szValue,
                          int szValueSize,
                          DWORD *ret_dword);

#ifdef NT50
/*-----------------------------------------------------------------
  clear_nt_device - clear out the Device# entries.
|------------------------------------------------------------------*/
int clear_nt_device(Driver_Config *wi)
{
 DWORD dstat;
 char tmpstr[50];
 char reg_str[240];
 HKEY DrvHandle = NULL;
 HKEY NewHandle = NULL;
 Device_Config *dev;

 int stat;

  DbgPrintf(D_Test, (TEXT("clear_nt_device\n")));

#ifdef NT50
  make_szSCS(reg_str, szServiceName);
  stat = reg_open_key(NULL, &NewHandle, reg_str, KEY_READ);
#else
  make_szSCS(reg_str, szServiceName);
  stat = reg_open_key(NULL, &NewHandle, reg_str, KEY_READ);
#endif
  if (stat == 0)
  {
    stat = reg_open_key(NewHandle, &DrvHandle, szParameters, KEY_READ);
    reg_close_key(NewHandle);
  }
  else
  {
    DbgPrintf(D_Error, (TEXT("no service key %s\n"), reg_str));
    return 1;
  }

  if (DrvHandle == NULL)
  {
    DbgPrintf(D_Error, (TEXT("no drv key for %s\n"), szParameters));
    return 2;
  }

  dev = &wi->dev[0];
#if (defined(NT50))
    // for nt50 and rocketport, the os tracks our devices, and
    // we use a pnp name to stash our configuration
  strcpy(tmpstr, wi->ip.szNt50DevObjName);
#else
  wsprintf(tmpstr, szDeviceNode, dev_i);
#endif

  RegDeleteKeyNT(DrvHandle, tmpstr);
  reg_close_key(DrvHandle);

  return 0;
}
#endif

/*-----------------------------------------------------------------
  get_nt_config - Read the configuration information from the registry.
|------------------------------------------------------------------*/
int get_nt_config(Driver_Config *wi)
{
 DWORD dstat, option_dword;               //hopefully ERROR_SUCCESS
 int dev_i, pi;
 Device_Config *dev;
 Port_Config *port;
 char tmpstr[50];
 char reg_str[240];
 char option_str[240];
 Our_Options *options;

 HKEY DrvHandle = NULL;
 HKEY DevHandle = NULL;
 HKEY PortHandle = NULL;
 //HKEY NewHandle = NULL;

 int stat;
#ifdef S_VS
 int mac_nums[6];
#endif
  DbgPrintf(D_Test, (TEXT("get_nt_config\n")));

  make_szSCS(reg_str, szServiceName);

  strcat(reg_str, szSlash);
  strcat(reg_str, szParameters);

  wi->nt_reg_flags = 0;      // default these flags to zero
  // get setup version string, helps us track if this is initial
  // install, if we are upgrading setup, etc.
  stat = reg_get_str(NULL, reg_str, szSetupVer, tmpstr, 10);
  if (stat != 0)
  {
     // failed to load this, so mark as initial install.
     wi->nt_reg_flags |= 4;  // initial install(no version string found).
  }

  wi->VerboseLog = 0;
#ifndef NT50
  wi->NumDevices = 0;  
#endif
  wi->NoPnpPorts = 0;
  wi->ScanRate = 0;
  wi->GlobalRS485 = 0;
  wi->ModemCountry = mcNA;            // North America

  options = driver_options;  // point at first in array(null terminated list)
  stat = reg_open_key(NULL, &DrvHandle, reg_str, KEY_READ);
  if (stat != 0)
  {
    DbgPrintf(D_Error, (TEXT("bad drv handle:%s\n"),reg_str));
  }
  while (options->name != NULL)
  {
    dstat = get_reg_option(options->var_type,  // dword, string, etc
                           DrvHandle,
                           options->name,  // name of var. to get
                           option_str,
                           60,
                           &option_dword);
    if (dstat == 0) // ok we read it
    {
      //DbgPrintf(D_Test, (TEXT("got drv op %s\n"), options->name));
      
      switch(options->id)
      {
        case OP_VerboseLog:
          wi->VerboseLog = option_dword;
        break;
        case OP_NumDevices:
          wi->NumDevices = option_dword;
        break;
        case OP_NoPnpPorts:
          wi->NoPnpPorts = option_dword;
        break;
        case OP_ScanRate:
          wi->ScanRate = option_dword;
        break;
        case OP_ModemCountry:
          wi->ModemCountry = option_dword;
        break;
        case OP_GlobalRS485:
          wi->GlobalRS485 = option_dword;
        break;
      }
    }
    else
    {
      //DbgPrintf(D_Error, (TEXT("no driver option %s\n"),options->name));
    }
    ++options; // next in list
  }  // while

  if (wi->NumDevices > MAX_NUM_DEVICES)   // limit to some sane value
     wi->NumDevices = MAX_NUM_DEVICES;
    // Loop through all possible boards/devices

  if (DrvHandle != NULL)
  {
    stat = reg_open_key(DrvHandle, &DevHandle, szParameters, KEY_READ);
  }

  //--- read in device options
  for(dev_i=0; dev_i<wi->NumDevices; dev_i++)
  {
    dev = &wi->dev[dev_i];
#if (defined(NT50))
      // for nt50 and rocketport, the os tracks our devices, and
      // we use a pnp name to stash our configuration
    strcpy(tmpstr, wi->ip.szNt50DevObjName);
#else
    wsprintf(tmpstr, szDeviceNode,dev_i);
#endif
    stat = reg_open_key(DrvHandle, &DevHandle, tmpstr, KEY_READ);
    if (stat)
    {
      DbgPrintf(D_Error, (TEXT("no dev key for %s\n"), tmpstr));
      continue;
    }

    options = device_options;  // point at first in array(null terminated list)
    while (options->name != NULL)
    {
      dstat = get_reg_option(options->var_type,  // dword, string, etc
                             DevHandle,
                             options->name,  // name of var. to get
                             option_str, 60, &option_dword);  // return string value
      if (dstat == 0) // ok we read it
      {
        //DbgPrintf(D_Test, (TEXT("got dev op %s\n"), options->name));
        switch(options->id)
        {
          case OP_NumPorts:
            dev->NumPorts = option_dword;
          break;
#ifdef S_VS
          case OP_MacAddr:
            stat = sscanf(option_str, "%x %x %x %x %x %x",
                     &mac_nums[0], &mac_nums[1], &mac_nums[2],
                     &mac_nums[3], &mac_nums[4], &mac_nums[5]);
            if (stat == 6)
            {
              dev->MacAddr[0] = mac_nums[0];
              dev->MacAddr[1] = mac_nums[1];
              dev->MacAddr[2] = mac_nums[2];
              dev->MacAddr[3] = mac_nums[3];
              dev->MacAddr[4] = mac_nums[4];
              dev->MacAddr[5] = mac_nums[5];

  DbgPrintf(D_Test, ("read config mac: %x %x %x %x %x %x\n",
           dev->MacAddr[0], dev->MacAddr[1], dev->MacAddr[2],
           dev->MacAddr[3], dev->MacAddr[4], dev->MacAddr[5]))
            }
          break;
          case OP_BackupServer:
            dev->BackupServer = option_dword;
          break;
          case OP_BackupTimer:
            dev->BackupTimer = option_dword;
    DbgPrintf(D_Test,(TEXT("reg backTimer:%d\n"), dev->BackupTimer));
          break;
#endif
          case OP_Name:
            if (strlen(option_str) >= sizeof(dev->Name))
              option_str[sizeof(dev->Name)-1] = 0;
            strcpy(dev->Name, option_str);
          break;
          case OP_ModelName:
            if (strlen(option_str) >= sizeof(dev->ModelName))
              option_str[sizeof(dev->ModelName)-1] = 0;
            strcpy(dev->ModelName, option_str);
          break;
#ifdef S_RK
          case OP_IoAddress:
            dev->IoAddress = option_dword;
          break;
#endif
          case OP_ModemDevice:
            dev->ModemDevice = option_dword;
          break;
          case OP_HubDevice:
            dev->HubDevice = option_dword;
          break;
        }
      }
      else
      {
        DbgPrintf(D_Test, (TEXT("NOT got dev op %s\n"), options->name));
      }
      ++options;
    }

    for(pi=0; pi<dev->NumPorts; pi++)   // Loop through all ports
    {
      port = &dev->ports[pi];

      port->LockBaud = 0;
      port->TxCloseTime = 0;
      port->MapCdToDsr = 0;
      port->RingEmulate = 0;
      port->WaitOnTx = 0;
      port->RS485Override = 0;
      port->RS485Low = 0;
      port->Map2StopsTo1 = 0;

      wsprintf(tmpstr, szPortNode,pi);
      stat = reg_open_key(DevHandle, &PortHandle, tmpstr, KEY_READ);
      if (stat)
      {
        DbgPrintf(D_Error, (TEXT("no port key: %s\n"), tmpstr));
        if (DevHandle == NULL)
        {
          DbgPrintf(D_Error, (TEXT("no dev handle\n")));
        }
        continue;
      }

      options = port_options;  // point at first in array(null terminated list)
      while (options->name != NULL)
      {
        dstat = get_reg_option(options->var_type,  // dword, string, etc
                               PortHandle,
                               options->name,  // name of var. to get
                               option_str, 60, &option_dword);  // return string value
        if (dstat == 0) // ok we read it
        {
          //DbgPrintf(D_Test, (TEXT("got port op %s\n"), options->name));
          switch(options->id)
          {
            case OP_WaitOnTx:
              port->WaitOnTx = option_dword;
            break;
            case OP_RS485Override:
              port->RS485Override = option_dword;
            break;
            case OP_RS485Low:
              port->RS485Low = option_dword;
            break;
            case OP_TxCloseTime:
              port->TxCloseTime = option_dword;
            break;
            case OP_LockBaud:
              port->LockBaud = option_dword;
            break;
            case OP_Map2StopsTo1:
              port->Map2StopsTo1 = option_dword;
            break;
            case OP_MapCdToDsr:
              port->MapCdToDsr = option_dword;
            break;
            case OP_RingEmulate:
              port->RingEmulate = option_dword;
            break;
            case OP_PortName:
              if (strlen(option_str) >= sizeof(port->Name))
                option_str[sizeof(port->Name)-1] = 0;
              strcpy(port->Name, option_str);
            break;
          }
        }
        ++options;
      }
      //wsprintf(dev->Name, "COM%d", pi+5);
      reg_close_key(PortHandle);
    }  // numports
    reg_close_key(DevHandle);
  }  // for all devices(boards or boxes)

  reg_close_key(DrvHandle);

                         // "SYSTEM\\CurrentControlSet\\Services -
                         //   \\EventLog\\System\\RocketPort"
  make_szSCSES(reg_str, szServiceName);
  if (!reg_key_exists(NULL,reg_str))
       wi->nt_reg_flags |= 1;  // missing important registry info(possibly)

  make_szSCS(reg_str, szServiceName);
  strcat(reg_str, szSlash); strcat(reg_str, szLinkage);
  if (!reg_key_exists(NULL, reg_str))
       wi->nt_reg_flags |= 2;  // missing linkage thing(did not install via network inf)

  return 0;
}

/*----------------------------------------------------------------------
 get_reg_option - read in a option from the registry, and convert it to
   ascii.
|----------------------------------------------------------------------*/
static int get_reg_option(int OptionVarType,
                          HKEY RegKey,
                          const char *szVarName,
                          char *szValue,
                          int szValueSize,
                          DWORD *ret_dword)
{
 int stat = 1;  // err
 //ULONG dwValue;

  if (RegKey == NULL)
    return 1;

  if (OptionVarType == OP_T_STRING)  // string option type
  {
    szValue[0] = 0;
    stat = reg_get_str(RegKey, "", szVarName, szValue, szValueSize);
    if (stat)
      szValue[0] = 0;
  }
  else  // DWORD option type
  {
    stat = reg_get_dword(RegKey, "", szVarName, ret_dword);
    if (stat)
      *ret_dword = 0;
  }
  return stat;
}

/*-----------------------------------------------------------------
  set_nt_config - Set the configuration information.
|------------------------------------------------------------------*/
int set_nt_config(Driver_Config *wi)
{
 int  i,pi, stat;
 char tmpstr[150];
 char str[240];
 DWORD dstat, dwstat;
 int bad_error = 0;
 int new_install = 0;
 Device_Config *dev;
 Port_Config *port;
 HKEY DrvHandle = NULL;
 HKEY DevHandle = NULL;
 HKEY PortHandle = NULL;
 HKEY NewHandle = NULL;

  DbgPrintf(D_Test, (TEXT("set_nt_config\n")));
  // -------- create the following if not present:
  // "SYSTEM\\CurrentControlSet\\Services\\RocketPort",
  make_szSCS(str, szServiceName);
  if (!reg_key_exists(NULL, str))
    dstat = reg_create_key(NULL, str);

  stat = reg_open_key(NULL, &NewHandle, str, KEY_ALL_ACCESS);
  if (stat)
  {
    DbgPrintf(D_Test, (TEXT("bad service handle:%s\n"),str));
  }

  // -------- create the following if not present:
  // "SYSTEM\\CurrentControlSet\\Services\\RocketPort\\Parameters",
  if (!reg_key_exists(NewHandle, szParameters))
    dstat = reg_create_key(NewHandle, szParameters);  // create it

  stat = reg_open_key(NewHandle, &DrvHandle, szParameters, KEY_ALL_ACCESS);
  if (stat)
  {
    DbgPrintf(D_Test, (TEXT("bad drv handle:%s\n"),str));
  }
  reg_close_key(NewHandle);

  //----- set setup version string, helps us track if this is initial
  // install, if we are upgrading setup, etc.
  dstat = reg_set_str(DrvHandle, "", szSetupVer, VERSION_STRING, REG_SZ);

  //---- see if parameter is present, if not assume it
  //---- is a new install(as apposed to changing parameters).
  dstat = reg_get_dword(DrvHandle, "", szNumDevices, &dwstat);
  if (dstat)
     new_install = 1;  // new install

  // -------- create the following if not present:
  // "SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\RocketPort"
  make_szSCSES(str, szServiceName);
  if (!reg_key_exists(NULL,str))
    dstat = reg_create_key(NULL,str);

                  // ---- Set the Event ID message-file name.
  strcpy(tmpstr, "%SystemRoot%\\system32\\IoLogMsg.dll;");
  strcat(tmpstr, "%SystemRoot%\\system32\\drivers\\");
  strcat(tmpstr, wi->ip.szDriverName);
  dstat = reg_set_str(NULL, str, "EventMessageFile", tmpstr, REG_EXPAND_SZ);
   
                  // ---- Set the supported types flags.
  dstat = reg_set_dword(NULL, str, "TypesSupported",
                  EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE |
                  EVENTLOG_INFORMATION_TYPE);

                  // ---- Setup some NT-specific registry variables
                  // "SYSTEM\\CurrentControlSet\\Services\\RocketPort",
  make_szSCS(str, szServiceName);
  dstat = reg_set_dword(NULL, str, "ErrorControl", SERVICE_ERROR_IGNORE); // 0

  dstat = reg_set_str(NULL, str, "Group", "Extended Base", REG_SZ);

  strcpy(tmpstr, "System32\\Drivers\\");
  strcat(tmpstr, wi->ip.szDriverName);
  dstat = reg_set_str(NULL, str, "ImagePath", tmpstr, REG_SZ);

  // allows user(programmer) to turn following off and leave it off!

  if (new_install) // fresh install
  {
#ifdef NT50
    dstat = reg_set_dword(NULL, str, "Start", 3); // SERVICE_DEMAND_START
#else
    dstat = reg_set_dword(NULL, str, "Start", SERVICE_AUTO_START);  // 2
#endif
  }
  dstat = reg_set_dword(NULL, str, "Tag", 1);  // 1 (load order)
  dstat = reg_set_dword(NULL, str, "Type", SERVICE_KERNEL_DRIVER);  // 1

  dstat = reg_set_dword_del(DrvHandle,"", szNumDevices, wi->NumDevices,0);
  dstat = reg_set_dword_del(DrvHandle,"", szModemCountry, wi->ModemCountry, mcNA);
  dstat = reg_set_dword_del(DrvHandle,"", szGlobalRS485, wi->GlobalRS485, 0);
  dstat = reg_set_dword_del(DrvHandle,"", szVerboseLog, wi->VerboseLog,0);
  dstat = reg_set_dword_del(DrvHandle,"", szScanRate, wi->ScanRate,0);
  dstat = reg_set_dword_del(DrvHandle,"", szNoPnpPorts, wi->NoPnpPorts,0);

  reg_close_key(DrvHandle);
#if (defined(NT50) && defined(USE_PNP_AREA))
  stat = nt5_open_dev_key(&NewHandle);
#else
  make_szSCS(str, szServiceName);
  stat = reg_open_key(NULL, &NewHandle, str, KEY_ALL_ACCESS);
  if (stat)
  {
    DbgPrintf(D_Test, (TEXT("bad service handle:%s\n"),str));
  }
#endif

  // -------- create the following if not present:
  // "SYSTEM\\CurrentControlSet\\Services\\RocketPort\\Parameters",
  if (!reg_key_exists(NewHandle, szParameters))
    dstat = reg_create_key(NewHandle, szParameters);  // create it

  stat = reg_open_key(NewHandle, &DrvHandle, szParameters, KEY_ALL_ACCESS);
  if (stat)
  {
    DbgPrintf(D_Test, (TEXT("Bad drv handle:%s\n"),str));
  }
  reg_close_key(NewHandle);


  for(i=0; i<wi->NumDevices; i++)   // Loop through all possible boxes
  {
    dev = &wi->dev[i];

#if (defined(NT50))
# ifdef USE_PNP_AREA
    tmpstr[0] = 0;
# else
      // for nt50 and rocketport, the os tracks our devices, and
      // we use a pnp name to stash our configuration
    strcpy(tmpstr, wi->ip.szNt50DevObjName);
#endif
#else
    wsprintf(tmpstr, szDeviceNode,i);
#endif

    if (tmpstr[0] != 0)
    {
      if (!reg_key_exists(DrvHandle, tmpstr))
        dstat = reg_create_key(DrvHandle, tmpstr);  // create it

      stat = reg_open_key(DrvHandle, &DevHandle, tmpstr, KEY_ALL_ACCESS);
      if (stat)
      {
        DbgPrintf(D_Test, (TEXT("bad dev handle:%s\n"),tmpstr));
      }
    }
    else
    {
      // must be nt50 pnp, where we write out to the pnp reg area.
      DevHandle = DrvHandle;
    }

    DbgPrintf(D_Test, (TEXT("set reg dev %s \n"), tmpstr));
    dstat = reg_set_dword_del(DevHandle,"", szNumPorts, dev->NumPorts,0);
    dstat = reg_set_str(DevHandle,"", szName, dev->Name, REG_SZ);
    dstat = reg_set_dword_del(DevHandle,"", szModemDevice, dev->ModemDevice, 0);
    dstat = reg_set_dword_del(DevHandle,"", szHubDevice, dev->HubDevice, 0);
    dstat = reg_set_str(DevHandle,"", szModelName, dev->ModelName, REG_SZ);
#ifdef S_VS
    dstat = reg_set_dword_del(DevHandle,"", szBackupServer, dev->BackupServer,0);
    dstat = reg_set_dword_del(DevHandle,"", szBackupTimer, dev->BackupTimer,0);
    wsprintf(tmpstr, "%x %x %x %x %x %x",
              dev->MacAddr[0], dev->MacAddr[1], dev->MacAddr[2],
              dev->MacAddr[3], dev->MacAddr[4], dev->MacAddr[5]);
    dstat = reg_set_str(DevHandle,"", szMacAddr, tmpstr,REG_SZ);
#else
  // rocket
    dstat = reg_set_dword_del(DevHandle,"", szIoAddress, dev->IoAddress,0);
#endif

    for(pi=0; pi<dev->NumPorts; pi++)   // Loop through all ports
    {
      port = &dev->ports[pi];
      wsprintf(tmpstr, szPortNode,pi);

      if (!reg_key_exists(DevHandle, tmpstr))
        dstat = reg_create_key(DevHandle, tmpstr);  // create it

      stat = reg_open_key(DevHandle, &PortHandle, tmpstr, KEY_ALL_ACCESS);
      if (stat)
      {
        DbgPrintf(D_Test, (TEXT("bad port handle:%s\n"),tmpstr));
      }

      //DbgPrintf(D_Test, (TEXT("set port %s \n"), tmpstr));
      dstat = reg_set_str(PortHandle,"", szName, port->Name, REG_SZ);
      dstat = reg_set_dword_del(PortHandle,"", szLockBaud, port->LockBaud, 0);
      dstat = reg_set_dword_del(PortHandle,"", szTxCloseTime, port->TxCloseTime, 0);
      dstat = reg_set_dword_del(PortHandle,"", szMapCdToDsr, port->MapCdToDsr, 0);
      dstat = reg_set_dword_del(PortHandle,"", szRingEmulate, port->RingEmulate, 0);
      dstat = reg_set_dword_del(PortHandle,"", szWaitOnTx, port->WaitOnTx, 0);
      dstat = reg_set_dword_del(PortHandle,"", szRS485Override, port->RS485Override, 0);
      dstat = reg_set_dword_del(PortHandle,"", szRS485Low, port->RS485Low, 0);
      dstat = reg_set_dword_del(PortHandle,"", szMap2StopsTo1, port->Map2StopsTo1, 0);
      reg_close_key(PortHandle);
    }  // ports loop

    // clear out any old box keys(bugbug:this won't work with values in it!)
    for(pi=dev->NumPorts; pi<MAX_NUM_PORTS_PER_DEVICE; pi++)// Loop through all ports
    {
      port = &dev->ports[pi];
      wsprintf(tmpstr, szPortNode,pi);

      if (reg_key_exists(DevHandle, tmpstr))
        reg_delete_key(DevHandle, "", tmpstr);  // create it
    }
    reg_close_key(DevHandle);
  }  // dev loop

  reg_close_key(DrvHandle);

  return 0;  // ok
}

/*----------------------------------------------------------------------
| copy_files_nt - Handle file copies for either Windows NT
|----------------------------------------------------------------------*/
int copy_files_nt(InstallPaths *ip)
{
 char *pstr;
 int stat;
#ifdef S_VS
 static char *nt_files[] = {
                            "ctmmdm35.inf",
                            "readme.txt",
                            "setup.exe",
                            "setup.hlp",
                            "wcom32.exe",
                            "wcom.hlp",
                            "portmon.exe",
                            "portmon.hlp",
                            "peer.exe",
                            "peer.hlp",
                            NULL};

 static char *nt_driver[] = {"vslinka.sys",
                             "vslinka.bin",
                             NULL};
#else
 static char *nt_files[] = {
                            "ctmmdm35.inf",
                            "readme.txt",
                            "setup.exe",
                            "setup.hlp",
                            "wcom32.exe",
                            "wcom.hlp",
                            "portmon.exe",
                            "portmon.hlp",
                            "peer.exe",
                            "ctmmdmld.rm",
                            "ctmmdmfw.rm",
                            "peer.hlp",
                            NULL};

 static char *nt_driver[] = {"rocket.sys",
                             NULL};

#endif
 static char *nt_inf[] = {  "mdmctm1.inf",
                            NULL};

  //------ Copy driver to the driver dir
  GetSystemDirectory(ip->dest_dir, 144);
  strcat(ip->dest_dir,"\\Drivers");

  stat = copy_files(ip, nt_driver);
  if (stat)
     return 1;  // error

  GetSystemDirectory(ip->dest_dir, 144);
  pstr = ip->dest_dir;
  while (*pstr)  // find end of string
    ++pstr;
  while ((*pstr != '\\')  && (pstr != ip->dest_dir)) // find "\\System32"
    --pstr;
  *pstr = 0;  // null terminate here
  strcat(ip->dest_dir,"\\Inf");  // copy to INF directory

  stat = copy_files(ip, nt_inf);

  GetSystemDirectory(ip->dest_dir, 144);
#ifdef S_VS
  strcat(ip->dest_dir, "\\vslink");
#else
  strcat(ip->dest_dir, "\\rocket");
#endif
#ifndef NO_CLIB_FILE_STUFF
  _mkdir(ip->dest_dir);
#endif
  stat = copy_files(ip, nt_files);

  return 0;  // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\setupu.h ===
// setupu.h

//--- flags for win_type
#define WIN_UNKNOWN     0
#define WIN_NT          1
#define WIN_95          2

//--- country codes for SocketModem support
#define mcNotUsed         0
#define mcAustria         1
#define mcBelgium         2
#define mcDenmark         3
#define mcFinland         4
#define mcFrance          5
#define mcGermany         6
#define mcIreland         7
#define mcItaly           8
#define mcLuxembourg      9
#define mcNetherlands     10
#define mcNorway          11
#define mcPortugal        12
#define mcSpain           13
#define mcSweden          14
#define mcSwitzerland     15
#define mcUK              16
#define mcGreece          17
#define mcIsrael          18
#define mcCzechRep        19
#define mcCanada          20
#define mcMexico          21
#define mcUSA             22         
#define mcNA              mcUSA          // North America
#define mcHungary         23
#define mcPoland          24
#define mcRussia          25
#define mcSlovacRep       26
#define mcBulgaria        27
// 28
// 29
#define mcIndia           30
// 31
// 32
// 33
// 34
// 35
// 36
// 37
// 38
// 39
#define mcAustralia       40
#define mcChina           41
#define mcHongKong        42
#define mcJapan           43
#define mcPhilippines     mcJapan
#define mcKorea           44
// 45
#define mcTaiwan          46
#define mcSingapore       47
#define mcNewZealand      48

typedef struct {
  HINSTANCE hinst;    // needed for some system calls
  int prompting_off;  // turns prompting off(silent install).
  int win_type;       // 0=unknown, 1=NT, 2=win95
  int major_ver;
  int minor_ver;

       // this holds the pnp-name we use as a registry key to hold
       // our device parameters in the registry for RocketPort & NT50
  char szNt50DevObjName[50];  // typical: "Device_002456

  char szServiceName[50];   // typical: "RocketPort"
  char szDriverName[50];    // typical: "Rocket.sys"
  char szAppDir[50];        // typical: "Rocket"
  char szAppName[150];      // typical: "RocketPort/RocketModem Setup"

  char src_dir[250];        // typical: "a:\"
  char dest_dir[250];       // typical: "c:\windows\system32\rocket

  // following are used as convenient buffer for build src/dest filenames
  char src_str[256];
  char dest_str[256];
  char tmpstr[256];
} InstallPaths;

//--- flags for io_sel[]
#define PCI_SEL 1
#define MCA_SEL 2

//--- flags for install_type
#define INS_NETWORK_INF   1     // traditional nt4.0 network install(oemsetup.inf)
#define INS_NT50_INF      2     // plug n pray nt5.0 install(rocketpt.inf)
#define INS_SIMPLE        3     // no inf, we installed

typedef struct Port_Config;     // forward decl.

// option_flags: option to ignore some tx-buffering
//#define OPT_WAITONTX       1
// option_flags: option to always process with 485 control on rts signal
//#define OPT_RS485_OVERRIDE 2
// option_flags: option to process 485 rts to low(backward) to enable tx.
//#define OPT_RS485_LOW      4
// option_flags: option to map CD to DSR.
//#define OPT_MAP_CDTODSR    8
// option_flags: option to map 2 stop bits to 1
//#define OPT_MAP_2TO1       10

typedef struct {
  int index;
  char  Name[16];       // actual com port name(example: "COM#")
  //char  Desc[42];       // a user description tag for convience
  DWORD LockBaud;       // override for the baud rate

  //DWORD Options;        // see bit options
  DWORD WaitOnTx : 1;
  DWORD RS485Override : 1;
  DWORD RS485Low : 1;
  DWORD Map2StopsTo1 : 1;
  DWORD MapCdToDsr : 1;
  DWORD RingEmulate : 1;

  DWORD TxCloseTime;    // seconds to wait for tx to finish spooling on close.
  HTREEITEM tvHandle;   // treeview handle
#ifdef NT50
 HANDLE hPnpNode;  // handle to device node
#endif
} Port_Config;

typedef struct {
  char Name[64];       // user designated name(limit to 59 chars please)
  char ModelName[50];  // (e.g., "RocketModem")
  BYTE MacAddr[6];     // mac addr, ff ff ff ff ff ff = auto
  int NumPorts;
  int ModemDevice;     // 1=RocketModem & VS2000, 0=RocketPort & VS1000
  int HubDevice;       // 1=SerialHub family, 0=VS family
  int IoAddress;       // rocketport(0=not installed, 1=pci, 0x180 = def isa io)
  int StartComIndex;   // first port(0=auto)
  int BackupServer;    // 1=backup server, 0=normal server
  int BackupTimer;     // delay timeout for backup to kick in(minutes)
  Port_Config *ports;  // ptr to an array of ports config structs
  HTREEITEM tvHandle;  // treeview handle
  int HardwareId;      // Pnp reads in a unique id from the reg/inf files.
} Device_Config;

#define MAX_NUM_DEVICES 64

typedef struct {
   int driver_type;  // 0=rocketport, 1=vs1000...

   // NT4.0 used older network style INF files, we need to switch
   // to newer NT5.0 style INF files.  As a alternative to both,
   // we allow running without an INF file where we copy over the
   // needed files and setup the registry directly.
  int install_style;

  int nt_reg_flags;     // 1H=new install, 2H=Missing registry entries

  // following is array of device config structs.
  Device_Config *dev;   // ptr to array of Device structs, up to MAX_NUM_DEVICES.
  int NumDevices;

  // following used to hold the current selection of io-addr, irq, etc.
  int  irq_sel;         //

  int ScanRate;       // in millisecond units.
  int VerboseLog;     // true if we want verbose event logging
  int NoPnpPorts;       // true if nt5.0 pnp ports active
  int UseIRQ;         // true if user wants to use an irq
  int ModemCountry;   // modem country code for internal modem devices
  int GlobalRS485;    // display RS485 options on all ports

  int DriverExitDone; // tells if we did all the Driver exit stuff.
  int NeedReset;      // flag, true if we need a reset to invoke changes
  int ChangesMade;    // flag, true if changes were made.

  InstallPaths ip;
} Driver_Config;

int APIENTRY setup_install_info(InstallPaths *ip,
                 HINSTANCE hinst,
                 char *NewServiceName,
                 char *NewDriverName,
                 char *NewAppName,
                 char *NewAppDir);

int APIENTRY remove_driver_reg_entries(char *ServiceName);
int APIENTRY remove_pnp_reg_entries(void);
DWORD APIENTRY RegDeleteKeyNT(HKEY hStartKey , LPTSTR pKeyName );
int APIENTRY modem_inf_change(InstallPaths *ip,
                              char *modemfile,
                              char *szModemInfEntry);
int APIENTRY backup_modem_inf(InstallPaths *ip);

#define CHORE_INSTALL 1
#define CHORE_START   2
#define CHORE_STOP    3
#define CHORE_REMOVE  4
#define CHORE_INSTALL_SERVICE 5
#define CHORE_IS_INSTALLED 6

int APIENTRY service_man(LPSTR lpServiceName, LPSTR lpBinaryPath, int chore);

int APIENTRY make_szSCS(char *str, const char *szName);
int APIENTRY make_szSCSES(char *str, const char *szName);
int APIENTRY copy_files(InstallPaths *ip, char **files);
int APIENTRY our_copy_file(char *dest, char *src);

int APIENTRY our_message(InstallPaths *ip, char *str, WORD option);
int APIENTRY load_str(HINSTANCE hinst, int id, char *dest, int str_size);
int APIENTRY our_id_message(InstallPaths *ip, int id, WORD prompt);
void APIENTRY mess(InstallPaths *ip, char *format, ...);
int APIENTRY unattended_add_port_entries(InstallPaths *ip,
                                         int num_entries,
                                         int start_port);
TCHAR *RcStr(int msgstrindx);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\strings.h ===
#define NUM_ROW_COUNTRIES 6
#define NUM_CTR_ROW_COUNTRIES 12

typedef struct {
  int RowCountryCode;
  char RowCountryName[40];
} row_entry;

/*-----------------------------------------------------------------*/

extern const char * szServiceName;
extern const char * szDriverDevice;

/* registry values - device options */
#ifdef S_RK
  extern const char * szRocketPort;
  extern const char * szRocketPort485;
  extern const char * szRocketPortPlus;
  extern const char * szRocketModem;
  extern const char * szRocketModemII;
  extern const char * szRocketModem_i;
#else
  extern const char * szVS1000;
  extern const char * szVS2000;
  extern const char * szSerialHub;
#endif

/* registry values - port options */

extern const char * szNP2;
extern const char * szNP4;
extern const char * szNP6;
extern const char * szNP8;
extern const char * szNP16;
extern const char * szNP32;
extern const char * szNP48;
extern const char * szNP64;

extern row_entry RowInfo[NUM_ROW_COUNTRIES];
extern row_entry CTRRowInfo[NUM_CTR_ROW_COUNTRIES];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\setup.h ===
//--- setup.h

// pluck the version out of ourver.h
#define VERSION_STRING VER_PRODUCTVERSION_STR

#define NUM_DRIVER_SHEETS 2

// these are now defined in the individual make files
//#define NT50
//#define S_VS   // vslink
//#define S_RK   // rocketport

#define CharSizeOf(s) (sizeof(s) / sizeof(TCHAR))

// for vs1000, which can have 64 ports:
#define MAX_NUM_PORTS_PER_DEVICE 64

// property sheet message sent to other sheets at same level
// to gather up changes
// from windows controls into our c-structs.
#define QUERYSIB_GET_OUR_PROPS 100

//---- macro to see if mac-addresses match
#define mac_match(_addr1, _addr2) \
     ( (*((DWORD *)_addr1) == *((DWORD *)_addr2) ) && \
       (*((WORD *)(_addr1+4)) == *((WORD *)(_addr2+4)) ) )

#define BOARD_SELECTED  0
#define PORT_SELECTED   1

typedef struct {
  HDEVINFO         DeviceInfoSet;  // a plug & play context handle
  PSP_DEVINFO_DATA DeviceInfoData; // a plug & play context handle
  int device_selected;      // the current/selected device(board or vs-box)
  int port_selected;        // the current/selected port
  int selected;             // tree view selection: 0=board selected, 1=port
} OUR_INFO;

typedef struct {
  int IsIsa;                // isa?  0 = pci bus
  int IsHub;                // serial hub?  0 = VS1000/2000
  int IoAddress;            // io base address
  int IsModemDev;           // 1=VS2000 or RocketModem
  int CountryIdx;           // list index for country code
  int CountryCode;          // actual country code
  int NumPorts;             // number of ports on board
  char BoardType[50];       // name of board model (e.g., RocketModem)
  BYTE MacAddr[6];          // mac addr, ff ff ff ff ff ff = auto
  int finished;             // flag
  int BackupServer;         // 1=backup server, 0=normal server
  int BackupTimer;          // delay timeout for backup to kick in(minutes)
} AddWiz_Config;

#define TYPE_RM_VS2000  1       
#define TYPE_RMII       2       
#define TYPE_RM_i       3

int DoDriverPropPages(HWND hwndOwner);
int allow_exit(int want_to_cancel);
void our_exit(void);

// for flags in setup_service
#define OUR_REMOVE        1
#define OUR_RESTART       2
#define OUR_INSTALL_START 4

// for which_service in setup_service
#define OUR_SERVICE 0
#define OUR_DRIVER  1
int setup_service(int flags, int which_service);

int our_help(InstallPaths *ip, int index);
void our_context_help(LPARAM lParam);
int ioctl_talk(unsigned char *buf, int ioctl_type,
                      unsigned char **ret_buf, int *ret_size);
int update_modem_inf(int ok_prompt);
int setup_utils_exist(void);
int setup_make_progman_group(int prompt);
int setup_init(void);
int copy_setup_init(void);
int remove_driver(int all);
int send_to_driver(int send_it);
int do_install(void);
int FillDriverPropertySheets(PROPSHEETPAGE *psp, LPARAM our_params);
int get_mac_list(char *buf, int in_buf_size, int *ret_buf_size);
BYTE *our_get_ping_list(int *ret_stat, int *ret_bytes);

int validate_config(int auto_correct);
int validate_port(Port_Config *ps, int auto_correct);
int validate_port_name(Port_Config *ps, int auto_correct);
int validate_device(Device_Config *dev, int auto_correct);
int FormANewComPortName(IN OUT TCHAR *szComName, IN TCHAR *szDefName);
int IsPortNameInSetupUse(IN TCHAR *szComName);
int IsPortNameInRegUse(IN TCHAR *szComName);
int GetLastValidName(IN OUT TCHAR *szComName);
void rename_ascending(int device_selected,
                      int port_selected);
int StripNameNum(IN OUT TCHAR *szComName);
int ExtractNameNum(IN TCHAR *szComName);
int BumpPortName(IN OUT TCHAR *szComName);

/* PCI Defines(copied from ssci.h in driver code) */
#define PCI_VENDOR_ID           0x11fe
#define PCI_DEVICE_32I          0x0001
#define PCI_DEVICE_8I           0x0002
#define PCI_DEVICE_16I          0x0003
#define PCI_DEVICE_4Q           0x0004
#define PCI_DEVICE_8O           0x0005
#define PCI_DEVICE_8RJ          0x0006
#define PCI_DEVICE_4RJ          0x0007
#define PCI_DEVICE_SIEMENS8     0x0008
#define PCI_DEVICE_SIEMENS16    0x0009
#define PCI_DEVICE_RPLUS4       0x000a
#define PCI_DEVICE_RPLUS8       0x000b
#define PCI_DEVICE_RMODEM6      0x000c
#define PCI_DEVICE_RMODEM4      0x000d
#define PCI_DEVICE_RPLUS2       0x000e
#define PCI_DEVICE_422RPLUS2    0x000f

/*--------------------------  Global Variables  ---------------------*/
//extern char *aptitle;
extern char *szAppName;
extern char *OurServiceName;
extern char *OurDriverName;
extern char *OurAppDir;
extern char *szSetup_hlp;
extern char szAppTitle[];
extern char *szDeviceNames[];


extern char *progman_list_nt[];
extern unsigned char broadcast_addr[6];
extern unsigned char mac_zero_addr[6];
extern HWND glob_hwnd;
extern HINSTANCE glob_hinst;      // current instance
extern char gtmpstr[250];
extern HWND  glob_hDlg;
extern int glob_device_index;
extern OUR_INFO *glob_info;
extern AddWiz_Config *glob_add_wiz;
extern Driver_Config *wi;      // current info
extern Driver_Config *org_wi;  // original info, use to detect changes
//extern Driver_Config *adv_org_wi;  // original info, use to detect changes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\setupu.c ===
/*--------------------------------------------------------------------------
  setupu.c - setup driver utilitities.
|--------------------------------------------------------------------------*/
#include "precomp.h"

char *szSlash      = {"\\"};
char *szSYSTEM     = {"SYSTEM"};
char *szCurrentControlSet = {"CurrentControlSet"};
char *szEnum       = {"Enum"};
char *szServices   = {"Services"};
char *szParameters = {"Parameters"};
char *szSecurity   = {"Security"};
char *szLinkage    = {"Linkage"};
char *szEventLog   = {"EventLog"};
char *szSystem     = {"System"};

// just turn debug for this module off
#define D_Level 0

/*----------------------------------------------------------------------
| setup_install_info - Get the version of Windows info, and the source path
   of where we are running from
|----------------------------------------------------------------------*/
int APIENTRY setup_install_info(InstallPaths *ip,
                 HINSTANCE hinst,
                 char *NewServiceName,  // "RocketPort" or "VSLink"
                 char *NewDriverName,   // "rocket.sys" or "vslink.sys"
                 char *NewAppName,      // "Comtrol RocketPort,RocketModem Install"
                 char *NewAppDir)       // "rocket" or "vslink"

{
  DWORD ver_info;
  char *str;
  int i;

  struct w_ver_struct {
    BYTE win_major;
    BYTE win_minor;
    BYTE dos_major;
    BYTE dos_minor;
  } *w_ver;

  ver_info = GetVersion();
  w_ver = (struct w_ver_struct *) &ver_info;

  if (ver_info < 0x80000000)
  {
    ip->win_type = WIN_NT;
    //wsprintf (szVersion, "Microsoft Windows NT %u.%u (Build: %u)",
    //(DWORD)(LOBYTE(LOWORD(dwVersion))),
    //(DWORD)(HIBYTE(LOWORD(dwVersion))),
    //      (DWORD)(HIWORD(dwVersion)) );
  }

  ip->major_ver = w_ver->win_major;
  ip->minor_ver = w_ver->win_minor;
  if (ip->win_type == WIN_UNKNOWN)
  {
    ip->win_type = WIN_NT;  // force it
  }

  //GetWindowsDirectory(ip->win_dir,144);
  //GetSystemDirectory(ip->system_dir,144);
  ip->hinst = hinst;

  // Initialize the default source path so that it uses the same
  // drive that the SETUP.EXE application was executed from.
  GetModuleFileName(hinst, ip->src_dir, sizeof(ip->src_dir));

  // chop off file name leaving only the directory
  str = ip->src_dir;
  i = strlen(str);
  if (i > 0) --i;
  while ((str[i] != '\\') && (i != 0))
    --i;
  if (i==0)
    str[0] = 0;  // problem, no install dir
  else
  {
    str[i] = 0;  // terminate over "\"
  }

  strcpy(ip->szServiceName, NewServiceName);
  strcpy(ip->szDriverName,  NewDriverName);
  strcpy(ip->szAppName,     NewAppName);
  strcpy(ip->szAppDir,     NewAppDir);

  GetSystemDirectory(ip->dest_dir, 144);
  strcat(ip->dest_dir, "\\");
  strcat(ip->dest_dir, NewAppDir);

  return 0;
}

/*------------------------------------------------------------------------
| unattended_add_port_entries - Add port entries so that RAS will "see"
   some ports which we can install to.  Normally the driver puts these
   entries in the reg on startup, the reg hardware area gets re-built
   every startup.  This is a kludge so that unattended install can
   go on to add RAS ports.
|------------------------------------------------------------------------*/
int APIENTRY unattended_add_port_entries(InstallPaths *ip,
                                         int num_entries,
                                         int start_port)
{
 int i;

static char *szSHDSt = {"HARDWARE\\DEVICEMAP\\SERIALCOMM"};
char szName[120];
char szCom[20];
char str[20];
//DWORD dwstat;

   if (start_port == 0)
     start_port = 5;

   reg_create_key(NULL, szSHDSt);  // "HARDWARE\\DEVICEMAP\\SERIALCOMM"

   for (i=0; i<num_entries; i++)
   {
     wsprintf(szCom,    "COM%d", i+start_port);
     strncpy(szName, ip->szAppDir, strlen(ip->szAppDir) + 1);  // "Rocket" or "VSLink"
     wsprintf(str, "%d", i);
     strncat(szName, str, strlen(str) + 1);
     reg_set_str(NULL, szSHDSt, szName, szCom, REG_SZ);
   }
  return 0;
}

/*-----------------------------------------------------------------
  remove_driver_reg_entries - 
|------------------------------------------------------------------*/
int APIENTRY remove_driver_reg_entries(char *ServiceName)
{
 int stat;
 char str[180];

  //our_message("Nuking RocketPort Reg Entry",MB_OK);

  make_szSCS(str, ServiceName);
  stat = reg_delete_key(NULL, str, szEnum);
  stat = reg_delete_key(NULL, str, szParameters);
  stat = reg_delete_key(NULL, str, szSecurity);
  stat = reg_delete_key(NULL, str, szLinkage);

  make_szSCS(str, NULL);
  stat = reg_delete_key(NULL, str, ServiceName);
  if (stat) {
    DbgPrintf(D_Level, ("Error 4E\n"))
  }

  // get rid of the Services\EventLog\..RocketPort entry
  make_szSCSES(str, NULL);
  stat = reg_delete_key(NULL, str, ServiceName);
  if (stat) {
    DbgPrintf(D_Level, ("Error 4F\n"))
  }
#ifdef NT50
#if 0
  remove_pnp_reg_entries();
#endif
#endif
  return 0;
}

#if 0
  this is experimental
/*--------------------------------------------------------------------------
| remove_pnp_reg_entries -
|--------------------------------------------------------------------------*/
int APIENTRY remove_pnp_reg_entries(void)
{
 DWORD stat, keystat;
static char *enum_pci = {"SYSTEM\\CurrentControlSet\\Enum\\PCI"};
static char *enum_root = {"SYSTEM\\CurrentControlSet\\Enum\\root"};
//static char root_name[124];
 char node_name[140];
 char *pc;
 DWORD node_i;
 HKEY hKey;

  DbgPrintf(D_Level, ("Looking\n"))

  keystat = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      enum_pci,
                      0,
                      KEY_ENUMERATE_SUB_KEYS | KEY_EXECUTE | KEY_QUERY_VALUE,
                      &hKey);

  if (keystat != ERROR_SUCCESS)
  {
    DbgPrintf(D_Level, ("Err14a\n"))
    return 1;
  }

  node_i = 0;
  stat = RegEnumKey (hKey, node_i++, node_name, 138);
  while (stat == ERROR_SUCCESS)
  {
    pc = node_name;
    while (*pc)
    {
      *pc = toupper(*pc);
      ++pc;
    }

    if (strstr(node_name, "VEN_11FE") != 0)
    {
       // found a Comtrol hardware node
      DbgPrintf(D_Level, ("Found Node:%s\n", node_name))
      stat = RegDeleteKeyNT(hKey, node_name);
      if (stat != ERROR_SUCCESS)
      {
        DbgPrintf(D_Level, ("No Delete\n"))
      }
      //stat = reg_delete_key(NULL, node_name, node_name);
    }
    stat = RegEnumKey (hKey, node_i++, node_name, 68);
  }
  RegCloseKey (hKey);   // Close the key handle.
  return 0;
}
#endif

/*--------------------------------------------------------------------------
 RegDeleteKeyNT -
   A registry key that is opened by an application can be deleted
   without error by another application in both Windows 95 and
   Windows NT. This is by design.
|--------------------------------------------------------------------------*/
DWORD APIENTRY RegDeleteKeyNT(HKEY hStartKey , LPTSTR pKeyName )
{
   DWORD   dwRtn, dwSubKeyLength;
   LPTSTR  pSubKey = NULL;
   TCHAR   szSubKey[256]; // (256) this should be dynamic.
   HKEY    hKey;

   // do not allow NULL or empty key name
   if ( pKeyName &&  lstrlen(pKeyName))
   {
      if( (dwRtn=RegOpenKeyEx(hStartKey,pKeyName,
         0, KEY_ENUMERATE_SUB_KEYS | DELETE, &hKey )) == ERROR_SUCCESS)
      {
         while (dwRtn == ERROR_SUCCESS )
         {
            dwSubKeyLength = 250;
            dwRtn=RegEnumKeyEx(
                           hKey,
                           0,       // always index zero
                           szSubKey,
                           &dwSubKeyLength,
                           NULL,
                           NULL,
                           NULL,
                           NULL
                         );

            if(dwRtn == ERROR_NO_MORE_ITEMS)
            {
               dwRtn = RegDeleteKey(hStartKey, pKeyName);
               break;
            }
            else if(dwRtn == ERROR_SUCCESS)
               dwRtn=RegDeleteKeyNT(hKey, szSubKey);
         }
         RegCloseKey(hKey);
         // Do not save return code because error
         // has already occurred
      }
      else
      {
        DbgPrintf(D_Level, ("Access Error\n"))
      }
   }
   else
      dwRtn = ERROR_BADKEY;
   return dwRtn;
}

/*---------------------------------------------------------------------------
| modem_inf_change - go make the needed changes to the modem.inf file.
|  Make a backup copy too.
|----------------------------------------------------------------------------*/
int APIENTRY modem_inf_change(InstallPaths *ip,
                              char *modemfile,
                              char *szModemInfEntry)
{
 int i=0;
 int stat = 1;
 OUR_FILE *fp;   // in
 OUR_FILE *fp2;  // out
 OUR_FILE *fp_new;  // entries file to add
 char buf[202];
 char *str;
 char *szRAS={"\\RAS\\"};
 int section = 0;
 int chk;

 DbgPrintf(D_Level, ("chg inf start\n"))

               // first backup original modem.inf if not done already.
  stat = backup_modem_inf(ip);
  if (stat)
    return 1;  // err, couldn't backup modem.inf

 DbgPrintf(D_Level, ("chg A\n"))
  GetSystemDirectory(buf, 144);
  strcat(buf,"\\");
  strcat(buf,modemfile);
  fp_new  = our_fopen(buf, "rb");    // rocket\rocket35.inf
 DbgPrintf(D_Level, ("chg B\n"))

  if (fp_new == NULL)
  {
    wsprintf(ip->tmpstr,RcStr((MSGSTR+15)),buf);
    stat = our_message(ip, ip->tmpstr, MB_OK);
    return 1;
  }

  GetSystemDirectory(ip->dest_str, 144);
  strcat(ip->dest_str, szRAS);
  strcat(ip->dest_str,"modem.inf");

     //----- now copy modem.inf to modem.rk0 as a base to read from and
     // write new file
  GetSystemDirectory(ip->src_str, 144);
  strcat(ip->src_str, szRAS);
  strcat(ip->src_str,"modem.rk0");

  stat = our_copy_file(ip->src_str, ip->dest_str);
  if (stat)
  {
    wsprintf(ip->tmpstr,RcStr((MSGSTR+16)), ip->dest_str, ip->src_str, stat);
    stat = our_message(ip, ip->tmpstr, MB_OK);
    return 2;  // err
  }

  fp  = our_fopen(ip->src_str, "rb");    // modem.rk0
  if (fp == NULL)
  {
    wsprintf(ip->tmpstr,RcStr((MSGSTR+17)), ip->src_str);
    stat = our_message(ip, ip->tmpstr, MB_OK);
    return 1;
  }

  fp2 = our_fopen(ip->dest_str, "wb");   // modem.inf
  if (fp2 == NULL)
  {
    wsprintf(ip->tmpstr, "Tried to open the %s file for changes, but could not open it.", ip->dest_str);
    our_fclose(fp);
    return 1;
  }

  chk = 0;
  while ((our_fgets(buf, 200, fp)) && (!our_feof(fp)) && (!our_ferror(fp)) && (!our_ferror(fp2)) &&
         (chk < 30000))
  {
    ++chk;
    // search and kill any 0x1a eof markers
    str = buf;
    while (*str != 0)
    {
      if (*str == 0x1a)
        *str = ' ';  // change eof to space
      ++str;
    }
    
    // pass up spaces
    str = buf;
    while (*str == ' ')
      ++str;
    if (*str == '[')
    {
      
      if (str[0] == '[')  // starting new section
      {
        section = 0;  // not our section to worry about

        if (my_substr_lstricmp(str, szModemInfEntry) == 0)  // match
        {
          // make sure 
          section = 1;
        }
      }  // end of new [] section header
    }

    // process all entries here
    if (section == 1)
      str[0] = 0;  // first delete all "[Comtrol RocketModem]" entries

    if (str[0] != 0)
    {
      str = buf;  // don't skip spaces
      our_fputs(buf,fp2);
    }
  }  // end of while fgets();

  stat = 0;
  if ( (our_ferror(fp)) || (our_ferror(fp2)) || (chk >= 10000))
  {
    stat = 3;  // error
  }

  if (stat)
  {
    our_fclose(fp);
    our_fclose(fp2);
    our_fclose(fp_new);
    // try to restore to the read file backup(modem.rk0)
    stat = our_copy_file(ip->dest_str, ip->src_str);
    wsprintf(ip->tmpstr, "Errors encountered while making %s file changes.", ip->dest_str);
    stat = 3;  // error
  }
  else
  {
    // append the changes to it

    our_fputs("\x0d\x0a",fp2);
    our_fputs(szModemInfEntry, fp2);
    our_fputs("\x0d\x0a;-------------------\x0d\x0a",fp2);
    while ((our_fgets(buf, 200, fp_new)) && (!our_feof(fp_new)) && (!our_ferror(fp2)))
    {
      our_fputs(buf,fp2);
    }
    our_fclose(fp);
    our_fclose(fp2);
    our_fclose(fp_new);
    our_remove(ip->src_str);  // kill temporary modem.rk0 file
  }

  return stat;
}

/*---------------------------------------------------------------------------
| backup_modem_inf -  backs up to modem.bak.
|----------------------------------------------------------------------------*/
int APIENTRY backup_modem_inf(InstallPaths *ip)
{
 int stat = 1;
 char *szRAS = {"\\RAS\\"};
 OUR_FILE *fp;

               // first copy modem.inf over to our directory as a backup
  GetSystemDirectory(ip->dest_str, 144);
  strcat(ip->dest_str, szRAS);
  strcat(ip->dest_str,"modem.bak");

  GetSystemDirectory(ip->src_str, 144);
  strcat(ip->src_str, szRAS);
  strcat(ip->src_str,"modem.inf");

  fp  = our_fopen(ip->dest_str, "rb");  // see if already backed up
  if (fp == NULL)
  {
    stat = our_copy_file(ip->dest_str, ip->src_str);
    if (stat != 0)
    {
      wsprintf(ip->tmpstr,RcStr((MSGSTR+18)), ip->src_str, stat);
      our_message(ip, ip->tmpstr, MB_OK);
      return 1;  // err
    }
  }
  else our_fclose(fp);

  return 0; // ok
}

/*---------------------------------------------------------------------------
| service_man - Handle installation, removal, starting, stopping of NT
   services(or drivers.).
|----------------------------------------------------------------------------*/
int APIENTRY service_man(LPSTR lpServiceName, LPSTR lpBinaryPath, int chore)
{ 
  SC_HANDLE hSCManager = NULL; 
  SC_HANDLE hService   = NULL; 
  SC_LOCK   lSCLock    = NULL; 
//  SERVICE_STATUS ServiceStatus;
  BOOL Status = 1;  // success
  int stat = 0;  // ret status(0=ok)
 
  hSCManager = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS ); 
 
  if (hSCManager == NULL) 
  { 
     return 2; 
  } 
    //---- Lock the service database
  lSCLock = LockServiceDatabase( hSCManager ); 
  if (lSCLock == NULL) 
  { 
    CloseServiceHandle( hSCManager ); 
    return 1; 
  }

  if ((chore != CHORE_INSTALL) && (chore != CHORE_INSTALL_SERVICE))
  {
    hService = OpenService( hSCManager, lpServiceName, SERVICE_ALL_ACCESS);
    if (hService == NULL)
    {
      UnlockServiceDatabase( lSCLock ); 
      CloseServiceHandle( hSCManager ); 
      return 2;
    }
  }

  switch(chore)
  {
    case CHORE_INSTALL:
      // Create the service
      hService = CreateService( hSCManager, 
                            lpServiceName,     // Service's name 
                            lpServiceName,     // Display name (new for NT) 
                            SERVICE_ALL_ACCESS,// Access (allow all) 
                            SERVICE_KERNEL_DRIVER, // Service type 
                            SERVICE_AUTO_START,    // Startup behavior 
                            0x1,               // Error control 
                            lpBinaryPath,      // Full pathname of binary 
                            NULL,              // Load order group 
                            NULL,              // Tag ID 
                            NULL,              // Dependencies (none) 
                            NULL,              // Account name 
                            NULL               // Password 
                            ); 
      if (hService == NULL)
        stat = 5;
      Status = 0;
    break;

    case CHORE_START:
      // Unlock the database
      if (lSCLock != NULL)
      {
        UnlockServiceDatabase( lSCLock ); 
        lSCLock = NULL;
      }

      Status = StartService(hService,  0, NULL);
      //if (Status !=
      if (Status == 0)  // false
      {
        stat = GetLastError();
        Status = 1;
      }
    break;

    case CHORE_STOP:
      {
        SERVICE_STATUS ss;
        Status = ControlService(hService,  SERVICE_CONTROL_STOP, &ss);
        if (Status == 0)  // false
        {
          stat = GetLastError();
          if (stat == 0)
            stat = 1234;
          Status = 1;
        }
      }
    break;

    case CHORE_REMOVE:
      Status = DeleteService(hService);
    break;

    case CHORE_INSTALL_SERVICE:
      // Create the service
      hService = CreateService( hSCManager, 
                            lpServiceName,     // Service's name 
                            lpServiceName,     // Display name (new for NT) 
                            SERVICE_ALL_ACCESS,// Access (allow all)
                            SERVICE_WIN32_OWN_PROCESS, // Service type
                            SERVICE_AUTO_START,    // Startup behavior
                            SERVICE_ERROR_NORMAL,  // Error control
                            lpBinaryPath,      // Full pathname of binary
                            NULL,              // Load order group
                            NULL,              // Tag ID
                            NULL,              // Dependencies (none)
                            NULL,              // Account name
                            NULL               // Password
                            );
      if (hService == NULL)
        stat = 6;
      //Status = 0;
    break;

    case CHORE_IS_INSTALLED:
      // return without error to indicate it is installed.
    break;
  }
  if (Status == 0)  // false
    stat = 8;

  // Close our handle to the new service
  if (hService != NULL)
    CloseServiceHandle(hService); 

  // Unlock the database
  if (lSCLock != NULL)
    UnlockServiceDatabase( lSCLock ); 

  // Free our handle to the service control manager
  CloseServiceHandle( hSCManager ); 
  return stat; 
} 

/*-----------------------------------------------------------------
  make_szSCS - Services area.
    form ascii string: "SYSTEM\CurrentControlSet\Services"
|------------------------------------------------------------------*/
int APIENTRY make_szSCS(char *str, const char *szName)
{
  strcpy(str, szSYSTEM);  strcat(str, szSlash);
  strcat(str, szCurrentControlSet); strcat(str, szSlash);
  strcat(str, szServices);
  if (szName != NULL)
  {
    strcat(str, szSlash);
    strcat(str, szName);
  }
  return 0;
}

/*-----------------------------------------------------------------
  make_szSCSES - Event log reg area
   form ascii string: "SYSTEM\CurrentControlSet\Services\EventLog\System"
|------------------------------------------------------------------*/
int APIENTRY make_szSCSES(char *str, const char *szName)
{
  strcpy(str, szSYSTEM);  strcat(str, szSlash);
  strcat(str, szCurrentControlSet); strcat(str, szSlash);
  strcat(str, szServices); strcat(str, szSlash);
  strcat(str, szEventLog); strcat(str, szSlash);
  strcat(str, szSystem);
  if (szName != NULL)
  {
    strcat(str, szSlash);
    strcat(str, szName);
  }
  return 0;
}

/*---------------------------------------------------------------------------
| copy_files - copy a list of files from wi->src_dir to wi->dest_dir
|   Uses the wi->src_str & wi->dest_str.  Assumes you want the same name
|   as copying from.
|----------------------------------------------------------------------------*/
int APIENTRY copy_files(InstallPaths *ip, char **files)
{
 int i=0;
 int stat;

  if (my_lstricmp(ip->src_dir, ip->dest_dir) == 0) // src_dir == dest_drv
    return 0;

  while (files[i] != NULL)
  {
    strcpy(ip->src_str, ip->src_dir);
    strcat(ip->src_str, szSlash);
    strcat(ip->src_str, files[i]);

    strcpy(ip->dest_str, ip->dest_dir);
    strcat(ip->dest_str, szSlash);
    strcat(ip->dest_str, files[i]);
again1:
    stat = our_copy_file(ip->dest_str, ip->src_str);
    if (stat)
    {
      //if (stat == 1)  // error opening read file
      //  return 1;  // don't report errors, since some driver sets differ in
                   // which files they include
      // (that was a stupid idea(karl to karl)!)

      wsprintf(ip->tmpstr,RcStr((MSGSTR+19)), ip->src_str, ip->dest_str);
      stat = our_message(ip, ip->tmpstr, MB_ABORTRETRYIGNORE);
      if (stat == IDABORT)
        return 1;  // error
      if (stat == IDRETRY) goto again1;
    }
    ++i;
  }
  return 0;
}

/*---------------------------------------------------------------------------
| our_copy_file - copy a file from here to there.
|----------------------------------------------------------------------------*/
int APIENTRY our_copy_file(char *dest, char *src)
{
 int stat;

  // just use the stock Win32 function
  stat = CopyFile(src, dest,
                  0);  // 1=fail if exist
  if (stat)
    return 0; // ok, worked

  return 1; // failed

#ifdef COMMENT_OUT
 char *buf;
 unsigned int bytes, wbytes;
 int err = 0;
 int chk = 0;

 OUR_FILE *fp1, *fp2;

  buf = (char *) malloc(0x4010);
  if (buf == NULL)
  {
    //our_message("Error, no memory",MB_OK);
    return 6;  // no mem
  }

  fp1 = our_fopen(src,"rb");
  if (fp1 == NULL)
  {
    //our_message("Error Opening to read",MB_OK);
    free(buf);
    return 1;  // no src
  }

  fp2 = our_fopen(dest,"wb");
  if (fp2 == NULL)
  {
    //our_message("Error Opening to write",MB_OK);
    free(buf);
    our_fclose(fp1);
    return 2;  /* err opening dest */
  }

  bytes = our_fread(buf, 1, 0x4000, fp1);
  while ((bytes > 0) && (!err))
  {
    ++chk;
    if (chk > 10000)
      err = 5;
    wbytes = our_fwrite(buf, 1, bytes, fp2);
    if (wbytes != bytes)
    {
      err = 3;
    }
    bytes = our_fread(buf, 1, 0x4000, fp1);

    if (our_ferror(fp1))
    {
      //our_message("Error reading",MB_OK);
      err = 4;
    }
    if (our_ferror(fp2))
    {
      //our_message("Error writing",MB_OK);
      err = 6;
    }
  }

  free(buf);
  our_fclose(fp1);
  our_fclose(fp2);

  return err;  // 0=ok, else error
#endif
}

/*-----------------------------------------------------------------------------
| our_message -
|-----------------------------------------------------------------------------*/
int APIENTRY our_message(InstallPaths *ip, char *str, WORD option)
{
  if (ip->prompting_off)
  {
    // we are doing unattended install, and don't want user interface
    // popping up.  So just say YES or OK to all prompts.
    if (option == MB_YESNO)
      return IDYES;
    return IDOK;
  }
  return MessageBox(GetFocus(), str, ip->szAppName, option);
}

/*-----------------------------------------------------------------------------
| load_str -
|-----------------------------------------------------------------------------*/
int APIENTRY load_str(HINSTANCE hinst, int id, char *dest, int str_size)
{
  dest[0] = 0;
  if (!LoadString(hinst, id, dest, str_size) )
  {
    wsprintf(dest,"Err,str-id %d", id);
    MessageBox(GetFocus(), dest, "Error", MB_OK);
    return 1;
  }
  return 0;
}

#if 0
/*-----------------------------------------------------------------------------
| our_id_message -
|-----------------------------------------------------------------------------*/
int APIENTRY our_id_message(InstallPaths *ip, int id, WORD prompt)
{
 int stat;
  if (ip->prompting_off)
  {
    // we are doing unattended install, and don't want user interface
    // popping up.  So just say YES or OK to all prompts.
    if (option == MB_YESNO)
      return IDYES;
    return IDOK;
  }

  load_str(ip->hinst, id, ip->tmpstr, CharSizeOf(ip->tmpstr));
  stat = our_message(ip, ip->tmpstr, prompt);
  return stat;
}
#endif

/*---------------------------------------------------------------------------
| mess - message
|---------------------------------------------------------------------------*/
void APIENTRY mess(InstallPaths *ip, char *format, ...)
{
  va_list next;
  char buf[200];

  if (ip->prompting_off)
    return;

  va_start(next, format);
  vsprintf(buf, format, next);
  MessageBox(GetFocus(), buf, ip->szAppName, MB_OK);
}

TCHAR *
RcStr( int MsgIndex )
{
  static TCHAR RcStrBuf[200];

  load_str(glob_hinst, MsgIndex, RcStrBuf, CharSizeOf(RcStrBuf) );
  if (!LoadString(glob_hinst, MsgIndex, RcStrBuf, CharSizeOf(RcStrBuf)) ) {
    wsprintf(RcStrBuf,"Err, str-id %d", MsgIndex);
  }

  return RcStrBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\comtrol\rocket\setup\strings.c ===
#include "strings.h"

/* Module to hold const strings used in setup program */

#ifdef S_VS
const char * szServiceName      = {"VSLinkA"};
const char * szDriverDevice     = {"\\\\.\\vslinka"};
#else
const char * szServiceName      = {"RocketPort"};
const char * szDriverDevice     = {"\\\\.\\rocket"};
#endif

/* registry values - device options */
#ifdef S_RK
  const char * szRocketPort     = {"RocketPort"};
  const char * szRocketPort485  = {"RocketPort 485"};
  const char * szRocketPortPlus = {"RocketPort Plus"};
  const char * szRocketModem    = {"RocketModem"};
  const char * szRocketModemII  = {"RocketModemII"};
  const char * szRocketModem_i  = {"RocketModem i"};
#else
  const char * szVS1000         = {"VS1000"};
  const char * szVS2000         = {"VS2000"};
  const char * szSerialHub      = {"RocketPort Serial Hub"};
#endif

/* values - port options */
const char * szNP2            = {"2"};
const char * szNP4            = {"4"};
const char * szNP6            = {"6"};
const char * szNP8            = {"8"};
const char * szNP16           = {"16"};
const char * szNP32           = {"32"};
const char * szNP48           = {"48"};
const char * szNP64           = {"64"};

//--- country codes for SocketModem support
#define mcNotUsed         0
#define mcAustria         1
#define mcBelgium         2
#define mcDenmark         3
#define mcFinland         4
#define mcFrance          5
#define mcGermany         6
#define mcIreland         7
#define mcItaly           8
#define mcLuxembourg      9
#define mcNetherlands     10
#define mcNorway          11
#define mcPortugal        12
#define mcSpain           13
#define mcSweden          14
#define mcSwitzerland     15
#define mcUK              16
#define mcGreece          17
#define mcIsrael          18
#define mcCzechRep        19
#define mcCanada          20
#define mcMexico          21
#define mcUSA             22         
#define mcNA              mcUSA          // North America
#define mcHungary         23
#define mcPoland          24
#define mcRussia          25
#define mcSlovacRep       26
#define mcBulgaria        27
// 28
// 29
#define mcIndia           30
// 31
// 32
// 33
// 34
// 35
// 36
// 37
// 38
// 39
#define mcAustralia       40
#define mcChina           41
#define mcHongKong        42
#define mcJapan           43
#define mcPhilippines     mcJapan
#define mcKorea           44
// 45
#define mcTaiwan          46
#define mcSingapore       47
#define mcNewZealand      48
//
//  this table is for the 33.6K V.34 ROW modems, & RocketModemII...
//
row_entry RowInfo[NUM_ROW_COUNTRIES] =
                  {{mcNA,       "North America"},
                  { mcFrance,   "France"},
                  { mcGermany,  "Germany"},
                  { mcItaly,    "Italy"},
                  { mcSweden,   "Sweden"},
                  { mcUK,       "United Kingdom"}};
//
//  this table is for the 56K V.90 ROW modems...
//
row_entry CTRRowInfo[NUM_CTR_ROW_COUNTRIES] =
                  {{mcUK,           "United Kingdom"},
                  { mcDenmark,      "Denmark"},
                  { mcFrance,       "France"},
                  { mcGermany,      "Germany"},
                  { mcIreland,      "Ireland"},
                  { mcItaly,        "Italy"},
                  { mcJapan,        "Japan"},
                  { mcNetherlands,  "Netherlands"},
                  { mcPhilippines,  "Philippines"},
                  { mcSpain,        "Spain"},
                  { mcSweden,       "Sweden"},
                  { mcSwitzerland,  "Switzerland"}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyclom-y\cd1400.h ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1996-2001.
*   All rights reserved.
*	
*   Cyclom-Y Bus/Port Driver
*	
*   This file:      cd1400.h
*	
*   Description:    This file contains the Cirrus CD1400 serial
*                   controller related contants, macros, addresses,
*                   etc.
*
*   Notes:			This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/


#ifndef CD1400
#define CD1400 1


/* max number of chars in the FIFO */

#define MAX_CHAR_FIFO   (12)

/* Firmware Revision Code */

#define REV_G		0x46


/* CD1400 registers */

/* Global Registers */

#define GFRCR  (2 * 0x40)
#define CAR    (2 * 0x68)
#define GCR    (2 * 0x4b)
#define SVRR   (2 * 0x67)
#define RICR   (2 * 0x44)
#define TICR   (2 * 0x45)
#define MICR   (2 * 0x46)
#define RIR    (2 * 0x6b)
#define TIR    (2 * 0x6a)
#define MIR    (2 * 0x69)
#define PPR    (2 * 0x7e)

/* Virtual Registers */

#define RIVR   (2 * 0x43)
#define TIVR   (2 * 0x42)
#define MIVR   (2 * 0x41)
#define TDR    (2 * 0x63)
#define RDSR   (2 * 0x62)
#define MISR   (2 * 0x4c)
#define EOSRR  (2 * 0x60)

/* Channel Registers */

#define LIVR   (2 * 0x18)
#define CCR    (2 * 0x05)
#define SRER   (2 * 0x06)
#define COR1   (2 * 0x08)
#define COR2   (2 * 0x09)
#define COR3   (2 * 0x0a)
#define COR4   (2 * 0x1e)
#define COR5   (2 * 0x1f)
#define CCSR   (2 * 0x0b)
#define RDCR   (2 * 0x0e)
#define SCHR1  (2 * 0x1a)
#define SCHR2  (2 * 0x1b)
#define SCHR3  (2 * 0x1c)
#define SCHR4  (2 * 0x1d)
#define SCRL   (2 * 0x22)
#define SCRH   (2 * 0x23)
#define LNC    (2 * 0x24)
#define MCOR1  (2 * 0x15)
#define MCOR2  (2 * 0x16)
#define RTPR   (2 * 0x21)
#define MSVR1  (2 * 0x6c)
#define MSVR2  (2 * 0x6d)
#define PVSR   (2 * 0x6f)
#define RBPR   (2 * 0x78)
#define RCOR   (2 * 0x7c)
#define TBPR   (2 * 0x72)
#define TCOR   (2 * 0x76)


/* Register Settings */

/* Channel Access Register  (CAR) */

#define CHAN0	0x00
#define CHAN1 	0x01
#define CHAN2	0x02
#define CHAN3	0x03
 
/* Channel Option Register 1 (COR1)  */

#define  COR1_NONE_PARITY     0x10
#define  COR1_ODD_PARITY      0xc0
#define  COR1_EVEN_PARITY     0x40
#define  COR1_MARK_PARITY     0xb0
#define  COR1_SPACE_PARITY    0x30
#define  COR1_PARITY_MASK     0xf0
#define  COR1_PARITY_ENABLE_MASK 0x60

#define  COR1_1_STOP    0x00
#define  COR1_1_5_STOP  0x04
#define  COR1_2_STOP    0x08
#define  COR1_STOP_MASK 0x0c

#define  COR1_5_DATA		0x00
#define  COR1_6_DATA		0x01
#define  COR1_7_DATA		0x02
#define  COR1_8_DATA		0x03
#define  COR1_DATA_MASK	0x03

/* Channel Option Register 2  (COR2) */

#define IMPL_XON	0x80
#define AUTO_TXFL	0x40
#define EMBED_TX_ENABLE 0x20
#define LOCAL_LOOP_BCK 	0x10
#define REMOTE_LOOP_BCK 0x08
#define RTS_AUT_OUTPUT	0x04
#define CTS_AUT_ENABLE	0x02

/* Channel Option Register 3  (COR3) */

#define SPL_CH_DRANGE	0x80  /* special character detect range */
#define SPL_CH_DET1	0x40  /* enable special char. detect on SCHR4-SCHR3 */
#define FL_CTRL_TRNSP	0x20  /* Flow Control Transparency */
#define SPL_CH_DET2	0x10  /* Enable spl char. detect on SCHR2-SCHR1 */
#define REC_FIFO_12CH	0x0c  /* Receive FIFO threshold= 12 chars */


/* Global Configuration Register (GCR) values */

#define GCR_CH0_IS_SERIAL	0x00

/* Prescaler Period Register (PPR) values */

#define CLOCK_20_1MS	0x27
#define CLOCK_25_1MS	0x31
#define CLOCK_60_1MS	0x75

/* Channel Command Register (CCR) values */

#define CCR_RESET_CHANNEL           0x80
#define CCR_RESET_CD1400            0x81
#define CCR_FLUSH_TXFIFO            0x82
#define CCR_CORCHG_COR1             0x42
#define CCR_CORCHG_COR2             0x44
#define CCR_CORCHG_COR1_COR2        0x46
#define CCR_CORCHG_COR3             0x48
#define CCR_CORCHG_COR3_COR1        0x4a
#define CCR_CORCHG_COR3_COR2        0x4c
#define CCR_CORCHG_COR1_COR2_COR3   0x4e
#define CCR_SENDSC_SCHR1            0x21
#define CCR_SENDSC_SCHR2            0x22
#define CCR_SENDSC_SCHR3            0x23
#define CCR_SENDSC_SCHR4            0x24
#define CCR_DIS_RX                  0x11
#define CCR_ENA_RX                  0x12
#define CCR_DIS_TX                  0x14
#define CCR_ENA_TX                  0x18
#define CCR_DIS_TX_RX               0x15
#define CCR_DIS_TX_ENA_RX           0x16
#define CCR_ENA_TX_DIS_RX           0x19
#define CCR_ENA_TX_RX               0x1a

/* Service Request Enable Register (SRER) values */

#define SRER_TXRDY         0x04
#define SRER_TXMPTY        0x02


// Read from CD1400 registers

#define CD1400_READ(ChipAddress,IsPci,Register)             \
   (READ_REGISTER_UCHAR((ChipAddress)+((Register)<<(IsPci))))

// Write to CD1400 registers

#define CD1400_WRITE(ChipAddress,IsPci,Register,Value)      \
do                                                          \
{                                                           \
   WRITE_REGISTER_UCHAR(                                    \
      (ChipAddress)+ ((Register) << (IsPci)),               \
      (UCHAR)(Value)                                        \
      );                                                    \
} while (0);

#define CD1400_DISABLE_ALL_INTERRUPTS(ChipAddress,IsPci,CdChannel)  \
do                                                                  \
{                                                                   \
    CD1400_WRITE((ChipAddress),(IsPci),CAR,(CdChannel & 0x03));     \
    CD1400_WRITE((ChipAddress),(IsPci),SRER,0x00);                  \
                                                                    \
} while (0);


#endif /* CD1400 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyclom-y\cyclom-y.h ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Enumerator Driver
*	
*   This file:      cyclom-y.h
*	
*   Description:    This module contains the common private declarations 
*                   for the cyyport enumerator.
*
*   Notes:			This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#ifndef CYCLOMY_H
#define CYCLOMY_H

#include "cyyhw.h"

#define DEVICE_OBJECT_NAME_LENGTH   128     // Copied from serial.h

#define CYY_PDO_NAME_BASE L"\\Cyy\\"


#define CYCLOMY_POOL_TAG (ULONG)'YcyC'

#undef ExAllocatePool
#define ExAllocatePool(type, size) \
   ExAllocatePoolWithTag(type, size, CYCLOMY_POOL_TAG)


#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect


//
// Debugging Output Levels
//

#define SER_DBG_STARTUP_SHUTDOWN_MASK  0x0000000F
#define SER_DBG_SS_NOISE               0x00000001
#define SER_DBG_SS_TRACE               0x00000002
#define SER_DBG_SS_INFO                0x00000004
#define SER_DBG_SS_ERROR               0x00000008

#define SER_DBG_PNP_MASK               0x000000F0
#define SER_DBG_PNP_NOISE              0x00000010
#define SER_DBG_PNP_TRACE              0x00000020
#define SER_DBG_PNP_INFO               0x00000040
#define SER_DBG_PNP_ERROR              0x00000080
#define SER_DBG_PNP_DUMP_PACKET        0x00000100

#define SER_DBG_IOCTL_TRACE            0x00000200
#define SER_DBG_POWER_TRACE            0x00000400
#define SER_DBG_CYCLADES               0x00000800

#define SER_DEFAULT_DEBUG_OUTPUT_LEVEL 0x00000000
//#define SER_DEFAULT_DEBUG_OUTPUT_LEVEL 0xFFFFFFFF


#if DBG
#define Cyclomy_KdPrint(_d_,_l_, _x_) \
            if ((_d_)->DebugLevel & (_l_)) { \
               DbgPrint ("Cyclom-y: "); \
               DbgPrint _x_; \
            }

#define Cyclomy_KdPrint_Cont(_d_,_l_, _x_) \
            if ((_d_)->DebugLevel & (_l_)) { \
               DbgPrint _x_; \
            }

#define Cyclomy_KdPrint_Def(_l_, _x_) \
            if (SER_DEFAULT_DEBUG_OUTPUT_LEVEL & (_l_)) { \
               DbgPrint ("Cyclom-y: "); \
               DbgPrint _x_; \
            }

#define TRAP() DbgBreakPoint()
#define DbgRaiseIrql(_x_,_y_) KeRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_) KeLowerIrql(_x_)
#else

#define Cyclomy_KdPrint(_d_, _l_, _x_)
#define Cyclomy_KdPrint_Cont(_d_, _l_, _x_)
#define Cyclomy_KdPrint_Def(_l_, _x_)
#define TRAP()
#define DbgRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_)

#endif

#if !defined(MIN)
#define MIN(_A_,_B_) (((_A_) < (_B_)) ? (_A_) : (_B_))
#endif


//
// These are the states a PDO or FDO transition upon
// receiving a specific PnP Irp. Refer to the PnP Device States
// diagram in DDK documentation for better understanding.
//

typedef enum _DEVICE_PNP_STATE {

    NotStarted = 0,         // Not started yet
    Started,                // Device has received the START_DEVICE IRP
    StopPending,            // Device has received the QUERY_STOP IRP
    Stopped,                // Device has received the STOP_DEVICE IRP
    RemovePending,          // Device has received the QUERY_REMOVE IRP
    SurpriseRemovePending,  // Device has received the SURPRISE_REMOVE IRP
    Deleted,                // Device has received the REMOVE_DEVICE IRP
    UnKnown                 // Unknown state

} DEVICE_PNP_STATE;


//
// A common header for the device extensions of the PDOs and FDO
//

typedef struct _COMMON_DEVICE_DATA
{
    PDEVICE_OBJECT  Self;
    // A backpointer to the device object for which this is the extension

    BOOLEAN         IsFDO;

//    BOOLEAN         Removed;   // Added in build 2072
    // Has this device been removed?  Should we fail any requests?

    // We track the state of the device with every PnP Irp
    // that affects the device through these two variables.
    
    DEVICE_PNP_STATE DevicePnPState;
    DEVICE_PNP_STATE PreviousPnPState;

    ULONG           DebugLevel;

    SYSTEM_POWER_STATE  SystemState;
    DEVICE_POWER_STATE  DeviceState;
} COMMON_DEVICE_DATA, *PCOMMON_DEVICE_DATA;

//
// The device extension for the PDOs.
// That is the serial ports of which this bus driver enumerates.
// (IE there is a PDO for the 201 serial port).
//

typedef struct _PDO_DEVICE_DATA
{
    COMMON_DEVICE_DATA;

    PDEVICE_OBJECT  ParentFdo;
    // A back pointer to the bus

    UNICODE_STRING  HardwareIDs;
    // Either in the form of bus\device
    // or *PNPXXXX - meaning root enumerated

    UNICODE_STRING  CompIDs;
    // compatible ids to the hardware id

    UNICODE_STRING  DeviceIDs;
    // Format: bus\device

    UNICODE_STRING  InstanceIDs;

    //
    // Text describing device
    //

    UNICODE_STRING DevDesc;

    BOOLEAN     Attached;

    //    BOOLEAN     Removed;  -> Removed in build 2072
    // When a device (PDO) is found on a bus and presented as a device relation
    // to the PlugPlay system, Attached is set to TRUE, and Removed to FALSE.
    // When the bus driver determines that this PDO is no longer valid, because
    // the device has gone away, it informs the PlugPlay system of the new
    // device relastions, but it does not delete the device object at that time.
    // The PDO is deleted only when the PlugPlay system has sent a remove IRP,
    // and there is no longer a device on the bus.
    //
    // If the PlugPlay system sends a remove IRP then the Removed field is set
    // to true, and all client (non PlugPlay system) accesses are failed.
    // If the device is removed from the bus Attached is set to FALSE.
    //
    // During a query relations Irp Minor call, only the PDOs that are
    // attached to the bus (and all that are attached to the bus) are returned
    // (even if they have been removed).
    //
    // During a remove device Irp Minor call, if and only if, attached is set
    // to FALSE, the PDO is deleted.
    //


   // The child devices will have to know which PortIndex they are.
   ULONG PortIndex;

} PDO_DEVICE_DATA, *PPDO_DEVICE_DATA;


//
// The device extension of the bus itself.  From whence the PDO's are born.
//

typedef struct _FDO_DEVICE_DATA
{
    COMMON_DEVICE_DATA;

    PDRIVER_OBJECT   DriverObject;

    UCHAR            PdoIndex;
    // A number to keep track of the Pdo we're allocating.
    // Increment every time we create a new PDO.  It's ok that it wraps.

    ULONG            NumPDOs;
    // The PDOs currently enumerated.

    PDEVICE_OBJECT   AttachedPDO[CYY_MAX_PORTS];

    PPDO_DEVICE_DATA PdoData[CYY_MAX_PORTS];

    PDEVICE_OBJECT  UnderlyingPDO;
    PDEVICE_OBJECT  TopOfStack;
    // the underlying bus PDO and the actual device object to which our
    // FDO is attached

    ULONG           OutstandingIO;
    // the number of IRPs sent from the bus to the underlying device object

    KEVENT          RemoveEvent;
    // On remove device plugplay request we must wait until all outstanding
    // requests have been completed before we can actually delete the device
    // object.

    UNICODE_STRING DevClassAssocName;
    // The name returned from IoRegisterDeviceClass Association,
    // which is used as a handle for IoSetDev... and friends.

    SYSTEM_POWER_STATE  SystemWake;
    DEVICE_POWER_STATE  DeviceWake;

    //
    // We keep the following values around so that we can connect
    // to the interrupt and report resources after the configuration
    // record is gone.
    //

    //
    // Translated vector
    //
    ULONG Vector;

    //
    // Translated Irql
    //
    KIRQL Irql;

    //
    // Untranslated vector
    //
    ULONG OriginalVector;

    //
    // Untranslated irql
    //
    ULONG OriginalIrql;

    //
    // Bus number
    //
    ULONG BusNumber;

    //
    // Interface type
    //
    INTERFACE_TYPE InterfaceType;
       
    //
    // Cyclom-Y hardware
    //
    PHYSICAL_ADDRESS PhysicalRuntime;
    PHYSICAL_ADDRESS TranslatedRuntime;
    ULONG            RuntimeLength;
    
    PHYSICAL_ADDRESS PhysicalBoardMemory;
    PHYSICAL_ADDRESS TranslatedBoardMemory;
    ULONG            BoardMemoryLength;
 
    PUCHAR           Runtime;
    PUCHAR           BoardMemory;

    ULONG            IsPci;

    PUCHAR           Cd1400Base[CYY_MAX_CHIPS];

    // We are passing the resources privatly to our children so that Device Manager will not 
    // complain about resource conflict between children.

    PIO_RESOURCE_REQUIREMENTS_LIST  PChildRequiredList;
    PCM_RESOURCE_LIST  PChildResourceList;
    ULONG              PChildResourceListSize;

    PCM_RESOURCE_LIST  PChildResourceListTr;
    ULONG              PChildResourceListSizeTr;

    ULONG            UINumber;

} FDO_DEVICE_DATA, *PFDO_DEVICE_DATA;

//
// Macros
//

#define INITIALIZE_PNP_STATE(_Data_)    \
        (_Data_)->DevicePnPState =  NotStarted;\
        (_Data_)->PreviousPnPState = NotStarted;

#define SET_NEW_PNP_STATE(_Data_, _state_) \
        (_Data_)->PreviousPnPState =  (_Data_)->DevicePnPState;\
        (_Data_)->DevicePnPState = (_state_);

#define RESTORE_PREVIOUS_PNP_STATE(_Data_)   \
        (_Data_)->DevicePnPState =   (_Data_)->PreviousPnPState;\

//
// Free the buffer associated with a Unicode string
// and re-init it to NULL
//

#define CyclomyFreeUnicodeString(PStr) \
{ \
   if ((PStr)->Buffer != NULL) { \
      ExFreePool((PStr)->Buffer); \
   } \
   RtlInitUnicodeString((PStr), NULL); \
}

//
// Prototypes
//

NTSTATUS
Cyclomy_CreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Cyclomy_IoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Cyclomy_InternIoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
Cyclomy_DriverUnload (
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
Cyclomy_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Cyclomy_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Cyclomy_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusDeviceObject
    );

NTSTATUS
Cyclomy_PnPRemove (
    PDEVICE_OBJECT      Device,
    PPDO_DEVICE_DATA    PdoData
    );

NTSTATUS
Cyclomy_FDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PFDO_DEVICE_DATA     DeviceData
    );

NTSTATUS
Cyclomy_PDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PPDO_DEVICE_DATA     DeviceData
    );

NTSTATUS
Cyclomy_IncIoCount (
    PFDO_DEVICE_DATA   Data
    );

VOID
Cyclomy_DecIoCount (
    PFDO_DEVICE_DATA   Data
    );

NTSTATUS
Cyclomy_DispatchPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Cyclomy_ReenumerateDevices(
    IN PIRP                 Irp,
    IN PFDO_DEVICE_DATA     DeviceData
    );

NTSTATUS
Cyclomy_InitMultiString(PFDO_DEVICE_DATA FdoData, PUNICODE_STRING MultiString,
                        ...);
void
Cyclomy_PDO_EnumMarkMissing(
    PFDO_DEVICE_DATA FdoData,
    PPDO_DEVICE_DATA PdoData);

NTSTATUS
Cyclomy_GetRegistryKeyValue (
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength,
    OUT PULONG ActualLength);

void
Cyclomy_InitPDO (
    ULONG               index,
    PDEVICE_OBJECT      pdoData,
    PFDO_DEVICE_DATA    fdoData
    );

NTSTATUS
CyclomySyncCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
                      IN PKEVENT CyclomySyncEvent);

NTSTATUS
Cyclomy_GetResourceInfo(IN PDEVICE_OBJECT PDevObj,
                    IN PCM_RESOURCE_LIST PResList,
                    IN PCM_RESOURCE_LIST PTrResList);

VOID
Cyclomy_ReleaseResources(IN PFDO_DEVICE_DATA PDevExt);

NTSTATUS
Cyclomy_GotoPowerState(IN PDEVICE_OBJECT PDevObj,
                   IN PFDO_DEVICE_DATA PDevExt,
                   IN DEVICE_POWER_STATE DevPowerState);
NTSTATUS
Cyclomy_SystemPowerCompletion(IN PDEVICE_OBJECT PDevObj, UCHAR MinorFunction,
                          IN POWER_STATE PowerState, IN PVOID Context,
                          PIO_STATUS_BLOCK IoStatus);

NTSTATUS
Cyclomy_ItemCallBack(
                  IN PVOID Context,
                  IN PUNICODE_STRING PathName,
                  IN INTERFACE_TYPE BusType,
                  IN ULONG BusNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
                  IN CONFIGURATION_TYPE ControllerType,
                  IN ULONG ControllerNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
                  IN CONFIGURATION_TYPE PeripheralType,
                  IN ULONG PeripheralNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
                  );

NTSTATUS
Cyclomy_BuildRequirementsList(
                          OUT PIO_RESOURCE_REQUIREMENTS_LIST *PChildRequiredList_Pointer,
                          IN PCM_RESOURCE_LIST PResourceList, IN ULONG NumberOfResources
                          );

NTSTATUS
Cyclomy_BuildResourceList(
                      OUT PCM_RESOURCE_LIST *POutList_Pointer,
                      OUT ULONG *ListSize_Pointer,
                      IN PCM_RESOURCE_LIST PInList,
                      IN ULONG NumberOfResources
                      );

ULONG
Cyclomy_DoesBoardExist(
                   IN PFDO_DEVICE_DATA Extension
                   );

ULONG
Cyclomy_DoesBoardExist(
                   IN PFDO_DEVICE_DATA Extension
                   );

VOID
Cyclomy_EnableInterruptInPLX(
      IN PFDO_DEVICE_DATA PDevExt
      );

VOID
CyyLogError(
              IN PDRIVER_OBJECT DriverObject,
              IN PDEVICE_OBJECT DeviceObject OPTIONAL,
              IN PHYSICAL_ADDRESS P1,
              IN PHYSICAL_ADDRESS P2,
              IN ULONG SequenceNumber,
              IN UCHAR MajorFunctionCode,
              IN UCHAR RetryCount,
              IN ULONG UniqueErrorValue,
              IN NTSTATUS FinalStatus,
              IN NTSTATUS SpecificIOStatus,
              IN ULONG LengthOfInsert1,
              IN PWCHAR Insert1,
              IN ULONG LengthOfInsert2,
              IN PWCHAR Insert2
              );

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
);

#endif // endef CYCLOMY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyclom-y\cyclom-y.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Enumerator Driver
*	
*   This file:      cyclom-y.c
*	
*   Description:    This module contains contains the entry points 
*                   for a standard bus PNP / WDM driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#include "pch.h"

//
// Declare some entry functions as pageable, and make DriverEntry
// discardable
//

NTSTATUS DriverEntry(PDRIVER_OBJECT, PUNICODE_STRING);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, Cyclomy_DriverUnload)
#endif

NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING UniRegistryPath
    )
/*++
Routine Description:

    Initialize the entry points of the driver.

--*/
{
    ULONG i;
    PRTL_QUERY_REGISTRY_TABLE QueryTable = NULL;
    ULONG breakOnEntryDefault = FALSE;
    ULONG shouldBreakOnEntry = FALSE;

    UNREFERENCED_PARAMETER (UniRegistryPath);

    Cyclomy_KdPrint_Def (SER_DBG_SS_TRACE, ("Driver Entry\n"));
    Cyclomy_KdPrint_Def (SER_DBG_SS_TRACE, ("RegPath: %x\n", UniRegistryPath));

    //
    // Get the BreakOnEntry from the registry
    //

    if (NULL == (QueryTable = ExAllocatePool(
                         PagedPool,
                         sizeof(RTL_QUERY_REGISTRY_TABLE)*2
                          ))) {
        Cyclomy_KdPrint_Def (SER_DBG_PNP_ERROR,
              ("Failed to allocate memory to query registry\n"));
    } else {
        RtlZeroMemory(
                 QueryTable,
                 sizeof(RTL_QUERY_REGISTRY_TABLE)*2
                  );

        QueryTable[0].QueryRoutine = NULL;
        QueryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        QueryTable[0].EntryContext = &shouldBreakOnEntry;
        QueryTable[0].Name      = L"BreakOnEntry";
        QueryTable[0].DefaultType   = REG_DWORD;
        QueryTable[0].DefaultData   = &breakOnEntryDefault;
        QueryTable[0].DefaultLength= sizeof(ULONG);

        // BUGBUG: The rest of the table isn't filled in!

        if (!NT_SUCCESS(RtlQueryRegistryValues(
             RTL_REGISTRY_SERVICES,
             L"cyclom-y",
             QueryTable,
             NULL,
             NULL))) {
               Cyclomy_KdPrint_Def (SER_DBG_PNP_ERROR,
                   ("Failed to get BreakOnEntry level from registry.  Using default\n"));
               shouldBreakOnEntry = breakOnEntryDefault;
        }

        ExFreePool( QueryTable );
    }


    if (shouldBreakOnEntry) {
        DbgBreakPoint();
    }


    DriverObject->MajorFunction [IRP_MJ_CREATE] =
    DriverObject->MajorFunction [IRP_MJ_CLOSE]  = Cyclomy_CreateClose;
    DriverObject->MajorFunction [IRP_MJ_PNP]    = Cyclomy_PnP;
    DriverObject->MajorFunction [IRP_MJ_POWER]  = Cyclomy_Power;
    DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = Cyclomy_IoCtl;
    DriverObject->MajorFunction [IRP_MJ_SYSTEM_CONTROL] = Cyclomy_DispatchPassThrough;
    DriverObject->DriverUnload = Cyclomy_DriverUnload;
    DriverObject->DriverExtension->AddDevice = Cyclomy_AddDevice;

    return STATUS_SUCCESS;
}


NTSTATUS
CyclomySyncCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
                      IN PKEVENT CyclomySyncEvent)
{
   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);


   KeSetEvent(CyclomySyncEvent, IO_NO_INCREMENT, FALSE);
   return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
Cyclomy_CreateClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++
Routine Description:
    Some outside source is trying to create a file against us.

    If this is for the FDO (the bus itself) then the caller is trying to
    open the propriatary conection to tell us which serial port to enumerate.

    If this is for the PDO (an object on the bus) then this is a client that
    wishes to use the serial port.
--*/
{
   PIO_STACK_LOCATION irpStack;
   NTSTATUS status;
   PFDO_DEVICE_DATA fdoData;
   KEVENT completionEvent;
   PDEVICE_OBJECT pNextDevice;


   UNREFERENCED_PARAMETER(DeviceObject);

   status = STATUS_INVALID_DEVICE_REQUEST;
   Irp->IoStatus.Information = 0;
    
   fdoData = DeviceObject->DeviceExtension;
   if (fdoData->IsFDO) {

      if (fdoData->DevicePnPState == Deleted){         
         status = STATUS_DELETE_PENDING;
      } else {

         irpStack = IoGetCurrentIrpStackLocation(Irp);

         switch (irpStack->MajorFunction) {

         case IRP_MJ_CREATE:

            Cyclomy_KdPrint_Def(SER_DBG_SS_TRACE, ("Create"));
            if ((fdoData->DevicePnPState == RemovePending) || 
               (fdoData->DevicePnPState == SurpriseRemovePending)) {
               status = STATUS_DELETE_PENDING;
            } else {
               status = STATUS_SUCCESS;
            }
            break;

         case IRP_MJ_CLOSE:

            Cyclomy_KdPrint_Def (SER_DBG_SS_TRACE, ("Close \n"));
            status = STATUS_SUCCESS;
            break;
         }
      }
   }

   Irp->IoStatus.Status = status;
   IoCompleteRequest (Irp, IO_NO_INCREMENT);
   return status;
}

NTSTATUS
Cyclomy_IoCtl (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description:

--*/
{
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                status;
    PCOMMON_DEVICE_DATA     commonData;
    PFDO_DEVICE_DATA        fdoData;

    Cyclomy_KdPrint_Def (SER_DBG_IOCTL_TRACE, ("Cyclomy_IoCtl\n"));

    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IRP_MJ_DEVICE_CONTROL == irpStack->MajorFunction);

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;
    fdoData = (PFDO_DEVICE_DATA) DeviceObject->DeviceExtension;

    //
    // We only take Device Control requests for the FDO.
    // That is the bus itself.

    if (!commonData->IsFDO) {
        //
        // These commands are only allowed to go to the FDO.
        //   
        status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    status = Cyclomy_IncIoCount (fdoData);

    if (!NT_SUCCESS (status)) {
        //
        // This bus has received the PlugPlay remove IRP.  It will no longer
        // respond to external requests.
        //
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    // Actually, we don't handle any Ioctl.
    status = STATUS_INVALID_DEVICE_REQUEST;

    Cyclomy_DecIoCount (fdoData);

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return status;
}

VOID
Cyclomy_DriverUnload (
    IN PDRIVER_OBJECT Driver
    )
/*++
Routine Description:
    Clean up everything we did in driver entry.

--*/
{
    UNREFERENCED_PARAMETER (Driver);
    PAGED_CODE();

    //
    // All the device objects should be gone.
    //

    ASSERT (NULL == Driver->DeviceObject);

    //
    // Here we free any resources allocated in DriverEntry
    //

    return;
}

NTSTATUS
Cyclomy_IncIoCount (
    PFDO_DEVICE_DATA Data
    )
{
    InterlockedIncrement (&Data->OutstandingIO);
    if (Data->DevicePnPState == Deleted) {

        if (0 == InterlockedDecrement (&Data->OutstandingIO)) {
            KeSetEvent (&Data->RemoveEvent, 0, FALSE);
        }
        return STATUS_DELETE_PENDING;
    }
    return STATUS_SUCCESS;
}

VOID
Cyclomy_DecIoCount (
    PFDO_DEVICE_DATA Data
    )
{
    if (0 == InterlockedDecrement (&Data->OutstandingIO)) {
        KeSetEvent (&Data->RemoveEvent, 0, FALSE);
    }
}

NTSTATUS
Cyclomy_DispatchPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
Routine Description:

    Passes a request on to the lower driver.

--*/
{
    PIO_STACK_LOCATION IrpStack = 
            IoGetCurrentIrpStackLocation( Irp );

#if 1
        Cyclomy_KdPrint_Def (SER_DBG_SS_TRACE, ( 
            "[Cyclomy_DispatchPassThrough] "
            "IRP: %8x; "
            "MajorFunction: %d\n",
            Irp, 
            IrpStack->MajorFunction ));
#endif

    //
    // Pass the IRP to the target
    //
    IoSkipCurrentIrpStackLocation (Irp);
    
    if (((PPDO_DEVICE_DATA) DeviceObject->DeviceExtension)->IsFDO) {
        return IoCallDriver( 
            ((PFDO_DEVICE_DATA) DeviceObject->DeviceExtension)->TopOfStack,
            Irp );
    } else {
        return IoCallDriver( 
            ((PFDO_DEVICE_DATA) ((PPDO_DEVICE_DATA) DeviceObject->
                DeviceExtension)->ParentFdo->DeviceExtension)->TopOfStack,
                Irp );
    }
}           

void
Cyclomy_InitPDO (
    ULONG               Index,
    PDEVICE_OBJECT      Pdo,
    PFDO_DEVICE_DATA    FdoData
    )
/*
Description:
    Common code to initialize a newly created cyclom-y pdo.
    Called either when the control panel exposes a device or when Cyclom-Y senses
    a new device was attached.

Parameters:
    Pdo - The pdo
    FdoData - The fdo's device extension
    //Exposed - Was this pdo was found by serenum (FALSE) or was it was EXPOSEd by 
    //    a control panel applet (TRUE)?        -> Removed in build 2072
*/
{

    ULONG FdoFlags = FdoData->Self->Flags;
    PPDO_DEVICE_DATA pdoData = Pdo->DeviceExtension;

    HANDLE keyHandle;
    NTSTATUS status;
    
    //
    // Check the IO style
    //
    if (FdoFlags & DO_BUFFERED_IO) {
        Pdo->Flags |= DO_BUFFERED_IO;
    } else if (FdoFlags & DO_DIRECT_IO) {
        Pdo->Flags |= DO_DIRECT_IO;
    }
    
    //
    // Increment the pdo's stacksize so that it can pass irps through
    //
    Pdo->StackSize += FdoData->Self->StackSize;
    
    //
    // Initialize the rest of the device extension
    //
    pdoData->PortIndex = Index;
    pdoData->IsFDO = FALSE;
    pdoData->Self = Pdo;
    pdoData->ParentFdo = FdoData->Self;
    pdoData->Attached = TRUE; // attached to the bus

    INITIALIZE_PNP_STATE(pdoData);

    pdoData->DebugLevel = FdoData->DebugLevel;  // Copy the debug level

    pdoData->DeviceState = PowerDeviceD0;
    pdoData->SystemState = PowerSystemWorking;

    //
    // Add the pdo to cyclom-y's list
    //

    ASSERT(FdoData->AttachedPDO[Index] == NULL);
    ASSERT(FdoData->PdoData[Index] == NULL);
//  ASSERT(FdoData->NumPDOs == 0);  rem because NumPDOs can be > 0 in cyclom-y

    FdoData->AttachedPDO[Index] = Pdo;
    FdoData->PdoData[Index] = pdoData;
    FdoData->NumPDOs++;

    Pdo->Flags &= ~DO_DEVICE_INITIALIZING;  // Moved to end in DDK final version
    Pdo->Flags |= DO_POWER_PAGABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyclom-y\cyyhw.h ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Bus/Port Driver
*	
*   This file:      cyyhw.h
*	
*   Description:    This module contains the common hardware declarations 
*                   for the parent driver (cyclom-y) and child driver
*                   (cyyport).
*
*   Notes:			This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/

#ifndef CYYHW_H
#define CYYHW_H


#define MAX_DEVICE_ID_LEN     200	// This definition was copied from NTDDK\inc\cfgmgr32.h
									// Always check if this value was changed. 
									// This is the maximum length for the Hardware ID.

#define CYYPORT_PNP_ID_WSTR         L"Cyclom-Y\\Port"
#define CYYPORT_PNP_ID_STR          "Cyclom-Y\\Port"
#define CYYPORT_DEV_ID_STR          "Cyclom-Y\\Port"

#define CYY_NUMBER_OF_RESOURCES     3     // Memory, PLX Memory, Interrupt


// Cyclom-Y hardware
#define CYY_RUNTIME_LENGTH          0x00000080
#define CYY_MAX_CHIPS 	            8
#define CYY_CHANNELS_PER_CHIP       4
#define CYY_MAX_PORTS	            (CYY_CHANNELS_PER_CHIP*CYY_MAX_CHIPS)

// Custom register offsets
#define CYY_CLEAR_INTR	            0x1800	//Isa; for PCI, multiply by 2
#define CYY_RESET_16	               0x1400	//Isa; for PCI, multiply by 2
#define CYY_PCI_TYPE	               0x3400	//PCI (no need to multiply by 2)

// Values in CYY_PCI_TYPE register
#define CYY_PLX9050		(0x0b)
#define CYY_PLX9060		(0x0c)
#define CYY_PLX9080		(0x0d)

// Runtime registers (or Local Configuration registers)
#define PLX9050_INT_OFFSET	(0x4c)
#define PLX9060_INT_OFFSET	(0x68)
#define PLX9050_INT_ENABLE (0x00000043UL)
#define PLX9060_INT_ENABLE (0x00000900UL)


// Write to Custom registers

#define CYY_RESET_BOARD(BaseBoardAddress,IsPci)             \
do                                                          \
{                                                           \
   WRITE_REGISTER_UCHAR(                                    \
      (BaseBoardAddress)+(CYY_RESET_16 << IsPci),           \
      0x00                                                  \
      );                                                    \
} while (0);


#define CYY_CLEAR_INTERRUPT(BaseBoardAddress,IsPci)         \
do                                                          \
{                                                           \
   WRITE_REGISTER_UCHAR(                                    \
      (BaseBoardAddress)+(CYY_CLEAR_INTR << IsPci),         \
      0x00                                                  \
      );                                                    \
} while (0);

#define CYY_READ_PCI_TYPE(BaseBoardAddress)                 \
   (READ_REGISTER_UCHAR((BaseBoardAddress)+CYY_PCI_TYPE))

#define PLX9050_READ_INTERRUPT_CONTROL(BaseBoardAddress)       \
   (READ_REGISTER_ULONG((PULONG)((BaseBoardAddress)+PLX9050_INT_OFFSET)))

#define PLX9050_WRITE_INTERRUPT_CONTROL(BaseBoardAddress,Value)   \
do {                                                              \
   WRITE_REGISTER_ULONG(                                          \
      (PULONG)((BaseBoardAddress)+PLX9050_INT_OFFSET),            \
      Value                                                       \
      );                                                          \
} while (0);

#define PLX9060_READ_INTERRUPT_CONTROL(BaseBoardAddress)          \
   (READ_REGISTER_ULONG((PULONG)((BaseBoardAddress)+PLX9060_INT_OFFSET)))

#define PLX9060_WRITE_INTERRUPT_CONTROL(BaseBoardAddress,Value)   \
do {                                                              \
   WRITE_REGISTER_ULONG(                                          \
      (PULONG)((BaseBoardAddress)+PLX9060_INT_OFFSET),            \
      Value                                                       \
      );                                                          \
} while (0);

#endif // ndef CYCOMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyclom-y\cyyguid.h ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Enumerator Driver
*	
*   This file:      cyyguid.h
*	
*   Description:    Defines GUIDs for function device classes and device 
*                   events used in Plug & Play.
*
*   Notes:			This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#ifdef DEFINE_GUID   // don't break compiles of drivers that 
                     // include this header but don't want the
                     // GUIDs

// {27111c90-e3ee-11d2-90f6-0000b4341b13} 
DEFINE_GUID( GUID_BUS_TYPE_CYCLOMY, 
             0x27111c90L, 0xe3ee, 0x11d2, 0x90, 0xf6, 0x00, 0x00, 0xb4, 0x34, 0x1b, 0x13 );

// {6EF3E5F9-C75D-471c-BC7A-3E349058F7C8}
DEFINE_GUID( GUID_CYCLOMY_BUS_ENUMERATOR, 
             0x6ef3e5f9, 0xc75d, 0x471c, 0xbc, 0x7a, 0x3e, 0x34, 0x90, 0x58, 0xf7, 0xc8);

#endif   // DEFINE_GUID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyclom-y\pch.h ===
#include <ntddk.h>
#include <devioctl.h>
#include <initguid.h>
#include <wdmguid.h>
#include <ntddser.h>
#include <stdarg.h>
#include <stdio.h>
#include "cyyguid.h"
#include "log.h"
#include "cyclom-y.h"
#include "cd1400.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyclom-y\enum.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Enumerator Driver
*	
*   This file:      enum.c
*	
*   Description:    This module contains the enumeration code needed 
*                   to figure out whether or not a device is attached 
*                   to the serial port.  If there is one, it will 
*                   obtain the PNP COM ID (if the device is PNP) and
*                   parse out the relevant fields.
*
*   Notes:			This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#include "pch.h"

#define MAX_DEVNODE_NAME        256 // Total size of Device ID


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESENM, Cyclomy_ReenumerateDevices)

//#pragma alloc_text (PAGE, Cyclomy_GetRegistryKeyValue)
#endif

#if !defined(__isascii)
#define __isascii(_c)   ( (unsigned)(_c) < 0x80 )
#endif // !defined(__isascii)

NTSTATUS
Cyclomy_ReenumerateDevices(IN PIRP Irp, IN PFDO_DEVICE_DATA FdoData)
/*++

Routine Description:

    This enumerates the cyclom-y bus which is represented by Fdo (a pointer
    to the device object representing the cyclom-y bus). It creates new PDOs
    for any new devices which have been discovered since the last enumeration

Arguments:

    FdoData - Pointer to the fdo's device extension
              for the serial bus which needs to be enumerated
    Irp - Pointer to the Irp which was sent to reenumerate.

Return value:

    NTSTATUS

--*/
{
   PIRP NewIrp;
   NTSTATUS status = STATUS_SUCCESS;
   KEVENT event;
   KTIMER timer;

   IO_STATUS_BLOCK IoStatusBlock;
   UNICODE_STRING pdoUniName;
   UNICODE_STRING instanceStr;
   WCHAR instanceNumberBuffer[20];
   static ULONG currentInstance = 0;
//   PDEVICE_OBJECT pdo = FdoData->AttachedPDO;
   PDEVICE_OBJECT pdo;
   PPDO_DEVICE_DATA pdoData;

   UNICODE_STRING HardwareIDs;
   UNICODE_STRING CompIDs;
   UNICODE_STRING DeviceIDs;
   UNICODE_STRING DevDesc;
   UNICODE_STRING InstanceIDs;

   ULONG i;

   WCHAR pdoName[] = CYY_PDO_NAME_BASE;

   ULONG FdoFlags = FdoData->Self->Flags;

   ULONG numPorts;

   UNREFERENCED_PARAMETER (Irp);

   PAGED_CODE();

   // Cyclom-Y port enumeration

   numPorts = 0;
   for (i=0; i < CYY_MAX_CHIPS; i++) {
      if (FdoData->Cd1400Base[i]){
         numPorts += 4;
      }
   }


//************************************************************************
// HARDCODE NUMBER OF PORTS TO 1

// numPorts = 1;

//************************************************************************


   Cyclomy_KdPrint(FdoData,SER_DBG_CYCLADES,("numPorts detected = %d\n",numPorts));

   if (numPorts < FdoData->NumPDOs) {
      for (i=numPorts; i < CYY_MAX_PORTS; i++) {
         pdo = FdoData->AttachedPDO[i];
         if (pdo != NULL) {
            // Something was there. The device must have been unplugged.
            // Remove the PDO.
            Cyclomy_PDO_EnumMarkMissing(FdoData, pdo->DeviceExtension);
         }
      }
      goto ExitReenumerate;
   }

   if (numPorts == FdoData->NumPDOs) {
      // All ports already enumerated.
      Cyclomy_KdPrint(FdoData,SER_DBG_CYCLADES,("All ports already enumerated\n",numPorts));
      goto ExitReenumerate;
   }


   // New ports that need to be enumerated.

   RtlZeroMemory(&pdoUniName,sizeof(UNICODE_STRING));
   pdoUniName.MaximumLength = DEVICE_OBJECT_NAME_LENGTH * sizeof(WCHAR);
   pdoUniName.Buffer = ExAllocatePool(PagedPool,pdoUniName.MaximumLength
                                    + sizeof(WCHAR));
   if (pdoUniName.Buffer == NULL) {
      Cyclomy_KdPrint(FdoData,SER_DBG_CYCLADES,("Couldn't allocate memory for device name\n"));
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto ExitReenumerate; 
   }


   for (i=FdoData->NumPDOs; numPorts && (i< CYY_MAX_PORTS); i++) {
      
      UCHAR          RawString[MAX_DEVICE_ID_LEN];
      ANSI_STRING    AnsiString;


      RtlZeroMemory(pdoUniName.Buffer,pdoUniName.MaximumLength);
      pdoUniName.Length = 0;
      RtlAppendUnicodeToString(&pdoUniName,pdoName);
      RtlInitUnicodeString(&instanceStr, NULL);
      instanceStr.MaximumLength = sizeof(instanceNumberBuffer);
      instanceStr.Buffer = instanceNumberBuffer;
      RtlIntegerToUnicodeString(currentInstance++, 10, &instanceStr);
      RtlAppendUnicodeStringToString(&pdoUniName, &instanceStr);


      //
      // Allocate a pdo
      //
      status = IoCreateDevice(FdoData->Self->DriverObject,
                              sizeof(PDO_DEVICE_DATA), &pdoUniName,
                              FILE_DEVICE_UNKNOWN,
                              FILE_AUTOGENERATED_DEVICE_NAME, FALSE, &pdo);

      if (!NT_SUCCESS(status)) {
         Cyclomy_KdPrint(FdoData, SER_DBG_SS_ERROR, ("Create device failed\n"));
         ExFreePool(pdoUniName.Buffer);
         goto ExitReenumerate; 
      }

      Cyclomy_KdPrint(FdoData, SER_DBG_SS_TRACE,
                      ("Created PDO on top of filter: %x\n",pdo));

      pdoData = pdo->DeviceExtension;
         

      RtlInitUnicodeString(&pdoData->HardwareIDs, NULL);
      RtlInitUnicodeString(&pdoData->CompIDs, NULL);
      RtlInitUnicodeString(&pdoData->DeviceIDs, NULL);
      RtlInitUnicodeString(&pdoData->DevDesc, NULL);
      RtlInitUnicodeString(&pdoData->InstanceIDs,NULL);


      // Hardware ID
      sprintf((PCHAR)RawString,"%s%u",CYYPORT_PNP_ID_STR,i+1); // Cyclom-Y\\Port1, etc
      Cyclomy_InitMultiString(FdoData, &pdoData->HardwareIDs, RawString, NULL);
      Cyclomy_KdPrint(FdoData,SER_DBG_CYCLADES,("Hardware Id %ws\n",pdoData->HardwareIDs.Buffer));

      // That's how ..\parclass\pnppdo.c does. (Fanny)
      // Instance ID
      sprintf((PCHAR)RawString,"%02u",i+1);
      RtlInitAnsiString(&AnsiString,(PCHAR)RawString);
      RtlAnsiStringToUnicodeString(&pdoData->InstanceIDs,&AnsiString,TRUE);
      Cyclomy_KdPrint(FdoData,SER_DBG_CYCLADES,("Instance Id %s\n",AnsiString.Buffer));

      // Device ID
      sprintf((PCHAR)RawString,CYYPORT_DEV_ID_STR); 
      RtlInitAnsiString(&AnsiString,(PCHAR)RawString);
      RtlAnsiStringToUnicodeString(&pdoData->DeviceIDs,&AnsiString,TRUE);
      Cyclomy_KdPrint(FdoData,SER_DBG_CYCLADES,("Device Id %s\n",AnsiString.Buffer));

      // Device Description
      sprintf((PCHAR)RawString,"Cyclom-Y Port %2u",i+1);
      RtlInitAnsiString(&AnsiString,(PUCHAR)RawString);
      RtlAnsiStringToUnicodeString(&pdoData->DevDesc,&AnsiString,TRUE);
      Cyclomy_KdPrint(FdoData,SER_DBG_CYCLADES,("Device Description %s\n",AnsiString.Buffer));

      Cyclomy_InitPDO(i, pdo, FdoData);
      
      numPorts--;
   
   }

   ExFreePool(pdoUniName.Buffer);


ExitReenumerate:;

   return status;
}

void
Cyclomy_PDO_EnumMarkMissing(PFDO_DEVICE_DATA FdoData, PPDO_DEVICE_DATA PdoData)
/*++

Routine Description:
    Removes the attached pdo from the fdo's list of children.

    NOTE: THIS FUNCTION CAN ONLY BE CALLED DURING AN ENUMERATION. If called
          outside of enumeration, Cyclom-y might delete it's PDO before PnP has
          been told the PDO is gone.

Arguments:
    FdoData - Pointer to the fdo's device extension
    PdoData - Pointer to the pdo's device extension

Return value:
    none

--*/
{
    ULONG IndexPDO = PdoData->PortIndex;
    Cyclomy_KdPrint (FdoData, SER_DBG_SS_TRACE, ("Removing Pdo %x\n",
                                                 PdoData->Self));
    ASSERT(PdoData->Attached);
    PdoData->Attached = FALSE;
    FdoData->AttachedPDO[IndexPDO] = NULL;
    FdoData->PdoData[IndexPDO] = NULL;
    FdoData->NumPDOs--;
}

NTSTATUS
Cyclomy_GetRegistryKeyValue(IN HANDLE Handle, IN PWCHAR KeyNameString,
                            IN ULONG KeyNameStringLength, IN PVOID Data,
                            IN ULONG DataLength, OUT PULONG ActualLength)
/*++

Routine Description:

    Reads a registry key value from an already opened registry key.

Arguments:

    Handle              Handle to the opened registry key

    KeyNameString       ANSI string to the desired key

    KeyNameStringLength Length of the KeyNameString

    Data                Buffer to place the key value in

    DataLength          Length of the data buffer

Return Value:

    STATUS_SUCCESS if all works, otherwise status of system call that
    went wrong.

--*/
{
    UNICODE_STRING              keyName;
    ULONG                       length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;

    NTSTATUS                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

    RtlInitUnicodeString (&keyName, KeyNameString);

    length = sizeof(KEY_VALUE_FULL_INFORMATION) + KeyNameStringLength
      + DataLength;
    fullInfo = ExAllocatePool(PagedPool, length);

    if (ActualLength != NULL) {
       *ActualLength = 0;
    }

    if (fullInfo) {
        ntStatus = ZwQueryValueKey (Handle,
                                  &keyName,
                                  KeyValueFullInformation,
                                  fullInfo,
                                  length,
                                  &length);

        if (NT_SUCCESS(ntStatus)) {
            //
            // If there is enough room in the data buffer, copy the output
            //

            if (DataLength >= fullInfo->DataLength) {
                RtlCopyMemory(Data, ((PUCHAR)fullInfo) + fullInfo->DataOffset,
                              fullInfo->DataLength);
                if (ActualLength != NULL) {
                   *ActualLength = fullInfo->DataLength;
                }
            }
        }

        ExFreePool(fullInfo);
    }

    if (!NT_SUCCESS(ntStatus) && !NT_ERROR(ntStatus)) {
       if (ntStatus == STATUS_BUFFER_OVERFLOW) {
          ntStatus = STATUS_BUFFER_TOO_SMALL;
       } else {
          ntStatus = STATUS_UNSUCCESSFUL;
       }
    }
    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyclom-y\log.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Enumerator Driver
*	
*   This file:      log.c
*	
*   Description:    This module contains contains the entry points 
*                   for a standard bus PNP / WDM driver.
*
*   Notes:			This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/


#include "pch.h"

typedef enum _CYY_MEM_COMPARES {
    AddressesAreEqual,
    AddressesOverlap,
    AddressesAreDisjoint
    } CYY_MEM_COMPARES,*PCYY_MEM_COMPARES;

static const PHYSICAL_ADDRESS CyyPhysicalZero = {0};

CYY_MEM_COMPARES
CyyMemCompare(
                IN PHYSICAL_ADDRESS A,
                IN ULONG SpanOfA,
                IN PHYSICAL_ADDRESS B,
                IN ULONG SpanOfB
                )

/*++

Routine Description:

    Compare two phsical address.

Arguments:

    A - One half of the comparison.

    SpanOfA - In units of bytes, the span of A.

    B - One half of the comparison.

    SpanOfB - In units of bytes, the span of B.


Return Value:

    The result of the comparison.

--*/

{

   LARGE_INTEGER a;
   LARGE_INTEGER b;

   LARGE_INTEGER lower;
   ULONG lowerSpan;
   LARGE_INTEGER higher;

   //PAGED_CODE(); Non paged because it can be called during CyyLogError, which is no paged now.

   a = A;
   b = B;

   if (a.QuadPart == b.QuadPart) {

      return AddressesAreEqual;

   }

   if (a.QuadPart > b.QuadPart) {

      higher = a;
      lower = b;
      lowerSpan = SpanOfB;

   } else {

      higher = b;
      lower = a;
      lowerSpan = SpanOfA;

   }

   if ((higher.QuadPart - lower.QuadPart) >= lowerSpan) {

      return AddressesAreDisjoint;

   }

   return AddressesOverlap;

}


VOID
CyyLogError(
              IN PDRIVER_OBJECT DriverObject,
              IN PDEVICE_OBJECT DeviceObject OPTIONAL,
              IN PHYSICAL_ADDRESS P1,
              IN PHYSICAL_ADDRESS P2,
              IN ULONG SequenceNumber,
              IN UCHAR MajorFunctionCode,
              IN UCHAR RetryCount,
              IN ULONG UniqueErrorValue,
              IN NTSTATUS FinalStatus,
              IN NTSTATUS SpecificIOStatus,
              IN ULONG LengthOfInsert1,
              IN PWCHAR Insert1,
              IN ULONG LengthOfInsert2,
              IN PWCHAR Insert2
              )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DriverObject - A pointer to the driver object for the device.

    DeviceObject - A pointer to the device object associated with the
    device that had the error, early in initialization, one may not
    yet exist.

    P1,P2 - If phyical addresses for the controller ports involved
    with the error are available, put them through as dump data.

    SequenceNumber - A ulong value that is unique to an IRP over the
    life of the irp in this driver - 0 generally means an error not
    associated with an irp.

    MajorFunctionCode - If there is an error associated with the irp,
    this is the major function code of that irp.

    RetryCount - The number of times a particular operation has been
    retried.

    UniqueErrorValue - A unique long word that identifies the particular
    call to this function.

    FinalStatus - The final status given to the irp that was associated
    with this error.  If this log entry is being made during one of
    the retries this value will be STATUS_SUCCESS.

    SpecificIOStatus - The IO status for a particular error.

    LengthOfInsert1 - The length in bytes (including the terminating NULL)
                      of the first insertion string.

    Insert1 - The first insertion string.

    LengthOfInsert2 - The length in bytes (including the terminating NULL)
                      of the second insertion string.  NOTE, there must
                      be a first insertion string for their to be
                      a second insertion string.

    Insert2 - The second insertion string.

Return Value:

    None.

--*/

{
   PIO_ERROR_LOG_PACKET errorLogEntry;

   PVOID objectToUse;
   SHORT dumpToAllocate = 0;
   PUCHAR ptrToFirstInsert;
   PUCHAR ptrToSecondInsert;

   //PAGED_CODE(); It can be called at raised IRQL.

   if (Insert1 == NULL) {
      LengthOfInsert1 = 0;
   }

   if (Insert2 == NULL) {
      LengthOfInsert2 = 0;
   }


   if (ARGUMENT_PRESENT(DeviceObject)) {

      objectToUse = DeviceObject;

   } else {

      objectToUse = DriverObject;

   }

   if (CyyMemCompare(
                       P1,
                       (ULONG)1,
                       CyyPhysicalZero,
                       (ULONG)1
                       ) != AddressesAreEqual) {

      dumpToAllocate = (SHORT)sizeof(PHYSICAL_ADDRESS);

   }

   if (CyyMemCompare(
                       P2,
                       (ULONG)1,
                       CyyPhysicalZero,
                       (ULONG)1
                       ) != AddressesAreEqual) {

      dumpToAllocate += (SHORT)sizeof(PHYSICAL_ADDRESS);

   }

   errorLogEntry = IoAllocateErrorLogEntry(
                                          objectToUse,
                                          (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
                                                  dumpToAllocate
                                                  + LengthOfInsert1 +
                                                  LengthOfInsert2)
                                          );

   if ( errorLogEntry != NULL ) {

      errorLogEntry->ErrorCode = SpecificIOStatus;
      errorLogEntry->SequenceNumber = SequenceNumber;
      errorLogEntry->MajorFunctionCode = MajorFunctionCode;
      errorLogEntry->RetryCount = RetryCount;
      errorLogEntry->UniqueErrorValue = UniqueErrorValue;
      errorLogEntry->FinalStatus = FinalStatus;
      errorLogEntry->DumpDataSize = dumpToAllocate;

      if (dumpToAllocate) {

         RtlCopyMemory(
                      &errorLogEntry->DumpData[0],
                      &P1,
                      sizeof(PHYSICAL_ADDRESS)
                      );

         if (dumpToAllocate > sizeof(PHYSICAL_ADDRESS)) {

            RtlCopyMemory(
                         ((PUCHAR)&errorLogEntry->DumpData[0])
                         +sizeof(PHYSICAL_ADDRESS),
                         &P2,
                         sizeof(PHYSICAL_ADDRESS)
                         );

            ptrToFirstInsert =
            ((PUCHAR)&errorLogEntry->DumpData[0])+(2*sizeof(PHYSICAL_ADDRESS));

         } else {

            ptrToFirstInsert =
            ((PUCHAR)&errorLogEntry->DumpData[0])+sizeof(PHYSICAL_ADDRESS);


         }

      } else {

         ptrToFirstInsert = (PUCHAR)&errorLogEntry->DumpData[0];

      }

      ptrToSecondInsert = ptrToFirstInsert + LengthOfInsert1;

      if (LengthOfInsert1) {

         errorLogEntry->NumberOfStrings = 1;
         errorLogEntry->StringOffset = (USHORT)(ptrToFirstInsert -
                                                (PUCHAR)errorLogEntry);
         RtlCopyMemory(
                      ptrToFirstInsert,
                      Insert1,
                      LengthOfInsert1
                      );

         if (LengthOfInsert2) {

            errorLogEntry->NumberOfStrings = 2;
            RtlCopyMemory(
                         ptrToSecondInsert,
                         Insert2,
                         LengthOfInsert2
                         );

         }

      }

      IoWriteErrorLogEntry(errorLogEntry);

   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyclom-y\pnp.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Enumerator Driver
*	
*   This file:      pnp.c
*	
*   Description:    This module contains contains the plugplay calls
*                   PNP / WDM BUS driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#include "pch.h"

static const PHYSICAL_ADDRESS CyyPhysicalZero = {0};

// FANNY_ADDPAGABLE_LATER
//#ifdef ALLOC_PRAGMA
//#pragma alloc_text (PAGE, Cyclomy_AddDevice)
//#pragma alloc_text (PAGE, Cyclomy_PnP)
//#pragma alloc_text (PAGE, Cyclomy_FDO_PnP)
//#pragma alloc_text (PAGE, Cyclomy_PDO_PnP)
//#pragma alloc_text (PAGE, Cyclomy_PnPRemove)
//#pragma alloc_text (PAGE, Cyclomy_StartDevice)
////#pragma alloc_text (PAGE, Cyclomy_Remove)
//#endif


NTSTATUS
Cyclomy_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusPhysicalDeviceObject
    )
/*++
Routine Description.
    A bus has been found.  Attach our FDO to it.
    Allocate any required resources.  Set things up.  And be prepared for the
    first ``start device.''

Arguments:
    DriverObject - This very self referenced driver.

    BusPhysicalDeviceObject - Device object representing the bus.  That to which
        we attach a new FDO.

--*/
{
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject;
    PFDO_DEVICE_DATA    DeviceData;
    ULONG               nameLength;
    ULONG               i;
    INTERFACE_TYPE      interfaceType;
    ULONG               interfaceTypeLength;
    ULONG               uiNumber,uiNumberLength;
    
    PAGED_CODE ();

    Cyclomy_KdPrint_Def (SER_DBG_PNP_TRACE, ("Add Device: 0x%x\n",
                                              BusPhysicalDeviceObject));
    //
    // Create our FDO
    //

    status = IoCreateDevice(DriverObject, sizeof(FDO_DEVICE_DATA), NULL,
                           FILE_DEVICE_BUS_EXTENDER, 0, TRUE, &deviceObject);

    if (NT_SUCCESS (status)) {
        DeviceData = (PFDO_DEVICE_DATA) deviceObject->DeviceExtension;
        RtlFillMemory (DeviceData, sizeof (FDO_DEVICE_DATA), 0);

        DeviceData->IsFDO = TRUE;
        DeviceData->DebugLevel = SER_DEFAULT_DEBUG_OUTPUT_LEVEL;
        DeviceData->Self = deviceObject;
        DeviceData->DriverObject = DriverObject;
        for (i=0; i<CYY_MAX_PORTS; i++) {
           DeviceData->AttachedPDO[i] = NULL;
        }
        DeviceData->NumPDOs = 0;

        DeviceData->DeviceState = PowerDeviceD0;
        DeviceData->SystemState = PowerSystemWorking; // FANNY: This seems to be not needed

        DeviceData->SystemWake=PowerSystemUnspecified;
        DeviceData->DeviceWake=PowerDeviceUnspecified;

        INITIALIZE_PNP_STATE(DeviceData);

        // Set the PDO for use with PlugPlay functions
        DeviceData->UnderlyingPDO = BusPhysicalDeviceObject;


        //
        // Attach our filter driver to the device stack.
        // the return value of IoAttachDeviceToDeviceStack is the top of the
        // attachment chain.  This is where all the IRPs should be routed.
        //
        // Our filter will send IRPs to the top of the stack and use the PDO
        // for all PlugPlay functions.
        //
        DeviceData->TopOfStack 
            = IoAttachDeviceToDeviceStack(deviceObject, BusPhysicalDeviceObject);

        deviceObject->Flags |= DO_BUFFERED_IO;

        // Bias outstanding request to 1 so that we can look for a
        // transition to zero when processing the remove device PlugPlay IRP.
        DeviceData->OutstandingIO = 1;

        KeInitializeEvent(&DeviceData->RemoveEvent, SynchronizationEvent,
                        FALSE);

        //
        // Tell the PlugPlay system that this device will need an interface
        // device class shingle.
        //
        // It may be that the driver cannot hang the shingle until it starts
        // the device itself, so that it can query some of its properties.
        // (Aka the shingles guid (or ref string) is based on the properties
        // of the device.)
        //
        status = IoRegisterDeviceInterface (BusPhysicalDeviceObject,
                                            (LPGUID) &GUID_CYCLOMY_BUS_ENUMERATOR,
                                            NULL,
                                            &DeviceData->DevClassAssocName);

        if (!NT_SUCCESS (status)) {
            CyyLogError(DriverObject, NULL, CyyPhysicalZero, CyyPhysicalZero,
                        0, 0, 0, 0, status, CYY_REGISTER_INTERFACE_FAILURE,
                        0, NULL, 0, NULL);
            Cyclomy_KdPrint_Def (SER_DBG_PNP_ERROR,
                                ("AddDevice: IoRegisterDCA failed (%x)", status));
            goto CyclomyAddDevice_Error;
        }

        //
        // If for any reason you need to save values in a safe location that
        // clients of this DeviceClassAssociate might be interested in reading
        // here is the time to do so, with the function
        // IoOpenDeviceClassRegistryKey
        // the symbolic link name used is was returned in
        // DeviceData->DevClassAssocName (the same name which is returned by
        // IoGetDeviceClassAssociations and the SetupAPI equivs.
        //

#if DBG
      {
         PWCHAR deviceName = NULL;

         status = IoGetDeviceProperty (BusPhysicalDeviceObject,
                                       DevicePropertyPhysicalDeviceObjectName,0,
                                       NULL,&nameLength);

         if ((nameLength != 0) && (status == STATUS_BUFFER_TOO_SMALL)) {
            deviceName = ExAllocatePool (NonPagedPool, nameLength);

            if (NULL == deviceName) {
               goto someDebugStuffExit;
            }

            IoGetDeviceProperty (BusPhysicalDeviceObject,
                                 DevicePropertyPhysicalDeviceObjectName,
                                 nameLength, deviceName, &nameLength);

            Cyclomy_KdPrint_Def (SER_DBG_PNP_TRACE,
                                 ("AddDevice: %x to %x->%x (%ws) \n",
                                 deviceObject, DeviceData->TopOfStack,
                                 BusPhysicalDeviceObject, deviceName));
         }

someDebugStuffExit:;
         if (deviceName != NULL) {
            ExFreePool(deviceName);
         }
      }
#endif

        status = IoGetDeviceProperty (BusPhysicalDeviceObject,
                                      DevicePropertyLegacyBusType,
                                      sizeof(interfaceType),
                                      &interfaceType,
                                      &interfaceTypeLength);

        if (!NT_SUCCESS (status)) {
			if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
				interfaceType = Isa;
			} else {
                CyyLogError(DriverObject, NULL, CyyPhysicalZero, CyyPhysicalZero,
                        0, 0, 0, 0, status, CYY_GET_BUS_TYPE_FAILURE,
                        0, NULL, 0, NULL);
                Cyclomy_KdPrint_Def ( SER_DBG_PNP_ERROR,
                                      ("AddDevice: IoGetDeviceProperty LegacyBusType failed (%x)", 
                                      status));
                goto CyclomyAddDevice_Error;
            }
        }
        if (interfaceType == PCIBus) {
            DeviceData->IsPci = 1;

            status = IoGetDeviceProperty (BusPhysicalDeviceObject,
                                          DevicePropertyUINumber ,
                                          sizeof(uiNumber),
                                          &uiNumber,
                                          &uiNumberLength);

            if (!NT_SUCCESS (status)) {

                uiNumber = 0xFFFFFFFF;
                Cyclomy_KdPrint_Def (SER_DBG_PNP_ERROR,
                                     ("AddDevice: IoGetDeviceProperty DevicePropertyUINumber failed (%x)", 
                                     status));
            }
        } else {
            // ISA board
            uiNumber = 0xFFFFFFFF; // What does DevicePropertyUINumber return for ISA board?
        }
        DeviceData->UINumber = uiNumber;

        //
        // Turn on the shingle and point it to the given device object.
        //
        status = IoSetDeviceInterfaceState (
                        &DeviceData->DevClassAssocName,
                        TRUE);

        if (!NT_SUCCESS (status)) {
            CyyLogError(DriverObject, NULL, CyyPhysicalZero, CyyPhysicalZero,
                        0, 0, 0, 0, status, CYY_SET_INTERFACE_STATE_FAILURE,
                        0, NULL, 0, NULL);
            Cyclomy_KdPrint_Def (SER_DBG_PNP_ERROR,
                                ("AddDevice: IoSetDeviceClass failed (%x)", status));
            //return status;
            goto CyclomyAddDevice_Error;
        }

        deviceObject->Flags |= DO_POWER_PAGABLE;
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    } else {
      CyyLogError(DriverObject, NULL, CyyPhysicalZero, CyyPhysicalZero,
                  0, 0, 0, 0, status, CYY_DEVICE_CREATION_FAILURE,
                  0, NULL, 0, NULL);
    }

    return status;


CyclomyAddDevice_Error:

    if (DeviceData->DevClassAssocName.Buffer) {
       RtlFreeUnicodeString(&DeviceData->DevClassAssocName);
    }

    if (DeviceData->TopOfStack) {
       IoDetachDevice (DeviceData->TopOfStack);
    }
    if (deviceObject) {
       IoDeleteDevice (deviceObject);
    }
 
    return status;
}

NTSTATUS
Cyclomy_PnP (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++
Routine Description:
    Answer the plethora of Irp Major PnP IRPS.
--*/
{
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                status;
    PCOMMON_DEVICE_DATA     commonData;
    KIRQL                   oldIrq;
#if DBG
    UCHAR                   MinorFunction;
#endif

    PAGED_CODE ();

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (irpStack->MajorFunction == IRP_MJ_PNP);
#if DBG
    MinorFunction = irpStack->MinorFunction;
#endif

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;

    //
    // If removed, fail the request and get out
    //

    if (commonData->DevicePnPState == Deleted) {   // if (commonData->Removed) added in build 2072.

        Cyclomy_KdPrint(commonData, SER_DBG_PNP_TRACE,
                        ("PNP: removed DO: %x got IRP: %x\n", DeviceObject, 
                         Irp));

        Irp->IoStatus.Status = status = STATUS_NO_SUCH_DEVICE;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        goto PnPDone;
    }

    //
    // Call either the FDO or PDO Pnp code
    //

    if (commonData->IsFDO) {
        Cyclomy_KdPrint(commonData, SER_DBG_PNP_TRACE,
                        ("FDO(%x):%s IRP:%x\n", DeviceObject, 
                        PnPMinorFunctionString(irpStack->MinorFunction),Irp));

        status = Cyclomy_FDO_PnP(DeviceObject, Irp, irpStack,
                    (PFDO_DEVICE_DATA) commonData);
        goto PnPDone;

    }

    //
    // PDO
    //

    Cyclomy_KdPrint(commonData, SER_DBG_PNP_TRACE,
                    ("PDO(%x):%s IRP:%x\n", DeviceObject, 
                    PnPMinorFunctionString(irpStack->MinorFunction),Irp));

    status = Cyclomy_PDO_PnP(DeviceObject, Irp, irpStack,
                             (PPDO_DEVICE_DATA) commonData);

PnPDone:;
    return status;
}

NTSTATUS
Cyclomy_FDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PFDO_DEVICE_DATA     DeviceData
    )
/*++
Routine Description:
    Handle requests from the PlugPlay system for the BUS itself

    NB: the various Minor functions of the PlugPlay system will not be
    overlapped and do not have to be reentrant

--*/
{
    NTSTATUS    status;
    KIRQL       oldIrq;
    KEVENT      event;
    ULONG       length;
    ULONG       i;
    PLIST_ENTRY entry;
    PPDO_DEVICE_DATA    pdoData;
    PDEVICE_RELATIONS   relations;
    PIO_STACK_LOCATION  stack;
    PRTL_QUERY_REGISTRY_TABLE QueryTable = NULL;
    ULONG DebugLevelDefault = SER_DEFAULT_DEBUG_OUTPUT_LEVEL;
    HANDLE      instanceKey;
    UNICODE_STRING  keyName;
    ULONG       numOfPorts;
       
    PAGED_CODE ();

    status = Cyclomy_IncIoCount (DeviceData);
    if (!NT_SUCCESS (status)) {
        //Irp->IoStatus.Information = 0; Removed in build 2072
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    stack = IoGetCurrentIrpStackLocation (Irp);

    switch (IrpStack->MinorFunction) {

       case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: {

         PIO_RESOURCE_REQUIREMENTS_LIST pReqList;
         PIO_RESOURCE_LIST pResList;
         PIO_RESOURCE_DESCRIPTOR pResDesc;
         ULONG i, j;
         ULONG reqCnt;
         ULONG gotPLX;
         ULONG gotMemory;
         ULONG gotInt;
         ULONG listNum;


         // FANNY: The serial driver had it as SynchronizationEvent.
         KeInitializeEvent(&event, NotificationEvent, FALSE);

         IoCopyCurrentIrpStackLocationToNext(Irp);
         IoSetCompletionRoutine(Irp, 
                                CyclomySyncCompletion, 
                                &event,
                                TRUE, 
                                TRUE, 
                                TRUE);

         status = IoCallDriver(DeviceData->TopOfStack, Irp);

         if (status == STATUS_PENDING) {
            KeWaitForSingleObject (&event, Executive, KernelMode, FALSE,
                                   NULL);
         }

         if (Irp->IoStatus.Information == 0) {
            if (stack->Parameters.FilterResourceRequirements
                .IoResourceRequirementList == 0) {
               Cyclomy_KdPrint(DeviceData, SER_DBG_CYCLADES, ("Can't filter NULL resources!"
                                                       "\n"));
               status = Irp->IoStatus.Status;
               IoCompleteRequest (Irp, IO_NO_INCREMENT);
               Cyclomy_DecIoCount (DeviceData);
               return status;
            }

            Irp->IoStatus.Information = (ULONG_PTR)stack->Parameters
                                        .FilterResourceRequirements
                                        .IoResourceRequirementList;

         }


         //
         // Force ISR ports in IO_RES_REQ_LIST to shared status
         // Force interrupts to shared status
         //

         //
         // We will only process the first list -- multiport boards
         // should not have alternative resources
         //

         pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)Irp->IoStatus.Information;
         pResList = &pReqList->List[0];

         Cyclomy_KdPrint(DeviceData, SER_DBG_CYCLADES, ("------- List has %x lists "
                                                        "(including alternatives)\n",
                                                        pReqList->AlternativeLists));

         for (listNum = 0; listNum < (pReqList->AlternativeLists);
              listNum++) {
            gotPLX = 0;
            gotMemory = 0;
            gotInt = 0;

            Cyclomy_KdPrint(DeviceData, SER_DBG_CYCLADES, ("------- List has %x resources in it\n",
                                                           pResList->Count));

            for (j = 0; (j < pResList->Count); j++) {
               pResDesc = &pResList->Descriptors[j];

               switch (pResDesc->Type) {
               case CmResourceTypeMemory:
                  if (pResDesc->u.Memory.Length == CYY_RUNTIME_LENGTH) {
                      gotPLX = 1;
                      //wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
                      //pResDesc->ShareDisposition = CmResourceShareShared; 
                      //wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
                      //TODO FANNY: Which should be the ShareDisposition for Y?
                      //pResDesc->ShareDisposition = CmResourceShareDriverExclusive; 
                      //Cyclomy_KdPrint(DeviceData,SER_DBG_CYCLADES,("------- Sharing PLX Memory for "
                      //                               "device %x\n", DeviceData->TopOfStack));

                  } else {
                      gotMemory = 1;
                      //wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
                      //pResDesc->ShareDisposition = CmResourceShareShared; 
                      //wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
                      //TODO FANNY: Which should be the ShareDisposition for Y?
                      //pResDesc->ShareDisposition = CmResourceShareDriverExclusive; 
                      //Cyclomy_KdPrint(DeviceData,SER_DBG_CYCLADES,("------- Sharing Board Memory for "
                      //                               "device %x\n", DeviceData->TopOfStack));
                  }
                  break;

               case CmResourceTypePort:
                  Cyclomy_KdPrint(DeviceData,SER_DBG_CYCLADES,
                                         ("------- We should not have Port resource\n"));
                  break;

               case CmResourceTypeInterrupt:
                  gotInt = 1;
                  if (DeviceData->IsPci) {
                      pResDesc->ShareDisposition = CmResourceShareShared;
                  } 
                  Cyclomy_KdPrint(DeviceData,SER_DBG_CYCLADES,("------- Sharing interrupt for "
                                                 "device %x\n", DeviceData->TopOfStack));
                  break;

               default:
                  break;
               }

               //
               // If we found what we need, we can break out of the loop
               //

               // FANNY: STRANGE, THERE ARE TWICE FOR EACH TYPE. IT SEEMS THAT 
               // BOTH RAW AND TRANSLATED ARE LISTED.
               // (gotPLX && gotMemory && gotInt) 
               // break;
               //
            }

            pResList = (PIO_RESOURCE_LIST)((PUCHAR)pResList
                                           + sizeof(IO_RESOURCE_LIST)
                                           + sizeof(IO_RESOURCE_DESCRIPTOR)
                                           * (pResList->Count - 1));
         }

         status = STATUS_SUCCESS;
		 break;
    }

    case IRP_MN_START_DEVICE:
        //
        // BEFORE you are allowed to ``touch'' the device object to which
        // the FDO is attached (that send an irp from the bus to the Device
        // object to which the bus is attached).   You must first pass down
        // the start IRP.  It might not be powered on, or able to access or
        // something.
        //


        // FANNY_TODO
        // SHOULD I CALL MmLockPagableCodeSection as the serial driver?


//        if (DeviceData->Started) {
//            Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_TRACE,
//                ("Device already started\n"));
//            status = STATUS_SUCCESS;
//            break;
//        }

        KeInitializeEvent (&event, NotificationEvent, FALSE);
        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine (Irp,
                                CyclomySyncCompletion,
                                &event,
                                TRUE,
                                TRUE,
                                TRUE);

        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        if (STATUS_PENDING == status) {
            // wait for it...

            status = KeWaitForSingleObject (&event,
                                            Executive,
                                            KernelMode,
                                            FALSE, // Not allertable
                                            NULL); // No timeout structure

            ASSERT (STATUS_SUCCESS == status);

            status = Irp->IoStatus.Status;
        }

        if (NT_SUCCESS(status)) {

            //
            // Get the debug level from the registry
            //

            if (NULL == (QueryTable = ExAllocatePool(
                                        PagedPool,
                                        sizeof(RTL_QUERY_REGISTRY_TABLE)*2
                                        ))) {
                Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_ERROR,
                                ("Failed to allocate memory to query registy\n"));
                DeviceData->DebugLevel = DebugLevelDefault;
            } else {
                RtlZeroMemory(
                           QueryTable,
                           sizeof(RTL_QUERY_REGISTRY_TABLE)*2
                           );

                QueryTable[0].QueryRoutine = NULL;
                QueryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
                QueryTable[0].EntryContext = &DeviceData->DebugLevel;
                QueryTable[0].Name      = L"DebugLevel";
                QueryTable[0].DefaultType   = REG_DWORD;
                QueryTable[0].DefaultData   = &DebugLevelDefault;
                QueryTable[0].DefaultLength= sizeof(ULONG);

                // CIMEXCIMEX: The rest of the table isn't filled in!  Comment changed bld 2128

                if (!NT_SUCCESS(RtlQueryRegistryValues(
                    RTL_REGISTRY_SERVICES,
                    L"cyclom-y",
                    QueryTable,
                    NULL,
                    NULL))) {
                    Cyclomy_KdPrint (DeviceData,SER_DBG_PNP_ERROR,
                        ("Failed to get debug level from registry.  "
                         "Using default\n"));
                    DeviceData->DebugLevel = DebugLevelDefault;
                }

                ExFreePool( QueryTable );
            }

            status = Cyclomy_GetResourceInfo(DeviceObject,
                        IrpStack->Parameters.StartDevice.AllocatedResources,
                        IrpStack->Parameters.StartDevice.AllocatedResourcesTranslated);

            if (NT_SUCCESS(status)) {

                ULONG numberOfResources = CYY_NUMBER_OF_RESOURCES;
                if (!DeviceData->IsPci) {
                    numberOfResources--;
                }
                status = Cyclomy_BuildResourceList(&DeviceData->PChildResourceList,
                                    &DeviceData->PChildResourceListSize,
                                    IrpStack->Parameters.StartDevice.AllocatedResources,
                                    numberOfResources);

                if (!NT_SUCCESS(status)) {
                    goto CaseSTART_end;
                }

                status = Cyclomy_BuildResourceList(&DeviceData->PChildResourceListTr,
                                    &DeviceData->PChildResourceListSizeTr,
                                    IrpStack->Parameters.StartDevice.AllocatedResourcesTranslated,
                                    numberOfResources);

                if (!NT_SUCCESS(status)) {
                    goto CaseSTART_end;
                }
              
                status = Cyclomy_BuildRequirementsList(&DeviceData->PChildRequiredList,
                                    IrpStack->Parameters.StartDevice.AllocatedResources,
                                    numberOfResources);

                if (!NT_SUCCESS(status)) {
                    goto CaseSTART_end;
                }

                //
                // See if we are in the proper power state.
                //

                if (DeviceData->DeviceState != PowerDeviceD0) {

                    status = Cyclomy_GotoPowerState(DeviceData->UnderlyingPDO, DeviceData, 
                                              PowerDeviceD0);

                    if (!NT_SUCCESS(status)) {
                        goto CaseSTART_end;
                    }
                }

                numOfPorts=Cyclomy_DoesBoardExist(DeviceData);
                if (!numOfPorts){
                    Cyclomy_KdPrint_Def(SER_DBG_CYCLADES,("Does Port exist test failed\n"));
                    status = STATUS_SERIAL_NO_DEVICE_INITED;
                    goto CaseSTART_end;
                }
                Cyclomy_KdPrint(DeviceData,SER_DBG_CYCLADES,("Board found!\n"));

                Cyclomy_EnableInterruptInPLX(DeviceData); // Enable interrupt in the PLX

                // Save number of ports to the Registry, so that Property Page
                // code can retrieve it.
    
                IoOpenDeviceRegistryKey(DeviceData->UnderlyingPDO,PLUGPLAY_REGKEY_DEVICE,
                    STANDARD_RIGHTS_WRITE,&instanceKey);

                RtlInitUnicodeString(&keyName,L"NumOfPorts");
                ZwSetValueKey(instanceKey,&keyName,0,REG_DWORD,&numOfPorts,sizeof(ULONG));

                ZwFlushKey(instanceKey);
                ZwClose(instanceKey);

                Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_TRACE,
                                ("Start Device: Device started successfully\n"));
                SET_NEW_PNP_STATE(DeviceData, Started);

                // TODO: FOR NOW, LET'S KEEP THIS DEVICE IN POWER D0. 
                // THE SERIAL DRIVER SEEMS TO POWER DOWN TO D3, AND BECOME D0 DURING OPEN.
                // BUT NOT SURE IF THE BOARD NEED TO BE IN D0 WHILE THE CHILD DEVICES
                // ARE ENUMARATED.

            }                                
        }

CaseSTART_end:
        if (!NT_SUCCESS(status)) {
            Cyclomy_ReleaseResources(DeviceData);
        }
        
        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //

        //Irp->IoStatus.Information = 0;  Removed in build 2072
        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        //
        // Test to see if there are any PDO created as children of this FDO
        // If there are then conclude the device is busy and fail the
        // query stop.
        //
        // CIMEXCIMEX   (BUGBUG replaced by CIMEXCIMEX on build 2128 - Fanny)
        // We could do better, by seing if the children PDOs are actually
        // currently open.  If they are not then we could stop, get new
        // resouces, fill in the new resouce values, and then when a new client
        // opens the PDO use the new resources.  But this works for now.
        //
//TODO FANNY: FOR NOW WE WILL ALWAYS ACCEPT TO STOP DEVICE. REVIEW THIS LATER...
//        if (DeviceData->AttachedPDO) {
//            status = STATUS_UNSUCCESSFUL;
//        } else {
//            status = STATUS_SUCCESS;
//        }

        status = STATUS_SUCCESS;

        Irp->IoStatus.Status = status;

        if (NT_SUCCESS(status)) {
           SET_NEW_PNP_STATE(DeviceData, StopPending);
           IoSkipCurrentIrpStackLocation (Irp);
           status = IoCallDriver (DeviceData->TopOfStack, Irp);
        } else {
           IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }

        Cyclomy_DecIoCount (DeviceData);
        return status;

    case IRP_MN_CANCEL_STOP_DEVICE:

        KeInitializeEvent (&event, NotificationEvent, FALSE);
        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine (Irp,
                                CyclomySyncCompletion,
                                &event,
                                TRUE,
                                TRUE,
                                TRUE);

        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        if (STATUS_PENDING == status) {
            // wait for it...

            status = KeWaitForSingleObject (&event,
                                            Executive,
                                            KernelMode,
                                            FALSE, // Not allertable
                                            NULL); // No timeout structure

            ASSERT (STATUS_SUCCESS == status);

            status = Irp->IoStatus.Status;
        }

        if(StopPending == DeviceData->DevicePnPState)
        {
            //
            // We did receive a query-stop, so restore.
            //             
            RESTORE_PREVIOUS_PNP_STATE(DeviceData);
            ASSERT(DeviceData->DevicePnPState == Started);
        }        

        break;

    case IRP_MN_STOP_DEVICE:

        //
        // After the start IRP has been sent to the lower driver object, the
        // bus may NOT send any more IRPS down ``touch'' until another START
        // has occured.
        // What ever access is required must be done before the Irp is passed
        // on.
        //
        // Stop device means that the resources given durring Start device
        // are no revoked.  So we need to stop using them
        //
        Cyclomy_ReleaseResources(DeviceData);

        SET_NEW_PNP_STATE(DeviceData, Stopped);

        //
        // We don't need a completion routine so fire and forget.
        //
        // Set the current stack location to the next stack location and
        // call the next device object.
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        Cyclomy_DecIoCount (DeviceData);
        return status;

    case IRP_MN_QUERY_REMOVE_DEVICE:
        //
        // If we were to fail this call then we would need to complete the
        // IRP here.  Since we are not, set the status to SUCCESS and
        // call the next driver.
        //
        SET_NEW_PNP_STATE(DeviceData, RemovePending);

        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);
        Cyclomy_DecIoCount (DeviceData);
        return status;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        //
        // If we were to fail this call then we would need to complete the
        // IRP here.  Since we are not, set the status to SUCCESS and
        // call the next driver.
        //
        
        //
        // First check to see whether you have received cancel-remove
        // without first receiving a query-remove. This could happen if 
        // someone above us fails a query-remove and passes down the 
        // subsequent cancel-remove.
        //
        
        if(RemovePending == DeviceData->DevicePnPState)
        {
            //
            // We did receive a query-remove, so restore.
            //             
            RESTORE_PREVIOUS_PNP_STATE(DeviceData);
        }
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);
        Cyclomy_DecIoCount (DeviceData);
        return status;
        
    case IRP_MN_SURPRISE_REMOVAL:

        SET_NEW_PNP_STATE(DeviceData, SurpriseRemovePending);

        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);
        Cyclomy_DecIoCount (DeviceData);
        return status;

    case IRP_MN_REMOVE_DEVICE:

        //
        // The PlugPlay system has detected the removal of this device.  We
        // have no choice but to detach and delete the device object.
        // (If we wanted to express and interest in preventing this removal,
        // we should have filtered the query remove and query stop routines.)
        //
        // Note! we might receive a remove WITHOUT first receiving a stop.
        // ASSERT (!DeviceData->Removed);

        // We will accept no new requests
        //
//        DeviceData->Removed = TRUE;
        SET_NEW_PNP_STATE(DeviceData, Deleted);

        //
        // Complete any outstanding IRPs queued by the driver here.
        //

        //
        // Make the DCA go away.  Some drivers may choose to remove the DCA
        // when they receive a stop or even a query stop.  We just don't care.
        //
        IoSetDeviceInterfaceState (&DeviceData->DevClassAssocName, FALSE);

        //
        // Here if we had any outstanding requests in a personal queue we should
        // complete them all now.
        //
        // Note, the device is guarenteed stopped, so we cannot send it any non-
        // PNP IRPS.
        //

        //
        // Fire and forget
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        //
        // Wait for all outstanding requests to complete
        //
        Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_TRACE,
            ("Waiting for outstanding requests\n"));
        i = InterlockedDecrement (&DeviceData->OutstandingIO);

        ASSERT (0 < i);

        if (0 != InterlockedDecrement (&DeviceData->OutstandingIO)) {
            Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_INFO,
                          ("Remove Device waiting for request to complete\n"));

            KeWaitForSingleObject (&DeviceData->RemoveEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE, // Not Alertable
                                   NULL); // No timeout
        }
        //
        // Free the associated resources
        //

        //
        // Detach from the underlying devices.
        //
        Cyclomy_KdPrint(DeviceData, SER_DBG_PNP_INFO,
                        ("IoDetachDevice: 0x%x\n", DeviceData->TopOfStack));
        IoDetachDevice (DeviceData->TopOfStack);

        //
        // Clean up any resources here
        //
        Cyclomy_ReleaseResources(DeviceData);

        ExFreePool (DeviceData->DevClassAssocName.Buffer);
        Cyclomy_KdPrint(DeviceData, SER_DBG_PNP_INFO,
                        ("IoDeleteDevice: 0x%x\n", DeviceObject));

        //
        // Remove any PDO's we ejected
        //
//FANNY: CHANGED TO SUPPORT MORE THAN ONE CHILD DEVICE
//        if (DeviceData->AttachedPDO != NULL) {
//           ASSERT(DeviceData->NumPDOs == 1);
//
//           Cyclomy_PnPRemove(DeviceData->AttachedPDO, DeviceData->PdoData);
//           DeviceData->PdoData = NULL;
//           DeviceData->AttachedPDO = NULL;
//           DeviceData->NumPDOs = 0;
//        }

        i=DeviceData->NumPDOs;
        while(i--) {
           if (DeviceData->AttachedPDO[i] != NULL) {
              (DeviceData->PdoData[i])->Attached = FALSE;
              if(SurpriseRemovePending != (DeviceData->PdoData[i])->DevicePnPState) {
                  Cyclomy_PnPRemove(DeviceData->AttachedPDO[i], DeviceData->PdoData[i]);
              }
              DeviceData->PdoData[i] = NULL;
              DeviceData->AttachedPDO[i] = NULL;
           }
        }
        DeviceData->NumPDOs = 0;

        IoDeleteDevice(DeviceObject);

        return status;


    case IRP_MN_QUERY_DEVICE_RELATIONS:
        Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_TRACE, 
                    ("\tQueryDeviceRelation Type: %d\n", 
                    IrpStack->Parameters.QueryDeviceRelations.Type));

        if (BusRelations != IrpStack->Parameters.QueryDeviceRelations.Type) {
            //
            // We don't support this
            //
            Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_TRACE,
                ("Query Device Relations - Non bus\n"));
            goto CYY_FDO_PNP_DEFAULT;
        }

        Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_TRACE,
            ("\tQuery Bus Relations\n"));

        // Check for new devices or if old devices still there.
        status = Cyclomy_ReenumerateDevices(Irp, DeviceData );

        //
        // Tell the plug and play system about all the PDOs.
        //
        // There might also be device relations below and above this FDO,
        // so, be sure to propagate the relations from the upper drivers.
        //
        // No Completion routine is needed so long as the status is preset
        // to success.  (PDOs complete plug and play irps with the current
        // IoStatus.Status and IoStatus.Information as the default.)
        //

        //KeAcquireSpinLock (&DeviceData->Spin, &oldIrq);

        i = (0 == Irp->IoStatus.Information) ? 0 :
            ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Count;
        // The current number of PDOs in the device relations structure

        Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_TRACE,
                           ("#PDOS = %d + %d\n", i, DeviceData->NumPDOs));

        length = sizeof(DEVICE_RELATIONS) +
                ((DeviceData->NumPDOs + i) * sizeof (PDEVICE_OBJECT));

        relations = (PDEVICE_RELATIONS) ExAllocatePool (NonPagedPool, length);

        if (NULL == relations) {
           Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
           IoCompleteRequest(Irp, IO_NO_INCREMENT);
           Cyclomy_DecIoCount(DeviceData);
           return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Copy in the device objects so far
        //
        if (i) {
            RtlCopyMemory (
                  relations->Objects,
                  ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Objects,
                  i * sizeof (PDEVICE_OBJECT));
        }

        relations->Count = DeviceData->NumPDOs + i;


        //
        // For each PDO on this bus add a pointer to the device relations
        // buffer, being sure to take out a reference to that object.
        // The PlugPlay system will dereference the object when it is done with
        // it and free the device relations buffer.
        //

        //FANNY: CHANGED TO SUPPORT ADDITIONAL CHILD DEVICES
//        if (DeviceData->NumPDOs) {
//            relations->Objects[relations->Count-1] = DeviceData->AttachedPDO;
//            ObReferenceObject (DeviceData->AttachedPDO);
//        }

        for (i=0; i< DeviceData->NumPDOs; i++) {
           relations->Objects[relations->Count - DeviceData->NumPDOs + i] = 
                                                               DeviceData->AttachedPDO[i];
           ObReferenceObject (DeviceData->AttachedPDO[i]);

           Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_TRACE,
                           ("Child PDOS: %x\n", DeviceData->AttachedPDO[i]));
        }

        //
        // Set up and pass the IRP further down the stack
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;

        if (0 != Irp->IoStatus.Information) {
            ExFreePool ((PVOID) Irp->IoStatus.Information);
        }
        Irp->IoStatus.Information = (ULONG_PTR)relations;

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        Cyclomy_DecIoCount (DeviceData);

        return status;

    case IRP_MN_QUERY_CAPABILITIES: {

        PIO_STACK_LOCATION  irpSp;

        //
        // Send this down to the PDO first
        //

        KeInitializeEvent (&event, NotificationEvent, FALSE);
        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine (Irp,
                                CyclomySyncCompletion,
                                &event,
                                TRUE,
                                TRUE,
                                TRUE);

        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        if (STATUS_PENDING == status) {
            // wait for it...

            status = KeWaitForSingleObject (&event,
                                            Executive,
                                            KernelMode,
                                            FALSE, // Not allertable
                                            NULL); // No timeout structure

            ASSERT (STATUS_SUCCESS == status);

            status = Irp->IoStatus.Status;
        }

        if (NT_SUCCESS(status)) {

            irpSp = IoGetCurrentIrpStackLocation(Irp);

            DeviceData->SystemWake=irpSp->Parameters.DeviceCapabilities.Capabilities->SystemWake;
            DeviceData->DeviceWake=irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceWake;
//#if DBG
//            DbgPrint("PowerSystemSleeping1 %d\n",
//                irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceState[PowerSystemSleeping1]);
//            DbgPrint("PowerSystemSleeping2 %d\n",
//                irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceState[PowerSystemSleeping2]);
//            DbgPrint("PowerSystemSleeping3 %d\n",
//                irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceState[PowerSystemSleeping3]);
//            DbgPrint("PowerSystemHibernate %d\n",
//                irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceState[PowerSystemHibernate]);
//            DbgPrint("PowerSystemShutdown %d\n",
//                irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceState[PowerSystemShutdown]);
//            In the test with a system that supports standby, the result was:
//            D1, Unspecified, Unspecified, D3, D3.
//#endif

            Cyclomy_KdPrint(DeviceData, SER_DBG_PNP_INFO, ("SystemWake %d\n",DeviceData->SystemWake)); 
            Cyclomy_KdPrint(DeviceData, SER_DBG_PNP_INFO, ("DeviceWake %d\n",DeviceData->DeviceWake)); 
        }

        break;
    }

    default:
        //
        // In the default case we merely call the next driver since
        // we don't know what to do.
        //
        Cyclomy_KdPrint(DeviceData, SER_DBG_PNP_TRACE, 
                 ("FDO(%x):%s not handled\n", DeviceObject,
                        PnPMinorFunctionString(IrpStack->MinorFunction)));
CYY_FDO_PNP_DEFAULT:

        //
        // Fire and Forget
        //
        IoSkipCurrentIrpStackLocation (Irp);

        //
        // Done, do NOT complete the IRP, it will be processed by the lower
        // device object, which will complete the IRP
        //

        status = IoCallDriver (DeviceData->TopOfStack, Irp);
        Cyclomy_DecIoCount (DeviceData);
        return status;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    Cyclomy_DecIoCount (DeviceData);
    return status;
}


NTSTATUS
Cyclomy_PDO_PnP (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
                 IN PIO_STACK_LOCATION IrpStack, IN PPDO_DEVICE_DATA DeviceData)
/*++
Routine Description:
    Handle requests from the PlugPlay system for the devices on the BUS

--*/
{
   PDEVICE_CAPABILITIES    deviceCapabilities;
   ULONG                   information;
   PWCHAR                  buffer;
   ULONG                   length, i, j;
   NTSTATUS                status;
   KIRQL                   oldIrq;
   HANDLE                  keyHandle;
   UNICODE_STRING          keyName;
   PWCHAR returnBuffer = NULL;

   PAGED_CODE();

   status = Irp->IoStatus.Status;

   //
   // NB: since we are a bus enumerator, we have no one to whom we could
   // defer these irps.  Therefore we do not pass them down but merely
   // return them.
   //

   switch (IrpStack->MinorFunction) {
   case IRP_MN_QUERY_CAPABILITIES:

      //
      // Get the packet.
      //

      deviceCapabilities=IrpStack->Parameters.DeviceCapabilities.Capabilities;

      //
      // Set the capabilities.
      //

      deviceCapabilities->Version = 1;
      deviceCapabilities->Size = sizeof (DEVICE_CAPABILITIES);

      //
      // We cannot wake the system.
      //

      deviceCapabilities->SystemWake 
          = ((PFDO_DEVICE_DATA)DeviceData->ParentFdo->DeviceExtension)
            ->SystemWake;
      deviceCapabilities->DeviceWake 
          = ((PFDO_DEVICE_DATA)DeviceData->ParentFdo->DeviceExtension)
            ->DeviceWake;

      //
      // We have no latencies
      //

      deviceCapabilities->D1Latency = 0;
      deviceCapabilities->D2Latency = 0;
      deviceCapabilities->D3Latency = 0;

      deviceCapabilities->UniqueID = FALSE;

      // 
      // Initialize supported DeviceState
      //

      deviceCapabilities->DeviceState[PowerSystemWorking] = PowerDeviceD0;
      deviceCapabilities->DeviceState[PowerSystemSleeping1] = PowerDeviceD3;
      deviceCapabilities->DeviceState[PowerSystemSleeping2] = PowerDeviceD3;
      deviceCapabilities->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;
      deviceCapabilities->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
      deviceCapabilities->DeviceState[PowerSystemShutdown] = PowerDeviceD3;

      status = STATUS_SUCCESS;
      break;

   case IRP_MN_QUERY_DEVICE_TEXT: {
      if ((IrpStack->Parameters.QueryDeviceText.DeviceTextType
          != DeviceTextDescription) || DeviceData->DevDesc.Buffer == NULL) {
         break;
      }

// FANNY - CHANGE TO MaximumLength
//      returnBuffer = ExAllocatePool(PagedPool, DeviceData->DevDesc.Length);
      returnBuffer = ExAllocatePool(PagedPool, DeviceData->DevDesc.MaximumLength);

      if (returnBuffer == NULL) {
         status = STATUS_INSUFFICIENT_RESOURCES;
         break;
      }

      status = STATUS_SUCCESS;

// FANNY - CHANGE TO MaximumLength
//      RtlCopyMemory(returnBuffer, DeviceData->DevDesc.Buffer,
//                    DeviceData->DevDesc.Length);
      RtlCopyMemory(returnBuffer, DeviceData->DevDesc.Buffer,
                    DeviceData->DevDesc.MaximumLength);

      Cyclomy_KdPrint(DeviceData, SER_DBG_PNP_TRACE,
                            ("TextID: buf %ws\n", returnBuffer));

      Irp->IoStatus.Information = (ULONG_PTR)returnBuffer;
      break;
   }


   case IRP_MN_QUERY_ID:
      //
      // Query the IDs of the device
      //

      switch (IrpStack->Parameters.QueryId.IdType) {

      //
      // The other ID's we just copy from the buffers and are done.
      //

      case BusQueryDeviceID:
      case BusQueryHardwareIDs:
      case BusQueryCompatibleIDs:
      case BusQueryInstanceID:
         {
            PUNICODE_STRING pId;
            status = STATUS_SUCCESS;

            switch (IrpStack->Parameters.QueryId.IdType) {
            case BusQueryDeviceID:
               pId = &DeviceData->DeviceIDs;
               break;

            case BusQueryHardwareIDs:
               pId = &DeviceData->HardwareIDs;
               break;

            case BusQueryCompatibleIDs:
               pId = &DeviceData->CompIDs;
               break;

            case BusQueryInstanceID:
            // Build an instance ID.  This is what PnP uses to tell if it has
            // seen this thing before or not.  Build it from the first hardware
            // id and the port number.
               pId = &DeviceData->InstanceIDs;
               break;
            }

            buffer = pId->Buffer;

            if (buffer != NULL) {
               // FANNY CHANGED
               //length = pId->Length;
               length = pId->MaximumLength;
               returnBuffer = ExAllocatePool(PagedPool, length);
               if (returnBuffer != NULL) {
#if DBG
                  RtlFillMemory(returnBuffer, length, 0xff);
#endif
                  // FANNY CHANGED
                  //RtlCopyMemory(returnBuffer, buffer, pId->Length);
                  RtlCopyMemory(returnBuffer, buffer, length);
               } else {
                  status = STATUS_INSUFFICIENT_RESOURCES;
               }
            } else {
               // FANNY ADDED
               status = STATUS_NOT_FOUND;
            }

            Cyclomy_KdPrint(DeviceData, SER_DBG_PNP_TRACE,
                            ("ID: Unicode 0x%x\n", pId));
            Cyclomy_KdPrint(DeviceData, SER_DBG_PNP_TRACE,
                            ("ID: buf 0x%x\n", returnBuffer));

            Irp->IoStatus.Information = (ULONG_PTR)returnBuffer;
         }
         break;

      }
      break;

      case IRP_MN_QUERY_BUS_INFORMATION: {
       PPNP_BUS_INFORMATION pBusInfo;
       PFDO_DEVICE_DATA parentExtension;
       parentExtension = (DeviceData->ParentFdo)->DeviceExtension;

       ASSERTMSG("Cyclomy appears not to be the sole bus?!?",
                 Irp->IoStatus.Information == (ULONG_PTR)NULL);

       pBusInfo = ExAllocatePool(PagedPool, sizeof(PNP_BUS_INFORMATION));

       if (pBusInfo == NULL) {
          status = STATUS_INSUFFICIENT_RESOURCES;
          break;
       }

       pBusInfo->BusTypeGuid = GUID_BUS_TYPE_CYCLOMY;
       if (parentExtension->IsPci) {
         pBusInfo->LegacyBusType = PCIBus;
       } else {
         pBusInfo->LegacyBusType = Isa;
       }

       //
       // We really can't track our bus number since we can be torn
       // down with our bus
       //

       //pBusInfo->BusNumber = 0;
       pBusInfo->BusNumber = parentExtension->UINumber;

       Irp->IoStatus.Information = (ULONG_PTR)pBusInfo;
       status = STATUS_SUCCESS;
       break;
       }

   case IRP_MN_QUERY_DEVICE_RELATIONS:
      Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_TRACE, 
                    ("\tQueryDeviceRelation Type: %d\n", 
                    IrpStack->Parameters.QueryDeviceRelations.Type));

      switch (IrpStack->Parameters.QueryDeviceRelations.Type) {
      case TargetDeviceRelation: {
         PDEVICE_RELATIONS pDevRel;

         //
         // No one else should respond to this since we are the PDO
         //

         ASSERT(Irp->IoStatus.Information == 0);

         if (Irp->IoStatus.Information != 0) {
            break;
         }


         pDevRel = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));

         if (pDevRel == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
         }

         pDevRel->Count = 1;
         pDevRel->Objects[0] = DeviceObject;
         ObReferenceObject(DeviceObject);

         status = STATUS_SUCCESS;
         Irp->IoStatus.Information = (ULONG_PTR)pDevRel;
         break;
      }


      default:
         break;
      }

      break;

   case IRP_MN_START_DEVICE:

      //
      // Set the hw resources in the registry for this device.
      //

      status = IoOpenDeviceRegistryKey(DeviceObject, PLUGPLAY_REGKEY_DEVICE,
                                       STANDARD_RIGHTS_WRITE, &keyHandle);

      if (!NT_SUCCESS(status)) {
         //
         // This is a fatal error.  If we can't get to our registry key,
         // we are sunk.
         //
         Cyclomy_KdPrint(DeviceData, SER_DBG_SS_ERROR,
                          ("IoOpenDeviceRegistryKey failed - %x\n", status));
      } else {

         ULONG portIndex;
         PFDO_DEVICE_DATA parentExtension;

         // Set the Port Index in the Registry
         
         RtlInitUnicodeString(&keyName, L"PortIndex");

         portIndex = DeviceData->PortIndex;

         //
         // Doesn't matter whether this works or not.
         //

         ZwSetValueKey(keyHandle, &keyName, 0, REG_DWORD, &portIndex,
                       sizeof(ULONG));

         parentExtension = (DeviceData->ParentFdo)->DeviceExtension;

         RtlInitUnicodeString(&keyName, L"PortResources");

         status = ZwSetValueKey(keyHandle, &keyName, 0, REG_RESOURCE_LIST, 
                       parentExtension->PChildResourceList,
                       parentExtension->PChildResourceListSize);

         RtlInitUnicodeString(&keyName, L"PortResourcesTr");

         status = ZwSetValueKey(keyHandle, &keyName, 0, REG_RESOURCE_LIST, 
                       parentExtension->PChildResourceListTr,
                       parentExtension->PChildResourceListSizeTr);
         
         ZwFlushKey(keyHandle);
         ZwClose(keyHandle);
      }

      SET_NEW_PNP_STATE(DeviceData, Started);
      status = STATUS_SUCCESS;
      break;

   case IRP_MN_QUERY_STOP_DEVICE:

      //
      // No reason here why we can't stop the device.
      // If there were a reason we should speak now for answering success
      // here may result in a stop device irp.
      //

      SET_NEW_PNP_STATE(DeviceData, StopPending);
      status = STATUS_SUCCESS;
      break;

   case IRP_MN_CANCEL_STOP_DEVICE:
      //
      // The stop was canceled.  Whatever state we set, or resources we put
      // on hold in anticipation of the forcoming STOP device IRP should be
      // put back to normal.  Someone, in the long list of concerned parties,
      // has failed the stop device query.
      //

      //
      // First check to see whether you have received cancel-stop
      // without first receiving a query-stop. This could happen if someone
      // above us fails a query-stop and passes down the subsequent
      // cancel-stop.
      //
        
      if(StopPending == DeviceData->DevicePnPState)
      {
          //
          // We did receive a query-stop, so restore.
          //             
          RESTORE_PREVIOUS_PNP_STATE(DeviceData);
      }
      status = STATUS_SUCCESS;
      break;

   case IRP_MN_STOP_DEVICE:

      //
      // Here we shut down the device.  The opposite of start.
      //

      SET_NEW_PNP_STATE(DeviceData, Stopped);
      status = STATUS_SUCCESS;
      break;

   case IRP_MN_QUERY_REMOVE_DEVICE:
      //
      // Just like Query Stop only now the impending doom is the remove irp
      //
      SET_NEW_PNP_STATE(DeviceData, RemovePending);
      status = STATUS_SUCCESS;
      break;

   case IRP_MN_CANCEL_REMOVE_DEVICE:
      //
      // Clean up a remove that did not go through, just like cancel STOP.
      //

      //
      // First check to see whether you have received cancel-remove
      // without first receiving a query-remove. This could happen if 
      // someone above us fails a query-remove and passes down the 
      // subsequent cancel-remove.
      //
       
      if(RemovePending == DeviceData->DevicePnPState)
      {
          //
          // We did receive a query-remove, so restore.
          //             
          RESTORE_PREVIOUS_PNP_STATE(DeviceData);
      }
      status = STATUS_SUCCESS;
      break;

   case IRP_MN_SURPRISE_REMOVAL:

        //
        // We should stop all access to the device and relinquish all the
        // resources. Let's just mark that it happened and we will do 
        // the cleanup later in IRP_MN_REMOVE_DEVICE.
        //

        SET_NEW_PNP_STATE(DeviceData, SurpriseRemovePending);
        status = STATUS_SUCCESS;
        break;

   case IRP_MN_REMOVE_DEVICE:

      //
      // Attached is only set to FALSE by the enumeration process.
      //
      if (!DeviceData->Attached) {

          SET_NEW_PNP_STATE(DeviceData, Deleted);
          status = Cyclomy_PnPRemove(DeviceObject, DeviceData);
      }
      else {    // else added in build 2128 - Fanny
          //
          // Succeed the remove
          ///
          SET_NEW_PNP_STATE(DeviceData, NotStarted);
          status = STATUS_SUCCESS;
      }

// Changed in build 2072
//      status = STATUS_SUCCESS;

      break;

   case IRP_MN_QUERY_RESOURCES: {
#if 0
      PCM_RESOURCE_LIST pChildRes, pQueryRes;
      PFDO_DEVICE_DATA parentExtension;
      ULONG listSize;

      parentExtension = (DeviceData->ParentFdo)->DeviceExtension;
      pChildRes = parentExtension->PChildResourceList;
      listSize = parentExtension->PChildResourceListSize;

      if (pChildRes) {
         pQueryRes = ExAllocatePool(PagedPool, listSize);
         if (pQueryRes == NULL) {
            Irp->IoStatus.Information = (ULONG_PTR) NULL;
            status = STATUS_INSUFFICIENT_RESOURCES;
         } else {
            RtlCopyMemory(pQueryRes,pChildRes,listSize);
            Irp->IoStatus.Information = (ULONG_PTR)pQueryRes;
            status = STATUS_SUCCESS;
         }
      }
#endif
      break;

   }

   case IRP_MN_QUERY_RESOURCE_REQUIREMENTS: {
#if 0      
      PIO_RESOURCE_REQUIREMENTS_LIST pChildReq, pQueryReq;
      PFDO_DEVICE_DATA parentExtension;

      parentExtension = (DeviceData->ParentFdo)->DeviceExtension;
      pChildReq = parentExtension->PChildRequiredList;
      if (pChildReq) {
         pQueryReq = ExAllocatePool(PagedPool, pChildReq->ListSize);
         if (pQueryReq == NULL) {
            Irp->IoStatus.Information = (ULONG_PTR) NULL;
            status = STATUS_INSUFFICIENT_RESOURCES;
         } else {
            RtlCopyMemory(pQueryReq,pChildReq,pChildReq->ListSize);
            Irp->IoStatus.Information = (ULONG_PTR)pQueryReq;
            status = STATUS_SUCCESS;
         }
      }
#endif
      break;
   }

   case IRP_MN_READ_CONFIG:
   case IRP_MN_WRITE_CONFIG: // we have no config space
   case IRP_MN_EJECT:
   case IRP_MN_SET_LOCK:
   case IRP_MN_QUERY_INTERFACE: // We do not have any non IRP based interfaces.
   default:
      Cyclomy_KdPrint(DeviceData, SER_DBG_PNP_TRACE, 
                 ("PDO(%x):%s not handled\n", DeviceObject,
                        PnPMinorFunctionString(IrpStack->MinorFunction)));

      // For PnP requests to the PDO that we do not understand we should
      // return the IRP WITHOUT setting the status or information fields.
      // They may have already been set by a filter (eg acpi).
      break;
   }

   Irp->IoStatus.Status = status;
   IoCompleteRequest (Irp, IO_NO_INCREMENT);

   return status;
}

NTSTATUS
Cyclomy_PnPRemove (PDEVICE_OBJECT Device, PPDO_DEVICE_DATA PdoData)
/*++
Routine Description:
    The PlugPlay subsystem has instructed that this PDO should be removed.

    We should therefore
    - Complete any requests queued in the driver
    - If the device is still attached to the system,
      then complete the request and return.
    - Otherwise, cleanup device specific allocations, memory, events...
    - Call IoDeleteDevice
    - Return from the dispatch routine.

    Note that if the device is still connected to the bus (IE in this case
    the control panel has not yet told us that the serial device has
    disappeared) then the PDO must remain around, and must be returned during
    any query Device relaions IRPS.

--*/

{
   Cyclomy_KdPrint(PdoData, SER_DBG_PNP_TRACE,
                        ("Cyclomy_PnPRemove: 0x%x\n", Device));
    //
    // Complete any outstanding requests with STATUS_DELETE_PENDING.
    //
    // Serenum does not queue any irps at this time so we have nothing to do.
    //

    //REMOVED BY FANNY. THIS CHECK IS ALREADY DONE AT IRP_MN_REMOVE_DEVICE PDO.
    //if (PdoData->Attached) {
    //    return STATUS_SUCCESS;
    //}
    //PdoData->Removed = TRUE;
    
    //
    // Free any resources.
    //

    CyclomyFreeUnicodeString(&PdoData->HardwareIDs);
    //CyclomyFreeUnicodeString(&PdoData->CompIDs); We never allocate CompIDs.
    RtlFreeUnicodeString(&PdoData->DeviceIDs);
    RtlFreeUnicodeString(&PdoData->InstanceIDs);
    RtlFreeUnicodeString(&PdoData->DevDesc);

    Cyclomy_KdPrint(PdoData, SER_DBG_PNP_INFO,
                        ("IoDeleteDevice: 0x%x\n", Device));

    IoDeleteDevice(Device);


    return STATUS_SUCCESS;
}


NTSTATUS
Cyclomy_GetResourceInfo(IN PDEVICE_OBJECT PDevObj,
                    IN PCM_RESOURCE_LIST PResList,
                    IN PCM_RESOURCE_LIST PTrResList)
/*++

Routine Description:

    This routine gets the resources that PnP allocated to this device.


Arguments:

   PDevObj    -  Pointer to the devobj that is starting

   PResList   -  Pointer to the untranslated resources needed by this device

   PTrResList -  Pointer to the translated resources needed by this device


  Return Value:

    STATUS_SUCCESS on success, something else appropriate on failure


--*/

{
   PFDO_DEVICE_DATA pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status = STATUS_SUCCESS;

   ULONG count;
   ULONG i;
   PCM_PARTIAL_RESOURCE_LIST pPartialResourceList, pPartialTrResourceList;
   PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartialResourceDesc, pPartialTrResourceDesc;
   PCM_FULL_RESOURCE_DESCRIPTOR pFullResourceDesc = NULL,
                                pFullTrResourceDesc = NULL;
   KAFFINITY Affinity;
   KINTERRUPT_MODE InterruptMode;
   ULONG zero = 0;
   
   PAGED_CODE();

   // Let's get our resources
   pFullResourceDesc   = &PResList->List[0];
   pFullTrResourceDesc = &PTrResList->List[0];

   if (pFullResourceDesc) {
      pPartialResourceList    = &pFullResourceDesc->PartialResourceList;
      pPartialResourceDesc    = pPartialResourceList->PartialDescriptors;
      count                   = pPartialResourceList->Count;

      pDevExt->InterfaceType  = pFullResourceDesc->InterfaceType;
      pDevExt->BusNumber      = pFullResourceDesc->BusNumber;

      for (i = 0;     i < count;     i++, pPartialResourceDesc++) {

         switch (pPartialResourceDesc->Type) {
         case CmResourceTypeMemory: {

            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("CmResourceTypeMemory\n"));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Memory.Start = %x\n",
                                           pPartialResourceDesc->u.Memory.Start));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Memory.Length = %x\n",
                                           pPartialResourceDesc->u.Memory.Length));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Flags = %x\n",
                                           pPartialResourceDesc->Flags));
            
            if (pPartialResourceDesc->u.Memory.Length == CYY_RUNTIME_LENGTH) {
               pDevExt->PhysicalRuntime = pPartialResourceDesc->u.Memory.Start;
               pDevExt->RuntimeLength = pPartialResourceDesc->u.Memory.Length;
            } else {
               pDevExt->PhysicalBoardMemory = pPartialResourceDesc->u.Memory.Start;
               pDevExt->BoardMemoryLength = pPartialResourceDesc->u.Memory.Length;
            }
            break;
         }
         case CmResourceTypePort: {

            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("CmResourceTypePort\n"));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Port.Start = %x\n",
                                           pPartialResourceDesc->u.Port.Start));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Port.Length = %x\n",
                                           pPartialResourceDesc->u.Port.Length));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Flags = %x\n",
                                           pPartialResourceDesc->Flags));

            break;
         }

         case CmResourceTypeInterrupt: {

            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("CmResourceTypeInterrupt\n"));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Interrupt.Level = %x\n",
                                           pPartialResourceDesc->u.Interrupt.Level));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Interrupt.Vector = %x\n",
                                           pPartialResourceDesc->u.Interrupt.Vector));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Interrupt.Affinity = %x\n",
                                           pPartialResourceDesc->u.Interrupt.Affinity));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("Flags = %x\n",
                                           pPartialResourceDesc->Flags));

            pDevExt->OriginalIrql = pPartialResourceDesc->u.Interrupt.Level;
            pDevExt->OriginalVector =pPartialResourceDesc->u.Interrupt.Vector;
            Affinity = pPartialResourceDesc->u.Interrupt.Affinity;

            if (pPartialResourceDesc->Flags & CM_RESOURCE_INTERRUPT_LATCHED) {
               InterruptMode = Latched;
            } else {
               InterruptMode = LevelSensitive;
            }

            break;
         }

         case CmResourceTypeDeviceSpecific: {
            PCM_SERIAL_DEVICE_DATA sDeviceData;

            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("CmResourceTypeDeviceSpecific\n"));

            break;
         }


         default: {
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("CmResourceType = %x\n",
                                                      pPartialResourceDesc->Type));
            break;
         }
         }   // switch (pPartialResourceDesc->Type)
      }       // for (i = 0;     i < count;     i++, pPartialResourceDesc++)
   }           // if (pFullResourceDesc)



//SEE_LATER_IF_IT_SHOULD_BE_ADDED
//   //
//   // Do the same for the translated resources
//   //
//
//   gotInt = 0;
//   gotISR = 0;
//   gotIO = 0;
//   curIoIndex = 0;
//
   if (pFullTrResourceDesc) {
      pPartialTrResourceList = &pFullTrResourceDesc->PartialResourceList;
      pPartialTrResourceDesc = pPartialTrResourceList->PartialDescriptors;
      count = pPartialTrResourceList->Count;

      //
      // Reload PConfig with the translated values for later use
      //

      pDevExt->InterfaceType  = pFullTrResourceDesc->InterfaceType;
      pDevExt->BusNumber      = pFullTrResourceDesc->BusNumber;

//FANNY
//      pDevExt->TrInterruptStatus = SerialPhysicalZero;

      for (i = 0;     i < count;     i++, pPartialTrResourceDesc++) {

         switch (pPartialTrResourceDesc->Type) {
         case CmResourceTypeMemory: {

            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("CmResourceTypeMemory translated\n"));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Memory.Start = %x\n",
                                           pPartialTrResourceDesc->u.Memory.Start));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Memory.Length = %x\n",
                                           pPartialTrResourceDesc->u.Memory.Length));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Flags = %x\n",
                                           pPartialTrResourceDesc->Flags));

            if (pPartialTrResourceDesc->u.Memory.Length == CYY_RUNTIME_LENGTH) {
               pDevExt->TranslatedRuntime = pPartialTrResourceDesc->u.Memory.Start;
               pDevExt->RuntimeLength = pPartialTrResourceDesc->u.Memory.Length;
            } else {
               pDevExt->TranslatedBoardMemory = pPartialTrResourceDesc->u.Memory.Start;
               pDevExt->BoardMemoryLength = pPartialTrResourceDesc->u.Memory.Length;
            }
            break;
         }
         case CmResourceTypePort: {

            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("CmResourceTypePort translated\n"));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Port.Start = %x\n",
                                           pPartialTrResourceDesc->u.Port.Start));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Port.Length = %x\n",
                                           pPartialTrResourceDesc->u.Port.Length));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Flags = %x\n",
                                           pPartialTrResourceDesc->Flags));

            break;
         }

         case CmResourceTypeInterrupt: {

            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("CmResourceTypeInterrupt translated\n"));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Interrupt.Level = %x\n",
                                           pPartialTrResourceDesc->u.Interrupt.Level));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Interrupt.Vector = %x\n",
                                           pPartialTrResourceDesc->u.Interrupt.Vector));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Interrupt.Affinity = %x\n",
                                           pPartialTrResourceDesc->u.Interrupt.Affinity));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("Flags = %x\n",
                                           pPartialTrResourceDesc->Flags));

            pDevExt->Vector = pPartialTrResourceDesc->u.Interrupt.Vector;
            pDevExt->Irql = (KIRQL) pPartialTrResourceDesc->u.Interrupt.Level;
            Affinity = pPartialTrResourceDesc->u.Interrupt.Affinity;

            break;
         }

         default: {
               break;
         }
         }   // switch (pPartialTrResourceDesc->Type)
      }       // for (i = 0;     i < count;     i++, pPartialTrResourceDesc++)
   }           // if (pFullTrResourceDesc)


   //
   // Do some error checking on the configuration info we have.
   //
   // Make sure that the interrupt is non zero (which we defaulted
   // it to).
   //
   // Make sure that the portaddress is non zero (which we defaulted
   // it to).
   //
   // Make sure that the DosDevices is not NULL (which we defaulted
   // it to).
   //
   // We need to make sure that if an interrupt status
   // was specified, that a port index was also specfied,
   // and if so that the port index is <= maximum ports
   // on a board.
   //
   // We should also validate that the bus type and number
   // are correct.
   //
   // We will also validate that the interrupt mode makes
   // sense for the bus.
   //

   if (!pDevExt->TranslatedRuntime.LowPart && pDevExt->IsPci) {

      CyyLogError(
                    pDevExt->DriverObject,
                    NULL,
                    pDevExt->PhysicalBoardMemory,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    0,
                    STATUS_SUCCESS,
                    CYY_INVALID_RUNTIME_REGISTERS,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      Cyclomy_KdPrint (pDevExt,SER_DBG_CYCLADES,
                  ("Bogus PLX address %x\n",
                   pDevExt->TranslatedRuntime.LowPart));

      status = STATUS_INSUFFICIENT_RESOURCES;
      goto GetResourceInfo_Cleanup;
   }


   if (!pDevExt->TranslatedBoardMemory.LowPart) {

      CyyLogError(
                    pDevExt->DriverObject,
                    NULL,
                    pDevExt->PhysicalBoardMemory,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    0,
                    STATUS_SUCCESS,
                    CYY_INVALID_BOARD_MEMORY,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      Cyclomy_KdPrint (pDevExt,SER_DBG_CYCLADES,
                  ("Bogus TranslatedBoardMemory address %x\n",
                   pDevExt->TranslatedBoardMemory.LowPart));

      status = STATUS_INSUFFICIENT_RESOURCES;
      goto GetResourceInfo_Cleanup;
   }


   if (!pDevExt->OriginalVector) {

      CyyLogError(
                    pDevExt->DriverObject,
                    NULL,
                    pDevExt->PhysicalBoardMemory,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    0,
                    STATUS_SUCCESS,
                    CYY_INVALID_INTERRUPT,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      Cyclomy_KdPrint (pDevExt,SER_DBG_CYCLADES,("Bogus vector %x\n",
                             pDevExt->OriginalVector));

      status = STATUS_INSUFFICIENT_RESOURCES;
      goto GetResourceInfo_Cleanup;
   }


   //
   // We don't want to cause the hal to have a bad day,
   // so let's check the interface type and bus number.
   //
   // We only need to check the registry if they aren't
   // equal to the defaults.
   //

   if (pDevExt->BusNumber != 0) {

      BOOLEAN foundIt = 0;

      if (pDevExt->InterfaceType >= MaximumInterfaceType) {

         CyyLogError(
                       pDevExt->DriverObject,
                       NULL,
                       pDevExt->PhysicalBoardMemory,
                       CyyPhysicalZero,
                       0,
                       0,
                       0,
                       pDevExt->InterfaceType,
                       STATUS_SUCCESS,
                       CYY_UNKNOWN_BUS,
                       0,
                       NULL,
                       0,
                       NULL
                       );
         Cyclomy_KdPrint (pDevExt,SER_DBG_CYCLADES,
                  ("Invalid Bus type %x\n", pDevExt->BusNumber));

         //status = SERIAL_UNKNOWN_BUS;
         status = STATUS_INSUFFICIENT_RESOURCES;
         goto GetResourceInfo_Cleanup;
      }    

      IoQueryDeviceDescription(
                              (INTERFACE_TYPE *)&pDevExt->InterfaceType,
                              &zero,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              Cyclomy_ItemCallBack,
                              &foundIt
                              );

      if (!foundIt) {

         CyyLogError(
                       pDevExt->DriverObject,
                       NULL,
                       pDevExt->PhysicalBoardMemory,
                       CyyPhysicalZero,
                       0,
                       0,
                       0,
                       pDevExt->InterfaceType,
                       STATUS_SUCCESS,
                       CYY_BUS_NOT_PRESENT,
                       0,
                       NULL,
                       0,
                       NULL
                       );
         Cyclomy_KdPrint(
                   pDevExt,
                   SER_DBG_CYCLADES,
                   ("There aren't that many of those\n"
                    "------- busses on this system,%x\n",
                    pDevExt->BusNumber)
                   );

         //status = SERIAL_BUS_NOT_PRESENT;
         status = STATUS_INSUFFICIENT_RESOURCES;
         goto GetResourceInfo_Cleanup;
      }
   }


   //
   // Dump out the board configuration.
   //

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES, ("PhysicalRuntime: %x\n",
                          pDevExt->PhysicalRuntime.LowPart));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES, ("TranslatedRuntime: %x\n",
                          pDevExt->TranslatedRuntime.LowPart));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES, ("RuntimeLength: %x\n",
                          pDevExt->RuntimeLength));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES, ("PhysicalBoardMemory: %x\n",
                          pDevExt->PhysicalBoardMemory.LowPart));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES, ("TranslatedBoardMemory: %x\n",
                          pDevExt->TranslatedBoardMemory.LowPart));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES, ("BoardMemoryLength: %x\n",
                          pDevExt->BoardMemoryLength));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("OriginalIrql = %x\n",
                          pDevExt->OriginalIrql));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("OriginalVector = %x\n",
                          pDevExt->OriginalVector));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("Irql = %x\n",
                          pDevExt->Irql));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("Vector = %x\n",
                          pDevExt->Vector));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("Affinity = %x\n",
                          Affinity));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("InterfaceType = %x\n",
                          pDevExt->InterfaceType));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("BusNumber = %x\n",
                          pDevExt->BusNumber));

   // ABOVE: COPIED FROM SerialGetPortInfo
   // ------------------------------------

   // BELOW: COPIED FROM SerialInitController
   if (pDevExt->IsPci) {
      pDevExt->Runtime = MmMapIoSpace(pDevExt->TranslatedRuntime,
                                      pDevExt->RuntimeLength,
                                      FALSE);

      if (!pDevExt->Runtime){

         CyyLogError(
                       pDevExt->DriverObject,
                       NULL,
                       pDevExt->PhysicalBoardMemory,
                       CyyPhysicalZero,
                       0,
                       0,
                       0,
                       0,
                       STATUS_SUCCESS,
                       CYY_RUNTIME_NOT_MAPPED,
                       0,
                       NULL,
                       0,
                       NULL
                       );
         Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("Could not map memory for PLX\n"));
         status = STATUS_NONE_MAPPED;
         goto GetResourceInfo_Cleanup;
      }
   }
   pDevExt->BoardMemory = MmMapIoSpace(pDevExt->TranslatedBoardMemory,
                                       pDevExt->BoardMemoryLength,
                                       FALSE);

   if (!pDevExt->BoardMemory){

      CyyLogError(
                    pDevExt->DriverObject,
                    NULL,
                    pDevExt->PhysicalBoardMemory,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    0,
                    STATUS_SUCCESS,
                    CYY_BOARD_NOT_MAPPED,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("Could not map memory for CD1400\n"));
      status = STATUS_NONE_MAPPED;
      goto GetResourceInfo_Cleanup;
   }


GetResourceInfo_Cleanup:
   if (!NT_SUCCESS(status)) {
      
      if (pDevExt->Runtime) {
         MmUnmapIoSpace(pDevExt->Runtime, pDevExt->RuntimeLength);
	      pDevExt->Runtime = NULL;
      }

      if (pDevExt->BoardMemory) {
         MmUnmapIoSpace(pDevExt->BoardMemory, pDevExt->BoardMemoryLength);
 		   pDevExt->BoardMemory = NULL;
      }
   }

   Cyclomy_KdPrint (pDevExt,SER_DBG_CYCLADES, ("leaving Cyclomy_GetResourceInfo\n"));
   return status;
}

VOID
Cyclomy_ReleaseResources(IN PFDO_DEVICE_DATA PDevExt)
{   
   Cyclomy_KdPrint (PDevExt,SER_DBG_CYCLADES, ("entering Cyclomy_ReleaseResources\n"));

   if (PDevExt->PChildRequiredList) {
      ExFreePool(PDevExt->PChildRequiredList);
      PDevExt->PChildRequiredList = NULL;
   }

   if (PDevExt->PChildResourceList) {
      ExFreePool(PDevExt->PChildResourceList);
      PDevExt->PChildResourceList = NULL;
   }

   if (PDevExt->PChildResourceListTr) {
      ExFreePool(PDevExt->PChildResourceListTr);
      PDevExt->PChildResourceListTr = NULL;
   }

   if (PDevExt->Runtime) {
      MmUnmapIoSpace(PDevExt->Runtime, PDevExt->RuntimeLength);
      PDevExt->Runtime = NULL;
   }

   if (PDevExt->BoardMemory) {
      MmUnmapIoSpace(PDevExt->BoardMemory, PDevExt->BoardMemoryLength);
      PDevExt->BoardMemory = NULL;
   }
   Cyclomy_KdPrint (PDevExt,SER_DBG_CYCLADES, ("leaving Cyclomy_ReleaseResources\n"));   
}


NTSTATUS
Cyclomy_ItemCallBack(
                  IN PVOID Context,
                  IN PUNICODE_STRING PathName,
                  IN INTERFACE_TYPE BusType,
                  IN ULONG BusNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
                  IN CONFIGURATION_TYPE ControllerType,
                  IN ULONG ControllerNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
                  IN CONFIGURATION_TYPE PeripheralType,
                  IN ULONG PeripheralNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
                  )

/*++

Routine Description:

    This routine is called to check if a particular item
    is present in the registry.

Arguments:

    Context - Pointer to a boolean.

    PathName - unicode registry path.  Not Used.

    BusType - Internal, Isa, ...

    BusNumber - Which bus if we are on a multibus system.

    BusInformation - Configuration information about the bus. Not Used.

    ControllerType - Controller type.

    ControllerNumber - Which controller if there is more than one
                       controller in the system.

    ControllerInformation - Array of pointers to the three pieces of
                            registry information.

    PeripheralType - Should be a peripheral.

    PeripheralNumber - Which peripheral - not used..

    PeripheralInformation - Configuration information. Not Used.

Return Value:

    STATUS_SUCCESS

--*/

{
   UNREFERENCED_PARAMETER (PathName);
   UNREFERENCED_PARAMETER (BusType);
   UNREFERENCED_PARAMETER (BusNumber);
   UNREFERENCED_PARAMETER (BusInformation);
   UNREFERENCED_PARAMETER (ControllerType);
   UNREFERENCED_PARAMETER (ControllerNumber);
   UNREFERENCED_PARAMETER (ControllerInformation);
   UNREFERENCED_PARAMETER (PeripheralType);
   UNREFERENCED_PARAMETER (PeripheralNumber);
   UNREFERENCED_PARAMETER (PeripheralInformation);

   PAGED_CODE();


   *((BOOLEAN *)Context) = TRUE;
   return STATUS_SUCCESS;
}


NTSTATUS
Cyclomy_BuildRequirementsList(
                          OUT PIO_RESOURCE_REQUIREMENTS_LIST *PChildRequiredList_Pointer,
                          IN PCM_RESOURCE_LIST PResourceList, IN ULONG NumberOfResources
                          )
{

   NTSTATUS status = STATUS_SUCCESS;
   ULONG count;
   ULONG i,j;   
   PCM_FULL_RESOURCE_DESCRIPTOR    pFullResourceDesc = NULL;
   PCM_PARTIAL_RESOURCE_LIST       pPartialResourceList;
   PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartialResourceDesc;

   ULONG requiredLength;
   PIO_RESOURCE_REQUIREMENTS_LIST requiredList;
   PIO_RESOURCE_LIST       requiredResList;
   PIO_RESOURCE_DESCRIPTOR requiredResDesc;

   *PChildRequiredList_Pointer = NULL;

   // Validate input parameter

   if (PResourceList == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto CyclomyBuildRequirementList_Error;
   }

   ASSERT(PResourceList->Count == 1);

   // Initialize requiredList

   requiredLength = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) 
                + sizeof(IO_RESOURCE_DESCRIPTOR) * (NumberOfResources - 1);
 
   requiredList = ExAllocatePool(PagedPool, requiredLength);
   
   if (requiredList == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto CyclomyBuildRequirementList_Error;
   }

   RtlZeroMemory(requiredList, requiredLength);

   // Get information from PResourceList and build requiredList

   pFullResourceDesc = &PResourceList->List[0];

   if (pFullResourceDesc) {
      pPartialResourceList = &pFullResourceDesc->PartialResourceList;
      pPartialResourceDesc = pPartialResourceList->PartialDescriptors;
      count                = pPartialResourceList->Count;

      if (count < NumberOfResources) {
         ExFreePool(requiredList);
         return STATUS_INSUFFICIENT_RESOURCES;
      }

      requiredList->ListSize = requiredLength;
      requiredList->InterfaceType = pFullResourceDesc->InterfaceType;
      requiredList->BusNumber     = pFullResourceDesc->BusNumber;
      requiredList->SlotNumber    = 0; //?????? There's no SlotNumber in the Resource List
      requiredList->AlternativeLists = 1;

      requiredResList = &requiredList->List[0];
      requiredResList->Count = NumberOfResources;

      requiredResDesc = &requiredResList->Descriptors[0];

      for (i=0,j=0; i<count && j<NumberOfResources;  i++,pPartialResourceDesc++) {
         
         switch (pPartialResourceDesc->Type) {
         case CmResourceTypeMemory: {
            requiredResDesc->Type = pPartialResourceDesc->Type;
            //requiredResDesc->ShareDisposition = pPartialResourceDesc->ShareDisposition;
            requiredResDesc->ShareDisposition = CmResourceShareShared;
            requiredResDesc->Flags = pPartialResourceDesc->Flags;
            requiredResDesc->u.Memory.Length = pPartialResourceDesc->u.Memory.Length;
            requiredResDesc->u.Memory.Alignment = 4;
            requiredResDesc->u.Memory.MinimumAddress = pPartialResourceDesc->u.Memory.Start;
            requiredResDesc->u.Memory.MaximumAddress.QuadPart 
                        = pPartialResourceDesc->u.Memory.Start.QuadPart 
                        + pPartialResourceDesc->u.Memory.Length - 1;
            requiredResDesc++;
            j++;
            break;
         }
         case CmResourceTypePort: {
            break;
         }
         case CmResourceTypeInterrupt: {
            requiredResDesc->Type = pPartialResourceDesc->Type;
            requiredResDesc->ShareDisposition = CmResourceShareShared;
            requiredResDesc->Flags = pPartialResourceDesc->Flags;
            requiredResDesc->u.Interrupt.MinimumVector 
                                             = pPartialResourceDesc->u.Interrupt.Vector;
            requiredResDesc->u.Interrupt.MaximumVector 
                                             = pPartialResourceDesc->u.Interrupt.Vector;
            requiredResDesc++;
            j++;
            break;
         }
         default: 
            break;
         } // end switch
         
      } // end for

   } // end if (pFullResourceDesc)

   *PChildRequiredList_Pointer = requiredList;


CyclomyBuildRequirementList_Error:
   return status;

}

NTSTATUS
Cyclomy_BuildResourceList(
                      OUT PCM_RESOURCE_LIST *POutList_Pointer,
                      OUT ULONG *ListSize_Pointer,
                      IN PCM_RESOURCE_LIST PInList,
                      IN ULONG NumberOfResources
                      )
{

   NTSTATUS status = STATUS_SUCCESS;
   ULONG i,j;
   PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartialInDesc;

   ULONG length;
   PCM_RESOURCE_LIST pOutList;
   PCM_PARTIAL_RESOURCE_DESCRIPTOR  pPartialOutDesc;

   *POutList_Pointer = NULL;
   *ListSize_Pointer =0;

   // Validate input parameter

   if (PInList == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto CyclomyBuildResourceList_Error;
   }

   ASSERT(PInList->Count == 1);


   if (PInList->List[0].PartialResourceList.Count < NumberOfResources) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto CyclomyBuildResourceList_Error;
   }
   
   // Initialize pOutList

   length = sizeof(CM_RESOURCE_LIST) 
            + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) * (NumberOfResources - 1);
 
   pOutList = ExAllocatePool(PagedPool, length);
   
   if (pOutList == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto CyclomyBuildResourceList_Error;
   }

   RtlZeroMemory(pOutList, length);
   
   // Get information from PInList and build pOutList

   pOutList->Count = 1; // not sure if we have to report Translated information too.
   pOutList->List[0].InterfaceType = PInList->List[0].InterfaceType;
   pOutList->List[0].BusNumber     = PInList->List[0].BusNumber;
   pOutList->List[0].PartialResourceList.Count = NumberOfResources;

   pPartialOutDesc = &pOutList->List[0].PartialResourceList.PartialDescriptors[0];
   pPartialInDesc  = &PInList->List[0].PartialResourceList.PartialDescriptors[0];

   for (i=0,j=0; i < PInList->List[0].PartialResourceList.Count; i++,pPartialInDesc++) {
      if (j==NumberOfResources) {
         break;
      }
      switch(pPartialInDesc->Type) {
      case CmResourceTypeMemory:
         pPartialOutDesc->ShareDisposition = CmResourceShareShared;
         pPartialOutDesc->Type             = pPartialInDesc->Type;
         pPartialOutDesc->Flags            = pPartialInDesc->Flags;
         pPartialOutDesc->u.Memory.Start   = pPartialInDesc->u.Memory.Start;
         pPartialOutDesc->u.Memory.Length  = pPartialInDesc->u.Memory.Length;
         pPartialOutDesc++;
         j++;
         break;
      case CmResourceTypeInterrupt:
         pPartialOutDesc->ShareDisposition = CmResourceShareShared;
         pPartialOutDesc->Type             = pPartialInDesc->Type;
         pPartialOutDesc->Flags            = pPartialInDesc->Flags;
         pPartialOutDesc->u.Interrupt.Level    = pPartialInDesc->u.Interrupt.Level;
         pPartialOutDesc->u.Interrupt.Vector   = pPartialInDesc->u.Interrupt.Vector;
         pPartialOutDesc->u.Interrupt.Affinity = pPartialInDesc->u.Interrupt.Affinity;
         pPartialOutDesc++;
         j++;
         break;
      default:
         break;
      } // end switch
   } // end for
   
   *POutList_Pointer = pOutList;
   *ListSize_Pointer = length;

CyclomyBuildResourceList_Error:
   return status;

}


VOID
Cyclomy_Delay(
	ULONG NumberOfMilliseconds
    )
/*--------------------------------------------------------------------------
    Cyclomy_Delay()
    
    Routine Description: Delay routine.
    
    Arguments:
    
    NumberOfMilliseconds - Number of milliseconds to be delayed.
    
    Return Value: none.
--------------------------------------------------------------------------*/
{
    LARGE_INTEGER startOfSpin, nextQuery, difference, delayTime;

    delayTime.QuadPart = NumberOfMilliseconds*10*1000; // unit is 100ns
    KeQueryTickCount(&startOfSpin);

    do {			
        KeQueryTickCount(&nextQuery);
        difference.QuadPart = nextQuery.QuadPart - startOfSpin.QuadPart;
        ASSERT(KeQueryTimeIncrement() <= MAXLONG);
        if (difference.QuadPart * KeQueryTimeIncrement() >= 
                                        delayTime.QuadPart) {
            break;															
        }
    } while (1);

}


ULONG
Cyclomy_DoesBoardExist(
                   IN PFDO_DEVICE_DATA Extension
                   )

/*++

Routine Description:

    This routine examines if the board is present.


Arguments:

    Extension - A pointer to a serial device extension.

Return Value:

    Will return number of ports.

--*/

{
   ULONG numPorts = 0;
   const ULONG CyyCDOffset[] = {	// CD1400 offsets within the board
   0x00000000,0x00000400,0x00000800,0x00000C00,
   0x00000200,0x00000600,0x00000A00,0x00000E00
   };
   ULONG i;
   UCHAR dataread;
   ULONG isPci = Extension->IsPci;

   // Reset the board
   CYY_RESET_BOARD(Extension->BoardMemory, isPci);
   Cyclomy_Delay(1);
   CYY_CLEAR_INTERRUPT(Extension->BoardMemory, isPci);
   Cyclomy_Delay(1);
   
   for (i=0; i < CYY_MAX_CHIPS; i++) {
      Extension->Cd1400Base[i] = Extension->BoardMemory +
                                  (CyyCDOffset[i] << isPci);      
   }

   // Clear all GFRCR's
   for (i=0; i < CYY_MAX_CHIPS; i++) {
      CD1400_WRITE(Extension->Cd1400Base[i],isPci,GFRCR,0x00);      
   }

   // Test CD1400 presence
   for (i=0; i < CYY_MAX_CHIPS; i++) {
      dataread = CD1400_READ(Extension->Cd1400Base[i],isPci,GFRCR);
      //**************************
      // Error Injection
      //dataread = 0xff;
      //**************************
      if (dataread != 0x00) {
         if (i==0) {
            CyyLogError(
                    Extension->DriverObject,
                    Extension->Self,
                    Extension->PhysicalBoardMemory,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    dataread,
                    STATUS_SUCCESS,
                    CYY_GFRCR_FAILURE,
                    0,
                    NULL,
                    0,
                    NULL
                    );
         }
         break;
      }

      dataread = CD1400_READ(Extension->Cd1400Base[i],isPci,CCR);
      //**************************
      // Error Injection
      //dataread = 0xff;
      //**************************
      if (dataread != 0) {
         if (i==0) {
            CyyLogError(
                    Extension->DriverObject,
                    Extension->Self,
                    Extension->PhysicalBoardMemory,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    dataread,
                    STATUS_SUCCESS,
                    CYY_CCR_FAILURE,
                    0,
                    NULL,
                    0,
                    NULL
                    );
         }
         break;
      }

      CD1400_WRITE(Extension->Cd1400Base[i],isPci,CCR,CCR_RESET_CD1400);
      Cyclomy_Delay(1); //KeDelayExecutionThread(KernelMode,FALSE,&d1ms);

      dataread = CD1400_READ(Extension->Cd1400Base[i],isPci,GFRCR);
      if (dataread == 0) {
         Cyclomy_Delay(1); //KeDelayExecutionThread(KernelMode,FALSE,&d1ms);
         dataread = CD1400_READ(Extension->Cd1400Base[i],isPci,GFRCR);
      }

      //**************************
      // Error Injection
      //dataread = 0x55;
      //**************************
      if ((dataread & 0xf0) != 0x40) {

        if (i==0) {
            CyyLogError(
                    Extension->DriverObject,
                    Extension->Self,
                    Extension->PhysicalBoardMemory,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    dataread,
                    STATUS_SUCCESS,
                    CYY_BAD_CD1400_REVISION,
                    0,
                    NULL,
                    0,
                    NULL
                    );
        }
        break;
      }

      // Configure channel 0 serial
      CD1400_WRITE(Extension->Cd1400Base[i],isPci,GCR,GCR_CH0_IS_SERIAL);

      // Configure internal clock to 1ms
      if (dataread > REV_G) {
         CD1400_WRITE(Extension->Cd1400Base[i],isPci,PPR,CLOCK_60_1MS);
      } else {
         CD1400_WRITE(Extension->Cd1400Base[i],isPci,PPR,CLOCK_25_1MS);
      }
   }
   
   numPorts = i*4;

   for (;i < CYY_MAX_CHIPS; i++) {
      Extension->Cd1400Base[i] = NULL;
   }

   return numPorts;

}

VOID
Cyclomy_EnableInterruptInPLX(
      IN PFDO_DEVICE_DATA PDevExt
      )
{
      // Enable PLX interrupts
      if (PDevExt->IsPci){

         UCHAR plx_ver;
         ULONG original;

         plx_ver = CYY_READ_PCI_TYPE(PDevExt->BoardMemory);
         plx_ver &= 0x0f;

         switch(plx_ver) {
         case CYY_PLX9050:
            original = PLX9050_READ_INTERRUPT_CONTROL(PDevExt->Runtime);
            PLX9050_WRITE_INTERRUPT_CONTROL(PDevExt->Runtime,
                                            original|PLX9050_INT_ENABLE);
            break;
         case CYY_PLX9060:
         case CYY_PLX9080:
         default:
            original = PLX9060_READ_INTERRUPT_CONTROL(PDevExt->Runtime);
            PLX9060_WRITE_INTERRUPT_CONTROL(PDevExt->Runtime,
                                            original|PLX9060_INT_ENABLE);
            break;				
         }
	    
      }

}

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
)
{
    switch (MinorFunction)
    {
        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE";
        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE";
        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE";
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE";
        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE";
        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE";
        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE";
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS";
        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE";
        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES";
        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES";
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";
        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT";
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";
        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG";
        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG";
        case IRP_MN_EJECT:
            return "IRP_MN_EJECT";
        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK";
        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID";
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE";
        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION";
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION";
        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL";
        case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
            return "IRP_MN_QUERY_LEGACY_BUS_INFORMATION";
        default:
            return "IRP_MN_?????";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyclom-y\log.h ===
/*--------------------------------------------------------------------------
*
*   Copyright (C) Cyclades Corporation, 1996-2000.
*   All rights reserved.
*
*   Cyclom-Y Enumerator Driver
*	
*   This file:      log.mc
*
*   Description:    Messages that goes to the eventlog.
*
*   Notes:          This code supports Windows 2000 and i386 processor.
*
*   Complies with Cyclades SW Coding Standard rev 1.3.
*
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/

#ifndef _CYYLOG_
#define _CYYLOG_

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SERIAL_ERROR_CODE       0x6
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: CYY_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Not enough resources were available for the driver.
//
#define CYY_INSUFFICIENT_RESOURCES       ((NTSTATUS)0xC0041000L)

//
// MessageId: CYY_BOARD_NOT_MAPPED
//
// MessageText:
//
//  The Board Memory could not be translated to something the memory management system could understand.
//
#define CYY_BOARD_NOT_MAPPED             ((NTSTATUS)0xC0041001L)

//
// MessageId: CYY_RUNTIME_NOT_MAPPED
//
// MessageText:
//
//  The Runtime Registers could not be translated to something the memory management system could understand.
//
#define CYY_RUNTIME_NOT_MAPPED           ((NTSTATUS)0xC0041002L)

//
// MessageId: CYY_INVALID_RUNTIME_REGISTERS
//
// MessageText:
//
//  Invalid Runtime Registers base address.
//
#define CYY_INVALID_RUNTIME_REGISTERS    ((NTSTATUS)0xC0041003L)

//
// MessageId: CYY_INVALID_BOARD_MEMORY
//
// MessageText:
//
//  Invalid Board Memory address.
//
#define CYY_INVALID_BOARD_MEMORY         ((NTSTATUS)0xC0041004L)

//
// MessageId: CYY_INVALID_INTERRUPT
//
// MessageText:
//
//  Invalid Interrupt Vector.
//
#define CYY_INVALID_INTERRUPT            ((NTSTATUS)0xC0041005L)

//
// MessageId: CYY_UNKNOWN_BUS
//
// MessageText:
//
//  The bus type is not recognizable.
//
#define CYY_UNKNOWN_BUS                  ((NTSTATUS)0xC0041006L)

//
// MessageId: CYY_BUS_NOT_PRESENT
//
// MessageText:
//
//  The bus type is not available on this computer.
//
#define CYY_BUS_NOT_PRESENT              ((NTSTATUS)0xC0041007L)

//
// MessageId: CYY_GFRCR_FAILURE
//
// MessageText:
//
//  CD1400 not present or failure to read GFRCR register.
//
#define CYY_GFRCR_FAILURE                ((NTSTATUS)0xC0041008L)

//
// MessageId: CYY_CCR_FAILURE
//
// MessageText:
//
//  Failure to read CCR register in the CD1400.
//
#define CYY_CCR_FAILURE                  ((NTSTATUS)0xC0041009L)

//
// MessageId: CYY_BAD_CD1400_REVISION
//
// MessageText:
//
//  Invalid CD1400 revision number.
//
#define CYY_BAD_CD1400_REVISION          ((NTSTATUS)0xC004100AL)

//
// MessageId: CYY_NO_HW_RESOURCES
//
// MessageText:
//
//  No hardware resources available.
//
#define CYY_NO_HW_RESOURCES              ((NTSTATUS)0xC004100BL)

//
// MessageId: CYY_DEVICE_CREATION_FAILURE
//
// MessageText:
//
//  IoCreateDevice failed.
//
#define CYY_DEVICE_CREATION_FAILURE      ((NTSTATUS)0xC004100CL)

//
// MessageId: CYY_REGISTER_INTERFACE_FAILURE
//
// MessageText:
//
//  IoRegisterDeviceInterface failed.
//
#define CYY_REGISTER_INTERFACE_FAILURE   ((NTSTATUS)0xC004100DL)

//
// MessageId: CYY_GET_BUS_TYPE_FAILURE
//
// MessageText:
//
//  IoGetDeviceProperty LegacyBusType failed.
//
#define CYY_GET_BUS_TYPE_FAILURE         ((NTSTATUS)0xC004100EL)

//
// MessageId: CYY_GET_UINUMBER_FAILURE
//
// MessageText:
//
//  IoGetDeviceProperty DevicePropertyUINumber failed.
//
#define CYY_GET_UINUMBER_FAILURE         ((NTSTATUS)0x8004100FL)

//
// MessageId: CYY_SET_INTERFACE_STATE_FAILURE
//
// MessageText:
//
//  IoSetDeviceInterfaceState failed.
//
#define CYY_SET_INTERFACE_STATE_FAILURE  ((NTSTATUS)0xC0041010L)


#endif /* _CYYLOG_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyclom-y\string.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Enumerator Driver
*	
*   This file:      string.c
*	
*   Description:    This module contains the functions used to parse 
*                   the PNP COM ID and save it in the appropriate 
*                   UNICODE STRINGS.  The main function that is called 
*                   is Cyclomy_ParseData.  All other functions are called
*                   by this main function.
*
*   Notes:			This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#include "pch.h"


#define MAX_DEVNODE_NAME        256 // Total size of Device ID

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, Cyclomy_InitMultiString)
#endif

NTSTATUS
Cyclomy_InitMultiString(PFDO_DEVICE_DATA FdoData, PUNICODE_STRING MultiString,
                        ...)
/*++

    This routine will take a null terminated list of ascii strings and combine
    them together to generate a unicode multi-string block

Arguments:

    MultiString - a unicode structure in which a multi-string will be built
    ...         - a null terminated list of narrow strings which will be
             combined together. This list must contain at least a
        trailing NULL

Return Value:

    NTSTATUS

--*/
{
   ANSI_STRING ansiString;
   NTSTATUS status;
   PCSTR rawString;
   PWSTR unicodeLocation;
   ULONG multiLength = 0;
   UNICODE_STRING unicodeString;
   va_list ap;
   ULONG i;

   PAGED_CODE();

#if !DBG
   UNREFERENCED_PARAMETER(FdoData);
#endif


   Cyclomy_KdPrint(FdoData, SER_DBG_SS_TRACE,
                   ("Entering Cyclomy_InitMultiString\n"));

   va_start(ap,MultiString);

   //
   // Make sure that we won't leak memory
   //

   ASSERT(MultiString->Buffer == NULL);

   rawString = va_arg(ap, PCSTR);

   while (rawString != NULL) {
      RtlInitAnsiString(&ansiString, rawString);
      multiLength += RtlAnsiStringToUnicodeSize(&(ansiString));
      rawString = va_arg(ap, PCSTR);
   }

   va_end( ap );

   if (multiLength == 0) {
      //
      // Done
      //
      RtlInitUnicodeString(MultiString, NULL);
      Cyclomy_KdPrint(FdoData, SER_DBG_SS_TRACE,
                      ("Leaving Cyclomy_InitMultiString (1)\n"));

      return STATUS_SUCCESS;
   }

   //
   // We need an extra null
   //
   multiLength += sizeof(WCHAR);

   MultiString->MaximumLength = (USHORT)multiLength;
   MultiString->Buffer = ExAllocatePool(PagedPool, multiLength);
   MultiString->Length = 0;

   if (MultiString->Buffer == NULL) {
      Cyclomy_KdPrint(FdoData, SER_DBG_SS_TRACE,
                      ("Leaving Cyclomy_InitMultiString (2)\n"));

      return STATUS_INSUFFICIENT_RESOURCES;
   }

   Cyclomy_KdPrint(FdoData, SER_DBG_SS_TRACE,
                   ("Allocated %lu bytes for buffer\n", multiLength));

#if DBG
   RtlFillMemory(MultiString->Buffer, multiLength, 0xff);
#endif

   unicodeString.Buffer = MultiString->Buffer;
   unicodeString.MaximumLength = (USHORT) multiLength;

   va_start(ap, MultiString);
   rawString = va_arg(ap, PCSTR);

   while (rawString != NULL) {

      RtlInitAnsiString(&ansiString,rawString);
      status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, FALSE);

      //
      // We don't allocate memory, so if something goes wrong here,
      // its the function that's at fault
      //
      ASSERT(NT_SUCCESS(status));

      //
      // Check for any commas and replace them with NULLs
      //

      ASSERT(unicodeString.Length % sizeof(WCHAR) == 0);

      for (i = 0; i < (unicodeString.Length / sizeof(WCHAR)); i++) {
         if (unicodeString.Buffer[i] == L'\x2C' ||
             unicodeString.Buffer[i] == L'\x0C' ) {
            unicodeString.Buffer[i] = L'\0';
         }
      }

      Cyclomy_KdPrint(FdoData, SER_DBG_SS_TRACE, ("unicode buffer: %ws\n",
                                                  unicodeString.Buffer));

      //
      // Move the buffers along
      //
      unicodeString.Buffer += ((unicodeString.Length / sizeof(WCHAR)) + 1);
      unicodeString.MaximumLength -= (unicodeString.Length + sizeof(WCHAR));
      unicodeString.Length = 0;

      //
      // Next
      //

      rawString = va_arg(ap, PCSTR);
   } // while

   va_end(ap);

   ASSERT(unicodeString.MaximumLength == sizeof(WCHAR));

   //
   // Stick the final null there
   //

   Cyclomy_KdPrint(FdoData, SER_DBG_SS_TRACE, ("unicode buffer last addr: "
                                               "%x\n", unicodeString.Buffer));

   unicodeString.Buffer[0] = L'\0';

   //
   // Include the nulls in the length of the string
   //

   MultiString->Length = (USHORT)multiLength;
   MultiString->MaximumLength = MultiString->Length;

   Cyclomy_KdPrint(FdoData, SER_DBG_SS_TRACE,
                   ("Leaving Cyclomy_InitMultiString (3)\n"));

   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyclom-y\power.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Enumerator Driver
*	
*   This file:      power.c
*	
*   Description:    This module contains contains the power calls
*                   for the cyclom-y bus driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP, 
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
//#pragma alloc_text (PAGE, Cyclomy_Power)
//#pragma alloc_text (PAGE, Cyclomy_FDO_Power)
//#pragma alloc_text (PAGE, Cyclomy_PDO_Power)
#endif


typedef struct _POWER_COMPLETION_CONTEXT {

    PDEVICE_OBJECT  DeviceObject;
    PIRP            SIrp;

} POWER_COMPLETION_CONTEXT, *PPOWER_COMPLETION_CONTEXT;


VOID
OnPowerRequestComplete(
    PDEVICE_OBJECT DeviceObject,
    UCHAR MinorFunction,
    POWER_STATE state,
    POWER_COMPLETION_CONTEXT* PowerContext,
    PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

   Completion routine for D-IRP.

Arguments:


Return Value:

   NT status code

--*/
{
    PFDO_DEVICE_DATA   fdoData = (PFDO_DEVICE_DATA) PowerContext->DeviceObject->DeviceExtension;
    PIRP        sIrp = PowerContext->SIrp;

    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (MinorFunction);
    UNREFERENCED_PARAMETER (state);

    Cyclomy_KdPrint(fdoData,SER_DBG_POWER_TRACE, (">OnPowerRequestComplete\n"));

    //
    // Here we copy the D-IRP status into the S-IRP
    //
    sIrp->IoStatus.Status = IoStatus->Status;

    //
    // Release the IRP
    //
    PoStartNextPowerIrp(sIrp);
    IoCompleteRequest(sIrp, IO_NO_INCREMENT);

    //
    // Cleanup
    //
    ExFreePool(PowerContext);
    Cyclomy_DecIoCount(fdoData);

    Cyclomy_KdPrint(fdoData,SER_DBG_POWER_TRACE, ("<OnPowerRequestComplete\n"));

}

NTSTATUS
Cyclomy_FDOSystemPowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++
--*/
{
    POWER_COMPLETION_CONTEXT* powerContext;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;
    PIO_STACK_LOCATION  stack;
    PFDO_DEVICE_DATA    data;
    NTSTATUS    status = Irp->IoStatus.Status;

    UNREFERENCED_PARAMETER (Context);

    data = (PFDO_DEVICE_DATA) DeviceObject->DeviceExtension;

    Cyclomy_KdPrint(data,SER_DBG_POWER_TRACE, (">SystemPowerComplete\n"));

    if (!NT_SUCCESS(status)) {

        PoStartNextPowerIrp(Irp);
        Cyclomy_DecIoCount (data);    
        Cyclomy_KdPrint(data,SER_DBG_POWER_TRACE, ("<SystemPowerComplete1\n"));
        return STATUS_SUCCESS;
    }

    stack = IoGetCurrentIrpStackLocation (Irp);
    powerState = stack->Parameters.Power.State;
                        
    switch (stack->Parameters.Power.State.SystemState) {
    case PowerSystemUnspecified:
        powerState.DeviceState = PowerDeviceUnspecified;
        break;

    case PowerSystemWorking:
        powerState.DeviceState = PowerDeviceD0;
        break;

    case PowerSystemSleeping1:
    case PowerSystemSleeping2:
    case PowerSystemSleeping3:
    case PowerSystemHibernate:
    case PowerSystemShutdown:
    case PowerSystemMaximum:
        powerState.DeviceState = PowerDeviceD3;
        break;

    default:
        powerState.DeviceState = PowerDeviceD3;
    }

    //
    // Send IRP to change device state
    //
    powerContext = (POWER_COMPLETION_CONTEXT*)
                ExAllocatePool(NonPagedPool, sizeof(POWER_COMPLETION_CONTEXT));

    if (!powerContext) {

        status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        powerContext->DeviceObject = DeviceObject;
        powerContext->SIrp = Irp;

        status = PoRequestPowerIrp(data->Self, IRP_MN_SET_POWER, powerState, OnPowerRequestComplete, 
                                   powerContext, NULL);
    }

    if (!NT_SUCCESS(status)) {

        Cyclomy_KdPrint(data,SER_DBG_POWER_TRACE, ("PoRequestPowerIrp %x\n",status));
        if (powerContext) {
            ExFreePool(powerContext);
        }

        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = status;
        //IoCompleteRequest(Irp, IO_NO_INCREMENT); Toaster has this line.
        Cyclomy_DecIoCount(data);
        Cyclomy_KdPrint(data,SER_DBG_POWER_TRACE, ("<2SystemPowerComplete\n"));
        return status;
    }

    Cyclomy_KdPrint(data,SER_DBG_POWER_TRACE, ("<3SystemPowerComplete\n"));
    return STATUS_MORE_PROCESSING_REQUIRED;

}

NTSTATUS
Cyclomy_FDOPowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++
--*/
{
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;
    PIO_STACK_LOCATION  stack;
    PFDO_DEVICE_DATA    data;
//    NTSTATUS            status = STATUS_SUCCESS;    Removed in build 2072

    UNREFERENCED_PARAMETER (Context);

    if (Irp->PendingReturned) {  
        IoMarkIrpPending(Irp);
    }

    data = (PFDO_DEVICE_DATA) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    Cyclomy_KdPrint(data,SER_DBG_POWER_TRACE, (">DevicePowerComplete\n"));

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        switch (powerType) {
        case DevicePowerState:
            //
            // Powering Up
            // 
            ASSERT (powerState.DeviceState < data->DeviceState);

            Cyclomy_DoesBoardExist(data); // To initialize CD1400
            
            Cyclomy_EnableInterruptInPLX(data); // Enable interrupt in the PLX

            data->DeviceState = powerState.DeviceState;

            PoSetPowerState (data->Self, powerType, powerState);

            break;

        default:
           break;
        }
        break;

    case IRP_MN_QUERY_POWER:

        ASSERT (IRP_MN_QUERY_POWER != stack->MinorFunction);
        break;

    default:
        //
        // Basically, this is ASSERT(0)
        //
        ASSERT (0xBADBAD == IRP_MN_QUERY_POWER);
        break;
    }


    PoStartNextPowerIrp (Irp);
    Cyclomy_DecIoCount (data);

    Cyclomy_KdPrint(data,SER_DBG_POWER_TRACE, ("<DevicePowerComplete\n"));
    //return status; Changed to below line in build 2072
    return STATUS_SUCCESS; // Continue completion...
}

NTSTATUS
Cyclomy_FDO_Power (
    PFDO_DEVICE_DATA    Data,
    PIRP                Irp
    )
/*++
--*/
{
    NTSTATUS            status;
    BOOLEAN             hookit = FALSE;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;
    PIO_STACK_LOCATION  stack;
    // ADDED FANNY
    ULONG               indexPDO;

    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    status = Cyclomy_IncIoCount (Data);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        PoStartNextPowerIrp (Irp);
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        //
        // If it hasn't started, we just pass it through
        //

        //if (Data->Started != TRUE) {    // Added in DDK final version
        //    status = Irp->IoStatus.Status = STATUS_SUCCESS;
        //    break;
        //}
        if (Data->DevicePnPState != Started) {   // Toaster Bus compares to == NotStarted
            status = Irp->IoStatus.Status = STATUS_SUCCESS;
            break;
        }

        Cyclomy_KdPrint(Data,
                     SER_DBG_PNP_TRACE,
                     ("Cyclomy-PnP Setting %s state to %d\n",
                      ((powerType == SystemPowerState) ?  "System" : "Device"),
                      powerState.SystemState));

        switch (powerType) {
        case DevicePowerState:

            Cyclomy_KdPrint(Data,SER_DBG_POWER_TRACE, ("SET_POWER Device %x\n",Irp));

            status = Irp->IoStatus.Status = STATUS_SUCCESS;

            if (Data->DeviceState < powerState.DeviceState) {
                //
                // Powering down
                //
                PoSetPowerState (Data->Self, powerType, powerState);
                Data->DeviceState = powerState.DeviceState;
            } else if (Data->DeviceState > powerState.DeviceState) {
                //
                // Powering Up
                //
                hookit = TRUE;
            }
            
            break;

        case SystemPowerState: 

            Cyclomy_KdPrint(Data,SER_DBG_POWER_TRACE, ("SET_POWER System %x\n",Irp));

            IoMarkIrpPending(Irp);
            IoCopyCurrentIrpStackLocationToNext(Irp);

            status = Cyclomy_IncIoCount (Data);
            ASSERT (STATUS_SUCCESS == status);
            IoSetCompletionRoutine (Irp,
                                    Cyclomy_FDOSystemPowerComplete,
                                    NULL,
                                    TRUE,
                                    TRUE,
                                    TRUE);

            PoCallDriver (Data->TopOfStack, Irp);
            Cyclomy_DecIoCount (Data);

            return STATUS_PENDING;
               
        }
        break;

    case IRP_MN_QUERY_POWER:
        status = Irp->IoStatus.Status = STATUS_SUCCESS;
        break;

    default:
        //
        // status should be STATUS_SUCCESS
        //
        break;
    }
    
    if (hookit) {
        IoMarkIrpPending(Irp);
        IoCopyCurrentIrpStackLocationToNext (Irp);

        status = Cyclomy_IncIoCount (Data);
        ASSERT (STATUS_SUCCESS == status);
        IoSetCompletionRoutine (Irp,
                                Cyclomy_FDOPowerComplete,
                                NULL,
                                TRUE,
                                TRUE,
                                TRUE);

        PoCallDriver (Data->TopOfStack, Irp);
        Cyclomy_KdPrint(Data,SER_DBG_POWER_TRACE, ("SET_POWER Device status %x\n",status));
        Cyclomy_DecIoCount (Data);
        return STATUS_PENDING;

    }
    
    PoStartNextPowerIrp (Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    status =  PoCallDriver (Data->TopOfStack, Irp);    
    Cyclomy_DecIoCount (Data);
    return status;

}

NTSTATUS
Cyclomy_PDO_Power (
    PPDO_DEVICE_DATA    PdoData,
    PIRP                Irp
    )
/*++
--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  stack;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;

    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        switch (powerType) {
        case DevicePowerState:
            if (PdoData->DeviceState > powerState.DeviceState) {
                //DbgPrint("Up\n");
                PoSetPowerState (PdoData->Self, powerType, powerState);
                PdoData->DeviceState = powerState.DeviceState;
            } else if (PdoData->DeviceState < powerState.DeviceState) {
                //
                // Powering down.
                //
                //DbgPrint("Down\n");
                PoSetPowerState (PdoData->Self, powerType, powerState);
                PdoData->DeviceState = powerState.DeviceState;
            }
            break;

        case SystemPowerState:
            //
            // Default to STATUS_SUCCESS
            //
            break;

        default:
            status = STATUS_NOT_IMPLEMENTED;
            break;
        }
        break;

    case IRP_MN_QUERY_POWER:
        //
        // Default to STATUS_SUCCESS
        //
        break;

    case IRP_MN_WAIT_WAKE:
    case IRP_MN_POWER_SEQUENCE:
        status = STATUS_NOT_IMPLEMENTED;
        break;

    default:
       status = Irp->IoStatus.Status;
    }

    Irp->IoStatus.Status = status;
    PoStartNextPowerIrp (Irp);
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
Cyclomy_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status;
    PCOMMON_DEVICE_DATA commonData;

    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IRP_MJ_POWER == irpStack->MajorFunction);

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;

    if (commonData->IsFDO) {
        status = 
            Cyclomy_FDO_Power ((PFDO_DEVICE_DATA) DeviceObject->DeviceExtension,
                Irp);
    } else {
        status = 
            Cyclomy_PDO_Power ((PPDO_DEVICE_DATA) DeviceObject->DeviceExtension,
                Irp);
    }

    return status;
}     


NTSTATUS
Cyclomy_GotoPowerState(IN PDEVICE_OBJECT PDevObj,
                   IN PFDO_DEVICE_DATA PDevExt,
                   IN DEVICE_POWER_STATE DevPowerState)
/*++

Routine Description:

    This routine causes the driver to request the stack go to a particular
    power state.

Arguments:

    PDevObj - Pointer to the device object for this device

    PDevExt - Pointer to the device extension we are working from

    DevPowerState - the power state we wish to go to

Return Value:

    The function value is the final status of the call


--*/
{
   KEVENT gotoPowEvent;
   NTSTATUS status;
   POWER_STATE powerState;

   UNREFERENCED_PARAMETER (PDevExt);   

   PAGED_CODE();

   Cyclomy_KdPrint(PDevExt,SER_DBG_CYCLADES, ("In Cyclomy_GotoPowerState\n"));

   powerState.DeviceState = DevPowerState;

   KeInitializeEvent(&gotoPowEvent, SynchronizationEvent, FALSE);

   status = PoRequestPowerIrp(PDevObj, IRP_MN_SET_POWER, powerState,
                              Cyclomy_SystemPowerCompletion, &gotoPowEvent,
                              NULL);

   if (status == STATUS_PENDING) {
      KeWaitForSingleObject(&gotoPowEvent, Executive, KernelMode, FALSE, NULL);
      status = STATUS_SUCCESS;
   }

#if DBG
   if (!NT_SUCCESS(status)) {
      Cyclomy_KdPrint(PDevExt,SER_DBG_CYCLADES, ("Cyclomy_GotoPowerState FAILED\n"));
   }
#endif

   Cyclomy_KdPrint(PDevExt,SER_DBG_CYCLADES, ("Leaving Cyclomy_GotoPowerState\n"));

   return status;
}



NTSTATUS
Cyclomy_SystemPowerCompletion(IN PDEVICE_OBJECT PDevObj, UCHAR MinorFunction,
                              IN POWER_STATE PowerState, IN PVOID Context,
                              PIO_STATUS_BLOCK IoStatus)
/*++

Routine Description:

    This routine is the completion routine for PoRequestPowerIrp calls
    in this module.

Arguments:

    PDevObj - Pointer to the device object the irp is completing for

    MinorFunction - IRP_MN_XXXX value requested

    PowerState - Power state request was made of

    Context - Event to set or NULL if no setting required

    IoStatus - Status block from request

Return Value:

    VOID


--*/
{

   UNREFERENCED_PARAMETER (PDevObj);   
   UNREFERENCED_PARAMETER (MinorFunction);
   UNREFERENCED_PARAMETER (PowerState);
   UNREFERENCED_PARAMETER (IoStatus);
   
   if (Context != NULL) {
      KeSetEvent((PKEVENT)Context, IO_NO_INCREMENT, 0);
   }

   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyycoins\cyfriend.c ===
/** FILE: cyfriend.c ********** Module Header ********************************
 *
 *
 *
 *  Copyright (C) 2000 Cyclades Corporation
 *
 *************************************************************************/

#include "cyyports.h"

//
//  For Cyyport
//
TCHAR y_szCyyPort[] = TEXT("Cyclom-Y Port ");
TCHAR y_szPortIndex[] = TEXT("PortIndex");



BOOL
ReplaceFriendlyName(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN PTCHAR           NewComName
)
{

    DEVINST         parentInst;
    HDEVINFO        parentInfo;
    SP_DEVINFO_DATA parentData;
    TCHAR           parentId[MAX_DEVICE_ID_LEN];
    TCHAR           charBuffer[MAX_PATH],
                    deviceDesc[LINE_LEN];
    HKEY            hDeviceKey;
    TCHAR           PortName[20];
    DWORD           PortNameSize,PortIndexSize,PortIndex;
    DWORD           dwErr;
    PTCHAR          comName = NULL;
    DWORD           portNumber = 0;

    //DbgOut(TEXT("ReplaceFriendlyName\n"));

    if((hDeviceKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                          DeviceInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DEV,
                                          KEY_READ)) == INVALID_HANDLE_VALUE) {
        DbgOut(TEXT("SetupDiOpenDevRegKey failed\n"));
        return FALSE;
    }

    PortNameSize = sizeof(PortName);
    dwErr = RegQueryValueEx(hDeviceKey,
                          m_szPortName,
                          NULL,
                          NULL,
                          (PBYTE)PortName,
                          &PortNameSize
                          );

    if (dwErr == ERROR_SUCCESS) {
    PortIndexSize = sizeof(PortIndex);
    dwErr = RegQueryValueEx(hDeviceKey,
                          y_szPortIndex,
                          NULL,
                          NULL,
                          (PBYTE)&PortIndex,
                          &PortIndexSize
                          );
    }

    RegCloseKey(hDeviceKey);

    if(dwErr != ERROR_SUCCESS) {
        DbgOut(TEXT("RegQueryValueEx failed\n"));
        return FALSE;
    }
    if (NewComName == NULL) {
        comName = PortName;
    } else {
        comName = NewComName;
    }
    if (comName == NULL) {
        DbgOut(TEXT("comName NULL\n"));
        return FALSE;
    }

    portNumber = PortIndex+1;

    if (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                          DeviceInfoData,
                                          SPDRP_DEVICEDESC,
                                          NULL,
                                          (PBYTE)deviceDesc,
                                          sizeof(deviceDesc),
                                          NULL)) {
        DbgOut(TEXT("Couldn't get Device Description\n"));
        return FALSE;
    }

    if (_tcsnicmp (deviceDesc,y_szCyyPort,_tcslen(y_szCyyPort)) != 0){
        DbgOut(TEXT("Device Description is different of Cyclom-Y Port \n"));
        return FALSE;
    }
    
    if (portNumber == 0) {
        DbgOut(TEXT("Invalid portNumber\n"));
        return FALSE;
    }

    if (CM_Get_Parent(&parentInst,DeviceInfoData->DevInst,0) != CR_SUCCESS) {
        DbgOut(TEXT("CM_Get_Parent failed.\n"));
        return FALSE;
    }

    if (CM_Get_Device_ID(parentInst,parentId,CharSizeOf(parentId),0) != CR_SUCCESS) {
        DbgOut(TEXT("CM_Get_Device_ID failed.\n"));
        return FALSE;
    }

    parentInfo = SetupDiCreateDeviceInfoList(NULL,NULL);

    if (parentInfo == INVALID_HANDLE_VALUE) {
        DbgOut(TEXT("SetupDiCreateDeviceInfoList failed\n"));
        return FALSE;
    }
    
    parentData.cbSize = sizeof(SP_DEVINFO_DATA);

    if (SetupDiOpenDeviceInfo(parentInfo,parentId,NULL,0,&parentData)) {

        if (SetupDiGetDeviceRegistryProperty(parentInfo,
                                             &parentData,
                                             SPDRP_FRIENDLYNAME,
                                             NULL,
                                             (PBYTE)deviceDesc,
                                             sizeof(deviceDesc),
                                             NULL) ||  
            SetupDiGetDeviceRegistryProperty(parentInfo,
                                             &parentData,
                                             SPDRP_DEVICEDESC,
                                             NULL,
                                             (PBYTE)deviceDesc,
                                             sizeof(deviceDesc),
                                             NULL)) {
            wsprintf(charBuffer,TEXT("%s Port %2u (%s)"),deviceDesc,portNumber,comName);
//          #if DBG
//          {
//           TCHAR buf[500];
//           wsprintf(buf, TEXT("%s\n"), charBuffer);
//           DbgOut(buf);
//          }
//          #endif

            SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                             DeviceInfoData,
                                             SPDRP_FRIENDLYNAME,
                                             (PBYTE)charBuffer,
                                              ByteCountOf(_tcslen(charBuffer) + 1)
                                             );

        }

    } else {
        #if DBG
        {
         TCHAR buf[500];
         wsprintf(buf, TEXT("SetupDiOpenDeviceInfo failed with error %x\n"), GetLastError());
         DbgOut(buf);
        }
        #endif
    }
    
    SetupDiDestroyDeviceInfoList(parentInfo);    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyycoins\cyydel.h ===
/** FILE: cyydel.h********* Module Header ********************************
 *
 *  Header for cyydel module.
 * 
 *
 *  Copyright (C) 2000 Cyclades Corporation
 *
 *************************************************************************/

#ifndef CYYDEL_H
#define CYYDEL_H


//==========================================================================
//                            Function Prototypes
//==========================================================================


void
DeleteNonPresentDevices(
);

DWORD
GetParentIdAndRemoveChildren(
    IN PSP_DEVINFO_DATA DeviceInfoData
);


#endif // CYYDEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyycoins\cyfriend.h ===
/** FILE: cyfriend.h ********* Module Header ********************************
 *
 *
 * History:
 *
 *  Copyright (C) 2000 Cyclades Corporation
 *
 *************************************************************************/
//==========================================================================
//                            Include Files
//==========================================================================

#ifndef CYFRIEND_H
#define CYFRIEND_H


//==========================================================================
//                            Function Prototypes
//==========================================================================

//
//  cyfriend.c
//
extern
BOOL
ReplaceFriendlyName(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN PTCHAR           NewComName
);



#endif // CYFRIEND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyycoins\portstr.h ===
#ifndef PORTSTR_H
#define PORTSTR_H

//
//  exported from cyycoins.c
//
extern TCHAR  m_szColon[];
extern TCHAR  m_szComma[];
extern TCHAR  m_szPorts[];
extern TCHAR  m_szCOM[];

extern TCHAR m_szRegSerialMap[];

extern TCHAR m_szPortName[];
extern TCHAR m_szDefParams[];

#endif // PORTSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyycoins\cyydel.c ===
/** FILE: cyydel.c *******************************************************
 *
 *  This module is used by cyycoins.dll and yinfdelete.exe.
 *  Please re-generate both files when cyydel.c is changed.
 *
 *  Copyright (C) 2000 Cyclades Corporation
 *
 *************************************************************************/

//==========================================================================
//                                Include files
//==========================================================================
// C Runtime
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
//#include <stdio.h> Used with .exe

// Device Class GUID
#include <initguid.h>
#include <devguid.h>


// Application specific
#include <windows.h>  
#include <tchar.h> // Make all functions UNICODE safe.
#include <cfgmgr32.h>
#include <setupapi.h> // for SetupDiXxx functions.
#include <regstr.h>
#include "cyydel.h"
//#include "yinfdelete.h" Used with .exe


//==========================================================================
//                              Macros
//==========================================================================

#define CharSizeOf(x)   (sizeof(x) / sizeof(*x))
#define ByteCountOf(x)  ((x) * sizeof(TCHAR))

#if DBG
#define DbgOut(Text) OutputDebugString(Text)
#else
#define DbgOut(Text) 
#endif 

//==========================================================================
//                                Globals
//==========================================================================

TCHAR y_szCyclomyEnumerator[] = TEXT("Cyclom-Y");
TCHAR y_szParentIdPrefix[]  = TEXT("ParentIdPrefix");

//==========================================================================
//                            Local Function Prototypes
//==========================================================================

BOOL
IsItCyclomy(
    PTCHAR ptrChar
);

DWORD
RemoveMyChildren(
    PTCHAR ParentIdPrefix
);


//==========================================================================
//                                Functions
//==========================================================================

void
DeleteNonPresentDevices(
)
{
    HDEVINFO MultiportInfoSet, PresentInfoSet;
    SP_DEVINFO_DATA MultiportInfoData, PresentInfoData;
    DWORD i,j;
    DWORD bufType,bufSize;
    DWORD present;
    TCHAR bufChar[256];

    MultiportInfoSet = SetupDiGetClassDevs(&GUID_DEVCLASS_MULTIPORTSERIAL,
                                           0,
                                           0, 
                                           0 ); // All devices, even non present
    if (MultiportInfoSet == INVALID_HANDLE_VALUE) {
        return;
    }

    MultiportInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    for (i=0;SetupDiEnumDeviceInfo(MultiportInfoSet,i,&MultiportInfoData);i++){
        if (SetupDiGetDeviceRegistryProperty(MultiportInfoSet,
                                             &MultiportInfoData,
                                             SPDRP_HARDWAREID, //SPDRP_SERVICE,
                                             &bufType,
                                             (PBYTE) bufChar,
                                             sizeof(bufChar),
                                             NULL)) {
            if (bufType != REG_MULTI_SZ) {
                continue;
            }

            if (!IsItCyclomy(bufChar)) {
                continue;
            }

            // Verify if this cyclom-y is present.
            PresentInfoSet = SetupDiGetClassDevs(&GUID_DEVCLASS_MULTIPORTSERIAL,
                                                 0,
                                                 0, 
                                                 DIGCF_PRESENT ); 
            if (PresentInfoSet == INVALID_HANDLE_VALUE) {
                continue;
            }

            present = FALSE;
            PresentInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            for (j=0;SetupDiEnumDeviceInfo(PresentInfoSet,j,&PresentInfoData);j++) {
                if (MultiportInfoData.DevInst == PresentInfoData.DevInst) {
                    present = TRUE;
                    break;
                }
            }
            if (GetLastError() == ERROR_NO_MORE_ITEMS) {
                if (!present) {
                    //#if DBG
                    //TCHAR   myDevInstId[200];
                    //DWORD   err;
                    //err = CM_Get_Device_ID(MultiportInfoData.DevInst,myDevInstId,
                    //                       sizeof(myDevInstId),0);
                    //if (err==CR_SUCCESS) {
                    //    TCHAR buf[500];
                    //    wsprintf(buf, TEXT("Delete %s\n"), myDevInstId);    
                    //    DbgOut(buf);
                    //}
                    //#endif
                    GetParentIdAndRemoveChildren(&MultiportInfoData);
                    SetupDiCallClassInstaller(DIF_REMOVE,MultiportInfoSet,&MultiportInfoData);
                }
            }

            SetupDiDestroyDeviceInfoList(PresentInfoSet);

        }

    }
    SetupDiDestroyDeviceInfoList(MultiportInfoSet);
}

BOOL
IsItCyclomy(
    PTCHAR ptrChar
)
{

    while (*ptrChar) {
        //_tprintf("%s\n", ptrChar);
        if (_tcsnicmp(ptrChar,
                      TEXT("PCI\\VEN_120E&DEV_010"),
                      _tcslen(TEXT("PCI\\VEN_120E&DEV_010")))
             == 0) {
            return TRUE;
        }
        if (_tcsnicmp(ptrChar,
                      TEXT("YISA"),
                      _tcslen(TEXT("YISA")))
            == 0) {
            return TRUE;
        }
        ptrChar = ptrChar + _tcslen(ptrChar) + 1;
    }
    return FALSE;
}

DWORD
GetParentIdAndRemoveChildren(
    IN PSP_DEVINFO_DATA DeviceInfoData
)
{
    DWORD   dwSize;
    TCHAR   instanceId[MAX_DEVICE_ID_LEN];
    TCHAR   parentIdPrefix[50];
    HKEY    enumKey,instKey;
    BOOL    gotParentIdPrefix;
    DWORD   Status = NO_ERROR;

    if (CM_Get_Device_ID(DeviceInfoData->DevInst,instanceId,CharSizeOf(instanceId),0) ==
        CR_SUCCESS) {

        gotParentIdPrefix = FALSE;
        // Open Registry and retrieve ParentIdPrefix value
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_SYSTEMENUM,0,KEY_READ, 
            &enumKey) == ERROR_SUCCESS) {

            if (RegOpenKeyEx(enumKey,instanceId,0,KEY_READ,&instKey) == ERROR_SUCCESS) {
                
                dwSize = sizeof(parentIdPrefix);
                if (RegQueryValueEx(instKey,y_szParentIdPrefix,NULL,NULL,
                    (PBYTE)parentIdPrefix,&dwSize) == ERROR_SUCCESS) {
                    _tcsupr(parentIdPrefix);
                    gotParentIdPrefix = TRUE;
                            
                }
                RegCloseKey(instKey);
            }
            RegCloseKey(enumKey);
        }
        if (gotParentIdPrefix) {
            Status = RemoveMyChildren(parentIdPrefix);
        }
    }
    return Status;
}


DWORD
RemoveMyChildren(
    PTCHAR ParentIdPrefix
)
{
    HDEVINFO DeviceInfoSet;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD i,err;
    TCHAR portId[MAX_DEVICE_ID_LEN];
    PTCHAR ptrParent;

    DeviceInfoSet = SetupDiGetClassDevs( &GUID_DEVCLASS_PORTS,y_szCyclomyEnumerator,0,0 ); 
    if (DeviceInfoSet == INVALID_HANDLE_VALUE)
    {
        return GetLastError();
    }

    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    for (i=0;SetupDiEnumDeviceInfo(DeviceInfoSet,i,&DeviceInfoData);i++)
    {
        if (CM_Get_Device_ID(DeviceInfoData.DevInst,portId,CharSizeOf(portId),0)
            == CR_SUCCESS) {

            // BUG? For ParentIdPrefix "3&2b41c2e&1f" (12 characters), _tcscspn 
            // always returns 0!! Using _tcsstr instead.
            //position = _tcscspn(portId,ParentIdPrefix);

            ptrParent = _tcsstr(portId,ParentIdPrefix);
            if (ptrParent) {

                if (_tcsnicmp (ptrParent,ParentIdPrefix,_tcslen(ParentIdPrefix))
                    == 0){
                    //
                    // Worker function to remove device.
                    //
                    //#if DBG
                    //{
                    // TCHAR buf[500];
                    // wsprintf(buf, TEXT("Delete %s\n"), portId);    
                    // DbgOut(buf);
                    //}
                    //#endif

                    SetupDiCallClassInstaller(DIF_REMOVE,DeviceInfoSet,&DeviceInfoData);
                }

            }

        }
        DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    }
    SetupDiDestroyDeviceInfoList(DeviceInfoSet);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyycoins\cyyhelp.h ===
// Used by cyycoins.dll and cyycoins.chm

#define IDH_CYYCOINS_NOHELP             1
#define IDH_CYYCOINS_NUM_PORTS          2
#define IDH_CYYCOINS_START_COM          3
#define IDH_CYYCOINS_RESTORE_DEFAULTS   4
#define IDH_CYYCOINS_BUS_TYPE           5
#define IDH_CYYCOINS_CONFIGURATION      6
#define IDH_CYYCOINS_MODEL              7
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyycoins\cyycoins.c ===
/** FILE: cyycoins.c ********** Module Header ********************************
 *
 *  Cyclom-Y device co-installer.
 *
 *
 *  Copyright (C) 2000 Cyclades Corporation
 *
 *************************************************************************/
//==========================================================================
//                                Include files
//==========================================================================
// C Runtime
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

// Device Class GUID
#include <initguid.h>
#include <devguid.h>


// Application specific
#include "cyyports.h"
#include <msports.h>
#include "cyydel.h"


//==========================================================================
//                                Globals
//==========================================================================

HANDLE  g_hInst  = NULL;

TCHAR g_szErrMem[ 200 ];            //  Low memory message
TCHAR g_szPortsApplet[ 30 ];        //  "Ports Control Panel Applet" title
TCHAR g_szNull[]  = TEXT("");       //  Null string

TCHAR  m_szColon[]      = TEXT( ":" );
TCHAR  m_szPorts[]      = TEXT( "Ports" );
TCHAR  m_szCOM[]        = TEXT( "COM" );

//
//  NT Registry keys to find COM port to Serial Device mapping
//
TCHAR m_szRegSerialMap[]    = TEXT( "Hardware\\DeviceMap\\SerialComm" );

//
//  Registry Serial Port Advanced I/O settings key and valuenames
//
TCHAR m_szPortName[]        = REGSTR_VAL_PORTNAME;

TCHAR m_szDefParams[]       = TEXT( "9600,n,8,1" );



//==========================================================================
//                            Local Function Prototypes
//==========================================================================

LPTSTR GetDIFString(IN DI_FUNCTION Func);

DWORD
CreateFriendlyName(
    IN     HDEVINFO          DeviceInfoSet,
    IN     PSP_DEVINFO_DATA  DeviceInfoData
);

//==========================================================================
//                                Dll Entry Point
//==========================================================================

BOOL APIENTRY LibMain( HANDLE hDll, DWORD dwReason, LPVOID lpReserved )
{

//#if DBG
//        OutputDebugString(TEXT("cyycoins LibMain entry\n"));
//#endif
   
    switch( dwReason )
    {
    case DLL_PROCESS_ATTACH:
//#if DBG
//        OutputDebugString(TEXT("cyycoins DLL_PROCESS_ATTACH\n"));
//#endif
        g_hInst = hDll;
        DisableThreadLibraryCalls(hDll);
        InitStrings();

        break;

    case DLL_PROCESS_DETACH:
//#if DBG
//        OutputDebugString(TEXT("cyycoins DLL_PROCESS_DETACH\n"));
//#endif
        break;

    default:
//#if DBG
//        OutputDebugString(TEXT("cyycoins default\n"));
//#endif
        break;
    }

//#if DBG
//        OutputDebugString(TEXT("cyycoins LibMain exit\n"));
//#endif
    return TRUE;
}


void InitStrings(void)
{
    DWORD  dwClass, dwShare;
    TCHAR  szClass[ 40 ];

    LoadString(g_hInst, 
               INITS,
               g_szErrMem,
               CharSizeOf(g_szErrMem));
    LoadString(g_hInst, 
               IDS_CYCLOMY,
               g_szPortsApplet,
               CharSizeOf(g_szPortsApplet));
}


//==========================================================================
//                                Functions
//==========================================================================


HRESULT
CyclomyCoInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL,
    IN OUT PCOINSTALLER_CONTEXT_DATA    Context
)
/*++

Routine Description:

    This routine is a Co-Installer for the Cyclom-Y device.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

    Context - Points to a coinstaller-specific context structure for this 
        installation request. 

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/
{
    DWORD   Status = NO_ERROR;

//    #if DBG
//    {
//     TCHAR buf[500];
//     wsprintf(buf, TEXT("CyclomyCoInstaller:InstallFunction(%s) PostProcessing:%d\n"), GetDIFString(InstallFunction), Context->PostProcessing);
//     DbgOut(buf);
//    }
//    #endif

    switch(InstallFunction) {
        case DIF_INSTALLDEVICE :

            //
            // We should not copy any INF files until the install has completed
            // like the primary INF, all secondary INF's must exist on each disk
            // of a multi-disk install.
            //

            if(!Context->PostProcessing){

                DeleteNonPresentDevices();

                Status = ERROR_DI_POSTPROCESSING_REQUIRED;
            } else { 
                // post processing

                //
                // if driver installation failed, we're not interested
                // in processing CopyINF entries.
                //
                if (Context->InstallResult != NO_ERROR) {
                    DbgOut(TEXT("DIF_INSTALLDEVICE PostProcessing on failure"));
                    Status = Context->InstallResult;
                    break;
                }

                CreateFriendlyName(DeviceInfoSet,DeviceInfoData);
            }
            break;

        case DIF_REMOVE:    

            GetParentIdAndRemoveChildren(DeviceInfoData);
            
            break;

        default :
            break;
    }
    return Status;
}


LPTSTR GetDIFString(IN DI_FUNCTION Func)
/*++

Routine Description:

    Given a DI_FUNCTION value, returns a text representation.

Arguments:

    Func - DI_FUNCTON value

Return Value:

    Text string if value is known.  Hex representation if not.

--*/
{
    static TCHAR buf[32];
#define MakeCase(d)  case d: return TEXT(#d)
    switch (Func)
    {
        MakeCase(DIF_SELECTDEVICE);
        MakeCase(DIF_INSTALLDEVICE);
        MakeCase(DIF_ASSIGNRESOURCES);
        MakeCase(DIF_PROPERTIES);
        MakeCase(DIF_REMOVE);
        MakeCase(DIF_FIRSTTIMESETUP);
        MakeCase(DIF_FOUNDDEVICE);
        MakeCase(DIF_SELECTCLASSDRIVERS);
        MakeCase(DIF_VALIDATECLASSDRIVERS);
        MakeCase(DIF_INSTALLCLASSDRIVERS);
        MakeCase(DIF_CALCDISKSPACE);
        MakeCase(DIF_DESTROYPRIVATEDATA);
        MakeCase(DIF_VALIDATEDRIVER);
        MakeCase(DIF_MOVEDEVICE);
        MakeCase(DIF_DETECT);
        MakeCase(DIF_INSTALLWIZARD);
        MakeCase(DIF_DESTROYWIZARDDATA);
        MakeCase(DIF_PROPERTYCHANGE);
        MakeCase(DIF_ENABLECLASS);
        MakeCase(DIF_DETECTVERIFY);
        MakeCase(DIF_INSTALLDEVICEFILES);
        MakeCase(DIF_UNREMOVE);
        MakeCase(DIF_SELECTBESTCOMPATDRV);
        MakeCase(DIF_ALLOW_INSTALL);
        MakeCase(DIF_REGISTERDEVICE);
        MakeCase(DIF_INSTALLINTERFACES);
        MakeCase(DIF_DETECTCANCEL);
        MakeCase(DIF_REGISTER_COINSTALLERS);
        MakeCase(DIF_NEWDEVICEWIZARD_FINISHINSTALL);
        MakeCase(DIF_ADDPROPERTYPAGE_ADVANCED);
        MakeCase(DIF_TROUBLESHOOTER);
        default:
            wsprintf(buf, TEXT("%x"), Func);
            return buf;
    }
}


DWORD
CreateFriendlyName(
    IN     HDEVINFO          DeviceInfoSet,
    IN     PSP_DEVINFO_DATA  DeviceInfoData
)
{   
    HDEVINFO multportInfoSet;
    SP_DEVINFO_DATA multportInfoData;
    TCHAR   charBuffer[MAX_PATH],
            friendlyName[LINE_LEN],
            deviceDesc[LINE_LEN],
            myDeviceDesc[LINE_LEN];
    TCHAR * pBoardNumber;
#define MAX_BOARDS 10
    BYTE    used[MAX_BOARDS];
    DWORD i;
    DWORD retStatus = NO_ERROR;
    DWORD tmpBoardNumber = 0;

    //DbgOut(TEXT("CreateFriendlyName\n"));

    for (i=0; i<MAX_BOARDS; i++) {
        used[i]=FALSE;
    }

    if (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                          DeviceInfoData,
                                          SPDRP_DEVICEDESC,
                                          NULL,
                                          (PBYTE)myDeviceDesc,
                                          sizeof(myDeviceDesc),
                                          NULL)) {
        #if DBG
        {
         TCHAR buf[500];
         wsprintf(buf, TEXT("Device Description failed with %x\n"), GetLastError());
         DbgOut(buf);
        }
        #endif
        return retStatus;
    }

    //#if DBG
    //{
    // TCHAR buf[500];
    // wsprintf(buf, TEXT("myDeviceDesc %s\n"), myDeviceDesc);
    // DbgOut(buf);
    //}
    //#endif

    multportInfoSet = SetupDiGetClassDevs(&GUID_DEVCLASS_MULTIPORTSERIAL,NULL,0,0);
    if (multportInfoSet == INVALID_HANDLE_VALUE) {
        // If failure, we will continue installation without creating Friendly Name.
        return retStatus;
    }
    multportInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    for (i=0; SetupDiEnumDeviceInfo(multportInfoSet,i,&multportInfoData);i++) {
        if (SetupDiGetDeviceRegistryProperty(multportInfoSet,
                                             &multportInfoData,
                                             SPDRP_DEVICEDESC,
                                             NULL,
                                             (PBYTE)deviceDesc,
                                             sizeof(deviceDesc),
                                             NULL)) {
            
            if ((multportInfoData.DevInst != DeviceInfoData->DevInst) &&
                _tcscmp (deviceDesc,myDeviceDesc) == 0){

                // Another board with same device description found.

                if (SetupDiGetDeviceRegistryProperty(multportInfoSet,
                                                     &multportInfoData,
                                                     SPDRP_FRIENDLYNAME,
                                                     NULL,
                                                     (PBYTE)friendlyName,
                                                     sizeof(friendlyName),
                                                     NULL)) {
                    
                    pBoardNumber = _tcschr(friendlyName,'#');
                    if (pBoardNumber == NULL) {
                        used[0] = TRUE;
                        continue;
                    }
                    if ((pBoardNumber +1) == NULL) {
                        continue;
                    }
                    tmpBoardNumber = MyAtoi(pBoardNumber+1);
                    if ((tmpBoardNumber > 0) && (tmpBoardNumber < MAX_BOARDS)) {
                        used[tmpBoardNumber] = TRUE;
                    }
                } 
            }
            
        }

        multportInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    }

    SetupDiDestroyDeviceInfoList(multportInfoSet);

    if (used[0]==TRUE) {
        for (i=2; i<MAX_BOARDS; i++) {
            if (used[i] == FALSE) {
                break;
            }
        }
        if (i<MAX_BOARDS) {
            wsprintf(charBuffer, TEXT("%s #%d "), myDeviceDesc, i);
            // Write the string friendly name string out
            SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                             DeviceInfoData,
                                             SPDRP_FRIENDLYNAME,
                                             (PBYTE)charBuffer,
                                             ByteCountOf(lstrlen(charBuffer) + 1)
                                             );

        }
    } else {
        wsprintf(charBuffer, TEXT("%s "), myDeviceDesc);
        // Write the string friendly name string out
        SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                         DeviceInfoData,
                                         SPDRP_FRIENDLYNAME,
                                         (PBYTE)charBuffer,
                                         ByteCountOf(lstrlen(charBuffer) + 1)
                                         );
    }

    return retStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyycoins\cyyports.h ===
/** FILE: cyyports.h ********* Module Header ********************************
 *
 *  Control Panel System applet common definitions, resource ids, typedefs,
 *  external declarations and library routine function prototypes.
 *
 * History:
 *
 *
 *  Copyright (C) 2000 Cyclades Corporation
 *
 *************************************************************************/
//==========================================================================
//                            Include Files
//==========================================================================

#ifndef PORTS_H
#define PORTS_H

#include <windows.h>
#include <tchar.h>
#include <cfgmgr32.h>
#include <setupapi.h>
#include <regstr.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include "resource.h"

#include "portstr.h"

#define PORTS        4
#define MAXPORTS    32
#define KEYBZ       4096
#define BUFFER_SIZE 81

#define DEF_BAUD    3       //  1200
#define DEF_WORD    4       //  8 bits
#define DEF_PARITY  2       //  None
#define DEF_STOP    0       //  1
#define DEF_PORT    0       //  Null Port
#define DEF_SHAKE   2       //  None
#define PAR_EVEN    0
#define PAR_ODD     1
#define PAR_NONE    2
#define PAR_MARK    3
#define PAR_SPACE   4
#define STOP_1      0
#define STOP_15     1
#define STOP_2      2
#define FLOW_XON    0
#define FLOW_HARD   1
#define FLOW_NONE   2

//#define MAX_COM_PORT  COMDB_MIN_PORTS_ARBITRATED   // Maximum number of COM ports NT supports
#define MAX_COM_PORT  2048                         // We should support at least 1024 ports.
#define MIN_COM       1                            // Minimum new COM port number

#define POLL_PERIOD_DEFAULT_IDX 1 

//==========================================================================
//                        Definitions
//==========================================================================

//
//  General definitions
//

#define PATHMAX             MAX_PATH


//
//  Help IDs -- for the Ports applet
//
//
#define IDH_HELPFIRST        5000
#define IDH_SYSMENU     (IDH_HELPFIRST + 2000)
#define IDH_MBFIRST     (IDH_HELPFIRST + 2001)
#define IDH_MBLAST      (IDH_HELPFIRST + 2099)
#define IDH_DLGFIRST    (IDH_HELPFIRST + 3000)

#define IDH_MENU_SCHHELP    (IDH_HELPFIRST + MENU_SCHHELP)
#define IDH_MENU_INDHELP    (IDH_HELPFIRST + MENU_INDHELP)
#define IDH_MENU_USEHELP    (IDH_HELPFIRST + MENU_USEHELP)
#define IDH_MENU_ABOUT      (IDH_HELPFIRST + MENU_ABOUT )
#define IDH_MENU_EXIT       (IDH_HELPFIRST + MENU_EXIT)
#define IDH_CHILD_PORTS     (IDH_HELPFIRST + 4 /* CHILD_PORTS */ )
#define IDH_DLG_PORTS2      (IDH_DLGFIRST + DLG_PORTS2)
#define IDH_DLG_PORTS3      (IDH_DLGFIRST + DLG_PORTS3)

//==========================================================================
//                           Typedefs
//==========================================================================
typedef struct {
    SP_DEVINFO_DATA  DeviceInfoData;

    TCHAR ComName[20];
    TCHAR Settings[20];
    
    ULONG BaseAddress;
} PORT_INFO, *PPORT_INFO;

typedef struct _PORTS_WIZARD_DATA {

    HDEVINFO          DeviceInfoSet;
    PSP_DEVINFO_DATA  pDeviceInfoData;

    ULONG BaseAddress;
    ULONG FirstComNumber;

    ULONG PortsCount;
    PPORT_INFO Ports;

    PUINT UsedComNumbers;
    UINT UsedComNumbersCount;

    BOOL IsMulti;
} PORTS_WIZARD_DATA, *PPORTS_WIZARD_DATA;


//==========================================================================
//                              Macros
//==========================================================================

#define CharSizeOf(x)   (sizeof(x) / sizeof(*x))
#define ByteCountOf(x)  ((x) * sizeof(TCHAR))

#if DBG
#define DbgOut(Text) OutputDebugString(Text)
#else
#define DbgOut(Text) 
#endif 

//==========================================================================
//                         External Declarations
//==========================================================================
//
//  DATA


//
//  exported from cpl.c
//

extern HANDLE g_hInst;
extern TCHAR  g_szErrMem[ ];        //  Low memory message
extern TCHAR  g_szPortsApplet[ ];   //  "Ports Control Panel Applet" title
extern TCHAR  g_szNull[];           //  Null string

extern DWORD PollingPeriods[];

extern TCHAR  m_szPorts[];
extern TCHAR  m_szPortName[];

//==========================================================================
//                            Function Prototypes
//==========================================================================

//
//  LibMain module
//

extern 
VOID
InitStrings(void);


//
//  cyfriend.c
//

extern
BOOL
ReplaceFriendlyName(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN PTCHAR           NewComName
);


//
//  util.c
//

extern 
LPTSTR 
BackslashTerm(LPTSTR pszPath);

extern 
VOID 
ErrMemDlg(HWND hParent);

extern 
int    
MyAtoi(LPTSTR  string);

extern 
int    
myatoi(LPTSTR pszInt);

extern 
int    
MyMessageBox(HWND hWnd, 
                         DWORD wText, 
                         DWORD wCaption, 
                         DWORD wType, 
                         ...);

extern
int
MyMessageBoxWithErr(
    HWND hWnd, 
	DWORD wText, 
	DWORD wCaption, 
	DWORD wType,
    DWORD wError
    );

extern 
LPTSTR 
MyItoa(INT value, 
           LPTSTR  string, 
           INT  radix);

extern 
LPTSTR 
MyUltoa(unsigned long  value, 
                LPTSTR  string, 
                INT  radix);

extern 
VOID   
SendWinIniChange(LPTSTR szSection);

extern 
LPTSTR 
strscan(LPTSTR pszString, 
                LPTSTR pszTarget);

extern 
VOID
StripBlanks(LPTSTR pszString);


#endif // PORTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyycoins\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cyycoins.rc
//
#define INITS                           0
#define PORTS_ICON                      2
#define DLG_PP_PORTSETTINGS             15
#define IDS_FRIENDLY_FORMAT             29
#define IDS_IN_USE                      61
#define IDS_CYCLOMY                     80
#define IDS_NUM_PORTS_DISABLED          81
#define IDS_START_COM_DISABLED          82
#define IDS_COM_TOO_BIG_WRN             83
#define IDS_MEM_ALLOC_WRN               84
#define IDS_COM_TOO_BIG_ERR             85
#define IDS_MEM_ALLOC_ERR               86
#define IDS_INVALID_HCOMDB              87
#define IDS_START_COM_NOT_CHANGED       88
#define IDS_PORT_OPEN_ERROR             89
#define IDS_PORT_IN_USE_ERROR           90
#define IDS_PORT_RENAME_ERROR           91
#define PP_START_COM                    1038
#define IDC_START_COM                   1040
#define PP_NUM_PORTS                    1044
#define IDC_NUM_PORTS                   1045
#define IDC_RESTORE_DEFAULTS            1046
#define PP_BUS_TYPE                     1047
#define IDC_MODEL                       1052
#define PP_MODEL                        1053
#define IDC_CONFIGURATION               1054
#define PP_CONFIGURATION                1055
#define IDC_BUS_TYPE                    1056
#define IDC_STATIC_BOARD_DETAILS        1057
#define IDC_STATIC_SETTINGS             1058
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        112
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1058
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\cyclades\y\cyycoins\pp.c ===
/*----------------------------------------------------------------------
 file: pp.c - property page

----------------------------------------------------------------------*/
#include "cyyports.h"
#include "pp.h"
#include <htmlhelp.h>

#include <windowsx.h>

//TCHAR m_szDevMgrHelp[]   = _T("devmgr.hlp");
TCHAR m_szCyycoinsHelp[] = _T("cyycoins.chm");
TCHAR y_szNumOfPorts[]   = TEXT("NumOfPorts");

const DWORD HelpIDs[]=
{
    IDC_STATIC,               IDH_CYYCOINS_NOHELP,
    IDC_STATIC_BOARD_DETAILS, IDH_CYYCOINS_NOHELP,
    IDC_STATIC_SETTINGS,      IDH_CYYCOINS_NOHELP,
    IDC_NUM_PORTS,            IDH_CYYCOINS_NUM_PORTS,
    PP_NUM_PORTS,             IDH_CYYCOINS_NUM_PORTS,
    IDC_START_COM,            IDH_CYYCOINS_START_COM,
    PP_START_COM,             IDH_CYYCOINS_START_COM,
    IDC_RESTORE_DEFAULTS,     IDH_CYYCOINS_RESTORE_DEFAULTS,
    IDC_BUS_TYPE,             IDH_CYYCOINS_BUS_TYPE,
    PP_BUS_TYPE,              IDH_CYYCOINS_BUS_TYPE,
    IDC_CONFIGURATION,        IDH_CYYCOINS_CONFIGURATION,
    PP_CONFIGURATION,         IDH_CYYCOINS_CONFIGURATION,
    IDC_MODEL,                IDH_CYYCOINS_MODEL,
    PP_MODEL,                 IDH_CYYCOINS_MODEL,
    0, 0
};

void InitPortParams(
    IN OUT PPORT_PARAMS      Params,
    IN HDEVINFO              DeviceInfoSet,
    IN PSP_DEVINFO_DATA      DeviceInfoData
    )
{
    SP_DEVINFO_LIST_DETAIL_DATA detailData;
    HCOMDB                      hComDB;
    DWORD                       maxPortsReported;

    //DbgOut(TEXT("InitPortParams\n"));

    ZeroMemory(Params, sizeof(PORT_PARAMS));

    Params->DeviceInfoSet = DeviceInfoSet;
    Params->DeviceInfoData = DeviceInfoData;

    // Allocate and initialize PortUsage matrix
    ComDBOpen(&hComDB);
    if (hComDB != INVALID_HANDLE_VALUE) {
        ComDBGetCurrentPortUsage(hComDB,
                                 NULL,
                                 0,
                                 CDB_REPORT_BYTES,
                                 &maxPortsReported);

        //#if DBG
        //{
        // TCHAR buf[500];
        // wsprintf(buf, TEXT("maxPortsReported %d\n"),maxPortsReported);
        // DbgOut(buf);
        //}
        //#endif

        if (maxPortsReported != 0) {
            Params->ShowStartCom = TRUE;
            //Params->PortUsage = (PBYTE) LocalAlloc(LPTR,maxPortsReported/8);
            if (maxPortsReported > MAX_COM_PORT) {
                Params->PortUsageSize = maxPortsReported;
            } else {
                Params->PortUsageSize = MAX_COM_PORT;
            }
            Params->PortUsage = (PBYTE) LocalAlloc(LPTR,Params->PortUsageSize/8);
            if (Params->PortUsage != NULL) {
                Params->PortUsageSize = maxPortsReported/8;
                ComDBGetCurrentPortUsage(hComDB,
                                         Params->PortUsage,
                                         Params->PortUsageSize,
                                         CDB_REPORT_BITS,
                                         &maxPortsReported
                                         );
            }
        }

        ComDBClose(hComDB);
    } else {
        // This happens if we don't have sufficient security privileges.
        // GetLastError returns 0 here!!! Some bug in ComDBOpen.
        DbgOut(TEXT("cyycoins ComDBOpen failed.\n"));
    }

    //
    // See if we are being invoked locally or over the network.  If over the net,
    // then disable all possible changes.
    //
    detailData.cbSize = sizeof(SP_DEVINFO_LIST_DETAIL_DATA);
    if (SetupDiGetDeviceInfoListDetail(DeviceInfoSet, &detailData) &&
        detailData.RemoteMachineHandle != NULL) {
        Params->ShowStartCom = FALSE;
    }

}

HPROPSHEETPAGE InitSettingsPage(PROPSHEETPAGE *     psp,
                                OUT PPORT_PARAMS    Params)
{
    //
    // Add the Port Settings property page
    //
    psp->dwSize      = sizeof(PROPSHEETPAGE);
    psp->dwFlags     = PSP_USECALLBACK; // | PSP_HASHELP;
    psp->hInstance   = g_hInst;
    psp->pszTemplate = MAKEINTRESOURCE(DLG_PP_PORTSETTINGS);

    //
    // following points to the dlg window proc
    //
    psp->pfnDlgProc = PortSettingsDlgProc;
    psp->lParam     = (LPARAM) Params;

    //
    // following points to some control callback of the dlg window proc
    //
    psp->pfnCallback = PortSettingsDlgCallback;

    //
    // allocate our "Ports Setting" sheet
    //
    return CreatePropertySheetPage(psp);
}

/*++

Routine Description: CyclomyPropPageProvider

    Entry-point for adding additional device manager property
    sheet pages.  Registry specifies this routine under
    Control\Class\PortNode::EnumPropPage32="msports.dll,thisproc"
    entry.  This entry-point gets called only when the Device
    Manager asks for additional property pages.

Arguments:

    Info  - points to PROPSHEETPAGE_REQUEST, see setupapi.h
    AddFunc - function ptr to call to add sheet.
    Lparam - add sheet functions private data handle.

Return Value:

    BOOL: FALSE if pages could not be added, TRUE on success

--*/
BOOL APIENTRY CyclomyPropPageProvider(LPVOID               Info,
                                      LPFNADDPROPSHEETPAGE AddFunc,
                                      LPARAM               Lparam
                                      )
{
   PSP_PROPSHEETPAGE_REQUEST pprPropPageRequest;
   PROPSHEETPAGE             psp;
   HPROPSHEETPAGE            hpsp;
   PPORT_PARAMS              params = NULL; 

   //DbgOut(TEXT("cyycoins CyclomyPropPageProvider entry\n"));

   pprPropPageRequest = (PSP_PROPSHEETPAGE_REQUEST) Info;


   //
   // Allocate and zero out memory for the struct that will contain
   // page specific data
   //
   params = (PPORT_PARAMS) LocalAlloc(LPTR, sizeof(PORT_PARAMS));

//******************************************************************
// TEST ERROR
//   if (params)
//        LocalFree(params);
//   params = NULL;
//   
//******************************************************************

   if (!params) {
       ErrMemDlg(GetFocus());
       return FALSE;
   }

   if (pprPropPageRequest->PageRequested == SPPSR_ENUM_ADV_DEVICE_PROPERTIES) {

        InitPortParams(params,
                       pprPropPageRequest->DeviceInfoSet,
                       pprPropPageRequest->DeviceInfoData);

        hpsp = InitSettingsPage(&psp, params);
      
        if (!hpsp) {
            return FALSE;
        }
        
        if (!(*AddFunc)(hpsp, Lparam)) {
            DestroyPropertySheetPage(hpsp);
            return FALSE;
        }
   }

   return TRUE;
} /* CyclomyPropPageProvider */


UINT CALLBACK
PortSettingsDlgCallback(HWND hwnd,
                        UINT uMsg,
                        LPPROPSHEETPAGE ppsp)
{
    PPORT_PARAMS params;

    switch (uMsg) {
    case PSPCB_CREATE:
        return TRUE;    // return TRUE to continue with creation of page

    case PSPCB_RELEASE:
        //DbgOut(TEXT("PortSettingsDlgCallBack PSPCB_RELEASE\n"));
        params = (PPORT_PARAMS) ppsp->lParam;
        if (params->PortUsage) {
            LocalFree(params->PortUsage);
        }
        LocalFree(params);

        return 0;       // return value ignored

    default:
        break;
    }

    return TRUE;
}

void
Port_OnCommand(
    HWND DialogHwnd,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    );

BOOL
Port_OnContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    );

void
Port_OnHelp(
    HWND       DialogHwnd,
    LPHELPINFO HelpInfo
    );

BOOL
Port_OnInitDialog(
    HWND    DialogHwnd,
    HWND    FocusHwnd,
    LPARAM  Lparam
    );

BOOL
Port_OnNotify(
    HWND    DialogHwnd,
    LPNMHDR NmHdr
    );

/*++

Routine Description: PortSettingsDlgProc

    The windows control function for the Port Settings properties window

Arguments:

    hDlg, uMessage, wParam, lParam: standard windows DlgProc parameters

Return Value:

    BOOL: FALSE if function fails, TRUE if function passes

--*/
INT_PTR APIENTRY
PortSettingsDlgProc(IN HWND   hDlg,
                    IN UINT   uMessage,
                    IN WPARAM wParam,
                    IN LPARAM lParam)
{
    switch(uMessage) {
    case WM_COMMAND:
        Port_OnCommand(hDlg, (int) LOWORD(wParam), (HWND)lParam, (UINT)HIWORD(wParam));
        break;

    case WM_CONTEXTMENU:
        return Port_OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP: 
        Port_OnHelp(hDlg, (LPHELPINFO) lParam);
        break;
    
    case WM_INITDIALOG:
        return Port_OnInitDialog(hDlg, (HWND)wParam, lParam); 

    case WM_NOTIFY:
        return Port_OnNotify(hDlg,  (NMHDR *)lParam);
    }

    return FALSE;
} /* PortSettingsDialogProc */

void
Port_OnRestoreDefaultsClicked(
    HWND            DialogHwnd,
    PPORT_PARAMS    Params
    )
{
    RestoreDefaults(DialogHwnd, Params);
    PropSheet_Changed(GetParent(DialogHwnd), DialogHwnd);
}

void
Port_OnCommand(
    HWND DialogHwnd,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    )
{
    PPORT_PARAMS params = (PPORT_PARAMS)GetWindowLongPtr(DialogHwnd, DWLP_USER);

    if (NotifyCode == CBN_SELCHANGE) {
        PropSheet_Changed(GetParent(DialogHwnd), DialogHwnd);
    }
    else {
        switch (ControlId) {
        //case IDC_ADVANCED:
        //    Port_OnAdvancedClicked(DialogHwnd, params);
        //    break; 
        //
        case IDC_RESTORE_DEFAULTS:
            Port_OnRestoreDefaultsClicked(DialogHwnd, params);
            break; 
        
        //
        // Because this is a prop sheet, we should never get this.
        // All notifications for ctrols outside of the sheet come through
        // WM_NOTIFY
        //
        case IDCANCEL:
            EndDialog(DialogHwnd, 0); 
            return;
        }
    }
}

BOOL
Port_OnContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    )
{
//  WinHelp(HwndControl,
//          m_szCyycoinsHelp, //m_szDevMgrHelp,
//          HELP_CONTEXTMENU,
//          (ULONG_PTR) HelpIDs);
    HtmlHelp(HwndControl,
            m_szCyycoinsHelp,
            HH_TP_HELP_CONTEXTMENU,
            (ULONG_PTR) HelpIDs);

    return FALSE;
}

void
Port_OnHelp(
    HWND       DialogHwnd,
    LPHELPINFO HelpInfo
    )
{
    if (HelpInfo->iContextType == HELPINFO_WINDOW) {
//      WinHelp((HWND) HelpInfo->hItemHandle,
//              m_szCyycoinsHelp, //m_szDevMgrHelp,
//              HELP_WM_HELP, 
//              (ULONG_PTR) HelpIDs);
        HtmlHelp((HWND) HelpInfo->hItemHandle,
                m_szCyycoinsHelp,
                HH_TP_HELP_WM_HELP, 
                (ULONG_PTR) HelpIDs);
    }
}

BOOL
Port_OnInitDialog(
    HWND    DialogHwnd,
    HWND    FocusHwnd,
    LPARAM  Lparam
    )
{
    PPORT_PARAMS params;
    DWORD dwError;

    //DbgOut(TEXT("Port_OnInitDialog\n"));

    //
    // on WM_INITDIALOG call, lParam points to the property
    // sheet page.
    //
    // The lParam field in the property sheet page struct is set by the
    // caller. When I created the property sheet, I passed in a pointer
    // to a struct containing information about the device. Save this in
    // the user window long so I can access it on later messages.
    //
    params = (PPORT_PARAMS) ((LPPROPSHEETPAGE)Lparam)->lParam;
    SetWindowLongPtr(DialogHwnd, DWLP_USER, (ULONG_PTR) params);
    

    // Display board details
    FillNumberOfPortsText(DialogHwnd,params);
    FillModelAndBusTypeText(DialogHwnd,params);

    //
    // Set up the combo box with choices
    //
    if (params->ShowStartCom) {
        ComDBOpen(&params->hComDB);
        params->ShowStartCom = FillStartComCb(DialogHwnd, params);
        if (params->hComDB != HCOMDB_INVALID_HANDLE_VALUE) {
            ComDBClose(params->hComDB);
        }
    } else {
        EnableWindow(GetDlgItem(DialogHwnd, PP_START_COM), FALSE);
        EnableWindow(GetDlgItem(DialogHwnd, IDC_START_COM), FALSE);
    }

    return TRUE;  // No need for us to set the focus.
}

BOOL
Port_OnNotify(
    HWND    DialogHwnd,
    LPNMHDR NmHdr
    )
{
    PPORT_PARAMS params = (PPORT_PARAMS)GetWindowLongPtr(DialogHwnd, DWLP_USER);

    switch (NmHdr->code) {
    //
    // Sent when the user clicks on Apply OR OK !!
    //
    case PSN_APPLY:

        //DbgOut(TEXT("Port_OnNotify PSN_APPLY\n"));

        //
        // Write out the com port options to the registry
        //
        if (SavePortSettingsDlg(DialogHwnd, params)) {
            SetWindowLongPtr(DialogHwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
        } else {
            SetWindowLongPtr(DialogHwnd, DWLP_MSGRESULT, PSNRET_INVALID);
        }
        return TRUE;
        
    default:
        //DbgOut(TEXT("Port_OnNotify default\n"));
        return FALSE;
    }
}


ULONG
FillModelAndBusTypeText(
    IN HWND             DialogHwnd,
    IN PPORT_PARAMS     Params
    )
{

    TCHAR szHardwareId[LINE_LEN];
    PTCHAR szCharPtr;
    HWND  detailHwnd;
    TCHAR szBusType[10];
    TCHAR szConfiguration[10];
    TCHAR szModel[10];
    DWORD dataType;

    ZeroMemory(szBusType,sizeof(szBusType));
    ZeroMemory(szConfiguration,sizeof(szConfiguration));
    ZeroMemory(szModel,sizeof(szModel));
    
    if (SetupDiGetDeviceRegistryProperty(Params->DeviceInfoSet,
                                         Params->DeviceInfoData,
                                         SPDRP_HARDWAREID,
                                         &dataType,
                                         (PBYTE) szHardwareId,
                                         sizeof(szHardwareId),
                                         NULL)) {

        szCharPtr = szHardwareId;
        while (*szCharPtr) {
            if (_tcsnicmp(szCharPtr,
                          TEXT("PCI\\VEN_120E&DEV_0100&SUBSYS_0100120E"),
                          _tcslen(TEXT("PCI\\VEN_120E&DEV_0100&SUBSYS_0100120E")))
                 == 0) {
                wsprintf(szBusType, TEXT("PCI"));            
                wsprintf(szConfiguration, TEXT("Below 1MB"));
                wsprintf(szModel, TEXT("YeP"));
                break;
            } else if (_tcsnicmp(szCharPtr,
                          TEXT("PCI\\VEN_120E&DEV_0101&SUBSYS_0100120E"),
                          _tcslen(TEXT("PCI\\VEN_120E&DEV_0101&SUBSYS_0100120E")))
                 == 0) {
                wsprintf(szBusType, TEXT("PCI"));            
                wsprintf(szConfiguration, TEXT("Above 1MB"));
                wsprintf(szModel, TEXT("YeP"));
                break;
            } else if (_tcsnicmp(szCharPtr,
                          TEXT("PCI\\VEN_120E&DEV_0100"),
                          _tcslen(TEXT("PCI\\VEN_120E&DEV_0100")))
                 == 0) {
                wsprintf(szBusType, TEXT("PCI"));            
                wsprintf(szConfiguration, TEXT("Below 1MB"));
                break;
            } else if (_tcsnicmp(szCharPtr,
                          TEXT("PCI\\VEN_120E&DEV_0101"),
                          _tcslen(TEXT("PCI\\VEN_120E&DEV_0101")))
                 == 0) {
                wsprintf(szBusType, TEXT("PCI"));            
                wsprintf(szConfiguration, TEXT("Above 1MB"));
                break;
            } else if (_tcsnicmp(szCharPtr,
                          TEXT("PCI\\VEN_120E&DEV_0102"),
                          _tcslen(TEXT("PCI\\VEN_120E&DEV_0102")))
                 == 0) {
                wsprintf(szBusType, TEXT("PCI"));
                wsprintf(szConfiguration, TEXT("Below 1MB"));
                wsprintf(szModel, TEXT("4YP"));
                break;
            } else if (_tcsnicmp(szCharPtr,
                          TEXT("PCI\\VEN_120E&DEV_0103"),
                          _tcslen(TEXT("PCI\\VEN_120E&DEV_0103")))
                 == 0) {
                wsprintf(szBusType, TEXT("PCI"));
                wsprintf(szConfiguration, TEXT("Above 1MB"));
                wsprintf(szModel, TEXT("4YP"));
                break;
            } else if (_tcsnicmp(szCharPtr,
                          TEXT("PCI\\VEN_120E&DEV_0104"),
                          _tcslen(TEXT("PCI\\VEN_120E&DEV_0104")))
                 == 0) {
                wsprintf(szBusType, TEXT("PCI"));
                wsprintf(szConfiguration, TEXT("Below 1MB"));
                wsprintf(szModel, TEXT("8YP"));
                break;
            } else if (_tcsnicmp(szCharPtr,
                          TEXT("PCI\\VEN_120E&DEV_0105"),
                          _tcslen(TEXT("PCI\\VEN_120E&DEV_0105")))
                 == 0) {
                wsprintf(szBusType, TEXT("PCI"));
                wsprintf(szConfiguration, TEXT("Above 1MB"));
                wsprintf(szModel, TEXT("8YP"));
                break;
            } else if (_tcsnicmp(szCharPtr,
                          TEXT("YISA"),
                          _tcslen(TEXT("YISA")))
                == 0) {
                wsprintf(szBusType, TEXT("ISA"));
            }   break;
            szCharPtr = szCharPtr + _tcslen(szCharPtr) + 1;
        }

        if (*szBusType) {
            detailHwnd = GetDlgItem(DialogHwnd, PP_BUS_TYPE);
            SetWindowText(detailHwnd,szBusType);
        }
        if (*szConfiguration) {
            detailHwnd = GetDlgItem(DialogHwnd, IDC_CONFIGURATION);
            SetWindowText(detailHwnd,TEXT("Configuration:"));
            detailHwnd = GetDlgItem(DialogHwnd, PP_CONFIGURATION);
            SetWindowText(detailHwnd,szConfiguration);
        }
        if (*szModel) {
            detailHwnd = GetDlgItem(DialogHwnd, IDC_MODEL);
            SetWindowText(detailHwnd,TEXT("Model:"));
            detailHwnd = GetDlgItem(DialogHwnd, PP_MODEL);
            SetWindowText(detailHwnd,szModel);
        }
    }

    return ERROR_SUCCESS;
    
}

ULONG
FillNumberOfPortsText(
    IN HWND             DialogHwnd,
    IN PPORT_PARAMS     Params
    )
{
    HKEY  hDeviceKey;
    DWORD err,numOfPortsSize,numOfPorts;
    HWND  numportHwnd;
    TCHAR szText[10];

    err = ERROR_SUCCESS;

    if((hDeviceKey = SetupDiOpenDevRegKey(Params->DeviceInfoSet,
                                          Params->DeviceInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DEV,
                                          KEY_READ)) == INVALID_HANDLE_VALUE) {
        err = GetLastError();
        goto FillNPortsExit;
    }

    numOfPortsSize =