);
    extern int ASN1CALL ASN1Dec_RequestInProgress_cryptoTokens_ElmFn(ASN1decoding_t dec, PRequestInProgress_cryptoTokens val);
	extern void ASN1CALL ASN1Free_RequestInProgress_cryptoTokens_ElmFn(PRequestInProgress_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_UnknownMessageResponse_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnknownMessageResponse_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_UnknownMessageResponse_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnknownMessageResponse_cryptoTokens val);
	extern void ASN1CALL ASN1Free_UnknownMessageResponse_cryptoTokens_ElmFn(PUnknownMessageResponse_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_H225NonStandardMessage_cryptoTokens_ElmFn(ASN1encoding_t enc, PH225NonStandardMessage_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_H225NonStandardMessage_cryptoTokens_ElmFn(ASN1decoding_t dec, PH225NonStandardMessage_cryptoTokens val);
	extern void ASN1CALL ASN1Free_H225NonStandardMessage_cryptoTokens_ElmFn(PH225NonStandardMessage_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestNak_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestNak_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestNak_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestNak_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequestNak_cryptoTokens_ElmFn(PInfoRequestNak_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestAck_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestAck_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestAck_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestAck_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequestAck_cryptoTokens_ElmFn(PInfoRequestAck_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_cryptoTokens_ElmFn(PInfoRequestResponse_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequest_cryptoTokens_ElmFn(PInfoRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_DisengageReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_DisengageReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_DisengageReject_cryptoTokens_ElmFn(PDisengageReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_DisengageConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_DisengageConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_DisengageConfirm_cryptoTokens_ElmFn(PDisengageConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_DisengageRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_DisengageRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_DisengageRequest_cryptoTokens_ElmFn(PDisengageRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_LocationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_LocationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_LocationReject_cryptoTokens_ElmFn(PLocationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_LocationConfirm_cryptoTokens_ElmFn(PLocationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_LocationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_LocationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_LocationRequest_cryptoTokens_ElmFn(PLocationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_BandwidthReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_BandwidthReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_BandwidthReject_cryptoTokens_ElmFn(PBandwidthReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_BandwidthConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_BandwidthConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_BandwidthConfirm_cryptoTokens_ElmFn(PBandwidthConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_BandwidthRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_BandwidthRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_BandwidthRequest_cryptoTokens_ElmFn(PBandwidthRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_AdmissionReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_AdmissionReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_AdmissionReject_cryptoTokens_ElmFn(PAdmissionReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_cryptoTokens_ElmFn(PAdmissionConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_cryptoTokens_ElmFn(PAdmissionRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_UnregistrationReject_cryptoTokens_ElmFn(PUnregistrationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_UnregistrationConfirm_cryptoTokens_ElmFn(PUnregistrationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_cryptoTokens_ElmFn(PUnregistrationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_RegistrationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_RegistrationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_RegistrationReject_cryptoTokens_ElmFn(PRegistrationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_cryptoTokens_ElmFn(PRegistrationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_cryptoTokens_ElmFn(PRegistrationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_GatekeeperReject_cryptoTokens_ElmFn(PGatekeeperReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_GatekeeperConfirm_cryptoTokens_ElmFn(PGatekeeperConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_cryptoTokens_ElmFn(PGatekeeperRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Endpoint_cryptoTokens_ElmFn(ASN1encoding_t enc, PEndpoint_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Endpoint_cryptoTokens_ElmFn(ASN1decoding_t dec, PEndpoint_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Endpoint_cryptoTokens_ElmFn(PEndpoint_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Progress_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PProgress_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Progress_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PProgress_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Progress_UUIE_cryptoTokens_ElmFn(PProgress_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_conferences_ElmFn(ASN1encoding_t enc, PFacility_UUIE_conferences val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_conferences_ElmFn(ASN1decoding_t dec, PFacility_UUIE_conferences val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_conferences_ElmFn(PFacility_UUIE_conferences val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PFacility_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PFacility_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_cryptoTokens_ElmFn(PFacility_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PSetup_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PSetup_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_cryptoTokens_ElmFn(PSetup_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Connect_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PConnect_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Connect_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PConnect_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Connect_UUIE_cryptoTokens_ElmFn(PConnect_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_CallProceeding_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_CallProceeding_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_CallProceeding_UUIE_cryptoTokens_ElmFn(PCallProceeding_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Alerting_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Alerting_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Alerting_UUIE_cryptoTokens_ElmFn(PAlerting_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_pdu val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_pdu val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(PInfoRequestResponse_perCallInfo_Seq_pdu val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _H225PP_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\gkwsock.cpp ===
#include "stdafx.h"
#include "gkwsock.h"


// ASYNC_ACCEPT --------------------------------------------------------------------------


ASYNC_ACCEPT::ASYNC_ACCEPT (void)
{
	AcceptSocket = INVALID_SOCKET;
	ClientSocket = INVALID_SOCKET;
	AcceptFunc = NULL;
	AcceptFuncContext = NULL;
	ReferenceCount = 0L;
	StopNotifyEvent = NULL;
}

ASYNC_ACCEPT::~ASYNC_ACCEPT (void)
{
	assert (AcceptSocket == INVALID_SOCKET);
	assert (ClientSocket == INVALID_SOCKET);
	assert (ReferenceCount == 0L);
	assert (!StopNotifyEvent);
}

HRESULT ASYNC_ACCEPT::StartIo (
	IN	SOCKADDR_IN *		SocketAddress,
	IN	ASYNC_ACCEPT_FUNC	ArgAcceptFunc,
	IN	PVOID				ArgAcceptContext)
{
	HRESULT		Result;

	assert (SocketAddress);
	assert (ArgAcceptFunc);

	Lock ();

	if (AcceptSocket == INVALID_SOCKET && ReferenceCount == 0L) {
		// this object is not currently in use
		// so, it's acceptable to use it

		assert (!AcceptFunc);
		assert (!AcceptFuncContext);
		assert (!StopNotifyEvent);

		// This increase in reference count is needed
		// to shut down the service gracefully
		// Reference count on ASYNC_ACCEPT objects
		// will never drop to zero unless StopWait is called.
		// StopWait will call matching Release, which will
		// bring the reference count to the expected value of 0. 
		AddRef ();

		Result = StartIoLocked (SocketAddress);

		if (Result == S_OK) {

			assert (AcceptSocket != INVALID_SOCKET);

			AcceptFunc = ArgAcceptFunc;
			AcceptFuncContext = ArgAcceptContext;
		}
		else {

			Release ();
		}
	}
	else {
		Debug (_T("ASYNC_ACCEPT::StartIo: this object is already in use, must first call Stop and wait for sync counter\n"));
		Result = E_FAIL;
	}

	Unlock();

	return Result;
}


HRESULT ASYNC_ACCEPT::StartIoLocked (
	IN	SOCKADDR_IN *		SocketAddress)
{
	HRESULT		Result;
    BOOL        KeepaliveOption;

	assert (SocketAddress);
	assert (AcceptSocket == INVALID_SOCKET);
	assert (ClientSocket == INVALID_SOCKET);
	assert (ReferenceCount == 1);
	assert (!StopNotifyEvent);
  
	StopNotifyEvent = CreateEvent (NULL, TRUE, FALSE, NULL);

	if (!StopNotifyEvent) {

		Result = GetLastErrorAsResult ();
		DebugLastError (_T("ASYNC_ACCEPT::StartIoLocked: failed to create stop notify event\n"));

	} else {

		AcceptSocket = WSASocket (AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);

		if (AcceptSocket == INVALID_SOCKET) {

			Result = GetLastErrorAsResult ();
			DebugLastError (_T("ASYNC_ACCEPT::StartIoLocked: failed to create accept socket\n"));

		} else { 

            //
            // Set RCV and SND buffers to zero
            // Yes, it is ugly and bad practice but this is a QFE 
            // for details look up bug# WinSE 31054, 691666 (read both 35928 and 33546). 
            //
            ULONG Option = 0;
            setsockopt( AcceptSocket, SOL_SOCKET, SO_SNDBUF,
                        (PCHAR)&Option, sizeof(Option) );
            Option = 0;
            setsockopt( AcceptSocket, SOL_SOCKET, SO_SNDBUF,
                        (PCHAR)&Option, sizeof(Option) );


			if (bind (AcceptSocket, (SOCKADDR *) SocketAddress, sizeof (SOCKADDR_IN))) {

				Result = GetLastErrorAsResult ();
				DebugLastErrorF (_T("ASYNC_ACCEPT::StartIoLocked: failed to bind accept socket to address %08X:%04X\n"),
						ntohl (SocketAddress -> sin_addr.s_addr),
						ntohs (SocketAddress -> sin_port));

			} else {

                // Set keepalive on the socket
                KeepaliveOption = TRUE;
                if (SOCKET_ERROR == setsockopt (AcceptSocket, SOL_SOCKET, 
                                               SO_KEEPALIVE, (PCHAR) &KeepaliveOption, sizeof (KeepaliveOption)))
                {
                    Result = GetLastErrorAsResult ();
                    DebugLastError (_T("ASYNC_ACCEPT: Failed to set keepalive on accept socket.\n"));

                } else  {

                    if (listen (AcceptSocket, 10)) {

                        Result = GetLastErrorAsResult ();
                        DebugLastError (_T("ASYNC_ACCEPT::StartIoLocked: failed to listen on accept socket\n"));

                    } else {
                    
                        if (!BindIoCompletionCallback ((HANDLE) AcceptSocket, ASYNC_ACCEPT::IoCompletionCallback, 0)) {
                        
                            Result = GetLastErrorAsResult ();
                            DebugLastError (_T("ASYNC_ACCEPT::StartIoLocked: failed to bind i/o completion callback\n"));
                        
                        } else {
                        
                            Result = IssueAccept ();
                        
                            if (Result == S_OK) {
                        
                                return Result;
                        
                            }
                        }
                    }
                }
			}

			closesocket (AcceptSocket);
			AcceptSocket = INVALID_SOCKET;
		}

		CloseHandle (StopNotifyEvent);
		StopNotifyEvent = NULL;
	}

	return Result;
}


HRESULT ASYNC_ACCEPT::GetListenSocketAddress (
	OUT	SOCKADDR_IN *	ReturnSocketAddress)
{
	HRESULT		Result;
	INT			SocketAddressLength;

	Lock();

	if (AcceptSocket != INVALID_SOCKET) {

		SocketAddressLength = sizeof (SOCKADDR_IN);
		if (getsockname (AcceptSocket, (SOCKADDR *) ReturnSocketAddress, &SocketAddressLength) == SOCKET_ERROR) {
			Result = GetLastErrorAsResult();
		}
		else {
			Result = S_OK;
		}
	}
	else {
		Result = E_INVALIDARG;
	}

	Unlock();

	return Result;
}

HRESULT ASYNC_ACCEPT::IssueAccept (void)
{
	HRESULT Result;
	BOOL    KeepaliveOption;

	AssertLocked();
	assert (ClientSocket == INVALID_SOCKET);
//	assert (ReferenceCount == 0);

	ClientSocket = WSASocket (AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);
	if (ClientSocket == INVALID_SOCKET) {
		Result = GetLastErrorAsResult ();
		DebugLastError (_T("ASYNC_ACCEPT::IssueAccept: failed to create client socket.\n"));
		return Result;
	}
    //
    // Set RCV and SND buffers to zero
    // Yes, it is ugly and bad practice but this is a QFE 
    // for details look up bug# WinSE 31054, 691666 (read both 35928 and 33546). 
    //
    ULONG Option = 0;
    setsockopt( ClientSocket, SOL_SOCKET, SO_SNDBUF,
                (PCHAR)&Option, sizeof(Option) );
    Option = 0;
    setsockopt( ClientSocket, SOL_SOCKET, SO_SNDBUF,
                (PCHAR)&Option, sizeof(Option) );


	ZeroMemory (&Overlapped, sizeof (OVERLAPPED));

	AddRef();

	if (!AcceptEx (AcceptSocket,
		ClientSocket,
		ClientInfoBuffer,
		0,
		sizeof (SOCKADDR_IN) + 0x10,
		sizeof (SOCKADDR_IN) + 0x10,
		&ClientInfoBufferLength,
		&Overlapped)) {

		if (WSAGetLastError() != WSA_IO_PENDING) {
			// an error occurred
			Release ();
			Result = GetLastErrorAsResult ();
			DebugLastError (_T("ASYNC_ACCEPT::IssueAccept: failed to issue accept.\n"));
			return Result;
		} 

        // Set keepalive on the socket
        KeepaliveOption = TRUE;
        if (SOCKET_ERROR == setsockopt (ClientSocket, SOL_SOCKET, 
                                       SO_KEEPALIVE, (PCHAR) &KeepaliveOption, sizeof (KeepaliveOption)))
        {
			Release ();
            Result = GetLastErrorAsResult ();
            DebugLastError (_T("ASYNC_ACCEPT: IssueAccept: Failed to set keepalive on client socket.\n"));
			return Result;

        } 
	}

	return S_OK;
}

// static
void ASYNC_ACCEPT::IoCompletionCallback (DWORD Status, DWORD BytesTransferred, LPOVERLAPPED Overlapped)
{
	ASYNC_ACCEPT *	AsyncAccept;

	AsyncAccept = CONTAINING_RECORD (Overlapped, ASYNC_ACCEPT, Overlapped);

	AsyncAccept -> IoComplete (Status, BytesTransferred);

	AsyncAccept -> Release ();
}

void ASYNC_ACCEPT::IoComplete (DWORD Status, DWORD BytesTransferred)
{
	ASYNC_ACCEPT_FUNC	LocalAcceptFunc;
	PVOID				LocalAcceptFuncContext;
	SOCKADDR_IN			LocalAddressCopy;
	SOCKADDR_IN			RemoteAddressCopy;
	SOCKET				LocalClientSocket;
	SOCKADDR *			LocalAddress;
	INT					LocalAddressLength;
	SOCKADDR *			RemoteAddress;
	INT					RemoteAddressLength;
	INT					Result;

	Lock();

	assert (ClientSocket != INVALID_SOCKET);
	assert (ReferenceCount > 0);

	if (AcceptSocket == INVALID_SOCKET) {
		// Stop has been called
		// just immediately disconnect the client
		// we'll deal with object lifetime below

		closesocket (ClientSocket);
		ClientSocket = INVALID_SOCKET;
	}
	else {
		// the context is in the normal state
		// continue processing

		if (Status == ERROR_SUCCESS) {
			// a client has successfully connected

			GetAcceptExSockaddrs (
				ClientInfoBuffer,
				0,									// no initial recv
				sizeof (SOCKADDR_IN) + 0x10,
				sizeof (SOCKADDR_IN) + 0x10,
				&LocalAddress,
				&LocalAddressLength,
				&RemoteAddress,
				&RemoteAddressLength);

			// copy information out of the context
			// so that it will be valid after we issue a new accept and unlock
			LocalAddressCopy = *(SOCKADDR_IN *) LocalAddress;
			RemoteAddressCopy = *(SOCKADDR_IN *) RemoteAddress;
			LocalClientSocket = ClientSocket;
			LocalAcceptFunc = AcceptFunc;
			LocalAcceptFuncContext = AcceptFuncContext;

			ClientSocket = INVALID_SOCKET;

			// update the accept context
			Result = setsockopt (ClientSocket, SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT,
				reinterpret_cast <char *> (&AcceptSocket), sizeof (SOCKET));

			// issue a new accept
			IssueAccept();

			Unlock();

			(*LocalAcceptFunc) (LocalAcceptFuncContext, LocalClientSocket, &LocalAddressCopy, &RemoteAddressCopy);

			Lock();
		}
		else {
			// some error has occurred
			// this is usually (but not always) fatal

			assert (ClientSocket != INVALID_SOCKET);

			closesocket (ClientSocket);
			ClientSocket = INVALID_SOCKET;

			switch (Status) {
			case	STATUS_CANCELLED:
				Debug (_T("ASYNC_ACCEPT::IoComplete: accept failed, STATUS_CANCELED, original thread probably exited, resubmitting request...\n"));
				break;

			default:
				DebugError (Status, _T("AsyncAccept: async accept FAILED, sleeping 2000ms and retrying...\n"));
				Sleep (2000);
				break;
			}

			IssueAccept();
		}
	}

	Unlock();
}

void ASYNC_ACCEPT::StopWait (void)
{
	DWORD Status;

	Lock();

	if (AcceptSocket != INVALID_SOCKET) {

		// closing the socket cancels all pending i/o
		// we do NOT close the ClientSocket
		// only the i/o completion callback path may do that
		closesocket (AcceptSocket);
		AcceptSocket = INVALID_SOCKET;
		AcceptFunc = NULL;
		AcceptFuncContext = NULL;

		if (ClientSocket != INVALID_SOCKET) {
			// an accept is still pending. it may complete successfully,
			// or it may complete with STATUS_CANCELED (since we just closed AcceptSocket)
			// in either case, we must wait for the i/o complete callback to run.
			// AcceptSocket = INVALID_SOCKET is an indicator to the completion callback
			// that it should abort / return immediately. 

			assert (StopNotifyEvent);

			Unlock ();

			// This is the counterpart to the AddRef called in 
			// StartIoLocked (see comment there)
			Release ();

			DebugF (_T("ASYNC_ACCEPT::StopWait: waiting for i/o completion thread...\n"));
			
			Status = WaitForSingleObject (StopNotifyEvent, INFINITE);

			assert (Status == WAIT_OBJECT_0);

			Lock ();
		}
	}
	else {
		assert (!AcceptFunc);
		assert (!AcceptFuncContext);
	}

    if (StopNotifyEvent) {
        CloseHandle (StopNotifyEvent);
        StopNotifyEvent = NULL;
    }

	Unlock();
}


void ASYNC_ACCEPT::AddRef (void) {
	assert (ReferenceCount >= 0L);
	InterlockedIncrement (&ReferenceCount);
}


void ASYNC_ACCEPT::Release (void) {
	LONG Count;

	assert (ReferenceCount >= 0L);

	Count = InterlockedDecrement (&ReferenceCount);

	if (Count == 0L) {
		DebugF (_T("ASYNC_ACCEPT::Release -- Reference count dropped to zero. (this is %x)\n"), this);

		if (StopNotifyEvent) {
			SetEvent (StopNotifyEvent);
		}
		else {
			DebugF (_T("ASYNC_ACCEPT::Release  notify-event object was NULL (%x)\n"), this);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\emsend.cpp ===
/*
 * Copyright (c) 1998, Microsoft Corporation
 * File: emsend.cpp
 *
 * Purpose: 
 * 
 * Contains all the event manager routines which
 * manage the overlapped send operations
 * 
 *
 * History:
 *
 *   1. created 
 *       Ajay Chitturi (ajaych)  12-Jun-1998
 *
 */

#include "stdafx.h"
#include "cbridge.h"
#include "ovioctx.h"

static 
HRESULT 
EventMgrIssueSendHelperFn (
    IN PSendRecvContext pSendCtxt
    );

/*
 * This function allocates and returns an initialized SendRecvContext or
 * NULL in case of no memory
 */
static 
PSendRecvContext 
EventMgrCreateSendContext(
       IN SOCKET                   sock,
       IN OVERLAPPED_PROCESSOR &   rOvProcessor,
       IN BYTE                    *pBuf,
       IN DWORD                    BufLen
       )
{
    PSendRecvContext pSendContext;

    pSendContext = (PSendRecvContext) HeapAlloc (GetProcessHeap (),
						0, // No Flags
						sizeof(SendRecvContext));
    if (!pSendContext)
        return NULL;

    memset(pSendContext, 0, sizeof(SendRecvContext));
    // IO Context part - make this a separate inline function
    pSendContext->ioCtxt.reqType = EMGR_OV_IO_REQ_SEND;
    pSendContext->ioCtxt.pOvProcessor = &rOvProcessor;

    // Send Context part
    pSendContext->pbData = pBuf;
    pSendContext->dwDataLen = BufLen;

    pSendContext->sock = sock;
    pSendContext->dwTpktHdrBytesDone = 0;
    pSendContext->dwDataBytesDone = 0;

    return pSendContext;
}

void
EventMgrFreeSendContext(
       IN PSendRecvContext			pSendCtxt
       )
{
    // Socket, OvProcessor are owned by the 
    // Call Bridge Machine

    EM_FREE(pSendCtxt->pbData);
   
    HeapFree (GetProcessHeap (),
             0, // no flags
             pSendCtxt);
}



/*++

Routine Description:
    This function issues an asynch send of the buffer on the socket.
    Calling this passes the ownership of the buffer and this buffer is
    freed right here in case of an error. If the call succeeds,
    HandleSendCompletion() is responsible for freeing the buffer once
    all the bytes are sent.
    
Arguments:
    
Return Values:
    
--*/


HRESULT EventMgrIssueSend(
        IN SOCKET                   sock,
        IN OVERLAPPED_PROCESSOR &   rOverlappedProcessor,
        IN BYTE                    *pBuf,
        IN DWORD                    BufLen
        )
{
    PSendRecvContext pSendCtxt;
    HRESULT hRes;

    // Create Send overlapped I/O context
    pSendCtxt = EventMgrCreateSendContext(sock, 
                                          rOverlappedProcessor,
                                          pBuf, BufLen);
    if (!pSendCtxt)
    {
        return E_OUTOFMEMORY;
    }

    // TPKT is already filled in by the encode functions in pdu.cpp
    // Fill in the TPKT header based on the packet length
    // SetupTPKTHeader(pSendCtxt->pbTpktHdr, pSendCtxt->dwDataLen);

    // Do an asynchronous Write
    hRes = EventMgrIssueSendHelperFn(pSendCtxt);
    if (hRes != S_OK)
    {
        // This calls also frees the buffer.
        EventMgrFreeSendContext(pSendCtxt);
    }
    
    return hRes;
}

/*
 * Call WriteFile to start an overlapped request
 * on a socket.  Make sure we handle errors
 * that are recoverable.
 * 
 * pSendCtxt is not freed. It is freed only in HandleSendCompletion.
 * NO more TPKT stuff.
 */
static
HRESULT EventMgrIssueSendHelperFn(
        IN PSendRecvContext pSendCtxt
        )
{
    DWORD dwWritten, dwToSend;
    int   i = 0;
    BOOL  bResult;
    int   err;
    PBYTE pbSendBuf;  
    
    _ASSERTE(pSendCtxt);

	if (pSendCtxt ->ioCtxt.pOvProcessor->IsSocketValid())
	{
        dwToSend = pSendCtxt->dwDataLen - pSendCtxt->dwDataBytesDone;
        pbSendBuf = pSendCtxt->pbData + pSendCtxt->dwDataBytesDone;

        // Kick off the first write
        while (++i)
        {
            // make an overlapped I/O Request
            memset(&pSendCtxt->ioCtxt.ov, 0, sizeof(OVERLAPPED));

            pSendCtxt->ioCtxt.pOvProcessor->GetCallBridge().AddRef();

            bResult = WriteFile((HANDLE)pSendCtxt->sock,
                                pbSendBuf,
                                dwToSend,
                                &dwWritten,
                                &pSendCtxt->ioCtxt.ov
                                );
            // It succeeded immediately, but do not process it
            // here, wait for the completion packet.
            if (bResult)
                return S_OK;

            err = GetLastError();

            // This is what we want to happen, its not an error
            if (err == ERROR_IO_PENDING)
                return S_OK;

            pSendCtxt->ioCtxt.pOvProcessor->GetCallBridge().Release();

            // Handle recoverable errors
            if ( err == ERROR_INVALID_USER_BUFFER ||
                 err == ERROR_NOT_ENOUGH_QUOTA ||
                 err == ERROR_NOT_ENOUGH_MEMORY )
            {
                if (i <= 5) // I just picked a number
                {
                    Sleep(50);  // Wait around and try later
                    continue;
                }

                DebugF(_T("H323: System ran out of non-paged space.\n"));
            }

            // This means this is an unrecoverable error
            // one possibility is that that Call bridge could have closed
            // the socket some time in between
            break;
        }
        DebugF(_T("H323: WriteFile(sock: %d) failed. Error: %d.\n"), pSendCtxt->sock, err);

        return E_FAIL;

	} else {

        DebugF (_T("H323: 0x%x overlapped processor %x had invalid socket.\n"), 
            &pSendCtxt ->ioCtxt.pOvProcessor -> GetCallBridge (),
            pSendCtxt ->ioCtxt.pOvProcessor);

		return E_ABORT;
	}

	// Treat as success if overlapped process had its socket disabled
	return S_OK;
}

/* 
 * This function is called by the event loop when a send I/O completes.
 * The Call Bridge Machine's send call back function is called. 
 *
 * This function does not return any error code. In case of an error,
 * the call bridge machine is notified about the error in the callback.
 *
 * This function always frees pSendCtxt if another Send is not issued
 *
 * NO More TPKT stuff.
 */
void 
HandleSendCompletion (
     IN PSendRecvContext   pSendCtxt,
     IN DWORD              dwNumSent,
     IN DWORD              status
     )
{
    if (status != NO_ERROR || dwNumSent == 0)
    {
        // This means the send request failed
        HRESULT hRes;
        if (status != NO_ERROR)
        {
            hRes = E_FAIL; //the socket was closed
        }
        else 
        {
            hRes = HRESULT_FROM_WIN32_ERROR_CODE(status);
        }
        
        DebugF(_T("H323: 0x%x rror 0x%x on send callback. dwNumSent: %d\n"), 
                &pSendCtxt -> ioCtxt.pOvProcessor -> GetCallBridge (),
                status, dwNumSent);

        pSendCtxt->ioCtxt.pOvProcessor->SendCallback(hRes);
    }
    else 
    {
        pSendCtxt->dwDataBytesDone += dwNumSent;

        // Check if the send completed
        if (pSendCtxt->dwDataBytesDone < pSendCtxt->dwDataLen)
        {
            HRESULT hRes = S_OK;
            hRes = EventMgrIssueSendHelperFn(pSendCtxt);
            if (hRes != S_OK)
            {
                pSendCtxt->ioCtxt.pOvProcessor->SendCallback(hRes);
                EventMgrFreeSendContext(pSendCtxt);
            }
            return;
        }

        // The send completed. Make the callback
        pSendCtxt->ioCtxt.pOvProcessor->SendCallback(S_OK);
    }
        
    // clean up I/O context structure
    EventMgrFreeSendContext(pSendCtxt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\h245pp.c ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for Multimedia System Control (H.245) */

#include <windows.h>
#include "h245pp.h"

ASN1module_t H245PP_Module = NULL;

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1_errorCorrection(ASN1encoding_t enc, NewATMVCIndication_aal_aal1_errorCorrection *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1_clockRecovery(ASN1encoding_t enc, NewATMVCIndication_aal_aal1_clockRecovery *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(ASN1encoding_t enc, MiscellaneousCommand_type_progressiveRefinementStart_repeatCount *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode_eRM_recovery(ASN1encoding_t enc, V76LogicalChannelParameters_mode_eRM_recovery *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_extendedPAR_Set *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI_customPCF_Set(ASN1encoding_t enc, CustomPictureFormat_mPI_customPCF_Set *val);
static int ASN1CALL ASN1Enc_VCCapability_availableBitRates_type_rangeOfBitRates(ASN1encoding_t enc, VCCapability_availableBitRates_type_rangeOfBitRates *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(ASN1encoding_t enc, TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *val);
static int ASN1CALL ASN1Enc_VCCapability_availableBitRates_type(ASN1encoding_t enc, VCCapability_availableBitRates_type *val);
static int ASN1CALL ASN1Enc_H223Capability_h223MultiplexTableCapability_enhanced(ASN1encoding_t enc, H223Capability_h223MultiplexTableCapability_enhanced *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI_customPCF(ASN1encoding_t enc, CustomPictureFormat_mPI_customPCF *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_extendedPAR *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val);
static int ASN1CALL ASN1Enc_H223LogicalChannelParameters_adaptationLayerType_al3(ASN1encoding_t enc, H223LogicalChannelParameters_adaptationLayerType_al3 *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode_eRM(ASN1encoding_t enc, V76LogicalChannelParameters_mode_eRM *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_routing(ASN1encoding_t enc, UnicastAddress_iPSourceRouteAddress_routing *val);
static int ASN1CALL ASN1Enc_H223ModeParameters_adaptationLayerType_al3(ASN1encoding_t enc, H223ModeParameters_adaptationLayerType_al3 *val);
static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(ASN1encoding_t enc, SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val);
static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart(ASN1encoding_t enc, MiscellaneousCommand_type_progressiveRefinementStart *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_videoFastUpdateMB(ASN1encoding_t enc, MiscellaneousCommand_type_videoFastUpdateMB *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_videoFastUpdateGOB(ASN1encoding_t enc, MiscellaneousCommand_type_videoFastUpdateGOB *val);
static int ASN1CALL ASN1Enc_MiscellaneousIndication_type_videoNotDecodedMBs(ASN1encoding_t enc, MiscellaneousIndication_type_videoNotDecodedMBs *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal5(ASN1encoding_t enc, NewATMVCIndication_aal_aal5 *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1(ASN1encoding_t enc, NewATMVCIndication_aal_aal1 *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_reverseParameters_multiplex(ASN1encoding_t enc, NewATMVCIndication_reverseParameters_multiplex *val);
static int ASN1CALL ASN1Enc_UserInputIndication_signal_rtp(ASN1encoding_t enc, UserInputIndication_signal_rtp *val);
static int ASN1CALL ASN1Enc_UserInputIndication_signalUpdate_rtp(ASN1encoding_t enc, UserInputIndication_signalUpdate_rtp *val);
static int ASN1CALL ASN1Enc_UserInputIndication_signalUpdate(ASN1encoding_t enc, UserInputIndication_signalUpdate *val);
static int ASN1CALL ASN1Enc_UserInputIndication_signal(ASN1encoding_t enc, UserInputIndication_signal *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_reverseParameters(ASN1encoding_t enc, NewATMVCIndication_reverseParameters *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_multiplex(ASN1encoding_t enc, NewATMVCIndication_multiplex *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_aal(ASN1encoding_t enc, NewATMVCIndication_aal *val);
static int ASN1CALL ASN1Enc_JitterIndication_scope(ASN1encoding_t enc, JitterIndication_scope *val);
static int ASN1CALL ASN1Enc_FunctionNotSupported_cause(ASN1encoding_t enc, FunctionNotSupported_cause *val);
static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration_h223AnnexADoubleFlag(ASN1encoding_t enc, H223MultiplexReconfiguration_h223AnnexADoubleFlag *val);
static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration_h223ModeChange(ASN1encoding_t enc, H223MultiplexReconfiguration_h223ModeChange *val);
static int ASN1CALL ASN1Enc_EndSessionCommand_isdnOptions(ASN1encoding_t enc, EndSessionCommand_isdnOptions *val);
static int ASN1CALL ASN1Enc_EndSessionCommand_gstnOptions(ASN1encoding_t enc, EndSessionCommand_gstnOptions *val);
static int ASN1CALL ASN1Enc_FlowControlCommand_restriction(ASN1encoding_t enc, FlowControlCommand_restriction *val);
static int ASN1CALL ASN1Enc_FlowControlCommand_scope(ASN1encoding_t enc, FlowControlCommand_scope *val);
static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest(ASN1encoding_t enc, SendTerminalCapabilitySet_specificRequest *val);
static int ASN1CALL ASN1Enc_RemoteMCResponse_reject(ASN1encoding_t enc, RemoteMCResponse_reject *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_sendThisSourceResponse(ASN1encoding_t enc, ConferenceResponse_sendThisSourceResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_makeTerminalBroadcasterResponse(ASN1encoding_t enc, ConferenceResponse_makeTerminalBroadcasterResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_broadcastMyLogicalChannelResponse(ASN1encoding_t enc, ConferenceResponse_broadcastMyLogicalChannelResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_extensionAddressResponse(ASN1encoding_t enc, ConferenceResponse_extensionAddressResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_makeMeChairResponse(ASN1encoding_t enc, ConferenceResponse_makeMeChairResponse *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopReject_cause(ASN1encoding_t enc, MaintenanceLoopReject_cause *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopReject_type(ASN1encoding_t enc, MaintenanceLoopReject_type *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopAck_type(ASN1encoding_t enc, MaintenanceLoopAck_type *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopRequest_type(ASN1encoding_t enc, MaintenanceLoopRequest_type *val);
static int ASN1CALL ASN1Enc_G7231AnnexCMode_g723AnnexCAudioMode(ASN1encoding_t enc, G7231AnnexCMode_g723AnnexCAudioMode *val);
static int ASN1CALL ASN1Enc_IS13818AudioMode_multichannelType(ASN1encoding_t enc, IS13818AudioMode_multichannelType *val);
static int ASN1CALL ASN1Enc_IS13818AudioMode_audioSampling(ASN1encoding_t enc, IS13818AudioMode_audioSampling *val);
static int ASN1CALL ASN1Enc_IS13818AudioMode_audioLayer(ASN1encoding_t enc, IS13818AudioMode_audioLayer *val);
static int ASN1CALL ASN1Enc_IS11172AudioMode_multichannelType(ASN1encoding_t enc, IS11172AudioMode_multichannelType *val);
static int ASN1CALL ASN1Enc_IS11172AudioMode_audioSampling(ASN1encoding_t enc, IS11172AudioMode_audioSampling *val);
static int ASN1CALL ASN1Enc_IS11172AudioMode_audioLayer(ASN1encoding_t enc, IS11172AudioMode_audioLayer *val);
static int ASN1CALL ASN1Enc_AudioMode_g7231(ASN1encoding_t enc, AudioMode_g7231 *val);
static int ASN1CALL ASN1Enc_H263VideoMode_resolution(ASN1encoding_t enc, H263VideoMode_resolution *val);
static int ASN1CALL ASN1Enc_H262VideoMode_profileAndLevel(ASN1encoding_t enc, H262VideoMode_profileAndLevel *val);
static int ASN1CALL ASN1Enc_H261VideoMode_resolution(ASN1encoding_t enc, H261VideoMode_resolution *val);
static int ASN1CALL ASN1Enc_RequestModeReject_cause(ASN1encoding_t enc, RequestModeReject_cause *val);
static int ASN1CALL ASN1Enc_RequestModeAck_response(ASN1encoding_t enc, RequestModeAck_response *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryRelease_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryRelease_entryNumbers *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryRejectionDescriptions_cause(ASN1encoding_t enc, RequestMultiplexEntryRejectionDescriptions_cause *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryReject_entryNumbers *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryAck_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryAck_entryNumbers *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntry_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntry_entryNumbers *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendRelease_multiplexTableEntryNumber(ASN1encoding_t enc, MultiplexEntrySendRelease_multiplexTableEntryNumber *val);
static int ASN1CALL ASN1Enc_MultiplexEntryRejectionDescriptions_cause(ASN1encoding_t enc, MultiplexEntryRejectionDescriptions_cause *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendAck_multiplexTableEntryNumber(ASN1encoding_t enc, MultiplexEntrySendAck_multiplexTableEntryNumber *val);
static int ASN1CALL ASN1Enc_MultiplexElement_repeatCount(ASN1encoding_t enc, MultiplexElement_repeatCount *val);
static int ASN1CALL ASN1Enc_MultiplexElement_type(ASN1encoding_t enc, MultiplexElement_type *val);
static int ASN1CALL ASN1Enc_RequestChannelCloseReject_cause(ASN1encoding_t enc, RequestChannelCloseReject_cause *val);
static int ASN1CALL ASN1Enc_RequestChannelClose_reason(ASN1encoding_t enc, RequestChannelClose_reason *val);
static int ASN1CALL ASN1Enc_CloseLogicalChannel_reason(ASN1encoding_t enc, CloseLogicalChannel_reason *val);
static int ASN1CALL ASN1Enc_CloseLogicalChannel_source(ASN1encoding_t enc, CloseLogicalChannel_source *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelReject_cause(ASN1encoding_t enc, OpenLogicalChannelReject_cause *val);
static int ASN1CALL ASN1Enc_MulticastAddress_iP6Address(ASN1encoding_t enc, MulticastAddress_iP6Address *val);
static int ASN1CALL ASN1Enc_MulticastAddress_iPAddress(ASN1encoding_t enc, MulticastAddress_iPAddress *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress(ASN1encoding_t enc, UnicastAddress_iPSourceRouteAddress *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iP6Address(ASN1encoding_t enc, UnicastAddress_iP6Address *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPXAddress(ASN1encoding_t enc, UnicastAddress_iPXAddress *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPAddress(ASN1encoding_t enc, UnicastAddress_iPAddress *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode(ASN1encoding_t enc, V76LogicalChannelParameters_mode *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_suspendResume(ASN1encoding_t enc, V76LogicalChannelParameters_suspendResume *val);
static int ASN1CALL ASN1Enc_H223AnnexCArqParameters_numberOfRetransmissions(ASN1encoding_t enc, H223AnnexCArqParameters_numberOfRetransmissions *val);
static int ASN1CALL ASN1Enc_H223AL3MParameters_crcLength(ASN1encoding_t enc, H223AL3MParameters_crcLength *val);
static int ASN1CALL ASN1Enc_H223AL3MParameters_headerFormat(ASN1encoding_t enc, H223AL3MParameters_headerFormat *val);
static int ASN1CALL ASN1Enc_H223AL2MParameters_headerFEC(ASN1encoding_t enc, H223AL2MParameters_headerFEC *val);
static int ASN1CALL ASN1Enc_H223AL1MParameters_crcLength(ASN1encoding_t enc, H223AL1MParameters_crcLength *val);
static int ASN1CALL ASN1Enc_H223AL1MParameters_headerFEC(ASN1encoding_t enc, H223AL1MParameters_headerFEC *val);
static int ASN1CALL ASN1Enc_H223AL1MParameters_transferMode(ASN1encoding_t enc, H223AL1MParameters_transferMode *val);
static int ASN1CALL ASN1Enc_Q2931Address_address(ASN1encoding_t enc, Q2931Address_address *val);
static int ASN1CALL ASN1Enc_NetworkAccessParameters_t120SetupProcedure(ASN1encoding_t enc, NetworkAccessParameters_t120SetupProcedure *val);
static int ASN1CALL ASN1Enc_NetworkAccessParameters_distribution(ASN1encoding_t enc, NetworkAccessParameters_distribution *val);
static int ASN1CALL ASN1Enc_T84Profile_t84Restricted(ASN1encoding_t enc, T84Profile_t84Restricted *val);
static int ASN1CALL ASN1Enc_G7231AnnexCCapability_g723AnnexCAudioMode(ASN1encoding_t enc, G7231AnnexCCapability_g723AnnexCAudioMode *val);
static int ASN1CALL ASN1Enc_AudioCapability_g7231(ASN1encoding_t enc, AudioCapability_g7231 *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI(ASN1encoding_t enc, CustomPictureFormat_mPI *val);
static int ASN1CALL ASN1Enc_RefPictureSelection_videoBackChannelSend(ASN1encoding_t enc, RefPictureSelection_videoBackChannelSend *val);
static int ASN1CALL ASN1Enc_RefPictureSelection_additionalPictureMemory(ASN1encoding_t enc, RefPictureSelection_additionalPictureMemory *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyFrameMapping_frameSequence(ASN1encoding_t enc, RTPH263VideoRedundancyFrameMapping_frameSequence *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_containedThreads(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding_containedThreads *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding_frameToThreadMapping *val);
static int ASN1CALL ASN1Enc_RedundancyEncodingCapability_secondaryEncoding(ASN1encoding_t enc, PRedundancyEncodingCapability_secondaryEncoding *val);
static int ASN1CALL ASN1Enc_H2250Capability_mcCapability(ASN1encoding_t enc, H2250Capability_mcCapability *val);
static int ASN1CALL ASN1Enc_H223Capability_mobileOperationTransmitCapability(ASN1encoding_t enc, H223Capability_mobileOperationTransmitCapability *val);
static int ASN1CALL ASN1Enc_H223Capability_h223MultiplexTableCapability(ASN1encoding_t enc, H223Capability_h223MultiplexTableCapability *val);
static int ASN1CALL ASN1Enc_VCCapability_availableBitRates(ASN1encoding_t enc, VCCapability_availableBitRates *val);
static int ASN1CALL ASN1Enc_VCCapability_aal5(ASN1encoding_t enc, VCCapability_aal5 *val);
static int ASN1CALL ASN1Enc_VCCapability_aal1(ASN1encoding_t enc, VCCapability_aal1 *val);
static int ASN1CALL ASN1Enc_Capability_h233EncryptionReceiveCapability(ASN1encoding_t enc, Capability_h233EncryptionReceiveCapability *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject_cause(ASN1encoding_t enc, TerminalCapabilitySetReject_cause *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationReject_cause(ASN1encoding_t enc, MasterSlaveDeterminationReject_cause *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationAck_decision(ASN1encoding_t enc, MasterSlaveDeterminationAck_decision *val);
static int ASN1CALL ASN1Enc_NonStandardIdentifier_h221NonStandard(ASN1encoding_t enc, NonStandardIdentifier_h221NonStandard *val);
static int ASN1CALL ASN1Enc_NonStandardIdentifier(ASN1encoding_t enc, NonStandardIdentifier *val);
static int ASN1CALL ASN1Enc_MasterSlaveDetermination(ASN1encoding_t enc, MasterSlaveDetermination *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationAck(ASN1encoding_t enc, MasterSlaveDeterminationAck *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationReject(ASN1encoding_t enc, MasterSlaveDeterminationReject *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationRelease(ASN1encoding_t enc, MasterSlaveDeterminationRelease *val);
static int ASN1CALL ASN1Enc_CapabilityDescriptor(ASN1encoding_t enc, CapabilityDescriptor *val);
static int ASN1CALL ASN1Enc_AlternativeCapabilitySet(ASN1encoding_t enc, AlternativeCapabilitySet *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetAck(ASN1encoding_t enc, TerminalCapabilitySetAck *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject(ASN1encoding_t enc, TerminalCapabilitySetReject *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetRelease(ASN1encoding_t enc, TerminalCapabilitySetRelease *val);
static int ASN1CALL ASN1Enc_H222Capability(ASN1encoding_t enc, H222Capability *val);
static int ASN1CALL ASN1Enc_VCCapability(ASN1encoding_t enc, VCCapability *val);
static int ASN1CALL ASN1Enc_H223AnnexCCapability(ASN1encoding_t enc, H223AnnexCCapability *val);
static int ASN1CALL ASN1Enc_V75Capability(ASN1encoding_t enc, V75Capability *val);
static int ASN1CALL ASN1Enc_QOSMode(ASN1encoding_t enc, QOSMode *val);
static int ASN1CALL ASN1Enc_ATMParameters(ASN1encoding_t enc, ATMParameters *val);
static int ASN1CALL ASN1Enc_MediaTransportType(ASN1encoding_t enc, MediaTransportType *val);
static int ASN1CALL ASN1Enc_MediaChannelCapability(ASN1encoding_t enc, MediaChannelCapability *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyFrameMapping(ASN1encoding_t enc, RTPH263VideoRedundancyFrameMapping *val);
static int ASN1CALL ASN1Enc_MultipointCapability(ASN1encoding_t enc, MultipointCapability *val);
static int ASN1CALL ASN1Enc_MediaDistributionCapability(ASN1encoding_t enc, MediaDistributionCapability *val);
static int ASN1CALL ASN1Enc_H261VideoCapability(ASN1encoding_t enc, H261VideoCapability *val);
static int ASN1CALL ASN1Enc_H262VideoCapability(ASN1encoding_t enc, H262VideoCapability *val);
static int ASN1CALL ASN1Enc_EnhancementLayerInfo(ASN1encoding_t enc, EnhancementLayerInfo *val);
static int ASN1CALL ASN1Enc_TransparencyParameters(ASN1encoding_t enc, TransparencyParameters *val);
static int ASN1CALL ASN1Enc_RefPictureSelection(ASN1encoding_t enc, RefPictureSelection *val);
static int ASN1CALL ASN1Enc_CustomPictureClockFrequency(ASN1encoding_t enc, CustomPictureClockFrequency *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat(ASN1encoding_t enc, CustomPictureFormat *val);
static int ASN1CALL ASN1Enc_H263ModeComboFlags(ASN1encoding_t enc, H263ModeComboFlags *val);
static int ASN1CALL ASN1Enc_IS11172VideoCapability(ASN1encoding_t enc, IS11172VideoCapability *val);
static int ASN1CALL ASN1Enc_G7231AnnexCCapability(ASN1encoding_t enc, G7231AnnexCCapability *val);
static int ASN1CALL ASN1Enc_IS11172AudioCapability(ASN1encoding_t enc, IS11172AudioCapability *val);
static int ASN1CALL ASN1Enc_IS13818AudioCapability(ASN1encoding_t enc, IS13818AudioCapability *val);
static int ASN1CALL ASN1Enc_GSMAudioCapability(ASN1encoding_t enc, GSMAudioCapability *val);
static int ASN1CALL ASN1Enc_V42bis(ASN1encoding_t enc, V42bis *val);
static int ASN1CALL ASN1Enc_T84Profile(ASN1encoding_t enc, T84Profile *val);
static int ASN1CALL ASN1Enc_ConferenceCapability(ASN1encoding_t enc, ConferenceCapability *val);
static int ASN1CALL ASN1Enc_Q2931Address(ASN1encoding_t enc, Q2931Address *val);
static int ASN1CALL ASN1Enc_V75Parameters(ASN1encoding_t enc, V75Parameters *val);
static int ASN1CALL ASN1Enc_H222LogicalChannelParameters(ASN1encoding_t enc, H222LogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_H223AL2MParameters(ASN1encoding_t enc, H223AL2MParameters *val);
static int ASN1CALL ASN1Enc_H223AnnexCArqParameters(ASN1encoding_t enc, H223AnnexCArqParameters *val);
static int ASN1CALL ASN1Enc_CRCLength(ASN1encoding_t enc, CRCLength *val);
static int ASN1CALL ASN1Enc_EscrowData(ASN1encoding_t enc, EscrowData *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelReject(ASN1encoding_t enc, OpenLogicalChannelReject *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelConfirm(ASN1encoding_t enc, OpenLogicalChannelConfirm *val);
static int ASN1CALL ASN1Enc_CloseLogicalChannel(ASN1encoding_t enc, CloseLogicalChannel *val);
static int ASN1CALL ASN1Enc_CloseLogicalChannelAck(ASN1encoding_t enc, CloseLogicalChannelAck *val);
static int ASN1CALL ASN1Enc_RequestChannelCloseAck(ASN1encoding_t enc, RequestChannelCloseAck *val);
static int ASN1CALL ASN1Enc_RequestChannelCloseReject(ASN1encoding_t enc, RequestChannelCloseReject *val);
static int ASN1CALL ASN1Enc_RequestChannelCloseRelease(ASN1encoding_t enc, RequestChannelCloseRelease *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySend(ASN1encoding_t enc, MultiplexEntrySend *val);
static int ASN1CALL ASN1Enc_MultiplexElement(ASN1encoding_t enc, MultiplexElement *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendAck(ASN1encoding_t enc, MultiplexEntrySendAck *val);
static int ASN1CALL ASN1Enc_MultiplexEntryRejectionDescriptions(ASN1encoding_t enc, MultiplexEntryRejectionDescriptions *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendRelease(ASN1encoding_t enc, MultiplexEntrySendRelease *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntry(ASN1encoding_t enc, RequestMultiplexEntry *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryAck(ASN1encoding_t enc, RequestMultiplexEntryAck *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryRejectionDescriptions(ASN1encoding_t enc, RequestMultiplexEntryRejectionDescriptions *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryRelease(ASN1encoding_t enc, RequestMultiplexEntryRelease *val);
static int ASN1CALL ASN1Enc_RequestMode(ASN1encoding_t enc, RequestMode *val);
static int ASN1CALL ASN1Enc_RequestModeAck(ASN1encoding_t enc, RequestModeAck *val);
static int ASN1CALL ASN1Enc_RequestModeReject(ASN1encoding_t enc, RequestModeReject *val);
static int ASN1CALL ASN1Enc_RequestModeRelease(ASN1encoding_t enc, RequestModeRelease *val);
static int ASN1CALL ASN1Enc_V76ModeParameters(ASN1encoding_t enc, V76ModeParameters *val);
static int ASN1CALL ASN1Enc_H261VideoMode(ASN1encoding_t enc, H261VideoMode *val);
static int ASN1CALL ASN1Enc_H262VideoMode(ASN1encoding_t enc, H262VideoMode *val);
static int ASN1CALL ASN1Enc_IS11172VideoMode(ASN1encoding_t enc, IS11172VideoMode *val);
static int ASN1CALL ASN1Enc_IS11172AudioMode(ASN1encoding_t enc, IS11172AudioMode *val);
static int ASN1CALL ASN1Enc_IS13818AudioMode(ASN1encoding_t enc, IS13818AudioMode *val);
static int ASN1CALL ASN1Enc_G7231AnnexCMode(ASN1encoding_t enc, G7231AnnexCMode *val);
static int ASN1CALL ASN1Enc_RoundTripDelayRequest(ASN1encoding_t enc, RoundTripDelayRequest *val);
static int ASN1CALL ASN1Enc_RoundTripDelayResponse(ASN1encoding_t enc, RoundTripDelayResponse *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopRequest(ASN1encoding_t enc, MaintenanceLoopRequest *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopAck(ASN1encoding_t enc, MaintenanceLoopAck *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopReject(ASN1encoding_t enc, MaintenanceLoopReject *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopOffCommand(ASN1encoding_t enc, MaintenanceLoopOffCommand *val);
static int ASN1CALL ASN1Enc_CommunicationModeCommand(ASN1encoding_t enc, CommunicationModeCommand *val);
static int ASN1CALL ASN1Enc_CommunicationModeRequest(ASN1encoding_t enc, CommunicationModeRequest *val);
static int ASN1CALL ASN1Enc_CommunicationModeResponse(ASN1encoding_t enc, CommunicationModeResponse *val);
static int ASN1CALL ASN1Enc_Criteria(ASN1encoding_t enc, Criteria *val);
static int ASN1CALL ASN1Enc_TerminalLabel(ASN1encoding_t enc, TerminalLabel *val);
static int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse(ASN1encoding_t enc, RequestAllTerminalIDsResponse *val);
static int ASN1CALL ASN1Enc_TerminalInformation(ASN1encoding_t enc, TerminalInformation *val);
static int ASN1CALL ASN1Enc_RemoteMCRequest(ASN1encoding_t enc, RemoteMCRequest *val);
static int ASN1CALL ASN1Enc_RemoteMCResponse(ASN1encoding_t enc, RemoteMCResponse *val);
static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet(ASN1encoding_t enc, SendTerminalCapabilitySet *val);
static int ASN1CALL ASN1Enc_FlowControlCommand(ASN1encoding_t enc, FlowControlCommand *val);
static int ASN1CALL ASN1Enc_SubstituteConferenceIDCommand(ASN1encoding_t enc, SubstituteConferenceIDCommand *val);
static int ASN1CALL ASN1Enc_KeyProtectionMethod(ASN1encoding_t enc, KeyProtectionMethod *val);
static int ASN1CALL ASN1Enc_EncryptionUpdateRequest(ASN1encoding_t enc, EncryptionUpdateRequest *val);
static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration(ASN1encoding_t enc, H223MultiplexReconfiguration *val);
static int ASN1CALL ASN1Enc_FunctionNotSupported(ASN1encoding_t enc, FunctionNotSupported *val);
static int ASN1CALL ASN1Enc_TerminalYouAreSeeingInSubPictureNumber(ASN1encoding_t enc, TerminalYouAreSeeingInSubPictureNumber *val);
static int ASN1CALL ASN1Enc_VideoIndicateCompose(ASN1encoding_t enc, VideoIndicateCompose *val);
static int ASN1CALL ASN1Enc_ConferenceIndication(ASN1encoding_t enc, ConferenceIndication *val);
static int ASN1CALL ASN1Enc_JitterIndication(ASN1encoding_t enc, JitterIndication *val);
static int ASN1CALL ASN1Enc_H223SkewIndication(ASN1encoding_t enc, H223SkewIndication *val);
static int ASN1CALL ASN1Enc_H2250MaximumSkewIndication(ASN1encoding_t enc, H2250MaximumSkewIndication *val);
static int ASN1CALL ASN1Enc_VendorIdentification(ASN1encoding_t enc, VendorIdentification *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication(ASN1encoding_t enc, NewATMVCIndication *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(ASN1encoding_t enc, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val);
static int ASN1CALL ASN1Enc_MultiplexElement_type_subElementList(ASN1encoding_t enc, PMultiplexElement_type_subElementList *val);
static int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation(ASN1encoding_t enc, PRequestAllTerminalIDsResponse_terminalInformation *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_terminalCertificateResponse(ASN1encoding_t enc, ConferenceResponse_terminalCertificateResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_chairTokenOwnerResponse(ASN1encoding_t enc, ConferenceResponse_chairTokenOwnerResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_terminalListResponse(ASN1encoding_t enc, ConferenceResponse_terminalListResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_passwordResponse(ASN1encoding_t enc, ConferenceResponse_passwordResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_conferenceIDResponse(ASN1encoding_t enc, ConferenceResponse_conferenceIDResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_terminalIDResponse(ASN1encoding_t enc, ConferenceResponse_terminalIDResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_mCTerminalIDResponse(ASN1encoding_t enc, ConferenceResponse_mCTerminalIDResponse *val);
static int ASN1CALL ASN1Enc_ConferenceRequest_requestTerminalCertificate(ASN1encoding_t enc, ConferenceRequest_requestTerminalCertificate *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject_rejectionDescriptions(ASN1encoding_t enc, RequestMultiplexEntryReject_rejectionDescriptions *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendReject_rejectionDescriptions(ASN1encoding_t enc, MultiplexEntrySendReject_rejectionDescriptions *val);
static int ASN1CALL ASN1Enc_MultiplexEntryDescriptor_elementList(ASN1encoding_t enc, MultiplexEntryDescriptor_elementList *val);
static int ASN1CALL ASN1Enc_EncryptionSync_escrowentry(ASN1encoding_t enc, PEncryptionSync_escrowentry *val);
static int ASN1CALL ASN1Enc_H223AL3MParameters_arqType(ASN1encoding_t enc, H223AL3MParameters_arqType *val);
static int ASN1CALL ASN1Enc_H223AL1MParameters_arqType(ASN1encoding_t enc, H223AL1MParameters_arqType *val);
static int ASN1CALL ASN1Enc_H263VideoModeCombos_h263VideoCoupledModes(ASN1encoding_t enc, H263VideoModeCombos_h263VideoCoupledModes *val);
static int ASN1CALL ASN1Enc_H263Options_customPictureFormat(ASN1encoding_t enc, PH263Options_customPictureFormat *val);
static int ASN1CALL ASN1Enc_H263Options_customPictureClockFrequency(ASN1encoding_t enc, PH263Options_customPictureClockFrequency *val);
static int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability *val);
static int ASN1CALL ASN1Enc_TransportCapability_mediaChannelCapabilities(ASN1encoding_t enc, TransportCapability_mediaChannelCapabilities *val);
static int ASN1CALL ASN1Enc_H222Capability_vcCapability(ASN1encoding_t enc, PH222Capability_vcCapability *val);
static int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityDescriptors(ASN1encoding_t enc, TerminalCapabilitySet_capabilityDescriptors *val);
static int ASN1CALL ASN1Enc_NonStandardParameter(ASN1encoding_t enc, NonStandardParameter *val);
static int ASN1CALL ASN1Enc_H223Capability(ASN1encoding_t enc, H223Capability *val);
static int ASN1CALL ASN1Enc_V76Capability(ASN1encoding_t enc, V76Capability *val);
static int ASN1CALL ASN1Enc_RSVPParameters(ASN1encoding_t enc, RSVPParameters *val);
static int ASN1CALL ASN1Enc_QOSCapability(ASN1encoding_t enc, QOSCapability *val);
static int ASN1CALL ASN1Enc_TransportCapability(ASN1encoding_t enc, TransportCapability *val);
static int ASN1CALL ASN1Enc_RedundancyEncodingMethod(ASN1encoding_t enc, RedundancyEncodingMethod *val);
static int ASN1CALL ASN1Enc_H263Options(ASN1encoding_t enc, H263Options *val);
static int ASN1CALL ASN1Enc_H263VideoModeCombos(ASN1encoding_t enc, H263VideoModeCombos *val);
static int ASN1CALL ASN1Enc_AudioCapability(ASN1encoding_t enc, AudioCapability *val);
static int ASN1CALL ASN1Enc_CompressionType(ASN1encoding_t enc, CompressionType *val);
static int ASN1CALL ASN1Enc_MediaEncryptionAlgorithm(ASN1encoding_t enc, MediaEncryptionAlgorithm *val);
static int ASN1CALL ASN1Enc_AuthenticationCapability(ASN1encoding_t enc, AuthenticationCapability *val);
static int ASN1CALL ASN1Enc_IntegrityCapability(ASN1encoding_t enc, IntegrityCapability *val);
static int ASN1CALL ASN1Enc_H223AL1MParameters(ASN1encoding_t enc, H223AL1MParameters *val);
static int ASN1CALL ASN1Enc_H223AL3MParameters(ASN1encoding_t enc, H223AL3MParameters *val);
static int ASN1CALL ASN1Enc_V76HDLCParameters(ASN1encoding_t enc, V76HDLCParameters *val);
static int ASN1CALL ASN1Enc_UnicastAddress(ASN1encoding_t enc, UnicastAddress *val);
static int ASN1CALL ASN1Enc_MulticastAddress(ASN1encoding_t enc, MulticastAddress *val);
static int ASN1CALL ASN1Enc_EncryptionSync(ASN1encoding_t enc, EncryptionSync *val);
static int ASN1CALL ASN1Enc_RequestChannelClose(ASN1encoding_t enc, RequestChannelClose *val);
static int ASN1CALL ASN1Enc_MultiplexEntryDescriptor(ASN1encoding_t enc, MultiplexEntryDescriptor *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendReject(ASN1encoding_t enc, MultiplexEntrySendReject *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject(ASN1encoding_t enc, RequestMultiplexEntryReject *val);
static int ASN1CALL ASN1Enc_H263VideoMode(ASN1encoding_t enc, H263VideoMode *val);
static int ASN1CALL ASN1Enc_AudioMode(ASN1encoding_t enc, AudioMode *val);
static int ASN1CALL ASN1Enc_EncryptionMode(ASN1encoding_t enc, EncryptionMode *val);
static int ASN1CALL ASN1Enc_ConferenceRequest(ASN1encoding_t enc, ConferenceRequest *val);
static int ASN1CALL ASN1Enc_CertSelectionCriteria(ASN1encoding_t enc, PCertSelectionCriteria *val);
static int ASN1CALL ASN1Enc_ConferenceResponse(ASN1encoding_t enc, ConferenceResponse *val);
static int ASN1CALL ASN1Enc_EndSessionCommand(ASN1encoding_t enc, EndSessionCommand *val);
static int ASN1CALL ASN1Enc_ConferenceCommand(ASN1encoding_t enc, ConferenceCommand *val);
static int ASN1CALL ASN1Enc_UserInputIndication_userInputSupportIndication(ASN1encoding_t enc, UserInputIndication_userInputSupportIndication *val);
static int ASN1CALL ASN1Enc_MiscellaneousIndication_type(ASN1encoding_t enc, MiscellaneousIndication_type *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type(ASN1encoding_t enc, MiscellaneousCommand_type *val);
static int ASN1CALL ASN1Enc_EncryptionCommand_encryptionAlgorithmID(ASN1encoding_t enc, EncryptionCommand_encryptionAlgorithmID *val);
static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard *val);
static int ASN1CALL ASN1Enc_RedundancyEncodingMode_secondaryEncoding(ASN1encoding_t enc, RedundancyEncodingMode_secondaryEncoding *val);
static int ASN1CALL ASN1Enc_H223ModeParameters_adaptationLayerType(ASN1encoding_t enc, H223ModeParameters_adaptationLayerType *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard *val);
static int ASN1CALL ASN1Enc_RTPPayloadType_payloadDescriptor(ASN1encoding_t enc, RTPPayloadType_payloadDescriptor *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard *val);
static int ASN1CALL ASN1Enc_H223LogicalChannelParameters_adaptationLayerType(ASN1encoding_t enc, H223LogicalChannelParameters_adaptationLayerType *val);
static int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData(ASN1encoding_t enc, PConferenceCapability_nonStandardData *val);
static int ASN1CALL ASN1Enc_UserInputCapability_nonStandard(ASN1encoding_t enc, UserInputCapability_nonStandard *val);
static int ASN1CALL ASN1Enc_DataProtocolCapability_v76wCompression(ASN1encoding_t enc, DataProtocolCapability_v76wCompression *val);
static int ASN1CALL ASN1Enc_H263Options_modeCombos(ASN1encoding_t enc, PH263Options_modeCombos *val);
static int ASN1CALL ASN1Enc_TransportCapability_qOSCapabilities(ASN1encoding_t enc, PTransportCapability_qOSCapabilities *val);
static int ASN1CALL ASN1Enc_NonStandardMessage(ASN1encoding_t enc, NonStandardMessage *val);
static int ASN1CALL ASN1Enc_RedundancyEncodingCapability(ASN1encoding_t enc, RedundancyEncodingCapability *val);
static int ASN1CALL ASN1Enc_H263VideoCapability(ASN1encoding_t enc, H263VideoCapability *val);
static int ASN1CALL ASN1Enc_EnhancementOptions(ASN1encoding_t enc, EnhancementOptions *val);
static int ASN1CALL ASN1Enc_DataProtocolCapability(ASN1encoding_t enc, DataProtocolCapability *val);
static int ASN1CALL ASN1Enc_EncryptionAuthenticationAndIntegrity(ASN1encoding_t enc, EncryptionAuthenticationAndIntegrity *val);
static int ASN1CALL ASN1Enc_EncryptionCapability(ASN1encoding_t enc, PEncryptionCapability *val);
static int ASN1CALL ASN1Enc_UserInputCapability(ASN1encoding_t enc, UserInputCapability *val);
static int ASN1CALL ASN1Enc_H223LogicalChannelParameters(ASN1encoding_t enc, H223LogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters(ASN1encoding_t enc, V76LogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_RTPPayloadType(ASN1encoding_t enc, RTPPayloadType *val);
static int ASN1CALL ASN1Enc_H245TransportAddress(ASN1encoding_t enc, H245TransportAddress *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters(ASN1encoding_t enc, H2250LogicalChannelAckParameters *val);
static int ASN1CALL ASN1Enc_H223ModeParameters(ASN1encoding_t enc, H223ModeParameters *val);
static int ASN1CALL ASN1Enc_RedundancyEncodingMode(ASN1encoding_t enc, RedundancyEncodingMode *val);
static int ASN1CALL ASN1Enc_VideoMode(ASN1encoding_t enc, VideoMode *val);
static int ASN1CALL ASN1Enc_EncryptionCommand(ASN1encoding_t enc, EncryptionCommand *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand(ASN1encoding_t enc, MiscellaneousCommand *val);
static int ASN1CALL ASN1Enc_MiscellaneousIndication(ASN1encoding_t enc, MiscellaneousIndication *val);
static int ASN1CALL ASN1Enc_MCLocationIndication(ASN1encoding_t enc, MCLocationIndication *val);
static int ASN1CALL ASN1Enc_UserInputIndication(ASN1encoding_t enc, UserInputIndication *val);
static int ASN1CALL ASN1Enc_DataApplicationCapability_application_nlpid(ASN1encoding_t enc, DataApplicationCapability_application_nlpid *val);
static int ASN1CALL ASN1Enc_DataApplicationCapability_application_t84(ASN1encoding_t enc, DataApplicationCapability_application_t84 *val);
static int ASN1CALL ASN1Enc_DataMode_application_nlpid(ASN1encoding_t enc, DataMode_application_nlpid *val);
static int ASN1CALL ASN1Enc_DataMode_application(ASN1encoding_t enc, DataMode_application *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_forwardMultiplexAckParameters(ASN1encoding_t enc, OpenLogicalChannelAck_forwardMultiplexAckParameters *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_mediaPacketization(ASN1encoding_t enc, H2250LogicalChannelParameters_mediaPacketization *val);
static int ASN1CALL ASN1Enc_NetworkAccessParameters_networkAddress(ASN1encoding_t enc, NetworkAccessParameters_networkAddress *val);
static int ASN1CALL ASN1Enc_DataApplicationCapability_application(ASN1encoding_t enc, DataApplicationCapability_application *val);
static int ASN1CALL ASN1Enc_EnhancementLayerInfo_spatialEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_spatialEnhancement *val);
static int ASN1CALL ASN1Enc_EnhancementLayerInfo_snrEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_snrEnhancement *val);
static int ASN1CALL ASN1Enc_MediaPacketizationCapability_rtpPayloadType(ASN1encoding_t enc, MediaPacketizationCapability_rtpPayloadType *val);
static int ASN1CALL ASN1Enc_H2250Capability_redundancyEncodingCapability(ASN1encoding_t enc, PH2250Capability_redundancyEncodingCapability *val);
static int ASN1CALL ASN1Enc_CommandMessage(ASN1encoding_t enc, CommandMessage *val);
static int ASN1CALL ASN1Enc_H235SecurityCapability(ASN1encoding_t enc, H235SecurityCapability *val);
static int ASN1CALL ASN1Enc_MediaPacketizationCapability(ASN1encoding_t enc, MediaPacketizationCapability *val);
static int ASN1CALL ASN1Enc_VideoCapability(ASN1encoding_t enc, VideoCapability *val);
static int ASN1CALL ASN1Enc_BEnhancementParameters(ASN1encoding_t enc, BEnhancementParameters *val);
static int ASN1CALL ASN1Enc_DataApplicationCapability(ASN1encoding_t enc, DataApplicationCapability *val);
static int ASN1CALL ASN1Enc_NetworkAccessParameters(ASN1encoding_t enc, NetworkAccessParameters *val);
static int ASN1CALL ASN1Enc_H2250ModeParameters(ASN1encoding_t enc, H2250ModeParameters *val);
static int ASN1CALL ASN1Enc_DataMode(ASN1encoding_t enc, DataMode *val);
static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_dataType(ASN1encoding_t enc, CommunicationModeTableEntry_dataType *val);
static int ASN1CALL ASN1Enc_H235Mode_mediaMode(ASN1encoding_t enc, H235Mode_mediaMode *val);
static int ASN1CALL ASN1Enc_H235Media_mediaType(ASN1encoding_t enc, H235Media_mediaType *val);
static int ASN1CALL ASN1Enc_EnhancementLayerInfo_bPictureEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_bPictureEnhancement *val);
static int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData(ASN1encoding_t enc, PMediaDistributionCapability_distributedData *val);
static int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData *val);
static int ASN1CALL ASN1Enc_Capability(ASN1encoding_t enc, Capability *val);
static int ASN1CALL ASN1Enc_H2250Capability(ASN1encoding_t enc, H2250Capability *val);
static int ASN1CALL ASN1Enc_H235Media(ASN1encoding_t enc, H235Media *val);
static int ASN1CALL ASN1Enc_H235Mode(ASN1encoding_t enc, H235Mode *val);
static int ASN1CALL ASN1Enc_ModeElement_type(ASN1encoding_t enc, ModeElement_type *val);
static int ASN1CALL ASN1Enc_CapabilityTableEntry(ASN1encoding_t enc, CapabilityTableEntry *val);
static int ASN1CALL ASN1Enc_MultiplexCapability(ASN1encoding_t enc, MultiplexCapability *val);
static int ASN1CALL ASN1Enc_DataType(ASN1encoding_t enc, DataType *val);
static int ASN1CALL ASN1Enc_RedundancyEncoding(ASN1encoding_t enc, RedundancyEncoding *val);
static int ASN1CALL ASN1Enc_ModeElement(ASN1encoding_t enc, ModeElement *val);
static int ASN1CALL ASN1Enc_CommunicationModeTableEntry(ASN1encoding_t enc, CommunicationModeTableEntry *val);
static int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable *val);
static int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySet(ASN1encoding_t enc, TerminalCapabilitySet *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters(ASN1encoding_t enc, H2250LogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_ModeDescription(ASN1encoding_t enc, ModeDescription *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Enc_RequestMode_requestedModes(ASN1encoding_t enc, PRequestMode_requestedModes *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannelAck_reverseLogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannel_reverseLogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannel_forwardLogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel(ASN1encoding_t enc, OpenLogicalChannel *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelAck(ASN1encoding_t enc, OpenLogicalChannelAck *val);
static int ASN1CALL ASN1Enc_RequestMessage(ASN1encoding_t enc, RequestMessage *val);
static int ASN1CALL ASN1Enc_ResponseMessage(ASN1encoding_t enc, ResponseMessage *val);
static int ASN1CALL ASN1Enc_FastConnectOLC(ASN1encoding_t enc, FastConnectOLC *val);
static int ASN1CALL ASN1Enc_FunctionNotUnderstood(ASN1encoding_t enc, FunctionNotUnderstood *val);
static int ASN1CALL ASN1Enc_IndicationMessage(ASN1encoding_t enc, IndicationMessage *val);
static int ASN1CALL ASN1Enc_MultimediaSystemControlMessage(ASN1encoding_t enc, MultimediaSystemControlMessage *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1_errorCorrection(ASN1decoding_t dec, NewATMVCIndication_aal_aal1_errorCorrection *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1_clockRecovery(ASN1decoding_t dec, NewATMVCIndication_aal_aal1_clockRecovery *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(ASN1decoding_t dec, MiscellaneousCommand_type_progressiveRefinementStart_repeatCount *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode_eRM_recovery(ASN1decoding_t dec, V76LogicalChannelParameters_mode_eRM_recovery *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_extendedPAR_Set *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI_customPCF_Set(ASN1decoding_t dec, CustomPictureFormat_mPI_customPCF_Set *val);
static int ASN1CALL ASN1Dec_VCCapability_availableBitRates_type_rangeOfBitRates(ASN1decoding_t dec, VCCapability_availableBitRates_type_rangeOfBitRates *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(ASN1decoding_t dec, TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *val);
static int ASN1CALL ASN1Dec_VCCapability_availableBitRates_type(ASN1decoding_t dec, VCCapability_availableBitRates_type *val);
static int ASN1CALL ASN1Dec_H223Capability_h223MultiplexTableCapability_enhanced(ASN1decoding_t dec, H223Capability_h223MultiplexTableCapability_enhanced *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI_customPCF(ASN1decoding_t dec, CustomPictureFormat_mPI_customPCF *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_extendedPAR *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val);
static int ASN1CALL ASN1Dec_H223LogicalChannelParameters_adaptationLayerType_al3(ASN1decoding_t dec, H223LogicalChannelParameters_adaptationLayerType_al3 *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode_eRM(ASN1decoding_t dec, V76LogicalChannelParameters_mode_eRM *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_routing(ASN1decoding_t dec, UnicastAddress_iPSourceRouteAddress_routing *val);
static int ASN1CALL ASN1Dec_H223ModeParameters_adaptationLayerType_al3(ASN1decoding_t dec, H223ModeParameters_adaptationLayerType_al3 *val);
static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(ASN1decoding_t dec, SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val);
static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart(ASN1decoding_t dec, MiscellaneousCommand_type_progressiveRefinementStart *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_videoFastUpdateMB(ASN1decoding_t dec, MiscellaneousCommand_type_videoFastUpdateMB *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_videoFastUpdateGOB(ASN1decoding_t dec, MiscellaneousCommand_type_videoFastUpdateGOB *val);
static int ASN1CALL ASN1Dec_MiscellaneousIndication_type_videoNotDecodedMBs(ASN1decoding_t dec, MiscellaneousIndication_type_videoNotDecodedMBs *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal5(ASN1decoding_t dec, NewATMVCIndication_aal_aal5 *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1(ASN1decoding_t dec, NewATMVCIndication_aal_aal1 *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_reverseParameters_multiplex(ASN1decoding_t dec, NewATMVCIndication_reverseParameters_multiplex *val);
static int ASN1CALL ASN1Dec_UserInputIndication_signal_rtp(ASN1decoding_t dec, UserInputIndication_signal_rtp *val);
static int ASN1CALL ASN1Dec_UserInputIndication_signalUpdate_rtp(ASN1decoding_t dec, UserInputIndication_signalUpdate_rtp *val);
static int ASN1CALL ASN1Dec_UserInputIndication_signalUpdate(ASN1decoding_t dec, UserInputIndication_signalUpdate *val);
static int ASN1CALL ASN1Dec_UserInputIndication_signal(ASN1decoding_t dec, UserInputIndication_signal *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_reverseParameters(ASN1decoding_t dec, NewATMVCIndication_reverseParameters *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_multiplex(ASN1decoding_t dec, NewATMVCIndication_multiplex *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal(ASN1decoding_t dec, NewATMVCIndication_aal *val);
static int ASN1CALL ASN1Dec_JitterIndication_scope(ASN1decoding_t dec, JitterIndication_scope *val);
static int ASN1CALL ASN1Dec_FunctionNotSupported_cause(ASN1decoding_t dec, FunctionNotSupported_cause *val);
static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration_h223AnnexADoubleFlag(ASN1decoding_t dec, H223MultiplexReconfiguration_h223AnnexADoubleFlag *val);
static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration_h223ModeChange(ASN1decoding_t dec, H223MultiplexReconfiguration_h223ModeChange *val);
static int ASN1CALL ASN1Dec_EndSessionCommand_isdnOptions(ASN1decoding_t dec, EndSessionCommand_isdnOptions *val);
static int ASN1CALL ASN1Dec_EndSessionCommand_gstnOptions(ASN1decoding_t dec, EndSessionCommand_gstnOptions *val);
static int ASN1CALL ASN1Dec_FlowControlCommand_restriction(ASN1decoding_t dec, FlowControlCommand_restriction *val);
static int ASN1CALL ASN1Dec_FlowControlCommand_scope(ASN1decoding_t dec, FlowControlCommand_scope *val);
static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest(ASN1decoding_t dec, SendTerminalCapabilitySet_specificRequest *val);
static int ASN1CALL ASN1Dec_RemoteMCResponse_reject(ASN1decoding_t dec, RemoteMCResponse_reject *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_sendThisSourceResponse(ASN1decoding_t dec, ConferenceResponse_sendThisSourceResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_makeTerminalBroadcasterResponse(ASN1decoding_t dec, ConferenceResponse_makeTerminalBroadcasterResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_broadcastMyLogicalChannelResponse(ASN1decoding_t dec, ConferenceResponse_broadcastMyLogicalChannelResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_extensionAddressResponse(ASN1decoding_t dec, ConferenceResponse_extensionAddressResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_makeMeChairResponse(ASN1decoding_t dec, ConferenceResponse_makeMeChairResponse *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopReject_cause(ASN1decoding_t dec, MaintenanceLoopReject_cause *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopReject_type(ASN1decoding_t dec, MaintenanceLoopReject_type *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopAck_type(ASN1decoding_t dec, MaintenanceLoopAck_type *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopRequest_type(ASN1decoding_t dec, MaintenanceLoopRequest_type *val);
static int ASN1CALL ASN1Dec_G7231AnnexCMode_g723AnnexCAudioMode(ASN1decoding_t dec, G7231AnnexCMode_g723AnnexCAudioMode *val);
static int ASN1CALL ASN1Dec_IS13818AudioMode_multichannelType(ASN1decoding_t dec, IS13818AudioMode_multichannelType *val);
static int ASN1CALL ASN1Dec_IS13818AudioMode_audioSampling(ASN1decoding_t dec, IS13818AudioMode_audioSampling *val);
static int ASN1CALL ASN1Dec_IS13818AudioMode_audioLayer(ASN1decoding_t dec, IS13818AudioMode_audioLayer *val);
static int ASN1CALL ASN1Dec_IS11172AudioMode_multichannelType(ASN1decoding_t dec, IS11172AudioMode_multichannelType *val);
static int ASN1CALL ASN1Dec_IS11172AudioMode_audioSampling(ASN1decoding_t dec, IS11172AudioMode_audioSampling *val);
static int ASN1CALL ASN1Dec_IS11172AudioMode_audioLayer(ASN1decoding_t dec, IS11172AudioMode_audioLayer *val);
static int ASN1CALL ASN1Dec_AudioMode_g7231(ASN1decoding_t dec, AudioMode_g7231 *val);
static int ASN1CALL ASN1Dec_H263VideoMode_resolution(ASN1decoding_t dec, H263VideoMode_resolution *val);
static int ASN1CALL ASN1Dec_H262VideoMode_profileAndLevel(ASN1decoding_t dec, H262VideoMode_profileAndLevel *val);
static int ASN1CALL ASN1Dec_H261VideoMode_resolution(ASN1decoding_t dec, H261VideoMode_resolution *val);
static int ASN1CALL ASN1Dec_RequestModeReject_cause(ASN1decoding_t dec, RequestModeReject_cause *val);
static int ASN1CALL ASN1Dec_RequestModeAck_response(ASN1decoding_t dec, RequestModeAck_response *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryRelease_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryRelease_entryNumbers *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryRejectionDescriptions_cause(ASN1decoding_t dec, RequestMultiplexEntryRejectionDescriptions_cause *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryReject_entryNumbers *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryAck_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryAck_entryNumbers *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntry_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntry_entryNumbers *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendRelease_multiplexTableEntryNumber(ASN1decoding_t dec, MultiplexEntrySendRelease_multiplexTableEntryNumber *val);
static int ASN1CALL ASN1Dec_MultiplexEntryRejectionDescriptions_cause(ASN1decoding_t dec, MultiplexEntryRejectionDescriptions_cause *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendAck_multiplexTableEntryNumber(ASN1decoding_t dec, MultiplexEntrySendAck_multiplexTableEntryNumber *val);
static int ASN1CALL ASN1Dec_MultiplexElement_repeatCount(ASN1decoding_t dec, MultiplexElement_repeatCount *val);
static int ASN1CALL ASN1Dec_MultiplexElement_type(ASN1decoding_t dec, MultiplexElement_type *val);
static int ASN1CALL ASN1Dec_RequestChannelCloseReject_cause(ASN1decoding_t dec, RequestChannelCloseReject_cause *val);
static int ASN1CALL ASN1Dec_RequestChannelClose_reason(ASN1decoding_t dec, RequestChannelClose_reason *val);
static int ASN1CALL ASN1Dec_CloseLogicalChannel_reason(ASN1decoding_t dec, CloseLogicalChannel_reason *val);
static int ASN1CALL ASN1Dec_CloseLogicalChannel_source(ASN1decoding_t dec, CloseLogicalChannel_source *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelReject_cause(ASN1decoding_t dec, OpenLogicalChannelReject_cause *val);
static int ASN1CALL ASN1Dec_MulticastAddress_iP6Address(ASN1decoding_t dec, MulticastAddress_iP6Address *val);
static int ASN1CALL ASN1Dec_MulticastAddress_iPAddress(ASN1decoding_t dec, MulticastAddress_iPAddress *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress(ASN1decoding_t dec, UnicastAddress_iPSourceRouteAddress *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iP6Address(ASN1decoding_t dec, UnicastAddress_iP6Address *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPXAddress(ASN1decoding_t dec, UnicastAddress_iPXAddress *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPAddress(ASN1decoding_t dec, UnicastAddress_iPAddress *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode(ASN1decoding_t dec, V76LogicalChannelParameters_mode *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_suspendResume(ASN1decoding_t dec, V76LogicalChannelParameters_suspendResume *val);
static int ASN1CALL ASN1Dec_H223AnnexCArqParameters_numberOfRetransmissions(ASN1decoding_t dec, H223AnnexCArqParameters_numberOfRetransmissions *val);
static int ASN1CALL ASN1Dec_H223AL3MParameters_crcLength(ASN1decoding_t dec, H223AL3MParameters_crcLength *val);
static int ASN1CALL ASN1Dec_H223AL3MParameters_headerFormat(ASN1decoding_t dec, H223AL3MParameters_headerFormat *val);
static int ASN1CALL ASN1Dec_H223AL2MParameters_headerFEC(ASN1decoding_t dec, H223AL2MParameters_headerFEC *val);
static int ASN1CALL ASN1Dec_H223AL1MParameters_crcLength(ASN1decoding_t dec, H223AL1MParameters_crcLength *val);
static int ASN1CALL ASN1Dec_H223AL1MParameters_headerFEC(ASN1decoding_t dec, H223AL1MParameters_headerFEC *val);
static int ASN1CALL ASN1Dec_H223AL1MParameters_transferMode(ASN1decoding_t dec, H223AL1MParameters_transferMode *val);
static int ASN1CALL ASN1Dec_Q2931Address_address(ASN1decoding_t dec, Q2931Address_address *val);
static int ASN1CALL ASN1Dec_NetworkAccessParameters_t120SetupProcedure(ASN1decoding_t dec, NetworkAccessParameters_t120SetupProcedure *val);
static int ASN1CALL ASN1Dec_NetworkAccessParameters_distribution(ASN1decoding_t dec, NetworkAccessParameters_distribution *val);
static int ASN1CALL ASN1Dec_T84Profile_t84Restricted(ASN1decoding_t dec, T84Profile_t84Restricted *val);
static int ASN1CALL ASN1Dec_G7231AnnexCCapability_g723AnnexCAudioMode(ASN1decoding_t dec, G7231AnnexCCapability_g723AnnexCAudioMode *val);
static int ASN1CALL ASN1Dec_AudioCapability_g7231(ASN1decoding_t dec, AudioCapability_g7231 *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI(ASN1decoding_t dec, CustomPictureFormat_mPI *val);
static int ASN1CALL ASN1Dec_RefPictureSelection_videoBackChannelSend(ASN1decoding_t dec, RefPictureSelection_videoBackChannelSend *val);
static int ASN1CALL ASN1Dec_RefPictureSelection_additionalPictureMemory(ASN1decoding_t dec, RefPictureSelection_additionalPictureMemory *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyFrameMapping_frameSequence(ASN1decoding_t dec, RTPH263VideoRedundancyFrameMapping_frameSequence *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_containedThreads(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding_containedThreads *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding_frameToThreadMapping *val);
static int ASN1CALL ASN1Dec_RedundancyEncodingCapability_secondaryEncoding(ASN1decoding_t dec, PRedundancyEncodingCapability_secondaryEncoding *val);
static int ASN1CALL ASN1Dec_H2250Capability_mcCapability(ASN1decoding_t dec, H2250Capability_mcCapability *val);
static int ASN1CALL ASN1Dec_H223Capability_mobileOperationTransmitCapability(ASN1decoding_t dec, H223Capability_mobileOperationTransmitCapability *val);
static int ASN1CALL ASN1Dec_H223Capability_h223MultiplexTableCapability(ASN1decoding_t dec, H223Capability_h223MultiplexTableCapability *val);
static int ASN1CALL ASN1Dec_VCCapability_availableBitRates(ASN1decoding_t dec, VCCapability_availableBitRates *val);
static int ASN1CALL ASN1Dec_VCCapability_aal5(ASN1decoding_t dec, VCCapability_aal5 *val);
static int ASN1CALL ASN1Dec_VCCapability_aal1(ASN1decoding_t dec, VCCapability_aal1 *val);
static int ASN1CALL ASN1Dec_Capability_h233EncryptionReceiveCapability(ASN1decoding_t dec, Capability_h233EncryptionReceiveCapability *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject_cause(ASN1decoding_t dec, TerminalCapabilitySetReject_cause *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationReject_cause(ASN1decoding_t dec, MasterSlaveDeterminationReject_cause *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationAck_decision(ASN1decoding_t dec, MasterSlaveDeterminationAck_decision *val);
static int ASN1CALL ASN1Dec_NonStandardIdentifier_h221NonStandard(ASN1decoding_t dec, NonStandardIdentifier_h221NonStandard *val);
static int ASN1CALL ASN1Dec_NonStandardIdentifier(ASN1decoding_t dec, NonStandardIdentifier *val);
static int ASN1CALL ASN1Dec_MasterSlaveDetermination(ASN1decoding_t dec, MasterSlaveDetermination *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationAck(ASN1decoding_t dec, MasterSlaveDeterminationAck *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationReject(ASN1decoding_t dec, MasterSlaveDeterminationReject *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationRelease(ASN1decoding_t dec, MasterSlaveDeterminationRelease *val);
static int ASN1CALL ASN1Dec_CapabilityDescriptor(ASN1decoding_t dec, CapabilityDescriptor *val);
static int ASN1CALL ASN1Dec_AlternativeCapabilitySet(ASN1decoding_t dec, AlternativeCapabilitySet *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetAck(ASN1decoding_t dec, TerminalCapabilitySetAck *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject(ASN1decoding_t dec, TerminalCapabilitySetReject *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetRelease(ASN1decoding_t dec, TerminalCapabilitySetRelease *val);
static int ASN1CALL ASN1Dec_H222Capability(ASN1decoding_t dec, H222Capability *val);
static int ASN1CALL ASN1Dec_VCCapability(ASN1decoding_t dec, VCCapability *val);
static int ASN1CALL ASN1Dec_H223AnnexCCapability(ASN1decoding_t dec, H223AnnexCCapability *val);
static int ASN1CALL ASN1Dec_V75Capability(ASN1decoding_t dec, V75Capability *val);
static int ASN1CALL ASN1Dec_QOSMode(ASN1decoding_t dec, QOSMode *val);
static int ASN1CALL ASN1Dec_ATMParameters(ASN1decoding_t dec, ATMParameters *val);
static int ASN1CALL ASN1Dec_MediaTransportType(ASN1decoding_t dec, MediaTransportType *val);
static int ASN1CALL ASN1Dec_MediaChannelCapability(ASN1decoding_t dec, MediaChannelCapability *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyFrameMapping(ASN1decoding_t dec, RTPH263VideoRedundancyFrameMapping *val);
static int ASN1CALL ASN1Dec_MultipointCapability(ASN1decoding_t dec, MultipointCapability *val);
static int ASN1CALL ASN1Dec_MediaDistributionCapability(ASN1decoding_t dec, MediaDistributionCapability *val);
static int ASN1CALL ASN1Dec_H261VideoCapability(ASN1decoding_t dec, H261VideoCapability *val);
static int ASN1CALL ASN1Dec_H262VideoCapability(ASN1decoding_t dec, H262VideoCapability *val);
static int ASN1CALL ASN1Dec_EnhancementLayerInfo(ASN1decoding_t dec, EnhancementLayerInfo *val);
static int ASN1CALL ASN1Dec_TransparencyParameters(ASN1decoding_t dec, TransparencyParameters *val);
static int ASN1CALL ASN1Dec_RefPictureSelection(ASN1decoding_t dec, RefPictureSelection *val);
static int ASN1CALL ASN1Dec_CustomPictureClockFrequency(ASN1decoding_t dec, CustomPictureClockFrequency *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat(ASN1decoding_t dec, CustomPictureFormat *val);
static int ASN1CALL ASN1Dec_H263ModeComboFlags(ASN1decoding_t dec, H263ModeComboFlags *val);
static int ASN1CALL ASN1Dec_IS11172VideoCapability(ASN1decoding_t dec, IS11172VideoCapability *val);
static int ASN1CALL ASN1Dec_G7231AnnexCCapability(ASN1decoding_t dec, G7231AnnexCCapability *val);
static int ASN1CALL ASN1Dec_IS11172AudioCapability(ASN1decoding_t dec, IS11172AudioCapability *val);
static int ASN1CALL ASN1Dec_IS13818AudioCapability(ASN1decoding_t dec, IS13818AudioCapability *val);
static int ASN1CALL ASN1Dec_GSMAudioCapability(ASN1decoding_t dec, GSMAudioCapability *val);
static int ASN1CALL ASN1Dec_V42bis(ASN1decoding_t dec, V42bis *val);
static int ASN1CALL ASN1Dec_T84Profile(ASN1decoding_t dec, T84Profile *val);
static int ASN1CALL ASN1Dec_ConferenceCapability(ASN1decoding_t dec, ConferenceCapability *val);
static int ASN1CALL ASN1Dec_Q2931Address(ASN1decoding_t dec, Q2931Address *val);
static int ASN1CALL ASN1Dec_V75Parameters(ASN1decoding_t dec, V75Parameters *val);
static int ASN1CALL ASN1Dec_H222LogicalChannelParameters(ASN1decoding_t dec, H222LogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_H223AL2MParameters(ASN1decoding_t dec, H223AL2MParameters *val);
static int ASN1CALL ASN1Dec_H223AnnexCArqParameters(ASN1decoding_t dec, H223AnnexCArqParameters *val);
static int ASN1CALL ASN1Dec_CRCLength(ASN1decoding_t dec, CRCLength *val);
static int ASN1CALL ASN1Dec_EscrowData(ASN1decoding_t dec, EscrowData *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelReject(ASN1decoding_t dec, OpenLogicalChannelReject *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelConfirm(ASN1decoding_t dec, OpenLogicalChannelConfirm *val);
static int ASN1CALL ASN1Dec_CloseLogicalChannel(ASN1decoding_t dec, CloseLogicalChannel *val);
static int ASN1CALL ASN1Dec_CloseLogicalChannelAck(ASN1decoding_t dec, CloseLogicalChannelAck *val);
static int ASN1CALL ASN1Dec_RequestChannelCloseAck(ASN1decoding_t dec, RequestChannelCloseAck *val);
static int ASN1CALL ASN1Dec_RequestChannelCloseReject(ASN1decoding_t dec, RequestChannelCloseReject *val);
static int ASN1CALL ASN1Dec_RequestChannelCloseRelease(ASN1decoding_t dec, RequestChannelCloseRelease *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySend(ASN1decoding_t dec, MultiplexEntrySend *val);
static int ASN1CALL ASN1Dec_MultiplexElement(ASN1decoding_t dec, MultiplexElement *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendAck(ASN1decoding_t dec, MultiplexEntrySendAck *val);
static int ASN1CALL ASN1Dec_MultiplexEntryRejectionDescriptions(ASN1decoding_t dec, MultiplexEntryRejectionDescriptions *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendRelease(ASN1decoding_t dec, MultiplexEntrySendRelease *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntry(ASN1decoding_t dec, RequestMultiplexEntry *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryAck(ASN1decoding_t dec, RequestMultiplexEntryAck *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryRejectionDescriptions(ASN1decoding_t dec, RequestMultiplexEntryRejectionDescriptions *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryRelease(ASN1decoding_t dec, RequestMultiplexEntryRelease *val);
static int ASN1CALL ASN1Dec_RequestMode(ASN1decoding_t dec, RequestMode *val);
static int ASN1CALL ASN1Dec_RequestModeAck(ASN1decoding_t dec, RequestModeAck *val);
static int ASN1CALL ASN1Dec_RequestModeReject(ASN1decoding_t dec, RequestModeReject *val);
static int ASN1CALL ASN1Dec_RequestModeRelease(ASN1decoding_t dec, RequestModeRelease *val);
static int ASN1CALL ASN1Dec_V76ModeParameters(ASN1decoding_t dec, V76ModeParameters *val);
static int ASN1CALL ASN1Dec_H261VideoMode(ASN1decoding_t dec, H261VideoMode *val);
static int ASN1CALL ASN1Dec_H262VideoMode(ASN1decoding_t dec, H262VideoMode *val);
static int ASN1CALL ASN1Dec_IS11172VideoMode(ASN1decoding_t dec, IS11172VideoMode *val);
static int ASN1CALL ASN1Dec_IS11172AudioMode(ASN1decoding_t dec, IS11172AudioMode *val);
static int ASN1CALL ASN1Dec_IS13818AudioMode(ASN1decoding_t dec, IS13818AudioMode *val);
static int ASN1CALL ASN1Dec_G7231AnnexCMode(ASN1decoding_t dec, G7231AnnexCMode *val);
static int ASN1CALL ASN1Dec_RoundTripDelayRequest(ASN1decoding_t dec, RoundTripDelayRequest *val);
static int ASN1CALL ASN1Dec_RoundTripDelayResponse(ASN1decoding_t dec, RoundTripDelayResponse *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopRequest(ASN1decoding_t dec, MaintenanceLoopRequest *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopAck(ASN1decoding_t dec, MaintenanceLoopAck *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopReject(ASN1decoding_t dec, MaintenanceLoopReject *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopOffCommand(ASN1decoding_t dec, MaintenanceLoopOffCommand *val);
static int ASN1CALL ASN1Dec_CommunicationModeCommand(ASN1decoding_t dec, CommunicationModeCommand *val);
static int ASN1CALL ASN1Dec_CommunicationModeRequest(ASN1decoding_t dec, CommunicationModeRequest *val);
static int ASN1CALL ASN1Dec_CommunicationModeResponse(ASN1decoding_t dec, CommunicationModeResponse *val);
static int ASN1CALL ASN1Dec_Criteria(ASN1decoding_t dec, Criteria *val);
static int ASN1CALL ASN1Dec_TerminalLabel(ASN1decoding_t dec, TerminalLabel *val);
static int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse(ASN1decoding_t dec, RequestAllTerminalIDsResponse *val);
static int ASN1CALL ASN1Dec_TerminalInformation(ASN1decoding_t dec, TerminalInformation *val);
static int ASN1CALL ASN1Dec_RemoteMCRequest(ASN1decoding_t dec, RemoteMCRequest *val);
static int ASN1CALL ASN1Dec_RemoteMCResponse(ASN1decoding_t dec, RemoteMCResponse *val);
static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet(ASN1decoding_t dec, SendTerminalCapabilitySet *val);
static int ASN1CALL ASN1Dec_FlowControlCommand(ASN1decoding_t dec, FlowControlCommand *val);
static int ASN1CALL ASN1Dec_SubstituteConferenceIDCommand(ASN1decoding_t dec, SubstituteConferenceIDCommand *val);
static int ASN1CALL ASN1Dec_KeyProtectionMethod(ASN1decoding_t dec, KeyProtectionMethod *val);
static int ASN1CALL ASN1Dec_EncryptionUpdateRequest(ASN1decoding_t dec, EncryptionUpdateRequest *val);
static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration(ASN1decoding_t dec, H223MultiplexReconfiguration *val);
static int ASN1CALL ASN1Dec_FunctionNotSupported(ASN1decoding_t dec, FunctionNotSupported *val);
static int ASN1CALL ASN1Dec_TerminalYouAreSeeingInSubPictureNumber(ASN1decoding_t dec, TerminalYouAreSeeingInSubPictureNumber *val);
static int ASN1CALL ASN1Dec_VideoIndicateCompose(ASN1decoding_t dec, VideoIndicateCompose *val);
static int ASN1CALL ASN1Dec_ConferenceIndication(ASN1decoding_t dec, ConferenceIndication *val);
static int ASN1CALL ASN1Dec_JitterIndication(ASN1decoding_t dec, JitterIndication *val);
static int ASN1CALL ASN1Dec_H223SkewIndication(ASN1decoding_t dec, H223SkewIndication *val);
static int ASN1CALL ASN1Dec_H2250MaximumSkewIndication(ASN1decoding_t dec, H2250MaximumSkewIndication *val);
static int ASN1CALL ASN1Dec_VendorIdentification(ASN1decoding_t dec, VendorIdentification *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication(ASN1decoding_t dec, NewATMVCIndication *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(ASN1decoding_t dec, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val);
static int ASN1CALL ASN1Dec_MultiplexElement_type_subElementList(ASN1decoding_t dec, PMultiplexElement_type_subElementList *val);
static int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation(ASN1decoding_t dec, PRequestAllTerminalIDsResponse_terminalInformation *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_terminalCertificateResponse(ASN1decoding_t dec, ConferenceResponse_terminalCertificateResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_chairTokenOwnerResponse(ASN1decoding_t dec, ConferenceResponse_chairTokenOwnerResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_terminalListResponse(ASN1decoding_t dec, ConferenceResponse_terminalListResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_passwordResponse(ASN1decoding_t dec, ConferenceResponse_passwordResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_conferenceIDResponse(ASN1decoding_t dec, ConferenceResponse_conferenceIDResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_terminalIDResponse(ASN1decoding_t dec, ConferenceResponse_terminalIDResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_mCTerminalIDResponse(ASN1decoding_t dec, ConferenceResponse_mCTerminalIDResponse *val);
static int ASN1CALL ASN1Dec_ConferenceRequest_requestTerminalCertificate(ASN1decoding_t dec, ConferenceRequest_requestTerminalCertificate *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject_rejectionDescriptions(ASN1decoding_t dec, RequestMultiplexEntryReject_rejectionDescriptions *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendReject_rejectionDescriptions(ASN1decoding_t dec, MultiplexEntrySendReject_rejectionDescriptions *val);
static int ASN1CALL ASN1Dec_MultiplexEntryDescriptor_elementList(ASN1decoding_t dec, MultiplexEntryDescriptor_elementList *val);
static int ASN1CALL ASN1Dec_EncryptionSync_escrowentry(ASN1decoding_t dec, PEncryptionSync_escrowentry *val);
static int ASN1CALL ASN1Dec_H223AL3MParameters_arqType(ASN1decoding_t dec, H223AL3MParameters_arqType *val);
static int ASN1CALL ASN1Dec_H223AL1MParameters_arqType(ASN1decoding_t dec, H223AL1MParameters_arqType *val);
static int ASN1CALL ASN1Dec_H263VideoModeCombos_h263VideoCoupledModes(ASN1decoding_t dec, H263VideoModeCombos_h263VideoCoupledModes *val);
static int ASN1CALL ASN1Dec_H263Options_customPictureFormat(ASN1decoding_t dec, PH263Options_customPictureFormat *val);
static int ASN1CALL ASN1Dec_H263Options_customPictureClockFrequency(ASN1decoding_t dec, PH263Options_customPictureClockFrequency *val);
static int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability *val);
static int ASN1CALL ASN1Dec_TransportCapability_mediaChannelCapabilities(ASN1decoding_t dec, TransportCapability_mediaChannelCapabilities *val);
static int ASN1CALL ASN1Dec_H222Capability_vcCapability(ASN1decoding_t dec, PH222Capability_vcCapability *val);
static int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityDescriptors(ASN1decoding_t dec, TerminalCapabilitySet_capabilityDescriptors *val);
static int ASN1CALL ASN1Dec_NonStandardParameter(ASN1decoding_t dec, NonStandardParameter *val);
static int ASN1CALL ASN1Dec_H223Capability(ASN1decoding_t dec, H223Capability *val);
static int ASN1CALL ASN1Dec_V76Capability(ASN1decoding_t dec, V76Capability *val);
static int ASN1CALL ASN1Dec_RSVPParameters(ASN1decoding_t dec, RSVPParameters *val);
static int ASN1CALL ASN1Dec_QOSCapability(ASN1decoding_t dec, QOSCapability *val);
static int ASN1CALL ASN1Dec_TransportCapability(ASN1decoding_t dec, TransportCapability *val);
static int ASN1CALL ASN1Dec_RedundancyEncodingMethod(ASN1decoding_t dec, RedundancyEncodingMethod *val);
static int ASN1CALL ASN1Dec_H263Options(ASN1decoding_t dec, H263Options *val);
static int ASN1CALL ASN1Dec_H263VideoModeCombos(ASN1decoding_t dec, H263VideoModeCombos *val);
static int ASN1CALL ASN1Dec_AudioCapability(ASN1decoding_t dec, AudioCapability *val);
static int ASN1CALL ASN1Dec_CompressionType(ASN1decoding_t dec, CompressionType *val);
static int ASN1CALL ASN1Dec_MediaEncryptionAlgorithm(ASN1decoding_t dec, MediaEncryptionAlgorithm *val);
static int ASN1CALL ASN1Dec_AuthenticationCapability(ASN1decoding_t dec, AuthenticationCapability *val);
static int ASN1CALL ASN1Dec_IntegrityCapability(ASN1decoding_t dec, IntegrityCapability *val);
static int ASN1CALL ASN1Dec_H223AL1MParameters(ASN1decoding_t dec, H223AL1MParameters *val);
static int ASN1CALL ASN1Dec_H223AL3MParameters(ASN1decoding_t dec, H223AL3MParameters *val);
static int ASN1CALL ASN1Dec_V76HDLCParameters(ASN1decoding_t dec, V76HDLCParameters *val);
static int ASN1CALL ASN1Dec_UnicastAddress(ASN1decoding_t dec, UnicastAddress *val);
static int ASN1CALL ASN1Dec_MulticastAddress(ASN1decoding_t dec, MulticastAddress *val);
static int ASN1CALL ASN1Dec_EncryptionSync(ASN1decoding_t dec, EncryptionSync *val);
static int ASN1CALL ASN1Dec_RequestChannelClose(ASN1decoding_t dec, RequestChannelClose *val);
static int ASN1CALL ASN1Dec_MultiplexEntryDescriptor(ASN1decoding_t dec, MultiplexEntryDescriptor *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendReject(ASN1decoding_t dec, MultiplexEntrySendReject *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject(ASN1decoding_t dec, RequestMultiplexEntryReject *val);
static int ASN1CALL ASN1Dec_H263VideoMode(ASN1decoding_t dec, H263VideoMode *val);
static int ASN1CALL ASN1Dec_AudioMode(ASN1decoding_t dec, AudioMode *val);
static int ASN1CALL ASN1Dec_EncryptionMode(ASN1decoding_t dec, EncryptionMode *val);
static int ASN1CALL ASN1Dec_ConferenceRequest(ASN1decoding_t dec, ConferenceRequest *val);
static int ASN1CALL ASN1Dec_CertSelectionCriteria(ASN1decoding_t dec, PCertSelectionCriteria *val);
static int ASN1CALL ASN1Dec_ConferenceResponse(ASN1decoding_t dec, ConferenceResponse *val);
static int ASN1CALL ASN1Dec_EndSessionCommand(ASN1decoding_t dec, EndSessionCommand *val);
static int ASN1CALL ASN1Dec_ConferenceCommand(ASN1decoding_t dec, ConferenceCommand *val);
static int ASN1CALL ASN1Dec_UserInputIndication_userInputSupportIndication(ASN1decoding_t dec, UserInputIndication_userInputSupportIndication *val);
static int ASN1CALL ASN1Dec_MiscellaneousIndication_type(ASN1decoding_t dec, MiscellaneousIndication_type *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type(ASN1decoding_t dec, MiscellaneousCommand_type *val);
static int ASN1CALL ASN1Dec_EncryptionCommand_encryptionAlgorithmID(ASN1decoding_t dec, EncryptionCommand_encryptionAlgorithmID *val);
static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard *val);
static int ASN1CALL ASN1Dec_RedundancyEncodingMode_secondaryEncoding(ASN1decoding_t dec, RedundancyEncodingMode_secondaryEncoding *val);
static int ASN1CALL ASN1Dec_H223ModeParameters_adaptationLayerType(ASN1decoding_t dec, H223ModeParameters_adaptationLayerType *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard *val);
static int ASN1CALL ASN1Dec_RTPPayloadType_payloadDescriptor(ASN1decoding_t dec, RTPPayloadType_payloadDescriptor *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard *val);
static int ASN1CALL ASN1Dec_H223LogicalChannelParameters_adaptationLayerType(ASN1decoding_t dec, H223LogicalChannelParameters_adaptationLayerType *val);
static int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData(ASN1decoding_t dec, PConferenceCapability_nonStandardData *val);
static int ASN1CALL ASN1Dec_UserInputCapability_nonStandard(ASN1decoding_t dec, UserInputCapability_nonStandard *val);
static int ASN1CALL ASN1Dec_DataProtocolCapability_v76wCompression(ASN1decoding_t dec, DataProtocolCapability_v76wCompression *val);
static int ASN1CALL ASN1Dec_H263Options_modeCombos(ASN1decoding_t dec, PH263Options_modeCombos *val);
static int ASN1CALL ASN1Dec_TransportCapability_qOSCapabilities(ASN1decoding_t dec, PTransportCapability_qOSCapabilities *val);
static int ASN1CALL ASN1Dec_NonStandardMessage(ASN1decoding_t dec, NonStandardMessage *val);
static int ASN1CALL ASN1Dec_RedundancyEncodingCapability(ASN1decoding_t dec, RedundancyEncodingCapability *val);
static int ASN1CALL ASN1Dec_H263VideoCapability(ASN1decoding_t dec, H263VideoCapability *val);
static int ASN1CALL ASN1Dec_EnhancementOptions(ASN1decoding_t dec, EnhancementOptions *val);
static int ASN1CALL ASN1Dec_DataProtocolCapability(ASN1decoding_t dec, DataProtocolCapability *val);
static int ASN1CALL ASN1Dec_EncryptionAuthenticationAndIntegrity(ASN1decoding_t dec, EncryptionAuthenticationAndIntegrity *val);
static int ASN1CALL ASN1Dec_EncryptionCapability(ASN1decoding_t dec, PEncryptionCapability *val);
static int ASN1CALL ASN1Dec_UserInputCapability(ASN1decoding_t dec, UserInputCapability *val);
static int ASN1CALL ASN1Dec_H223LogicalChannelParameters(ASN1decoding_t dec, H223LogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters(ASN1decoding_t dec, V76LogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_RTPPayloadType(ASN1decoding_t dec, RTPPayloadType *val);
static int ASN1CALL ASN1Dec_H245TransportAddress(ASN1decoding_t dec, H245TransportAddress *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters(ASN1decoding_t dec, H2250LogicalChannelAckParameters *val);
static int ASN1CALL ASN1Dec_H223ModeParameters(ASN1decoding_t dec, H223ModeParameters *val);
static int ASN1CALL ASN1Dec_RedundancyEncodingMode(ASN1decoding_t dec, RedundancyEncodingMode *val);
static int ASN1CALL ASN1Dec_VideoMode(ASN1decoding_t dec, VideoMode *val);
static int ASN1CALL ASN1Dec_EncryptionCommand(ASN1decoding_t dec, EncryptionCommand *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand(ASN1decoding_t dec, MiscellaneousCommand *val);
static int ASN1CALL ASN1Dec_MiscellaneousIndication(ASN1decoding_t dec, MiscellaneousIndication *val);
static int ASN1CALL ASN1Dec_MCLocationIndication(ASN1decoding_t dec, MCLocationIndication *val);
static int ASN1CALL ASN1Dec_UserInputIndication(ASN1decoding_t dec, UserInputIndication *val);
static int ASN1CALL ASN1Dec_DataApplicationCapability_application_nlpid(ASN1decoding_t dec, DataApplicationCapability_application_nlpid *val);
static int ASN1CALL ASN1Dec_DataApplicationCapability_application_t84(ASN1decoding_t dec, DataApplicationCapability_application_t84 *val);
static int ASN1CALL ASN1Dec_DataMode_application_nlpid(ASN1decoding_t dec, DataMode_application_nlpid *val);
static int ASN1CALL ASN1Dec_DataMode_application(ASN1decoding_t dec, DataMode_application *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_forwardMultiplexAckParameters(ASN1decoding_t dec, OpenLogicalChannelAck_forwardMultiplexAckParameters *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_mediaPacketization(ASN1decoding_t dec, H2250LogicalChannelParameters_mediaPacketization *val);
static int ASN1CALL ASN1Dec_NetworkAccessParameters_networkAddress(ASN1decoding_t dec, NetworkAccessParameters_networkAddress *val);
static int ASN1CALL ASN1Dec_DataApplicationCapability_application(ASN1decoding_t dec, DataApplicationCapability_application *val);
static int ASN1CALL ASN1Dec_EnhancementLayerInfo_spatialEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_spatialEnhancement *val);
static int ASN1CALL ASN1Dec_EnhancementLayerInfo_snrEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_snrEnhancement *val);
static int ASN1CALL ASN1Dec_MediaPacketizationCapability_rtpPayloadType(ASN1decoding_t dec, MediaPacketizationCapability_rtpPayloadType *val);
static int ASN1CALL ASN1Dec_H2250Capability_redundancyEncodingCapability(ASN1decoding_t dec, PH2250Capability_redundancyEncodingCapability *val);
static int ASN1CALL ASN1Dec_CommandMessage(ASN1decoding_t dec, CommandMessage *val);
static int ASN1CALL ASN1Dec_H235SecurityCapability(ASN1decoding_t dec, H235SecurityCapability *val);
static int ASN1CALL ASN1Dec_MediaPacketizationCapability(ASN1decoding_t dec, MediaPacketizationCapability *val);
static int ASN1CALL ASN1Dec_VideoCapability(ASN1decoding_t dec, VideoCapability *val);
static int ASN1CALL ASN1Dec_BEnhancementParameters(ASN1decoding_t dec, BEnhancementParameters *val);
static int ASN1CALL ASN1Dec_DataApplicationCapability(ASN1decoding_t dec, DataApplicationCapability *val);
static int ASN1CALL ASN1Dec_NetworkAccessParameters(ASN1decoding_t dec, NetworkAccessParameters *val);
static int ASN1CALL ASN1Dec_H2250ModeParameters(ASN1decoding_t dec, H2250ModeParameters *val);
static int ASN1CALL ASN1Dec_DataMode(ASN1decoding_t dec, DataMode *val);
static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_dataType(ASN1decoding_t dec, CommunicationModeTableEntry_dataType *val);
static int ASN1CALL ASN1Dec_H235Mode_mediaMode(ASN1decoding_t dec, H235Mode_mediaMode *val);
static int ASN1CALL ASN1Dec_H235Media_mediaType(ASN1decoding_t dec, H235Media_mediaType *val);
static int ASN1CALL ASN1Dec_EnhancementLayerInfo_bPictureEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_bPictureEnhancement *val);
static int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData(ASN1decoding_t dec, PMediaDistributionCapability_distributedData *val);
static int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData *val);
static int ASN1CALL ASN1Dec_Capability(ASN1decoding_t dec, Capability *val);
static int ASN1CALL ASN1Dec_H2250Capability(ASN1decoding_t dec, H2250Capability *val);
static int ASN1CALL ASN1Dec_H235Media(ASN1decoding_t dec, H235Media *val);
static int ASN1CALL ASN1Dec_H235Mode(ASN1decoding_t dec, H235Mode *val);
static int ASN1CALL ASN1Dec_ModeElement_type(ASN1decoding_t dec, ModeElement_type *val);
static int ASN1CALL ASN1Dec_CapabilityTableEntry(ASN1decoding_t dec, CapabilityTableEntry *val);
static int ASN1CALL ASN1Dec_MultiplexCapability(ASN1decoding_t dec, MultiplexCapability *val);
static int ASN1CALL ASN1Dec_DataType(ASN1decoding_t dec, DataType *val);
static int ASN1CALL ASN1Dec_RedundancyEncoding(ASN1decoding_t dec, RedundancyEncoding *val);
static int ASN1CALL ASN1Dec_ModeElement(ASN1decoding_t dec, ModeElement *val);
static int ASN1CALL ASN1Dec_CommunicationModeTableEntry(ASN1decoding_t dec, CommunicationModeTableEntry *val);
static int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable *val);
static int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySet(ASN1decoding_t dec, TerminalCapabilitySet *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters(ASN1decoding_t dec, H2250LogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_ModeDescription(ASN1decoding_t dec, ModeDescription *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Dec_RequestMode_requestedModes(ASN1decoding_t dec, PRequestMode_requestedModes *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannelAck_reverseLogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannel_reverseLogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannel_forwardLogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel(ASN1decoding_t dec, OpenLogicalChannel *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelAck(ASN1decoding_t dec, OpenLogicalChannelAck *val);
static int ASN1CALL ASN1Dec_RequestMessage(ASN1decoding_t dec, RequestMessage *val);
static int ASN1CALL ASN1Dec_ResponseMessage(ASN1decoding_t dec, ResponseMessage *val);
static int ASN1CALL ASN1Dec_FastConnectOLC(ASN1decoding_t dec, FastConnectOLC *val);
static int ASN1CALL ASN1Dec_FunctionNotUnderstood(ASN1decoding_t dec, FunctionNotUnderstood *val);
static int ASN1CALL ASN1Dec_IndicationMessage(ASN1decoding_t dec, IndicationMessage *val);
static int ASN1CALL ASN1Dec_MultimediaSystemControlMessage(ASN1decoding_t dec, MultimediaSystemControlMessage *val);
static void ASN1CALL ASN1Free_CustomPictureFormat_mPI_customPCF(CustomPictureFormat_mPI_customPCF *val);
static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation_extendedPAR(CustomPictureFormat_pixelAspectInformation_extendedPAR *val);
static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val);
static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route(PUnicastAddress_iPSourceRouteAddress_route *val);
static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val);
static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val);
static void ASN1CALL ASN1Free_UserInputIndication_signal(UserInputIndication_signal *val);
static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest(SendTerminalCapabilitySet_specificRequest *val);
static void ASN1CALL ASN1Free_ConferenceResponse_extensionAddressResponse(ConferenceResponse_extensionAddressResponse *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryRelease_entryNumbers(RequestMultiplexEntryRelease_entryNumbers *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryReject_entryNumbers(RequestMultiplexEntryReject_entryNumbers *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryAck_entryNumbers(RequestMultiplexEntryAck_entryNumbers *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntry_entryNumbers(RequestMultiplexEntry_entryNumbers *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendRelease_multiplexTableEntryNumber(MultiplexEntrySendRelease_multiplexTableEntryNumber *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendAck_multiplexTableEntryNumber(MultiplexEntrySendAck_multiplexTableEntryNumber *val);
static void ASN1CALL ASN1Free_MultiplexElement_type(MultiplexElement_type *val);
static void ASN1CALL ASN1Free_MulticastAddress_iP6Address(MulticastAddress_iP6Address *val);
static void ASN1CALL ASN1Free_MulticastAddress_iPAddress(MulticastAddress_iPAddress *val);
static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress(UnicastAddress_iPSourceRouteAddress *val);
static void ASN1CALL ASN1Free_UnicastAddress_iP6Address(UnicastAddress_iP6Address *val);
static void ASN1CALL ASN1Free_UnicastAddress_iPXAddress(UnicastAddress_iPXAddress *val);
static void ASN1CALL ASN1Free_UnicastAddress_iPAddress(UnicastAddress_iPAddress *val);
static void ASN1CALL ASN1Free_Q2931Address_address(Q2931Address_address *val);
static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation(CustomPictureFormat_pixelAspectInformation *val);
static void ASN1CALL ASN1Free_CustomPictureFormat_mPI(CustomPictureFormat_mPI *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyFrameMapping_frameSequence(RTPH263VideoRedundancyFrameMapping_frameSequence *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_containedThreads(RTPH263VideoRedundancyEncoding_containedThreads *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping(RTPH263VideoRedundancyEncoding_frameToThreadMapping *val);
static void ASN1CALL ASN1Free_RedundancyEncodingCapability_secondaryEncoding(PRedundancyEncodingCapability_secondaryEncoding *val);
static void ASN1CALL ASN1Free_NonStandardIdentifier(NonStandardIdentifier *val);
static void ASN1CALL ASN1Free_CapabilityDescriptor(CapabilityDescriptor *val);
static void ASN1CALL ASN1Free_AlternativeCapabilitySet(AlternativeCapabilitySet *val);
static void ASN1CALL ASN1Free_H222Capability(H222Capability *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding(RTPH263VideoRedundancyEncoding *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyFrameMapping(RTPH263VideoRedundancyFrameMapping *val);
static void ASN1CALL ASN1Free_MultipointCapability(MultipointCapability *val);
static void ASN1CALL ASN1Free_MediaDistributionCapability(MediaDistributionCapability *val);
static void ASN1CALL ASN1Free_EnhancementLayerInfo(EnhancementLayerInfo *val);
static void ASN1CALL ASN1Free_CustomPictureFormat(CustomPictureFormat *val);
static void ASN1CALL ASN1Free_ConferenceCapability(ConferenceCapability *val);
static void ASN1CALL ASN1Free_Q2931Address(Q2931Address *val);
static void ASN1CALL ASN1Free_H222LogicalChannelParameters(H222LogicalChannelParameters *val);
static void ASN1CALL ASN1Free_EscrowData(EscrowData *val);
static void ASN1CALL ASN1Free_MultiplexEntrySend(MultiplexEntrySend *val);
static void ASN1CALL ASN1Free_MultiplexElement(MultiplexElement *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendAck(MultiplexEntrySendAck *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendRelease(MultiplexEntrySendRelease *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntry(RequestMultiplexEntry *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryAck(RequestMultiplexEntryAck *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryRelease(RequestMultiplexEntryRelease *val);
static void ASN1CALL ASN1Free_RequestMode(RequestMode *val);
static void ASN1CALL ASN1Free_CommunicationModeCommand(CommunicationModeCommand *val);
static void ASN1CALL ASN1Free_CommunicationModeResponse(CommunicationModeResponse *val);
static void ASN1CALL ASN1Free_Criteria(Criteria *val);
static void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse(RequestAllTerminalIDsResponse *val);
static void ASN1CALL ASN1Free_TerminalInformation(TerminalInformation *val);
static void ASN1CALL ASN1Free_SendTerminalCapabilitySet(SendTerminalCapabilitySet *val);
static void ASN1CALL ASN1Free_SubstituteConferenceIDCommand(SubstituteConferenceIDCommand *val);
static void ASN1CALL ASN1Free_FunctionNotSupported(FunctionNotSupported *val);
static void ASN1CALL ASN1Free_VendorIdentification(VendorIdentification *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val);
static void ASN1CALL ASN1Free_MultiplexElement_type_subElementList(PMultiplexElement_type_subElementList *val);
static void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse_terminalInformation(PRequestAllTerminalIDsResponse_terminalInformation *val);
static void ASN1CALL ASN1Free_ConferenceResponse_terminalCertificateResponse(ConferenceResponse_terminalCertificateResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_chairTokenOwnerResponse(ConferenceResponse_chairTokenOwnerResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_terminalListResponse(ConferenceResponse_terminalListResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_passwordResponse(ConferenceResponse_passwordResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_conferenceIDResponse(ConferenceResponse_conferenceIDResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_terminalIDResponse(ConferenceResponse_terminalIDResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_mCTerminalIDResponse(ConferenceResponse_mCTerminalIDResponse *val);
static void ASN1CALL ASN1Free_ConferenceRequest_requestTerminalCertificate(ConferenceRequest_requestTerminalCertificate *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryReject_rejectionDescriptions(RequestMultiplexEntryReject_rejectionDescriptions *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendReject_rejectionDescriptions(MultiplexEntrySendReject_rejectionDescriptions *val);
static void ASN1CALL ASN1Free_MultiplexEntryDescriptor_elementList(MultiplexEntryDescriptor_elementList *val);
static void ASN1CALL ASN1Free_EncryptionSync_escrowentry(PEncryptionSync_escrowentry *val);
static void ASN1CALL ASN1Free_H263VideoModeCombos_h263VideoCoupledModes(H263VideoModeCombos_h263VideoCoupledModes *val);
static void ASN1CALL ASN1Free_H263Options_customPictureFormat(PH263Options_customPictureFormat *val);
static void ASN1CALL ASN1Free_H263Options_customPictureClockFrequency(PH263Options_customPictureClockFrequency *val);
static void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability(PMultipointCapability_mediaDistributionCapability *val);
static void ASN1CALL ASN1Free_TransportCapability_mediaChannelCapabilities(TransportCapability_mediaChannelCapabilities *val);
static void ASN1CALL ASN1Free_H222Capability_vcCapability(PH222Capability_vcCapability *val);
static void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities(PCapabilityDescriptor_simultaneousCapabilities *val);
static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityDescriptors(TerminalCapabilitySet_capabilityDescriptors *val);
static void ASN1CALL ASN1Free_NonStandardParameter(NonStandardParameter *val);
static void ASN1CALL ASN1Free_QOSCapability(QOSCapability *val);
static void ASN1CALL ASN1Free_TransportCapability(TransportCapability *val);
static void ASN1CALL ASN1Free_RedundancyEncodingMethod(RedundancyEncodingMethod *val);
static void ASN1CALL ASN1Free_H263Options(H263Options *val);
static void ASN1CALL ASN1Free_H263VideoModeCombos(H263VideoModeCombos *val);
static void ASN1CALL ASN1Free_AudioCapability(AudioCapability *val);
static void ASN1CALL ASN1Free_MediaEncryptionAlgorithm(MediaEncryptionAlgorithm *val);
static void ASN1CALL ASN1Free_AuthenticationCapability(AuthenticationCapability *val);
static void ASN1CALL ASN1Free_IntegrityCapability(IntegrityCapability *val);
static void ASN1CALL ASN1Free_UnicastAddress(UnicastAddress *val);
static void ASN1CALL ASN1Free_MulticastAddress(MulticastAddress *val);
static void ASN1CALL ASN1Free_EncryptionSync(EncryptionSync *val);
static void ASN1CALL ASN1Free_RequestChannelClose(RequestChannelClose *val);
static void ASN1CALL ASN1Free_MultiplexEntryDescriptor(MultiplexEntryDescriptor *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendReject(MultiplexEntrySendReject *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryReject(RequestMultiplexEntryReject *val);
static void ASN1CALL ASN1Free_H263VideoMode(H263VideoMode *val);
static void ASN1CALL ASN1Free_AudioMode(AudioMode *val);
static void ASN1CALL ASN1Free_EncryptionMode(EncryptionMode *val);
static void ASN1CALL ASN1Free_ConferenceRequest(ConferenceRequest *val);
static void ASN1CALL ASN1Free_CertSelectionCriteria(PCertSelectionCriteria *val);
static void ASN1CALL ASN1Free_ConferenceResponse(ConferenceResponse *val);
static void ASN1CALL ASN1Free_EndSessionCommand(EndSessionCommand *val);
static void ASN1CALL ASN1Free_ConferenceCommand(ConferenceCommand *val);
static void ASN1CALL ASN1Free_UserInputIndication_userInputSupportIndication(UserInputIndication_userInputSupportIndication *val);
static void ASN1CALL ASN1Free_MiscellaneousIndication_type(MiscellaneousIndication_type *val);
static void ASN1CALL ASN1Free_MiscellaneousCommand_type(MiscellaneousCommand_type *val);
static void ASN1CALL ASN1Free_EncryptionCommand_encryptionAlgorithmID(EncryptionCommand_encryptionAlgorithmID *val);
static void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard(PCommunicationModeTableEntry_nonStandard *val);
static void ASN1CALL ASN1Free_RedundancyEncodingMode_secondaryEncoding(RedundancyEncodingMode_secondaryEncoding *val);
static void ASN1CALL ASN1Free_H223ModeParameters_adaptationLayerType(H223ModeParameters_adaptationLayerType *val);
static void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors(PMultiplexEntrySend_multiplexEntryDescriptors *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard(PH2250LogicalChannelAckParameters_nonStandard *val);
static void ASN1CALL ASN1Free_RTPPayloadType_payloadDescriptor(RTPPayloadType_payloadDescriptor *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard(PH2250LogicalChannelParameters_nonStandard *val);
static void ASN1CALL ASN1Free_H223LogicalChannelParameters_adaptationLayerType(H223LogicalChannelParameters_adaptationLayerType *val);
static void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData(PConferenceCapability_nonStandardData *val);
static void ASN1CALL ASN1Free_UserInputCapability_nonStandard(UserInputCapability_nonStandard *val);
static void ASN1CALL ASN1Free_H263Options_modeCombos(PH263Options_modeCombos *val);
static void ASN1CALL ASN1Free_TransportCapability_qOSCapabilities(PTransportCapability_qOSCapabilities *val);
static void ASN1CALL ASN1Free_NonStandardMessage(NonStandardMessage *val);
static void ASN1CALL ASN1Free_RedundancyEncodingCapability(RedundancyEncodingCapability *val);
static void ASN1CALL ASN1Free_H263VideoCapability(H263VideoCapability *val);
static void ASN1CALL ASN1Free_EnhancementOptions(EnhancementOptions *val);
static void ASN1CALL ASN1Free_DataProtocolCapability(DataProtocolCapability *val);
static void ASN1CALL ASN1Free_EncryptionAuthenticationAndIntegrity(EncryptionAuthenticationAndIntegrity *val);
static void ASN1CALL ASN1Free_EncryptionCapability(PEncryptionCapability *val);
static void ASN1CALL ASN1Free_UserInputCapability(UserInputCapability *val);
static void ASN1CALL ASN1Free_H223LogicalChannelParameters(H223LogicalChannelParameters *val);
static void ASN1CALL ASN1Free_RTPPayloadType(RTPPayloadType *val);
static void ASN1CALL ASN1Free_H245TransportAddress(H245TransportAddress *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters(H2250LogicalChannelAckParameters *val);
static void ASN1CALL ASN1Free_H223ModeParameters(H223ModeParameters *val);
static void ASN1CALL ASN1Free_RedundancyEncodingMode(RedundancyEncodingMode *val);
static void ASN1CALL ASN1Free_VideoMode(VideoMode *val);
static void ASN1CALL ASN1Free_EncryptionCommand(EncryptionCommand *val);
static void ASN1CALL ASN1Free_MiscellaneousCommand(MiscellaneousCommand *val);
static void ASN1CALL ASN1Free_MiscellaneousIndication(MiscellaneousIndication *val);
static void ASN1CALL ASN1Free_MCLocationIndication(MCLocationIndication *val);
static void ASN1CALL ASN1Free_UserInputIndication(UserInputIndication *val);
static void ASN1CALL ASN1Free_DataApplicationCapability_application_nlpid(DataApplicationCapability_application_nlpid *val);
static void ASN1CALL ASN1Free_DataApplicationCapability_application_t84(DataApplicationCapability_application_t84 *val);
static void ASN1CALL ASN1Free_DataMode_application_nlpid(DataMode_application_nlpid *val);
static void ASN1CALL ASN1Free_DataMode_application(DataMode_application *val);
static void ASN1CALL ASN1Free_OpenLogicalChannelAck_forwardMultiplexAckParameters(OpenLogicalChannelAck_forwardMultiplexAckParameters *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_mediaPacketization(H2250LogicalChannelParameters_mediaPacketization *val);
static void ASN1CALL ASN1Free_NetworkAccessParameters_networkAddress(NetworkAccessParameters_networkAddress *val);
static void ASN1CALL ASN1Free_DataApplicationCapability_application(DataApplicationCapability_application *val);
static void ASN1CALL ASN1Free_EnhancementLayerInfo_spatialEnhancement(PEnhancementLayerInfo_spatialEnhancement *val);
static void ASN1CALL ASN1Free_EnhancementLayerInfo_snrEnhancement(PEnhancementLayerInfo_snrEnhancement *val);
static void ASN1CALL ASN1Free_MediaPacketizationCapability_rtpPayloadType(MediaPacketizationCapability_rtpPayloadType *val);
static void ASN1CALL ASN1Free_H2250Capability_redundancyEncodingCapability(PH2250Capability_redundancyEncodingCapability *val);
static void ASN1CALL ASN1Free_CommandMessage(CommandMessage *val);
static void ASN1CALL ASN1Free_H235SecurityCapability(H235SecurityCapability *val);
static void ASN1CALL ASN1Free_MediaPacketizationCapability(MediaPacketizationCapability *val);
static void ASN1CALL ASN1Free_VideoCapability(VideoCapability *val);
static void ASN1CALL ASN1Free_BEnhancementParameters(BEnhancementParameters *val);
static void ASN1CALL ASN1Free_DataApplicationCapability(DataApplicationCapability *val);
static void ASN1CALL ASN1Free_NetworkAccessParameters(NetworkAccessParameters *val);
static void ASN1CALL ASN1Free_H2250ModeParameters(H2250ModeParameters *val);
static void ASN1CALL ASN1Free_DataMode(DataMode *val);
static void ASN1CALL ASN1Free_CommunicationModeTableEntry_dataType(CommunicationModeTableEntry_dataType *val);
static void ASN1CALL ASN1Free_H235Mode_mediaMode(H235Mode_mediaMode *val);
static void ASN1CALL ASN1Free_H235Media_mediaType(H235Media_mediaType *val);
static void ASN1CALL ASN1Free_EnhancementLayerInfo_bPictureEnhancement(PEnhancementLayerInfo_bPictureEnhancement *val);
static void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData(PMediaDistributionCapability_distributedData *val);
static void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData(PMediaDistributionCapability_centralizedData *val);
static void ASN1CALL ASN1Free_Capability(Capability *val);
static void ASN1CALL ASN1Free_H2250Capability(H2250Capability *val);
static void ASN1CALL ASN1Free_H235Media(H235Media *val);
static void ASN1CALL ASN1Free_H235Mode(H235Mode *val);
static void ASN1CALL ASN1Free_ModeElement_type(ModeElement_type *val);
static void ASN1CALL ASN1Free_CapabilityTableEntry(CapabilityTableEntry *val);
static void ASN1CALL ASN1Free_MultiplexCapability(MultiplexCapability *val);
static void ASN1CALL ASN1Free_DataType(DataType *val);
static void ASN1CALL ASN1Free_RedundancyEncoding(RedundancyEncoding *val);
static void ASN1CALL ASN1Free_ModeElement(ModeElement *val);
static void ASN1CALL ASN1Free_CommunicationModeTableEntry(CommunicationModeTableEntry *val);
static void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable(PCommunicationModeResponse_communicationModeTable *val);
static void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable(PCommunicationModeCommand_communicationModeTable *val);
static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable(PTerminalCapabilitySet_capabilityTable *val);
static void ASN1CALL ASN1Free_TerminalCapabilitySet(TerminalCapabilitySet *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelParameters(H2250LogicalChannelParameters *val);
static void ASN1CALL ASN1Free_ModeDescription(ModeDescription *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val);
static void ASN1CALL ASN1Free_RequestMode_requestedModes(PRequestMode_requestedModes *val);
static void ASN1CALL ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters(OpenLogicalChannelAck_reverseLogicalChannelParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters(OpenLogicalChannel_reverseLogicalChannelParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters(OpenLogicalChannel_forwardLogicalChannelParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel(OpenLogicalChannel *val);
static void ASN1CALL ASN1Free_OpenLogicalChannelAck(OpenLogicalChannelAck *val);
static void ASN1CALL ASN1Free_RequestMessage(RequestMessage *val);
static void ASN1CALL ASN1Free_ResponseMessage(ResponseMessage *val);
static void ASN1CALL ASN1Free_FastConnectOLC(FastConnectOLC *val);
static void ASN1CALL ASN1Free_FunctionNotUnderstood(FunctionNotUnderstood *val);
static void ASN1CALL ASN1Free_IndicationMessage(IndicationMessage *val);
static void ASN1CALL ASN1Free_MultimediaSystemControlMessage(MultimediaSystemControlMessage *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[2] = {
    (ASN1EncFun_t) ASN1Enc_FastConnectOLC,
    (ASN1EncFun_t) ASN1Enc_MultimediaSystemControlMessage,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[2] = {
    (ASN1DecFun_t) ASN1Dec_FastConnectOLC,
    (ASN1DecFun_t) ASN1Dec_MultimediaSystemControlMessage,
};
static const ASN1FreeFun_t freefntab[2] = {
    (ASN1FreeFun_t) ASN1Free_FastConnectOLC,
    (ASN1FreeFun_t) ASN1Free_MultimediaSystemControlMessage,
};
static const ULONG sizetab[2] = {
    SIZE_H245PP_Module_PDU_0,
    SIZE_H245PP_Module_PDU_1,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL H245PP_Module_Startup(void)
{
    H245PP_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 2, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x35343268);
}

void ASN1CALL H245PP_Module_Cleanup(void)
{
    ASN1_CloseModule(H245PP_Module);
    H245PP_Module = NULL;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1_errorCorrection(ASN1encoding_t enc, NewATMVCIndication_aal_aal1_errorCorrection *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1_errorCorrection(ASN1decoding_t dec, NewATMVCIndication_aal_aal1_errorCorrection *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1_clockRecovery(ASN1encoding_t enc, NewATMVCIndication_aal_aal1_clockRecovery *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1_clockRecovery(ASN1decoding_t dec, NewATMVCIndication_aal_aal1_clockRecovery *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(ASN1encoding_t enc, MiscellaneousCommand_type_progressiveRefinementStart_repeatCount *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(ASN1decoding_t dec, MiscellaneousCommand_type_progressiveRefinementStart_repeatCount *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode_eRM_recovery(ASN1encoding_t enc, V76LogicalChannelParameters_mode_eRM_recovery *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode_eRM_recovery(ASN1decoding_t dec, V76LogicalChannelParameters_mode_eRM_recovery *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_extendedPAR_Set *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->width - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->height - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_extendedPAR_Set *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->width))
	return 0;
    (val)->width += 1;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->height))
	return 0;
    (val)->height += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI_customPCF_Set(ASN1encoding_t enc, CustomPictureFormat_mPI_customPCF_Set *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->clockConversionCode - 1000))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->clockDivisor - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->customMPI - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI_customPCF_Set(ASN1decoding_t dec, CustomPictureFormat_mPI_customPCF_Set *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 1, &(val)->clockConversionCode))
	return 0;
    (val)->clockConversionCode += 1000;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->clockDivisor))
	return 0;
    (val)->clockDivisor += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->customMPI))
	return 0;
    (val)->customMPI += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_availableBitRates_type_rangeOfBitRates(ASN1encoding_t enc, VCCapability_availableBitRates_type_rangeOfBitRates *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->lowerBitRate - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->higherBitRate - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_availableBitRates_type_rangeOfBitRates(ASN1decoding_t dec, VCCapability_availableBitRates_type_rangeOfBitRates *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->lowerBitRate))
	return 0;
    (val)->lowerBitRate += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->higherBitRate))
	return 0;
    (val)->higherBitRate += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(ASN1encoding_t enc, TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.highestEntryNumberProcessed - 1))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(ASN1decoding_t dec, TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.highestEntryNumberProcessed))
	    return 0;
	(val)->u.highestEntryNumberProcessed += 1;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_availableBitRates_type(ASN1encoding_t enc, VCCapability_availableBitRates_type *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.singleBitRate - 1))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_VCCapability_availableBitRates_type_rangeOfBitRates(enc, &(val)->u.rangeOfBitRates))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_availableBitRates_type(ASN1decoding_t dec, VCCapability_availableBitRates_type *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.singleBitRate))
	    return 0;
	(val)->u.singleBitRate += 1;
	break;
    case 2:
	if (!ASN1Dec_VCCapability_availableBitRates_type_rangeOfBitRates(dec, &(val)->u.rangeOfBitRates))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223Capability_h223MultiplexTableCapability_enhanced(ASN1encoding_t enc, H223Capability_h223MultiplexTableCapability_enhanced *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->maximumNestingDepth - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->maximumElementListSize - 2))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->maximumSubElementListSize - 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223Capability_h223MultiplexTableCapability_enhanced(ASN1decoding_t dec, H223Capability_h223MultiplexTableCapability_enhanced *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->maximumNestingDepth))
	return 0;
    (val)->maximumNestingDepth += 1;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maximumElementListSize))
	return 0;
    (val)->maximumElementListSize += 2;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maximumSubElementListSize))
	return 0;
    (val)->maximumSubElementListSize += 2;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI_customPCF(ASN1encoding_t enc, CustomPictureFormat_mPI_customPCF *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_CustomPictureFormat_mPI_customPCF_Set(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI_customPCF(ASN1decoding_t dec, CustomPictureFormat_mPI_customPCF *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_CustomPictureFormat_mPI_customPCF_Set(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat_mPI_customPCF(CustomPictureFormat_mPI_customPCF *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_extendedPAR *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_extendedPAR *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation_extendedPAR(CustomPictureFormat_pixelAspectInformation_extendedPAR *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H223LogicalChannelParameters_adaptationLayerType_al3(ASN1encoding_t enc, H223LogicalChannelParameters_adaptationLayerType_al3 *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncBitVal(enc, 2, (val)->controlFieldOctets))
	return 0;
    l = ASN1uint32_uoctets((val)->sendBufferSize);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223LogicalChannelParameters_adaptationLayerType_al3(ASN1decoding_t dec, H223LogicalChannelParameters_adaptationLayerType_al3 *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecU16Val(dec, 2, &(val)->controlFieldOctets))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode_eRM(ASN1encoding_t enc, V76LogicalChannelParameters_mode_eRM *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->windowSize - 1))
	return 0;
    if (!ASN1Enc_V76LogicalChannelParameters_mode_eRM_recovery(enc, &(val)->recovery))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode_eRM(ASN1decoding_t dec, V76LogicalChannelParameters_mode_eRM *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->windowSize))
	return 0;
    (val)->windowSize += 1;
    if (!ASN1Dec_V76LogicalChannelParameters_mode_eRM_recovery(dec, &(val)->recovery))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn);
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route(PUnicastAddress_iPSourceRouteAddress_route *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn(PUnicastAddress_iPSourceRouteAddress_route val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_routing(ASN1encoding_t enc, UnicastAddress_iPSourceRouteAddress_routing *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_routing(ASN1decoding_t dec, UnicastAddress_iPSourceRouteAddress_routing *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223ModeParameters_adaptationLayerType_al3(ASN1encoding_t enc, H223ModeParameters_adaptationLayerType_al3 *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncBitVal(enc, 2, (val)->controlFieldOctets))
	return 0;
    l = ASN1uint32_uoctets((val)->sendBufferSize);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223ModeParameters_adaptationLayerType_al3(ASN1decoding_t dec, H223ModeParameters_adaptationLayerType_al3 *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecU16Val(dec, 2, &(val)->controlFieldOctets))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(ASN1encoding_t enc, SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(ASN1decoding_t dec, SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn, 1, 65535, 16);
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn, sizeof(**val), 1, 65535, 16);
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart(ASN1encoding_t enc, MiscellaneousCommand_type_progressiveRefinementStart *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(enc, &(val)->repeatCount))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart(ASN1decoding_t dec, MiscellaneousCommand_type_progressiveRefinementStart *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(dec, &(val)->repeatCount))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_videoFastUpdateMB(ASN1encoding_t enc, MiscellaneousCommand_type_videoFastUpdateMB *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->firstGOB))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->firstMB - 1))
	    return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->numberOfMBs - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_videoFastUpdateMB(ASN1decoding_t dec, MiscellaneousCommand_type_videoFastUpdateMB *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->firstGOB))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->firstMB))
	    return 0;
	(val)->firstMB += 1;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->numberOfMBs))
	return 0;
    (val)->numberOfMBs += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_videoFastUpdateGOB(ASN1encoding_t enc, MiscellaneousCommand_type_videoFastUpdateGOB *val)
{
    if (!ASN1PEREncBitVal(enc, 5, (val)->firstGOB))
	return 0;
    if (!ASN1PEREncBitVal(enc, 5, (val)->numberOfGOBs - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_videoFastUpdateGOB(ASN1decoding_t dec, MiscellaneousCommand_type_videoFastUpdateGOB *val)
{
    if (!ASN1PERDecU16Val(dec, 5, &(val)->firstGOB))
	return 0;
    if (!ASN1PERDecU16Val(dec, 5, &(val)->numberOfGOBs))
	return 0;
    (val)->numberOfGOBs += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousIndication_type_videoNotDecodedMBs(ASN1encoding_t enc, MiscellaneousIndication_type_videoNotDecodedMBs *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->firstMB - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->numberOfMBs - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->temporalReference))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousIndication_type_videoNotDecodedMBs(ASN1decoding_t dec, MiscellaneousIndication_type_videoNotDecodedMBs *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->firstMB))
	return 0;
    (val)->firstMB += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->numberOfMBs))
	return 0;
    (val)->numberOfMBs += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->temporalReference))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal5(ASN1encoding_t enc, NewATMVCIndication_aal_aal5 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardMaximumSDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->backwardMaximumSDUSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal5(ASN1decoding_t dec, NewATMVCIndication_aal_aal5 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardMaximumSDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->backwardMaximumSDUSize))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1(ASN1encoding_t enc, NewATMVCIndication_aal_aal1 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_NewATMVCIndication_aal_aal1_clockRecovery(enc, &(val)->clockRecovery))
	return 0;
    if (!ASN1Enc_NewATMVCIndication_aal_aal1_errorCorrection(enc, &(val)->errorCorrection))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->structuredDataTransfer))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->partiallyFilledCells))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1(ASN1decoding_t dec, NewATMVCIndication_aal_aal1 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_NewATMVCIndication_aal_aal1_clockRecovery(dec, &(val)->clockRecovery))
	return 0;
    if (!ASN1Dec_NewATMVCIndication_aal_aal1_errorCorrection(dec, &(val)->errorCorrection))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->structuredDataTransfer))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->partiallyFilledCells))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_reverseParameters_multiplex(ASN1encoding_t enc, NewATMVCIndication_reverseParameters_multiplex *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_reverseParameters_multiplex(ASN1decoding_t dec, NewATMVCIndication_reverseParameters_multiplex *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UserInputIndication_signal_rtp(ASN1encoding_t enc, UserInputIndication_signal_rtp *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->timestamp);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->timestamp))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->expirationTime);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->expirationTime))
	    return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication_signal_rtp(ASN1decoding_t dec, UserInputIndication_signal_rtp *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->timestamp))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->expirationTime))
	    return 0;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber))
	return 0;
    (val)->logicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UserInputIndication_signalUpdate_rtp(ASN1encoding_t enc, UserInputIndication_signalUpdate_rtp *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication_signalUpdate_rtp(ASN1decoding_t dec, UserInputIndication_signalUpdate_rtp *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber))
	return 0;
    (val)->logicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UserInputIndication_signalUpdate(ASN1encoding_t enc, UserInputIndication_signalUpdate *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->duration - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_UserInputIndication_signalUpdate_rtp(enc, &(val)->rtp))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication_signalUpdate(ASN1decoding_t dec, UserInputIndication_signalUpdate *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->duration))
	return 0;
    (val)->duration += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_UserInputIndication_signalUpdate_rtp(dec, &(val)->rtp))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UserInputIndication_signal(ASN1encoding_t enc, UserInputIndication_signal *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    t = lstrlenA((val)->signalType);
    if (!ASN1PEREncCharString(enc, t, (val)->signalType, 8))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->duration - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_UserInputIndication_signal_rtp(enc, &(val)->rtp))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication_signal(ASN1decoding_t dec, UserInputIndication_signal *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
 
    // SECURITY BUG: 782696
    if ( 1 >= sizeof( (val)->signalType ) )
    {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0;
    }

    if (!ASN1PERDecZeroCharStringNoAlloc(dec, 1, (val)->signalType, 8))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->duration))
	    return 0;
	(val)->duration += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_UserInputIndication_signal_rtp(dec, &(val)->rtp))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputIndication_signal(UserInputIndication_signal *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_reverseParameters(ASN1encoding_t enc, NewATMVCIndication_reverseParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->bitRateLockedToPCRClock))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->bitRateLockedToNetworkClock))
	return 0;
    if (!ASN1Enc_NewATMVCIndication_reverseParameters_multiplex(enc, &(val)->multiplex))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_reverseParameters(ASN1decoding_t dec, NewATMVCIndication_reverseParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->bitRateLockedToPCRClock))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->bitRateLockedToNetworkClock))
	return 0;
    if (!ASN1Dec_NewATMVCIndication_reverseParameters_multiplex(dec, &(val)->multiplex))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_multiplex(ASN1encoding_t enc, NewATMVCIndication_multiplex *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_multiplex(ASN1decoding_t dec, NewATMVCIndication_multiplex *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal(ASN1encoding_t enc, NewATMVCIndication_aal *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NewATMVCIndication_aal_aal1(enc, &(val)->u.aal1))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_NewATMVCIndication_aal_aal5(enc, &(val)->u.aal5))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal(ASN1decoding_t dec, NewATMVCIndication_aal *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NewATMVCIndication_aal_aal1(dec, &(val)->u.aal1))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_NewATMVCIndication_aal_aal5(dec, &(val)->u.aal5))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_JitterIndication_scope(ASN1encoding_t enc, JitterIndication_scope *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelNumber - 1))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.resourceID))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_JitterIndication_scope(ASN1decoding_t dec, JitterIndication_scope *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelNumber))
	    return 0;
	(val)->u.logicalChannelNumber += 1;
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.resourceID))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_FunctionNotSupported_cause(ASN1encoding_t enc, FunctionNotSupported_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FunctionNotSupported_cause(ASN1decoding_t dec, FunctionNotSupported_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration_h223AnnexADoubleFlag(ASN1encoding_t enc, H223MultiplexReconfiguration_h223AnnexADoubleFlag *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration_h223AnnexADoubleFlag(ASN1decoding_t dec, H223MultiplexReconfiguration_h223AnnexADoubleFlag *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration_h223ModeChange(ASN1encoding_t enc, H223MultiplexReconfiguration_h223ModeChange *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration_h223ModeChange(ASN1decoding_t dec, H223MultiplexReconfiguration_h223ModeChange *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_EndSessionCommand_isdnOptions(ASN1encoding_t enc, EndSessionCommand_isdnOptions *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EndSessionCommand_isdnOptions(ASN1decoding_t dec, EndSessionCommand_isdnOptions *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_EndSessionCommand_gstnOptions(ASN1encoding_t enc, EndSessionCommand_gstnOptions *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EndSessionCommand_gstnOptions(ASN1decoding_t dec, EndSessionCommand_gstnOptions *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_FlowControlCommand_restriction(ASN1encoding_t enc, FlowControlCommand_restriction *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	l = ASN1uint32_uoctets((val)->u.maximumBitRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->u.maximumBitRate))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FlowControlCommand_restriction(ASN1decoding_t dec, FlowControlCommand_restriction *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->u.maximumBitRate))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_FlowControlCommand_scope(ASN1encoding_t enc, FlowControlCommand_scope *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelNumber - 1))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.resourceID))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FlowControlCommand_scope(ASN1decoding_t dec, FlowControlCommand_scope *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelNumber))
	    return 0;
	(val)->u.logicalChannelNumber += 1;
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.resourceID))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest(ASN1encoding_t enc, SendTerminalCapabilitySet_specificRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multiplexCapability))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(enc, &(val)->capabilityTableEntryNumbers))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(enc, &(val)->capabilityDescriptorNumbers))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest(ASN1decoding_t dec, SendTerminalCapabilitySet_specificRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multiplexCapability))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(dec, &(val)->capabilityTableEntryNumbers))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(dec, &(val)->capabilityDescriptorNumbers))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest(SendTerminalCapabilitySet_specificRequest *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(&(val)->capabilityTableEntryNumbers);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(&(val)->capabilityDescriptorNumbers);
	}
    }
}

static int ASN1CALL ASN1Enc_RemoteMCResponse_reject(ASN1encoding_t enc, RemoteMCResponse_reject *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteMCResponse_reject(ASN1decoding_t dec, RemoteMCResponse_reject *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceResponse_sendThisSourceResponse(ASN1encoding_t enc, ConferenceResponse_sendThisSourceResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_sendThisSourceResponse(ASN1decoding_t dec, ConferenceResponse_sendThisSourceResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceResponse_makeTerminalBroadcasterResponse(ASN1encoding_t enc, ConferenceResponse_makeTerminalBroadcasterResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_makeTerminalBroadcasterResponse(ASN1decoding_t dec, ConferenceResponse_makeTerminalBroadcasterResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceResponse_broadcastMyLogicalChannelResponse(ASN1encoding_t enc, ConferenceResponse_broadcastMyLogicalChannelResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_broadcastMyLogicalChannelResponse(ASN1decoding_t dec, ConferenceResponse_broadcastMyLogicalChannelResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceResponse_extensionAddressResponse(ASN1encoding_t enc, ConferenceResponse_extensionAddressResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->extensionAddress, 1, 128, 7))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_extensionAddressResponse(ASN1decoding_t dec, ConferenceResponse_extensionAddressResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->extensionAddress, 1, 128, 7))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_extensionAddressResponse(ConferenceResponse_extensionAddressResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_makeMeChairResponse(ASN1encoding_t enc, ConferenceResponse_makeMeChairResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_makeMeChairResponse(ASN1decoding_t dec, ConferenceResponse_makeMeChairResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopReject_cause(ASN1encoding_t enc, MaintenanceLoopReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopReject_cause(ASN1decoding_t dec, MaintenanceLoopReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopReject_type(ASN1encoding_t enc, MaintenanceLoopReject_type *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.mediaLoop - 1))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelLoop - 1))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopReject_type(ASN1decoding_t dec, MaintenanceLoopReject_type *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.mediaLoop))
	    return 0;
	(val)->u.mediaLoop += 1;
	break;
    case 3:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelLoop))
	    return 0;
	(val)->u.logicalChannelLoop += 1;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopAck_type(ASN1encoding_t enc, MaintenanceLoopAck_type *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.mediaLoop - 1))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelLoop - 1))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopAck_type(ASN1decoding_t dec, MaintenanceLoopAck_type *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.mediaLoop))
	    return 0;
	(val)->u.mediaLoop += 1;
	break;
    case 3:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelLoop))
	    return 0;
	(val)->u.logicalChannelLoop += 1;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopRequest_type(ASN1encoding_t enc, MaintenanceLoopRequest_type *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.mediaLoop - 1))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelLoop - 1))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopRequest_type(ASN1decoding_t dec, MaintenanceLoopRequest_type *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.mediaLoop))
	    return 0;
	(val)->u.mediaLoop += 1;
	break;
    case 3:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelLoop))
	    return 0;
	(val)->u.logicalChannelLoop += 1;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_G7231AnnexCMode_g723AnnexCAudioMode(ASN1encoding_t enc, G7231AnnexCMode_g723AnnexCAudioMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->highRateMode0 - 27))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->highRateMode1 - 27))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->lowRateMode0 - 23))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->lowRateMode1 - 23))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->sidMode0 - 6))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->sidMode1 - 6))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_G7231AnnexCMode_g723AnnexCAudioMode(ASN1decoding_t dec, G7231AnnexCMode_g723AnnexCAudioMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->highRateMode0))
	return 0;
    (val)->highRateMode0 += 27;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->highRateMode1))
	return 0;
    (val)->highRateMode1 += 27;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->lowRateMode0))
	return 0;
    (val)->lowRateMode0 += 23;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->lowRateMode1))
	return 0;
    (val)->lowRateMode1 += 23;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->sidMode0))
	return 0;
    (val)->sidMode0 += 6;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->sidMode1))
	return 0;
    (val)->sidMode1 += 6;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioMode_multichannelType(ASN1encoding_t enc, IS13818AudioMode_multichannelType *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioMode_multichannelType(ASN1decoding_t dec, IS13818AudioMode_multichannelType *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioMode_audioSampling(ASN1encoding_t enc, IS13818AudioMode_audioSampling *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioMode_audioSampling(ASN1decoding_t dec, IS13818AudioMode_audioSampling *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioMode_audioLayer(ASN1encoding_t enc, IS13818AudioMode_audioLayer *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioMode_audioLayer(ASN1decoding_t dec, IS13818AudioMode_audioLayer *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioMode_multichannelType(ASN1encoding_t enc, IS11172AudioMode_multichannelType *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioMode_multichannelType(ASN1decoding_t dec, IS11172AudioMode_multichannelType *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioMode_audioSampling(ASN1encoding_t enc, IS11172AudioMode_audioSampling *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioMode_audioSampling(ASN1decoding_t dec, IS11172AudioMode_audioSampling *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioMode_audioLayer(ASN1encoding_t enc, IS11172AudioMode_audioLayer *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioMode_audioLayer(ASN1decoding_t dec, IS11172AudioMode_audioLayer *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_AudioMode_g7231(ASN1encoding_t enc, AudioMode_g7231 *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AudioMode_g7231(ASN1decoding_t dec, AudioMode_g7231 *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H263VideoMode_resolution(ASN1encoding_t enc, H263VideoMode_resolution *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoMode_resolution(ASN1decoding_t dec, H263VideoMode_resolution *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H262VideoMode_profileAndLevel(ASN1encoding_t enc, H262VideoMode_profileAndLevel *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H262VideoMode_profileAndLevel(ASN1decoding_t dec, H262VideoMode_profileAndLevel *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H261VideoMode_resolution(ASN1encoding_t enc, H261VideoMode_resolution *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H261VideoMode_resolution(ASN1decoding_t dec, H261VideoMode_resolution *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestModeReject_cause(ASN1encoding_t enc, RequestModeReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeReject_cause(ASN1decoding_t dec, RequestModeReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestModeAck_response(ASN1encoding_t enc, RequestModeAck_response *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeAck_response(ASN1decoding_t dec, RequestModeAck_response *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryRelease_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryRelease_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryRelease_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryRelease_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryRelease_entryNumbers(RequestMultiplexEntryRelease_entryNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryRejectionDescriptions_cause(ASN1encoding_t enc, RequestMultiplexEntryRejectionDescriptions_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryRejectionDescriptions_cause(ASN1decoding_t dec, RequestMultiplexEntryRejectionDescriptions_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryReject_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryReject_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryReject_entryNumbers(RequestMultiplexEntryReject_entryNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryAck_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryAck_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryAck_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryAck_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryAck_entryNumbers(RequestMultiplexEntryAck_entryNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntry_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntry_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntry_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntry_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntry_entryNumbers(RequestMultiplexEntry_entryNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendRelease_multiplexTableEntryNumber(ASN1encoding_t enc, MultiplexEntrySendRelease_multiplexTableEntryNumber *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendRelease_multiplexTableEntryNumber(ASN1decoding_t dec, MultiplexEntrySendRelease_multiplexTableEntryNumber *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendRelease_multiplexTableEntryNumber(MultiplexEntrySendRelease_multiplexTableEntryNumber *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntryRejectionDescriptions_cause(ASN1encoding_t enc, MultiplexEntryRejectionDescriptions_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntryRejectionDescriptions_cause(ASN1decoding_t dec, MultiplexEntryRejectionDescriptions_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendAck_multiplexTableEntryNumber(ASN1encoding_t enc, MultiplexEntrySendAck_multiplexTableEntryNumber *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendAck_multiplexTableEntryNumber(ASN1decoding_t dec, MultiplexEntrySendAck_multiplexTableEntryNumber *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendAck_multiplexTableEntryNumber(MultiplexEntrySendAck_multiplexTableEntryNumber *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexElement_repeatCount(ASN1encoding_t enc, MultiplexElement_repeatCount *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.finite - 1))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexElement_repeatCount(ASN1decoding_t dec, MultiplexElement_repeatCount *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.finite))
	    return 0;
	(val)->u.finite += 1;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexElement_type(ASN1encoding_t enc, MultiplexElement_type *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MultiplexElement_type_subElementList(enc, &(val)->u.subElementList))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexElement_type(ASN1decoding_t dec, MultiplexElement_type *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MultiplexElement_type_subElementList(dec, &(val)->u.subElementList))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexElement_type(MultiplexElement_type *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_MultiplexElement_type_subElementList(&(val)->u.subElementList);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RequestChannelCloseReject_cause(ASN1encoding_t enc, RequestChannelCloseReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelCloseReject_cause(ASN1decoding_t dec, RequestChannelCloseReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestChannelClose_reason(ASN1encoding_t enc, RequestChannelClose_reason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelClose_reason(ASN1decoding_t dec, RequestChannelClose_reason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CloseLogicalChannel_reason(ASN1encoding_t enc, CloseLogicalChannel_reason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CloseLogicalChannel_reason(ASN1decoding_t dec, CloseLogicalChannel_reason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CloseLogicalChannel_source(ASN1encoding_t enc, CloseLogicalChannel_source *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CloseLogicalChannel_source(ASN1decoding_t dec, CloseLogicalChannel_source *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelReject_cause(ASN1encoding_t enc, OpenLogicalChannelReject_cause *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelReject_cause(ASN1decoding_t dec, OpenLogicalChannelReject_cause *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MulticastAddress_iP6Address(ASN1encoding_t enc, MulticastAddress_iP6Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MulticastAddress_iP6Address(ASN1decoding_t dec, MulticastAddress_iP6Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MulticastAddress_iP6Address(MulticastAddress_iP6Address *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MulticastAddress_iPAddress(ASN1encoding_t enc, MulticastAddress_iPAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MulticastAddress_iPAddress(ASN1decoding_t dec, MulticastAddress_iPAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MulticastAddress_iPAddress(MulticastAddress_iPAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress(ASN1encoding_t enc, UnicastAddress_iPSourceRouteAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_UnicastAddress_iPSourceRouteAddress_routing(enc, &(val)->routing))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
	return 0;
    if (!ASN1Enc_UnicastAddress_iPSourceRouteAddress_route(enc, &(val)->route))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress(ASN1decoding_t dec, UnicastAddress_iPSourceRouteAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_UnicastAddress_iPSourceRouteAddress_routing(dec, &(val)->routing))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
	return 0;
    if (!ASN1Dec_UnicastAddress_iPSourceRouteAddress_route(dec, &(val)->route))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress(UnicastAddress_iPSourceRouteAddress *val)
{
    if (val) {
	ASN1Free_UnicastAddress_iPSourceRouteAddress_route(&(val)->route);
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iP6Address(ASN1encoding_t enc, UnicastAddress_iP6Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iP6Address(ASN1decoding_t dec, UnicastAddress_iP6Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iP6Address(UnicastAddress_iP6Address *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPXAddress(ASN1encoding_t enc, UnicastAddress_iPXAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->tsapIdentifier, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPXAddress(ASN1decoding_t dec, UnicastAddress_iPXAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->tsapIdentifier, 2))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iPXAddress(UnicastAddress_iPXAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPAddress(ASN1encoding_t enc, UnicastAddress_iPAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPAddress(ASN1decoding_t dec, UnicastAddress_iPAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iPAddress(UnicastAddress_iPAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode(ASN1encoding_t enc, V76LogicalChannelParameters_mode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_V76LogicalChannelParameters_mode_eRM(enc, &(val)->u.eRM))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode(ASN1decoding_t dec, V76LogicalChannelParameters_mode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_V76LogicalChannelParameters_mode_eRM(dec, &(val)->u.eRM))
	    return 0;
	break;
    case 2:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_suspendResume(ASN1encoding_t enc, V76LogicalChannelParameters_suspendResume *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_suspendResume(ASN1decoding_t dec, V76LogicalChannelParameters_suspendResume *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AnnexCArqParameters_numberOfRetransmissions(ASN1encoding_t enc, H223AnnexCArqParameters_numberOfRetransmissions *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncBitVal(enc, 5, (val)->u.finite))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexCArqParameters_numberOfRetransmissions(ASN1decoding_t dec, H223AnnexCArqParameters_numberOfRetransmissions *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU16Val(dec, 5, &(val)->u.finite))
	    return 0;
	break;
    case 2:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL3MParameters_crcLength(ASN1encoding_t enc, H223AL3MParameters_crcLength *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL3MParameters_crcLength(ASN1decoding_t dec, H223AL3MParameters_crcLength *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL3MParameters_headerFormat(ASN1encoding_t enc, H223AL3MParameters_headerFormat *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL3MParameters_headerFormat(ASN1decoding_t dec, H223AL3MParameters_headerFormat *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL2MParameters_headerFEC(ASN1encoding_t enc, H223AL2MParameters_headerFEC *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL2MParameters_headerFEC(ASN1decoding_t dec, H223AL2MParameters_headerFEC *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL1MParameters_crcLength(ASN1encoding_t enc, H223AL1MParameters_crcLength *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL1MParameters_crcLength(ASN1decoding_t dec, H223AL1MParameters_crcLength *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL1MParameters_headerFEC(ASN1encoding_t enc, H223AL1MParameters_headerFEC *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL1MParameters_headerFEC(ASN1decoding_t dec, H223AL1MParameters_headerFEC *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL1MParameters_transferMode(ASN1encoding_t enc, H223AL1MParameters_transferMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL1MParameters_transferMode(ASN1decoding_t dec, H223AL1MParameters_transferMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static ASN1stringtableentry_t Q2931Address_address_internationalNumber_StringTableEntries[] = {
    { 32, 32, 0 }, { 48, 57, 1 }, 
};

static ASN1stringtable_t Q2931Address_address_internationalNumber_StringTable = {
    2, Q2931Address_address_internationalNumber_StringTableEntries
};

static int ASN1CALL ASN1Enc_Q2931Address_address(ASN1encoding_t enc, Q2931Address_address *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	t = lstrlenA((val)->u.internationalNumber);
	if (!ASN1PEREncBitVal(enc, 4, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.internationalNumber, 4, &Q2931Address_address_internationalNumber_StringTable))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->u.nsapAddress, 1, 20, 5))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Q2931Address_address(ASN1decoding_t dec, Q2931Address_address *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 4, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);

        // SECURITY BUG: 782696
        if ( l >= sizeof( (val)->u.internationalNumber ) )
        {
            ASN1DecSetError(dec, ASN1_ERR_LARGE);
            return 0;
        }

	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.internationalNumber, 4, &Q2931Address_address_internationalNumber_StringTable))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->u.nsapAddress, 1, 20, 5))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Q2931Address_address(Q2931Address_address *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	case 2:
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_NetworkAccessParameters_t120SetupProcedure(ASN1encoding_t enc, NetworkAccessParameters_t120SetupProcedure *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAccessParameters_t120SetupProcedure(ASN1decoding_t dec, NetworkAccessParameters_t120SetupProcedure *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NetworkAccessParameters_distribution(ASN1encoding_t enc, NetworkAccessParameters_distribution *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAccessParameters_distribution(ASN1decoding_t dec, NetworkAccessParameters_distribution *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_T84Profile_t84Restricted(ASN1encoding_t enc, T84Profile_t84Restricted *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->qcif))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->cif))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->ccir601Seq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->ccir601Prog))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->hdtvSeq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->hdtvProg))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->g3FacsMH200x100))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->g3FacsMH200x200))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->g4FacsMMR200x100))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->g4FacsMMR200x200))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->jbig200x200Seq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->jbig200x200Prog))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->jbig300x300Seq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->jbig300x300Prog))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoLow))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoMedSeq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoMedProg))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoHighSeq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoHighProg))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_T84Profile_t84Restricted(ASN1decoding_t dec, T84Profile_t84Restricted *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->qcif))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->cif))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->ccir601Seq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->ccir601Prog))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->hdtvSeq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->hdtvProg))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->g3FacsMH200x100))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->g3FacsMH200x200))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->g4FacsMMR200x100))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->g4FacsMMR200x200))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->jbig200x200Seq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->jbig200x200Prog))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->jbig300x300Seq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->jbig300x300Prog))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoLow))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoMedSeq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoMedProg))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoHighSeq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoHighProg))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_G7231AnnexCCapability_g723AnnexCAudioMode(ASN1encoding_t enc, G7231AnnexCCapability_g723AnnexCAudioMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->highRateMode0 - 27))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->highRateMode1 - 27))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->lowRateMode0 - 23))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->lowRateMode1 - 23))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->sidMode0 - 6))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->sidMode1 - 6))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_G7231AnnexCCapability_g723AnnexCAudioMode(ASN1decoding_t dec, G7231AnnexCCapability_g723AnnexCAudioMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->highRateMode0))
	return 0;
    (val)->highRateMode0 += 27;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->highRateMode1))
	return 0;
    (val)->highRateMode1 += 27;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->lowRateMode0))
	return 0;
    (val)->lowRateMode0 += 23;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->lowRateMode1))
	return 0;
    (val)->lowRateMode1 += 23;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->sidMode0))
	return 0;
    (val)->sidMode0 += 6;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->sidMode1))
	return 0;
    (val)->sidMode1 += 6;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_AudioCapability_g7231(ASN1encoding_t enc, AudioCapability_g7231 *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->maxAl_sduAudioFrames - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->silenceSuppression))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AudioCapability_g7231(ASN1decoding_t dec, AudioCapability_g7231 *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maxAl_sduAudioFrames))
	return 0;
    (val)->maxAl_sduAudioFrames += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->silenceSuppression))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncBoolean(enc, (val)->u.anyPixelAspectRatio))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(enc, &(val)->u.pixelAspectCode))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR(enc, &(val)->u.extendedPAR))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecBoolean(dec, &(val)->u.anyPixelAspectRatio))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(dec, &(val)->u.pixelAspectCode))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR(dec, &(val)->u.extendedPAR))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation(CustomPictureFormat_pixelAspectInformation *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(&(val)->u.pixelAspectCode);
	    break;
	case 3:
	    ASN1Free_CustomPictureFormat_pixelAspectInformation_extendedPAR(&(val)->u.extendedPAR);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI(ASN1encoding_t enc, CustomPictureFormat_mPI *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->standardMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CustomPictureFormat_mPI_customPCF(enc, &(val)->customPCF))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI(ASN1decoding_t dec, CustomPictureFormat_mPI *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->standardMPI))
	    return 0;
	(val)->standardMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_CustomPictureFormat_mPI_customPCF(dec, &(val)->customPCF))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat_mPI(CustomPictureFormat_mPI *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CustomPictureFormat_mPI_customPCF(&(val)->customPCF);
	}
    }
}

static int ASN1CALL ASN1Enc_RefPictureSelection_videoBackChannelSend(ASN1encoding_t enc, RefPictureSelection_videoBackChannelSend *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RefPictureSelection_videoBackChannelSend(ASN1decoding_t dec, RefPictureSelection_videoBackChannelSend *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RefPictureSelection_additionalPictureMemory(ASN1encoding_t enc, RefPictureSelection_additionalPictureMemory *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->sqcifAdditionalPictureMemory - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->qcifAdditionalPictureMemory - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->cifAdditionalPictureMemory - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->cif4AdditionalPictureMemory - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->cif16AdditionalPictureMemory - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->bigCpfAdditionalPictureMemory - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RefPictureSelection_additionalPictureMemory(ASN1decoding_t dec, RefPictureSelection_additionalPictureMemory *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->sqcifAdditionalPictureMemory))
	    return 0;
	(val)->sqcifAdditionalPictureMemory += 1;
    }
    if ((val)->o[0] & 0x40) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->qcifAdditionalPictureMemory))
	    return 0;
	(val)->qcifAdditionalPictureMemory += 1;
    }
    if ((val)->o[0] & 0x20) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->cifAdditionalPictureMemory))
	    return 0;
	(val)->cifAdditionalPictureMemory += 1;
    }
    if ((val)->o[0] & 0x10) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->cif4AdditionalPictureMemory))
	    return 0;
	(val)->cif4AdditionalPictureMemory += 1;
    }
    if ((val)->o[0] & 0x8) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->cif16AdditionalPictureMemory))
	    return 0;
	(val)->cif16AdditionalPictureMemory += 1;
    }
    if ((val)->o[0] & 0x4) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->bigCpfAdditionalPictureMemory))
	    return 0;
	(val)->bigCpfAdditionalPictureMemory += 1;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyFrameMapping_frameSequence(ASN1encoding_t enc, RTPH263VideoRedundancyFrameMapping_frameSequence *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyFrameMapping_frameSequence(ASN1decoding_t dec, RTPH263VideoRedundancyFrameMapping_frameSequence *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyFrameMapping_frameSequence(RTPH263VideoRedundancyFrameMapping_frameSequence *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_containedThreads(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding_containedThreads *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_containedThreads(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding_containedThreads *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_containedThreads(RTPH263VideoRedundancyEncoding_containedThreads *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding_frameToThreadMapping *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(enc, &(val)->u.custom))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding_frameToThreadMapping *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(dec, &(val)->u.custom))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping(RTPH263VideoRedundancyEncoding_frameToThreadMapping *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(&(val)->u.custom);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncodingCapability_secondaryEncoding(ASN1encoding_t enc, PRedundancyEncodingCapability_secondaryEncoding *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RedundancyEncodingCapability_secondaryEncoding_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_RedundancyEncodingCapability_secondaryEncoding_ElmFn(ASN1encoding_t enc, PRedundancyEncodingCapability_secondaryEncoding val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncodingCapability_secondaryEncoding(ASN1decoding_t dec, PRedundancyEncodingCapability_secondaryEncoding *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RedundancyEncodingCapability_secondaryEncoding_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_RedundancyEncodingCapability_secondaryEncoding_ElmFn(ASN1decoding_t dec, PRedundancyEncodingCapability_secondaryEncoding val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncodingCapability_secondaryEncoding(PRedundancyEncodingCapability_secondaryEncoding *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RedundancyEncodingCapability_secondaryEncoding_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RedundancyEncodingCapability_secondaryEncoding_ElmFn(PRedundancyEncodingCapability_secondaryEncoding val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H2250Capability_mcCapability(ASN1encoding_t enc, H2250Capability_mcCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->centralizedConferenceMC))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->decentralizedConferenceMC))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250Capability_mcCapability(ASN1decoding_t dec, H2250Capability_mcCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->centralizedConferenceMC))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->decentralizedConferenceMC))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223Capability_mobileOperationTransmitCapability(ASN1encoding_t enc, H223Capability_mobileOperationTransmitCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->modeChangeCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h223AnnexA))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h223AnnexADoubleFlag))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h223AnnexB))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h223AnnexBwithHeader))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223Capability_mobileOperationTransmitCapability(ASN1decoding_t dec, H223Capability_mobileOperationTransmitCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->modeChangeCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h223AnnexA))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h223AnnexADoubleFlag))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h223AnnexB))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h223AnnexBwithHeader))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223Capability_h223MultiplexTableCapability(ASN1encoding_t enc, H223Capability_h223MultiplexTableCapability *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_H223Capability_h223MultiplexTableCapability_enhanced(enc, &(val)->u.enhanced))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223Capability_h223MultiplexTableCapability(ASN1decoding_t dec, H223Capability_h223MultiplexTableCapability *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_H223Capability_h223MultiplexTableCapability_enhanced(dec, &(val)->u.enhanced))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_availableBitRates(ASN1encoding_t enc, VCCapability_availableBitRates *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_VCCapability_availableBitRates_type(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_availableBitRates(ASN1decoding_t dec, VCCapability_availableBitRates *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_VCCapability_availableBitRates_type(dec, &(val)->type))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_aal5(ASN1encoding_t enc, VCCapability_aal5 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardMaximumSDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->backwardMaximumSDUSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_aal5(ASN1decoding_t dec, VCCapability_aal5 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardMaximumSDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->backwardMaximumSDUSize))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_aal1(ASN1encoding_t enc, VCCapability_aal1 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->nullClockRecovery))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->srtsClockRecovery))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->adaptiveClockRecovery))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->nullErrorCorrection))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->longInterleaver))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->shortInterleaver))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->errorCorrectionOnly))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->structuredDataTransfer))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->partiallyFilledCells))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_aal1(ASN1decoding_t dec, VCCapability_aal1 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->nullClockRecovery))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->srtsClockRecovery))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->adaptiveClockRecovery))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->nullErrorCorrection))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->longInterleaver))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->shortInterleaver))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->errorCorrectionOnly))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->structuredDataTransfer))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->partiallyFilledCells))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_Capability_h233EncryptionReceiveCapability(ASN1encoding_t enc, Capability_h233EncryptionReceiveCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->h233IVResponseTime))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Capability_h233EncryptionReceiveCapability(ASN1decoding_t dec, Capability_h233EncryptionReceiveCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->h233IVResponseTime))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject_cause(ASN1encoding_t enc, TerminalCapabilitySetReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Enc_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(enc, &(val)->u.tableEntryCapacityExceeded))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject_cause(ASN1decoding_t dec, TerminalCapabilitySetReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Dec_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(dec, &(val)->u.tableEntryCapacityExceeded))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationReject_cause(ASN1encoding_t enc, MasterSlaveDeterminationReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationReject_cause(ASN1decoding_t dec, MasterSlaveDeterminationReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationAck_decision(ASN1encoding_t enc, MasterSlaveDeterminationAck_decision *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationAck_decision(ASN1decoding_t dec, MasterSlaveDeterminationAck_decision *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NonStandardIdentifier_h221NonStandard(ASN1encoding_t enc, NonStandardIdentifier_h221NonStandard *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35CountryCode))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35Extension))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->manufacturerCode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardIdentifier_h221NonStandard(ASN1decoding_t dec, NonStandardIdentifier_h221NonStandard *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35CountryCode))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35Extension))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->manufacturerCode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NonStandardIdentifier(ASN1encoding_t enc, NonStandardIdentifier *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_NonStandardIdentifier_h221NonStandard(enc, &(val)->u.h221NonStandard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardIdentifier(ASN1decoding_t dec, NonStandardIdentifier *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_NonStandardIdentifier_h221NonStandard(dec, &(val)->u.h221NonStandard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardIdentifier(NonStandardIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1objectidentifier_free(&(val)->u.object);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MasterSlaveDetermination(ASN1encoding_t enc, MasterSlaveDetermination *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->terminalType))
	return 0;
    l = ASN1uint32_uoctets((val)->statusDeterminationNumber);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->statusDeterminationNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDetermination(ASN1decoding_t dec, MasterSlaveDetermination *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->terminalType))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->statusDeterminationNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationAck(ASN1encoding_t enc, MasterSlaveDeterminationAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MasterSlaveDeterminationAck_decision(enc, &(val)->decision))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationAck(ASN1decoding_t dec, MasterSlaveDeterminationAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MasterSlaveDeterminationAck_decision(dec, &(val)->decision))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationReject(ASN1encoding_t enc, MasterSlaveDeterminationReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MasterSlaveDeterminationReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationReject(ASN1decoding_t dec, MasterSlaveDeterminationReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MasterSlaveDeterminationReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationRelease(ASN1encoding_t enc, MasterSlaveDeterminationRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationRelease(ASN1decoding_t dec, MasterSlaveDeterminationRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CapabilityDescriptor(ASN1encoding_t enc, CapabilityDescriptor *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->capabilityDescriptorNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CapabilityDescriptor_simultaneousCapabilities(enc, &(val)->simultaneousCapabilities))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CapabilityDescriptor(ASN1decoding_t dec, CapabilityDescriptor *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->capabilityDescriptorNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CapabilityDescriptor_simultaneousCapabilities(dec, &(val)->simultaneousCapabilities))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CapabilityDescriptor(CapabilityDescriptor *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CapabilityDescriptor_simultaneousCapabilities(&(val)->simultaneousCapabilities);
	}
    }
}

static int ASN1CALL ASN1Enc_AlternativeCapabilitySet(ASN1encoding_t enc, AlternativeCapabilitySet *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncUnsignedShort(enc, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AlternativeCapabilitySet(ASN1decoding_t dec, AlternativeCapabilitySet *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecUnsignedShort(dec, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AlternativeCapabilitySet(AlternativeCapabilitySet *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetAck(ASN1encoding_t enc, TerminalCapabilitySetAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetAck(ASN1decoding_t dec, TerminalCapabilitySetAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject(ASN1encoding_t enc, TerminalCapabilitySetReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_TerminalCapabilitySetReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject(ASN1decoding_t dec, TerminalCapabilitySetReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_TerminalCapabilitySetReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetRelease(ASN1encoding_t enc, TerminalCapabilitySetRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetRelease(ASN1decoding_t dec, TerminalCapabilitySetRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H222Capability(ASN1encoding_t enc, H222Capability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->numberOfVCs - 1))
	return 0;
    if (!ASN1Enc_H222Capability_vcCapability(enc, &(val)->vcCapability))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H222Capability(ASN1decoding_t dec, H222Capability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->numberOfVCs))
	return 0;
    (val)->numberOfVCs += 1;
    if (!ASN1Dec_H222Capability_vcCapability(dec, &(val)->vcCapability))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H222Capability(H222Capability *val)
{
    if (val) {
	ASN1Free_H222Capability_vcCapability(&(val)->vcCapability);
    }
}

static int ASN1CALL ASN1Enc_VCCapability(ASN1encoding_t enc, VCCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_VCCapability_aal1(enc, &(val)->aal1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_VCCapability_aal5(enc, &(val)->aal5))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->transportStream))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->programStream))
	return 0;
    if (!ASN1Enc_VCCapability_availableBitRates(enc, &(val)->availableBitRates))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability(ASN1decoding_t dec, VCCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_VCCapability_aal1(dec, &(val)->aal1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_VCCapability_aal5(dec, &(val)->aal5))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->transportStream))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->programStream))
	return 0;
    if (!ASN1Dec_VCCapability_availableBitRates(dec, &(val)->availableBitRates))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AnnexCCapability(ASN1encoding_t enc, H223AnnexCCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL1M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL2M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL3M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL1M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL2M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL3M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL1M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL2M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL3M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alpduInterleaving))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAL1MPDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAL2MSDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAL3MSDUSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexCCapability(ASN1decoding_t dec, H223AnnexCCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL1M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL2M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL3M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL1M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL2M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL3M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL1M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL2M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL3M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alpduInterleaving))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAL1MPDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAL2MSDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAL3MSDUSize))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V75Capability(ASN1encoding_t enc, V75Capability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioHeader))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V75Capability(ASN1decoding_t dec, V75Capability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioHeader))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_QOSMode(ASN1encoding_t enc, QOSMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_QOSMode(ASN1decoding_t dec, QOSMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ATMParameters(ASN1encoding_t enc, ATMParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maxNTUSize))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atmUBR))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atmrtVBR))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atmnrtVBR))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atmABR))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atmCBR))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ATMParameters(ASN1decoding_t dec, ATMParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maxNTUSize))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atmUBR))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atmrtVBR))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atmnrtVBR))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atmABR))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atmCBR))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MediaTransportType(ASN1encoding_t enc, MediaTransportType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MediaTransportType(ASN1decoding_t dec, MediaTransportType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MediaChannelCapability(ASN1encoding_t enc, MediaChannelCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MediaTransportType(enc, &(val)->mediaTransport))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaChannelCapability(ASN1decoding_t dec, MediaChannelCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_MediaTransportType(dec, &(val)->mediaTransport))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->numberOfThreads - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->framesBetweenSyncPoints - 1))
	return 0;
    if (!ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping(enc, &(val)->frameToThreadMapping))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_RTPH263VideoRedundancyEncoding_containedThreads(enc, &(val)->containedThreads))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->numberOfThreads))
	return 0;
    (val)->numberOfThreads += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->framesBetweenSyncPoints))
	return 0;
    (val)->framesBetweenSyncPoints += 1;
    if (!ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping(dec, &(val)->frameToThreadMapping))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_RTPH263VideoRedundancyEncoding_containedThreads(dec, &(val)->containedThreads))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding(RTPH263VideoRedundancyEncoding *val)
{
    if (val) {
	ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping(&(val)->frameToThreadMapping);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_RTPH263VideoRedundancyEncoding_containedThreads(&(val)->containedThreads);
	}
    }
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyFrameMapping(ASN1encoding_t enc, RTPH263VideoRedundancyFrameMapping *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->threadNumber))
	return 0;
    if (!ASN1Enc_RTPH263VideoRedundancyFrameMapping_frameSequence(enc, &(val)->frameSequence))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyFrameMapping(ASN1decoding_t dec, RTPH263VideoRedundancyFrameMapping *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->threadNumber))
	return 0;
    if (!ASN1Dec_RTPH263VideoRedundancyFrameMapping_frameSequence(dec, &(val)->frameSequence))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyFrameMapping(RTPH263VideoRedundancyFrameMapping *val)
{
    if (val) {
	ASN1Free_RTPH263VideoRedundancyFrameMapping_frameSequence(&(val)->frameSequence);
    }
}

static int ASN1CALL ASN1Enc_MultipointCapability(ASN1encoding_t enc, MultipointCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multicastCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multiUniCastConference))
	return 0;
    if (!ASN1Enc_MultipointCapability_mediaDistributionCapability(enc, &(val)->mediaDistributionCapability))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultipointCapability(ASN1decoding_t dec, MultipointCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multicastCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multiUniCastConference))
	return 0;
    if (!ASN1Dec_MultipointCapability_mediaDistributionCapability(dec, &(val)->mediaDistributionCapability))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultipointCapability(MultipointCapability *val)
{
    if (val) {
	ASN1Free_MultipointCapability_mediaDistributionCapability(&(val)->mediaDistributionCapability);
    }
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability(ASN1encoding_t enc, MediaDistributionCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->centralizedControl))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->distributedControl))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->centralizedAudio))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->distributedAudio))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->centralizedVideo))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->distributedVideo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MediaDistributionCapability_centralizedData(enc, &(val)->centralizedData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_MediaDistributionCapability_distributedData(enc, &(val)->distributedData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability(ASN1decoding_t dec, MediaDistributionCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->centralizedControl))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->distributedControl))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->centralizedAudio))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->distributedAudio))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->centralizedVideo))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->distributedVideo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_MediaDistributionCapability_centralizedData(dec, &(val)->centralizedData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_MediaDistributionCapability_distributedData(dec, &(val)->distributedData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MediaDistributionCapability(MediaDistributionCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MediaDistributionCapability_centralizedData(&(val)->centralizedData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_MediaDistributionCapability_distributedData(&(val)->distributedData);
	}
    }
}

static int ASN1CALL ASN1Enc_H261VideoCapability(ASN1encoding_t enc, H261VideoCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 2, (val)->qcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 2, (val)->cifMPI - 1))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->temporalSpatialTradeOffCapability))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maxBitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->stillImageTransmission))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H261VideoCapability(ASN1decoding_t dec, H261VideoCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 2, &(val)->qcifMPI))
	    return 0;
	(val)->qcifMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 2, &(val)->cifMPI))
	    return 0;
	(val)->cifMPI += 1;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->temporalSpatialTradeOffCapability))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maxBitRate))
	return 0;
    (val)->maxBitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->stillImageTransmission))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H262VideoCapability(ASN1encoding_t enc, H262VideoCapability *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_SPatML))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_MPatLL))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_MPatML))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_MPatH_14))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_MPatHL))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_SNRatLL))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_SNRatML))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_SpatialatH_14))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_HPatML))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_HPatH_14))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_HPatHL))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->videoBitRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->vbvBufferSize);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->framesPerSecond))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->luminanceSampleRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->luminanceSampleRate))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H262VideoCapability(ASN1decoding_t dec, H262VideoCapability *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_SPatML))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_MPatLL))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_MPatML))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_MPatH_14))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_MPatHL))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_SNRatLL))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_SNRatML))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_SpatialatH_14))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_HPatML))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_HPatH_14))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_HPatHL))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->framesPerSecond))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->luminanceSampleRate))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo(ASN1encoding_t enc, EnhancementLayerInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->baseBitRateConstrained))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_EnhancementLayerInfo_snrEnhancement(enc, &(val)->snrEnhancement))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_EnhancementLayerInfo_spatialEnhancement(enc, &(val)->spatialEnhancement))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_EnhancementLayerInfo_bPictureEnhancement(enc, &(val)->bPictureEnhancement))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo(ASN1decoding_t dec, EnhancementLayerInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->baseBitRateConstrained))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_EnhancementLayerInfo_snrEnhancement(dec, &(val)->snrEnhancement))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_EnhancementLayerInfo_spatialEnhancement(dec, &(val)->spatialEnhancement))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_EnhancementLayerInfo_bPictureEnhancement(dec, &(val)->bPictureEnhancement))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo(EnhancementLayerInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_EnhancementLayerInfo_snrEnhancement(&(val)->snrEnhancement);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_EnhancementLayerInfo_spatialEnhancement(&(val)->spatialEnhancement);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_EnhancementLayerInfo_bPictureEnhancement(&(val)->bPictureEnhancement);
	}
    }
}

static int ASN1CALL ASN1Enc_TransparencyParameters(ASN1encoding_t enc, TransparencyParameters *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->presentationOrder - 1))
	return 0;
    l = ASN1uint32_uoctets((val)->offset_x + 262144);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->offset_x + 262144))
	return 0;
    l = ASN1uint32_uoctets((val)->offset_y + 262144);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->offset_y + 262144))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->scale_x - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->scale_y - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransparencyParameters(ASN1decoding_t dec, TransparencyParameters *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->presentationOrder))
	return 0;
    (val)->presentationOrder += 1;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->offset_x))
	return 0;
    (val)->offset_x += 0 - 262144;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->offset_y))
	return 0;
    (val)->offset_y += 0 - 262144;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->scale_x))
	return 0;
    (val)->scale_x += 1;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->scale_y))
	return 0;
    (val)->scale_y += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RefPictureSelection(ASN1encoding_t enc, RefPictureSelection *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_RefPictureSelection_additionalPictureMemory(enc, &(val)->additionalPictureMemory))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->videoMux))
	return 0;
    if (!ASN1Enc_RefPictureSelection_videoBackChannelSend(enc, &(val)->videoBackChannelSend))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RefPictureSelection(ASN1decoding_t dec, RefPictureSelection *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_RefPictureSelection_additionalPictureMemory(dec, &(val)->additionalPictureMemory))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->videoMux))
	return 0;
    if (!ASN1Dec_RefPictureSelection_videoBackChannelSend(dec, &(val)->videoBackChannelSend))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureClockFrequency(ASN1encoding_t enc, CustomPictureClockFrequency *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->clockConversionCode - 1000))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->clockDivisor - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->sqcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->qcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->cifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->cif4MPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->cif16MPI - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureClockFrequency(ASN1decoding_t dec, CustomPictureClockFrequency *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if (!ASN1PERDecU16Val(dec, 1, &(val)->clockConversionCode))
	return 0;
    (val)->clockConversionCode += 1000;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->clockDivisor))
	return 0;
    (val)->clockDivisor += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->sqcifMPI))
	    return 0;
	(val)->sqcifMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->qcifMPI))
	    return 0;
	(val)->qcifMPI += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->cifMPI))
	    return 0;
	(val)->cifMPI += 1;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->cif4MPI))
	    return 0;
	(val)->cif4MPI += 1;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->cif16MPI))
	    return 0;
	(val)->cif16MPI += 1;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureFormat(ASN1encoding_t enc, CustomPictureFormat *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maxCustomPictureWidth - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maxCustomPictureHeight - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->minCustomPictureWidth - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->minCustomPictureHeight - 1))
	return 0;
    if (!ASN1Enc_CustomPictureFormat_mPI(enc, &(val)->mPI))
	return 0;
    if (!ASN1Enc_CustomPictureFormat_pixelAspectInformation(enc, &(val)->pixelAspectInformation))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat(ASN1decoding_t dec, CustomPictureFormat *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maxCustomPictureWidth))
	return 0;
    (val)->maxCustomPictureWidth += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maxCustomPictureHeight))
	return 0;
    (val)->maxCustomPictureHeight += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->minCustomPictureWidth))
	return 0;
    (val)->minCustomPictureWidth += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->minCustomPictureHeight))
	return 0;
    (val)->minCustomPictureHeight += 1;
    if (!ASN1Dec_CustomPictureFormat_mPI(dec, &(val)->mPI))
	return 0;
    if (!ASN1Dec_CustomPictureFormat_pixelAspectInformation(dec, &(val)->pixelAspectInformation))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat(CustomPictureFormat *val)
{
    if (val) {
	ASN1Free_CustomPictureFormat_mPI(&(val)->mPI);
	ASN1Free_CustomPictureFormat_pixelAspectInformation(&(val)->pixelAspectInformation);
    }
}

static int ASN1CALL ASN1Enc_H263ModeComboFlags(ASN1encoding_t enc, H263ModeComboFlags *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unrestrictedVector))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->arithmeticCoding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedPrediction))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->pbFrames))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedIntraCodingMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->deblockingFilterMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unlimitedMotionVectors))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesInOrder_NonRect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesInOrder_Rect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesNoOrder_NonRect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesNoOrder_Rect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->improvedPBFramesMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->referencePicSelect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicPictureResizingByFour))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicPictureResizingSixteenthPel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicWarpingHalfPel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicWarpingSixteenthPel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->reducedResolutionUpdate))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->independentSegmentDecoding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alternateInterVLCMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->modifiedQuantizationMode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263ModeComboFlags(ASN1decoding_t dec, H263ModeComboFlags *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->unrestrictedVector))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->arithmeticCoding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedPrediction))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->pbFrames))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedIntraCodingMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->deblockingFilterMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->unlimitedMotionVectors))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesInOrder_NonRect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesInOrder_Rect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesNoOrder_NonRect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesNoOrder_Rect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->improvedPBFramesMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->referencePicSelect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicPictureResizingByFour))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicPictureResizingSixteenthPel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicWarpingHalfPel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicWarpingSixteenthPel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->reducedResolutionUpdate))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->independentSegmentDecoding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alternateInterVLCMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->modifiedQuantizationMode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172VideoCapability(ASN1encoding_t enc, IS11172VideoCapability *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->constrainedBitstream))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->videoBitRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->vbvBufferSize);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->pictureRate))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->luminanceSampleRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->luminanceSampleRate))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172VideoCapability(ASN1decoding_t dec, IS11172VideoCapability *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->constrainedBitstream))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->pictureRate))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->luminanceSampleRate))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_G7231AnnexCCapability(ASN1encoding_t enc, G7231AnnexCCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->maxAl_sduAudioFrames - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->silenceSuppression))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_G7231AnnexCCapability_g723AnnexCAudioMode(enc, &(val)->g723AnnexCAudioMode))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_G7231AnnexCCapability(ASN1decoding_t dec, G7231AnnexCCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maxAl_sduAudioFrames))
	return 0;
    (val)->maxAl_sduAudioFrames += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->silenceSuppression))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_G7231AnnexCCapability_g723AnnexCAudioMode(dec, &(val)->g723AnnexCAudioMode))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioCapability(ASN1encoding_t enc, IS11172AudioCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer3))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling32k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling44k1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling48k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->singleChannel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->twoChannels))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioCapability(ASN1decoding_t dec, IS11172AudioCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer3))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling32k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling44k1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling48k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->singleChannel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->twoChannels))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioCapability(ASN1encoding_t enc, IS13818AudioCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer3))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling16k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling22k05))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling24k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling32k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling44k1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling48k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->singleChannel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->twoChannels))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->threeChannels2_1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->threeChannels3_0))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fourChannels2_0_2_0))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fourChannels2_2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fourChannels3_1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fiveChannels3_0_2_0))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fiveChannels3_2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->lowFrequencyEnhancement))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multilingual))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioCapability(ASN1decoding_t dec, IS13818AudioCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer3))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling16k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling22k05))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling24k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling32k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling44k1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling48k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->singleChannel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->twoChannels))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->threeChannels2_1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->threeChannels3_0))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fourChannels2_0_2_0))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fourChannels2_2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fourChannels3_1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fiveChannels3_0_2_0))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fiveChannels3_2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->lowFrequencyEnhancement))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multilingual))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_GSMAudioCapability(ASN1encoding_t enc, GSMAudioCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->audioUnitSize - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->comfortNoise))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->scrambled))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GSMAudioCapability(ASN1decoding_t dec, GSMAudioCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->audioUnitSize))
	return 0;
    (val)->audioUnitSize += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->comfortNoise))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->scrambled))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V42bis(ASN1encoding_t enc, V42bis *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, (val)->numberOfCodewords - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->maximumStringLength - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V42bis(ASN1decoding_t dec, V42bis *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &(val)->numberOfCodewords))
	return 0;
    (val)->numberOfCodewords += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maximumStringLength))
	return 0;
    (val)->maximumStringLength += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_T84Profile(ASN1encoding_t enc, T84Profile *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_T84Profile_t84Restricted(enc, &(val)->u.t84Restricted))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_T84Profile(ASN1decoding_t dec, T84Profile *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_T84Profile_t84Restricted(dec, &(val)->u.t84Restricted))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceCapability(ASN1encoding_t enc, ConferenceCapability *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_ConferenceCapability_nonStandardData(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->chairControlCapability))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1PEREncBoolean(ee, (val)->videoIndicateMixingCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceCapability(ASN1decoding_t dec, ConferenceCapability *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ConferenceCapability_nonStandardData(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->chairControlCapability))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->videoIndicateMixingCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceCapability(ConferenceCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ConferenceCapability_nonStandardData(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_Q2931Address(ASN1encoding_t enc, Q2931Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_Q2931Address_address(enc, &(val)->address))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->subaddress, 1, 20, 5))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Q2931Address(ASN1decoding_t dec, Q2931Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_Q2931Address_address(dec, &(val)->address))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->subaddress, 1, 20, 5))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Q2931Address(Q2931Address *val)
{
    if (val) {
	ASN1Free_Q2931Address_address(&(val)->address);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_V75Parameters(ASN1encoding_t enc, V75Parameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioHeaderPresent))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V75Parameters(ASN1decoding_t dec, V75Parameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioHeaderPresent))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H222LogicalChannelParameters(ASN1encoding_t enc, H222LogicalChannelParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->resourceID))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->subChannelID))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->pcr_pid))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->programDescriptors))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->streamDescriptors))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H222LogicalChannelParameters(ASN1decoding_t dec, H222LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->resourceID))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->subChannelID))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->pcr_pid))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->programDescriptors))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->streamDescriptors))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H222LogicalChannelParameters(H222LogicalChannelParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1octetstring_free(&(val)->programDescriptors);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1octetstring_free(&(val)->streamDescriptors);
	}
    }
}

static int ASN1CALL ASN1Enc_H223AL2MParameters(ASN1encoding_t enc, H223AL2MParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223AL2MParameters_headerFEC(enc, &(val)->headerFEC))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alpduInterleaving))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL2MParameters(ASN1decoding_t dec, H223AL2MParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223AL2MParameters_headerFEC(dec, &(val)->headerFEC))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alpduInterleaving))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AnnexCArqParameters(ASN1encoding_t enc, H223AnnexCArqParameters *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223AnnexCArqParameters_numberOfRetransmissions(enc, &(val)->numberOfRetransmissions))
	return 0;
    l = ASN1uint32_uoctets((val)->sendBufferSize);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexCArqParameters(ASN1decoding_t dec, H223AnnexCArqParameters *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223AnnexCArqParameters_numberOfRetransmissions(dec, &(val)->numberOfRetransmissions))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sendBufferSize))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CRCLength(ASN1encoding_t enc, CRCLength *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CRCLength(ASN1decoding_t dec, CRCLength *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_EscrowData(ASN1encoding_t enc, EscrowData *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->escrowID))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, ((val)->escrowValue).length - 1))
	return 0;
    if (!ASN1PEREncBits(enc, ((val)->escrowValue).length, ((val)->escrowValue).value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EscrowData(ASN1decoding_t dec, EscrowData *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->escrowID))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &((val)->escrowValue).length))
	return 0;
    ((val)->escrowValue).length += 1;
    if (!ASN1PERDecBits(dec, ((val)->escrowValue).length, &((val)->escrowValue).value))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EscrowData(EscrowData *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->escrowID);
	ASN1bitstring_free(&(val)->escrowValue);
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelReject(ASN1encoding_t enc, OpenLogicalChannelReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_OpenLogicalChannelReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelReject(ASN1decoding_t dec, OpenLogicalChannelReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!ASN1Dec_OpenLogicalChannelReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelConfirm(ASN1encoding_t enc, OpenLogicalChannelConfirm *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelConfirm(ASN1decoding_t dec, OpenLogicalChannelConfirm *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CloseLogicalChannel(ASN1encoding_t enc, CloseLogicalChannel *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_CloseLogicalChannel_source(enc, &(val)->source))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1Enc_CloseLogicalChannel_reason(ee, &(val)->reason))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CloseLogicalChannel(ASN1decoding_t dec, CloseLogicalChannel *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!ASN1Dec_CloseLogicalChannel_source(dec, &(val)->source))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CloseLogicalChannel_reason(dd, &(val)->reason))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CloseLogicalChannelAck(ASN1encoding_t enc, CloseLogicalChannelAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CloseLogicalChannelAck(ASN1decoding_t dec, CloseLogicalChannelAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestChannelCloseAck(ASN1encoding_t enc, RequestChannelCloseAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelCloseAck(ASN1decoding_t dec, RequestChannelCloseAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestChannelCloseReject(ASN1encoding_t enc, RequestChannelCloseReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_RequestChannelCloseReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelCloseReject(ASN1decoding_t dec, RequestChannelCloseReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!ASN1Dec_RequestChannelCloseReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestChannelCloseRelease(ASN1encoding_t enc, RequestChannelCloseRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelCloseRelease(ASN1decoding_t dec, RequestChannelCloseRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexEntrySend(ASN1encoding_t enc, MultiplexEntrySend *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors(enc, &(val)->multiplexEntryDescriptors))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySend(ASN1decoding_t dec, MultiplexEntrySend *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors(dec, &(val)->multiplexEntryDescriptors))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySend(MultiplexEntrySend *val)
{
    if (val) {
	ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors(&(val)->multiplexEntryDescriptors);
    }
}

static int ASN1CALL ASN1Enc_MultiplexElement(ASN1encoding_t enc, MultiplexElement *val)
{
    if (!ASN1Enc_MultiplexElement_type(enc, &(val)->type))
	return 0;
    if (!ASN1Enc_MultiplexElement_repeatCount(enc, &(val)->repeatCount))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexElement(ASN1decoding_t dec, MultiplexElement *val)
{
    if (!ASN1Dec_MultiplexElement_type(dec, &(val)->type))
	return 0;
    if (!ASN1Dec_MultiplexElement_repeatCount(dec, &(val)->repeatCount))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexElement(MultiplexElement *val)
{
    if (val) {
	ASN1Free_MultiplexElement_type(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendAck(ASN1encoding_t enc, MultiplexEntrySendAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_MultiplexEntrySendAck_multiplexTableEntryNumber(enc, &(val)->multiplexTableEntryNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendAck(ASN1decoding_t dec, MultiplexEntrySendAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_MultiplexEntrySendAck_multiplexTableEntryNumber(dec, &(val)->multiplexTableEntryNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendAck(MultiplexEntrySendAck *val)
{
    if (val) {
	ASN1Free_MultiplexEntrySendAck_multiplexTableEntryNumber(&(val)->multiplexTableEntryNumber);
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntryRejectionDescriptions(ASN1encoding_t enc, MultiplexEntryRejectionDescriptions *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->multiplexTableEntryNumber - 1))
	return 0;
    if (!ASN1Enc_MultiplexEntryRejectionDescriptions_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntryRejectionDescriptions(ASN1decoding_t dec, MultiplexEntryRejectionDescriptions *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->multiplexTableEntryNumber))
	return 0;
    (val)->multiplexTableEntryNumber += 1;
    if (!ASN1Dec_MultiplexEntryRejectionDescriptions_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendRelease(ASN1encoding_t enc, MultiplexEntrySendRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MultiplexEntrySendRelease_multiplexTableEntryNumber(enc, &(val)->multiplexTableEntryNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendRelease(ASN1decoding_t dec, MultiplexEntrySendRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MultiplexEntrySendRelease_multiplexTableEntryNumber(dec, &(val)->multiplexTableEntryNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendRelease(MultiplexEntrySendRelease *val)
{
    if (val) {
	ASN1Free_MultiplexEntrySendRelease_multiplexTableEntryNumber(&(val)->multiplexTableEntryNumber);
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntry(ASN1encoding_t enc, RequestMultiplexEntry *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntry_entryNumbers(enc, &(val)->entryNumbers))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntry(ASN1decoding_t dec, RequestMultiplexEntry *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_RequestMultiplexEntry_entryNumbers(dec, &(val)->entryNumbers))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntry(RequestMultiplexEntry *val)
{
    if (val) {
	ASN1Free_RequestMultiplexEntry_entryNumbers(&(val)->entryNumbers);
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryAck(ASN1encoding_t enc, RequestMultiplexEntryAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntryAck_entryNumbers(enc, &(val)->entryNumbers))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryAck(ASN1decoding_t dec, RequestMultiplexEntryAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_RequestMultiplexEntryAck_entryNumbers(dec, &(val)->entryNumbers))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryAck(RequestMultiplexEntryAck *val)
{
    if (val) {
	ASN1Free_RequestMultiplexEntryAck_entryNumbers(&(val)->entryNumbers);
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryRejectionDescriptions(ASN1encoding_t enc, RequestMultiplexEntryRejectionDescriptions *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->multiplexTableEntryNumber - 1))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntryRejectionDescriptions_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryRejectionDescriptions(ASN1decoding_t dec, RequestMultiplexEntryRejectionDescriptions *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->multiplexTableEntryNumber))
	return 0;
    (val)->multiplexTableEntryNumber += 1;
    if (!ASN1Dec_RequestMultiplexEntryRejectionDescriptions_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryRelease(ASN1encoding_t enc, RequestMultiplexEntryRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntryRelease_entryNumbers(enc, &(val)->entryNumbers))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryRelease(ASN1decoding_t dec, RequestMultiplexEntryRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_RequestMultiplexEntryRelease_entryNumbers(dec, &(val)->entryNumbers))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryRelease(RequestMultiplexEntryRelease *val)
{
    if (val) {
	ASN1Free_RequestMultiplexEntryRelease_entryNumbers(&(val)->entryNumbers);
    }
}

static int ASN1CALL ASN1Enc_RequestMode(ASN1encoding_t enc, RequestMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_RequestMode_requestedModes(enc, &(val)->requestedModes))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMode(ASN1decoding_t dec, RequestMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_RequestMode_requestedModes(dec, &(val)->requestedModes))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMode(RequestMode *val)
{
    if (val) {
	ASN1Free_RequestMode_requestedModes(&(val)->requestedModes);
    }
}

static int ASN1CALL ASN1Enc_RequestModeAck(ASN1encoding_t enc, RequestModeAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_RequestModeAck_response(enc, &(val)->response))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeAck(ASN1decoding_t dec, RequestModeAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_RequestModeAck_response(dec, &(val)->response))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestModeReject(ASN1encoding_t enc, RequestModeReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_RequestModeReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeReject(ASN1decoding_t dec, RequestModeReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_RequestModeReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestModeRelease(ASN1encoding_t enc, RequestModeRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeRelease(ASN1decoding_t dec, RequestModeRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V76ModeParameters(ASN1encoding_t enc, V76ModeParameters *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76ModeParameters(ASN1decoding_t dec, V76ModeParameters *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H261VideoMode(ASN1encoding_t enc, H261VideoMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H261VideoMode_resolution(enc, &(val)->resolution))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->stillImageTransmission))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H261VideoMode(ASN1decoding_t dec, H261VideoMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H261VideoMode_resolution(dec, &(val)->resolution))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->stillImageTransmission))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H262VideoMode(ASN1encoding_t enc, H262VideoMode *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1Enc_H262VideoMode_profileAndLevel(enc, &(val)->profileAndLevel))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->videoBitRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->vbvBufferSize);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->framesPerSecond))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->luminanceSampleRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->luminanceSampleRate))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H262VideoMode(ASN1decoding_t dec, H262VideoMode *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1Dec_H262VideoMode_profileAndLevel(dec, &(val)->profileAndLevel))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->framesPerSecond))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->luminanceSampleRate))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172VideoMode(ASN1encoding_t enc, IS11172VideoMode *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->constrainedBitstream))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->videoBitRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->vbvBufferSize);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->pictureRate))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->luminanceSampleRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->luminanceSampleRate))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172VideoMode(ASN1decoding_t dec, IS11172VideoMode *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->constrainedBitstream))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->pictureRate))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->luminanceSampleRate))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioMode(ASN1encoding_t enc, IS11172AudioMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_IS11172AudioMode_audioLayer(enc, &(val)->audioLayer))
	return 0;
    if (!ASN1Enc_IS11172AudioMode_audioSampling(enc, &(val)->audioSampling))
	return 0;
    if (!ASN1Enc_IS11172AudioMode_multichannelType(enc, &(val)->multichannelType))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioMode(ASN1decoding_t dec, IS11172AudioMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_IS11172AudioMode_audioLayer(dec, &(val)->audioLayer))
	return 0;
    if (!ASN1Dec_IS11172AudioMode_audioSampling(dec, &(val)->audioSampling))
	return 0;
    if (!ASN1Dec_IS11172AudioMode_multichannelType(dec, &(val)->multichannelType))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioMode(ASN1encoding_t enc, IS13818AudioMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_IS13818AudioMode_audioLayer(enc, &(val)->audioLayer))
	return 0;
    if (!ASN1Enc_IS13818AudioMode_audioSampling(enc, &(val)->audioSampling))
	return 0;
    if (!ASN1Enc_IS13818AudioMode_multichannelType(enc, &(val)->multichannelType))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->lowFrequencyEnhancement))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multilingual))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioMode(ASN1decoding_t dec, IS13818AudioMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_IS13818AudioMode_audioLayer(dec, &(val)->audioLayer))
	return 0;
    if (!ASN1Dec_IS13818AudioMode_audioSampling(dec, &(val)->audioSampling))
	return 0;
    if (!ASN1Dec_IS13818AudioMode_multichannelType(dec, &(val)->multichannelType))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->lowFrequencyEnhancement))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multilingual))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_G7231AnnexCMode(ASN1encoding_t enc, G7231AnnexCMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->maxAl_sduAudioFrames - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->silenceSuppression))
	return 0;
    if (!ASN1Enc_G7231AnnexCMode_g723AnnexCAudioMode(enc, &(val)->g723AnnexCAudioMode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_G7231AnnexCMode(ASN1decoding_t dec, G7231AnnexCMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maxAl_sduAudioFrames))
	return 0;
    (val)->maxAl_sduAudioFrames += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->silenceSuppression))
	return 0;
    if (!ASN1Dec_G7231AnnexCMode_g723AnnexCAudioMode(dec, &(val)->g723AnnexCAudioMode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RoundTripDelayRequest(ASN1encoding_t enc, RoundTripDelayRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RoundTripDelayRequest(ASN1decoding_t dec, RoundTripDelayRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RoundTripDelayResponse(ASN1encoding_t enc, RoundTripDelayResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RoundTripDelayResponse(ASN1decoding_t dec, RoundTripDelayResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopRequest(ASN1encoding_t enc, MaintenanceLoopRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MaintenanceLoopRequest_type(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopRequest(ASN1decoding_t dec, MaintenanceLoopRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MaintenanceLoopRequest_type(dec, &(val)->type))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopAck(ASN1encoding_t enc, MaintenanceLoopAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MaintenanceLoopAck_type(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopAck(ASN1decoding_t dec, MaintenanceLoopAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MaintenanceLoopAck_type(dec, &(val)->type))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopReject(ASN1encoding_t enc, MaintenanceLoopReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MaintenanceLoopReject_type(enc, &(val)->type))
	return 0;
    if (!ASN1Enc_MaintenanceLoopReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopReject(ASN1decoding_t dec, MaintenanceLoopReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MaintenanceLoopReject_type(dec, &(val)->type))
	return 0;
    if (!ASN1Dec_MaintenanceLoopReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopOffCommand(ASN1encoding_t enc, MaintenanceLoopOffCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopOffCommand(ASN1decoding_t dec, MaintenanceLoopOffCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CommunicationModeCommand(ASN1encoding_t enc, CommunicationModeCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_CommunicationModeCommand_communicationModeTable(enc, &(val)->communicationModeTable))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeCommand(ASN1decoding_t dec, CommunicationModeCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_CommunicationModeCommand_communicationModeTable(dec, &(val)->communicationModeTable))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeCommand(CommunicationModeCommand *val)
{
    if (val) {
	ASN1Free_CommunicationModeCommand_communicationModeTable(&(val)->communicationModeTable);
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeRequest(ASN1encoding_t enc, CommunicationModeRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeRequest(ASN1decoding_t dec, CommunicationModeRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CommunicationModeResponse(ASN1encoding_t enc, CommunicationModeResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_CommunicationModeResponse_communicationModeTable(enc, &(val)->u.communicationModeTable))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeResponse(ASN1decoding_t dec, CommunicationModeResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_CommunicationModeResponse_communicationModeTable(dec, &(val)->u.communicationModeTable))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeResponse(CommunicationModeResponse *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_CommunicationModeResponse_communicationModeTable(&(val)->u.communicationModeTable);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_Criteria(ASN1encoding_t enc, Criteria *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->field))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->value, 1, 65535, 16))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Criteria(ASN1decoding_t dec, Criteria *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->field))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->value, 1, 65535, 16))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Criteria(Criteria *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->field);
    }
}

static int ASN1CALL ASN1Enc_TerminalLabel(ASN1encoding_t enc, TerminalLabel *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->mcuNumber))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->terminalNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalLabel(ASN1decoding_t dec, TerminalLabel *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->mcuNumber))
	return 0;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->terminalNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse(ASN1encoding_t enc, RequestAllTerminalIDsResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation(enc, &(val)->terminalInformation))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse(ASN1decoding_t dec, RequestAllTerminalIDsResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation(dec, &(val)->terminalInformation))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse(RequestAllTerminalIDsResponse *val)
{
    if (val) {
	ASN1Free_RequestAllTerminalIDsResponse_terminalInformation(&(val)->terminalInformation);
    }
}

static int ASN1CALL ASN1Enc_TerminalInformation(ASN1encoding_t enc, TerminalInformation *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalInformation(ASN1decoding_t dec, TerminalInformation *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TerminalInformation(TerminalInformation *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RemoteMCRequest(ASN1encoding_t enc, RemoteMCRequest *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteMCRequest(ASN1decoding_t dec, RemoteMCRequest *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RemoteMCResponse(ASN1encoding_t enc, RemoteMCResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_RemoteMCResponse_reject(enc, &(val)->u.reject))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteMCResponse(ASN1decoding_t dec, RemoteMCResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_RemoteMCResponse_reject(dec, &(val)->u.reject))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet(ASN1encoding_t enc, SendTerminalCapabilitySet *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_SendTerminalCapabilitySet_specificRequest(enc, &(val)->u.specificRequest))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet(ASN1decoding_t dec, SendTerminalCapabilitySet *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_SendTerminalCapabilitySet_specificRequest(dec, &(val)->u.specificRequest))
	    return 0;
	break;
    case 2:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet(SendTerminalCapabilitySet *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_SendTerminalCapabilitySet_specificRequest(&(val)->u.specificRequest);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_FlowControlCommand(ASN1encoding_t enc, FlowControlCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_FlowControlCommand_scope(enc, &(val)->scope))
	return 0;
    if (!ASN1Enc_FlowControlCommand_restriction(enc, &(val)->restriction))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FlowControlCommand(ASN1decoding_t dec, FlowControlCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_FlowControlCommand_scope(dec, &(val)->scope))
	return 0;
    if (!ASN1Dec_FlowControlCommand_restriction(dec, &(val)->restriction))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_SubstituteConferenceIDCommand(ASN1encoding_t enc, SubstituteConferenceIDCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceIdentifier, 16))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SubstituteConferenceIDCommand(ASN1decoding_t dec, SubstituteConferenceIDCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceIdentifier, 16))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SubstituteConferenceIDCommand(SubstituteConferenceIDCommand *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_KeyProtectionMethod(ASN1encoding_t enc, KeyProtectionMethod *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->secureChannel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->sharedSecret))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->certProtectedKey))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyProtectionMethod(ASN1decoding_t dec, KeyProtectionMethod *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->secureChannel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->sharedSecret))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->certProtectedKey))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_EncryptionUpdateRequest(ASN1encoding_t enc, EncryptionUpdateRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KeyProtectionMethod(enc, &(val)->keyProtectionMethod))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionUpdateRequest(ASN1decoding_t dec, EncryptionUpdateRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_KeyProtectionMethod(dec, &(val)->keyProtectionMethod))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration(ASN1encoding_t enc, H223MultiplexReconfiguration *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H223MultiplexReconfiguration_h223ModeChange(enc, &(val)->u.h223ModeChange))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H223MultiplexReconfiguration_h223AnnexADoubleFlag(enc, &(val)->u.h223AnnexADoubleFlag))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration(ASN1decoding_t dec, H223MultiplexReconfiguration *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H223MultiplexReconfiguration_h223ModeChange(dec, &(val)->u.h223ModeChange))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H223MultiplexReconfiguration_h223AnnexADoubleFlag(dec, &(val)->u.h223AnnexADoubleFlag))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_FunctionNotSupported(ASN1encoding_t enc, FunctionNotSupported *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_FunctionNotSupported_cause(enc, &(val)->cause))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->returnedFunction))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FunctionNotSupported(ASN1decoding_t dec, FunctionNotSupported *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_FunctionNotSupported_cause(dec, &(val)->cause))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->returnedFunction))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_FunctionNotSupported(FunctionNotSupported *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->returnedFunction);
	}
    }
}

static int ASN1CALL ASN1Enc_TerminalYouAreSeeingInSubPictureNumber(ASN1encoding_t enc, TerminalYouAreSeeingInSubPictureNumber *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->terminalNumber))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->subPictureNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalYouAreSeeingInSubPictureNumber(ASN1decoding_t dec, TerminalYouAreSeeingInSubPictureNumber *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->terminalNumber))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->subPictureNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VideoIndicateCompose(ASN1encoding_t enc, VideoIndicateCompose *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->compositionNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VideoIndicateCompose(ASN1decoding_t dec, VideoIndicateCompose *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->compositionNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceIndication(ASN1encoding_t enc, ConferenceIndication *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncBitVal(enc, 4, (val)->u.sbeNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.terminalNumberAssign))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.terminalJoinedConference))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.terminalLeftConference))
	    return 0;
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.terminalYouAreSeeing))
	    return 0;
	break;
    case 10:
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TerminalLabel(ee, &(val)->u.floorRequested))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 13:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TerminalYouAreSeeingInSubPictureNumber(ee, &(val)->u.terminalYouAreSeeingInSubPictureNumber))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 14:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_VideoIndicateCompose(ee, &(val)->u.videoIndicateCompose))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceIndication(ASN1decoding_t dec, ConferenceIndication *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU16Val(dec, 4, &(val)->u.sbeNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.terminalNumberAssign))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.terminalJoinedConference))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.terminalLeftConference))
	    return 0;
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.terminalYouAreSeeing))
	    return 0;
	break;
    case 10:
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_TerminalLabel(dd, &(val)->u.floorRequested))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 13:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_TerminalYouAreSeeingInSubPictureNumber(dd, &(val)->u.terminalYouAreSeeingInSubPictureNumber))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 14:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_VideoIndicateCompose(dd, &(val)->u.videoIndicateCompose))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_JitterIndication(ASN1encoding_t enc, JitterIndication *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_JitterIndication_scope(enc, &(val)->scope))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->estimatedReceivedJitterMantissa))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->estimatedReceivedJitterExponent))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->skippedFrameCount))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->additionalDecoderBuffer);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->additionalDecoderBuffer))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_JitterIndication(ASN1decoding_t dec, JitterIndication *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_JitterIndication_scope(dec, &(val)->scope))
	return 0;
    if (!ASN1PERDecU16Val(dec, 2, &(val)->estimatedReceivedJitterMantissa))
	return 0;
    if (!ASN1PERDecU16Val(dec, 3, &(val)->estimatedReceivedJitterExponent))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->skippedFrameCount))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->additionalDecoderBuffer))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223SkewIndication(ASN1encoding_t enc, H223SkewIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber1 - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber2 - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->skew))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223SkewIndication(ASN1decoding_t dec, H223SkewIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber1))
	return 0;
    (val)->logicalChannelNumber1 += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber2))
	return 0;
    (val)->logicalChannelNumber2 += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->skew))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H2250MaximumSkewIndication(ASN1encoding_t enc, H2250MaximumSkewIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber1 - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber2 - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumSkew))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250MaximumSkewIndication(ASN1decoding_t dec, H2250MaximumSkewIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber1))
	return 0;
    (val)->logicalChannelNumber1 += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber2))
	return 0;
    (val)->logicalChannelNumber2 += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumSkew))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VendorIdentification(ASN1encoding_t enc, VendorIdentification *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->vendor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->productNumber, 1, 256, 8))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->versionNumber, 1, 256, 8))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VendorIdentification(ASN1decoding_t dec, VendorIdentification *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->vendor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->productNumber, 1, 256, 8))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->versionNumber, 1, 256, 8))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VendorIdentification(VendorIdentification *val)
{
    if (val) {
	ASN1Free_NonStandardIdentifier(&(val)->vendor);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_NewATMVCIndication(ASN1encoding_t enc, NewATMVCIndication *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->resourceID))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->bitRateLockedToPCRClock))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->bitRateLockedToNetworkClock))
	return 0;
    if (!ASN1Enc_NewATMVCIndication_aal(enc, &(val)->aal))
	return 0;
    if (!ASN1Enc_NewATMVCIndication_multiplex(enc, &(val)->multiplex))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1Enc_NewATMVCIndication_reverseParameters(ee, &(val)->reverseParameters))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication(ASN1decoding_t dec, NewATMVCIndication *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->resourceID))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->bitRateLockedToPCRClock))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->bitRateLockedToNetworkClock))
	return 0;
    if (!ASN1Dec_NewATMVCIndication_aal(dec, &(val)->aal))
	return 0;
    if (!ASN1Dec_NewATMVCIndication_multiplex(dec, &(val)->multiplex))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_NewATMVCIndication_reverseParameters(dd, &(val)->reverseParameters))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(ASN1encoding_t enc, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(ASN1encoding_t enc, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val)
{
    if (!ASN1Enc_RTPH263VideoRedundancyFrameMapping(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(ASN1decoding_t dec, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(ASN1decoding_t dec, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val)
{
    if (!ASN1Dec_RTPH263VideoRedundancyFrameMapping(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val)
{
    if (val) {
	ASN1Free_RTPH263VideoRedundancyFrameMapping(&val->value);
    }
}

static int ASN1CALL ASN1Enc_MultiplexElement_type_subElementList(ASN1encoding_t enc, PMultiplexElement_type_subElementList *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 8, (*val)->count - 2))
	return 0;
    for (i = 0; i < (*val)->count; i++) {
	if (!ASN1Enc_MultiplexElement(enc, &((*val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexElement_type_subElementList(ASN1decoding_t dec, PMultiplexElement_type_subElementList *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 8, &(*val)->count))
	return 0;
    (*val)->count += 2;
    for (i = 0; i < (*val)->count; i++) {
	if (!ASN1Dec_MultiplexElement(dec, &((*val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexElement_type_subElementList(PMultiplexElement_type_subElementList *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (*val)->count; i++) {
	    ASN1Free_MultiplexElement(&(*val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation(ASN1encoding_t enc, PRequestAllTerminalIDsResponse_terminalInformation *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation_ElmFn);
}

static int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(ASN1encoding_t enc, PRequestAllTerminalIDsResponse_terminalInformation val)
{
    if (!ASN1Enc_TerminalInformation(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation(ASN1decoding_t dec, PRequestAllTerminalIDsResponse_terminalInformation *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(ASN1decoding_t dec, PRequestAllTerminalIDsResponse_terminalInformation val)
{
    if (!ASN1Dec_TerminalInformation(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse_terminalInformation(PRequestAllTerminalIDsResponse_terminalInformation *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RequestAllTerminalIDsResponse_terminalInformation_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(PRequestAllTerminalIDsResponse_terminalInformation val)
{
    if (val) {
	ASN1Free_TerminalInformation(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_terminalCertificateResponse(ASN1encoding_t enc, ConferenceResponse_terminalCertificateResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->certificateResponse, 1, 65535, 16))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_terminalCertificateResponse(ASN1decoding_t dec, ConferenceResponse_terminalCertificateResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->certificateResponse, 1, 65535, 16))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_terminalCertificateResponse(ConferenceResponse_terminalCertificateResponse *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_chairTokenOwnerResponse(ASN1encoding_t enc, ConferenceResponse_chairTokenOwnerResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_chairTokenOwnerResponse(ASN1decoding_t dec, ConferenceResponse_chairTokenOwnerResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_chairTokenOwnerResponse(ConferenceResponse_chairTokenOwnerResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_terminalListResponse(ASN1encoding_t enc, ConferenceResponse_terminalListResponse *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_TerminalLabel(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_terminalListResponse(ASN1decoding_t dec, ConferenceResponse_terminalListResponse *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_TerminalLabel(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_terminalListResponse(ConferenceResponse_terminalListResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_passwordResponse(ASN1encoding_t enc, ConferenceResponse_passwordResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->password, 1, 32, 5))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_passwordResponse(ASN1decoding_t dec, ConferenceResponse_passwordResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->password, 1, 32, 5))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_passwordResponse(ConferenceResponse_passwordResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_conferenceIDResponse(ASN1encoding_t enc, ConferenceResponse_conferenceIDResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 1, 32, 5))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_conferenceIDResponse(ASN1decoding_t dec, ConferenceResponse_conferenceIDResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 1, 32, 5))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_conferenceIDResponse(ConferenceResponse_conferenceIDResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_terminalIDResponse(ASN1encoding_t enc, ConferenceResponse_terminalIDResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_terminalIDResponse(ASN1decoding_t dec, ConferenceResponse_terminalIDResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_terminalIDResponse(ConferenceResponse_terminalIDResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_mCTerminalIDResponse(ASN1encoding_t enc, ConferenceResponse_mCTerminalIDResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_mCTerminalIDResponse(ASN1decoding_t dec, ConferenceResponse_mCTerminalIDResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_mCTerminalIDResponse(ConferenceResponse_mCTerminalIDResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceRequest_requestTerminalCertificate(ASN1encoding_t enc, ConferenceRequest_requestTerminalCertificate *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CertSelectionCriteria(enc, &(val)->certSelectionCriteria))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	l = ASN1uint32_uoctets((val)->sRandom - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->sRandom - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceRequest_requestTerminalCertificate(ASN1decoding_t dec, ConferenceRequest_requestTerminalCertificate *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_CertSelectionCriteria(dec, &(val)->certSelectionCriteria))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sRandom))
	    return 0;
	(val)->sRandom += 1;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceRequest_requestTerminalCertificate(ConferenceRequest_requestTerminalCertificate *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CertSelectionCriteria(&(val)->certSelectionCriteria);
	}
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject_rejectionDescriptions(ASN1encoding_t enc, RequestMultiplexEntryReject_rejectionDescriptions *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_RequestMultiplexEntryRejectionDescriptions(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject_rejectionDescriptions(ASN1decoding_t dec, RequestMultiplexEntryReject_rejectionDescriptions *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_RequestMultiplexEntryRejectionDescriptions(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryReject_rejectionDescriptions(RequestMultiplexEntryReject_rejectionDescriptions *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendReject_rejectionDescriptions(ASN1encoding_t enc, MultiplexEntrySendReject_rejectionDescriptions *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_MultiplexEntryRejectionDescriptions(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendReject_rejectionDescriptions(ASN1decoding_t dec, MultiplexEntrySendReject_rejectionDescriptions *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_MultiplexEntryRejectionDescriptions(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendReject_rejectionDescriptions(MultiplexEntrySendReject_rejectionDescriptions *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntryDescriptor_elementList(ASN1encoding_t enc, MultiplexEntryDescriptor_elementList *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_MultiplexElement(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntryDescriptor_elementList(ASN1decoding_t dec, MultiplexEntryDescriptor_elementList *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_MultiplexElement(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntryDescriptor_elementList(MultiplexEntryDescriptor_elementList *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_MultiplexElement(&(val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionSync_escrowentry(ASN1encoding_t enc, PEncryptionSync_escrowentry *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EncryptionSync_escrowentry_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_EncryptionSync_escrowentry_ElmFn(ASN1encoding_t enc, PEncryptionSync_escrowentry val)
{
    if (!ASN1Enc_EscrowData(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionSync_escrowentry(ASN1decoding_t dec, PEncryptionSync_escrowentry *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EncryptionSync_escrowentry_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_EncryptionSync_escrowentry_ElmFn(ASN1decoding_t dec, PEncryptionSync_escrowentry val)
{
    if (!ASN1Dec_EscrowData(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionSync_escrowentry(PEncryptionSync_escrowentry *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EncryptionSync_escrowentry_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EncryptionSync_escrowentry_ElmFn(PEncryptionSync_escrowentry val)
{
    if (val) {
	ASN1Free_EscrowData(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H223AL3MParameters_arqType(ASN1encoding_t enc, H223AL3MParameters_arqType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_H223AnnexCArqParameters(enc, &(val)->u.typeIArq))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H223AnnexCArqParameters(enc, &(val)->u.typeIIArq))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL3MParameters_arqType(ASN1decoding_t dec, H223AL3MParameters_arqType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_H223AnnexCArqParameters(dec, &(val)->u.typeIArq))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H223AnnexCArqParameters(dec, &(val)->u.typeIIArq))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL1MParameters_arqType(ASN1encoding_t enc, H223AL1MParameters_arqType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_H223AnnexCArqParameters(enc, &(val)->u.typeIArq))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H223AnnexCArqParameters(enc, &(val)->u.typeIIArq))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL1MParameters_arqType(ASN1decoding_t dec, H223AL1MParameters_arqType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_H223AnnexCArqParameters(dec, &(val)->u.typeIArq))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H223AnnexCArqParameters(dec, &(val)->u.typeIIArq))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H263VideoModeCombos_h263VideoCoupledModes(ASN1encoding_t enc, H263VideoModeCombos_h263VideoCoupledModes *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_H263ModeComboFlags(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoModeCombos_h263VideoCoupledModes(ASN1decoding_t dec, H263VideoModeCombos_h263VideoCoupledModes *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_H263ModeComboFlags(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H263VideoModeCombos_h263VideoCoupledModes(H263VideoModeCombos_h263VideoCoupledModes *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H263Options_customPictureFormat(ASN1encoding_t enc, PH263Options_customPictureFormat *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H263Options_customPictureFormat_ElmFn, 1, 16, 4);
}

static int ASN1CALL ASN1Enc_H263Options_customPictureFormat_ElmFn(ASN1encoding_t enc, PH263Options_customPictureFormat val)
{
    if (!ASN1Enc_CustomPictureFormat(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263Options_customPictureFormat(ASN1decoding_t dec, PH263Options_customPictureFormat *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H263Options_customPictureFormat_ElmFn, sizeof(**val), 1, 16, 4);
}

static int ASN1CALL ASN1Dec_H263Options_customPictureFormat_ElmFn(ASN1decoding_t dec, PH263Options_customPictureFormat val)
{
    if (!ASN1Dec_CustomPictureFormat(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H263Options_customPictureFormat(PH263Options_customPictureFormat *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H263Options_customPictureFormat_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H263Options_customPictureFormat_ElmFn(PH263Options_customPictureFormat val)
{
    if (val) {
	ASN1Free_CustomPictureFormat(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H263Options_customPictureClockFrequency(ASN1encoding_t enc, PH263Options_customPictureClockFrequency *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H263Options_customPictureClockFrequency_ElmFn, 1, 16, 4);
}

static int ASN1CALL ASN1Enc_H263Options_customPictureClockFrequency_ElmFn(ASN1encoding_t enc, PH263Options_customPictureClockFrequency val)
{
    if (!ASN1Enc_CustomPictureClockFrequency(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263Options_customPictureClockFrequency(ASN1decoding_t dec, PH263Options_customPictureClockFrequency *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H263Options_customPictureClockFrequency_ElmFn, sizeof(**val), 1, 16, 4);
}

static int ASN1CALL ASN1Dec_H263Options_customPictureClockFrequency_ElmFn(ASN1decoding_t dec, PH263Options_customPictureClockFrequency val)
{
    if (!ASN1Dec_CustomPictureClockFrequency(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H263Options_customPictureClockFrequency(PH263Options_customPictureClockFrequency *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H263Options_customPictureClockFrequency_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H263Options_customPictureClockFrequency_ElmFn(PH263Options_customPictureClockFrequency val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn);
}

static int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability val)
{
    if (!ASN1Enc_MediaDistributionCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability val)
{
    if (!ASN1Dec_MediaDistributionCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability(PMultipointCapability_mediaDistributionCapability *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn(PMultipointCapability_mediaDistributionCapability val)
{
    if (val) {
	ASN1Free_MediaDistributionCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TransportCapability_mediaChannelCapabilities(ASN1encoding_t enc, TransportCapability_mediaChannelCapabilities *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_MediaChannelCapability(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportCapability_mediaChannelCapabilities(ASN1decoding_t dec, TransportCapability_mediaChannelCapabilities *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_MediaChannelCapability(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportCapability_mediaChannelCapabilities(TransportCapability_mediaChannelCapabilities *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H222Capability_vcCapability(ASN1encoding_t enc, PH222Capability_vcCapability *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H222Capability_vcCapability_ElmFn);
}

static int ASN1CALL ASN1Enc_H222Capability_vcCapability_ElmFn(ASN1encoding_t enc, PH222Capability_vcCapability val)
{
    if (!ASN1Enc_VCCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H222Capability_vcCapability(ASN1decoding_t dec, PH222Capability_vcCapability *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H222Capability_vcCapability_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H222Capability_vcCapability_ElmFn(ASN1decoding_t dec, PH222Capability_vcCapability val)
{
    if (!ASN1Dec_VCCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H222Capability_vcCapability(PH222Capability_vcCapability *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H222Capability_vcCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H222Capability_vcCapability_ElmFn(PH222Capability_vcCapability val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CapabilityDescriptor_simultaneousCapabilities_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities val)
{
    if (!ASN1Enc_AlternativeCapabilitySet(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CapabilityDescriptor_simultaneousCapabilities_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities val)
{
    if (!ASN1Dec_AlternativeCapabilitySet(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities(PCapabilityDescriptor_simultaneousCapabilities *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CapabilityDescriptor_simultaneousCapabilities_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities_ElmFn(PCapabilityDescriptor_simultaneousCapabilities val)
{
    if (val) {
	ASN1Free_AlternativeCapabilitySet(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityDescriptors(ASN1encoding_t enc, TerminalCapabilitySet_capabilityDescriptors *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_CapabilityDescriptor(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityDescriptors(ASN1decoding_t dec, TerminalCapabilitySet_capabilityDescriptors *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_CapabilityDescriptor(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityDescriptors(TerminalCapabilitySet_capabilityDescriptors *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_CapabilityDescriptor(&(val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_NonStandardParameter(ASN1encoding_t enc, NonStandardParameter *val)
{
    if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardParameter(ASN1decoding_t dec, NonStandardParameter *val)
{
    if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardParameter(NonStandardParameter *val)
{
    if (val) {
	ASN1Free_NonStandardIdentifier(&(val)->nonStandardIdentifier);
	ASN1octetstring_free(&(val)->data);
    }
}

static int ASN1CALL ASN1Enc_H223Capability(ASN1encoding_t enc, H223Capability *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    o[0] |= 0x40;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->transportWithI_frames))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL3))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL3))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL3))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAl2SDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAl3SDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumDelayJitter))
	return 0;
    if (!ASN1Enc_H223Capability_h223MultiplexTableCapability(enc, &(val)->h223MultiplexTableCapability))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1PEREncBoolean(ee, (val)->maxMUXPDUSizeCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x40) {
	    if (!ASN1PEREncBoolean(ee, (val)->nsrpSupport))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x20) {
	    if (!ASN1Enc_H223Capability_mobileOperationTransmitCapability(ee, &(val)->mobileOperationTransmitCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x10) {
	    if (!ASN1Enc_H223AnnexCCapability(ee, &(val)->h223AnnexCCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223Capability(ASN1decoding_t dec, H223Capability *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->transportWithI_frames))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL3))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL3))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL3))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAl2SDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAl3SDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumDelayJitter))
	return 0;
    if (!ASN1Dec_H223Capability_h223MultiplexTableCapability(dec, &(val)->h223MultiplexTableCapability))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->maxMUXPDUSizeCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->nsrpSupport))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H223Capability_mobileOperationTransmitCapability(dd, &(val)->mobileOperationTransmitCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H223AnnexCCapability(dd, &(val)->h223AnnexCCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V76Capability(ASN1encoding_t enc, V76Capability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->suspendResumeCapabilitywAddress))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->suspendResumeCapabilitywoAddress))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->rejCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->sREJCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->mREJCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->crc8bitCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->crc16bitCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->crc32bitCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->uihCapability))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->numOfDLCS - 2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->twoOctetAddressFieldCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->loopBackTestCapability))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->n401Capability - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->maxWindowSizeCapability - 1))
	return 0;
    if (!ASN1Enc_V75Capability(enc, &(val)->v75Capability))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76Capability(ASN1decoding_t dec, V76Capability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->suspendResumeCapabilitywAddress))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->suspendResumeCapabilitywoAddress))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->rejCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->sREJCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->mREJCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->crc8bitCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->crc16bitCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->crc32bitCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->uihCapability))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->numOfDLCS))
	return 0;
    (val)->numOfDLCS += 2;
    if (!ASN1PERDecBoolean(dec, &(val)->twoOctetAddressFieldCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->loopBackTestCapability))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->n401Capability))
	return 0;
    (val)->n401Capability += 1;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->maxWindowSizeCapability))
	return 0;
    (val)->maxWindowSizeCapability += 1;
    if (!ASN1Dec_V75Capability(dec, &(val)->v75Capability))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RSVPParameters(ASN1encoding_t enc, RSVPParameters *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_QOSMode(enc, &(val)->qosMode))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->tokenRate - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->tokenRate - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	l = ASN1uint32_uoctets((val)->bucketSize - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->bucketSize - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	l = ASN1uint32_uoctets((val)->peakRate - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->peakRate - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	l = ASN1uint32_uoctets((val)->minPoliced - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->minPoliced - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->maxPktSize - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->maxPktSize - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RSVPParameters(ASN1decoding_t dec, RSVPParameters *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_QOSMode(dec, &(val)->qosMode))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->tokenRate))
	    return 0;
	(val)->tokenRate += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bucketSize))
	    return 0;
	(val)->bucketSize += 1;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->peakRate))
	    return 0;
	(val)->peakRate += 1;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->minPoliced))
	    return 0;
	(val)->minPoliced += 1;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->maxPktSize))
	    return 0;
	(val)->maxPktSize += 1;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_QOSCapability(ASN1encoding_t enc, QOSCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_RSVPParameters(enc, &(val)->rsvpParameters))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_ATMParameters(enc, &(val)->atmParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_QOSCapability(ASN1decoding_t dec, QOSCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_RSVPParameters(dec, &(val)->rsvpParameters))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_ATMParameters(dec, &(val)->atmParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_QOSCapability(QOSCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_TransportCapability(ASN1encoding_t enc, TransportCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandard))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_TransportCapability_qOSCapabilities(enc, &(val)->qOSCapabilities))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_TransportCapability_mediaChannelCapabilities(enc, &(val)->mediaChannelCapabilities))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportCapability(ASN1decoding_t dec, TransportCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandard))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_TransportCapability_qOSCapabilities(dec, &(val)->qOSCapabilities))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_TransportCapability_mediaChannelCapabilities(dec, &(val)->mediaChannelCapabilities))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportCapability(TransportCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandard);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_TransportCapability_qOSCapabilities(&(val)->qOSCapabilities);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_TransportCapability_mediaChannelCapabilities(&(val)->mediaChannelCapabilities);
	}
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncodingMethod(ASN1encoding_t enc, RedundancyEncodingMethod *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_RTPH263VideoRedundancyEncoding(ee, &(val)->u.rtpH263VideoRedundancyEncoding))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncodingMethod(ASN1decoding_t dec, RedundancyEncodingMethod *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_RTPH263VideoRedundancyEncoding(dd, &(val)->u.rtpH263VideoRedundancyEncoding))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncodingMethod(RedundancyEncodingMethod *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1Free_RTPH263VideoRedundancyEncoding(&(val)->u.rtpH263VideoRedundancyEncoding);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H263Options(ASN1encoding_t enc, H263Options *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedIntraCodingMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->deblockingFilterMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->improvedPBFramesMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unlimitedMotionVectors))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fullPictureFreeze))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->partialPictureFreezeAndRelease))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->resizingPartPicFreezeAndRelease))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fullPictureSnapshot))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->partialPictureSnapshot))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoSegmentTagging))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->progressiveRefinement))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicPictureResizingByFour))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicPictureResizingSixteenthPel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicWarpingHalfPel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicWarpingSixteenthPel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->independentSegmentDecoding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesInOrder_NonRect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesInOrder_Rect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesNoOrder_NonRect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesNoOrder_Rect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alternateInterVLCMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->modifiedQuantizationMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->reducedResolutionUpdate))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TransparencyParameters(enc, &(val)->transparencyParameters))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->separateVideoBackChannel))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_RefPictureSelection(enc, &(val)->refPictureSelection))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_H263Options_customPictureClockFrequency(enc, &(val)->customPictureClockFrequency))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_H263Options_customPictureFormat(enc, &(val)->customPictureFormat))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_H263Options_modeCombos(enc, &(val)->modeCombos))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H263Options(ASN1decoding_t dec, H263Options *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedIntraCodingMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->deblockingFilterMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->improvedPBFramesMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->unlimitedMotionVectors))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fullPictureFreeze))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->partialPictureFreezeAndRelease))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->resizingPartPicFreezeAndRelease))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fullPictureSnapshot))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->partialPictureSnapshot))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoSegmentTagging))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->progressiveRefinement))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicPictureResizingByFour))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicPictureResizingSixteenthPel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicWarpingHalfPel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicWarpingSixteenthPel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->independentSegmentDecoding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesInOrder_NonRect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesInOrder_Rect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesNoOrder_NonRect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesNoOrder_Rect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alternateInterVLCMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->modifiedQuantizationMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->reducedResolutionUpdate))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransparencyParameters(dec, &(val)->transparencyParameters))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->separateVideoBackChannel))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_RefPictureSelection(dec, &(val)->refPictureSelection))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_H263Options_customPictureClockFrequency(dec, &(val)->customPictureClockFrequency))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_H263Options_customPictureFormat(dec, &(val)->customPictureFormat))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_H263Options_modeCombos(dec, &(val)->modeCombos))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H263Options(H263Options *val)
{
    if (val) {
	if ((val)->o[0] & 0x20) {
	    ASN1Free_H263Options_customPictureClockFrequency(&(val)->customPictureClockFrequency);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_H263Options_customPictureFormat(&(val)->customPictureFormat);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_H263Options_modeCombos(&(val)->modeCombos);
	}
    }
}

static int ASN1CALL ASN1Enc_H263VideoModeCombos(ASN1encoding_t enc, H263VideoModeCombos *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H263ModeComboFlags(enc, &(val)->h263VideoUncoupledModes))
	return 0;
    if (!ASN1Enc_H263VideoModeCombos_h263VideoCoupledModes(enc, &(val)->h263VideoCoupledModes))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoModeCombos(ASN1decoding_t dec, H263VideoModeCombos *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H263ModeComboFlags(dec, &(val)->h263VideoUncoupledModes))
	return 0;
    if (!ASN1Dec_H263VideoModeCombos_h263VideoCoupledModes(dec, &(val)->h263VideoCoupledModes))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H263VideoModeCombos(H263VideoModeCombos *val)
{
    if (val) {
	ASN1Free_H263VideoModeCombos_h263VideoCoupledModes(&(val)->h263VideoCoupledModes);
    }
}

static int ASN1CALL ASN1Enc_AudioCapability(ASN1encoding_t enc, AudioCapability *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g711Alaw64k - 1))
	    return 0;
	break;
    case 3:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g711Alaw56k - 1))
	    return 0;
	break;
    case 4:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g711Ulaw64k - 1))
	    return 0;
	break;
    case 5:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g711Ulaw56k - 1))
	    return 0;
	break;
    case 6:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g722_64k - 1))
	    return 0;
	break;
    case 7:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g722_56k - 1))
	    return 0;
	break;
    case 8:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g722_48k - 1))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_AudioCapability_g7231(enc, &(val)->u.g7231))
	    return 0;
	break;
    case 10:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g728 - 1))
	    return 0;
	break;
    case 11:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g729 - 1))
	    return 0;
	break;
    case 12:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g729AnnexA - 1))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_IS11172AudioCapability(enc, &(val)->u.is11172AudioCapability))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_IS13818AudioCapability(enc, &(val)->u.is13818AudioCapability))
	    return 0;
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 8, (val)->u.g729wAnnexB - 1))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 8, (val)->u.g729AnnexAwAnnexB - 1))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 17:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_G7231AnnexCCapability(ee, &(val)->u.g7231AnnexCCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 18:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmFullRate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 19:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmHalfRate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 20:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmEnhancedFullRate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AudioCapability(ASN1decoding_t dec, AudioCapability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g711Alaw64k))
	    return 0;
	(val)->u.g711Alaw64k += 1;
	break;
    case 3:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g711Alaw56k))
	    return 0;
	(val)->u.g711Alaw56k += 1;
	break;
    case 4:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g711Ulaw64k))
	    return 0;
	(val)->u.g711Ulaw64k += 1;
	break;
    case 5:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g711Ulaw56k))
	    return 0;
	(val)->u.g711Ulaw56k += 1;
	break;
    case 6:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g722_64k))
	    return 0;
	(val)->u.g722_64k += 1;
	break;
    case 7:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g722_56k))
	    return 0;
	(val)->u.g722_56k += 1;
	break;
    case 8:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g722_48k))
	    return 0;
	(val)->u.g722_48k += 1;
	break;
    case 9:
	if (!ASN1Dec_AudioCapability_g7231(dec, &(val)->u.g7231))
	    return 0;
	break;
    case 10:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g728))
	    return 0;
	(val)->u.g728 += 1;
	break;
    case 11:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g729))
	    return 0;
	(val)->u.g729 += 1;
	break;
    case 12:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g729AnnexA))
	    return 0;
	(val)->u.g729AnnexA += 1;
	break;
    case 13:
	if (!ASN1Dec_IS11172AudioCapability(dec, &(val)->u.is11172AudioCapability))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_IS13818AudioCapability(dec, &(val)->u.is13818AudioCapability))
	    return 0;
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU16Val(dd, 8, &(val)->u.g729wAnnexB))
	    return 0;
	(val)->u.g729wAnnexB += 1;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU16Val(dd, 8, &(val)->u.g729AnnexAwAnnexB))
	    return 0;
	(val)->u.g729AnnexAwAnnexB += 1;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 17:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_G7231AnnexCCapability(dd, &(val)->u.g7231AnnexCCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 18:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmFullRate))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 19:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmHalfRate))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 20:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmEnhancedFullRate))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AudioCapability(AudioCapability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CompressionType(ASN1encoding_t enc, CompressionType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_V42bis(enc, &(val)->u.v42bis))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CompressionType(ASN1decoding_t dec, CompressionType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_V42bis(dec, &(val)->u.v42bis))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MediaEncryptionAlgorithm(ASN1encoding_t enc, MediaEncryptionAlgorithm *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.algorithm))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaEncryptionAlgorithm(ASN1decoding_t dec, MediaEncryptionAlgorithm *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.algorithm))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MediaEncryptionAlgorithm(MediaEncryptionAlgorithm *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1objectidentifier_free(&(val)->u.algorithm);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_AuthenticationCapability(ASN1encoding_t enc, AuthenticationCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandard))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AuthenticationCapability(ASN1decoding_t dec, AuthenticationCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandard))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AuthenticationCapability(AuthenticationCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandard);
	}
    }
}

static int ASN1CALL ASN1Enc_IntegrityCapability(ASN1encoding_t enc, IntegrityCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandard))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IntegrityCapability(ASN1decoding_t dec, IntegrityCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandard))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_IntegrityCapability(IntegrityCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandard);
	}
    }
}

static int ASN1CALL ASN1Enc_H223AL1MParameters(ASN1encoding_t enc, H223AL1MParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223AL1MParameters_transferMode(enc, &(val)->transferMode))
	return 0;
    if (!ASN1Enc_H223AL1MParameters_headerFEC(enc, &(val)->headerFEC))
	return 0;
    if (!ASN1Enc_H223AL1MParameters_crcLength(enc, &(val)->crcLength))
	return 0;
    if (!ASN1PEREncBitVal(enc, 5, (val)->rcpcCodeRate - 8))
	return 0;
    if (!ASN1Enc_H223AL1MParameters_arqType(enc, &(val)->arqType))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alpduInterleaving))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alsduSplitting))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL1MParameters(ASN1decoding_t dec, H223AL1MParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223AL1MParameters_transferMode(dec, &(val)->transferMode))
	return 0;
    if (!ASN1Dec_H223AL1MParameters_headerFEC(dec, &(val)->headerFEC))
	return 0;
    if (!ASN1Dec_H223AL1MParameters_crcLength(dec, &(val)->crcLength))
	return 0;
    if (!ASN1PERDecU16Val(dec, 5, &(val)->rcpcCodeRate))
	return 0;
    (val)->rcpcCodeRate += 8;
    if (!ASN1Dec_H223AL1MParameters_arqType(dec, &(val)->arqType))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alpduInterleaving))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alsduSplitting))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL3MParameters(ASN1encoding_t enc, H223AL3MParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223AL3MParameters_headerFormat(enc, &(val)->headerFormat))
	return 0;
    if (!ASN1Enc_H223AL3MParameters_crcLength(enc, &(val)->crcLength))
	return 0;
    if (!ASN1PEREncBitVal(enc, 5, (val)->rcpcCodeRate - 8))
	return 0;
    if (!ASN1Enc_H223AL3MParameters_arqType(enc, &(val)->arqType))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alpduInterleaving))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL3MParameters(ASN1decoding_t dec, H223AL3MParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223AL3MParameters_headerFormat(dec, &(val)->headerFormat))
	return 0;
    if (!ASN1Dec_H223AL3MParameters_crcLength(dec, &(val)->crcLength))
	return 0;
    if (!ASN1PERDecU16Val(dec, 5, &(val)->rcpcCodeRate))
	return 0;
    (val)->rcpcCodeRate += 8;
    if (!ASN1Dec_H223AL3MParameters_arqType(dec, &(val)->arqType))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alpduInterleaving))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V76HDLCParameters(ASN1encoding_t enc, V76HDLCParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_CRCLength(enc, &(val)->crcLength))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->n401 - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->loopbackTestProcedure))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76HDLCParameters(ASN1decoding_t dec, V76HDLCParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_CRCLength(dec, &(val)->crcLength))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->n401))
	return 0;
    (val)->n401 += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->loopbackTestProcedure))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UnicastAddress(ASN1encoding_t enc, UnicastAddress *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 5))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_UnicastAddress_iPAddress(enc, &(val)->u.iPAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_UnicastAddress_iPXAddress(enc, &(val)->u.iPXAddress))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_UnicastAddress_iP6Address(enc, &(val)->u.iP6Address))
	    return 0;
	break;
    case 4:
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_UnicastAddress_iPSourceRouteAddress(enc, &(val)->u.iPSourceRouteAddress))
	    return 0;
	break;
    case 6:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncOctetString_VarSize(ee, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 7:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_NonStandardParameter(ee, &(val)->u.nonStandardAddress))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress(ASN1decoding_t dec, UnicastAddress *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 5))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_UnicastAddress_iPAddress(dec, &(val)->u.iPAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_UnicastAddress_iPXAddress(dec, &(val)->u.iPXAddress))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_UnicastAddress_iP6Address(dec, &(val)->u.iP6Address))
	    return 0;
	break;
    case 4:
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_UnicastAddress_iPSourceRouteAddress(dec, &(val)->u.iPSourceRouteAddress))
	    return 0;
	break;
    case 6:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1PERDecOctetString_VarSize(dd, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 7:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_NonStandardParameter(dd, &(val)->u.nonStandardAddress))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress(UnicastAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_UnicastAddress_iPAddress(&(val)->u.iPAddress);
	    break;
	case 2:
	    ASN1Free_UnicastAddress_iPXAddress(&(val)->u.iPXAddress);
	    break;
	case 3:
	    ASN1Free_UnicastAddress_iP6Address(&(val)->u.iP6Address);
	    break;
	case 4:
	    break;
	case 5:
	    ASN1Free_UnicastAddress_iPSourceRouteAddress(&(val)->u.iPSourceRouteAddress);
	    break;
	case 6:
	    break;
	case 7:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAddress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MulticastAddress(ASN1encoding_t enc, MulticastAddress *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_MulticastAddress_iPAddress(enc, &(val)->u.iPAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MulticastAddress_iP6Address(enc, &(val)->u.iP6Address))
	    return 0;
	break;
    case 3:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncOctetString_VarSize(ee, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_NonStandardParameter(ee, &(val)->u.nonStandardAddress))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MulticastAddress(ASN1decoding_t dec, MulticastAddress *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_MulticastAddress_iPAddress(dec, &(val)->u.iPAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MulticastAddress_iP6Address(dec, &(val)->u.iP6Address))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1PERDecOctetString_VarSize(dd, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_NonStandardParameter(dd, &(val)->u.nonStandardAddress))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MulticastAddress(MulticastAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_MulticastAddress_iPAddress(&(val)->u.iPAddress);
	    break;
	case 2:
	    ASN1Free_MulticastAddress_iP6Address(&(val)->u.iP6Address);
	    break;
	case 3:
	    break;
	case 4:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAddress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionSync(ASN1encoding_t enc, EncryptionSync *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandard))
	    return 0;
    }
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->synchFlag))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->h235Key, 1, 65535, 16))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_EncryptionSync_escrowentry(enc, &(val)->escrowentry))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionSync(ASN1decoding_t dec, EncryptionSync *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandard))
	    return 0;
    }
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->synchFlag))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->h235Key, 1, 65535, 16))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_EncryptionSync_escrowentry(dec, &(val)->escrowentry))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionSync(EncryptionSync *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandard);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_EncryptionSync_escrowentry(&(val)->escrowentry);
	}
    }
}

static int ASN1CALL ASN1Enc_RequestChannelClose(ASN1encoding_t enc, RequestChannelClose *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1Enc_QOSCapability(ee, &(val)->qosCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x40) {
	    if (!ASN1Enc_RequestChannelClose_reason(ee, &(val)->reason))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelClose(ASN1decoding_t dec, RequestChannelClose *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_QOSCapability(dd, &(val)->qosCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RequestChannelClose_reason(dd, &(val)->reason))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestChannelClose(RequestChannelClose *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_QOSCapability(&(val)->qosCapability);
	}
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntryDescriptor(ASN1encoding_t enc, MultiplexEntryDescriptor *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->multiplexTableEntryNumber - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MultiplexEntryDescriptor_elementList(enc, &(val)->elementList))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntryDescriptor(ASN1decoding_t dec, MultiplexEntryDescriptor *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->multiplexTableEntryNumber))
	return 0;
    (val)->multiplexTableEntryNumber += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_MultiplexEntryDescriptor_elementList(dec, &(val)->elementList))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntryDescriptor(MultiplexEntryDescriptor *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MultiplexEntryDescriptor_elementList(&(val)->elementList);
	}
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendReject(ASN1encoding_t enc, MultiplexEntrySendReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_MultiplexEntrySendReject_rejectionDescriptions(enc, &(val)->rejectionDescriptions))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendReject(ASN1decoding_t dec, MultiplexEntrySendReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_MultiplexEntrySendReject_rejectionDescriptions(dec, &(val)->rejectionDescriptions))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendReject(MultiplexEntrySendReject *val)
{
    if (val) {
	ASN1Free_MultiplexEntrySendReject_rejectionDescriptions(&(val)->rejectionDescriptions);
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject(ASN1encoding_t enc, RequestMultiplexEntryReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntryReject_entryNumbers(enc, &(val)->entryNumbers))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntryReject_rejectionDescriptions(enc, &(val)->rejectionDescriptions))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject(ASN1decoding_t dec, RequestMultiplexEntryReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_RequestMultiplexEntryReject_entryNumbers(dec, &(val)->entryNumbers))
	return 0;
    if (!ASN1Dec_RequestMultiplexEntryReject_rejectionDescriptions(dec, &(val)->rejectionDescriptions))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryReject(RequestMultiplexEntryReject *val)
{
    if (val) {
	ASN1Free_RequestMultiplexEntryReject_entryNumbers(&(val)->entryNumbers);
	ASN1Free_RequestMultiplexEntryReject_rejectionDescriptions(&(val)->rejectionDescriptions);
    }
}

static int ASN1CALL ASN1Enc_H263VideoMode(ASN1encoding_t enc, H263VideoMode *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1Enc_H263VideoMode_resolution(enc, &(val)->resolution))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unrestrictedVector))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->arithmeticCoding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedPrediction))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->pbFrames))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1PEREncBoolean(ee, (val)->errorCompensation))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x40) {
	    if (!ASN1Enc_EnhancementLayerInfo(ee, &(val)->enhancementLayerInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x20) {
	    if (!ASN1Enc_H263Options(ee, &(val)->h263Options))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoMode(ASN1decoding_t dec, H263VideoMode *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H263VideoMode_resolution(dec, &(val)->resolution))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->unrestrictedVector))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->arithmeticCoding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedPrediction))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->pbFrames))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->errorCompensation))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_EnhancementLayerInfo(dd, &(val)->enhancementLayerInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H263Options(dd, &(val)->h263Options))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H263VideoMode(H263VideoMode *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_EnhancementLayerInfo(&(val)->enhancementLayerInfo);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_H263Options(&(val)->h263Options);
	}
    }
}

static int ASN1CALL ASN1Enc_AudioMode(ASN1encoding_t enc, AudioMode *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	break;
    case 11:
	break;
    case 12:
	if (!ASN1Enc_AudioMode_g7231(enc, &(val)->u.g7231))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_IS11172AudioMode(enc, &(val)->u.is11172AudioMode))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_IS13818AudioMode(enc, &(val)->u.is13818AudioMode))
	    return 0;
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 8, (val)->u.g729wAnnexB - 1))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 8, (val)->u.g729AnnexAwAnnexB - 1))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 17:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_G7231AnnexCMode(ee, &(val)->u.g7231AnnexCMode))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 18:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmFullRate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 19:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmHalfRate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 20:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmEnhancedFullRate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AudioMode(ASN1decoding_t dec, AudioMode *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	break;
    case 11:
	break;
    case 12:
	if (!ASN1Dec_AudioMode_g7231(dec, &(val)->u.g7231))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_IS11172AudioMode(dec, &(val)->u.is11172AudioMode))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_IS13818AudioMode(dec, &(val)->u.is13818AudioMode))
	    return 0;
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU16Val(dd, 8, &(val)->u.g729wAnnexB))
	    return 0;
	(val)->u.g729wAnnexB += 1;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU16Val(dd, 8, &(val)->u.g729AnnexAwAnnexB))
	    return 0;
	(val)->u.g729AnnexAwAnnexB += 1;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 17:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_G7231AnnexCMode(dd, &(val)->u.g7231AnnexCMode))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 18:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmFullRate))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 19:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmHalfRate))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 20:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmEnhancedFullRate))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AudioMode(AudioMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionMode(ASN1encoding_t enc, EncryptionMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionMode(ASN1decoding_t dec, EncryptionMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionMode(EncryptionMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceRequest(ASN1encoding_t enc, ConferenceRequest *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 8))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.dropTerminal))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.requestTerminalID))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 10:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceRequest_requestTerminalCertificate(ee, &(val)->u.requestTerminalCertificate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncUnsignedShort(ee, (val)->u.broadcastMyLogicalChannel - 1))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 13:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TerminalLabel(ee, &(val)->u.makeTerminalBroadcaster))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 14:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TerminalLabel(ee, &(val)->u.sendThisSource))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_RemoteMCRequest(ee, &(val)->u.remoteMCRequest))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceRequest(ASN1decoding_t dec, ConferenceRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 8))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.dropTerminal))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.requestTerminalID))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 10:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceRequest_requestTerminalCertificate(dd, &(val)->u.requestTerminalCertificate))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1PERDecUnsignedShort(dd, &(val)->u.broadcastMyLogicalChannel))
	    return 0;
	(val)->u.broadcastMyLogicalChannel += 1;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 13:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_TerminalLabel(dd, &(val)->u.makeTerminalBroadcaster))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 14:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_TerminalLabel(dd, &(val)->u.sendThisSource))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_RemoteMCRequest(dd, &(val)->u.remoteMCRequest))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceRequest(ConferenceRequest *val)
{
    if (val) {
	switch ((val)->choice) {
	case 11:
	    ASN1Free_ConferenceRequest_requestTerminalCertificate(&(val)->u.requestTerminalCertificate);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CertSelectionCriteria(ASN1encoding_t enc, PCertSelectionCriteria *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CertSelectionCriteria_ElmFn, 1, 16, 4);
}

static int ASN1CALL ASN1Enc_CertSelectionCriteria_ElmFn(ASN1encoding_t enc, PCertSelectionCriteria val)
{
    if (!ASN1Enc_Criteria(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertSelectionCriteria(ASN1decoding_t dec, PCertSelectionCriteria *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CertSelectionCriteria_ElmFn, sizeof(**val), 1, 16, 4);
}

static int ASN1CALL ASN1Dec_CertSelectionCriteria_ElmFn(ASN1decoding_t dec, PCertSelectionCriteria val)
{
    if (!ASN1Dec_Criteria(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertSelectionCriteria(PCertSelectionCriteria *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CertSelectionCriteria_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CertSelectionCriteria_ElmFn(PCertSelectionCriteria val)
{
    if (val) {
	ASN1Free_Criteria(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse(ASN1encoding_t enc, ConferenceResponse *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 8))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ConferenceResponse_mCTerminalIDResponse(enc, &(val)->u.mCTerminalIDResponse))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ConferenceResponse_terminalIDResponse(enc, &(val)->u.terminalIDResponse))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ConferenceResponse_conferenceIDResponse(enc, &(val)->u.conferenceIDResponse))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ConferenceResponse_passwordResponse(enc, &(val)->u.passwordResponse))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_ConferenceResponse_terminalListResponse(enc, &(val)->u.terminalListResponse))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (!ASN1Enc_ConferenceResponse_makeMeChairResponse(enc, &(val)->u.makeMeChairResponse))
	    return 0;
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse_extensionAddressResponse(ee, &(val)->u.extensionAddressResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 10:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse_chairTokenOwnerResponse(ee, &(val)->u.chairTokenOwnerResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse_terminalCertificateResponse(ee, &(val)->u.terminalCertificateResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse_broadcastMyLogicalChannelResponse(ee, &(val)->u.broadcastMyLogicalChannelResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 13:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse_makeTerminalBroadcasterResponse(ee, &(val)->u.makeTerminalBroadcasterResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 14:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse_sendThisSourceResponse(ee, &(val)->u.sendThisSourceResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_RequestAllTerminalIDsResponse(ee, &(val)->u.requestAllTerminalIDsResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_RemoteMCResponse(ee, &(val)->u.remoteMCResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse(ASN1decoding_t dec, ConferenceResponse *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 8))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ConferenceResponse_mCTerminalIDResponse(dec, &(val)->u.mCTerminalIDResponse))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ConferenceResponse_terminalIDResponse(dec, &(val)->u.terminalIDResponse))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ConferenceResponse_conferenceIDResponse(dec, &(val)->u.conferenceIDResponse))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ConferenceResponse_passwordResponse(dec, &(val)->u.passwordResponse))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_ConferenceResponse_terminalListResponse(dec, &(val)->u.terminalListResponse))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (!ASN1Dec_ConferenceResponse_makeMeChairResponse(dec, &(val)->u.makeMeChairResponse))
	    return 0;
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse_extensionAddressResponse(dd, &(val)->u.extensionAddressResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 10:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse_chairTokenOwnerResponse(dd, &(val)->u.chairTokenOwnerResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse_terminalCertificateResponse(dd, &(val)->u.terminalCertificateResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse_broadcastMyLogicalChannelResponse(dd, &(val)->u.broadcastMyLogicalChannelResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 13:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse_makeTerminalBroadcasterResponse(dd, &(val)->u.makeTerminalBroadcasterResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 14:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse_sendThisSourceResponse(dd, &(val)->u.sendThisSourceResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_RequestAllTerminalIDsResponse(dd, &(val)->u.requestAllTerminalIDsResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_RemoteMCResponse(dd, &(val)->u.remoteMCResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse(ConferenceResponse *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ConferenceResponse_mCTerminalIDResponse(&(val)->u.mCTerminalIDResponse);
	    break;
	case 2:
	    ASN1Free_ConferenceResponse_terminalIDResponse(&(val)->u.terminalIDResponse);
	    break;
	case 3:
	    ASN1Free_ConferenceResponse_conferenceIDResponse(&(val)->u.conferenceIDResponse);
	    break;
	case 4:
	    ASN1Free_ConferenceResponse_passwordResponse(&(val)->u.passwordResponse);
	    break;
	case 5:
	    ASN1Free_ConferenceResponse_terminalListResponse(&(val)->u.terminalListResponse);
	    break;
	case 9:
	    ASN1Free_ConferenceResponse_extensionAddressResponse(&(val)->u.extensionAddressResponse);
	    break;
	case 10:
	    ASN1Free_ConferenceResponse_chairTokenOwnerResponse(&(val)->u.chairTokenOwnerResponse);
	    break;
	case 11:
	    ASN1Free_ConferenceResponse_terminalCertificateResponse(&(val)->u.terminalCertificateResponse);
	    break;
	case 15:
	    ASN1Free_RequestAllTerminalIDsResponse(&(val)->u.requestAllTerminalIDsResponse);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EndSessionCommand(ASN1encoding_t enc, EndSessionCommand *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_EndSessionCommand_gstnOptions(enc, &(val)->u.gstnOptions))
	    return 0;
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_EndSessionCommand_isdnOptions(ee, &(val)->u.isdnOptions))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EndSessionCommand(ASN1decoding_t dec, EndSessionCommand *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_EndSessionCommand_gstnOptions(dec, &(val)->u.gstnOptions))
	    return 0;
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_EndSessionCommand_isdnOptions(dd, &(val)->u.isdnOptions))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EndSessionCommand(EndSessionCommand *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceCommand(ASN1encoding_t enc, ConferenceCommand *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.broadcastMyLogicalChannel - 1))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.cancelBroadcastMyLogicalChannel - 1))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.makeTerminalBroadcaster))
	    return 0;
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.sendThisSource))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_SubstituteConferenceIDCommand(ee, &(val)->u.substituteConferenceIDCommand))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceCommand(ASN1decoding_t dec, ConferenceCommand *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.broadcastMyLogicalChannel))
	    return 0;
	(val)->u.broadcastMyLogicalChannel += 1;
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.cancelBroadcastMyLogicalChannel))
	    return 0;
	(val)->u.cancelBroadcastMyLogicalChannel += 1;
	break;
    case 3:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.makeTerminalBroadcaster))
	    return 0;
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.sendThisSource))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_SubstituteConferenceIDCommand(dd, &(val)->u.substituteConferenceIDCommand))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceCommand(ConferenceCommand *val)
{
    if (val) {
	switch ((val)->choice) {
	case 8:
	    ASN1Free_SubstituteConferenceIDCommand(&(val)->u.substituteConferenceIDCommand);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_UserInputIndication_userInputSupportIndication(ASN1encoding_t enc, UserInputIndication_userInputSupportIndication *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication_userInputSupportIndication(ASN1decoding_t dec, UserInputIndication_userInputSupportIndication *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputIndication_userInputSupportIndication(UserInputIndication_userInputSupportIndication *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousIndication_type(ASN1encoding_t enc, MiscellaneousIndication_type *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	if (!ASN1PEREncBitVal(enc, 5, (val)->u.videoTemporalSpatialTradeOff))
	    return 0;
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_MiscellaneousIndication_type_videoNotDecodedMBs(ee, &(val)->u.videoNotDecodedMBs))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TransportCapability(ee, &(val)->u.transportCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousIndication_type(ASN1decoding_t dec, MiscellaneousIndication_type *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	if (!ASN1PERDecU16Val(dec, 5, &(val)->u.videoTemporalSpatialTradeOff))
	    return 0;
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_MiscellaneousIndication_type_videoNotDecodedMBs(dd, &(val)->u.videoNotDecodedMBs))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_TransportCapability(dd, &(val)->u.transportCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MiscellaneousIndication_type(MiscellaneousIndication_type *val)
{
    if (val) {
	switch ((val)->choice) {
	case 12:
	    ASN1Free_TransportCapability(&(val)->u.transportCapability);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type(ASN1encoding_t enc, MiscellaneousCommand_type *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Enc_MiscellaneousCommand_type_videoFastUpdateGOB(enc, &(val)->u.videoFastUpdateGOB))
	    return 0;
	break;
    case 8:
	if (!ASN1PEREncBitVal(enc, 5, (val)->u.videoTemporalSpatialTradeOff))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_MiscellaneousCommand_type_videoFastUpdateMB(ee, &(val)->u.videoFastUpdateMB))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncUnsignedShort(ee, (val)->u.maxH223MUXPDUsize - 1))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 13:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_EncryptionSync(ee, &(val)->u.encryptionUpdate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 14:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_EncryptionUpdateRequest(ee, &(val)->u.encryptionUpdateRequest))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 17:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart(ee, &(val)->u.progressiveRefinementStart))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 18:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 19:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type(ASN1decoding_t dec, MiscellaneousCommand_type *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Dec_MiscellaneousCommand_type_videoFastUpdateGOB(dec, &(val)->u.videoFastUpdateGOB))
	    return 0;
	break;
    case 8:
	if (!ASN1PERDecU16Val(dec, 5, &(val)->u.videoTemporalSpatialTradeOff))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_MiscellaneousCommand_type_videoFastUpdateMB(dd, &(val)->u.videoFastUpdateMB))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1PERDecUnsignedShort(dd, &(val)->u.maxH223MUXPDUsize))
	    return 0;
	(val)->u.maxH223MUXPDUsize += 1;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 13:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_EncryptionSync(dd, &(val)->u.encryptionUpdate))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 14:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_EncryptionUpdateRequest(dd, &(val)->u.encryptionUpdateRequest))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 17:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart(dd, &(val)->u.progressiveRefinementStart))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 18:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 19:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MiscellaneousCommand_type(MiscellaneousCommand_type *val)
{
    if (val) {
	switch ((val)->choice) {
	case 13:
	    ASN1Free_EncryptionSync(&(val)->u.encryptionUpdate);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionCommand_encryptionAlgorithmID(ASN1encoding_t enc, EncryptionCommand_encryptionAlgorithmID *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->h233AlgorithmIdentifier))
	return 0;
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->associatedAlgorithm))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionCommand_encryptionAlgorithmID(ASN1decoding_t dec, EncryptionCommand_encryptionAlgorithmID *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->h233AlgorithmIdentifier))
	return 0;
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->associatedAlgorithm))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionCommand_encryptionAlgorithmID(EncryptionCommand_encryptionAlgorithmID *val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&(val)->associatedAlgorithm);
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CommunicationModeTableEntry_nonStandard_ElmFn);
}

static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CommunicationModeTableEntry_nonStandard_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard(PCommunicationModeTableEntry_nonStandard *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CommunicationModeTableEntry_nonStandard_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard_ElmFn(PCommunicationModeTableEntry_nonStandard val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncodingMode_secondaryEncoding(ASN1encoding_t enc, RedundancyEncodingMode_secondaryEncoding *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_AudioMode(enc, &(val)->u.audioData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncodingMode_secondaryEncoding(ASN1decoding_t dec, RedundancyEncodingMode_secondaryEncoding *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_AudioMode(dec, &(val)->u.audioData))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncodingMode_secondaryEncoding(RedundancyEncodingMode_secondaryEncoding *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_AudioMode(&(val)->u.audioData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H223ModeParameters_adaptationLayerType(ASN1encoding_t enc, H223ModeParameters_adaptationLayerType *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Enc_H223ModeParameters_adaptationLayerType_al3(enc, &(val)->u.al3))
	    return 0;
	break;
    case 7:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AL1MParameters(ee, &(val)->u.al1M))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AL2MParameters(ee, &(val)->u.al2M))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AL3MParameters(ee, &(val)->u.al3M))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223ModeParameters_adaptationLayerType(ASN1decoding_t dec, H223ModeParameters_adaptationLayerType *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Dec_H223ModeParameters_adaptationLayerType_al3(dec, &(val)->u.al3))
	    return 0;
	break;
    case 7:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H223AL1MParameters(dd, &(val)->u.al1M))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H223AL2MParameters(dd, &(val)->u.al2M))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H223AL3MParameters(dd, &(val)->u.al3M))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223ModeParameters_adaptationLayerType(H223ModeParameters_adaptationLayerType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn, 1, 15, 4);
}

static int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors val)
{
    if (!ASN1Enc_MultiplexEntryDescriptor(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn, sizeof(**val), 1, 15, 4);
}

static int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors val)
{
    if (!ASN1Dec_MultiplexEntryDescriptor(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors(PMultiplexEntrySend_multiplexEntryDescriptors *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn);
    }
}

static void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(PMultiplexEntrySend_multiplexEntryDescriptors val)
{
    if (val) {
	ASN1Free_MultiplexEntryDescriptor(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H2250LogicalChannelAckParameters_nonStandard_ElmFn);
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H2250LogicalChannelAckParameters_nonStandard_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard(PH2250LogicalChannelAckParameters_nonStandard *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H2250LogicalChannelAckParameters_nonStandard_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard_ElmFn(PH2250LogicalChannelAckParameters_nonStandard val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RTPPayloadType_payloadDescriptor(ASN1encoding_t enc, RTPPayloadType_payloadDescriptor *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardIdentifier))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncExtensionBitClear(enc))
	    return 0;
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.rfc_number - 1))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.oid))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPPayloadType_payloadDescriptor(ASN1decoding_t dec, RTPPayloadType_payloadDescriptor *val)
{
    ASN1uint32_t x;
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardIdentifier))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecExtensionBit(dec, &x))
	    return 0;
	if (!x) {
	    if (!ASN1PERDecUnsignedShort(dec, &(val)->u.rfc_number))
		return 0;
	    (val)->u.rfc_number += 1;
	} else {
	    ASN1PERDecAlignment(dec);
	    if (!ASN1PERDecFragmentedLength(dec, &l))
		return 0;
	    if (!ASN1PERDecSkipBits(dec, l * 8))
		return 0;
	}
	break;
    case 3:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.oid))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPPayloadType_payloadDescriptor(RTPPayloadType_payloadDescriptor *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardIdentifier);
	    break;
	case 3:
	    ASN1objectidentifier_free(&(val)->u.oid);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn);
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard(PH2250LogicalChannelParameters_nonStandard *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn(PH2250LogicalChannelParameters_nonStandard val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H223LogicalChannelParameters_adaptationLayerType(ASN1encoding_t enc, H223LogicalChannelParameters_adaptationLayerType *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Enc_H223LogicalChannelParameters_adaptationLayerType_al3(enc, &(val)->u.al3))
	    return 0;
	break;
    case 7:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AL1MParameters(ee, &(val)->u.al1M))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AL2MParameters(ee, &(val)->u.al2M))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AL3MParameters(ee, &(val)->u.al3M))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223LogicalChannelParameters_adaptationLayerType(ASN1decoding_t dec, H223LogicalChannelParameters_adaptationLayerType *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Dec_H223LogicalChannelParameters_adaptationLayerType_al3(dec, &(val)->u.al3))
	    return 0;
	break;
    case 7:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H223AL1MParameters(dd, &(val)->u.al1M))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H223AL2MParameters(dd, &(val)->u.al2M))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H223AL3MParameters(dd, &(val)->u.al3M))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223LogicalChannelParameters_adaptationLayerType(H223LogicalChannelParameters_adaptationLayerType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData(ASN1encoding_t enc, PConferenceCapability_nonStandardData *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConferenceCapability_nonStandardData_ElmFn);
}

static int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData_ElmFn(ASN1encoding_t enc, PConferenceCapability_nonStandardData val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData(ASN1decoding_t dec, PConferenceCapability_nonStandardData *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConferenceCapability_nonStandardData_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData_ElmFn(ASN1decoding_t dec, PConferenceCapability_nonStandardData val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData(PConferenceCapability_nonStandardData *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConferenceCapability_nonStandardData_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData_ElmFn(PConferenceCapability_nonStandardData val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UserInputCapability_nonStandard(ASN1encoding_t enc, UserInputCapability_nonStandard *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_NonStandardParameter(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputCapability_nonStandard(ASN1decoding_t dec, UserInputCapability_nonStandard *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_NonStandardParameter(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputCapability_nonStandard(UserInputCapability_nonStandard *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_NonStandardParameter(&(val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_DataProtocolCapability_v76wCompression(ASN1encoding_t enc, DataProtocolCapability_v76wCompression *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_CompressionType(enc, &(val)->u.transmitCompression))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_CompressionType(enc, &(val)->u.receiveCompression))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_CompressionType(enc, &(val)->u.transmitAndReceiveCompression))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataProtocolCapability_v76wCompression(ASN1decoding_t dec, DataProtocolCapability_v76wCompression *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_CompressionType(dec, &(val)->u.transmitCompression))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_CompressionType(dec, &(val)->u.receiveCompression))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_CompressionType(dec, &(val)->u.transmitAndReceiveCompression))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H263Options_modeCombos(ASN1encoding_t enc, PH263Options_modeCombos *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H263Options_modeCombos_ElmFn, 1, 16, 4);
}

static int ASN1CALL ASN1Enc_H263Options_modeCombos_ElmFn(ASN1encoding_t enc, PH263Options_modeCombos val)
{
    if (!ASN1Enc_H263VideoModeCombos(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263Options_modeCombos(ASN1decoding_t dec, PH263Options_modeCombos *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H263Options_modeCombos_ElmFn, sizeof(**val), 1, 16, 4);
}

static int ASN1CALL ASN1Dec_H263Options_modeCombos_ElmFn(ASN1decoding_t dec, PH263Options_modeCombos val)
{
    if (!ASN1Dec_H263VideoModeCombos(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H263Options_modeCombos(PH263Options_modeCombos *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H263Options_modeCombos_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H263Options_modeCombos_ElmFn(PH263Options_modeCombos val)
{
    if (val) {
	ASN1Free_H263VideoModeCombos(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TransportCapability_qOSCapabilities(ASN1encoding_t enc, PTransportCapability_qOSCapabilities *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TransportCapability_qOSCapabilities_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_TransportCapability_qOSCapabilities_ElmFn(ASN1encoding_t enc, PTransportCapability_qOSCapabilities val)
{
    if (!ASN1Enc_QOSCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportCapability_qOSCapabilities(ASN1decoding_t dec, PTransportCapability_qOSCapabilities *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TransportCapability_qOSCapabilities_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_TransportCapability_qOSCapabilities_ElmFn(ASN1decoding_t dec, PTransportCapability_qOSCapabilities val)
{
    if (!ASN1Dec_QOSCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportCapability_qOSCapabilities(PTransportCapability_qOSCapabilities *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TransportCapability_qOSCapabilities_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TransportCapability_qOSCapabilities_ElmFn(PTransportCapability_qOSCapabilities val)
{
    if (val) {
	ASN1Free_QOSCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_NonStandardMessage(ASN1encoding_t enc, NonStandardMessage *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardMessage(ASN1decoding_t dec, NonStandardMessage *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardMessage(NonStandardMessage *val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&(val)->nonStandardData);
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncodingCapability(ASN1encoding_t enc, RedundancyEncodingCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_RedundancyEncodingMethod(enc, &(val)->redundancyEncodingMethod))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->primaryEncoding - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_RedundancyEncodingCapability_secondaryEncoding(enc, &(val)->secondaryEncoding))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncodingCapability(ASN1decoding_t dec, RedundancyEncodingCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_RedundancyEncodingMethod(dec, &(val)->redundancyEncodingMethod))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->primaryEncoding))
	return 0;
    (val)->primaryEncoding += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_RedundancyEncodingCapability_secondaryEncoding(dec, &(val)->secondaryEncoding))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncodingCapability(RedundancyEncodingCapability *val)
{
    if (val) {
	ASN1Free_RedundancyEncodingMethod(&(val)->redundancyEncodingMethod);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_RedundancyEncodingCapability_secondaryEncoding(&(val)->secondaryEncoding);
	}
    }
}

static int ASN1CALL ASN1Enc_H263VideoCapability(ASN1encoding_t enc, H263VideoCapability *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x4;
    y = ASN1PEREncCheckExtensions(8, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 7, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->sqcifMPI - 1))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->qcifMPI - 1))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cifMPI - 1))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cif4MPI - 1))
	    return 0;
    }
    if (o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cif16MPI - 1))
	    return 0;
    }
    l = ASN1uint32_uoctets((val)->maxBitRate - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->maxBitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unrestrictedVector))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->arithmeticCoding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedPrediction))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->pbFrames))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->temporalSpatialTradeOffCapability))
	return 0;
    if (o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->hrd_B);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->hrd_B))
	    return 0;
    }
    if (o[0] & 0x2) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->bppMaxKb))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 8, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->slowSqcifMPI - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->slowQcifMPI - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->slowCifMPI - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->slowCif4MPI - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->slowCif16MPI - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1PEREncBoolean(ee, (val)->errorCompensation))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1Enc_EnhancementLayerInfo(ee, &(val)->enhancementLayerInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x1) {
	    if (!ASN1Enc_H263Options(ee, &(val)->h263Options))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoCapability(ASN1decoding_t dec, H263VideoCapability *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->sqcifMPI))
	    return 0;
	(val)->sqcifMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->qcifMPI))
	    return 0;
	(val)->qcifMPI += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cifMPI))
	    return 0;
	(val)->cifMPI += 1;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cif4MPI))
	    return 0;
	(val)->cif4MPI += 1;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cif16MPI))
	    return 0;
	(val)->cif16MPI += 1;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->maxBitRate))
	return 0;
    (val)->maxBitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->unrestrictedVector))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->arithmeticCoding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedPrediction))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->pbFrames))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->temporalSpatialTradeOffCapability))
	return 0;
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->hrd_B))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->bppMaxKb))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 8, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->slowSqcifMPI))
		return 0;
	    (val)->slowSqcifMPI += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->slowQcifMPI))
		return 0;
	    (val)->slowQcifMPI += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->slowCifMPI))
		return 0;
	    (val)->slowCifMPI += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->slowCif4MPI))
		return 0;
	    (val)->slowCif4MPI += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->slowCif16MPI))
		return 0;
	    (val)->slowCif16MPI += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->errorCompensation))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_EnhancementLayerInfo(dd, &(val)->enhancementLayerInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H263Options(dd, &(val)->h263Options))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H263VideoCapability(H263VideoCapability *val)
{
    if (val) {
	if ((val)->o[1] & 0x2) {
	    ASN1Free_EnhancementLayerInfo(&(val)->enhancementLayerInfo);
	}
	if ((val)->o[1] & 0x1) {
	    ASN1Free_H263Options(&(val)->h263Options);
	}
    }
}

static int ASN1CALL ASN1Enc_EnhancementOptions(ASN1encoding_t enc, EnhancementOptions *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 11, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->sqcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->qcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cif4MPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cif16MPI - 1))
	    return 0;
    }
    l = ASN1uint32_uoctets((val)->maxBitRate - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->maxBitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unrestrictedVector))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->arithmeticCoding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->temporalSpatialTradeOffCapability))
	return 0;
    if ((val)->o[0] & 0x4) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->slowSqcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->slowQcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->slowCifMPI - 1))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->slowCif4MPI - 1))
	    return 0;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->slowCif16MPI - 1))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->errorCompensation))
	return 0;
    if ((val)->o[1] & 0x20) {
	if (!ASN1Enc_H263Options(enc, &(val)->h263Options))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancementOptions(ASN1decoding_t dec, EnhancementOptions *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 11, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->sqcifMPI))
	    return 0;
	(val)->sqcifMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->qcifMPI))
	    return 0;
	(val)->qcifMPI += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cifMPI))
	    return 0;
	(val)->cifMPI += 1;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cif4MPI))
	    return 0;
	(val)->cif4MPI += 1;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cif16MPI))
	    return 0;
	(val)->cif16MPI += 1;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->maxBitRate))
	return 0;
    (val)->maxBitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->unrestrictedVector))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->arithmeticCoding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->temporalSpatialTradeOffCapability))
	return 0;
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->slowSqcifMPI))
	    return 0;
	(val)->slowSqcifMPI += 1;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->slowQcifMPI))
	    return 0;
	(val)->slowQcifMPI += 1;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->slowCifMPI))
	    return 0;
	(val)->slowCifMPI += 1;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->slowCif4MPI))
	    return 0;
	(val)->slowCif4MPI += 1;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->slowCif16MPI))
	    return 0;
	(val)->slowCif16MPI += 1;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->errorCompensation))
	return 0;
    if ((val)->o[1] & 0x20) {
	if (!ASN1Dec_H263Options(dec, &(val)->h263Options))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EnhancementOptions(EnhancementOptions *val)
{
    if (val) {
	if ((val)->o[1] & 0x20) {
	    ASN1Free_H263Options(&(val)->h263Options);
	}
    }
}

static int ASN1CALL ASN1Enc_DataProtocolCapability(ASN1encoding_t enc, DataProtocolCapability *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 10:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_DataProtocolCapability_v76wCompression(ee, &(val)->u.v76wCompression))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataProtocolCapability(ASN1decoding_t dec, DataProtocolCapability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 10:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_DataProtocolCapability_v76wCompression(dd, &(val)->u.v76wCompression))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataProtocolCapability(DataProtocolCapability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionAuthenticationAndIntegrity(ASN1encoding_t enc, EncryptionAuthenticationAndIntegrity *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_EncryptionCapability(enc, &(val)->encryptionCapability))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_AuthenticationCapability(enc, &(val)->authenticationCapability))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_IntegrityCapability(enc, &(val)->integrityCapability))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionAuthenticationAndIntegrity(ASN1decoding_t dec, EncryptionAuthenticationAndIntegrity *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_EncryptionCapability(dec, &(val)->encryptionCapability))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_AuthenticationCapability(dec, &(val)->authenticationCapability))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_IntegrityCapability(dec, &(val)->integrityCapability))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionAuthenticationAndIntegrity(EncryptionAuthenticationAndIntegrity *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_EncryptionCapability(&(val)->encryptionCapability);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_AuthenticationCapability(&(val)->authenticationCapability);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_IntegrityCapability(&(val)->integrityCapability);
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionCapability(ASN1encoding_t enc, PEncryptionCapability *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EncryptionCapability_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_EncryptionCapability_ElmFn(ASN1encoding_t enc, PEncryptionCapability val)
{
    if (!ASN1Enc_MediaEncryptionAlgorithm(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionCapability(ASN1decoding_t dec, PEncryptionCapability *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EncryptionCapability_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_EncryptionCapability_ElmFn(ASN1decoding_t dec, PEncryptionCapability val)
{
    if (!ASN1Dec_MediaEncryptionAlgorithm(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionCapability(PEncryptionCapability *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EncryptionCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EncryptionCapability_ElmFn(PEncryptionCapability val)
{
    if (val) {
	ASN1Free_MediaEncryptionAlgorithm(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UserInputCapability(ASN1encoding_t enc, UserInputCapability *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_UserInputCapability_nonStandard(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputCapability(ASN1decoding_t dec, UserInputCapability *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_UserInputCapability_nonStandard(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputCapability(UserInputCapability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_UserInputCapability_nonStandard(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H223LogicalChannelParameters(ASN1encoding_t enc, H223LogicalChannelParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223LogicalChannelParameters_adaptationLayerType(enc, &(val)->adaptationLayerType))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->segmentableFlag))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223LogicalChannelParameters(ASN1decoding_t dec, H223LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223LogicalChannelParameters_adaptationLayerType(dec, &(val)->adaptationLayerType))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->segmentableFlag))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223LogicalChannelParameters(H223LogicalChannelParameters *val)
{
    if (val) {
	ASN1Free_H223LogicalChannelParameters_adaptationLayerType(&(val)->adaptationLayerType);
    }
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters(ASN1encoding_t enc, V76LogicalChannelParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_V76HDLCParameters(enc, &(val)->hdlcParameters))
	return 0;
    if (!ASN1Enc_V76LogicalChannelParameters_suspendResume(enc, &(val)->suspendResume))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->uIH))
	return 0;
    if (!ASN1Enc_V76LogicalChannelParameters_mode(enc, &(val)->mode))
	return 0;
    if (!ASN1Enc_V75Parameters(enc, &(val)->v75Parameters))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters(ASN1decoding_t dec, V76LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_V76HDLCParameters(dec, &(val)->hdlcParameters))
	return 0;
    if (!ASN1Dec_V76LogicalChannelParameters_suspendResume(dec, &(val)->suspendResume))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->uIH))
	return 0;
    if (!ASN1Dec_V76LogicalChannelParameters_mode(dec, &(val)->mode))
	return 0;
    if (!ASN1Dec_V75Parameters(dec, &(val)->v75Parameters))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RTPPayloadType(ASN1encoding_t enc, RTPPayloadType *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_RTPPayloadType_payloadDescriptor(enc, &(val)->payloadDescriptor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 7, (val)->payloadType))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPPayloadType(ASN1decoding_t dec, RTPPayloadType *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_RTPPayloadType_payloadDescriptor(dec, &(val)->payloadDescriptor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 7, &(val)->payloadType))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPPayloadType(RTPPayloadType *val)
{
    if (val) {
	ASN1Free_RTPPayloadType_payloadDescriptor(&(val)->payloadDescriptor);
    }
}

static int ASN1CALL ASN1Enc_H245TransportAddress(ASN1encoding_t enc, H245TransportAddress *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_UnicastAddress(enc, &(val)->u.unicastAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MulticastAddress(enc, &(val)->u.multicastAddress))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H245TransportAddress(ASN1decoding_t dec, H245TransportAddress *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_UnicastAddress(dec, &(val)->u.unicastAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MulticastAddress(dec, &(val)->u.multicastAddress))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H245TransportAddress(H245TransportAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_UnicastAddress(&(val)->u.unicastAddress);
	    break;
	case 2:
	    ASN1Free_MulticastAddress(&(val)->u.multicastAddress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters(ASN1encoding_t enc, H2250LogicalChannelAckParameters *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 5, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H2250LogicalChannelAckParameters_nonStandard(enc, &(val)->nonStandard))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 8, (val)->sessionID - 1))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaChannel))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaControlChannel))
	    return 0;
    }
    if (o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->dynamicRTPPayloadType - 96))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1PEREncBoolean(ee, (val)->flowControlToZero))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->portNumber))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters(ASN1decoding_t dec, H2250LogicalChannelAckParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H2250LogicalChannelAckParameters_nonStandard(dec, &(val)->nonStandard))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 8, &(val)->sessionID))
	    return 0;
	(val)->sessionID += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->dynamicRTPPayloadType))
	    return 0;
	(val)->dynamicRTPPayloadType += 96;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->flowControlToZero))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->portNumber))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters(H2250LogicalChannelAckParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H2250LogicalChannelAckParameters_nonStandard(&(val)->nonStandard);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_H245TransportAddress(&(val)->mediaChannel);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_H245TransportAddress(&(val)->mediaControlChannel);
	}
    }
}

static int ASN1CALL ASN1Enc_H223ModeParameters(ASN1encoding_t enc, H223ModeParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223ModeParameters_adaptationLayerType(enc, &(val)->adaptationLayerType))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->segmentableFlag))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223ModeParameters(ASN1decoding_t dec, H223ModeParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223ModeParameters_adaptationLayerType(dec, &(val)->adaptationLayerType))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->segmentableFlag))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223ModeParameters(H223ModeParameters *val)
{
    if (val) {
	ASN1Free_H223ModeParameters_adaptationLayerType(&(val)->adaptationLayerType);
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncodingMode(ASN1encoding_t enc, RedundancyEncodingMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_RedundancyEncodingMethod(enc, &(val)->redundancyEncodingMethod))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_RedundancyEncodingMode_secondaryEncoding(enc, &(val)->secondaryEncoding))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncodingMode(ASN1decoding_t dec, RedundancyEncodingMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_RedundancyEncodingMethod(dec, &(val)->redundancyEncodingMethod))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_RedundancyEncodingMode_secondaryEncoding(dec, &(val)->secondaryEncoding))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncodingMode(RedundancyEncodingMode *val)
{
    if (val) {
	ASN1Free_RedundancyEncodingMethod(&(val)->redundancyEncodingMethod);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_RedundancyEncodingMode_secondaryEncoding(&(val)->secondaryEncoding);
	}
    }
}

static int ASN1CALL ASN1Enc_VideoMode(ASN1encoding_t enc, VideoMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H261VideoMode(enc, &(val)->u.h261VideoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H262VideoMode(enc, &(val)->u.h262VideoMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_H263VideoMode(enc, &(val)->u.h263VideoMode))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_IS11172VideoMode(enc, &(val)->u.is11172VideoMode))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VideoMode(ASN1decoding_t dec, VideoMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H261VideoMode(dec, &(val)->u.h261VideoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H262VideoMode(dec, &(val)->u.h262VideoMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_H263VideoMode(dec, &(val)->u.h263VideoMode))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_IS11172VideoMode(dec, &(val)->u.is11172VideoMode))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VideoMode(VideoMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 4:
	    ASN1Free_H263VideoMode(&(val)->u.h263VideoMode);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionCommand(ASN1encoding_t enc, EncryptionCommand *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->u.encryptionSE))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_EncryptionCommand_encryptionAlgorithmID(enc, &(val)->u.encryptionAlgorithmID))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionCommand(ASN1decoding_t dec, EncryptionCommand *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->u.encryptionSE))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_EncryptionCommand_encryptionAlgorithmID(dec, &(val)->u.encryptionAlgorithmID))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionCommand(EncryptionCommand *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1octetstring_free(&(val)->u.encryptionSE);
	    break;
	case 3:
	    ASN1Free_EncryptionCommand_encryptionAlgorithmID(&(val)->u.encryptionAlgorithmID);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand(ASN1encoding_t enc, MiscellaneousCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_MiscellaneousCommand_type(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand(ASN1decoding_t dec, MiscellaneousCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber))
	return 0;
    (val)->logicalChannelNumber += 1;
    if (!ASN1Dec_MiscellaneousCommand_type(dec, &(val)->type))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MiscellaneousCommand(MiscellaneousCommand *val)
{
    if (val) {
	ASN1Free_MiscellaneousCommand_type(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousIndication(ASN1encoding_t enc, MiscellaneousIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_MiscellaneousIndication_type(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousIndication(ASN1decoding_t dec, MiscellaneousIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber))
	return 0;
    (val)->logicalChannelNumber += 1;
    if (!ASN1Dec_MiscellaneousIndication_type(dec, &(val)->type))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MiscellaneousIndication(MiscellaneousIndication *val)
{
    if (val) {
	ASN1Free_MiscellaneousIndication_type(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_MCLocationIndication(ASN1encoding_t enc, MCLocationIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H245TransportAddress(enc, &(val)->signalAddress))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MCLocationIndication(ASN1decoding_t dec, MCLocationIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H245TransportAddress(dec, &(val)->signalAddress))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MCLocationIndication(MCLocationIndication *val)
{
    if (val) {
	ASN1Free_H245TransportAddress(&(val)->signalAddress);
    }
}

static int ASN1CALL ASN1Enc_UserInputIndication(ASN1encoding_t enc, UserInputIndication *val)
{
    ASN1uint32_t t;
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	t = lstrlenA((val)->u.alphanumeric);
	if (!ASN1PEREncFragmentedCharString(enc, t, (val)->u.alphanumeric, 8))
	    return 0;
	break;
    case 3:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_UserInputIndication_userInputSupportIndication(ee, &(val)->u.userInputSupportIndication))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_UserInputIndication_signal(ee, &(val)->u.signal))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 5:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_UserInputIndication_signalUpdate(ee, &(val)->u.signalUpdate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication(ASN1decoding_t dec, UserInputIndication *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecFragmentedZeroCharString(dec, &(val)->u.alphanumeric, 8))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_UserInputIndication_userInputSupportIndication(dd, &(val)->u.userInputSupportIndication))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_UserInputIndication_signal(dd, &(val)->u.signal))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 5:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_UserInputIndication_signalUpdate(dd, &(val)->u.signalUpdate))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputIndication(UserInputIndication *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1ztcharstring_free((val)->u.alphanumeric);
	    break;
	case 3:
	    ASN1Free_UserInputIndication_userInputSupportIndication(&(val)->u.userInputSupportIndication);
	    break;
	case 4:
	    ASN1Free_UserInputIndication_signal(&(val)->u.signal);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DataApplicationCapability_application_nlpid(ASN1encoding_t enc, DataApplicationCapability_application_nlpid *val)
{
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->nlpidProtocol))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->nlpidData))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataApplicationCapability_application_nlpid(ASN1decoding_t dec, DataApplicationCapability_application_nlpid *val)
{
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->nlpidProtocol))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->nlpidData))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DataApplicationCapability_application_nlpid(DataApplicationCapability_application_nlpid *val)
{
    if (val) {
	ASN1Free_DataProtocolCapability(&(val)->nlpidProtocol);
	ASN1octetstring_free(&(val)->nlpidData);
    }
}

static int ASN1CALL ASN1Enc_DataApplicationCapability_application_t84(ASN1encoding_t enc, DataApplicationCapability_application_t84 *val)
{
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->t84Protocol))
	return 0;
    if (!ASN1Enc_T84Profile(enc, &(val)->t84Profile))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataApplicationCapability_application_t84(ASN1decoding_t dec, DataApplicationCapability_application_t84 *val)
{
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->t84Protocol))
	return 0;
    if (!ASN1Dec_T84Profile(dec, &(val)->t84Profile))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DataApplicationCapability_application_t84(DataApplicationCapability_application_t84 *val)
{
    if (val) {
	ASN1Free_DataProtocolCapability(&(val)->t84Protocol);
    }
}

static int ASN1CALL ASN1Enc_DataMode_application_nlpid(ASN1encoding_t enc, DataMode_application_nlpid *val)
{
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->nlpidProtocol))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->nlpidData))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataMode_application_nlpid(ASN1decoding_t dec, DataMode_application_nlpid *val)
{
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->nlpidProtocol))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->nlpidData))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DataMode_application_nlpid(DataMode_application_nlpid *val)
{
    if (val) {
	ASN1Free_DataProtocolCapability(&(val)->nlpidProtocol);
	ASN1octetstring_free(&(val)->nlpidData);
    }
}

static int ASN1CALL ASN1Enc_DataMode_application(ASN1encoding_t enc, DataMode_application *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t120))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.dsm_cc))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.userData))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t84))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t434))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.h224))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_DataMode_application_nlpid(enc, &(val)->u.nlpid))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.h222DataPartitioning))
	    return 0;
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_DataProtocolCapability(ee, &(val)->u.t30fax))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_DataProtocolCapability(ee, &(val)->u.t140))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataMode_application(ASN1decoding_t dec, DataMode_application *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t120))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.dsm_cc))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.userData))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t84))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t434))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.h224))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_DataMode_application_nlpid(dec, &(val)->u.nlpid))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.h222DataPartitioning))
	    return 0;
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_DataProtocolCapability(dd, &(val)->u.t30fax))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_DataProtocolCapability(dd, &(val)->u.t140))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataMode_application(DataMode_application *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_DataProtocolCapability(&(val)->u.t120);
	    break;
	case 3:
	    ASN1Free_DataProtocolCapability(&(val)->u.dsm_cc);
	    break;
	case 4:
	    ASN1Free_DataProtocolCapability(&(val)->u.userData);
	    break;
	case 5:
	    ASN1Free_DataProtocolCapability(&(val)->u.t84);
	    break;
	case 6:
	    ASN1Free_DataProtocolCapability(&(val)->u.t434);
	    break;
	case 7:
	    ASN1Free_DataProtocolCapability(&(val)->u.h224);
	    break;
	case 8:
	    ASN1Free_DataMode_application_nlpid(&(val)->u.nlpid);
	    break;
	case 10:
	    ASN1Free_DataProtocolCapability(&(val)->u.h222DataPartitioning);
	    break;
	case 11:
	    ASN1Free_DataProtocolCapability(&(val)->u.t30fax);
	    break;
	case 12:
	    ASN1Free_DataProtocolCapability(&(val)->u.t140);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_forwardMultiplexAckParameters(ASN1encoding_t enc, OpenLogicalChannelAck_forwardMultiplexAckParameters *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H2250LogicalChannelAckParameters(enc, &(val)->u.h2250LogicalChannelAckParameters))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_forwardMultiplexAckParameters(ASN1decoding_t dec, OpenLogicalChannelAck_forwardMultiplexAckParameters *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H2250LogicalChannelAckParameters(dec, &(val)->u.h2250LogicalChannelAckParameters))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannelAck_forwardMultiplexAckParameters(OpenLogicalChannelAck_forwardMultiplexAckParameters *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H2250LogicalChannelAckParameters(&(val)->u.h2250LogicalChannelAckParameters);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_mediaPacketization(ASN1encoding_t enc, H2250LogicalChannelParameters_mediaPacketization *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_RTPPayloadType(ee, &(val)->u.rtpPayloadType))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_mediaPacketization(ASN1decoding_t dec, H2250LogicalChannelParameters_mediaPacketization *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_RTPPayloadType(dd, &(val)->u.rtpPayloadType))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_mediaPacketization(H2250LogicalChannelParameters_mediaPacketization *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_RTPPayloadType(&(val)->u.rtpPayloadType);
	    break;
	}
    }
}

static ASN1stringtableentry_t NetworkAccessParameters_networkAddress_e164Address_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t NetworkAccessParameters_networkAddress_e164Address_StringTable = {
    4, NetworkAccessParameters_networkAddress_e164Address_StringTableEntries
};

static int ASN1CALL ASN1Enc_NetworkAccessParameters_networkAddress(ASN1encoding_t enc, NetworkAccessParameters_networkAddress *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_Q2931Address(enc, &(val)->u.q2931Address))
	    return 0;
	break;
    case 2:
	t = lstrlenA((val)->u.e164Address);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.e164Address, 4, &NetworkAccessParameters_networkAddress_e164Address_StringTable))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->u.localAreaAddress))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAccessParameters_networkAddress(ASN1decoding_t dec, NetworkAccessParameters_networkAddress *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_Q2931Address(dec, &(val)->u.q2931Address))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);

        // SECURITY BUG: 782696
        if ( l >= sizeof( (val)->u.e164Address ) )
        {
            ASN1DecSetError(dec, ASN1_ERR_LARGE);
            return 0;
        }

	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.e164Address, 4, &NetworkAccessParameters_networkAddress_e164Address_StringTable))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->u.localAreaAddress))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NetworkAccessParameters_networkAddress(NetworkAccessParameters_networkAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_Q2931Address(&(val)->u.q2931Address);
	    break;
	case 2:
	    break;
	case 3:
	    ASN1Free_H245TransportAddress(&(val)->u.localAreaAddress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DataApplicationCapability_application(ASN1encoding_t enc, DataApplicationCapability_application *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t120))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.dsm_cc))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.userData))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_DataApplicationCapability_application_t84(enc, &(val)->u.t84))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t434))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.h224))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_DataApplicationCapability_application_nlpid(enc, &(val)->u.nlpid))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.h222DataPartitioning))
	    return 0;
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_DataProtocolCapability(ee, &(val)->u.t30fax))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_DataProtocolCapability(ee, &(val)->u.t140))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataApplicationCapability_application(ASN1decoding_t dec, DataApplicationCapability_application *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t120))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.dsm_cc))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.userData))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_DataApplicationCapability_application_t84(dec, &(val)->u.t84))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t434))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.h224))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_DataApplicationCapability_application_nlpid(dec, &(val)->u.nlpid))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.h222DataPartitioning))
	    return 0;
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_DataProtocolCapability(dd, &(val)->u.t30fax))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_DataProtocolCapability(dd, &(val)->u.t140))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataApplicationCapability_application(DataApplicationCapability_application *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_DataProtocolCapability(&(val)->u.t120);
	    break;
	case 3:
	    ASN1Free_DataProtocolCapability(&(val)->u.dsm_cc);
	    break;
	case 4:
	    ASN1Free_DataProtocolCapability(&(val)->u.userData);
	    break;
	case 5:
	    ASN1Free_DataApplicationCapability_application_t84(&(val)->u.t84);
	    break;
	case 6:
	    ASN1Free_DataProtocolCapability(&(val)->u.t434);
	    break;
	case 7:
	    ASN1Free_DataProtocolCapability(&(val)->u.h224);
	    break;
	case 8:
	    ASN1Free_DataApplicationCapability_application_nlpid(&(val)->u.nlpid);
	    break;
	case 10:
	    ASN1Free_DataProtocolCapability(&(val)->u.h222DataPartitioning);
	    break;
	case 11:
	    ASN1Free_DataProtocolCapability(&(val)->u.t30fax);
	    break;
	case 12:
	    ASN1Free_DataProtocolCapability(&(val)->u.t140);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_spatialEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_spatialEnhancement *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EnhancementLayerInfo_spatialEnhancement_ElmFn, 1, 14, 4);
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_spatialEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_spatialEnhancement val)
{
    if (!ASN1Enc_EnhancementOptions(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_spatialEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_spatialEnhancement *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EnhancementLayerInfo_spatialEnhancement_ElmFn, sizeof(**val), 1, 14, 4);
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_spatialEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_spatialEnhancement val)
{
    if (!ASN1Dec_EnhancementOptions(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_spatialEnhancement(PEnhancementLayerInfo_spatialEnhancement *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EnhancementLayerInfo_spatialEnhancement_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_spatialEnhancement_ElmFn(PEnhancementLayerInfo_spatialEnhancement val)
{
    if (val) {
	ASN1Free_EnhancementOptions(&val->value);
    }
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_snrEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_snrEnhancement *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EnhancementLayerInfo_snrEnhancement_ElmFn, 1, 14, 4);
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_snrEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_snrEnhancement val)
{
    if (!ASN1Enc_EnhancementOptions(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_snrEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_snrEnhancement *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EnhancementLayerInfo_snrEnhancement_ElmFn, sizeof(**val), 1, 14, 4);
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_snrEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_snrEnhancement val)
{
    if (!ASN1Dec_EnhancementOptions(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_snrEnhancement(PEnhancementLayerInfo_snrEnhancement *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EnhancementLayerInfo_snrEnhancement_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_snrEnhancement_ElmFn(PEnhancementLayerInfo_snrEnhancement val)
{
    if (val) {
	ASN1Free_EnhancementOptions(&val->value);
    }
}

static int ASN1CALL ASN1Enc_MediaPacketizationCapability_rtpPayloadType(ASN1encoding_t enc, MediaPacketizationCapability_rtpPayloadType *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_RTPPayloadType(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaPacketizationCapability_rtpPayloadType(ASN1decoding_t dec, MediaPacketizationCapability_rtpPayloadType *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_RTPPayloadType(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MediaPacketizationCapability_rtpPayloadType(MediaPacketizationCapability_rtpPayloadType *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_RTPPayloadType(&(val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_H2250Capability_redundancyEncodingCapability(ASN1encoding_t enc, PH2250Capability_redundancyEncodingCapability *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H2250Capability_redundancyEncodingCapability_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_H2250Capability_redundancyEncodingCapability_ElmFn(ASN1encoding_t enc, PH2250Capability_redundancyEncodingCapability val)
{
    if (!ASN1Enc_RedundancyEncodingCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250Capability_redundancyEncodingCapability(ASN1decoding_t dec, PH2250Capability_redundancyEncodingCapability *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H2250Capability_redundancyEncodingCapability_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_H2250Capability_redundancyEncodingCapability_ElmFn(ASN1decoding_t dec, PH2250Capability_redundancyEncodingCapability val)
{
    if (!ASN1Dec_RedundancyEncodingCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H2250Capability_redundancyEncodingCapability(PH2250Capability_redundancyEncodingCapability *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H2250Capability_redundancyEncodingCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H2250Capability_redundancyEncodingCapability_ElmFn(PH2250Capability_redundancyEncodingCapability val)
{
    if (val) {
	ASN1Free_RedundancyEncodingCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CommandMessage(ASN1encoding_t enc, CommandMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MaintenanceLoopOffCommand(enc, &(val)->u.maintenanceLoopOffCommand))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_SendTerminalCapabilitySet(enc, &(val)->u.sendTerminalCapabilitySet))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_EncryptionCommand(enc, &(val)->u.encryptionCommand))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_FlowControlCommand(enc, &(val)->u.flowControlCommand))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_EndSessionCommand(enc, &(val)->u.endSessionCommand))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_MiscellaneousCommand(enc, &(val)->u.miscellaneousCommand))
	    return 0;
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_CommunicationModeCommand(ee, &(val)->u.communicationModeCommand))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceCommand(ee, &(val)->u.conferenceCommand))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 10:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223MultiplexReconfiguration(ee, &(val)->u.h223MultiplexReconfiguration))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CommandMessage(ASN1decoding_t dec, CommandMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MaintenanceLoopOffCommand(dec, &(val)->u.maintenanceLoopOffCommand))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_SendTerminalCapabilitySet(dec, &(val)->u.sendTerminalCapabilitySet))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_EncryptionCommand(dec, &(val)->u.encryptionCommand))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_FlowControlCommand(dec, &(val)->u.flowControlCommand))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_EndSessionCommand(dec, &(val)->u.endSessionCommand))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_MiscellaneousCommand(dec, &(val)->u.miscellaneousCommand))
	    return 0;
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_CommunicationModeCommand(dd, &(val)->u.communicationModeCommand))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceCommand(dd, &(val)->u.conferenceCommand))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 10:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H223MultiplexReconfiguration(dd, &(val)->u.h223MultiplexReconfiguration))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommandMessage(CommandMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1Free_SendTerminalCapabilitySet(&(val)->u.sendTerminalCapabilitySet);
	    break;
	case 4:
	    ASN1Free_EncryptionCommand(&(val)->u.encryptionCommand);
	    break;
	case 6:
	    ASN1Free_EndSessionCommand(&(val)->u.endSessionCommand);
	    break;
	case 7:
	    ASN1Free_MiscellaneousCommand(&(val)->u.miscellaneousCommand);
	    break;
	case 8:
	    ASN1Free_CommunicationModeCommand(&(val)->u.communicationModeCommand);
	    break;
	case 9:
	    ASN1Free_ConferenceCommand(&(val)->u.conferenceCommand);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H235SecurityCapability(ASN1encoding_t enc, H235SecurityCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_EncryptionAuthenticationAndIntegrity(enc, &(val)->encryptionAuthenticationAndIntegrity))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->mediaCapability - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H235SecurityCapability(ASN1decoding_t dec, H235SecurityCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_EncryptionAuthenticationAndIntegrity(dec, &(val)->encryptionAuthenticationAndIntegrity))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->mediaCapability))
	return 0;
    (val)->mediaCapability += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H235SecurityCapability(H235SecurityCapability *val)
{
    if (val) {
	ASN1Free_EncryptionAuthenticationAndIntegrity(&(val)->encryptionAuthenticationAndIntegrity);
    }
}

static int ASN1CALL ASN1Enc_MediaPacketizationCapability(ASN1encoding_t enc, MediaPacketizationCapability *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h261aVideoPacketization))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, (val)->o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1Enc_MediaPacketizationCapability_rtpPayloadType(ee, &(val)->rtpPayloadType))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaPacketizationCapability(ASN1decoding_t dec, MediaPacketizationCapability *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h261aVideoPacketization))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_MediaPacketizationCapability_rtpPayloadType(dd, &(val)->rtpPayloadType))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_MediaPacketizationCapability(MediaPacketizationCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MediaPacketizationCapability_rtpPayloadType(&(val)->rtpPayloadType);
	}
    }
}

static int ASN1CALL ASN1Enc_VideoCapability(ASN1encoding_t enc, VideoCapability *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H261VideoCapability(enc, &(val)->u.h261VideoCapability))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H262VideoCapability(enc, &(val)->u.h262VideoCapability))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_H263VideoCapability(enc, &(val)->u.h263VideoCapability))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_IS11172VideoCapability(enc, &(val)->u.is11172VideoCapability))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VideoCapability(ASN1decoding_t dec, VideoCapability *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H261VideoCapability(dec, &(val)->u.h261VideoCapability))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H262VideoCapability(dec, &(val)->u.h262VideoCapability))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_H263VideoCapability(dec, &(val)->u.h263VideoCapability))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_IS11172VideoCapability(dec, &(val)->u.is11172VideoCapability))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VideoCapability(VideoCapability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 4:
	    ASN1Free_H263VideoCapability(&(val)->u.h263VideoCapability);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BEnhancementParameters(ASN1encoding_t enc, BEnhancementParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_EnhancementOptions(enc, &(val)->enhancementOptions))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->numberOfBPictures - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BEnhancementParameters(ASN1decoding_t dec, BEnhancementParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_EnhancementOptions(dec, &(val)->enhancementOptions))
	return 0;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->numberOfBPictures))
	return 0;
    (val)->numberOfBPictures += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BEnhancementParameters(BEnhancementParameters *val)
{
    if (val) {
	ASN1Free_EnhancementOptions(&(val)->enhancementOptions);
    }
}

static int ASN1CALL ASN1Enc_DataApplicationCapability(ASN1encoding_t enc, DataApplicationCapability *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_DataApplicationCapability_application(enc, &(val)->application))
	return 0;
    l = ASN1uint32_uoctets((val)->maxBitRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->maxBitRate))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataApplicationCapability(ASN1decoding_t dec, DataApplicationCapability *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_DataApplicationCapability_application(dec, &(val)->application))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->maxBitRate))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataApplicationCapability(DataApplicationCapability *val)
{
    if (val) {
	ASN1Free_DataApplicationCapability_application(&(val)->application);
    }
}

static int ASN1CALL ASN1Enc_NetworkAccessParameters(ASN1encoding_t enc, NetworkAccessParameters *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NetworkAccessParameters_distribution(enc, &(val)->distribution))
	    return 0;
    }
    if (!ASN1Enc_NetworkAccessParameters_networkAddress(enc, &(val)->networkAddress))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->associateConference))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->externalReference, 1, 255, 8))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_NetworkAccessParameters_t120SetupProcedure(ee, &(val)->t120SetupProcedure))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAccessParameters(ASN1decoding_t dec, NetworkAccessParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NetworkAccessParameters_distribution(dec, &(val)->distribution))
	    return 0;
    }
    if (!ASN1Dec_NetworkAccessParameters_networkAddress(dec, &(val)->networkAddress))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->associateConference))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->externalReference, 1, 255, 8))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_NetworkAccessParameters_t120SetupProcedure(dd, &(val)->t120SetupProcedure))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_NetworkAccessParameters(NetworkAccessParameters *val)
{
    if (val) {
	ASN1Free_NetworkAccessParameters_networkAddress(&(val)->networkAddress);
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_H2250ModeParameters(ASN1encoding_t enc, H2250ModeParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_RedundancyEncodingMode(enc, &(val)->redundancyEncodingMode))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250ModeParameters(ASN1decoding_t dec, H2250ModeParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_RedundancyEncodingMode(dec, &(val)->redundancyEncodingMode))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250ModeParameters(H2250ModeParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_RedundancyEncodingMode(&(val)->redundancyEncodingMode);
	}
    }
}

static int ASN1CALL ASN1Enc_DataMode(ASN1encoding_t enc, DataMode *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_DataMode_application(enc, &(val)->application))
	return 0;
    l = ASN1uint32_uoctets((val)->bitRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bitRate))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataMode(ASN1decoding_t dec, DataMode *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_DataMode_application(dec, &(val)->application))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bitRate))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataMode(DataMode *val)
{
    if (val) {
	ASN1Free_DataMode_application(&(val)->application);
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_dataType(ASN1encoding_t enc, CommunicationModeTableEntry_dataType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.videoData))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.audioData))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.data))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_dataType(ASN1decoding_t dec, CommunicationModeTableEntry_dataType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.videoData))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.audioData))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.data))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeTableEntry_dataType(CommunicationModeTableEntry_dataType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_VideoCapability(&(val)->u.videoData);
	    break;
	case 2:
	    ASN1Free_AudioCapability(&(val)->u.audioData);
	    break;
	case 3:
	    ASN1Free_DataApplicationCapability(&(val)->u.data);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H235Mode_mediaMode(ASN1encoding_t enc, H235Mode_mediaMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_VideoMode(enc, &(val)->u.videoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_AudioMode(enc, &(val)->u.audioMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_DataMode(enc, &(val)->u.dataMode))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H235Mode_mediaMode(ASN1decoding_t dec, H235Mode_mediaMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_VideoMode(dec, &(val)->u.videoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_AudioMode(dec, &(val)->u.audioMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_DataMode(dec, &(val)->u.dataMode))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H235Mode_mediaMode(H235Mode_mediaMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_VideoMode(&(val)->u.videoMode);
	    break;
	case 3:
	    ASN1Free_AudioMode(&(val)->u.audioMode);
	    break;
	case 4:
	    ASN1Free_DataMode(&(val)->u.dataMode);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H235Media_mediaType(ASN1encoding_t enc, H235Media_mediaType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.videoData))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.audioData))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.data))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H235Media_mediaType(ASN1decoding_t dec, H235Media_mediaType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.videoData))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.audioData))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.data))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H235Media_mediaType(H235Media_mediaType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_VideoCapability(&(val)->u.videoData);
	    break;
	case 3:
	    ASN1Free_AudioCapability(&(val)->u.audioData);
	    break;
	case 4:
	    ASN1Free_DataApplicationCapability(&(val)->u.data);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_bPictureEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_bPictureEnhancement *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EnhancementLayerInfo_bPictureEnhancement_ElmFn, 1, 14, 4);
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_bPictureEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_bPictureEnhancement val)
{
    if (!ASN1Enc_BEnhancementParameters(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_bPictureEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_bPictureEnhancement *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EnhancementLayerInfo_bPictureEnhancement_ElmFn, sizeof(**val), 1, 14, 4);
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_bPictureEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_bPictureEnhancement val)
{
    if (!ASN1Dec_BEnhancementParameters(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_bPictureEnhancement(PEnhancementLayerInfo_bPictureEnhancement *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EnhancementLayerInfo_bPictureEnhancement_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_bPictureEnhancement_ElmFn(PEnhancementLayerInfo_bPictureEnhancement val)
{
    if (val) {
	ASN1Free_BEnhancementParameters(&val->value);
    }
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData(ASN1encoding_t enc, PMediaDistributionCapability_distributedData *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_MediaDistributionCapability_distributedData_ElmFn);
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_distributedData val)
{
    if (!ASN1Enc_DataApplicationCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData(ASN1decoding_t dec, PMediaDistributionCapability_distributedData *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_MediaDistributionCapability_distributedData_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_distributedData val)
{
    if (!ASN1Dec_DataApplicationCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData(PMediaDistributionCapability_distributedData *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_MediaDistributionCapability_distributedData_ElmFn);
    }
}

static void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData_ElmFn(PMediaDistributionCapability_distributedData val)
{
    if (val) {
	ASN1Free_DataApplicationCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn);
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData val)
{
    if (!ASN1Enc_DataApplicationCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData val)
{
    if (!ASN1Dec_DataApplicationCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData(PMediaDistributionCapability_centralizedData *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_MediaDistributionCapability_centralizedData_ElmFn);
    }
}

static void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData_ElmFn(PMediaDistributionCapability_centralizedData val)
{
    if (val) {
	ASN1Free_DataApplicationCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Capability(ASN1encoding_t enc, Capability *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 12))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.receiveVideoCapability))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.transmitVideoCapability))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.receiveAndTransmitVideoCapability))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.receiveAudioCapability))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.transmitAudioCapability))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.receiveAndTransmitAudioCapability))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.receiveDataApplicationCapability))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.transmitDataApplicationCapability))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.receiveAndTransmitDataApplicationCapability))
	    return 0;
	break;
    case 11:
	if (!ASN1PEREncBoolean(enc, (val)->u.h233EncryptionTransmitCapability))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_Capability_h233EncryptionReceiveCapability(enc, &(val)->u.h233EncryptionReceiveCapability))
	    return 0;
	break;
    case 13:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceCapability(ee, &(val)->u.conferenceCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 14:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H235SecurityCapability(ee, &(val)->u.h235SecurityCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 8, (val)->u.maxPendingReplacementFor))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_UserInputCapability(ee, &(val)->u.receiveUserInputCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 17:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_UserInputCapability(ee, &(val)->u.transmitUserInputCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 18:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_UserInputCapability(ee, &(val)->u.receiveAndTransmitUserInputCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Capability(ASN1decoding_t dec, Capability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 12))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.receiveVideoCapability))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.transmitVideoCapability))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.receiveAndTransmitVideoCapability))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.receiveAudioCapability))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.transmitAudioCapability))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.receiveAndTransmitAudioCapability))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.receiveDataApplicationCapability))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.transmitDataApplicationCapability))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.receiveAndTransmitDataApplicationCapability))
	    return 0;
	break;
    case 11:
	if (!ASN1PERDecBoolean(dec, &(val)->u.h233EncryptionTransmitCapability))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_Capability_h233EncryptionReceiveCapability(dec, &(val)->u.h233EncryptionReceiveCapability))
	    return 0;
	break;
    case 13:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceCapability(dd, &(val)->u.conferenceCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 14:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H235SecurityCapability(dd, &(val)->u.h235SecurityCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU16Val(dd, 8, &(val)->u.maxPendingReplacementFor))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_UserInputCapability(dd, &(val)->u.receiveUserInputCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 17:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_UserInputCapability(dd, &(val)->u.transmitUserInputCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 18:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_UserInputCapability(dd, &(val)->u.receiveAndTransmitUserInputCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Capability(Capability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_VideoCapability(&(val)->u.receiveVideoCapability);
	    break;
	case 3:
	    ASN1Free_VideoCapability(&(val)->u.transmitVideoCapability);
	    break;
	case 4:
	    ASN1Free_VideoCapability(&(val)->u.receiveAndTransmitVideoCapability);
	    break;
	case 5:
	    ASN1Free_AudioCapability(&(val)->u.receiveAudioCapability);
	    break;
	case 6:
	    ASN1Free_AudioCapability(&(val)->u.transmitAudioCapability);
	    break;
	case 7:
	    ASN1Free_AudioCapability(&(val)->u.receiveAndTransmitAudioCapability);
	    break;
	case 8:
	    ASN1Free_DataApplicationCapability(&(val)->u.receiveDataApplicationCapability);
	    break;
	case 9:
	    ASN1Free_DataApplicationCapability(&(val)->u.transmitDataApplicationCapability);
	    break;
	case 10:
	    ASN1Free_DataApplicationCapability(&(val)->u.receiveAndTransmitDataApplicationCapability);
	    break;
	case 13:
	    ASN1Free_ConferenceCapability(&(val)->u.conferenceCapability);
	    break;
	case 14:
	    ASN1Free_H235SecurityCapability(&(val)->u.h235SecurityCapability);
	    break;
	case 16:
	    ASN1Free_UserInputCapability(&(val)->u.receiveUserInputCapability);
	    break;
	case 17:
	    ASN1Free_UserInputCapability(&(val)->u.transmitUserInputCapability);
	    break;
	case 18:
	    ASN1Free_UserInputCapability(&(val)->u.receiveAndTransmitUserInputCapability);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H2250Capability(ASN1encoding_t enc, H2250Capability *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x20;
    o[0] |= 0x10;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAudioDelayJitter))
	return 0;
    if (!ASN1Enc_MultipointCapability(enc, &(val)->receiveMultipointCapability))
	return 0;
    if (!ASN1Enc_MultipointCapability(enc, &(val)->transmitMultipointCapability))
	return 0;
    if (!ASN1Enc_MultipointCapability(enc, &(val)->receiveAndTransmitMultipointCapability))
	return 0;
    if (!ASN1Enc_H2250Capability_mcCapability(enc, &(val)->mcCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->rtcpVideoControlCapability))
	return 0;
    if (!ASN1Enc_MediaPacketizationCapability(enc, &(val)->mediaPacketizationCapability))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1Enc_TransportCapability(ee, &(val)->transportCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x40) {
	    if (!ASN1Enc_H2250Capability_redundancyEncodingCapability(ee, &(val)->redundancyEncodingCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x20) {
	    if (!ASN1PEREncBoolean(ee, (val)->logicalChannelSwitchingCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x10) {
	    if (!ASN1PEREncBoolean(ee, (val)->t120DynamicPortCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250Capability(ASN1decoding_t dec, H2250Capability *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAudioDelayJitter))
	return 0;
    if (!ASN1Dec_MultipointCapability(dec, &(val)->receiveMultipointCapability))
	return 0;
    if (!ASN1Dec_MultipointCapability(dec, &(val)->transmitMultipointCapability))
	return 0;
    if (!ASN1Dec_MultipointCapability(dec, &(val)->receiveAndTransmitMultipointCapability))
	return 0;
    if (!ASN1Dec_H2250Capability_mcCapability(dec, &(val)->mcCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->rtcpVideoControlCapability))
	return 0;
    if (!ASN1Dec_MediaPacketizationCapability(dec, &(val)->mediaPacketizationCapability))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_TransportCapability(dd, &(val)->transportCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H2250Capability_redundancyEncodingCapability(dd, &(val)->redundancyEncodingCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->logicalChannelSwitchingCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->t120DynamicPortCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250Capability(H2250Capability *val)
{
    if (val) {
	ASN1Free_MultipointCapability(&(val)->receiveMultipointCapability);
	ASN1Free_MultipointCapability(&(val)->transmitMultipointCapability);
	ASN1Free_MultipointCapability(&(val)->receiveAndTransmitMultipointCapability);
	ASN1Free_MediaPacketizationCapability(&(val)->mediaPacketizationCapability);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportCapability(&(val)->transportCapability);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H2250Capability_redundancyEncodingCapability(&(val)->redundancyEncodingCapability);
	}
    }
}

static int ASN1CALL ASN1Enc_H235Media(ASN1encoding_t enc, H235Media *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_EncryptionAuthenticationAndIntegrity(enc, &(val)->encryptionAuthenticationAndIntegrity))
	return 0;
    if (!ASN1Enc_H235Media_mediaType(enc, &(val)->mediaType))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H235Media(ASN1decoding_t dec, H235Media *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_EncryptionAuthenticationAndIntegrity(dec, &(val)->encryptionAuthenticationAndIntegrity))
	return 0;
    if (!ASN1Dec_H235Media_mediaType(dec, &(val)->mediaType))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H235Media(H235Media *val)
{
    if (val) {
	ASN1Free_EncryptionAuthenticationAndIntegrity(&(val)->encryptionAuthenticationAndIntegrity);
	ASN1Free_H235Media_mediaType(&(val)->mediaType);
    }
}

static int ASN1CALL ASN1Enc_H235Mode(ASN1encoding_t enc, H235Mode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_EncryptionAuthenticationAndIntegrity(enc, &(val)->encryptionAuthenticationAndIntegrity))
	return 0;
    if (!ASN1Enc_H235Mode_mediaMode(enc, &(val)->mediaMode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H235Mode(ASN1decoding_t dec, H235Mode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_EncryptionAuthenticationAndIntegrity(dec, &(val)->encryptionAuthenticationAndIntegrity))
	return 0;
    if (!ASN1Dec_H235Mode_mediaMode(dec, &(val)->mediaMode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H235Mode(H235Mode *val)
{
    if (val) {
	ASN1Free_EncryptionAuthenticationAndIntegrity(&(val)->encryptionAuthenticationAndIntegrity);
	ASN1Free_H235Mode_mediaMode(&(val)->mediaMode);
    }
}

static int ASN1CALL ASN1Enc_ModeElement_type(ASN1encoding_t enc, ModeElement_type *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 5))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_VideoMode(enc, &(val)->u.videoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_AudioMode(enc, &(val)->u.audioMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_DataMode(enc, &(val)->u.dataMode))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_EncryptionMode(enc, &(val)->u.encryptionMode))
	    return 0;
	break;
    case 6:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H235Mode(ee, &(val)->u.h235Mode))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ModeElement_type(ASN1decoding_t dec, ModeElement_type *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 5))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_VideoMode(dec, &(val)->u.videoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_AudioMode(dec, &(val)->u.audioMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_DataMode(dec, &(val)->u.dataMode))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_EncryptionMode(dec, &(val)->u.encryptionMode))
	    return 0;
	break;
    case 6:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H235Mode(dd, &(val)->u.h235Mode))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ModeElement_type(ModeElement_type *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_VideoMode(&(val)->u.videoMode);
	    break;
	case 3:
	    ASN1Free_AudioMode(&(val)->u.audioMode);
	    break;
	case 4:
	    ASN1Free_DataMode(&(val)->u.dataMode);
	    break;
	case 5:
	    ASN1Free_EncryptionMode(&(val)->u.encryptionMode);
	    break;
	case 6:
	    ASN1Free_H235Mode(&(val)->u.h235Mode);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CapabilityTableEntry(ASN1encoding_t enc, CapabilityTableEntry *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->capabilityTableEntryNumber - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Capability(enc, &(val)->capability))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CapabilityTableEntry(ASN1decoding_t dec, CapabilityTableEntry *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->capabilityTableEntryNumber))
	return 0;
    (val)->capabilityTableEntryNumber += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_Capability(dec, &(val)->capability))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CapabilityTableEntry(CapabilityTableEntry *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Capability(&(val)->capability);
	}
    }
}

static int ASN1CALL ASN1Enc_MultiplexCapability(ASN1encoding_t enc, MultiplexCapability *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H222Capability(enc, &(val)->u.h222Capability))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H223Capability(enc, &(val)->u.h223Capability))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_V76Capability(enc, &(val)->u.v76Capability))
	    return 0;
	break;
    case 5:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250Capability(ee, &(val)->u.h2250Capability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexCapability(ASN1decoding_t dec, MultiplexCapability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H222Capability(dec, &(val)->u.h222Capability))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H223Capability(dec, &(val)->u.h223Capability))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_V76Capability(dec, &(val)->u.v76Capability))
	    return 0;
	break;
    case 5:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H2250Capability(dd, &(val)->u.h2250Capability))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexCapability(MultiplexCapability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_H222Capability(&(val)->u.h222Capability);
	    break;
	case 5:
	    ASN1Free_H2250Capability(&(val)->u.h2250Capability);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DataType(ASN1encoding_t enc, DataType *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.videoData))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.audioData))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.data))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_EncryptionMode(enc, &(val)->u.encryptionData))
	    return 0;
	break;
    case 7:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_NonStandardParameter(ee, &(val)->u.h235Control))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H235Media(ee, &(val)->u.h235Media))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataType(ASN1decoding_t dec, DataType *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.videoData))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.audioData))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.data))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_EncryptionMode(dec, &(val)->u.encryptionData))
	    return 0;
	break;
    case 7:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_NonStandardParameter(dd, &(val)->u.h235Control))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H235Media(dd, &(val)->u.h235Media))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataType(DataType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1Free_VideoCapability(&(val)->u.videoData);
	    break;
	case 4:
	    ASN1Free_AudioCapability(&(val)->u.audioData);
	    break;
	case 5:
	    ASN1Free_DataApplicationCapability(&(val)->u.data);
	    break;
	case 6:
	    ASN1Free_EncryptionMode(&(val)->u.encryptionData);
	    break;
	case 7:
	    ASN1Free_NonStandardParameter(&(val)->u.h235Control);
	    break;
	case 8:
	    ASN1Free_H235Media(&(val)->u.h235Media);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncoding(ASN1encoding_t enc, RedundancyEncoding *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_RedundancyEncodingMethod(enc, &(val)->redundancyEncodingMethod))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_DataType(enc, &(val)->secondaryEncoding))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncoding(ASN1decoding_t dec, RedundancyEncoding *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_RedundancyEncodingMethod(dec, &(val)->redundancyEncodingMethod))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_DataType(dec, &(val)->secondaryEncoding))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncoding(RedundancyEncoding *val)
{
    if (val) {
	ASN1Free_RedundancyEncodingMethod(&(val)->redundancyEncodingMethod);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_DataType(&(val)->secondaryEncoding);
	}
    }
}

static int ASN1CALL ASN1Enc_ModeElement(ASN1encoding_t enc, ModeElement *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_ModeElement_type(enc, &(val)->type))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H223ModeParameters(enc, &(val)->h223ModeParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_V76ModeParameters(ee, &(val)->v76ModeParameters))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_H2250ModeParameters(ee, &(val)->h2250ModeParameters))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ModeElement(ASN1decoding_t dec, ModeElement *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_ModeElement_type(dec, &(val)->type))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H223ModeParameters(dec, &(val)->h223ModeParameters))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_V76ModeParameters(dd, &(val)->v76ModeParameters))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H2250ModeParameters(dd, &(val)->h2250ModeParameters))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_ModeElement(ModeElement *val)
{
    if (val) {
	ASN1Free_ModeElement_type(&(val)->type);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H223ModeParameters(&(val)->h223ModeParameters);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H2250ModeParameters(&(val)->h2250ModeParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeTableEntry(ASN1encoding_t enc, CommunicationModeTableEntry *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 7, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CommunicationModeTableEntry_nonStandard(enc, &(val)->nonStandard))
	    return 0;
    }
    if (!ASN1PEREncBitVal(enc, 8, (val)->sessionID - 1))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 8, (val)->associatedSessionID - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	    return 0;
    }
    if (!ASN1PEREncBitVal(enc, 7, ((val)->sessionDescription).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->sessionDescription).length, ((val)->sessionDescription).value, 16))
	return 0;
    if (!ASN1Enc_CommunicationModeTableEntry_dataType(enc, &(val)->dataType))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBoolean(enc, (val)->mediaGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PEREncBoolean(enc, (val)->mediaControlGuaranteedDelivery))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_RedundancyEncoding(ee, &(val)->redundancyEncoding))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PEREncBitVal(ee, 8, (val)->sessionDependency - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_TerminalLabel(ee, &(val)->destination))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeTableEntry(ASN1decoding_t dec, CommunicationModeTableEntry *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CommunicationModeTableEntry_nonStandard(dec, &(val)->nonStandard))
	    return 0;
    }
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sessionID))
	return 0;
    (val)->sessionID += 1;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 8, &(val)->associatedSessionID))
	    return 0;
	(val)->associatedSessionID += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 7, &((val)->sessionDescription).length))
	return 0;
    ((val)->sessionDescription).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->sessionDescription).length, &((val)->sessionDescription).value, 16))
	return 0;
    if (!ASN1Dec_CommunicationModeTableEntry_dataType(dec, &(val)->dataType))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecBoolean(dec, &(val)->mediaGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PERDecBoolean(dec, &(val)->mediaControlGuaranteedDelivery))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RedundancyEncoding(dd, &(val)->redundancyEncoding))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecU16Val(dd, 8, &(val)->sessionDependency))
		return 0;
	    (val)->sessionDependency += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_TerminalLabel(dd, &(val)->destination))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeTableEntry(CommunicationModeTableEntry *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CommunicationModeTableEntry_nonStandard(&(val)->nonStandard);
	}
	ASN1char16string_free(&(val)->sessionDescription);
	ASN1Free_CommunicationModeTableEntry_dataType(&(val)->dataType);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_H245TransportAddress(&(val)->mediaChannel);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_H245TransportAddress(&(val)->mediaControlChannel);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_RedundancyEncoding(&(val)->redundancyEncoding);
	}
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CommunicationModeResponse_communicationModeTable_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable val)
{
    if (!ASN1Enc_CommunicationModeTableEntry(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CommunicationModeResponse_communicationModeTable_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable val)
{
    if (!ASN1Dec_CommunicationModeTableEntry(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable(PCommunicationModeResponse_communicationModeTable *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CommunicationModeResponse_communicationModeTable_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable_ElmFn(PCommunicationModeResponse_communicationModeTable val)
{
    if (val) {
	ASN1Free_CommunicationModeTableEntry(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CommunicationModeCommand_communicationModeTable_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable val)
{
    if (!ASN1Enc_CommunicationModeTableEntry(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CommunicationModeCommand_communicationModeTable_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable val)
{
    if (!ASN1Dec_CommunicationModeTableEntry(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable(PCommunicationModeCommand_communicationModeTable *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CommunicationModeCommand_communicationModeTable_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable_ElmFn(PCommunicationModeCommand_communicationModeTable val)
{
    if (val) {
	ASN1Free_CommunicationModeTableEntry(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TerminalCapabilitySet_capabilityTable_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable val)
{
    if (!ASN1Enc_CapabilityTableEntry(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TerminalCapabilitySet_capabilityTable_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable val)
{
    if (!ASN1Dec_CapabilityTableEntry(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable(PTerminalCapabilitySet_capabilityTable *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TerminalCapabilitySet_capabilityTable_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable_ElmFn(PTerminalCapabilitySet_capabilityTable val)
{
    if (val) {
	ASN1Free_CapabilityTableEntry(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySet(ASN1encoding_t enc, TerminalCapabilitySet *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MultiplexCapability(enc, &(val)->multiplexCapability))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_TerminalCapabilitySet_capabilityTable(enc, &(val)->capabilityTable))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_TerminalCapabilitySet_capabilityDescriptors(enc, &(val)->capabilityDescriptors))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySet(ASN1decoding_t dec, TerminalCapabilitySet *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_MultiplexCapability(dec, &(val)->multiplexCapability))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_TerminalCapabilitySet_capabilityTable(dec, &(val)->capabilityTable))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_TerminalCapabilitySet_capabilityDescriptors(dec, &(val)->capabilityDescriptors))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TerminalCapabilitySet(TerminalCapabilitySet *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MultiplexCapability(&(val)->multiplexCapability);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_TerminalCapabilitySet_capabilityTable(&(val)->capabilityTable);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_TerminalCapabilitySet_capabilityDescriptors(&(val)->capabilityDescriptors);
	}
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters(ASN1encoding_t enc, H2250LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 2);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 10, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H2250LogicalChannelParameters_nonStandard(enc, &(val)->nonStandard))
	    return 0;
    }
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sessionID))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 8, (val)->associatedSessionID - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncBoolean(enc, (val)->mediaGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PEREncBoolean(enc, (val)->mediaControlGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PEREncBoolean(enc, (val)->silenceSuppression))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1Enc_TerminalLabel(enc, &(val)->destination))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->dynamicRTPPayloadType - 96))
	    return 0;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1Enc_H2250LogicalChannelParameters_mediaPacketization(enc, &(val)->mediaPacketization))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 2))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[2] & 0x80) {
	    if (!ASN1Enc_TransportCapability(ee, &(val)->transportCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[2] & 0x40) {
	    if (!ASN1Enc_RedundancyEncoding(ee, &(val)->redundancyEncoding))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[2] & 0x20) {
	    if (!ASN1Enc_TerminalLabel(ee, &(val)->source))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters(ASN1decoding_t dec, H2250LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 10, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H2250LogicalChannelParameters_nonStandard(dec, &(val)->nonStandard))
	    return 0;
    }
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sessionID))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 8, &(val)->associatedSessionID))
	    return 0;
	(val)->associatedSessionID += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecBoolean(dec, &(val)->mediaGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecBoolean(dec, &(val)->mediaControlGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PERDecBoolean(dec, &(val)->silenceSuppression))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1Dec_TerminalLabel(dec, &(val)->destination))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->dynamicRTPPayloadType))
	    return 0;
	(val)->dynamicRTPPayloadType += 96;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1Dec_H2250LogicalChannelParameters_mediaPacketization(dec, &(val)->mediaPacketization))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 2, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 2))
	    return 0;
	if ((val)->o[2] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_TransportCapability(dd, &(val)->transportCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[2] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RedundancyEncoding(dd, &(val)->redundancyEncoding))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[2] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_TerminalLabel(dd, &(val)->source))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelParameters(H2250LogicalChannelParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H2250LogicalChannelParameters_nonStandard(&(val)->nonStandard);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_H245TransportAddress(&(val)->mediaChannel);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_H245TransportAddress(&(val)->mediaControlChannel);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H2250LogicalChannelParameters_mediaPacketization(&(val)->mediaPacketization);
	}
	if ((val)->o[2] & 0x80) {
	    ASN1Free_TransportCapability(&(val)->transportCapability);
	}
	if ((val)->o[2] & 0x40) {
	    ASN1Free_RedundancyEncoding(&(val)->redundancyEncoding);
	}
    }
}

static int ASN1CALL ASN1Enc_ModeDescription(ASN1encoding_t enc, ModeDescription *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_ModeElement(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ModeDescription(ASN1decoding_t dec, ModeDescription *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_ModeElement(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ModeDescription(ModeDescription *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_ModeElement(&(val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H222LogicalChannelParameters(enc, &(val)->u.h222LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H223LogicalChannelParameters(enc, &(val)->u.h223LogicalChannelParameters))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_V76LogicalChannelParameters(enc, &(val)->u.v76LogicalChannelParameters))
	    return 0;
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250LogicalChannelParameters(ee, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 5:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H222LogicalChannelParameters(dec, &(val)->u.h222LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H223LogicalChannelParameters(dec, &(val)->u.h223LogicalChannelParameters))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_V76LogicalChannelParameters(dec, &(val)->u.v76LogicalChannelParameters))
	    return 0;
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H2250LogicalChannelParameters(dd, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 5:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H222LogicalChannelParameters(&(val)->u.h222LogicalChannelParameters);
	    break;
	case 2:
	    ASN1Free_H223LogicalChannelParameters(&(val)->u.h223LogicalChannelParameters);
	    break;
	case 4:
	    ASN1Free_H2250LogicalChannelParameters(&(val)->u.h2250LogicalChannelParameters);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H223LogicalChannelParameters(enc, &(val)->u.h223LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_V76LogicalChannelParameters(enc, &(val)->u.v76LogicalChannelParameters))
	    return 0;
	break;
    case 3:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250LogicalChannelParameters(ee, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H223LogicalChannelParameters(dec, &(val)->u.h223LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_V76LogicalChannelParameters(dec, &(val)->u.v76LogicalChannelParameters))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H2250LogicalChannelParameters(dd, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H223LogicalChannelParameters(&(val)->u.h223LogicalChannelParameters);
	    break;
	case 3:
	    ASN1Free_H2250LogicalChannelParameters(&(val)->u.h2250LogicalChannelParameters);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H222LogicalChannelParameters(enc, &(val)->u.h222LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250LogicalChannelParameters(ee, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H222LogicalChannelParameters(dec, &(val)->u.h222LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H2250LogicalChannelParameters(dd, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H222LogicalChannelParameters(&(val)->u.h222LogicalChannelParameters);
	    break;
	case 2:
	    ASN1Free_H2250LogicalChannelParameters(&(val)->u.h2250LogicalChannelParameters);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RequestMode_requestedModes(ASN1encoding_t enc, PRequestMode_requestedModes *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RequestMode_requestedModes_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_RequestMode_requestedModes_ElmFn(ASN1encoding_t enc, PRequestMode_requestedModes val)
{
    if (!ASN1Enc_ModeDescription(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMode_requestedModes(ASN1decoding_t dec, PRequestMode_requestedModes *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RequestMode_requestedModes_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_RequestMode_requestedModes_ElmFn(ASN1decoding_t dec, PRequestMode_requestedModes val)
{
    if (!ASN1Dec_ModeDescription(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RequestMode_requestedModes(PRequestMode_requestedModes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RequestMode_requestedModes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RequestMode_requestedModes_ElmFn(PRequestMode_requestedModes val)
{
    if (val) {
	ASN1Free_ModeDescription(&val->value);
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannelAck_reverseLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->reverseLogicalChannelNumber - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->portNumber))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(enc, &(val)->multiplexParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->replacementFor - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannelAck_reverseLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->reverseLogicalChannelNumber))
	return 0;
    (val)->reverseLogicalChannelNumber += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->portNumber))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(dec, &(val)->multiplexParameters))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->replacementFor))
		return 0;
	    (val)->replacementFor += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters(OpenLogicalChannelAck_reverseLogicalChannelParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(&(val)->multiplexParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannel_reverseLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_DataType(enc, &(val)->dataType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(enc, &(val)->multiplexParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->reverseLogicalChannelDependency - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->replacementFor - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannel_reverseLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_DataType(dec, &(val)->dataType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(dec, &(val)->multiplexParameters))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->reverseLogicalChannelDependency))
		return 0;
	    (val)->reverseLogicalChannelDependency += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->replacementFor))
		return 0;
	    (val)->replacementFor += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters(OpenLogicalChannel_reverseLogicalChannelParameters *val)
{
    if (val) {
	ASN1Free_DataType(&(val)->dataType);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(&(val)->multiplexParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannel_forwardLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->portNumber))
	    return 0;
    }
    if (!ASN1Enc_DataType(enc, &(val)->dataType))
	return 0;
    if (!ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(enc, &(val)->multiplexParameters))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->forwardLogicalChannelDependency - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->replacementFor - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannel_forwardLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->portNumber))
	    return 0;
    }
    if (!ASN1Dec_DataType(dec, &(val)->dataType))
	return 0;
    if (!ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(dec, &(val)->multiplexParameters))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->forwardLogicalChannelDependency))
		return 0;
	    (val)->forwardLogicalChannelDependency += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->replacementFor))
		return 0;
	    (val)->replacementFor += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters(OpenLogicalChannel_forwardLogicalChannelParameters *val)
{
    if (val) {
	ASN1Free_DataType(&(val)->dataType);
	ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(&(val)->multiplexParameters);
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel(ASN1encoding_t enc, OpenLogicalChannel *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters(enc, &(val)->forwardLogicalChannelParameters))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters(enc, &(val)->reverseLogicalChannelParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_NetworkAccessParameters(ee, &(val)->separateStack))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_EncryptionSync(ee, &(val)->encryptionSync))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel(ASN1decoding_t dec, OpenLogicalChannel *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters(dec, &(val)->forwardLogicalChannelParameters))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters(dec, &(val)->reverseLogicalChannelParameters))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_NetworkAccessParameters(dd, &(val)->separateStack))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_EncryptionSync(dd, &(val)->encryptionSync))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel(OpenLogicalChannel *val)
{
    if (val) {
	ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters(&(val)->forwardLogicalChannelParameters);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters(&(val)->reverseLogicalChannelParameters);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_NetworkAccessParameters(&(val)->separateStack);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_EncryptionSync(&(val)->encryptionSync);
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelAck(ASN1encoding_t enc, OpenLogicalChannelAck *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters(enc, &(val)->reverseLogicalChannelParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_NetworkAccessParameters(ee, &(val)->separateStack))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_OpenLogicalChannelAck_forwardMultiplexAckParameters(ee, &(val)->forwardMultiplexAckParameters))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_EncryptionSync(ee, &(val)->encryptionSync))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelAck(ASN1decoding_t dec, OpenLogicalChannelAck *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters(dec, &(val)->reverseLogicalChannelParameters))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_NetworkAccessParameters(dd, &(val)->separateStack))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_OpenLogicalChannelAck_forwardMultiplexAckParameters(dd, &(val)->forwardMultiplexAckParameters))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_EncryptionSync(dd, &(val)->encryptionSync))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannelAck(OpenLogicalChannelAck *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters(&(val)->reverseLogicalChannelParameters);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_NetworkAccessParameters(&(val)->separateStack);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_OpenLogicalChannelAck_forwardMultiplexAckParameters(&(val)->forwardMultiplexAckParameters);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_EncryptionSync(&(val)->encryptionSync);
	}
    }
}

static int ASN1CALL ASN1Enc_RequestMessage(ASN1encoding_t enc, RequestMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 11))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MasterSlaveDetermination(enc, &(val)->u.masterSlaveDetermination))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_TerminalCapabilitySet(enc, &(val)->u.terminalCapabilitySet))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_OpenLogicalChannel(enc, &(val)->u.openLogicalChannel))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_CloseLogicalChannel(enc, &(val)->u.closeLogicalChannel))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_RequestChannelClose(enc, &(val)->u.requestChannelClose))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_MultiplexEntrySend(enc, &(val)->u.multiplexEntrySend))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_RequestMultiplexEntry(enc, &(val)->u.requestMultiplexEntry))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_RequestMode(enc, &(val)->u.requestMode))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_RoundTripDelayRequest(enc, &(val)->u.roundTripDelayRequest))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_MaintenanceLoopRequest(enc, &(val)->u.maintenanceLoopRequest))
	    return 0;
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_CommunicationModeRequest(ee, &(val)->u.communicationModeRequest))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 13:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceRequest(ee, &(val)->u.conferenceRequest))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMessage(ASN1decoding_t dec, RequestMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 11))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MasterSlaveDetermination(dec, &(val)->u.masterSlaveDetermination))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_TerminalCapabilitySet(dec, &(val)->u.terminalCapabilitySet))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_OpenLogicalChannel(dec, &(val)->u.openLogicalChannel))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_CloseLogicalChannel(dec, &(val)->u.closeLogicalChannel))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_RequestChannelClose(dec, &(val)->u.requestChannelClose))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_MultiplexEntrySend(dec, &(val)->u.multiplexEntrySend))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_RequestMultiplexEntry(dec, &(val)->u.requestMultiplexEntry))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_RequestMode(dec, &(val)->u.requestMode))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_RoundTripDelayRequest(dec, &(val)->u.roundTripDelayRequest))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_MaintenanceLoopRequest(dec, &(val)->u.maintenanceLoopRequest))
	    return 0;
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_CommunicationModeRequest(dd, &(val)->u.communicationModeRequest))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 13:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceRequest(dd, &(val)->u.conferenceRequest))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMessage(RequestMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1Free_TerminalCapabilitySet(&(val)->u.terminalCapabilitySet);
	    break;
	case 4:
	    ASN1Free_OpenLogicalChannel(&(val)->u.openLogicalChannel);
	    break;
	case 6:
	    ASN1Free_RequestChannelClose(&(val)->u.requestChannelClose);
	    break;
	case 7:
	    ASN1Free_MultiplexEntrySend(&(val)->u.multiplexEntrySend);
	    break;
	case 8:
	    ASN1Free_RequestMultiplexEntry(&(val)->u.requestMultiplexEntry);
	    break;
	case 9:
	    ASN1Free_RequestMode(&(val)->u.requestMode);
	    break;
	case 13:
	    ASN1Free_ConferenceRequest(&(val)->u.conferenceRequest);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ResponseMessage(ASN1encoding_t enc, ResponseMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 5, 19))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MasterSlaveDeterminationAck(enc, &(val)->u.masterSlaveDeterminationAck))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_MasterSlaveDeterminationReject(enc, &(val)->u.masterSlaveDeterminationReject))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_TerminalCapabilitySetAck(enc, &(val)->u.terminalCapabilitySetAck))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_TerminalCapabilitySetReject(enc, &(val)->u.terminalCapabilitySetReject))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_OpenLogicalChannelAck(enc, &(val)->u.openLogicalChannelAck))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_OpenLogicalChannelReject(enc, &(val)->u.openLogicalChannelReject))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_CloseLogicalChannelAck(enc, &(val)->u.closeLogicalChannelAck))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_RequestChannelCloseAck(enc, &(val)->u.requestChannelCloseAck))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_RequestChannelCloseReject(enc, &(val)->u.requestChannelCloseReject))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_MultiplexEntrySendAck(enc, &(val)->u.multiplexEntrySendAck))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_MultiplexEntrySendReject(enc, &(val)->u.multiplexEntrySendReject))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_RequestMultiplexEntryAck(enc, &(val)->u.requestMultiplexEntryAck))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_RequestMultiplexEntryReject(enc, &(val)->u.requestMultiplexEntryReject))
	    return 0;
	break;
    case 15:
	if (!ASN1Enc_RequestModeAck(enc, &(val)->u.requestModeAck))
	    return 0;
	break;
    case 16:
	if (!ASN1Enc_RequestModeReject(enc, &(val)->u.requestModeReject))
	    return 0;
	break;
    case 17:
	if (!ASN1Enc_RoundTripDelayResponse(enc, &(val)->u.roundTripDelayResponse))
	    return 0;
	break;
    case 18:
	if (!ASN1Enc_MaintenanceLoopAck(enc, &(val)->u.maintenanceLoopAck))
	    return 0;
	break;
    case 19:
	if (!ASN1Enc_MaintenanceLoopReject(enc, &(val)->u.maintenanceLoopReject))
	    return 0;
	break;
    case 20:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_CommunicationModeResponse(ee, &(val)->u.communicationModeResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 21:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse(ee, &(val)->u.conferenceResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ResponseMessage(ASN1decoding_t dec, ResponseMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 5, 19))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MasterSlaveDeterminationAck(dec, &(val)->u.masterSlaveDeterminationAck))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_MasterSlaveDeterminationReject(dec, &(val)->u.masterSlaveDeterminationReject))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_TerminalCapabilitySetAck(dec, &(val)->u.terminalCapabilitySetAck))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_TerminalCapabilitySetReject(dec, &(val)->u.terminalCapabilitySetReject))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_OpenLogicalChannelAck(dec, &(val)->u.openLogicalChannelAck))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_OpenLogicalChannelReject(dec, &(val)->u.openLogicalChannelReject))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_CloseLogicalChannelAck(dec, &(val)->u.closeLogicalChannelAck))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_RequestChannelCloseAck(dec, &(val)->u.requestChannelCloseAck))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_RequestChannelCloseReject(dec, &(val)->u.requestChannelCloseReject))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_MultiplexEntrySendAck(dec, &(val)->u.multiplexEntrySendAck))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_MultiplexEntrySendReject(dec, &(val)->u.multiplexEntrySendReject))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_RequestMultiplexEntryAck(dec, &(val)->u.requestMultiplexEntryAck))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_RequestMultiplexEntryReject(dec, &(val)->u.requestMultiplexEntryReject))
	    return 0;
	break;
    case 15:
	if (!ASN1Dec_RequestModeAck(dec, &(val)->u.requestModeAck))
	    return 0;
	break;
    case 16:
	if (!ASN1Dec_RequestModeReject(dec, &(val)->u.requestModeReject))
	    return 0;
	break;
    case 17:
	if (!ASN1Dec_RoundTripDelayResponse(dec, &(val)->u.roundTripDelayResponse))
	    return 0;
	break;
    case 18:
	if (!ASN1Dec_MaintenanceLoopAck(dec, &(val)->u.maintenanceLoopAck))
	    return 0;
	break;
    case 19:
	if (!ASN1Dec_MaintenanceLoopReject(dec, &(val)->u.maintenanceLoopReject))
	    return 0;
	break;
    case 20:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_CommunicationModeResponse(dd, &(val)->u.communicationModeResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 21:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse(dd, &(val)->u.conferenceResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ResponseMessage(ResponseMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
	    break;
	case 6:
	    ASN1Free_OpenLogicalChannelAck(&(val)->u.openLogicalChannelAck);
	    break;
	case 11:
	    ASN1Free_MultiplexEntrySendAck(&(val)->u.multiplexEntrySendAck);
	    break;
	case 12:
	    ASN1Free_MultiplexEntrySendReject(&(val)->u.multiplexEntrySendReject);
	    break;
	case 13:
	    ASN1Free_RequestMultiplexEntryAck(&(val)->u.requestMultiplexEntryAck);
	    break;
	case 14:
	    ASN1Free_RequestMultiplexEntryReject(&(val)->u.requestMultiplexEntryReject);
	    break;
	case 20:
	    ASN1Free_CommunicationModeResponse(&(val)->u.communicationModeResponse);
	    break;
	case 21:
	    ASN1Free_ConferenceResponse(&(val)->u.conferenceResponse);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_FastConnectOLC(ASN1encoding_t enc, FastConnectOLC *val)
{
    if (!ASN1Enc_OpenLogicalChannel(enc, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FastConnectOLC(ASN1decoding_t dec, FastConnectOLC *val)
{
    if (!ASN1Dec_OpenLogicalChannel(dec, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_FastConnectOLC(FastConnectOLC *val)
{
    if (val) {
	ASN1Free_OpenLogicalChannel(val);
    }
}

static int ASN1CALL ASN1Enc_FunctionNotUnderstood(ASN1encoding_t enc, FunctionNotUnderstood *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_RequestMessage(enc, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ResponseMessage(enc, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_CommandMessage(enc, &(val)->u.command))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FunctionNotUnderstood(ASN1decoding_t dec, FunctionNotUnderstood *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_RequestMessage(dec, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ResponseMessage(dec, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_CommandMessage(dec, &(val)->u.command))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_FunctionNotUnderstood(FunctionNotUnderstood *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_RequestMessage(&(val)->u.request);
	    break;
	case 2:
	    ASN1Free_ResponseMessage(&(val)->u.response);
	    break;
	case 3:
	    ASN1Free_CommandMessage(&(val)->u.command);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_IndicationMessage(ASN1encoding_t enc, IndicationMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_FunctionNotUnderstood(enc, &(val)->u.functionNotUnderstood))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_MasterSlaveDeterminationRelease(enc, &(val)->u.masterSlaveDeterminationRelease))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_TerminalCapabilitySetRelease(enc, &(val)->u.terminalCapabilitySetRelease))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_OpenLogicalChannelConfirm(enc, &(val)->u.openLogicalChannelConfirm))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_RequestChannelCloseRelease(enc, &(val)->u.requestChannelCloseRelease))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_MultiplexEntrySendRelease(enc, &(val)->u.multiplexEntrySendRelease))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_RequestMultiplexEntryRelease(enc, &(val)->u.requestMultiplexEntryRelease))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_RequestModeRelease(enc, &(val)->u.requestModeRelease))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_MiscellaneousIndication(enc, &(val)->u.miscellaneousIndication))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_JitterIndication(enc, &(val)->u.jitterIndication))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_H223SkewIndication(enc, &(val)->u.h223SkewIndication))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_NewATMVCIndication(enc, &(val)->u.newATMVCIndication))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_UserInputIndication(enc, &(val)->u.userInput))
	    return 0;
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250MaximumSkewIndication(ee, &(val)->u.h2250MaximumSkewIndication))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_MCLocationIndication(ee, &(val)->u.mcLocationIndication))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 17:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceIndication(ee, &(val)->u.conferenceIndication))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 18:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_VendorIdentification(ee, &(val)->u.vendorIdentification))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 19:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_FunctionNotSupported(ee, &(val)->u.functionNotSupported))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IndicationMessage(ASN1decoding_t dec, IndicationMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_FunctionNotUnderstood(dec, &(val)->u.functionNotUnderstood))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_MasterSlaveDeterminationRelease(dec, &(val)->u.masterSlaveDeterminationRelease))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_TerminalCapabilitySetRelease(dec, &(val)->u.terminalCapabilitySetRelease))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_OpenLogicalChannelConfirm(dec, &(val)->u.openLogicalChannelConfirm))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_RequestChannelCloseRelease(dec, &(val)->u.requestChannelCloseRelease))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_MultiplexEntrySendRelease(dec, &(val)->u.multiplexEntrySendRelease))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_RequestMultiplexEntryRelease(dec, &(val)->u.requestMultiplexEntryRelease))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_RequestModeRelease(dec, &(val)->u.requestModeRelease))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_MiscellaneousIndication(dec, &(val)->u.miscellaneousIndication))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_JitterIndication(dec, &(val)->u.jitterIndication))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_H223SkewIndication(dec, &(val)->u.h223SkewIndication))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_NewATMVCIndication(dec, &(val)->u.newATMVCIndication))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_UserInputIndication(dec, &(val)->u.userInput))
	    return 0;
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H2250MaximumSkewIndication(dd, &(val)->u.h2250MaximumSkewIndication))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_MCLocationIndication(dd, &(val)->u.mcLocationIndication))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 17:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceIndication(dd, &(val)->u.conferenceIndication))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 18:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_VendorIdentification(dd, &(val)->u.vendorIdentification))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 19:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_FunctionNotSupported(dd, &(val)->u.functionNotSupported))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_IndicationMessage(IndicationMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_FunctionNotUnderstood(&(val)->u.functionNotUnderstood);
	    break;
	case 7:
	    ASN1Free_MultiplexEntrySendRelease(&(val)->u.multiplexEntrySendRelease);
	    break;
	case 8:
	    ASN1Free_RequestMultiplexEntryRelease(&(val)->u.requestMultiplexEntryRelease);
	    break;
	case 10:
	    ASN1Free_MiscellaneousIndication(&(val)->u.miscellaneousIndication);
	    break;
	case 14:
	    ASN1Free_UserInputIndication(&(val)->u.userInput);
	    break;
	case 16:
	    ASN1Free_MCLocationIndication(&(val)->u.mcLocationIndication);
	    break;
	case 18:
	    ASN1Free_VendorIdentification(&(val)->u.vendorIdentification);
	    break;
	case 19:
	    ASN1Free_FunctionNotSupported(&(val)->u.functionNotSupported);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MultimediaSystemControlMessage(ASN1encoding_t enc, MultimediaSystemControlMessage *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_RequestMessage(enc, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ResponseMessage(enc, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_CommandMessage(enc, &(val)->u.command))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_IndicationMessage(enc, &(val)->u.indication))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultimediaSystemControlMessage(ASN1decoding_t dec, MultimediaSystemControlMessage *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_RequestMessage(dec, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ResponseMessage(dec, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_CommandMessage(dec, &(val)->u.command))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_IndicationMessage(dec, &(val)->u.indication))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultimediaSystemControlMessage(MultimediaSystemControlMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_RequestMessage(&(val)->u.request);
	    break;
	case 2:
	    ASN1Free_ResponseMessage(&(val)->u.response);
	    break;
	case 3:
	    ASN1Free_CommandMessage(&(val)->u.command);
	    break;
	case 4:
	    ASN1Free_IndicationMessage(&(val)->u.indication);
	    break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\h245info.h ===
#ifndef _cbridge_h245_h_
#define _cbridge_h245_h_

// H245 states
// H245_STATE_CON_LISTEN is only applicable to the source side
// H245_STATE_CON_INFO is only applicable to the dest side
enum H245_STATE
{
    H245_STATE_NOT_INIT = 0,
    H245_STATE_INIT,
	H245_STATE_CON_LISTEN,
	H245_STATE_CON_INFO,
	H245_STATE_CON_ESTD
};

class H245_INFO :
    public OVERLAPPED_PROCESSOR
{
	// we need to let the LOGICAL_CHANNEL send PDUs using the
	// H245 sockets and transition to shutdown mode
	friend HRESULT 
		LOGICAL_CHANNEL::ProcessOpenLogicalChannelRejectPDU (
		IN      MultimediaSystemControlMessage   *pH245pdu
		);

    // XXX Is this the only way out ?
    friend HRESULT
    T120_LOGICAL_CHANNEL::HandleOpenLogicalChannelPDU(
        IN H245_INFO                            &H245Info,
        IN MEDIA_TYPE                           MediaType,
        IN WORD                                 LogicalChannelNumber,
        IN BYTE                                 SessionId,
        IN DWORD                                T120ConnectToIPAddr,
        IN WORD                                 T120ConnectToPort,
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    friend HRESULT
    T120_LOGICAL_CHANNEL::ProcessOpenLogicalChannelAckPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

public:

	inline 
    H245_INFO (
        void
        );

    inline 
    void 
    Init (
        IN H323_STATE   &H323State
        );

    inline 
    H245_INFO &GetOtherH245Info (
        void
        );

    inline 
    LOGICAL_CHANNEL_ARRAY &GetLogicalChannelArray (
        void
        );

    HRESULT 
    ProcessMessage (
        IN MultimediaSystemControlMessage   * pH245pdu
        );

    HRESULT
    H245_INFO::SendEndSessionCommand (
        void
        );

    virtual 
    ~H245_INFO (
        void
        );

protected:

    H245_STATE  m_H245State;

	// logical channels
	LOGICAL_CHANNEL_ARRAY   m_LogicalChannelArray;

	// the other h245 addresses are needed because we need to 
	// cancel NAT redirections in the logical channel destructor
	// and we can't access the other h245 instance there because
	// it may have been destroyed already 

    // queue an asynchronous receive call back
    inline 
    HRESULT 
    QueueReceive (
        void
        );

    // queue an asynchronous send call back
    inline 
    HRESULT QueueSend (
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    virtual 
    HRESULT AcceptCallback (
		IN	DWORD			Status,
		IN	SOCKET			Socket,
		IN	SOCKADDR_IN *	LocalAddress,
		IN	SOCKADDR_IN *	RemoteAddress
        )
    {
        _ASSERTE(FALSE);
        return E_UNEXPECTED;
    }

    virtual 
    HRESULT 
    ReceiveCallback (
        IN      HRESULT                 CallbackHResult,
        IN      BYTE                   *pBuf,
        IN      DWORD                   BufLen
        );

    virtual 
    HRESULT 
    ReceiveCallback (
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    virtual 
    HRESULT 
    SendCallback (
        IN      HRESULT					 CallbackHResult
        );

private:
    
    HRESULT 
    HandleRequestMessage (
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    HRESULT ProcessResponseMessage (
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    HRESULT CheckOpenLogicalChannelPDU (
        IN  MultimediaSystemControlMessage  &H245pdu,
        OUT BYTE                            &SessionId,
        OUT MEDIA_TYPE                      &MediaType
        );
    
    HRESULT CheckOpenLogicalChannelPDU (
        IN  MultimediaSystemControlMessage  &H245pdu,
        OUT BYTE                            &SessionId,
        OUT DWORD                           &SourceIPv4Address,
        OUT WORD                            &SourceRTCPPort
        );

    HRESULT HandleOpenLogicalChannelPDU (
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    HRESULT HandleCloseLogicalChannelPDU (
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    HRESULT CheckOpenRtpLogicalChannelPDU (
        IN  OpenLogicalChannel              &OlcPDU,
		OUT	SOCKADDR_IN *					ReturnSourceAddress
        );
    
    HRESULT CheckOpenT120LogicalChannelPDU (
        IN  OpenLogicalChannel  &OlcPDU,
        OUT DWORD               &T120ConnectToIPAddr,
        OUT WORD                &T120ConnectToPort
        );

    HRESULT CreateRtpLogicalChannel (
        IN      OpenLogicalChannel               &OlcPDU,
        IN      BYTE                              SessionId,
        IN      MEDIA_TYPE                        MediaType,
        IN      MultimediaSystemControlMessage   *pH245pdu,
        OUT     LOGICAL_CHANNEL                 **ppReturnLogicalChannel 
        );
    
    HRESULT CreateT120LogicalChannel (
        IN      OpenLogicalChannel               &OlcPDU,
        IN      BYTE                              SessionId,
        IN      MEDIA_TYPE                        MediaType,
        IN      MultimediaSystemControlMessage   *pH245pdu,
        OUT     LOGICAL_CHANNEL                 **ppReturnLogicalChannel 
        );
        
};


inline 
H245_INFO::H245_INFO (
	)
	: m_H245State(H245_STATE_NOT_INIT)
{
}

inline 
void
H245_INFO::Init (
    IN H323_STATE   &H323State
    )
{
    // initialize the overlaped processor
    OVERLAPPED_PROCESSOR::Init(OPT_H245, H323State);

    m_LogicalChannelArray.Init();
    m_H245State     = H245_STATE_INIT;
}


inline LOGICAL_CHANNEL_ARRAY &
H245_INFO::GetLogicalChannelArray (
    void
    )
{
    return m_LogicalChannelArray;
}

class SOURCE_H245_INFO :
	public H245_INFO
{
public:

	inline 
    SOURCE_H245_INFO (
        void
        );

    inline 
    void Init (
        IN SOURCE_H323_STATE   &SourceH323State
        );

	inline 
    SOURCE_Q931_INFO &GetSourceQ931Info (
        void
        );

    inline 
    DEST_H245_INFO &GetDestH245Info (
        void
        );

	HRESULT 
    ListenForCaller	(
		IN	SOCKADDR_IN *	ListenAddress
        );

protected:
	
    virtual 
    HRESULT 
    AcceptCallback (
		IN	DWORD			Status,
		IN	SOCKET			Socket,
		IN	SOCKADDR_IN *	LocalAddress,
		IN	SOCKADDR_IN *	RemoteAddress
        );
};

	
inline 
SOURCE_H245_INFO::SOURCE_H245_INFO (
    void
	)
{
}

inline 
void
SOURCE_H245_INFO::Init (
    IN SOURCE_H323_STATE   &SourceH323State
    )
{
    H245_INFO::Init((H323_STATE &)SourceH323State);
}


class DEST_H245_INFO :
	public H245_INFO
{
public:

	inline 
    DEST_H245_INFO (
        void
        );

    inline 
    void 
    Init (
        IN DEST_H323_STATE   &DestH323State
        );

	inline 
    void 
    SetCalleeInfo (
		IN	SOCKADDR_IN *	CalleeAddress
        );

	inline 
    DEST_Q931_INFO &GetDestQ931Info (
        void
        );

	inline 
    HRESULT ConnectToCallee (
        void
        );

protected:

	SOCKADDR_IN		m_CalleeAddress;
};

	
inline 
DEST_H245_INFO::DEST_H245_INFO (
    void
	)
{
}

inline 
void
DEST_H245_INFO::Init (
    IN DEST_H323_STATE   &DestH323State
    )
{
    H245_INFO::Init((H323_STATE &)DestH323State);
}


inline void 
DEST_H245_INFO::SetCalleeInfo (
	IN	SOCKADDR_IN *	ArgCalleeAddress
    )
{
	assert (ArgCalleeAddress);

	m_CalleeAddress = *ArgCalleeAddress;

	// state transition to H245_STATE_CON_INFO
	m_H245State = H245_STATE_CON_INFO;
}

#endif // _cbridge_h245_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\h225pp.c ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for H.235 Security Messages v1 (H.235) */
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for Multimedia System Control (H.245) */
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for H.323 Messages v2 (H.225) */

#include <windows.h>
#include "h225pp.h"

ASN1module_t H225PP_Module = NULL;

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_routing(ASN1encoding_t enc, TransportAddress_ipSourceRoute_routing *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route *val);
static int ASN1CALL ASN1Enc_RTPSession_associatedSessionIds(ASN1encoding_t enc, PRTPSession_associatedSessionIds *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_preGrantedARQ(ASN1encoding_t enc, RegistrationConfirm_preGrantedARQ *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_algorithmOIDs(ASN1encoding_t enc, PGatekeeperRequest_algorithmOIDs *val);
static int ASN1CALL ASN1Enc_TransportAddress_ip6Address(ASN1encoding_t enc, TransportAddress_ip6Address *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipxAddress(ASN1encoding_t enc, TransportAddress_ipxAddress *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute(ASN1encoding_t enc, TransportAddress_ipSourceRoute *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipAddress(ASN1encoding_t enc, TransportAddress_ipAddress *val);
static int ASN1CALL ASN1Enc_Progress_UUIE_fastStart(ASN1encoding_t enc, PProgress_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_fastStart(ASN1encoding_t enc, PFacility_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_fastStart(ASN1encoding_t enc, PSetup_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_conferenceGoal(ASN1encoding_t enc, Setup_UUIE_conferenceGoal *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCRV(ASN1encoding_t enc, PSetup_UUIE_destExtraCRV *val);
static int ASN1CALL ASN1Enc_Connect_UUIE_fastStart(ASN1encoding_t enc, PConnect_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_CallProceeding_UUIE_fastStart(ASN1encoding_t enc, PCallProceeding_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_Alerting_UUIE_fastStart(ASN1encoding_t enc, PAlerting_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU_h245Control(ASN1encoding_t enc, PH323_UU_PDU_h245Control *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU_h4501SupplementaryService(ASN1encoding_t enc, PH323_UU_PDU_h4501SupplementaryService *val);
static int ASN1CALL ASN1Enc_H323_UserInformation_user_data(ASN1encoding_t enc, H323_UserInformation_user_data *val);
static int ASN1CALL ASN1Enc_H235NonStandardParameter(ASN1encoding_t enc, H235NonStandardParameter *val);
static int ASN1CALL ASN1Enc_DHset(ASN1encoding_t enc, DHset *val);
static int ASN1CALL ASN1Enc_TypedCertificate(ASN1encoding_t enc, TypedCertificate *val);
static int ASN1CALL ASN1Enc_AuthenticationMechanism(ASN1encoding_t enc, AuthenticationMechanism *val);
static int ASN1CALL ASN1Enc_ClearToken(ASN1encoding_t enc, ClearToken *val);
static int ASN1CALL ASN1Enc_Params(ASN1encoding_t enc, Params *val);
static int ASN1CALL ASN1Enc_EncodedGeneralToken(ASN1encoding_t enc, EncodedGeneralToken *val);
static int ASN1CALL ASN1Enc_PwdCertToken(ASN1encoding_t enc, PwdCertToken *val);
static int ASN1CALL ASN1Enc_EncodedPwdCertToken(ASN1encoding_t enc, EncodedPwdCertToken *val);
static int ASN1CALL ASN1Enc_ReleaseCompleteReason(ASN1encoding_t enc, ReleaseCompleteReason *val);
static int ASN1CALL ASN1Enc_FacilityReason(ASN1encoding_t enc, FacilityReason *val);
static int ASN1CALL ASN1Enc_H221NonStandard(ASN1encoding_t enc, H221NonStandard *val);
static int ASN1CALL ASN1Enc_H225NonStandardIdentifier(ASN1encoding_t enc, H225NonStandardIdentifier *val);
static int ASN1CALL ASN1Enc_PublicTypeOfNumber(ASN1encoding_t enc, PublicTypeOfNumber *val);
static int ASN1CALL ASN1Enc_PrivateTypeOfNumber(ASN1encoding_t enc, PrivateTypeOfNumber *val);
static int ASN1CALL ASN1Enc_AltGKInfo(ASN1encoding_t enc, AltGKInfo *val);
static int ASN1CALL ASN1Enc_Q954Details(ASN1encoding_t enc, Q954Details *val);
static int ASN1CALL ASN1Enc_CallIdentifier(ASN1encoding_t enc, CallIdentifier *val);
static int ASN1CALL ASN1Enc_ICV(ASN1encoding_t enc, ICV *val);
static int ASN1CALL ASN1Enc_GatekeeperRejectReason(ASN1encoding_t enc, GatekeeperRejectReason *val);
static int ASN1CALL ASN1Enc_RegistrationRejectReason(ASN1encoding_t enc, RegistrationRejectReason *val);
static int ASN1CALL ASN1Enc_UnregRequestReason(ASN1encoding_t enc, UnregRequestReason *val);
static int ASN1CALL ASN1Enc_UnregRejectReason(ASN1encoding_t enc, UnregRejectReason *val);
static int ASN1CALL ASN1Enc_CallType(ASN1encoding_t enc, CallType *val);
static int ASN1CALL ASN1Enc_CallModel(ASN1encoding_t enc, CallModel *val);
static int ASN1CALL ASN1Enc_TransportQOS(ASN1encoding_t enc, TransportQOS *val);
static int ASN1CALL ASN1Enc_UUIEsRequested(ASN1encoding_t enc, UUIEsRequested *val);
static int ASN1CALL ASN1Enc_AdmissionRejectReason(ASN1encoding_t enc, AdmissionRejectReason *val);
static int ASN1CALL ASN1Enc_BandRejectReason(ASN1encoding_t enc, BandRejectReason *val);
static int ASN1CALL ASN1Enc_LocationRejectReason(ASN1encoding_t enc, LocationRejectReason *val);
static int ASN1CALL ASN1Enc_DisengageReason(ASN1encoding_t enc, DisengageReason *val);
static int ASN1CALL ASN1Enc_DisengageRejectReason(ASN1encoding_t enc, DisengageRejectReason *val);
static int ASN1CALL ASN1Enc_InfoRequestNakReason(ASN1encoding_t enc, InfoRequestNakReason *val);
static int ASN1CALL ASN1Enc_UnknownMessageResponse(ASN1encoding_t enc, UnknownMessageResponse *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_tokens *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_tokens(ASN1encoding_t enc, PResourcesAvailableConfirm_tokens *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_tokens(ASN1encoding_t enc, PResourcesAvailableIndicate_tokens *val);
static int ASN1CALL ASN1Enc_RequestInProgress_tokens(ASN1encoding_t enc, PRequestInProgress_tokens *val);
static int ASN1CALL ASN1Enc_UnknownMessageResponse_tokens(ASN1encoding_t enc, PUnknownMessageResponse_tokens *val);
static int ASN1CALL ASN1Enc_H225NonStandardMessage_tokens(ASN1encoding_t enc, PH225NonStandardMessage_tokens *val);
static int ASN1CALL ASN1Enc_InfoRequestNak_tokens(ASN1encoding_t enc, PInfoRequestNak_tokens *val);
static int ASN1CALL ASN1Enc_InfoRequestAck_tokens(ASN1encoding_t enc, PInfoRequestAck_tokens *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_tokens(ASN1encoding_t enc, PInfoRequestResponse_tokens *val);
static int ASN1CALL ASN1Enc_InfoRequest_tokens(ASN1encoding_t enc, PInfoRequest_tokens *val);
static int ASN1CALL ASN1Enc_DisengageReject_tokens(ASN1encoding_t enc, PDisengageReject_tokens *val);
static int ASN1CALL ASN1Enc_DisengageConfirm_tokens(ASN1encoding_t enc, PDisengageConfirm_tokens *val);
static int ASN1CALL ASN1Enc_DisengageRequest_tokens(ASN1encoding_t enc, PDisengageRequest_tokens *val);
static int ASN1CALL ASN1Enc_LocationReject_tokens(ASN1encoding_t enc, PLocationReject_tokens *val);
static int ASN1CALL ASN1Enc_LocationConfirm_tokens(ASN1encoding_t enc, PLocationConfirm_tokens *val);
static int ASN1CALL ASN1Enc_LocationRequest_tokens(ASN1encoding_t enc, PLocationRequest_tokens *val);
static int ASN1CALL ASN1Enc_BandwidthReject_tokens(ASN1encoding_t enc, PBandwidthReject_tokens *val);
static int ASN1CALL ASN1Enc_BandwidthConfirm_tokens(ASN1encoding_t enc, PBandwidthConfirm_tokens *val);
static int ASN1CALL ASN1Enc_BandwidthRequest_tokens(ASN1encoding_t enc, PBandwidthRequest_tokens *val);
static int ASN1CALL ASN1Enc_AdmissionReject_tokens(ASN1encoding_t enc, PAdmissionReject_tokens *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_tokens(ASN1encoding_t enc, PAdmissionConfirm_tokens *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_tokens(ASN1encoding_t enc, PAdmissionRequest_tokens *val);
static int ASN1CALL ASN1Enc_UnregistrationReject_tokens(ASN1encoding_t enc, PUnregistrationReject_tokens *val);
static int ASN1CALL ASN1Enc_UnregistrationConfirm_tokens(ASN1encoding_t enc, PUnregistrationConfirm_tokens *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest_tokens(ASN1encoding_t enc, PUnregistrationRequest_tokens *val);
static int ASN1CALL ASN1Enc_RegistrationReject_tokens(ASN1encoding_t enc, PRegistrationReject_tokens *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_tokens(ASN1encoding_t enc, PRegistrationConfirm_tokens *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_tokens(ASN1encoding_t enc, PRegistrationRequest_tokens *val);
static int ASN1CALL ASN1Enc_GatekeeperReject_tokens(ASN1encoding_t enc, PGatekeeperReject_tokens *val);
static int ASN1CALL ASN1Enc_GatekeeperConfirm_tokens(ASN1encoding_t enc, PGatekeeperConfirm_tokens *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_authenticationCapability(ASN1encoding_t enc, PGatekeeperRequest_authenticationCapability *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_tokens(ASN1encoding_t enc, PGatekeeperRequest_tokens *val);
static int ASN1CALL ASN1Enc_Endpoint_tokens(ASN1encoding_t enc, PEndpoint_tokens *val);
static int ASN1CALL ASN1Enc_Progress_UUIE_tokens(ASN1encoding_t enc, PProgress_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_tokens(ASN1encoding_t enc, PFacility_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_tokens(ASN1encoding_t enc, PSetup_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_Connect_UUIE_tokens(ASN1encoding_t enc, PConnect_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_CallProceeding_UUIE_tokens(ASN1encoding_t enc, PCallProceeding_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_Alerting_UUIE_tokens(ASN1encoding_t enc, PAlerting_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_SIGNED_EncodedGeneralToken(ASN1encoding_t enc, SIGNED_EncodedGeneralToken *val);
static int ASN1CALL ASN1Enc_ENCRYPTED(ASN1encoding_t enc, ENCRYPTED *val);
static int ASN1CALL ASN1Enc_HASHED(ASN1encoding_t enc, HASHED *val);
static int ASN1CALL ASN1Enc_SIGNED_EncodedPwdCertToken(ASN1encoding_t enc, SIGNED_EncodedPwdCertToken *val);
static int ASN1CALL ASN1Enc_Information_UUIE(ASN1encoding_t enc, Information_UUIE *val);
static int ASN1CALL ASN1Enc_ReleaseComplete_UUIE(ASN1encoding_t enc, ReleaseComplete_UUIE *val);
static int ASN1CALL ASN1Enc_VendorIdentifier(ASN1encoding_t enc, VendorIdentifier *val);
static int ASN1CALL ASN1Enc_H225NonStandardParameter(ASN1encoding_t enc, H225NonStandardParameter *val);
static int ASN1CALL ASN1Enc_PublicPartyNumber(ASN1encoding_t enc, PublicPartyNumber *val);
static int ASN1CALL ASN1Enc_PrivatePartyNumber(ASN1encoding_t enc, PrivatePartyNumber *val);
static int ASN1CALL ASN1Enc_SecurityServiceMode(ASN1encoding_t enc, SecurityServiceMode *val);
static int ASN1CALL ASN1Enc_SecurityCapabilities(ASN1encoding_t enc, SecurityCapabilities *val);
static int ASN1CALL ASN1Enc_H245Security(ASN1encoding_t enc, H245Security *val);
static int ASN1CALL ASN1Enc_QseriesOptions(ASN1encoding_t enc, QseriesOptions *val);
static int ASN1CALL ASN1Enc_EncryptIntAlg(ASN1encoding_t enc, EncryptIntAlg *val);
static int ASN1CALL ASN1Enc_NonIsoIntegrityMechanism(ASN1encoding_t enc, NonIsoIntegrityMechanism *val);
static int ASN1CALL ASN1Enc_IntegrityMechanism(ASN1encoding_t enc, IntegrityMechanism *val);
#define ASN1Enc_FastStartToken(x,y)      0
static int ASN1CALL ASN1Enc_EncodedFastStartToken(ASN1encoding_t enc, EncodedFastStartToken *val);
static int ASN1CALL ASN1Enc_DataRate(ASN1encoding_t enc, DataRate *val);
static int ASN1CALL ASN1Enc_GatekeeperReject(ASN1encoding_t enc, GatekeeperReject *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm(ASN1encoding_t enc, RegistrationConfirm *val);
static int ASN1CALL ASN1Enc_RegistrationReject(ASN1encoding_t enc, RegistrationReject *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest(ASN1encoding_t enc, UnregistrationRequest *val);
static int ASN1CALL ASN1Enc_UnregistrationConfirm(ASN1encoding_t enc, UnregistrationConfirm *val);
static int ASN1CALL ASN1Enc_UnregistrationReject(ASN1encoding_t enc, UnregistrationReject *val);
static int ASN1CALL ASN1Enc_AdmissionReject(ASN1encoding_t enc, AdmissionReject *val);
static int ASN1CALL ASN1Enc_BandwidthRequest(ASN1encoding_t enc, BandwidthRequest *val);
static int ASN1CALL ASN1Enc_BandwidthConfirm(ASN1encoding_t enc, BandwidthConfirm *val);
static int ASN1CALL ASN1Enc_BandwidthReject(ASN1encoding_t enc, BandwidthReject *val);
static int ASN1CALL ASN1Enc_LocationReject(ASN1encoding_t enc, LocationReject *val);
static int ASN1CALL ASN1Enc_DisengageRequest(ASN1encoding_t enc, DisengageRequest *val);
static int ASN1CALL ASN1Enc_DisengageConfirm(ASN1encoding_t enc, DisengageConfirm *val);
static int ASN1CALL ASN1Enc_DisengageReject(ASN1encoding_t enc, DisengageReject *val);
static int ASN1CALL ASN1Enc_InfoRequestAck(ASN1encoding_t enc, InfoRequestAck *val);
static int ASN1CALL ASN1Enc_InfoRequestNak(ASN1encoding_t enc, InfoRequestNak *val);
static int ASN1CALL ASN1Enc_H225NonStandardMessage(ASN1encoding_t enc, H225NonStandardMessage *val);
static int ASN1CALL ASN1Enc_RequestInProgress(ASN1encoding_t enc, RequestInProgress *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate(ASN1encoding_t enc, ResourcesAvailableIndicate *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm(ASN1encoding_t enc, ResourcesAvailableConfirm *val);
static int ASN1CALL ASN1Enc_GatekeeperConfirm_integrity(ASN1encoding_t enc, PGatekeeperConfirm_integrity *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_integrity(ASN1encoding_t enc, PGatekeeperRequest_integrity *val);
static int ASN1CALL ASN1Enc_CryptoH323Token_cryptoGKPwdHash(ASN1encoding_t enc, CryptoH323Token_cryptoGKPwdHash *val);
static int ASN1CALL ASN1Enc_NonStandardProtocol_dataRatesSupported(ASN1encoding_t enc, PNonStandardProtocol_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_T120OnlyCaps_dataRatesSupported(ASN1encoding_t enc, PT120OnlyCaps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_VoiceCaps_dataRatesSupported(ASN1encoding_t enc, PVoiceCaps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H324Caps_dataRatesSupported(ASN1encoding_t enc, PH324Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H323Caps_dataRatesSupported(ASN1encoding_t enc, PH323Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H322Caps_dataRatesSupported(ASN1encoding_t enc, PH322Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H321Caps_dataRatesSupported(ASN1encoding_t enc, PH321Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H320Caps_dataRatesSupported(ASN1encoding_t enc, PH320Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H310Caps_dataRatesSupported(ASN1encoding_t enc, PH310Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_h245SecurityCapability(ASN1encoding_t enc, PSetup_UUIE_h245SecurityCapability *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU_nonStandardControl(ASN1encoding_t enc, PH323_UU_PDU_nonStandardControl *val);
static int ASN1CALL ASN1Enc_CryptoToken_cryptoHashedToken(ASN1encoding_t enc, CryptoToken_cryptoHashedToken *val);
static int ASN1CALL ASN1Enc_CryptoToken_cryptoSignedToken(ASN1encoding_t enc, CryptoToken_cryptoSignedToken *val);
static int ASN1CALL ASN1Enc_CryptoToken_cryptoEncryptedToken(ASN1encoding_t enc, CryptoToken_cryptoEncryptedToken *val);
static int ASN1CALL ASN1Enc_CryptoToken(ASN1encoding_t enc, CryptoToken *val);
static int ASN1CALL ASN1Enc_SIGNED_EncodedFastStartToken(ASN1encoding_t enc, SIGNED_EncodedFastStartToken *val);
static int ASN1CALL ASN1Enc_TransportAddress(ASN1encoding_t enc, TransportAddress *val);
static int ASN1CALL ASN1Enc_GatewayInfo(ASN1encoding_t enc, GatewayInfo *val);
static int ASN1CALL ASN1Enc_H310Caps(ASN1encoding_t enc, H310Caps *val);
static int ASN1CALL ASN1Enc_H320Caps(ASN1encoding_t enc, H320Caps *val);
static int ASN1CALL ASN1Enc_H321Caps(ASN1encoding_t enc, H321Caps *val);
static int ASN1CALL ASN1Enc_H322Caps(ASN1encoding_t enc, H322Caps *val);
static int ASN1CALL ASN1Enc_H323Caps(ASN1encoding_t enc, H323Caps *val);
static int ASN1CALL ASN1Enc_H324Caps(ASN1encoding_t enc, H324Caps *val);
static int ASN1CALL ASN1Enc_VoiceCaps(ASN1encoding_t enc, VoiceCaps *val);
static int ASN1CALL ASN1Enc_T120OnlyCaps(ASN1encoding_t enc, T120OnlyCaps *val);
static int ASN1CALL ASN1Enc_NonStandardProtocol(ASN1encoding_t enc, NonStandardProtocol *val);
static int ASN1CALL ASN1Enc_McuInfo(ASN1encoding_t enc, McuInfo *val);
static int ASN1CALL ASN1Enc_TerminalInfo(ASN1encoding_t enc, TerminalInfo *val);
static int ASN1CALL ASN1Enc_GatekeeperInfo(ASN1encoding_t enc, GatekeeperInfo *val);
static int ASN1CALL ASN1Enc_PartyNumber(ASN1encoding_t enc, PartyNumber *val);
static int ASN1CALL ASN1Enc_AlternateGK(ASN1encoding_t enc, AlternateGK *val);
static int ASN1CALL ASN1Enc_GatekeeperConfirm(ASN1encoding_t enc, GatekeeperConfirm *val);
static int ASN1CALL ASN1Enc_AdmissionRequest(ASN1encoding_t enc, AdmissionRequest *val);
static int ASN1CALL ASN1Enc_LocationRequest(ASN1encoding_t enc, LocationRequest *val);
static int ASN1CALL ASN1Enc_InfoRequest(ASN1encoding_t enc, InfoRequest *val);
static int ASN1CALL ASN1Enc_TransportChannelInfo(ASN1encoding_t enc, TransportChannelInfo *val);
static int ASN1CALL ASN1Enc_RTPSession(ASN1encoding_t enc, RTPSession *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_data *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_video *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_audio *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq(ASN1encoding_t enc, InfoRequestResponse_perCallInfo_Seq *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_callSignalAddress(ASN1encoding_t enc, PInfoRequestResponse_callSignalAddress *val);
static int ASN1CALL ASN1Enc_AdmissionReject_callSignalAddress(ASN1encoding_t enc, PAdmissionReject_callSignalAddress *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest_callSignalAddress(ASN1encoding_t enc, PUnregistrationRequest_callSignalAddress *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_alternateGatekeeper(ASN1encoding_t enc, PRegistrationConfirm_alternateGatekeeper *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_callSignalAddress(ASN1encoding_t enc, PRegistrationConfirm_callSignalAddress *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_rasAddress(ASN1encoding_t enc, PRegistrationRequest_rasAddress *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_callSignalAddress(ASN1encoding_t enc, PRegistrationRequest_callSignalAddress *val);
static int ASN1CALL ASN1Enc_GatekeeperConfirm_alternateGatekeeper(ASN1encoding_t enc, PGatekeeperConfirm_alternateGatekeeper *val);
static int ASN1CALL ASN1Enc_AltGKInfo_alternateGatekeeper(ASN1encoding_t enc, PAltGKInfo_alternateGatekeeper *val);
static int ASN1CALL ASN1Enc_Endpoint_rasAddress(ASN1encoding_t enc, PEndpoint_rasAddress *val);
static int ASN1CALL ASN1Enc_Endpoint_callSignalAddress(ASN1encoding_t enc, PEndpoint_callSignalAddress *val);
static int ASN1CALL ASN1Enc_EndpointType(ASN1encoding_t enc, EndpointType *val);
static int ASN1CALL ASN1Enc_SupportedProtocols(ASN1encoding_t enc, SupportedProtocols *val);
static int ASN1CALL ASN1Enc_AliasAddress(ASN1encoding_t enc, AliasAddress *val);
static int ASN1CALL ASN1Enc_Endpoint(ASN1encoding_t enc, Endpoint *val);
static int ASN1CALL ASN1Enc_SupportedPrefix(ASN1encoding_t enc, SupportedPrefix *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest(ASN1encoding_t enc, GatekeeperRequest *val);
static int ASN1CALL ASN1Enc_RegistrationRequest(ASN1encoding_t enc, RegistrationRequest *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm(ASN1encoding_t enc, AdmissionConfirm *val);
static int ASN1CALL ASN1Enc_LocationConfirm(ASN1encoding_t enc, LocationConfirm *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse(ASN1encoding_t enc, InfoRequestResponse *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_protocols(ASN1encoding_t enc, PResourcesAvailableIndicate_protocols *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_endpointAlias(ASN1encoding_t enc, PInfoRequestResponse_endpointAlias *val);
static int ASN1CALL ASN1Enc_LocationConfirm_alternateEndpoints(ASN1encoding_t enc, PLocationConfirm_alternateEndpoints *val);
static int ASN1CALL ASN1Enc_LocationConfirm_remoteExtensionAddress(ASN1encoding_t enc, PLocationConfirm_remoteExtensionAddress *val);
static int ASN1CALL ASN1Enc_LocationConfirm_destExtraCallInfo(ASN1encoding_t enc, PLocationConfirm_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_LocationConfirm_destinationInfo(ASN1encoding_t enc, PLocationConfirm_destinationInfo *val);
static int ASN1CALL ASN1Enc_LocationRequest_sourceInfo(ASN1encoding_t enc, PLocationRequest_sourceInfo *val);
static int ASN1CALL ASN1Enc_LocationRequest_destinationInfo(ASN1encoding_t enc, PLocationRequest_destinationInfo *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_alternateEndpoints(ASN1encoding_t enc, PAdmissionConfirm_alternateEndpoints *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_remoteExtensionAddress(ASN1encoding_t enc, PAdmissionConfirm_remoteExtensionAddress *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_destExtraCallInfo(ASN1encoding_t enc, PAdmissionConfirm_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_destinationInfo(ASN1encoding_t enc, PAdmissionConfirm_destinationInfo *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_destAlternatives(ASN1encoding_t enc, PAdmissionRequest_destAlternatives *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_srcAlternatives(ASN1encoding_t enc, PAdmissionRequest_srcAlternatives *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_srcInfo(ASN1encoding_t enc, PAdmissionRequest_srcInfo *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_destExtraCallInfo(ASN1encoding_t enc, PAdmissionRequest_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_destinationInfo(ASN1encoding_t enc, PAdmissionRequest_destinationInfo *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest_alternateEndpoints(ASN1encoding_t enc, PUnregistrationRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest_endpointAlias(ASN1encoding_t enc, PUnregistrationRequest_endpointAlias *val);
static int ASN1CALL ASN1Enc_RegistrationRejectReason_duplicateAlias(ASN1encoding_t enc, PRegistrationRejectReason_duplicateAlias *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_terminalAlias(ASN1encoding_t enc, PRegistrationConfirm_terminalAlias *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_alternateEndpoints(ASN1encoding_t enc, PRegistrationRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_terminalAlias(ASN1encoding_t enc, PRegistrationRequest_terminalAlias *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_alternateEndpoints(ASN1encoding_t enc, PGatekeeperRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_endpointAlias(ASN1encoding_t enc, PGatekeeperRequest_endpointAlias *val);
static int ASN1CALL ASN1Enc_CryptoH323Token_cryptoEPPwdHash(ASN1encoding_t enc, CryptoH323Token_cryptoEPPwdHash *val);
static int ASN1CALL ASN1Enc_Endpoint_destExtraCallInfo(ASN1encoding_t enc, PEndpoint_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_Endpoint_remoteExtensionAddress(ASN1encoding_t enc, PEndpoint_remoteExtensionAddress *val);
static int ASN1CALL ASN1Enc_Endpoint_aliasAddress(ASN1encoding_t enc, PEndpoint_aliasAddress *val);
static int ASN1CALL ASN1Enc_NonStandardProtocol_supportedPrefixes(ASN1encoding_t enc, PNonStandardProtocol_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_T120OnlyCaps_supportedPrefixes(ASN1encoding_t enc, PT120OnlyCaps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_VoiceCaps_supportedPrefixes(ASN1encoding_t enc, PVoiceCaps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H324Caps_supportedPrefixes(ASN1encoding_t enc, PH324Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H323Caps_supportedPrefixes(ASN1encoding_t enc, PH323Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H322Caps_supportedPrefixes(ASN1encoding_t enc, PH322Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H321Caps_supportedPrefixes(ASN1encoding_t enc, PH321Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H320Caps_supportedPrefixes(ASN1encoding_t enc, PH320Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H310Caps_supportedPrefixes(ASN1encoding_t enc, PH310Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_GatewayInfo_protocol(ASN1encoding_t enc, PGatewayInfo_protocol *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_destExtraCallInfo(ASN1encoding_t enc, PFacility_UUIE_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_alternativeAliasAddress(ASN1encoding_t enc, PFacility_UUIE_alternativeAliasAddress *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCallInfo(ASN1encoding_t enc, PSetup_UUIE_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_destinationAddress(ASN1encoding_t enc, PSetup_UUIE_destinationAddress *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_sourceAddress(ASN1encoding_t enc, PSetup_UUIE_sourceAddress *val);
static int ASN1CALL ASN1Enc_Alerting_UUIE(ASN1encoding_t enc, Alerting_UUIE *val);
static int ASN1CALL ASN1Enc_CallProceeding_UUIE(ASN1encoding_t enc, CallProceeding_UUIE *val);
static int ASN1CALL ASN1Enc_Connect_UUIE(ASN1encoding_t enc, Connect_UUIE *val);
static int ASN1CALL ASN1Enc_Setup_UUIE(ASN1encoding_t enc, Setup_UUIE *val);
static int ASN1CALL ASN1Enc_Facility_UUIE(ASN1encoding_t enc, Facility_UUIE *val);
static int ASN1CALL ASN1Enc_ConferenceList(ASN1encoding_t enc, ConferenceList *val);
static int ASN1CALL ASN1Enc_Progress_UUIE(ASN1encoding_t enc, Progress_UUIE *val);
static int ASN1CALL ASN1Enc_CryptoH323Token(ASN1encoding_t enc, CryptoH323Token *val);
static int ASN1CALL ASN1Enc_RasMessage(ASN1encoding_t enc, RasMessage *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_cryptoTokens(ASN1encoding_t enc, PResourcesAvailableConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_cryptoTokens(ASN1encoding_t enc, PResourcesAvailableIndicate_cryptoTokens *val);
static int ASN1CALL ASN1Enc_RequestInProgress_cryptoTokens(ASN1encoding_t enc, PRequestInProgress_cryptoTokens *val);
static int ASN1CALL ASN1Enc_UnknownMessageResponse_cryptoTokens(ASN1encoding_t enc, PUnknownMessageResponse_cryptoTokens *val);
static int ASN1CALL ASN1Enc_H225NonStandardMessage_cryptoTokens(ASN1encoding_t enc, PH225NonStandardMessage_cryptoTokens *val);
static int ASN1CALL ASN1Enc_InfoRequestNak_cryptoTokens(ASN1encoding_t enc, PInfoRequestNak_cryptoTokens *val);
static int ASN1CALL ASN1Enc_InfoRequestAck_cryptoTokens(ASN1encoding_t enc, PInfoRequestAck_cryptoTokens *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_cryptoTokens(ASN1encoding_t enc, PInfoRequestResponse_cryptoTokens *val);
static int ASN1CALL ASN1Enc_InfoRequest_cryptoTokens(ASN1encoding_t enc, PInfoRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_DisengageReject_cryptoTokens(ASN1encoding_t enc, PDisengageReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_DisengageConfirm_cryptoTokens(ASN1encoding_t enc, PDisengageConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_DisengageRequest_cryptoTokens(ASN1encoding_t enc, PDisengageRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_LocationReject_cryptoTokens(ASN1encoding_t enc, PLocationReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_LocationConfirm_cryptoTokens(ASN1encoding_t enc, PLocationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_LocationRequest_cryptoTokens(ASN1encoding_t enc, PLocationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_BandwidthReject_cryptoTokens(ASN1encoding_t enc, PBandwidthReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_BandwidthConfirm_cryptoTokens(ASN1encoding_t enc, PBandwidthConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_BandwidthRequest_cryptoTokens(ASN1encoding_t enc, PBandwidthRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_AdmissionReject_cryptoTokens(ASN1encoding_t enc, PAdmissionReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_cryptoTokens(ASN1encoding_t enc, PAdmissionConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_cryptoTokens(ASN1encoding_t enc, PAdmissionRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_UnregistrationReject_cryptoTokens(ASN1encoding_t enc, PUnregistrationReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_UnregistrationConfirm_cryptoTokens(ASN1encoding_t enc, PUnregistrationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest_cryptoTokens(ASN1encoding_t enc, PUnregistrationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_RegistrationReject_cryptoTokens(ASN1encoding_t enc, PRegistrationReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_cryptoTokens(ASN1encoding_t enc, PRegistrationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_cryptoTokens(ASN1encoding_t enc, PRegistrationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_GatekeeperReject_cryptoTokens(ASN1encoding_t enc, PGatekeeperReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_GatekeeperConfirm_cryptoTokens(ASN1encoding_t enc, PGatekeeperConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_cryptoTokens(ASN1encoding_t enc, PGatekeeperRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Endpoint_cryptoTokens(ASN1encoding_t enc, PEndpoint_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Progress_UUIE_cryptoTokens(ASN1encoding_t enc, PProgress_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_conferences(ASN1encoding_t enc, PFacility_UUIE_conferences *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_cryptoTokens(ASN1encoding_t enc, PFacility_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_cryptoTokens(ASN1encoding_t enc, PSetup_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Connect_UUIE_cryptoTokens(ASN1encoding_t enc, PConnect_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_CallProceeding_UUIE_cryptoTokens(ASN1encoding_t enc, PCallProceeding_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Alerting_UUIE_cryptoTokens(ASN1encoding_t enc, PAlerting_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU_h323_message_body(ASN1encoding_t enc, H323_UU_PDU_h323_message_body *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU(ASN1encoding_t enc, H323_UU_PDU *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(ASN1encoding_t enc, InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_pdu *val);
static int ASN1CALL ASN1Enc_H323_UserInformation(ASN1encoding_t enc, H323_UserInformation *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_routing(ASN1decoding_t dec, TransportAddress_ipSourceRoute_routing *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route *val);
static int ASN1CALL ASN1Dec_RTPSession_associatedSessionIds(ASN1decoding_t dec, PRTPSession_associatedSessionIds *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_preGrantedARQ(ASN1decoding_t dec, RegistrationConfirm_preGrantedARQ *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_algorithmOIDs(ASN1decoding_t dec, PGatekeeperRequest_algorithmOIDs *val);
static int ASN1CALL ASN1Dec_TransportAddress_ip6Address(ASN1decoding_t dec, TransportAddress_ip6Address *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipxAddress(ASN1decoding_t dec, TransportAddress_ipxAddress *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute(ASN1decoding_t dec, TransportAddress_ipSourceRoute *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipAddress(ASN1decoding_t dec, TransportAddress_ipAddress *val);
static int ASN1CALL ASN1Dec_Progress_UUIE_fastStart(ASN1decoding_t dec, PProgress_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_fastStart(ASN1decoding_t dec, PFacility_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_fastStart(ASN1decoding_t dec, PSetup_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_conferenceGoal(ASN1decoding_t dec, Setup_UUIE_conferenceGoal *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCRV(ASN1decoding_t dec, PSetup_UUIE_destExtraCRV *val);
static int ASN1CALL ASN1Dec_Connect_UUIE_fastStart(ASN1decoding_t dec, PConnect_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_CallProceeding_UUIE_fastStart(ASN1decoding_t dec, PCallProceeding_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_Alerting_UUIE_fastStart(ASN1decoding_t dec, PAlerting_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU_h245Control(ASN1decoding_t dec, PH323_UU_PDU_h245Control *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU_h4501SupplementaryService(ASN1decoding_t dec, PH323_UU_PDU_h4501SupplementaryService *val);
static int ASN1CALL ASN1Dec_H323_UserInformation_user_data(ASN1decoding_t dec, H323_UserInformation_user_data *val);
static int ASN1CALL ASN1Dec_H235NonStandardParameter(ASN1decoding_t dec, H235NonStandardParameter *val);
static int ASN1CALL ASN1Dec_DHset(ASN1decoding_t dec, DHset *val);
static int ASN1CALL ASN1Dec_TypedCertificate(ASN1decoding_t dec, TypedCertificate *val);
static int ASN1CALL ASN1Dec_AuthenticationMechanism(ASN1decoding_t dec, AuthenticationMechanism *val);
static int ASN1CALL ASN1Dec_ClearToken(ASN1decoding_t dec, ClearToken *val);
static int ASN1CALL ASN1Dec_Params(ASN1decoding_t dec, Params *val);
static int ASN1CALL ASN1Dec_EncodedGeneralToken(ASN1decoding_t dec, EncodedGeneralToken *val);
static int ASN1CALL ASN1Dec_PwdCertToken(ASN1decoding_t dec, PwdCertToken *val);
static int ASN1CALL ASN1Dec_EncodedPwdCertToken(ASN1decoding_t dec, EncodedPwdCertToken *val);
static int ASN1CALL ASN1Dec_ReleaseCompleteReason(ASN1decoding_t dec, ReleaseCompleteReason *val);
static int ASN1CALL ASN1Dec_FacilityReason(ASN1decoding_t dec, FacilityReason *val);
static int ASN1CALL ASN1Dec_H221NonStandard(ASN1decoding_t dec, H221NonStandard *val);
static int ASN1CALL ASN1Dec_H225NonStandardIdentifier(ASN1decoding_t dec, H225NonStandardIdentifier *val);
static int ASN1CALL ASN1Dec_PublicTypeOfNumber(ASN1decoding_t dec, PublicTypeOfNumber *val);
static int ASN1CALL ASN1Dec_PrivateTypeOfNumber(ASN1decoding_t dec, PrivateTypeOfNumber *val);
static int ASN1CALL ASN1Dec_AltGKInfo(ASN1decoding_t dec, AltGKInfo *val);
static int ASN1CALL ASN1Dec_Q954Details(ASN1decoding_t dec, Q954Details *val);
static int ASN1CALL ASN1Dec_CallIdentifier(ASN1decoding_t dec, CallIdentifier *val);
static int ASN1CALL ASN1Dec_ICV(ASN1decoding_t dec, ICV *val);
static int ASN1CALL ASN1Dec_GatekeeperRejectReason(ASN1decoding_t dec, GatekeeperRejectReason *val);
static int ASN1CALL ASN1Dec_RegistrationRejectReason(ASN1decoding_t dec, RegistrationRejectReason *val);
static int ASN1CALL ASN1Dec_UnregRequestReason(ASN1decoding_t dec, UnregRequestReason *val);
static int ASN1CALL ASN1Dec_UnregRejectReason(ASN1decoding_t dec, UnregRejectReason *val);
static int ASN1CALL ASN1Dec_CallType(ASN1decoding_t dec, CallType *val);
static int ASN1CALL ASN1Dec_CallModel(ASN1decoding_t dec, CallModel *val);
static int ASN1CALL ASN1Dec_TransportQOS(ASN1decoding_t dec, TransportQOS *val);
static int ASN1CALL ASN1Dec_UUIEsRequested(ASN1decoding_t dec, UUIEsRequested *val);
static int ASN1CALL ASN1Dec_AdmissionRejectReason(ASN1decoding_t dec, AdmissionRejectReason *val);
static int ASN1CALL ASN1Dec_BandRejectReason(ASN1decoding_t dec, BandRejectReason *val);
static int ASN1CALL ASN1Dec_LocationRejectReason(ASN1decoding_t dec, LocationRejectReason *val);
static int ASN1CALL ASN1Dec_DisengageReason(ASN1decoding_t dec, DisengageReason *val);
static int ASN1CALL ASN1Dec_DisengageRejectReason(ASN1decoding_t dec, DisengageRejectReason *val);
static int ASN1CALL ASN1Dec_InfoRequestNakReason(ASN1decoding_t dec, InfoRequestNakReason *val);
static int ASN1CALL ASN1Dec_UnknownMessageResponse(ASN1decoding_t dec, UnknownMessageResponse *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_tokens *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_tokens(ASN1decoding_t dec, PResourcesAvailableConfirm_tokens *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_tokens(ASN1decoding_t dec, PResourcesAvailableIndicate_tokens *val);
static int ASN1CALL ASN1Dec_RequestInProgress_tokens(ASN1decoding_t dec, PRequestInProgress_tokens *val);
static int ASN1CALL ASN1Dec_UnknownMessageResponse_tokens(ASN1decoding_t dec, PUnknownMessageResponse_tokens *val);
static int ASN1CALL ASN1Dec_H225NonStandardMessage_tokens(ASN1decoding_t dec, PH225NonStandardMessage_tokens *val);
static int ASN1CALL ASN1Dec_InfoRequestNak_tokens(ASN1decoding_t dec, PInfoRequestNak_tokens *val);
static int ASN1CALL ASN1Dec_InfoRequestAck_tokens(ASN1decoding_t dec, PInfoRequestAck_tokens *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_tokens(ASN1decoding_t dec, PInfoRequestResponse_tokens *val);
static int ASN1CALL ASN1Dec_InfoRequest_tokens(ASN1decoding_t dec, PInfoRequest_tokens *val);
static int ASN1CALL ASN1Dec_DisengageReject_tokens(ASN1decoding_t dec, PDisengageReject_tokens *val);
static int ASN1CALL ASN1Dec_DisengageConfirm_tokens(ASN1decoding_t dec, PDisengageConfirm_tokens *val);
static int ASN1CALL ASN1Dec_DisengageRequest_tokens(ASN1decoding_t dec, PDisengageRequest_tokens *val);
static int ASN1CALL ASN1Dec_LocationReject_tokens(ASN1decoding_t dec, PLocationReject_tokens *val);
static int ASN1CALL ASN1Dec_LocationConfirm_tokens(ASN1decoding_t dec, PLocationConfirm_tokens *val);
static int ASN1CALL ASN1Dec_LocationRequest_tokens(ASN1decoding_t dec, PLocationRequest_tokens *val);
static int ASN1CALL ASN1Dec_BandwidthReject_tokens(ASN1decoding_t dec, PBandwidthReject_tokens *val);
static int ASN1CALL ASN1Dec_BandwidthConfirm_tokens(ASN1decoding_t dec, PBandwidthConfirm_tokens *val);
static int ASN1CALL ASN1Dec_BandwidthRequest_tokens(ASN1decoding_t dec, PBandwidthRequest_tokens *val);
static int ASN1CALL ASN1Dec_AdmissionReject_tokens(ASN1decoding_t dec, PAdmissionReject_tokens *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_tokens(ASN1decoding_t dec, PAdmissionConfirm_tokens *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_tokens(ASN1decoding_t dec, PAdmissionRequest_tokens *val);
static int ASN1CALL ASN1Dec_UnregistrationReject_tokens(ASN1decoding_t dec, PUnregistrationReject_tokens *val);
static int ASN1CALL ASN1Dec_UnregistrationConfirm_tokens(ASN1decoding_t dec, PUnregistrationConfirm_tokens *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest_tokens(ASN1decoding_t dec, PUnregistrationRequest_tokens *val);
static int ASN1CALL ASN1Dec_RegistrationReject_tokens(ASN1decoding_t dec, PRegistrationReject_tokens *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_tokens(ASN1decoding_t dec, PRegistrationConfirm_tokens *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_tokens(ASN1decoding_t dec, PRegistrationRequest_tokens *val);
static int ASN1CALL ASN1Dec_GatekeeperReject_tokens(ASN1decoding_t dec, PGatekeeperReject_tokens *val);
static int ASN1CALL ASN1Dec_GatekeeperConfirm_tokens(ASN1decoding_t dec, PGatekeeperConfirm_tokens *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_authenticationCapability(ASN1decoding_t dec, PGatekeeperRequest_authenticationCapability *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_tokens(ASN1decoding_t dec, PGatekeeperRequest_tokens *val);
static int ASN1CALL ASN1Dec_Endpoint_tokens(ASN1decoding_t dec, PEndpoint_tokens *val);
static int ASN1CALL ASN1Dec_Progress_UUIE_tokens(ASN1decoding_t dec, PProgress_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_tokens(ASN1decoding_t dec, PFacility_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_tokens(ASN1decoding_t dec, PSetup_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_Connect_UUIE_tokens(ASN1decoding_t dec, PConnect_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_CallProceeding_UUIE_tokens(ASN1decoding_t dec, PCallProceeding_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_Alerting_UUIE_tokens(ASN1decoding_t dec, PAlerting_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_SIGNED_EncodedGeneralToken(ASN1decoding_t dec, SIGNED_EncodedGeneralToken *val);
static int ASN1CALL ASN1Dec_ENCRYPTED(ASN1decoding_t dec, ENCRYPTED *val);
static int ASN1CALL ASN1Dec_HASHED(ASN1decoding_t dec, HASHED *val);
static int ASN1CALL ASN1Dec_SIGNED_EncodedPwdCertToken(ASN1decoding_t dec, SIGNED_EncodedPwdCertToken *val);
static int ASN1CALL ASN1Dec_Information_UUIE(ASN1decoding_t dec, Information_UUIE *val);
static int ASN1CALL ASN1Dec_ReleaseComplete_UUIE(ASN1decoding_t dec, ReleaseComplete_UUIE *val);
static int ASN1CALL ASN1Dec_VendorIdentifier(ASN1decoding_t dec, VendorIdentifier *val);
static int ASN1CALL ASN1Dec_H225NonStandardParameter(ASN1decoding_t dec, H225NonStandardParameter *val);
static int ASN1CALL ASN1Dec_PublicPartyNumber(ASN1decoding_t dec, PublicPartyNumber *val);
static int ASN1CALL ASN1Dec_PrivatePartyNumber(ASN1decoding_t dec, PrivatePartyNumber *val);
static int ASN1CALL ASN1Dec_SecurityServiceMode(ASN1decoding_t dec, SecurityServiceMode *val);
static int ASN1CALL ASN1Dec_SecurityCapabilities(ASN1decoding_t dec, SecurityCapabilities *val);
static int ASN1CALL ASN1Dec_H245Security(ASN1decoding_t dec, H245Security *val);
static int ASN1CALL ASN1Dec_QseriesOptions(ASN1decoding_t dec, QseriesOptions *val);
static int ASN1CALL ASN1Dec_EncryptIntAlg(ASN1decoding_t dec, EncryptIntAlg *val);
static int ASN1CALL ASN1Dec_NonIsoIntegrityMechanism(ASN1decoding_t dec, NonIsoIntegrityMechanism *val);
static int ASN1CALL ASN1Dec_IntegrityMechanism(ASN1decoding_t dec, IntegrityMechanism *val);
#define ASN1Dec_FastStartToken(x,y)      0
static int ASN1CALL ASN1Dec_EncodedFastStartToken(ASN1decoding_t dec, EncodedFastStartToken *val);
static int ASN1CALL ASN1Dec_DataRate(ASN1decoding_t dec, DataRate *val);
static int ASN1CALL ASN1Dec_GatekeeperReject(ASN1decoding_t dec, GatekeeperReject *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm(ASN1decoding_t dec, RegistrationConfirm *val);
static int ASN1CALL ASN1Dec_RegistrationReject(ASN1decoding_t dec, RegistrationReject *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest(ASN1decoding_t dec, UnregistrationRequest *val);
static int ASN1CALL ASN1Dec_UnregistrationConfirm(ASN1decoding_t dec, UnregistrationConfirm *val);
static int ASN1CALL ASN1Dec_UnregistrationReject(ASN1decoding_t dec, UnregistrationReject *val);
static int ASN1CALL ASN1Dec_AdmissionReject(ASN1decoding_t dec, AdmissionReject *val);
static int ASN1CALL ASN1Dec_BandwidthRequest(ASN1decoding_t dec, BandwidthRequest *val);
static int ASN1CALL ASN1Dec_BandwidthConfirm(ASN1decoding_t dec, BandwidthConfirm *val);
static int ASN1CALL ASN1Dec_BandwidthReject(ASN1decoding_t dec, BandwidthReject *val);
static int ASN1CALL ASN1Dec_LocationReject(ASN1decoding_t dec, LocationReject *val);
static int ASN1CALL ASN1Dec_DisengageRequest(ASN1decoding_t dec, DisengageRequest *val);
static int ASN1CALL ASN1Dec_DisengageConfirm(ASN1decoding_t dec, DisengageConfirm *val);
static int ASN1CALL ASN1Dec_DisengageReject(ASN1decoding_t dec, DisengageReject *val);
static int ASN1CALL ASN1Dec_InfoRequestAck(ASN1decoding_t dec, InfoRequestAck *val);
static int ASN1CALL ASN1Dec_InfoRequestNak(ASN1decoding_t dec, InfoRequestNak *val);
static int ASN1CALL ASN1Dec_H225NonStandardMessage(ASN1decoding_t dec, H225NonStandardMessage *val);
static int ASN1CALL ASN1Dec_RequestInProgress(ASN1decoding_t dec, RequestInProgress *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate(ASN1decoding_t dec, ResourcesAvailableIndicate *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm(ASN1decoding_t dec, ResourcesAvailableConfirm *val);
static int ASN1CALL ASN1Dec_GatekeeperConfirm_integrity(ASN1decoding_t dec, PGatekeeperConfirm_integrity *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_integrity(ASN1decoding_t dec, PGatekeeperRequest_integrity *val);
static int ASN1CALL ASN1Dec_CryptoH323Token_cryptoGKPwdHash(ASN1decoding_t dec, CryptoH323Token_cryptoGKPwdHash *val);
static int ASN1CALL ASN1Dec_NonStandardProtocol_dataRatesSupported(ASN1decoding_t dec, PNonStandardProtocol_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_T120OnlyCaps_dataRatesSupported(ASN1decoding_t dec, PT120OnlyCaps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_VoiceCaps_dataRatesSupported(ASN1decoding_t dec, PVoiceCaps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H324Caps_dataRatesSupported(ASN1decoding_t dec, PH324Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H323Caps_dataRatesSupported(ASN1decoding_t dec, PH323Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H322Caps_dataRatesSupported(ASN1decoding_t dec, PH322Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H321Caps_dataRatesSupported(ASN1decoding_t dec, PH321Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H320Caps_dataRatesSupported(ASN1decoding_t dec, PH320Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H310Caps_dataRatesSupported(ASN1decoding_t dec, PH310Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_h245SecurityCapability(ASN1decoding_t dec, PSetup_UUIE_h245SecurityCapability *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU_nonStandardControl(ASN1decoding_t dec, PH323_UU_PDU_nonStandardControl *val);
static int ASN1CALL ASN1Dec_CryptoToken_cryptoHashedToken(ASN1decoding_t dec, CryptoToken_cryptoHashedToken *val);
static int ASN1CALL ASN1Dec_CryptoToken_cryptoSignedToken(ASN1decoding_t dec, CryptoToken_cryptoSignedToken *val);
static int ASN1CALL ASN1Dec_CryptoToken_cryptoEncryptedToken(ASN1decoding_t dec, CryptoToken_cryptoEncryptedToken *val);
static int ASN1CALL ASN1Dec_CryptoToken(ASN1decoding_t dec, CryptoToken *val);
static int ASN1CALL ASN1Dec_SIGNED_EncodedFastStartToken(ASN1decoding_t dec, SIGNED_EncodedFastStartToken *val);
static int ASN1CALL ASN1Dec_TransportAddress(ASN1decoding_t dec, TransportAddress *val);
static int ASN1CALL ASN1Dec_GatewayInfo(ASN1decoding_t dec, GatewayInfo *val);
static int ASN1CALL ASN1Dec_H310Caps(ASN1decoding_t dec, H310Caps *val);
static int ASN1CALL ASN1Dec_H320Caps(ASN1decoding_t dec, H320Caps *val);
static int ASN1CALL ASN1Dec_H321Caps(ASN1decoding_t dec, H321Caps *val);
static int ASN1CALL ASN1Dec_H322Caps(ASN1decoding_t dec, H322Caps *val);
static int ASN1CALL ASN1Dec_H323Caps(ASN1decoding_t dec, H323Caps *val);
static int ASN1CALL ASN1Dec_H324Caps(ASN1decoding_t dec, H324Caps *val);
static int ASN1CALL ASN1Dec_VoiceCaps(ASN1decoding_t dec, VoiceCaps *val);
static int ASN1CALL ASN1Dec_T120OnlyCaps(ASN1decoding_t dec, T120OnlyCaps *val);
static int ASN1CALL ASN1Dec_NonStandardProtocol(ASN1decoding_t dec, NonStandardProtocol *val);
static int ASN1CALL ASN1Dec_McuInfo(ASN1decoding_t dec, McuInfo *val);
static int ASN1CALL ASN1Dec_TerminalInfo(ASN1decoding_t dec, TerminalInfo *val);
static int ASN1CALL ASN1Dec_GatekeeperInfo(ASN1decoding_t dec, GatekeeperInfo *val);
static int ASN1CALL ASN1Dec_PartyNumber(ASN1decoding_t dec, PartyNumber *val);
static int ASN1CALL ASN1Dec_AlternateGK(ASN1decoding_t dec, AlternateGK *val);
static int ASN1CALL ASN1Dec_GatekeeperConfirm(ASN1decoding_t dec, GatekeeperConfirm *val);
static int ASN1CALL ASN1Dec_AdmissionRequest(ASN1decoding_t dec, AdmissionRequest *val);
static int ASN1CALL ASN1Dec_LocationRequest(ASN1decoding_t dec, LocationRequest *val);
static int ASN1CALL ASN1Dec_InfoRequest(ASN1decoding_t dec, InfoRequest *val);
static int ASN1CALL ASN1Dec_TransportChannelInfo(ASN1decoding_t dec, TransportChannelInfo *val);
static int ASN1CALL ASN1Dec_RTPSession(ASN1decoding_t dec, RTPSession *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_data *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_video *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_audio *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq(ASN1decoding_t dec, InfoRequestResponse_perCallInfo_Seq *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_callSignalAddress(ASN1decoding_t dec, PInfoRequestResponse_callSignalAddress *val);
static int ASN1CALL ASN1Dec_AdmissionReject_callSignalAddress(ASN1decoding_t dec, PAdmissionReject_callSignalAddress *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest_callSignalAddress(ASN1decoding_t dec, PUnregistrationRequest_callSignalAddress *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_alternateGatekeeper(ASN1decoding_t dec, PRegistrationConfirm_alternateGatekeeper *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_callSignalAddress(ASN1decoding_t dec, PRegistrationConfirm_callSignalAddress *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_rasAddress(ASN1decoding_t dec, PRegistrationRequest_rasAddress *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_callSignalAddress(ASN1decoding_t dec, PRegistrationRequest_callSignalAddress *val);
static int ASN1CALL ASN1Dec_GatekeeperConfirm_alternateGatekeeper(ASN1decoding_t dec, PGatekeeperConfirm_alternateGatekeeper *val);
static int ASN1CALL ASN1Dec_AltGKInfo_alternateGatekeeper(ASN1decoding_t dec, PAltGKInfo_alternateGatekeeper *val);
static int ASN1CALL ASN1Dec_Endpoint_rasAddress(ASN1decoding_t dec, PEndpoint_rasAddress *val);
static int ASN1CALL ASN1Dec_Endpoint_callSignalAddress(ASN1decoding_t dec, PEndpoint_callSignalAddress *val);
static int ASN1CALL ASN1Dec_EndpointType(ASN1decoding_t dec, EndpointType *val);
static int ASN1CALL ASN1Dec_SupportedProtocols(ASN1decoding_t dec, SupportedProtocols *val);
static int ASN1CALL ASN1Dec_AliasAddress(ASN1decoding_t dec, AliasAddress *val);
static int ASN1CALL ASN1Dec_Endpoint(ASN1decoding_t dec, Endpoint *val);
static int ASN1CALL ASN1Dec_SupportedPrefix(ASN1decoding_t dec, SupportedPrefix *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest(ASN1decoding_t dec, GatekeeperRequest *val);
static int ASN1CALL ASN1Dec_RegistrationRequest(ASN1decoding_t dec, RegistrationRequest *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm(ASN1decoding_t dec, AdmissionConfirm *val);
static int ASN1CALL ASN1Dec_LocationConfirm(ASN1decoding_t dec, LocationConfirm *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse(ASN1decoding_t dec, InfoRequestResponse *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_protocols(ASN1decoding_t dec, PResourcesAvailableIndicate_protocols *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_endpointAlias(ASN1decoding_t dec, PInfoRequestResponse_endpointAlias *val);
static int ASN1CALL ASN1Dec_LocationConfirm_alternateEndpoints(ASN1decoding_t dec, PLocationConfirm_alternateEndpoints *val);
static int ASN1CALL ASN1Dec_LocationConfirm_remoteExtensionAddress(ASN1decoding_t dec, PLocationConfirm_remoteExtensionAddress *val);
static int ASN1CALL ASN1Dec_LocationConfirm_destExtraCallInfo(ASN1decoding_t dec, PLocationConfirm_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_LocationConfirm_destinationInfo(ASN1decoding_t dec, PLocationConfirm_destinationInfo *val);
static int ASN1CALL ASN1Dec_LocationRequest_sourceInfo(ASN1decoding_t dec, PLocationRequest_sourceInfo *val);
static int ASN1CALL ASN1Dec_LocationRequest_destinationInfo(ASN1decoding_t dec, PLocationRequest_destinationInfo *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_alternateEndpoints(ASN1decoding_t dec, PAdmissionConfirm_alternateEndpoints *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_remoteExtensionAddress(ASN1decoding_t dec, PAdmissionConfirm_remoteExtensionAddress *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_destExtraCallInfo(ASN1decoding_t dec, PAdmissionConfirm_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_destinationInfo(ASN1decoding_t dec, PAdmissionConfirm_destinationInfo *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_destAlternatives(ASN1decoding_t dec, PAdmissionRequest_destAlternatives *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_srcAlternatives(ASN1decoding_t dec, PAdmissionRequest_srcAlternatives *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_srcInfo(ASN1decoding_t dec, PAdmissionRequest_srcInfo *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_destExtraCallInfo(ASN1decoding_t dec, PAdmissionRequest_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_destinationInfo(ASN1decoding_t dec, PAdmissionRequest_destinationInfo *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest_alternateEndpoints(ASN1decoding_t dec, PUnregistrationRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest_endpointAlias(ASN1decoding_t dec, PUnregistrationRequest_endpointAlias *val);
static int ASN1CALL ASN1Dec_RegistrationRejectReason_duplicateAlias(ASN1decoding_t dec, PRegistrationRejectReason_duplicateAlias *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_terminalAlias(ASN1decoding_t dec, PRegistrationConfirm_terminalAlias *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_alternateEndpoints(ASN1decoding_t dec, PRegistrationRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_terminalAlias(ASN1decoding_t dec, PRegistrationRequest_terminalAlias *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_alternateEndpoints(ASN1decoding_t dec, PGatekeeperRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_endpointAlias(ASN1decoding_t dec, PGatekeeperRequest_endpointAlias *val);
static int ASN1CALL ASN1Dec_CryptoH323Token_cryptoEPPwdHash(ASN1decoding_t dec, CryptoH323Token_cryptoEPPwdHash *val);
static int ASN1CALL ASN1Dec_Endpoint_destExtraCallInfo(ASN1decoding_t dec, PEndpoint_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_Endpoint_remoteExtensionAddress(ASN1decoding_t dec, PEndpoint_remoteExtensionAddress *val);
static int ASN1CALL ASN1Dec_Endpoint_aliasAddress(ASN1decoding_t dec, PEndpoint_aliasAddress *val);
static int ASN1CALL ASN1Dec_NonStandardProtocol_supportedPrefixes(ASN1decoding_t dec, PNonStandardProtocol_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_T120OnlyCaps_supportedPrefixes(ASN1decoding_t dec, PT120OnlyCaps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_VoiceCaps_supportedPrefixes(ASN1decoding_t dec, PVoiceCaps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H324Caps_supportedPrefixes(ASN1decoding_t dec, PH324Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H323Caps_supportedPrefixes(ASN1decoding_t dec, PH323Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H322Caps_supportedPrefixes(ASN1decoding_t dec, PH322Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H321Caps_supportedPrefixes(ASN1decoding_t dec, PH321Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H320Caps_supportedPrefixes(ASN1decoding_t dec, PH320Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H310Caps_supportedPrefixes(ASN1decoding_t dec, PH310Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_GatewayInfo_protocol(ASN1decoding_t dec, PGatewayInfo_protocol *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_destExtraCallInfo(ASN1decoding_t dec, PFacility_UUIE_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_alternativeAliasAddress(ASN1decoding_t dec, PFacility_UUIE_alternativeAliasAddress *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCallInfo(ASN1decoding_t dec, PSetup_UUIE_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_destinationAddress(ASN1decoding_t dec, PSetup_UUIE_destinationAddress *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_sourceAddress(ASN1decoding_t dec, PSetup_UUIE_sourceAddress *val);
static int ASN1CALL ASN1Dec_Alerting_UUIE(ASN1decoding_t dec, Alerting_UUIE *val);
static int ASN1CALL ASN1Dec_CallProceeding_UUIE(ASN1decoding_t dec, CallProceeding_UUIE *val);
static int ASN1CALL ASN1Dec_Connect_UUIE(ASN1decoding_t dec, Connect_UUIE *val);
static int ASN1CALL ASN1Dec_Setup_UUIE(ASN1decoding_t dec, Setup_UUIE *val);
static int ASN1CALL ASN1Dec_Facility_UUIE(ASN1decoding_t dec, Facility_UUIE *val);
static int ASN1CALL ASN1Dec_ConferenceList(ASN1decoding_t dec, ConferenceList *val);
static int ASN1CALL ASN1Dec_Progress_UUIE(ASN1decoding_t dec, Progress_UUIE *val);
static int ASN1CALL ASN1Dec_CryptoH323Token(ASN1decoding_t dec, CryptoH323Token *val);
static int ASN1CALL ASN1Dec_RasMessage(ASN1decoding_t dec, RasMessage *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_cryptoTokens(ASN1decoding_t dec, PResourcesAvailableConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_cryptoTokens(ASN1decoding_t dec, PResourcesAvailableIndicate_cryptoTokens *val);
static int ASN1CALL ASN1Dec_RequestInProgress_cryptoTokens(ASN1decoding_t dec, PRequestInProgress_cryptoTokens *val);
static int ASN1CALL ASN1Dec_UnknownMessageResponse_cryptoTokens(ASN1decoding_t dec, PUnknownMessageResponse_cryptoTokens *val);
static int ASN1CALL ASN1Dec_H225NonStandardMessage_cryptoTokens(ASN1decoding_t dec, PH225NonStandardMessage_cryptoTokens *val);
static int ASN1CALL ASN1Dec_InfoRequestNak_cryptoTokens(ASN1decoding_t dec, PInfoRequestNak_cryptoTokens *val);
static int ASN1CALL ASN1Dec_InfoRequestAck_cryptoTokens(ASN1decoding_t dec, PInfoRequestAck_cryptoTokens *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_cryptoTokens(ASN1decoding_t dec, PInfoRequestResponse_cryptoTokens *val);
static int ASN1CALL ASN1Dec_InfoRequest_cryptoTokens(ASN1decoding_t dec, PInfoRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_DisengageReject_cryptoTokens(ASN1decoding_t dec, PDisengageReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_DisengageConfirm_cryptoTokens(ASN1decoding_t dec, PDisengageConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_DisengageRequest_cryptoTokens(ASN1decoding_t dec, PDisengageRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_LocationReject_cryptoTokens(ASN1decoding_t dec, PLocationReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_LocationConfirm_cryptoTokens(ASN1decoding_t dec, PLocationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_LocationRequest_cryptoTokens(ASN1decoding_t dec, PLocationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_BandwidthReject_cryptoTokens(ASN1decoding_t dec, PBandwidthReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_BandwidthConfirm_cryptoTokens(ASN1decoding_t dec, PBandwidthConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_BandwidthRequest_cryptoTokens(ASN1decoding_t dec, PBandwidthRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_AdmissionReject_cryptoTokens(ASN1decoding_t dec, PAdmissionReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_cryptoTokens(ASN1decoding_t dec, PAdmissionConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_cryptoTokens(ASN1decoding_t dec, PAdmissionRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_UnregistrationReject_cryptoTokens(ASN1decoding_t dec, PUnregistrationReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_UnregistrationConfirm_cryptoTokens(ASN1decoding_t dec, PUnregistrationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest_cryptoTokens(ASN1decoding_t dec, PUnregistrationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_RegistrationReject_cryptoTokens(ASN1decoding_t dec, PRegistrationReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_cryptoTokens(ASN1decoding_t dec, PRegistrationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_cryptoTokens(ASN1decoding_t dec, PRegistrationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_GatekeeperReject_cryptoTokens(ASN1decoding_t dec, PGatekeeperReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_GatekeeperConfirm_cryptoTokens(ASN1decoding_t dec, PGatekeeperConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_cryptoTokens(ASN1decoding_t dec, PGatekeeperRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Endpoint_cryptoTokens(ASN1decoding_t dec, PEndpoint_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Progress_UUIE_cryptoTokens(ASN1decoding_t dec, PProgress_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_conferences(ASN1decoding_t dec, PFacility_UUIE_conferences *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_cryptoTokens(ASN1decoding_t dec, PFacility_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_cryptoTokens(ASN1decoding_t dec, PSetup_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Connect_UUIE_cryptoTokens(ASN1decoding_t dec, PConnect_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_CallProceeding_UUIE_cryptoTokens(ASN1decoding_t dec, PCallProceeding_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Alerting_UUIE_cryptoTokens(ASN1decoding_t dec, PAlerting_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU_h323_message_body(ASN1decoding_t dec, H323_UU_PDU_h323_message_body *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU(ASN1decoding_t dec, H323_UU_PDU *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(ASN1decoding_t dec, InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_pdu *val);
static int ASN1CALL ASN1Dec_H323_UserInformation(ASN1decoding_t dec, H323_UserInformation *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val);
static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route(PTransportAddress_ipSourceRoute_route *val);
static void ASN1CALL ASN1Free_RTPSession_associatedSessionIds(PRTPSession_associatedSessionIds *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_algorithmOIDs(PGatekeeperRequest_algorithmOIDs *val);
static void ASN1CALL ASN1Free_TransportAddress_ip6Address(TransportAddress_ip6Address *val);
static void ASN1CALL ASN1Free_TransportAddress_ipxAddress(TransportAddress_ipxAddress *val);
static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute(TransportAddress_ipSourceRoute *val);
static void ASN1CALL ASN1Free_TransportAddress_ipAddress(TransportAddress_ipAddress *val);
static void ASN1CALL ASN1Free_Progress_UUIE_fastStart(PProgress_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_Facility_UUIE_fastStart(PFacility_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_Setup_UUIE_fastStart(PSetup_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCRV(PSetup_UUIE_destExtraCRV *val);
static void ASN1CALL ASN1Free_Connect_UUIE_fastStart(PConnect_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_CallProceeding_UUIE_fastStart(PCallProceeding_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_Alerting_UUIE_fastStart(PAlerting_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_H323_UU_PDU_h245Control(PH323_UU_PDU_h245Control *val);
static void ASN1CALL ASN1Free_H323_UU_PDU_h4501SupplementaryService(PH323_UU_PDU_h4501SupplementaryService *val);
static void ASN1CALL ASN1Free_H323_UserInformation_user_data(H323_UserInformation_user_data *val);
static void ASN1CALL ASN1Free_H235NonStandardParameter(H235NonStandardParameter *val);
static void ASN1CALL ASN1Free_DHset(DHset *val);
static void ASN1CALL ASN1Free_TypedCertificate(TypedCertificate *val);
static void ASN1CALL ASN1Free_AuthenticationMechanism(AuthenticationMechanism *val);
static void ASN1CALL ASN1Free_ClearToken(ClearToken *val);
static void ASN1CALL ASN1Free_Params(Params *val);
static void ASN1CALL ASN1Free_EncodedGeneralToken(EncodedGeneralToken *val);
static void ASN1CALL ASN1Free_PwdCertToken(PwdCertToken *val);
static void ASN1CALL ASN1Free_EncodedPwdCertToken(EncodedPwdCertToken *val);
static void ASN1CALL ASN1Free_H225NonStandardIdentifier(H225NonStandardIdentifier *val);
static void ASN1CALL ASN1Free_AltGKInfo(AltGKInfo *val);
static void ASN1CALL ASN1Free_CallIdentifier(CallIdentifier *val);
static void ASN1CALL ASN1Free_ICV(ICV *val);
static void ASN1CALL ASN1Free_RegistrationRejectReason(RegistrationRejectReason *val);
static void ASN1CALL ASN1Free_UnknownMessageResponse(UnknownMessageResponse *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens(PInfoRequestResponse_perCallInfo_Seq_tokens *val);
static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_tokens(PResourcesAvailableConfirm_tokens *val);
static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_tokens(PResourcesAvailableIndicate_tokens *val);
static void ASN1CALL ASN1Free_RequestInProgress_tokens(PRequestInProgress_tokens *val);
static void ASN1CALL ASN1Free_UnknownMessageResponse_tokens(PUnknownMessageResponse_tokens *val);
static void ASN1CALL ASN1Free_H225NonStandardMessage_tokens(PH225NonStandardMessage_tokens *val);
static void ASN1CALL ASN1Free_InfoRequestNak_tokens(PInfoRequestNak_tokens *val);
static void ASN1CALL ASN1Free_InfoRequestAck_tokens(PInfoRequestAck_tokens *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_tokens(PInfoRequestResponse_tokens *val);
static void ASN1CALL ASN1Free_InfoRequest_tokens(PInfoRequest_tokens *val);
static void ASN1CALL ASN1Free_DisengageReject_tokens(PDisengageReject_tokens *val);
static void ASN1CALL ASN1Free_DisengageConfirm_tokens(PDisengageConfirm_tokens *val);
static void ASN1CALL ASN1Free_DisengageRequest_tokens(PDisengageRequest_tokens *val);
static void ASN1CALL ASN1Free_LocationReject_tokens(PLocationReject_tokens *val);
static void ASN1CALL ASN1Free_LocationConfirm_tokens(PLocationConfirm_tokens *val);
static void ASN1CALL ASN1Free_LocationRequest_tokens(PLocationRequest_tokens *val);
static void ASN1CALL ASN1Free_BandwidthReject_tokens(PBandwidthReject_tokens *val);
static void ASN1CALL ASN1Free_BandwidthConfirm_tokens(PBandwidthConfirm_tokens *val);
static void ASN1CALL ASN1Free_BandwidthRequest_tokens(PBandwidthRequest_tokens *val);
static void ASN1CALL ASN1Free_AdmissionReject_tokens(PAdmissionReject_tokens *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_tokens(PAdmissionConfirm_tokens *val);
static void ASN1CALL ASN1Free_AdmissionRequest_tokens(PAdmissionRequest_tokens *val);
static void ASN1CALL ASN1Free_UnregistrationReject_tokens(PUnregistrationReject_tokens *val);
static void ASN1CALL ASN1Free_UnregistrationConfirm_tokens(PUnregistrationConfirm_tokens *val);
static void ASN1CALL ASN1Free_UnregistrationRequest_tokens(PUnregistrationRequest_tokens *val);
static void ASN1CALL ASN1Free_RegistrationReject_tokens(PRegistrationReject_tokens *val);
static void ASN1CALL ASN1Free_RegistrationConfirm_tokens(PRegistrationConfirm_tokens *val);
static void ASN1CALL ASN1Free_RegistrationRequest_tokens(PRegistrationRequest_tokens *val);
static void ASN1CALL ASN1Free_GatekeeperReject_tokens(PGatekeeperReject_tokens *val);
static void ASN1CALL ASN1Free_GatekeeperConfirm_tokens(PGatekeeperConfirm_tokens *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_authenticationCapability(PGatekeeperRequest_authenticationCapability *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_tokens(PGatekeeperRequest_tokens *val);
static void ASN1CALL ASN1Free_Endpoint_tokens(PEndpoint_tokens *val);
static void ASN1CALL ASN1Free_Progress_UUIE_tokens(PProgress_UUIE_tokens *val);
static void ASN1CALL ASN1Free_Facility_UUIE_tokens(PFacility_UUIE_tokens *val);
static void ASN1CALL ASN1Free_Setup_UUIE_tokens(PSetup_UUIE_tokens *val);
static void ASN1CALL ASN1Free_Connect_UUIE_tokens(PConnect_UUIE_tokens *val);
static void ASN1CALL ASN1Free_CallProceeding_UUIE_tokens(PCallProceeding_UUIE_tokens *val);
static void ASN1CALL ASN1Free_Alerting_UUIE_tokens(PAlerting_UUIE_tokens *val);
static void ASN1CALL ASN1Free_SIGNED_EncodedGeneralToken(SIGNED_EncodedGeneralToken *val);
static void ASN1CALL ASN1Free_ENCRYPTED(ENCRYPTED *val);
static void ASN1CALL ASN1Free_HASHED(HASHED *val);
static void ASN1CALL ASN1Free_SIGNED_EncodedPwdCertToken(SIGNED_EncodedPwdCertToken *val);
static void ASN1CALL ASN1Free_Information_UUIE(Information_UUIE *val);
static void ASN1CALL ASN1Free_ReleaseComplete_UUIE(ReleaseComplete_UUIE *val);
static void ASN1CALL ASN1Free_VendorIdentifier(VendorIdentifier *val);
static void ASN1CALL ASN1Free_H225NonStandardParameter(H225NonStandardParameter *val);
static void ASN1CALL ASN1Free_PublicPartyNumber(PublicPartyNumber *val);
static void ASN1CALL ASN1Free_PrivatePartyNumber(PrivatePartyNumber *val);
static void ASN1CALL ASN1Free_SecurityServiceMode(SecurityServiceMode *val);
static void ASN1CALL ASN1Free_SecurityCapabilities(SecurityCapabilities *val);
static void ASN1CALL ASN1Free_H245Security(H245Security *val);
static void ASN1CALL ASN1Free_EncryptIntAlg(EncryptIntAlg *val);
static void ASN1CALL ASN1Free_NonIsoIntegrityMechanism(NonIsoIntegrityMechanism *val);
static void ASN1CALL ASN1Free_IntegrityMechanism(IntegrityMechanism *val);
#define ASN1Free_FastStartToken(x)     
static void ASN1CALL ASN1Free_EncodedFastStartToken(EncodedFastStartToken *val);
static void ASN1CALL ASN1Free_DataRate(DataRate *val);
static void ASN1CALL ASN1Free_GatekeeperReject(GatekeeperReject *val);
static void ASN1CALL ASN1Free_RegistrationConfirm(RegistrationConfirm *val);
static void ASN1CALL ASN1Free_RegistrationReject(RegistrationReject *val);
static void ASN1CALL ASN1Free_UnregistrationRequest(UnregistrationRequest *val);
static void ASN1CALL ASN1Free_UnregistrationConfirm(UnregistrationConfirm *val);
static void ASN1CALL ASN1Free_UnregistrationReject(UnregistrationReject *val);
static void ASN1CALL ASN1Free_AdmissionReject(AdmissionReject *val);
static void ASN1CALL ASN1Free_BandwidthRequest(BandwidthRequest *val);
static void ASN1CALL ASN1Free_BandwidthConfirm(BandwidthConfirm *val);
static void ASN1CALL ASN1Free_BandwidthReject(BandwidthReject *val);
static void ASN1CALL ASN1Free_LocationReject(LocationReject *val);
static void ASN1CALL ASN1Free_DisengageRequest(DisengageRequest *val);
static void ASN1CALL ASN1Free_DisengageConfirm(DisengageConfirm *val);
static void ASN1CALL ASN1Free_DisengageReject(DisengageReject *val);
static void ASN1CALL ASN1Free_InfoRequestAck(InfoRequestAck *val);
static void ASN1CALL ASN1Free_InfoRequestNak(InfoRequestNak *val);
static void ASN1CALL ASN1Free_H225NonStandardMessage(H225NonStandardMessage *val);
static void ASN1CALL ASN1Free_RequestInProgress(RequestInProgress *val);
static void ASN1CALL ASN1Free_ResourcesAvailableIndicate(ResourcesAvailableIndicate *val);
static void ASN1CALL ASN1Free_ResourcesAvailableConfirm(ResourcesAvailableConfirm *val);
static void ASN1CALL ASN1Free_GatekeeperConfirm_integrity(PGatekeeperConfirm_integrity *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_integrity(PGatekeeperRequest_integrity *val);
static void ASN1CALL ASN1Free_CryptoH323Token_cryptoGKPwdHash(CryptoH323Token_cryptoGKPwdHash *val);
static void ASN1CALL ASN1Free_NonStandardProtocol_dataRatesSupported(PNonStandardProtocol_dataRatesSupported *val);
static void ASN1CALL ASN1Free_T120OnlyCaps_dataRatesSupported(PT120OnlyCaps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_VoiceCaps_dataRatesSupported(PVoiceCaps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H324Caps_dataRatesSupported(PH324Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H323Caps_dataRatesSupported(PH323Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H322Caps_dataRatesSupported(PH322Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H321Caps_dataRatesSupported(PH321Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H320Caps_dataRatesSupported(PH320Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H310Caps_dataRatesSupported(PH310Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_Setup_UUIE_h245SecurityCapability(PSetup_UUIE_h245SecurityCapability *val);
static void ASN1CALL ASN1Free_H323_UU_PDU_nonStandardControl(PH323_UU_PDU_nonStandardControl *val);
static void ASN1CALL ASN1Free_CryptoToken_cryptoHashedToken(CryptoToken_cryptoHashedToken *val);
static void ASN1CALL ASN1Free_CryptoToken_cryptoSignedToken(CryptoToken_cryptoSignedToken *val);
static void ASN1CALL ASN1Free_CryptoToken_cryptoEncryptedToken(CryptoToken_cryptoEncryptedToken *val);
static void ASN1CALL ASN1Free_CryptoToken(CryptoToken *val);
static void ASN1CALL ASN1Free_SIGNED_EncodedFastStartToken(SIGNED_EncodedFastStartToken *val);
static void ASN1CALL ASN1Free_TransportAddress(TransportAddress *val);
static void ASN1CALL ASN1Free_GatewayInfo(GatewayInfo *val);
static void ASN1CALL ASN1Free_H310Caps(H310Caps *val);
static void ASN1CALL ASN1Free_H320Caps(H320Caps *val);
static void ASN1CALL ASN1Free_H321Caps(H321Caps *val);
static void ASN1CALL ASN1Free_H322Caps(H322Caps *val);
static void ASN1CALL ASN1Free_H323Caps(H323Caps *val);
static void ASN1CALL ASN1Free_H324Caps(H324Caps *val);
static void ASN1CALL ASN1Free_VoiceCaps(VoiceCaps *val);
static void ASN1CALL ASN1Free_T120OnlyCaps(T120OnlyCaps *val);
static void ASN1CALL ASN1Free_NonStandardProtocol(NonStandardProtocol *val);
static void ASN1CALL ASN1Free_McuInfo(McuInfo *val);
static void ASN1CALL ASN1Free_TerminalInfo(TerminalInfo *val);
static void ASN1CALL ASN1Free_GatekeeperInfo(GatekeeperInfo *val);
static void ASN1CALL ASN1Free_PartyNumber(PartyNumber *val);
static void ASN1CALL ASN1Free_AlternateGK(AlternateGK *val);
static void ASN1CALL ASN1Free_GatekeeperConfirm(GatekeeperConfirm *val);
static void ASN1CALL ASN1Free_AdmissionRequest(AdmissionRequest *val);
static void ASN1CALL ASN1Free_LocationRequest(LocationRequest *val);
static void ASN1CALL ASN1Free_InfoRequest(InfoRequest *val);
static void ASN1CALL ASN1Free_TransportChannelInfo(TransportChannelInfo *val);
static void ASN1CALL ASN1Free_RTPSession(RTPSession *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_data(PInfoRequestResponse_perCallInfo_Seq_data *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_video(PInfoRequestResponse_perCallInfo_Seq_video *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio(PInfoRequestResponse_perCallInfo_Seq_audio *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq(InfoRequestResponse_perCallInfo_Seq *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo(PInfoRequestResponse_perCallInfo *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_callSignalAddress(PInfoRequestResponse_callSignalAddress *val);
static void ASN1CALL ASN1Free_AdmissionReject_callSignalAddress(PAdmissionReject_callSignalAddress *val);
static void ASN1CALL ASN1Free_UnregistrationRequest_callSignalAddress(PUnregistrationRequest_callSignalAddress *val);
static void ASN1CALL ASN1Free_RegistrationConfirm_alternateGatekeeper(PRegistrationConfirm_alternateGatekeeper *val);
static void ASN1CALL ASN1Free_RegistrationConfirm_callSignalAddress(PRegistrationConfirm_callSignalAddress *val);
static void ASN1CALL ASN1Free_RegistrationRequest_rasAddress(PRegistrationRequest_rasAddress *val);
static void ASN1CALL ASN1Free_RegistrationRequest_callSignalAddress(PRegistrationRequest_callSignalAddress *val);
static void ASN1CALL ASN1Free_GatekeeperConfirm_alternateGatekeeper(PGatekeeperConfirm_alternateGatekeeper *val);
static void ASN1CALL ASN1Free_AltGKInfo_alternateGatekeeper(PAltGKInfo_alternateGatekeeper *val);
static void ASN1CALL ASN1Free_Endpoint_rasAddress(PEndpoint_rasAddress *val);
static void ASN1CALL ASN1Free_Endpoint_callSignalAddress(PEndpoint_callSignalAddress *val);
static void ASN1CALL ASN1Free_EndpointType(EndpointType *val);
static void ASN1CALL ASN1Free_SupportedProtocols(SupportedProtocols *val);
static void ASN1CALL ASN1Free_AliasAddress(AliasAddress *val);
static void ASN1CALL ASN1Free_Endpoint(Endpoint *val);
static void ASN1CALL ASN1Free_SupportedPrefix(SupportedPrefix *val);
static void ASN1CALL ASN1Free_GatekeeperRequest(GatekeeperRequest *val);
static void ASN1CALL ASN1Free_RegistrationRequest(RegistrationRequest *val);
static void ASN1CALL ASN1Free_AdmissionConfirm(AdmissionConfirm *val);
static void ASN1CALL ASN1Free_LocationConfirm(LocationConfirm *val);
static void ASN1CALL ASN1Free_InfoRequestResponse(InfoRequestResponse *val);
static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_protocols(PResourcesAvailableIndicate_protocols *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_endpointAlias(PInfoRequestResponse_endpointAlias *val);
static void ASN1CALL ASN1Free_LocationConfirm_alternateEndpoints(PLocationConfirm_alternateEndpoints *val);
static void ASN1CALL ASN1Free_LocationConfirm_remoteExtensionAddress(PLocationConfirm_remoteExtensionAddress *val);
static void ASN1CALL ASN1Free_LocationConfirm_destExtraCallInfo(PLocationConfirm_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_LocationConfirm_destinationInfo(PLocationConfirm_destinationInfo *val);
static void ASN1CALL ASN1Free_LocationRequest_sourceInfo(PLocationRequest_sourceInfo *val);
static void ASN1CALL ASN1Free_LocationRequest_destinationInfo(PLocationRequest_destinationInfo *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_alternateEndpoints(PAdmissionConfirm_alternateEndpoints *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_remoteExtensionAddress(PAdmissionConfirm_remoteExtensionAddress *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_destExtraCallInfo(PAdmissionConfirm_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_destinationInfo(PAdmissionConfirm_destinationInfo *val);
static void ASN1CALL ASN1Free_AdmissionRequest_destAlternatives(PAdmissionRequest_destAlternatives *val);
static void ASN1CALL ASN1Free_AdmissionRequest_srcAlternatives(PAdmissionRequest_srcAlternatives *val);
static void ASN1CALL ASN1Free_AdmissionRequest_srcInfo(PAdmissionRequest_srcInfo *val);
static void ASN1CALL ASN1Free_AdmissionRequest_destExtraCallInfo(PAdmissionRequest_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_AdmissionRequest_destinationInfo(PAdmissionRequest_destinationInfo *val);
static void ASN1CALL ASN1Free_UnregistrationRequest_alternateEndpoints(PUnregistrationRequest_alternateEndpoints *val);
static void ASN1CALL ASN1Free_UnregistrationRequest_endpointAlias(PUnregistrationRequest_endpointAlias *val);
static void ASN1CALL ASN1Free_RegistrationRejectReason_duplicateAlias(PRegistrationRejectReason_duplicateAlias *val);
static void ASN1CALL ASN1Free_RegistrationConfirm_terminalAlias(PRegistrationConfirm_terminalAlias *val);
static void ASN1CALL ASN1Free_RegistrationRequest_alternateEndpoints(PRegistrationRequest_alternateEndpoints *val);
static void ASN1CALL ASN1Free_RegistrationRequest_terminalAlias(PRegistrationRequest_terminalAlias *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_alternateEndpoints(PGatekeeperRequest_alternateEndpoints *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_endpointAlias(PGatekeeperRequest_endpointAlias *val);
static void ASN1CALL ASN1Free_CryptoH323Token_cryptoEPPwdHash(CryptoH323Token_cryptoEPPwdHash *val);
static void ASN1CALL ASN1Free_Endpoint_destExtraCallInfo(PEndpoint_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_Endpoint_remoteExtensionAddress(PEndpoint_remoteExtensionAddress *val);
static void ASN1CALL ASN1Free_Endpoint_aliasAddress(PEndpoint_aliasAddress *val);
static void ASN1CALL ASN1Free_NonStandardProtocol_supportedPrefixes(PNonStandardProtocol_supportedPrefixes *val);
static void ASN1CALL ASN1Free_T120OnlyCaps_supportedPrefixes(PT120OnlyCaps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_VoiceCaps_supportedPrefixes(PVoiceCaps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H324Caps_supportedPrefixes(PH324Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H323Caps_supportedPrefixes(PH323Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H322Caps_supportedPrefixes(PH322Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H321Caps_supportedPrefixes(PH321Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H320Caps_supportedPrefixes(PH320Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H310Caps_supportedPrefixes(PH310Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_GatewayInfo_protocol(PGatewayInfo_protocol *val);
static void ASN1CALL ASN1Free_Facility_UUIE_destExtraCallInfo(PFacility_UUIE_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_Facility_UUIE_alternativeAliasAddress(PFacility_UUIE_alternativeAliasAddress *val);
static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCallInfo(PSetup_UUIE_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_Setup_UUIE_destinationAddress(PSetup_UUIE_destinationAddress *val);
static void ASN1CALL ASN1Free_Setup_UUIE_sourceAddress(PSetup_UUIE_sourceAddress *val);
static void ASN1CALL ASN1Free_Alerting_UUIE(Alerting_UUIE *val);
static void ASN1CALL ASN1Free_CallProceeding_UUIE(CallProceeding_UUIE *val);
static void ASN1CALL ASN1Free_Connect_UUIE(Connect_UUIE *val);
static void ASN1CALL ASN1Free_Setup_UUIE(Setup_UUIE *val);
static void ASN1CALL ASN1Free_Facility_UUIE(Facility_UUIE *val);
static void ASN1CALL ASN1Free_ConferenceList(ConferenceList *val);
static void ASN1CALL ASN1Free_Progress_UUIE(Progress_UUIE *val);
static void ASN1CALL ASN1Free_CryptoH323Token(CryptoH323Token *val);
static void ASN1CALL ASN1Free_RasMessage(RasMessage *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val);
static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_cryptoTokens(PResourcesAvailableConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_cryptoTokens(PResourcesAvailableIndicate_cryptoTokens *val);
static void ASN1CALL ASN1Free_RequestInProgress_cryptoTokens(PRequestInProgress_cryptoTokens *val);
static void ASN1CALL ASN1Free_UnknownMessageResponse_cryptoTokens(PUnknownMessageResponse_cryptoTokens *val);
static void ASN1CALL ASN1Free_H225NonStandardMessage_cryptoTokens(PH225NonStandardMessage_cryptoTokens *val);
static void ASN1CALL ASN1Free_InfoRequestNak_cryptoTokens(PInfoRequestNak_cryptoTokens *val);
static void ASN1CALL ASN1Free_InfoRequestAck_cryptoTokens(PInfoRequestAck_cryptoTokens *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_cryptoTokens(PInfoRequestResponse_cryptoTokens *val);
static void ASN1CALL ASN1Free_InfoRequest_cryptoTokens(PInfoRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_DisengageReject_cryptoTokens(PDisengageReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_DisengageConfirm_cryptoTokens(PDisengageConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_DisengageRequest_cryptoTokens(PDisengageRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_LocationReject_cryptoTokens(PLocationReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_LocationConfirm_cryptoTokens(PLocationConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_LocationRequest_cryptoTokens(PLocationRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_BandwidthReject_cryptoTokens(PBandwidthReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_BandwidthConfirm_cryptoTokens(PBandwidthConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_BandwidthRequest_cryptoTokens(PBandwidthRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_AdmissionReject_cryptoTokens(PAdmissionReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_cryptoTokens(PAdmissionConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_AdmissionRequest_cryptoTokens(PAdmissionRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_UnregistrationReject_cryptoTokens(PUnregistrationReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_UnregistrationConfirm_cryptoTokens(PUnregistrationConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_UnregistrationRequest_cryptoTokens(PUnregistrationRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_RegistrationReject_cryptoTokens(PRegistrationReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_RegistrationConfirm_cryptoTokens(PRegistrationConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_RegistrationRequest_cryptoTokens(PRegistrationRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_GatekeeperReject_cryptoTokens(PGatekeeperReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_GatekeeperConfirm_cryptoTokens(PGatekeeperConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_cryptoTokens(PGatekeeperRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_Endpoint_cryptoTokens(PEndpoint_cryptoTokens *val);
static void ASN1CALL ASN1Free_Progress_UUIE_cryptoTokens(PProgress_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_Facility_UUIE_conferences(PFacility_UUIE_conferences *val);
static void ASN1CALL ASN1Free_Facility_UUIE_cryptoTokens(PFacility_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_Setup_UUIE_cryptoTokens(PSetup_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_Connect_UUIE_cryptoTokens(PConnect_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_CallProceeding_UUIE_cryptoTokens(PCallProceeding_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_Alerting_UUIE_cryptoTokens(PAlerting_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_H323_UU_PDU_h323_message_body(H323_UU_PDU_h323_message_body *val);
static void ASN1CALL ASN1Free_H323_UU_PDU(H323_UU_PDU *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu(PInfoRequestResponse_perCallInfo_Seq_pdu *val);
static void ASN1CALL ASN1Free_H323_UserInformation(H323_UserInformation *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[2] = {
    (ASN1EncFun_t) ASN1Enc_RasMessage,
    (ASN1EncFun_t) ASN1Enc_H323_UserInformation,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[2] = {
    (ASN1DecFun_t) ASN1Dec_RasMessage,
    (ASN1DecFun_t) ASN1Dec_H323_UserInformation,
};
static const ASN1FreeFun_t freefntab[2] = {
    (ASN1FreeFun_t) ASN1Free_RasMessage,
    (ASN1FreeFun_t) ASN1Free_H323_UserInformation,
};
static const ULONG sizetab[2] = {
    SIZE_H225PP_Module_PDU_0,
    SIZE_H225PP_Module_PDU_1,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL H225PP_Module_Startup(void)
{
    H225PP_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 2, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x35323268);
}

void ASN1CALL H225PP_Module_Cleanup(void)
{
    ASN1_CloseModule(H225PP_Module);
    H225PP_Module = NULL;
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &val->value, 16))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &val->value, 16))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_routing(ASN1encoding_t enc, TransportAddress_ipSourceRoute_routing *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_routing(ASN1decoding_t dec, TransportAddress_ipSourceRoute_routing *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn);
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route(PTransportAddress_ipSourceRoute_route *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn(PTransportAddress_ipSourceRoute_route val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RTPSession_associatedSessionIds(ASN1encoding_t enc, PRTPSession_associatedSessionIds *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RTPSession_associatedSessionIds_ElmFn);
}

static int ASN1CALL ASN1Enc_RTPSession_associatedSessionIds_ElmFn(ASN1encoding_t enc, PRTPSession_associatedSessionIds val)
{
    if (!ASN1PEREncBitVal(enc, 8, val->value - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RTPSession_associatedSessionIds(ASN1decoding_t dec, PRTPSession_associatedSessionIds *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RTPSession_associatedSessionIds_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RTPSession_associatedSessionIds_ElmFn(ASN1decoding_t dec, PRTPSession_associatedSessionIds val)
{
    if (!ASN1PERDecU16Val(dec, 8, &val->value))
	return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_RTPSession_associatedSessionIds(PRTPSession_associatedSessionIds *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RTPSession_associatedSessionIds_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RTPSession_associatedSessionIds_ElmFn(PRTPSession_associatedSessionIds val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_preGrantedARQ(ASN1encoding_t enc, RegistrationConfirm_preGrantedARQ *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->makeCall))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->useGKCallSignalAddressToMakeCall))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->answerCall))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->useGKCallSignalAddressToAnswer))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_preGrantedARQ(ASN1decoding_t dec, RegistrationConfirm_preGrantedARQ *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->makeCall))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->useGKCallSignalAddressToMakeCall))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->answerCall))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->useGKCallSignalAddressToAnswer))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_algorithmOIDs(ASN1encoding_t enc, PGatekeeperRequest_algorithmOIDs *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_algorithmOIDs_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_algorithmOIDs_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_algorithmOIDs val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_algorithmOIDs(ASN1decoding_t dec, PGatekeeperRequest_algorithmOIDs *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_algorithmOIDs_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_algorithmOIDs_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_algorithmOIDs val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_algorithmOIDs(PGatekeeperRequest_algorithmOIDs *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_algorithmOIDs_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_algorithmOIDs_ElmFn(PGatekeeperRequest_algorithmOIDs val)
{
    if (val) {
	ASN1objectidentifier_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ip6Address(ASN1encoding_t enc, TransportAddress_ip6Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ip6Address(ASN1decoding_t dec, TransportAddress_ip6Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ip6Address(TransportAddress_ip6Address *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipxAddress(ASN1encoding_t enc, TransportAddress_ipxAddress *val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->port, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipxAddress(ASN1decoding_t dec, TransportAddress_ipxAddress *val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->port, 2))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipxAddress(TransportAddress_ipxAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute(ASN1encoding_t enc, TransportAddress_ipSourceRoute *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    if (!ASN1Enc_TransportAddress_ipSourceRoute_route(enc, &(val)->route))
	return 0;
    if (!ASN1Enc_TransportAddress_ipSourceRoute_routing(enc, &(val)->routing))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute(ASN1decoding_t dec, TransportAddress_ipSourceRoute *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    if (!ASN1Dec_TransportAddress_ipSourceRoute_route(dec, &(val)->route))
	return 0;
    if (!ASN1Dec_TransportAddress_ipSourceRoute_routing(dec, &(val)->routing))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute(TransportAddress_ipSourceRoute *val)
{
    if (val) {
	ASN1Free_TransportAddress_ipSourceRoute_route(&(val)->route);
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipAddress(ASN1encoding_t enc, TransportAddress_ipAddress *val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipAddress(ASN1decoding_t dec, TransportAddress_ipAddress *val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipAddress(TransportAddress_ipAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_Progress_UUIE_fastStart(ASN1encoding_t enc, PProgress_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Progress_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_Progress_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PProgress_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Progress_UUIE_fastStart(ASN1decoding_t dec, PProgress_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Progress_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Progress_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PProgress_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Progress_UUIE_fastStart(PProgress_UUIE_fastStart *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Progress_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Progress_UUIE_fastStart_ElmFn(PProgress_UUIE_fastStart val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_fastStart(ASN1encoding_t enc, PFacility_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PFacility_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_fastStart(ASN1decoding_t dec, PFacility_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PFacility_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_fastStart(PFacility_UUIE_fastStart *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_fastStart_ElmFn(PFacility_UUIE_fastStart val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_fastStart(ASN1encoding_t enc, PSetup_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PSetup_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_fastStart(ASN1decoding_t dec, PSetup_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PSetup_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_fastStart(PSetup_UUIE_fastStart *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_fastStart_ElmFn(PSetup_UUIE_fastStart val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_conferenceGoal(ASN1encoding_t enc, Setup_UUIE_conferenceGoal *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_conferenceGoal(ASN1decoding_t dec, Setup_UUIE_conferenceGoal *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCRV(ASN1encoding_t enc, PSetup_UUIE_destExtraCRV *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_destExtraCRV_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCRV_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destExtraCRV val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCRV(ASN1decoding_t dec, PSetup_UUIE_destExtraCRV *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_destExtraCRV_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCRV_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destExtraCRV val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCRV(PSetup_UUIE_destExtraCRV *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_destExtraCRV_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCRV_ElmFn(PSetup_UUIE_destExtraCRV val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_Connect_UUIE_fastStart(ASN1encoding_t enc, PConnect_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Connect_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_Connect_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PConnect_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Connect_UUIE_fastStart(ASN1decoding_t dec, PConnect_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Connect_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Connect_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PConnect_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Connect_UUIE_fastStart(PConnect_UUIE_fastStart *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Connect_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Connect_UUIE_fastStart_ElmFn(PConnect_UUIE_fastStart val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_fastStart(ASN1encoding_t enc, PCallProceeding_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CallProceeding_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_fastStart(ASN1decoding_t dec, PCallProceeding_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CallProceeding_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_fastStart(PCallProceeding_UUIE_fastStart *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CallProceeding_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_fastStart_ElmFn(PCallProceeding_UUIE_fastStart val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_fastStart(ASN1encoding_t enc, PAlerting_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Alerting_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_fastStart(ASN1decoding_t dec, PAlerting_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Alerting_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Alerting_UUIE_fastStart(PAlerting_UUIE_fastStart *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Alerting_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Alerting_UUIE_fastStart_ElmFn(PAlerting_UUIE_fastStart val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h245Control(ASN1encoding_t enc, PH323_UU_PDU_h245Control *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H323_UU_PDU_h245Control_ElmFn);
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h245Control_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_h245Control val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h245Control(ASN1decoding_t dec, PH323_UU_PDU_h245Control *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H323_UU_PDU_h245Control_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h245Control_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_h245Control val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h245Control(PH323_UU_PDU_h245Control *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H323_UU_PDU_h245Control_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h245Control_ElmFn(PH323_UU_PDU_h245Control val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h4501SupplementaryService(ASN1encoding_t enc, PH323_UU_PDU_h4501SupplementaryService *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H323_UU_PDU_h4501SupplementaryService_ElmFn);
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h4501SupplementaryService_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_h4501SupplementaryService val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h4501SupplementaryService(ASN1decoding_t dec, PH323_UU_PDU_h4501SupplementaryService *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H323_UU_PDU_h4501SupplementaryService_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h4501SupplementaryService_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_h4501SupplementaryService val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h4501SupplementaryService(PH323_UU_PDU_h4501SupplementaryService *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H323_UU_PDU_h4501SupplementaryService_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h4501SupplementaryService_ElmFn(PH323_UU_PDU_h4501SupplementaryService val)
{
    if (val) {
	ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UserInformation_user_data(ASN1encoding_t enc, H323_UserInformation_user_data *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->protocol_discriminator))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->user_information, 1, 131, 8))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UserInformation_user_data(ASN1decoding_t dec, H323_UserInformation_user_data *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->protocol_discriminator))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->user_information, 1, 131, 8))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323_UserInformation_user_data(H323_UserInformation_user_data *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H235NonStandardParameter(ASN1encoding_t enc, H235NonStandardParameter *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H235NonStandardParameter(ASN1decoding_t dec, H235NonStandardParameter *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H235NonStandardParameter(H235NonStandardParameter *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->nonStandardIdentifier);
	ASN1octetstring_free(&(val)->data);
    }
}

static int ASN1CALL ASN1Enc_DHset(ASN1encoding_t enc, DHset *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, ((val)->halfkey).length))
	return 0;
    if (!ASN1PEREncBits(enc, ((val)->halfkey).length, ((val)->halfkey).value))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, ((val)->modSize).length))
	return 0;
    if (!ASN1PEREncBits(enc, ((val)->modSize).length, ((val)->modSize).value))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, ((val)->generator).length))
	return 0;
    if (!ASN1PEREncBits(enc, ((val)->generator).length, ((val)->generator).value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DHset(ASN1decoding_t dec, DHset *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &((val)->halfkey).length))
	return 0;
    if (!ASN1PERDecBits(dec, ((val)->halfkey).length, &((val)->halfkey).value))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &((val)->modSize).length))
	return 0;
    if (!ASN1PERDecBits(dec, ((val)->modSize).length, &((val)->modSize).value))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &((val)->generator).length))
	return 0;
    if (!ASN1PERDecBits(dec, ((val)->generator).length, &((val)->generator).value))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DHset(DHset *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->halfkey);
	ASN1bitstring_free(&(val)->modSize);
	ASN1bitstring_free(&(val)->generator);
    }
}

static int ASN1CALL ASN1Enc_TypedCertificate(ASN1encoding_t enc, TypedCertificate *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->type))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->certificate))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TypedCertificate(ASN1decoding_t dec, TypedCertificate *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->type))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->certificate))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TypedCertificate(TypedCertificate *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->type);
	ASN1octetstring_free(&(val)->certificate);
    }
}

static int ASN1CALL ASN1Enc_AuthenticationMechanism(ASN1encoding_t enc, AuthenticationMechanism *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Enc_H235NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AuthenticationMechanism(ASN1decoding_t dec, AuthenticationMechanism *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Dec_H235NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AuthenticationMechanism(AuthenticationMechanism *val)
{
    if (val) {
	switch ((val)->choice) {
	case 7:
	    ASN1Free_H235NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ClearToken(ASN1encoding_t enc, ClearToken *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 8, (val)->o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->tokenOID))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->timeStamp - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->timeStamp - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->password).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->password).length, ((val)->password).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_DHset(enc, &(val)->dhkey))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->challenge, 8, 128, 7))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncInteger(enc, (val)->random))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_TypedCertificate(enc, &(val)->certificate))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->generalID).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->generalID).length, ((val)->generalID).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1Enc_H235NonStandardParameter(enc, &(val)->nonStandard))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ClearToken(ASN1decoding_t dec, ClearToken *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 8, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->tokenOID))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->timeStamp))
	    return 0;
	(val)->timeStamp += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->password).length))
	    return 0;
	((val)->password).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->password).length, &((val)->password).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_DHset(dec, &(val)->dhkey))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->challenge, 8, 128, 7))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecInteger(dec, &(val)->random))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_TypedCertificate(dec, &(val)->certificate))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->generalID).length))
	    return 0;
	((val)->generalID).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->generalID).length, &((val)->generalID).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1Dec_H235NonStandardParameter(dec, &(val)->nonStandard))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ClearToken(ClearToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->tokenOID);
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->password);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_DHset(&(val)->dhkey);
	}
	if ((val)->o[0] & 0x10) {
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_TypedCertificate(&(val)->certificate);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1char16string_free(&(val)->generalID);
	}
	if ((val)->o[0] & 0x1) {
	    ASN1Free_H235NonStandardParameter(&(val)->nonStandard);
	}
    }
}

static int ASN1CALL ASN1Enc_Params(ASN1encoding_t enc, Params *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncInteger(enc, (val)->ranInt))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->iv8, 8))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Params(ASN1decoding_t dec, Params *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecInteger(dec, &(val)->ranInt))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->iv8, 8))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Params(Params *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_EncodedGeneralToken(ASN1encoding_t enc, EncodedGeneralToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->id))
	return 0;
    if (!ASN1Enc_ClearToken(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncodedGeneralToken(ASN1decoding_t dec, EncodedGeneralToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->id))
	return 0;
    if (!ASN1Dec_ClearToken(dec, &(val)->type))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncodedGeneralToken(EncodedGeneralToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->id);
	ASN1Free_ClearToken(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_PwdCertToken(ASN1encoding_t enc, PwdCertToken *val)
{
    if (!ASN1Enc_ClearToken(enc, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PwdCertToken(ASN1decoding_t dec, PwdCertToken *val)
{
    if (!ASN1Dec_ClearToken(dec, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PwdCertToken(PwdCertToken *val)
{
    if (val) {
	ASN1Free_ClearToken(val);
    }
}

static int ASN1CALL ASN1Enc_EncodedPwdCertToken(ASN1encoding_t enc, EncodedPwdCertToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->id))
	return 0;
    if (!ASN1Enc_PwdCertToken(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncodedPwdCertToken(ASN1decoding_t dec, EncodedPwdCertToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->id))
	return 0;
    if (!ASN1Dec_PwdCertToken(dec, &(val)->type))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncodedPwdCertToken(EncodedPwdCertToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->id);
	ASN1Free_PwdCertToken(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_ReleaseCompleteReason(ASN1encoding_t enc, ReleaseCompleteReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 12))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ReleaseCompleteReason(ASN1decoding_t dec, ReleaseCompleteReason *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 12))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_FacilityReason(ASN1encoding_t enc, FacilityReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FacilityReason(ASN1decoding_t dec, FacilityReason *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H221NonStandard(ASN1encoding_t enc, H221NonStandard *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35CountryCode))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35Extension))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->manufacturerCode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H221NonStandard(ASN1decoding_t dec, H221NonStandard *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35CountryCode))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35Extension))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->manufacturerCode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H225NonStandardIdentifier(ASN1encoding_t enc, H225NonStandardIdentifier *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H221NonStandard(enc, &(val)->u.h221NonStandard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardIdentifier(ASN1decoding_t dec, H225NonStandardIdentifier *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H221NonStandard(dec, &(val)->u.h221NonStandard))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardIdentifier(H225NonStandardIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1objectidentifier_free(&(val)->u.object);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_PublicTypeOfNumber(ASN1encoding_t enc, PublicTypeOfNumber *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PublicTypeOfNumber(ASN1decoding_t dec, PublicTypeOfNumber *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_PrivateTypeOfNumber(ASN1encoding_t enc, PrivateTypeOfNumber *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateTypeOfNumber(ASN1decoding_t dec, PrivateTypeOfNumber *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_AltGKInfo(ASN1encoding_t enc, AltGKInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_AltGKInfo_alternateGatekeeper(enc, &(val)->alternateGatekeeper))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->altGKisPermanent))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AltGKInfo(ASN1decoding_t dec, AltGKInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_AltGKInfo_alternateGatekeeper(dec, &(val)->alternateGatekeeper))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->altGKisPermanent))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AltGKInfo(AltGKInfo *val)
{
    if (val) {
	ASN1Free_AltGKInfo_alternateGatekeeper(&(val)->alternateGatekeeper);
    }
}

static int ASN1CALL ASN1Enc_Q954Details(ASN1encoding_t enc, Q954Details *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conferenceCalling))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->threePartyService))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Q954Details(ASN1decoding_t dec, Q954Details *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conferenceCalling))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->threePartyService))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CallIdentifier(ASN1encoding_t enc, CallIdentifier *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->guid, 16))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallIdentifier(ASN1decoding_t dec, CallIdentifier *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->guid, 16))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CallIdentifier(CallIdentifier *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ICV(ASN1encoding_t enc, ICV *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
	return 0;
    if (!ASN1PEREncFragmented(enc, ((val)->icv).length, ((val)->icv).value, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ICV(ASN1decoding_t dec, ICV *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
	return 0;
    if (!ASN1PERDecFragmented(dec, &((val)->icv).length, &((val)->icv).value, 1))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ICV(ICV *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->algorithmOID);
	ASN1bitstring_free(&(val)->icv);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRejectReason(ASN1encoding_t enc, GatekeeperRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRejectReason(ASN1decoding_t dec, GatekeeperRejectReason *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RegistrationRejectReason(ASN1encoding_t enc, RegistrationRejectReason *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 8))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Enc_RegistrationRejectReason_duplicateAlias(enc, &(val)->u.duplicateAlias))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 10:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRejectReason(ASN1decoding_t dec, RegistrationRejectReason *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 8))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Dec_RegistrationRejectReason_duplicateAlias(dec, &(val)->u.duplicateAlias))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 10:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRejectReason(RegistrationRejectReason *val)
{
    if (val) {
	switch ((val)->choice) {
	case 5:
	    ASN1Free_RegistrationRejectReason_duplicateAlias(&(val)->u.duplicateAlias);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_UnregRequestReason(ASN1encoding_t enc, UnregRequestReason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregRequestReason(ASN1decoding_t dec, UnregRequestReason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UnregRejectReason(ASN1encoding_t enc, UnregRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregRejectReason(ASN1decoding_t dec, UnregRejectReason *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CallType(ASN1encoding_t enc, CallType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallType(ASN1decoding_t dec, CallType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CallModel(ASN1encoding_t enc, CallModel *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallModel(ASN1decoding_t dec, CallModel *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TransportQOS(ASN1encoding_t enc, TransportQOS *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportQOS(ASN1decoding_t dec, TransportQOS *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UUIEsRequested(ASN1encoding_t enc, UUIEsRequested *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->setup))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->callProceeding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->connect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alerting))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->information))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->releaseComplete))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->facility))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->progress))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->empty))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UUIEsRequested(ASN1decoding_t dec, UUIEsRequested *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->setup))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->callProceeding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->connect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alerting))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->information))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->releaseComplete))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->facility))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->progress))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->empty))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_AdmissionRejectReason(ASN1encoding_t enc, AdmissionRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 8))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRejectReason(ASN1decoding_t dec, AdmissionRejectReason *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 8))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_BandRejectReason(ASN1encoding_t enc, BandRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandRejectReason(ASN1decoding_t dec, BandRejectReason *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_LocationRejectReason(ASN1encoding_t enc, LocationRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRejectReason(ASN1decoding_t dec, LocationRejectReason *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_DisengageReason(ASN1encoding_t enc, DisengageReason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageReason(ASN1decoding_t dec, DisengageReason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_DisengageRejectReason(ASN1encoding_t enc, DisengageRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageRejectReason(ASN1decoding_t dec, DisengageRejectReason *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_InfoRequestNakReason(ASN1encoding_t enc, InfoRequestNakReason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestNakReason(ASN1decoding_t dec, InfoRequestNakReason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UnknownMessageResponse(ASN1encoding_t enc, UnknownMessageResponse *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1Enc_UnknownMessageResponse_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1Enc_UnknownMessageResponse_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnknownMessageResponse(ASN1decoding_t dec, UnknownMessageResponse *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UnknownMessageResponse_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UnknownMessageResponse_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnknownMessageResponse(UnknownMessageResponse *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_UnknownMessageResponse_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_UnknownMessageResponse_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens(PInfoRequestResponse_perCallInfo_Seq_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(PInfoRequestResponse_perCallInfo_Seq_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_tokens(ASN1encoding_t enc, PResourcesAvailableConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ResourcesAvailableConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_tokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_tokens(ASN1decoding_t dec, PResourcesAvailableConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ResourcesAvailableConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_tokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_tokens(PResourcesAvailableConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ResourcesAvailableConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_tokens_ElmFn(PResourcesAvailableConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_tokens(ASN1encoding_t enc, PResourcesAvailableIndicate_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ResourcesAvailableIndicate_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_tokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_tokens(ASN1decoding_t dec, PResourcesAvailableIndicate_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ResourcesAvailableIndicate_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_tokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_tokens(PResourcesAvailableIndicate_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ResourcesAvailableIndicate_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_tokens_ElmFn(PResourcesAvailableIndicate_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RequestInProgress_tokens(ASN1encoding_t enc, PRequestInProgress_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RequestInProgress_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RequestInProgress_tokens_ElmFn(ASN1encoding_t enc, PRequestInProgress_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestInProgress_tokens(ASN1decoding_t dec, PRequestInProgress_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RequestInProgress_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RequestInProgress_tokens_ElmFn(ASN1decoding_t dec, PRequestInProgress_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RequestInProgress_tokens(PRequestInProgress_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RequestInProgress_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RequestInProgress_tokens_ElmFn(PRequestInProgress_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnknownMessageResponse_tokens(ASN1encoding_t enc, PUnknownMessageResponse_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnknownMessageResponse_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnknownMessageResponse_tokens_ElmFn(ASN1encoding_t enc, PUnknownMessageResponse_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnknownMessageResponse_tokens(ASN1decoding_t dec, PUnknownMessageResponse_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnknownMessageResponse_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnknownMessageResponse_tokens_ElmFn(ASN1decoding_t dec, PUnknownMessageResponse_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnknownMessageResponse_tokens(PUnknownMessageResponse_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnknownMessageResponse_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnknownMessageResponse_tokens_ElmFn(PUnknownMessageResponse_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H225NonStandardMessage_tokens(ASN1encoding_t enc, PH225NonStandardMessage_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H225NonStandardMessage_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_H225NonStandardMessage_tokens_ElmFn(ASN1encoding_t enc, PH225NonStandardMessage_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardMessage_tokens(ASN1decoding_t dec, PH225NonStandardMessage_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H225NonStandardMessage_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H225NonStandardMessage_tokens_ElmFn(ASN1decoding_t dec, PH225NonStandardMessage_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardMessage_tokens(PH225NonStandardMessage_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H225NonStandardMessage_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H225NonStandardMessage_tokens_ElmFn(PH225NonStandardMessage_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestNak_tokens(ASN1encoding_t enc, PInfoRequestNak_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestNak_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestNak_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestNak_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestNak_tokens(ASN1decoding_t dec, PInfoRequestNak_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestNak_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestNak_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestNak_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestNak_tokens(PInfoRequestNak_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestNak_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestNak_tokens_ElmFn(PInfoRequestNak_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestAck_tokens(ASN1encoding_t enc, PInfoRequestAck_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestAck_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestAck_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestAck_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestAck_tokens(ASN1decoding_t dec, PInfoRequestAck_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestAck_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestAck_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestAck_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestAck_tokens(PInfoRequestAck_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestAck_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestAck_tokens_ElmFn(PInfoRequestAck_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_tokens(ASN1encoding_t enc, PInfoRequestResponse_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_tokens(ASN1decoding_t dec, PInfoRequestResponse_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_tokens(PInfoRequestResponse_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_tokens_ElmFn(PInfoRequestResponse_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequest_tokens(ASN1encoding_t enc, PInfoRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequest_tokens_ElmFn(ASN1encoding_t enc, PInfoRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequest_tokens(ASN1decoding_t dec, PInfoRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequest_tokens_ElmFn(ASN1decoding_t dec, PInfoRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequest_tokens(PInfoRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequest_tokens_ElmFn(PInfoRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageReject_tokens(ASN1encoding_t enc, PDisengageReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageReject_tokens_ElmFn(ASN1encoding_t enc, PDisengageReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageReject_tokens(ASN1decoding_t dec, PDisengageReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageReject_tokens_ElmFn(ASN1decoding_t dec, PDisengageReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageReject_tokens(PDisengageReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageReject_tokens_ElmFn(PDisengageReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageConfirm_tokens(ASN1encoding_t enc, PDisengageConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageConfirm_tokens_ElmFn(ASN1encoding_t enc, PDisengageConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageConfirm_tokens(ASN1decoding_t dec, PDisengageConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageConfirm_tokens_ElmFn(ASN1decoding_t dec, PDisengageConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageConfirm_tokens(PDisengageConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageConfirm_tokens_ElmFn(PDisengageConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageRequest_tokens(ASN1encoding_t enc, PDisengageRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageRequest_tokens_ElmFn(ASN1encoding_t enc, PDisengageRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageRequest_tokens(ASN1decoding_t dec, PDisengageRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageRequest_tokens_ElmFn(ASN1decoding_t dec, PDisengageRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageRequest_tokens(PDisengageRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageRequest_tokens_ElmFn(PDisengageRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationReject_tokens(ASN1encoding_t enc, PLocationReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationReject_tokens_ElmFn(ASN1encoding_t enc, PLocationReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationReject_tokens(ASN1decoding_t dec, PLocationReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationReject_tokens_ElmFn(ASN1decoding_t dec, PLocationReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationReject_tokens(PLocationReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationReject_tokens_ElmFn(PLocationReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_tokens(ASN1encoding_t enc, PLocationConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_tokens_ElmFn(ASN1encoding_t enc, PLocationConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_tokens(ASN1decoding_t dec, PLocationConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_tokens_ElmFn(ASN1decoding_t dec, PLocationConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_tokens(PLocationConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_tokens_ElmFn(PLocationConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationRequest_tokens(ASN1encoding_t enc, PLocationRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationRequest_tokens_ElmFn(ASN1encoding_t enc, PLocationRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRequest_tokens(ASN1decoding_t dec, PLocationRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationRequest_tokens_ElmFn(ASN1decoding_t dec, PLocationRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationRequest_tokens(PLocationRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationRequest_tokens_ElmFn(PLocationRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthReject_tokens(ASN1encoding_t enc, PBandwidthReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthReject_tokens_ElmFn(ASN1encoding_t enc, PBandwidthReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthReject_tokens(ASN1decoding_t dec, PBandwidthReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthReject_tokens_ElmFn(ASN1decoding_t dec, PBandwidthReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthReject_tokens(PBandwidthReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthReject_tokens_ElmFn(PBandwidthReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthConfirm_tokens(ASN1encoding_t enc, PBandwidthConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthConfirm_tokens_ElmFn(ASN1encoding_t enc, PBandwidthConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthConfirm_tokens(ASN1decoding_t dec, PBandwidthConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthConfirm_tokens_ElmFn(ASN1decoding_t dec, PBandwidthConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthConfirm_tokens(PBandwidthConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthConfirm_tokens_ElmFn(PBandwidthConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthRequest_tokens(ASN1encoding_t enc, PBandwidthRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthRequest_tokens_ElmFn(ASN1encoding_t enc, PBandwidthRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthRequest_tokens(ASN1decoding_t dec, PBandwidthRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthRequest_tokens_ElmFn(ASN1decoding_t dec, PBandwidthRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthRequest_tokens(PBandwidthRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthRequest_tokens_ElmFn(PBandwidthRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionReject_tokens(ASN1encoding_t enc, PAdmissionReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionReject_tokens_ElmFn(ASN1encoding_t enc, PAdmissionReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionReject_tokens(ASN1decoding_t dec, PAdmissionReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionReject_tokens_ElmFn(ASN1decoding_t dec, PAdmissionReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionReject_tokens(PAdmissionReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionReject_tokens_ElmFn(PAdmissionReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_tokens(ASN1encoding_t enc, PAdmissionConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_tokens_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_tokens(ASN1decoding_t dec, PAdmissionConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_tokens_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_tokens(PAdmissionConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_tokens_ElmFn(PAdmissionConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_tokens(ASN1encoding_t enc, PAdmissionRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_tokens_ElmFn(ASN1encoding_t enc, PAdmissionRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_tokens(ASN1decoding_t dec, PAdmissionRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_tokens_ElmFn(ASN1decoding_t dec, PAdmissionRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_tokens(PAdmissionRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_tokens_ElmFn(PAdmissionRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationReject_tokens(ASN1encoding_t enc, PUnregistrationReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationReject_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationReject_tokens(ASN1decoding_t dec, PUnregistrationReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationReject_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationReject_tokens(PUnregistrationReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationReject_tokens_ElmFn(PUnregistrationReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationConfirm_tokens(ASN1encoding_t enc, PUnregistrationConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationConfirm_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationConfirm_tokens(ASN1decoding_t dec, PUnregistrationConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationConfirm_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationConfirm_tokens(PUnregistrationConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationConfirm_tokens_ElmFn(PUnregistrationConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_tokens(ASN1encoding_t enc, PUnregistrationRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_tokens(ASN1decoding_t dec, PUnregistrationRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest_tokens(PUnregistrationRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationRequest_tokens_ElmFn(PUnregistrationRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationReject_tokens(ASN1encoding_t enc, PRegistrationReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationReject_tokens_ElmFn(ASN1encoding_t enc, PRegistrationReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationReject_tokens(ASN1decoding_t dec, PRegistrationReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationReject_tokens_ElmFn(ASN1decoding_t dec, PRegistrationReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationReject_tokens(PRegistrationReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationReject_tokens_ElmFn(PRegistrationReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_tokens(ASN1encoding_t enc, PRegistrationConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_tokens_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_tokens(ASN1decoding_t dec, PRegistrationConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_tokens_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm_tokens(PRegistrationConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationConfirm_tokens_ElmFn(PRegistrationConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_tokens(ASN1encoding_t enc, PRegistrationRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_tokens_ElmFn(ASN1encoding_t enc, PRegistrationRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_tokens(ASN1decoding_t dec, PRegistrationRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_tokens_ElmFn(ASN1decoding_t dec, PRegistrationRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_tokens(PRegistrationRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_tokens_ElmFn(PRegistrationRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperReject_tokens(ASN1encoding_t enc, PGatekeeperReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperReject_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperReject_tokens(ASN1decoding_t dec, PGatekeeperReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperReject_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperReject_tokens(PGatekeeperReject_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperReject_tokens_ElmFn(PGatekeeperReject_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_tokens(ASN1encoding_t enc, PGatekeeperConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_tokens(ASN1decoding_t dec, PGatekeeperConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_tokens(PGatekeeperConfirm_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_tokens_ElmFn(PGatekeeperConfirm_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_authenticationCapability(ASN1encoding_t enc, PGatekeeperRequest_authenticationCapability *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_authenticationCapability_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_authenticationCapability_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_authenticationCapability val)
{
    if (!ASN1Enc_AuthenticationMechanism(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_authenticationCapability(ASN1decoding_t dec, PGatekeeperRequest_authenticationCapability *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_authenticationCapability_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_authenticationCapability_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_authenticationCapability val)
{
    if (!ASN1Dec_AuthenticationMechanism(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_authenticationCapability(PGatekeeperRequest_authenticationCapability *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_authenticationCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_authenticationCapability_ElmFn(PGatekeeperRequest_authenticationCapability val)
{
    if (val) {
	ASN1Free_AuthenticationMechanism(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_tokens(ASN1encoding_t enc, PGatekeeperRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_tokens(ASN1decoding_t dec, PGatekeeperRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_tokens(PGatekeeperRequest_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_tokens_ElmFn(PGatekeeperRequest_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_tokens(ASN1encoding_t enc, PEndpoint_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_tokens_ElmFn(ASN1encoding_t enc, PEndpoint_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_tokens(ASN1decoding_t dec, PEndpoint_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_tokens_ElmFn(ASN1decoding_t dec, PEndpoint_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_tokens(PEndpoint_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_tokens_ElmFn(PEndpoint_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Progress_UUIE_tokens(ASN1encoding_t enc, PProgress_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Progress_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Progress_UUIE_tokens_ElmFn(ASN1encoding_t enc, PProgress_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Progress_UUIE_tokens(ASN1decoding_t dec, PProgress_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Progress_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Progress_UUIE_tokens_ElmFn(ASN1decoding_t dec, PProgress_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Progress_UUIE_tokens(PProgress_UUIE_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Progress_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Progress_UUIE_tokens_ElmFn(PProgress_UUIE_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_tokens(ASN1encoding_t enc, PFacility_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_tokens_ElmFn(ASN1encoding_t enc, PFacility_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_tokens(ASN1decoding_t dec, PFacility_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_tokens_ElmFn(ASN1decoding_t dec, PFacility_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_tokens(PFacility_UUIE_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_tokens_ElmFn(PFacility_UUIE_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_tokens(ASN1encoding_t enc, PSetup_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_tokens_ElmFn(ASN1encoding_t enc, PSetup_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_tokens(ASN1decoding_t dec, PSetup_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_tokens_ElmFn(ASN1decoding_t dec, PSetup_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_tokens(PSetup_UUIE_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_tokens_ElmFn(PSetup_UUIE_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Connect_UUIE_tokens(ASN1encoding_t enc, PConnect_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Connect_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Connect_UUIE_tokens_ElmFn(ASN1encoding_t enc, PConnect_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Connect_UUIE_tokens(ASN1decoding_t dec, PConnect_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Connect_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Connect_UUIE_tokens_ElmFn(ASN1decoding_t dec, PConnect_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Connect_UUIE_tokens(PConnect_UUIE_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Connect_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Connect_UUIE_tokens_ElmFn(PConnect_UUIE_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_tokens(ASN1encoding_t enc, PCallProceeding_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CallProceeding_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_tokens_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_tokens(ASN1decoding_t dec, PCallProceeding_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CallProceeding_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_tokens_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_tokens(PCallProceeding_UUIE_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CallProceeding_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_tokens_ElmFn(PCallProceeding_UUIE_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_tokens(ASN1encoding_t enc, PAlerting_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Alerting_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_tokens_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_tokens(ASN1decoding_t dec, PAlerting_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Alerting_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_tokens_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Alerting_UUIE_tokens(PAlerting_UUIE_tokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Alerting_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Alerting_UUIE_tokens_ElmFn(PAlerting_UUIE_tokens val)
{
    if (val) {
	ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SIGNED_EncodedGeneralToken(ASN1encoding_t enc, SIGNED_EncodedGeneralToken *val)
{
    if (!ASN1Enc_EncodedGeneralToken(enc, &(val)->toBeSigned))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
	return 0;
    if (!ASN1Enc_Params(enc, &(val)->paramS))
	return 0;
    if (!ASN1PEREncFragmented(enc, ((val)->signature).length, ((val)->signature).value, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SIGNED_EncodedGeneralToken(ASN1decoding_t dec, SIGNED_EncodedGeneralToken *val)
{
    if (!ASN1Dec_EncodedGeneralToken(dec, &(val)->toBeSigned))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
	return 0;
    if (!ASN1Dec_Params(dec, &(val)->paramS))
	return 0;
    if (!ASN1PERDecFragmented(dec, &((val)->signature).length, &((val)->signature).value, 1))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SIGNED_EncodedGeneralToken(SIGNED_EncodedGeneralToken *val)
{
    if (val) {
	ASN1Free_EncodedGeneralToken(&(val)->toBeSigned);
	ASN1objectidentifier_free(&(val)->algorithmOID);
	ASN1Free_Params(&(val)->paramS);
	ASN1bitstring_free(&(val)->signature);
    }
}

static int ASN1CALL ASN1Enc_ENCRYPTED(ASN1encoding_t enc, ENCRYPTED *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
	return 0;
    if (!ASN1Enc_Params(enc, &(val)->paramS))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->encryptedData))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ENCRYPTED(ASN1decoding_t dec, ENCRYPTED *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
	return 0;
    if (!ASN1Dec_Params(dec, &(val)->paramS))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->encryptedData))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ENCRYPTED(ENCRYPTED *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->algorithmOID);
	ASN1Free_Params(&(val)->paramS);
	ASN1octetstring_free(&(val)->encryptedData);
    }
}

static int ASN1CALL ASN1Enc_HASHED(ASN1encoding_t enc, HASHED *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
	return 0;
    if (!ASN1Enc_Params(enc, &(val)->paramS))
	return 0;
    if (!ASN1PEREncFragmented(enc, ((val)->hash).length, ((val)->hash).value, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_HASHED(ASN1decoding_t dec, HASHED *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
	return 0;
    if (!ASN1Dec_Params(dec, &(val)->paramS))
	return 0;
    if (!ASN1PERDecFragmented(dec, &((val)->hash).length, &((val)->hash).value, 1))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_HASHED(HASHED *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->algorithmOID);
	ASN1Free_Params(&(val)->paramS);
	ASN1bitstring_free(&(val)->hash);
    }
}

static int ASN1CALL ASN1Enc_SIGNED_EncodedPwdCertToken(ASN1encoding_t enc, SIGNED_EncodedPwdCertToken *val)
{
    if (!ASN1Enc_EncodedPwdCertToken(enc, &(val)->toBeSigned))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
	return 0;
    if (!ASN1Enc_Params(enc, &(val)->paramS))
	return 0;
    if (!ASN1PEREncFragmented(enc, ((val)->signature).length, ((val)->signature).value, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SIGNED_EncodedPwdCertToken(ASN1decoding_t dec, SIGNED_EncodedPwdCertToken *val)
{
    if (!ASN1Dec_EncodedPwdCertToken(dec, &(val)->toBeSigned))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
	return 0;
    if (!ASN1Dec_Params(dec, &(val)->paramS))
	return 0;
    if (!ASN1PERDecFragmented(dec, &((val)->signature).length, &((val)->signature).value, 1))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SIGNED_EncodedPwdCertToken(SIGNED_EncodedPwdCertToken *val)
{
    if (val) {
	ASN1Free_EncodedPwdCertToken(&(val)->toBeSigned);
	ASN1objectidentifier_free(&(val)->algorithmOID);
	ASN1Free_Params(&(val)->paramS);
	ASN1bitstring_free(&(val)->signature);
    }
}

static int ASN1CALL ASN1Enc_Information_UUIE(ASN1encoding_t enc, Information_UUIE *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Information_UUIE(ASN1decoding_t dec, Information_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_Information_UUIE(Information_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
    }
}

static int ASN1CALL ASN1Enc_ReleaseComplete_UUIE(ASN1encoding_t enc, ReleaseComplete_UUIE *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_ReleaseCompleteReason(enc, &(val)->reason))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ReleaseComplete_UUIE(ASN1decoding_t dec, ReleaseComplete_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ReleaseCompleteReason(dec, &(val)->reason))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_ReleaseComplete_UUIE(ReleaseComplete_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
    }
}

static int ASN1CALL ASN1Enc_VendorIdentifier(ASN1encoding_t enc, VendorIdentifier *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_H221NonStandard(enc, &(val)->vendor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->productId, 1, 256, 8))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->versionId, 1, 256, 8))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VendorIdentifier(ASN1decoding_t dec, VendorIdentifier *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_H221NonStandard(dec, &(val)->vendor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->productId, 1, 256, 8))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->versionId, 1, 256, 8))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VendorIdentifier(VendorIdentifier *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_H225NonStandardParameter(ASN1encoding_t enc, H225NonStandardParameter *val)
{
    if (!ASN1Enc_H225NonStandardIdentifier(enc, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardParameter(ASN1decoding_t dec, H225NonStandardParameter *val)
{
    if (!ASN1Dec_H225NonStandardIdentifier(dec, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardParameter(H225NonStandardParameter *val)
{
    if (val) {
	ASN1Free_H225NonStandardIdentifier(&(val)->nonStandardIdentifier);
	ASN1octetstring_free(&(val)->data);
    }
}

static ASN1stringtableentry_t PublicPartyNumber_publicNumberDigits_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PublicPartyNumber_publicNumberDigits_StringTable = {
    4, PublicPartyNumber_publicNumberDigits_StringTableEntries
};

static int ASN1CALL ASN1Enc_PublicPartyNumber(ASN1encoding_t enc, PublicPartyNumber *val)
{
    ASN1uint32_t t;
    if (!ASN1Enc_PublicTypeOfNumber(enc, &(val)->publicTypeOfNumber))
	return 0;
    t = lstrlenA((val)->publicNumberDigits);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->publicNumberDigits, 4, &PublicPartyNumber_publicNumberDigits_StringTable))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PublicPartyNumber(ASN1decoding_t dec, PublicPartyNumber *val)
{
    ASN1uint32_t l;
    if (!ASN1Dec_PublicTypeOfNumber(dec, &(val)->publicTypeOfNumber))
	return 0;
    if (!ASN1PERDecU32Val(dec, 7, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);

    // SECURITY BUG: 782696
    if ( l >= sizeof( (val)->publicNumberDigits ) )
    {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0;
    }

    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->publicNumberDigits, 4, &PublicPartyNumber_publicNumberDigits_StringTable))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PublicPartyNumber(PublicPartyNumber *val)
{
    if (val) {
    }
}

static ASN1stringtableentry_t PrivatePartyNumber_privateNumberDigits_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PrivatePartyNumber_privateNumberDigits_StringTable = {
    4, PrivatePartyNumber_privateNumberDigits_StringTableEntries
};

static int ASN1CALL ASN1Enc_PrivatePartyNumber(ASN1encoding_t enc, PrivatePartyNumber *val)
{
    ASN1uint32_t t;
    if (!ASN1Enc_PrivateTypeOfNumber(enc, &(val)->privateTypeOfNumber))
	return 0;
    t = lstrlenA((val)->privateNumberDigits);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->privateNumberDigits, 4, &PrivatePartyNumber_privateNumberDigits_StringTable))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivatePartyNumber(ASN1decoding_t dec, PrivatePartyNumber *val)
{
    ASN1uint32_t l;
    if (!ASN1Dec_PrivateTypeOfNumber(dec, &(val)->privateTypeOfNumber))
	return 0;
    if (!ASN1PERDecU32Val(dec, 7, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);

    // SECURITY BUG: 782696
    if ( l >= sizeof( (val)->privateNumberDigits ) )
    {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0;
    }

    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->privateNumberDigits, 4, &PrivatePartyNumber_privateNumberDigits_StringTable))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivatePartyNumber(PrivatePartyNumber *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SecurityServiceMode(ASN1encoding_t enc, SecurityServiceMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SecurityServiceMode(ASN1decoding_t dec, SecurityServiceMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SecurityServiceMode(SecurityServiceMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_SecurityCapabilities(ASN1encoding_t enc, SecurityCapabilities *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandard))
	    return 0;
    }
    if (!ASN1Enc_SecurityServiceMode(enc, &(val)->encryption))
	return 0;
    if (!ASN1Enc_SecurityServiceMode(enc, &(val)->authenticaton))
	return 0;
    if (!ASN1Enc_SecurityServiceMode(enc, &(val)->integrity))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SecurityCapabilities(ASN1decoding_t dec, SecurityCapabilities *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandard))
	    return 0;
    }
    if (!ASN1Dec_SecurityServiceMode(dec, &(val)->encryption))
	return 0;
    if (!ASN1Dec_SecurityServiceMode(dec, &(val)->authenticaton))
	return 0;
    if (!ASN1Dec_SecurityServiceMode(dec, &(val)->integrity))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SecurityCapabilities(SecurityCapabilities *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandard);
	}
	ASN1Free_SecurityServiceMode(&(val)->encryption);
	ASN1Free_SecurityServiceMode(&(val)->authenticaton);
	ASN1Free_SecurityServiceMode(&(val)->integrity);
    }
}

static int ASN1CALL ASN1Enc_H245Security(ASN1encoding_t enc, H245Security *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_SecurityCapabilities(enc, &(val)->u.tls))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_SecurityCapabilities(enc, &(val)->u.ipsec))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H245Security(ASN1decoding_t dec, H245Security *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_SecurityCapabilities(dec, &(val)->u.tls))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_SecurityCapabilities(dec, &(val)->u.ipsec))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H245Security(H245Security *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1Free_SecurityCapabilities(&(val)->u.tls);
	    break;
	case 4:
	    ASN1Free_SecurityCapabilities(&(val)->u.ipsec);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_QseriesOptions(ASN1encoding_t enc, QseriesOptions *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q932Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q951Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q952Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q953Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q955Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q956Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q957Full))
	return 0;
    if (!ASN1Enc_Q954Details(enc, &(val)->q954Info))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_QseriesOptions(ASN1decoding_t dec, QseriesOptions *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q932Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q951Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q952Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q953Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q955Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q956Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q957Full))
	return 0;
    if (!ASN1Dec_Q954Details(dec, &(val)->q954Info))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_EncryptIntAlg(ASN1encoding_t enc, EncryptIntAlg *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.isoAlgorithm))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptIntAlg(ASN1decoding_t dec, EncryptIntAlg *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.isoAlgorithm))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptIntAlg(EncryptIntAlg *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1objectidentifier_free(&(val)->u.isoAlgorithm);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_NonIsoIntegrityMechanism(ASN1encoding_t enc, NonIsoIntegrityMechanism *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_EncryptIntAlg(enc, &(val)->u.hMAC_iso10118_2_s))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_EncryptIntAlg(enc, &(val)->u.hMAC_iso10118_2_l))
	    return 0;
	break;
    case 4:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.hMAC_iso10118_3))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NonIsoIntegrityMechanism(ASN1decoding_t dec, NonIsoIntegrityMechanism *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_EncryptIntAlg(dec, &(val)->u.hMAC_iso10118_2_s))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_EncryptIntAlg(dec, &(val)->u.hMAC_iso10118_2_l))
	    return 0;
	break;
    case 4:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.hMAC_iso10118_3))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonIsoIntegrityMechanism(NonIsoIntegrityMechanism *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_EncryptIntAlg(&(val)->u.hMAC_iso10118_2_s);
	    break;
	case 3:
	    ASN1Free_EncryptIntAlg(&(val)->u.hMAC_iso10118_2_l);
	    break;
	case 4:
	    ASN1objectidentifier_free(&(val)->u.hMAC_iso10118_3);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_IntegrityMechanism(ASN1encoding_t enc, IntegrityMechanism *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.iso9797))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_NonIsoIntegrityMechanism(enc, &(val)->u.nonIsoIM))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IntegrityMechanism(ASN1decoding_t dec, IntegrityMechanism *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.iso9797))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_NonIsoIntegrityMechanism(dec, &(val)->u.nonIsoIM))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_IntegrityMechanism(IntegrityMechanism *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1objectidentifier_free(&(val)->u.iso9797);
	    break;
	case 4:
	    ASN1Free_NonIsoIntegrityMechanism(&(val)->u.nonIsoIM);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EncodedFastStartToken(ASN1encoding_t enc, EncodedFastStartToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->id))
	return 0;
    if (!ASN1Enc_FastStartToken(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncodedFastStartToken(ASN1decoding_t dec, EncodedFastStartToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->id))
	return 0;
    if (!ASN1Dec_FastStartToken(dec, &(val)->type))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncodedFastStartToken(EncodedFastStartToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->id);
	ASN1Free_FastStartToken(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_DataRate(ASN1encoding_t enc, DataRate *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    l = ASN1uint32_uoctets((val)->channelRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->channelRate))
	return 0;
    if ((val)->o[0] & 0x40) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->channelMultiplier - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataRate(ASN1decoding_t dec, DataRate *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->channelRate))
	return 0;
    if ((val)->o[0] & 0x40) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->channelMultiplier))
	    return 0;
	(val)->channelMultiplier += 1;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataRate(DataRate *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_GatekeeperReject(ASN1encoding_t enc, GatekeeperReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Enc_GatekeeperRejectReason(enc, &(val)->rejectReason))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_GatekeeperReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_GatekeeperReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperReject(ASN1decoding_t dec, GatekeeperReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Dec_GatekeeperRejectReason(dec, &(val)->rejectReason))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperReject(GatekeeperReject *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_GatekeeperReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_GatekeeperReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm(ASN1encoding_t enc, RegistrationConfirm *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    ASN1uint32_t l;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x4;
    y = ASN1PEREncCheckExtensions(7, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 3, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Enc_RegistrationConfirm_callSignalAddress(enc, &(val)->callSignalAddress))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_RegistrationConfirm_terminalAlias(enc, &(val)->terminalAlias))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 7, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_RegistrationConfirm_alternateGatekeeper(ee, &(val)->alternateGatekeeper))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    l = ASN1uint32_uoctets((val)->timeToLive - 1);
	    if (!ASN1PEREncBitVal(ee, 2, l - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncBitVal(ee, l * 8, (val)->timeToLive - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_RegistrationConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_RegistrationConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1PEREncBoolean(ee, (val)->willRespondToIRR))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1Enc_RegistrationConfirm_preGrantedARQ(ee, &(val)->preGrantedARQ))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm(ASN1decoding_t dec, RegistrationConfirm *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t l;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Dec_RegistrationConfirm_callSignalAddress(dec, &(val)->callSignalAddress))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_RegistrationConfirm_terminalAlias(dec, &(val)->terminalAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 7, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationConfirm_alternateGatekeeper(dd, &(val)->alternateGatekeeper))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 2, &l))
		return 0;
	    l += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecU32Val(dd, l * 8, &(val)->timeToLive))
		return 0;
	    (val)->timeToLive += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->willRespondToIRR))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationConfirm_preGrantedARQ(dd, &(val)->preGrantedARQ))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm(RegistrationConfirm *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_RegistrationConfirm_callSignalAddress(&(val)->callSignalAddress);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_RegistrationConfirm_terminalAlias(&(val)->terminalAlias);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	ASN1char16string_free(&(val)->endpointIdentifier);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_RegistrationConfirm_alternateGatekeeper(&(val)->alternateGatekeeper);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_RegistrationConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_RegistrationConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_RegistrationReject(ASN1encoding_t enc, RegistrationReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Enc_RegistrationRejectReason(enc, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_RegistrationReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_RegistrationReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationReject(ASN1decoding_t dec, RegistrationReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Dec_RegistrationRejectReason(dec, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationReject(RegistrationReject *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_RegistrationRejectReason(&(val)->rejectReason);
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_RegistrationReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_RegistrationReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest(ASN1encoding_t enc, UnregistrationRequest *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(6, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_UnregistrationRequest_callSignalAddress(enc, &(val)->callSignalAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_UnregistrationRequest_endpointAlias(enc, &(val)->endpointAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 6, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_UnregistrationRequest_alternateEndpoints(ee, &(val)->alternateEndpoints))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PEREncBitVal(ee, 7, ((val)->gatekeeperIdentifier).length - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncChar16String(ee, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_UnregistrationRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_UnregistrationRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1Enc_UnregRequestReason(ee, &(val)->reason))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest(ASN1decoding_t dec, UnregistrationRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_UnregistrationRequest_callSignalAddress(dec, &(val)->callSignalAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_UnregistrationRequest_endpointAlias(dec, &(val)->endpointAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	    return 0;
	((val)->endpointIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 6, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationRequest_alternateEndpoints(dd, &(val)->alternateEndpoints))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 7, &((val)->gatekeeperIdentifier).length))
		return 0;
	    ((val)->gatekeeperIdentifier).length += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecChar16String(dd, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UnregRequestReason(dd, &(val)->reason))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest(UnregistrationRequest *val)
{
    if (val) {
	ASN1Free_UnregistrationRequest_callSignalAddress(&(val)->callSignalAddress);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_UnregistrationRequest_endpointAlias(&(val)->endpointAlias);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1char16string_free(&(val)->endpointIdentifier);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_UnregistrationRequest_alternateEndpoints(&(val)->alternateEndpoints);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_UnregistrationRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_UnregistrationRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_UnregistrationConfirm(ASN1encoding_t enc, UnregistrationConfirm *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_UnregistrationConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_UnregistrationConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationConfirm(ASN1decoding_t dec, UnregistrationConfirm *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationConfirm(UnregistrationConfirm *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_UnregistrationConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_UnregistrationConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_UnregistrationReject(ASN1encoding_t enc, UnregistrationReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_UnregRejectReason(enc, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_UnregistrationReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_UnregistrationReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationReject(ASN1decoding_t dec, UnregistrationReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_UnregRejectReason(dec, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UnregistrationReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationReject(UnregistrationReject *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_UnregistrationReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_UnregistrationReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_AdmissionReject(ASN1encoding_t enc, AdmissionReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_AdmissionRejectReason(enc, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 5, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_AdmissionReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_AdmissionReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_AdmissionReject_callSignalAddress(ee, &(val)->callSignalAddress))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionReject(ASN1decoding_t dec, AdmissionReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_AdmissionRejectReason(dec, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionReject_callSignalAddress(dd, &(val)->callSignalAddress))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionReject(AdmissionReject *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_AdmissionReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_AdmissionReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_AdmissionReject_callSignalAddress(&(val)->callSignalAddress);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_BandwidthRequest(ASN1encoding_t enc, BandwidthRequest *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    o[1] |= 0x4;
    y = ASN1PEREncCheckExtensions(6, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->callReferenceValue))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_CallType(enc, &(val)->callType))
	    return 0;
    }
    l = ASN1uint32_uoctets((val)->bandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bandWidth))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 6, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1PEREncBitVal(ee, 7, ((val)->gatekeeperIdentifier).length - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncChar16String(ee, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_BandwidthRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_BandwidthRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1PEREncBoolean(ee, (val)->answeredCall))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthRequest(ASN1decoding_t dec, BandwidthRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->callReferenceValue))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CallType(dec, &(val)->callType))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bandWidth))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 6, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 7, &((val)->gatekeeperIdentifier).length))
		return 0;
	    ((val)->gatekeeperIdentifier).length += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecChar16String(dd, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_BandwidthRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_BandwidthRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->answeredCall))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthRequest(BandwidthRequest *val)
{
    if (val) {
	ASN1char16string_free(&(val)->endpointIdentifier);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_BandwidthRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_BandwidthRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_BandwidthConfirm(ASN1encoding_t enc, BandwidthConfirm *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    l = ASN1uint32_uoctets((val)->bandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bandWidth))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_BandwidthConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_BandwidthConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthConfirm(ASN1decoding_t dec, BandwidthConfirm *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bandWidth))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_BandwidthConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_BandwidthConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthConfirm(BandwidthConfirm *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_BandwidthConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_BandwidthConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_BandwidthReject(ASN1encoding_t enc, BandwidthReject *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_BandRejectReason(enc, &(val)->rejectReason))
	return 0;
    l = ASN1uint32_uoctets((val)->allowedBandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->allowedBandWidth))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_BandwidthReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_BandwidthReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthReject(ASN1decoding_t dec, BandwidthReject *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_BandRejectReason(dec, &(val)->rejectReason))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->allowedBandWidth))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_BandwidthReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_BandwidthReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthReject(BandwidthReject *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_BandwidthReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_BandwidthReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_LocationReject(ASN1encoding_t enc, LocationReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_LocationRejectReason(enc, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_LocationReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_LocationReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_LocationReject(ASN1decoding_t dec, LocationReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_LocationRejectReason(dec, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_LocationReject(LocationReject *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_LocationReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_LocationReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_DisengageRequest(ASN1encoding_t enc, DisengageRequest *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    o[1] |= 0x4;
    y = ASN1PEREncCheckExtensions(6, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->callReferenceValue))
	return 0;
    if (!ASN1Enc_DisengageReason(enc, &(val)->disengageReason))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 6, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1PEREncBitVal(ee, 7, ((val)->gatekeeperIdentifier).length - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncChar16String(ee, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_DisengageRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_DisengageRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1PEREncBoolean(ee, (val)->answeredCall))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageRequest(ASN1decoding_t dec, DisengageRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->callReferenceValue))
	return 0;
    if (!ASN1Dec_DisengageReason(dec, &(val)->disengageReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 6, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 7, &((val)->gatekeeperIdentifier).length))
		return 0;
	    ((val)->gatekeeperIdentifier).length += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecChar16String(dd, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_DisengageRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_DisengageRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->answeredCall))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_DisengageRequest(DisengageRequest *val)
{
    if (val) {
	ASN1char16string_free(&(val)->endpointIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_DisengageRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_DisengageRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_DisengageConfirm(ASN1encoding_t enc, DisengageConfirm *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_DisengageConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_DisengageConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageConfirm(ASN1decoding_t dec, DisengageConfirm *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_DisengageConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_DisengageConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_DisengageConfirm(DisengageConfirm *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_DisengageConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_DisengageConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_DisengageReject(ASN1encoding_t enc, DisengageReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_DisengageRejectReason(enc, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_DisengageReject_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_DisengageReject_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageReject(ASN1decoding_t dec, DisengageReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_DisengageRejectReason(dec, &(val)->rejectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_DisengageReject_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_DisengageReject_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_DisengageReject(DisengageReject *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_DisengageReject_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_DisengageReject_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestAck(ASN1encoding_t enc, InfoRequestAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_InfoRequestAck_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_InfoRequestAck_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_ICV(enc, &(val)->integrityCheckValue))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestAck(ASN1decoding_t dec, InfoRequestAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_InfoRequestAck_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_InfoRequestAck_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_ICV(dec, &(val)->integrityCheckValue))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestAck(InfoRequestAck *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_InfoRequestAck_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_InfoRequestAck_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestNak(ASN1encoding_t enc, InfoRequestNak *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Enc_InfoRequestNakReason(enc, &(val)->nakReason))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_AltGKInfo(enc, &(val)->altGKInfo))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_InfoRequestNak_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_InfoRequestNak_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_ICV(enc, &(val)->integrityCheckValue))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestNak(ASN1decoding_t dec, InfoRequestNak *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Dec_InfoRequestNakReason(dec, &(val)->nakReason))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_AltGKInfo(dec, &(val)->altGKInfo))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_InfoRequestNak_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_InfoRequestNak_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_ICV(dec, &(val)->integrityCheckValue))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestNak(InfoRequestNak *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_AltGKInfo(&(val)->altGKInfo);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_InfoRequestNak_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_InfoRequestNak_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_H225NonStandardMessage(ASN1encoding_t enc, H225NonStandardMessage *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1Enc_H225NonStandardMessage_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1Enc_H225NonStandardMessage_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardMessage(ASN1decoding_t dec, H225NonStandardMessage *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H225NonStandardMessage_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H225NonStandardMessage_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardMessage(H225NonStandardMessage *val)
{
    if (val) {
	ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardMessage_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H225NonStandardMessage_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_RequestInProgress(ASN1encoding_t enc, RequestInProgress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_RequestInProgress_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_RequestInProgress_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_ICV(enc, &(val)->integrityCheckValue))
	    return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->delay - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestInProgress(ASN1decoding_t dec, RequestInProgress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_RequestInProgress_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_RequestInProgress_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_ICV(dec, &(val)->integrityCheckValue))
	    return 0;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->delay))
	return 0;
    (val)->delay += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestInProgress(RequestInProgress *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_RequestInProgress_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_RequestInProgress_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate(ASN1encoding_t enc, ResourcesAvailableIndicate *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1Enc_ResourcesAvailableIndicate_protocols(enc, &(val)->protocols))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->almostOutOfResources))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ResourcesAvailableIndicate_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_ResourcesAvailableIndicate_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_ICV(enc, &(val)->integrityCheckValue))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate(ASN1decoding_t dec, ResourcesAvailableIndicate *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1Dec_ResourcesAvailableIndicate_protocols(dec, &(val)->protocols))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->almostOutOfResources))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_ResourcesAvailableIndicate_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_ResourcesAvailableIndicate_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_ICV(dec, &(val)->integrityCheckValue))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate(ResourcesAvailableIndicate *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1char16string_free(&(val)->endpointIdentifier);
	ASN1Free_ResourcesAvailableIndicate_protocols(&(val)->protocols);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_ResourcesAvailableIndicate_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_ResourcesAvailableIndicate_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm(ASN1encoding_t enc, ResourcesAvailableConfirm *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ResourcesAvailableConfirm_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_ResourcesAvailableConfirm_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_ICV(enc, &(val)->integrityCheckValue))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm(ASN1decoding_t dec, ResourcesAvailableConfirm *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_ResourcesAvailableConfirm_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_ResourcesAvailableConfirm_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_ICV(dec, &(val)->integrityCheckValue))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableConfirm(ResourcesAvailableConfirm *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_ResourcesAvailableConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_ResourcesAvailableConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_integrity(ASN1encoding_t enc, PGatekeeperConfirm_integrity *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperConfirm_integrity_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_integrity_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_integrity val)
{
    if (!ASN1Enc_IntegrityMechanism(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_integrity(ASN1decoding_t dec, PGatekeeperConfirm_integrity *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperConfirm_integrity_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_integrity_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_integrity val)
{
    if (!ASN1Dec_IntegrityMechanism(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_integrity(PGatekeeperConfirm_integrity *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperConfirm_integrity_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_integrity_ElmFn(PGatekeeperConfirm_integrity val)
{
    if (val) {
	ASN1Free_IntegrityMechanism(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_integrity(ASN1encoding_t enc, PGatekeeperRequest_integrity *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_integrity_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_integrity_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_integrity val)
{
    if (!ASN1Enc_IntegrityMechanism(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_integrity(ASN1decoding_t dec, PGatekeeperRequest_integrity *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_integrity_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_integrity_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_integrity val)
{
    if (!ASN1Dec_IntegrityMechanism(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_integrity(PGatekeeperRequest_integrity *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_integrity_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_integrity_ElmFn(PGatekeeperRequest_integrity val)
{
    if (val) {
	ASN1Free_IntegrityMechanism(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CryptoH323Token_cryptoGKPwdHash(ASN1encoding_t enc, CryptoH323Token_cryptoGKPwdHash *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperId).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperId).length, ((val)->gatekeeperId).value, 16))
	return 0;
    l = ASN1uint32_uoctets((val)->timeStamp - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->timeStamp - 1))
	return 0;
    if (!ASN1Enc_HASHED(enc, &(val)->token))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoH323Token_cryptoGKPwdHash(ASN1decoding_t dec, CryptoH323Token_cryptoGKPwdHash *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperId).length))
	return 0;
    ((val)->gatekeeperId).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperId).length, &((val)->gatekeeperId).value, 16))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->timeStamp))
	return 0;
    (val)->timeStamp += 1;
    if (!ASN1Dec_HASHED(dec, &(val)->token))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CryptoH323Token_cryptoGKPwdHash(CryptoH323Token_cryptoGKPwdHash *val)
{
    if (val) {
	ASN1char16string_free(&(val)->gatekeeperId);
	ASN1Free_HASHED(&(val)->token);
    }
}

static int ASN1CALL ASN1Enc_NonStandardProtocol_dataRatesSupported(ASN1encoding_t enc, PNonStandardProtocol_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_NonStandardProtocol_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_NonStandardProtocol_dataRatesSupported_ElmFn(ASN1encoding_t enc, PNonStandardProtocol_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardProtocol_dataRatesSupported(ASN1decoding_t dec, PNonStandardProtocol_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_NonStandardProtocol_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_NonStandardProtocol_dataRatesSupported_ElmFn(ASN1decoding_t dec, PNonStandardProtocol_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardProtocol_dataRatesSupported(PNonStandardProtocol_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_NonStandardProtocol_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_NonStandardProtocol_dataRatesSupported_ElmFn(PNonStandardProtocol_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_T120OnlyCaps_dataRatesSupported(ASN1encoding_t enc, PT120OnlyCaps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_T120OnlyCaps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_T120OnlyCaps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PT120OnlyCaps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_T120OnlyCaps_dataRatesSupported(ASN1decoding_t dec, PT120OnlyCaps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_T120OnlyCaps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_T120OnlyCaps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PT120OnlyCaps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_T120OnlyCaps_dataRatesSupported(PT120OnlyCaps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_T120OnlyCaps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_T120OnlyCaps_dataRatesSupported_ElmFn(PT120OnlyCaps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_VoiceCaps_dataRatesSupported(ASN1encoding_t enc, PVoiceCaps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_VoiceCaps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_VoiceCaps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PVoiceCaps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VoiceCaps_dataRatesSupported(ASN1decoding_t dec, PVoiceCaps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_VoiceCaps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_VoiceCaps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PVoiceCaps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VoiceCaps_dataRatesSupported(PVoiceCaps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_VoiceCaps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_VoiceCaps_dataRatesSupported_ElmFn(PVoiceCaps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H324Caps_dataRatesSupported(ASN1encoding_t enc, PH324Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H324Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H324Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH324Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H324Caps_dataRatesSupported(ASN1decoding_t dec, PH324Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H324Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H324Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH324Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H324Caps_dataRatesSupported(PH324Caps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H324Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H324Caps_dataRatesSupported_ElmFn(PH324Caps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323Caps_dataRatesSupported(ASN1encoding_t enc, PH323Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H323Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H323Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH323Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323Caps_dataRatesSupported(ASN1decoding_t dec, PH323Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H323Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H323Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH323Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H323Caps_dataRatesSupported(PH323Caps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H323Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H323Caps_dataRatesSupported_ElmFn(PH323Caps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H322Caps_dataRatesSupported(ASN1encoding_t enc, PH322Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H322Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H322Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH322Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H322Caps_dataRatesSupported(ASN1decoding_t dec, PH322Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H322Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H322Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH322Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H322Caps_dataRatesSupported(PH322Caps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H322Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H322Caps_dataRatesSupported_ElmFn(PH322Caps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H321Caps_dataRatesSupported(ASN1encoding_t enc, PH321Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H321Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H321Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH321Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H321Caps_dataRatesSupported(ASN1decoding_t dec, PH321Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H321Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H321Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH321Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H321Caps_dataRatesSupported(PH321Caps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H321Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H321Caps_dataRatesSupported_ElmFn(PH321Caps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H320Caps_dataRatesSupported(ASN1encoding_t enc, PH320Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H320Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H320Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH320Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H320Caps_dataRatesSupported(ASN1decoding_t dec, PH320Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H320Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H320Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH320Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H320Caps_dataRatesSupported(PH320Caps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H320Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H320Caps_dataRatesSupported_ElmFn(PH320Caps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H310Caps_dataRatesSupported(ASN1encoding_t enc, PH310Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H310Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H310Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH310Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H310Caps_dataRatesSupported(ASN1decoding_t dec, PH310Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H310Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H310Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH310Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H310Caps_dataRatesSupported(PH310Caps_dataRatesSupported *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H310Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H310Caps_dataRatesSupported_ElmFn(PH310Caps_dataRatesSupported val)
{
    if (val) {
	ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_h245SecurityCapability(ASN1encoding_t enc, PSetup_UUIE_h245SecurityCapability *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_h245SecurityCapability_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_h245SecurityCapability_ElmFn(ASN1encoding_t enc, PSetup_UUIE_h245SecurityCapability val)
{
    if (!ASN1Enc_H245Security(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_h245SecurityCapability(ASN1decoding_t dec, PSetup_UUIE_h245SecurityCapability *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_h245SecurityCapability_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_h245SecurityCapability_ElmFn(ASN1decoding_t dec, PSetup_UUIE_h245SecurityCapability val)
{
    if (!ASN1Dec_H245Security(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_h245SecurityCapability(PSetup_UUIE_h245SecurityCapability *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_h245SecurityCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_h245SecurityCapability_ElmFn(PSetup_UUIE_h245SecurityCapability val)
{
    if (val) {
	ASN1Free_H245Security(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_nonStandardControl(ASN1encoding_t enc, PH323_UU_PDU_nonStandardControl *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H323_UU_PDU_nonStandardControl_ElmFn);
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_nonStandardControl_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_nonStandardControl val)
{
    if (!ASN1Enc_H225NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_nonStandardControl(ASN1decoding_t dec, PH323_UU_PDU_nonStandardControl *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H323_UU_PDU_nonStandardControl_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_nonStandardControl_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_nonStandardControl val)
{
    if (!ASN1Dec_H225NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU_nonStandardControl(PH323_UU_PDU_nonStandardControl *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H323_UU_PDU_nonStandardControl_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H323_UU_PDU_nonStandardControl_ElmFn(PH323_UU_PDU_nonStandardControl val)
{
    if (val) {
	ASN1Free_H225NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CryptoToken_cryptoHashedToken(ASN1encoding_t enc, CryptoToken_cryptoHashedToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->tokenOID))
	return 0;
    if (!ASN1Enc_ClearToken(enc, &(val)->hashedVals))
	return 0;
    if (!ASN1Enc_HASHED(enc, &(val)->token))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoToken_cryptoHashedToken(ASN1decoding_t dec, CryptoToken_cryptoHashedToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->tokenOID))
	return 0;
    if (!ASN1Dec_ClearToken(dec, &(val)->hashedVals))
	return 0;
    if (!ASN1Dec_HASHED(dec, &(val)->token))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CryptoToken_cryptoHashedToken(CryptoToken_cryptoHashedToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->tokenOID);
	ASN1Free_ClearToken(&(val)->hashedVals);
	ASN1Free_HASHED(&(val)->token);
    }
}

static int ASN1CALL ASN1Enc_CryptoToken_cryptoSignedToken(ASN1encoding_t enc, CryptoToken_cryptoSignedToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->tokenOID))
	return 0;
    if (!ASN1Enc_SIGNED_EncodedGeneralToken(enc, &(val)->token))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoToken_cryptoSignedToken(ASN1decoding_t dec, CryptoToken_cryptoSignedToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->tokenOID))
	return 0;
    if (!ASN1Dec_SIGNED_EncodedGeneralToken(dec, &(val)->token))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CryptoToken_cryptoSignedToken(CryptoToken_cryptoSignedToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->tokenOID);
	ASN1Free_SIGNED_EncodedGeneralToken(&(val)->token);
    }
}

static int ASN1CALL ASN1Enc_CryptoToken_cryptoEncryptedToken(ASN1encoding_t enc, CryptoToken_cryptoEncryptedToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->tokenOID))
	return 0;
    if (!ASN1Enc_ENCRYPTED(enc, &(val)->token))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoToken_cryptoEncryptedToken(ASN1decoding_t dec, CryptoToken_cryptoEncryptedToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->tokenOID))
	return 0;
    if (!ASN1Dec_ENCRYPTED(dec, &(val)->token))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CryptoToken_cryptoEncryptedToken(CryptoToken_cryptoEncryptedToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->tokenOID);
	ASN1Free_ENCRYPTED(&(val)->token);
    }
}

static int ASN1CALL ASN1Enc_CryptoToken(ASN1encoding_t enc, CryptoToken *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_CryptoToken_cryptoEncryptedToken(enc, &(val)->u.cryptoEncryptedToken))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_CryptoToken_cryptoSignedToken(enc, &(val)->u.cryptoSignedToken))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_CryptoToken_cryptoHashedToken(enc, &(val)->u.cryptoHashedToken))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ENCRYPTED(enc, &(val)->u.cryptoPwdEncr))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoToken(ASN1decoding_t dec, CryptoToken *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_CryptoToken_cryptoEncryptedToken(dec, &(val)->u.cryptoEncryptedToken))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_CryptoToken_cryptoSignedToken(dec, &(val)->u.cryptoSignedToken))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_CryptoToken_cryptoHashedToken(dec, &(val)->u.cryptoHashedToken))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ENCRYPTED(dec, &(val)->u.cryptoPwdEncr))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CryptoToken(CryptoToken *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_CryptoToken_cryptoEncryptedToken(&(val)->u.cryptoEncryptedToken);
	    break;
	case 2:
	    ASN1Free_CryptoToken_cryptoSignedToken(&(val)->u.cryptoSignedToken);
	    break;
	case 3:
	    ASN1Free_CryptoToken_cryptoHashedToken(&(val)->u.cryptoHashedToken);
	    break;
	case 4:
	    ASN1Free_ENCRYPTED(&(val)->u.cryptoPwdEncr);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_SIGNED_EncodedFastStartToken(ASN1encoding_t enc, SIGNED_EncodedFastStartToken *val)
{
    if (!ASN1Enc_EncodedFastStartToken(enc, &(val)->toBeSigned))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
	return 0;
    if (!ASN1Enc_Params(enc, &(val)->paramS))
	return 0;
    if (!ASN1PEREncFragmented(enc, ((val)->signature).length, ((val)->signature).value, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SIGNED_EncodedFastStartToken(ASN1decoding_t dec, SIGNED_EncodedFastStartToken *val)
{
    if (!ASN1Dec_EncodedFastStartToken(dec, &(val)->toBeSigned))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
	return 0;
    if (!ASN1Dec_Params(dec, &(val)->paramS))
	return 0;
    if (!ASN1PERDecFragmented(dec, &((val)->signature).length, &((val)->signature).value, 1))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SIGNED_EncodedFastStartToken(SIGNED_EncodedFastStartToken *val)
{
    if (val) {
	ASN1Free_EncodedFastStartToken(&(val)->toBeSigned);
	ASN1objectidentifier_free(&(val)->algorithmOID);
	ASN1Free_Params(&(val)->paramS);
	ASN1bitstring_free(&(val)->signature);
    }
}

static int ASN1CALL ASN1Enc_TransportAddress(ASN1encoding_t enc, TransportAddress *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_TransportAddress_ipAddress(enc, &(val)->u.ipAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_TransportAddress_ipSourceRoute(enc, &(val)->u.ipSourceRoute))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_TransportAddress_ipxAddress(enc, &(val)->u.ipxAddress))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_TransportAddress_ip6Address(enc, &(val)->u.ip6Address))
	    return 0;
	break;
    case 5:
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
	    return 0;
	break;
    case 6:
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardAddress))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress(ASN1decoding_t dec, TransportAddress *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_TransportAddress_ipAddress(dec, &(val)->u.ipAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_TransportAddress_ipSourceRoute(dec, &(val)->u.ipSourceRoute))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_TransportAddress_ipxAddress(dec, &(val)->u.ipxAddress))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_TransportAddress_ip6Address(dec, &(val)->u.ip6Address))
	    return 0;
	break;
    case 5:
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
	    return 0;
	break;
    case 6:
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardAddress))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress(TransportAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_TransportAddress_ipAddress(&(val)->u.ipAddress);
	    break;
	case 2:
	    ASN1Free_TransportAddress_ipSourceRoute(&(val)->u.ipSourceRoute);
	    break;
	case 3:
	    ASN1Free_TransportAddress_ipxAddress(&(val)->u.ipxAddress);
	    break;
	case 4:
	    ASN1Free_TransportAddress_ip6Address(&(val)->u.ip6Address);
	    break;
	case 5:
	    break;
	case 6:
	    break;
	case 7:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardAddress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_GatewayInfo(ASN1encoding_t enc, GatewayInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_GatewayInfo_protocol(enc, &(val)->protocol))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatewayInfo(ASN1decoding_t dec, GatewayInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_GatewayInfo_protocol(dec, &(val)->protocol))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatewayInfo(GatewayInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_GatewayInfo_protocol(&(val)->protocol);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_H310Caps(ASN1encoding_t enc, H310Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H310Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H310Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H310Caps(ASN1decoding_t dec, H310Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H310Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H310Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H310Caps(H310Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H310Caps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H310Caps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_H320Caps(ASN1encoding_t enc, H320Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H320Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H320Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H320Caps(ASN1decoding_t dec, H320Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H320Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H320Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H320Caps(H320Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H320Caps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H320Caps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_H321Caps(ASN1encoding_t enc, H321Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H321Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H321Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H321Caps(ASN1decoding_t dec, H321Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H321Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H321Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H321Caps(H321Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H321Caps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H321Caps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_H322Caps(ASN1encoding_t enc, H322Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H322Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H322Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H322Caps(ASN1decoding_t dec, H322Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H322Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H322Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H322Caps(H322Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H322Caps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H322Caps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_H323Caps(ASN1encoding_t enc, H323Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H323Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H323Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H323Caps(ASN1decoding_t dec, H323Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H323Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H323Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323Caps(H323Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H323Caps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H323Caps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_H324Caps(ASN1encoding_t enc, H324Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H324Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H324Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H324Caps(ASN1decoding_t dec, H324Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H324Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H324Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H324Caps(H324Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H324Caps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H324Caps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_VoiceCaps(ASN1encoding_t enc, VoiceCaps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_VoiceCaps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_VoiceCaps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VoiceCaps(ASN1decoding_t dec, VoiceCaps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_VoiceCaps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_VoiceCaps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_VoiceCaps(VoiceCaps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_VoiceCaps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_VoiceCaps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_T120OnlyCaps(ASN1encoding_t enc, T120OnlyCaps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_T120OnlyCaps_dataRatesSupported(ee, &(val)->dataRatesSupported))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_T120OnlyCaps_supportedPrefixes(ee, &(val)->supportedPrefixes))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_T120OnlyCaps(ASN1decoding_t dec, T120OnlyCaps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_T120OnlyCaps_dataRatesSupported(dd, &(val)->dataRatesSupported))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_T120OnlyCaps_supportedPrefixes(dd, &(val)->supportedPrefixes))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_T120OnlyCaps(T120OnlyCaps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_T120OnlyCaps_dataRatesSupported(&(val)->dataRatesSupported);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_T120OnlyCaps_supportedPrefixes(&(val)->supportedPrefixes);
	}
    }
}

static int ASN1CALL ASN1Enc_NonStandardProtocol(ASN1encoding_t enc, NonStandardProtocol *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_NonStandardProtocol_dataRatesSupported(enc, &(val)->dataRatesSupported))
	    return 0;
    }
    if (!ASN1Enc_NonStandardProtocol_supportedPrefixes(enc, &(val)->supportedPrefixes))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardProtocol(ASN1decoding_t dec, NonStandardProtocol *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_NonStandardProtocol_dataRatesSupported(dec, &(val)->dataRatesSupported))
	    return 0;
    }
    if (!ASN1Dec_NonStandardProtocol_supportedPrefixes(dec, &(val)->supportedPrefixes))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardProtocol(NonStandardProtocol *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_NonStandardProtocol_dataRatesSupported(&(val)->dataRatesSupported);
	}
	ASN1Free_NonStandardProtocol_supportedPrefixes(&(val)->supportedPrefixes);
    }
}

static int ASN1CALL ASN1Enc_McuInfo(ASN1encoding_t enc, McuInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_McuInfo(ASN1decoding_t dec, McuInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_McuInfo(McuInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_TerminalInfo(ASN1encoding_t enc, TerminalInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalInfo(ASN1decoding_t dec, TerminalInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TerminalInfo(TerminalInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_GatekeeperInfo(ASN1encoding_t enc, GatekeeperInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperInfo(ASN1decoding_t dec, GatekeeperInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperInfo(GatekeeperInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static ASN1stringtableentry_t PartyNumber_dataPartyNumber_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PartyNumber_dataPartyNumber_StringTable = {
    4, PartyNumber_dataPartyNumber_StringTableEntries
};

static ASN1stringtableentry_t PartyNumber_telexPartyNumber_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PartyNumber_telexPartyNumber_StringTable = {
    4, PartyNumber_telexPartyNumber_StringTableEntries
};

static ASN1stringtableentry_t PartyNumber_nationalStandardPartyNumber_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PartyNumber_nationalStandardPartyNumber_StringTable = {
    4, PartyNumber_nationalStandardPartyNumber_StringTableEntries
};

static int ASN1CALL ASN1Enc_PartyNumber(ASN1encoding_t enc, PartyNumber *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_PublicPartyNumber(enc, &(val)->u.publicNumber))
	    return 0;
	break;
    case 2:
	t = lstrlenA((val)->u.dataPartyNumber);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.dataPartyNumber, 4, &PartyNumber_dataPartyNumber_StringTable))
	    return 0;
	break;
    case 3:
	t = lstrlenA((val)->u.telexPartyNumber);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.telexPartyNumber, 4, &PartyNumber_telexPartyNumber_StringTable))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_PrivatePartyNumber(enc, &(val)->u.privateNumber))
	    return 0;
	break;
    case 5:
	t = lstrlenA((val)->u.nationalStandardPartyNumber);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.nationalStandardPartyNumber, 4, &PartyNumber_nationalStandardPartyNumber_StringTable))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PartyNumber(ASN1decoding_t dec, PartyNumber *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_PublicPartyNumber(dec, &(val)->u.publicNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);

        // SECURITY BUG: 782696
        if ( l >= sizeof( (val)->u.dataPartyNumber ) )
        {
            ASN1DecSetError(dec, ASN1_ERR_LARGE);
            return 0;
        }

	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.dataPartyNumber, 4, &PartyNumber_dataPartyNumber_StringTable))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);

        // SECURITY BUG: 782696
        if ( l >= sizeof( (val)->u.telexPartyNumber ) )
        {
            ASN1DecSetError(dec, ASN1_ERR_LARGE);
            return 0;
        }

	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.telexPartyNumber, 4, &PartyNumber_telexPartyNumber_StringTable))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_PrivatePartyNumber(dec, &(val)->u.privateNumber))
	    return 0;
	break;
    case 5:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);

        // SECURITY BUG: 782696
        if ( l >= sizeof( (val)->u.nationalStandardPartyNumber ) )
        {
            ASN1DecSetError(dec, ASN1_ERR_LARGE);
            return 0;
        }

	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.nationalStandardPartyNumber, 4, &PartyNumber_nationalStandardPartyNumber_StringTable))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PartyNumber(PartyNumber *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_PublicPartyNumber(&(val)->u.publicNumber);
	    break;
	case 2:
	    break;
	case 3:
	    break;
	case 4:
	    ASN1Free_PrivatePartyNumber(&(val)->u.privateNumber);
	    break;
	case 5:
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_AlternateGK(ASN1encoding_t enc, AlternateGK *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->rasAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->needToRegister))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->priority))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlternateGK(ASN1decoding_t dec, AlternateGK *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_TransportAddress(dec, &(val)->rasAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->needToRegister))
	return 0;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->priority))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AlternateGK(AlternateGK *val)
{
    if (val) {
	ASN1Free_TransportAddress(&(val)->rasAddress);
	if ((val)->o[0] & 0x80) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
    }
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm(ASN1encoding_t enc, GatekeeperConfirm *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(7, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Enc_TransportAddress(enc, &(val)->rasAddress))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 7, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_GatekeeperConfirm_alternateGatekeeper(ee, &(val)->alternateGatekeeper))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_AuthenticationMechanism(ee, &(val)->authenticationMode))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_GatekeeperConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_GatekeeperConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PEREncObjectIdentifier(ee, &(val)->algorithmOID))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1Enc_GatekeeperConfirm_integrity(ee, &(val)->integrity))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm(ASN1decoding_t dec, GatekeeperConfirm *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Dec_TransportAddress(dec, &(val)->rasAddress))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 7, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperConfirm_alternateGatekeeper(dd, &(val)->alternateGatekeeper))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AuthenticationMechanism(dd, &(val)->authenticationMode))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecObjectIdentifier(dd, &(val)->algorithmOID))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperConfirm_integrity(dd, &(val)->integrity))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperConfirm(GatekeeperConfirm *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	ASN1Free_TransportAddress(&(val)->rasAddress);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_GatekeeperConfirm_alternateGatekeeper(&(val)->alternateGatekeeper);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_AuthenticationMechanism(&(val)->authenticationMode);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_GatekeeperConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_GatekeeperConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1objectidentifier_free(&(val)->algorithmOID);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_GatekeeperConfirm_integrity(&(val)->integrity);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest(ASN1encoding_t enc, AdmissionRequest *val)
{
    ASN1octet_t o[3];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 3);
    o[1] |= 0x80;
    o[1] |= 0x40;
    o[2] |= 0x40;
    y = ASN1PEREncCheckExtensions(10, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 7, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_CallType(enc, &(val)->callType))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_CallModel(enc, &(val)->callModel))
	    return 0;
    }
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_AdmissionRequest_destinationInfo(enc, &(val)->destinationInfo))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->destCallSignalAddress))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1Enc_AdmissionRequest_destExtraCallInfo(enc, &(val)->destExtraCallInfo))
	    return 0;
    }
    if (!ASN1Enc_AdmissionRequest_srcInfo(enc, &(val)->srcInfo))
	return 0;
    if (o[0] & 0x8) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->srcCallSignalAddress))
	    return 0;
    }
    l = ASN1uint32_uoctets((val)->bandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bandWidth))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->callReferenceValue))
	return 0;
    if (o[0] & 0x4) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (o[0] & 0x2) {
	if (!ASN1Enc_QseriesOptions(enc, &(val)->callServices))
	    return 0;
    }
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->activeMC))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->answerCall))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 10, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1PEREncBoolean(ee, (val)->canMapAlias))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_AdmissionRequest_srcAlternatives(ee, &(val)->srcAlternatives))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_AdmissionRequest_destAlternatives(ee, &(val)->destAlternatives))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1PEREncBitVal(ee, 7, ((val)->gatekeeperIdentifier).length - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncChar16String(ee, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1Enc_AdmissionRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1Enc_AdmissionRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x1) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[2] & 0x80) {
	    if (!ASN1Enc_TransportQOS(ee, &(val)->transportQOS))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[2] & 0x40) {
	    if (!ASN1PEREncBoolean(ee, (val)->willSupplyUUIEs))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest(ASN1decoding_t dec, AdmissionRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_CallType(dec, &(val)->callType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CallModel(dec, &(val)->callModel))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_AdmissionRequest_destinationInfo(dec, &(val)->destinationInfo))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->destCallSignalAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_AdmissionRequest_destExtraCallInfo(dec, &(val)->destExtraCallInfo))
	    return 0;
    }
    if (!ASN1Dec_AdmissionRequest_srcInfo(dec, &(val)->srcInfo))
	return 0;
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->srcCallSignalAddress))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bandWidth))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->callReferenceValue))
	return 0;
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_QseriesOptions(dec, &(val)->callServices))
	    return 0;
    }
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->activeMC))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->answerCall))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 2);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 10, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->canMapAlias))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionRequest_srcAlternatives(dd, &(val)->srcAlternatives))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionRequest_destAlternatives(dd, &(val)->destAlternatives))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 7, &((val)->gatekeeperIdentifier).length))
		return 0;
	    ((val)->gatekeeperIdentifier).length += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecChar16String(dd, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[2] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_TransportQOS(dd, &(val)->transportQOS))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[2] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->willSupplyUUIEs))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest(AdmissionRequest *val)
{
    if (val) {
	ASN1char16string_free(&(val)->endpointIdentifier);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_AdmissionRequest_destinationInfo(&(val)->destinationInfo);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_TransportAddress(&(val)->destCallSignalAddress);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_AdmissionRequest_destExtraCallInfo(&(val)->destExtraCallInfo);
	}
	ASN1Free_AdmissionRequest_srcInfo(&(val)->srcInfo);
	if ((val)->o[0] & 0x8) {
	    ASN1Free_TransportAddress(&(val)->srcCallSignalAddress);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_AdmissionRequest_srcAlternatives(&(val)->srcAlternatives);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_AdmissionRequest_destAlternatives(&(val)->destAlternatives);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_AdmissionRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_AdmissionRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x1) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_LocationRequest(ASN1encoding_t enc, LocationRequest *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(6, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Enc_LocationRequest_destinationInfo(enc, &(val)->destinationInfo))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Enc_TransportAddress(enc, &(val)->replyAddress))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 6, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_LocationRequest_sourceInfo(ee, &(val)->sourceInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1PEREncBoolean(ee, (val)->canMapAlias))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1PEREncBitVal(ee, 7, ((val)->gatekeeperIdentifier).length - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncChar16String(ee, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_LocationRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_LocationRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRequest(ASN1decoding_t dec, LocationRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	    return 0;
	((val)->endpointIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Dec_LocationRequest_destinationInfo(dec, &(val)->destinationInfo))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Dec_TransportAddress(dec, &(val)->replyAddress))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 6, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationRequest_sourceInfo(dd, &(val)->sourceInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->canMapAlias))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 7, &((val)->gatekeeperIdentifier).length))
		return 0;
	    ((val)->gatekeeperIdentifier).length += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecChar16String(dd, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_LocationRequest(LocationRequest *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1char16string_free(&(val)->endpointIdentifier);
	}
	ASN1Free_LocationRequest_destinationInfo(&(val)->destinationInfo);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_TransportAddress(&(val)->replyAddress);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_LocationRequest_sourceInfo(&(val)->sourceInfo);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_LocationRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_LocationRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequest(ASN1encoding_t enc, InfoRequest *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->callReferenceValue))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->replyAddress))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 5, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_InfoRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_InfoRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_UUIEsRequested(ee, &(val)->uuiesRequested))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequest(ASN1decoding_t dec, InfoRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->callReferenceValue))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->replyAddress))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UUIEsRequested(dd, &(val)->uuiesRequested))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequest(InfoRequest *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_TransportAddress(&(val)->replyAddress);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_InfoRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_InfoRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_TransportChannelInfo(ASN1encoding_t enc, TransportChannelInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->sendAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->recvAddress))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportChannelInfo(ASN1decoding_t dec, TransportChannelInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->sendAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->recvAddress))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportChannelInfo(TransportChannelInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->sendAddress);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_TransportAddress(&(val)->recvAddress);
	}
    }
}

static int ASN1CALL ASN1Enc_RTPSession(ASN1encoding_t enc, RTPSession *val)
{
    ASN1uint32_t t;
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TransportChannelInfo(enc, &(val)->rtpAddress))
	return 0;
    if (!ASN1Enc_TransportChannelInfo(enc, &(val)->rtcpAddress))
	return 0;
    t = lstrlenA((val)->cname);
    if (!ASN1PEREncFragmentedCharString(enc, t, (val)->cname, 8))
	return 0;
    l = ASN1uint32_uoctets((val)->ssrc - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->ssrc - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->sessionId - 1))
	return 0;
    if (!ASN1Enc_RTPSession_associatedSessionIds(enc, &(val)->associatedSessionIds))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RTPSession(ASN1decoding_t dec, RTPSession *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TransportChannelInfo(dec, &(val)->rtpAddress))
	return 0;
    if (!ASN1Dec_TransportChannelInfo(dec, &(val)->rtcpAddress))
	return 0;
    if (!ASN1PERDecFragmentedZeroCharString(dec, &(val)->cname, 8))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->ssrc))
	return 0;
    (val)->ssrc += 1;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sessionId))
	return 0;
    (val)->sessionId += 1;
    if (!ASN1Dec_RTPSession_associatedSessionIds(dec, &(val)->associatedSessionIds))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPSession(RTPSession *val)
{
    if (val) {
	ASN1Free_TransportChannelInfo(&(val)->rtpAddress);
	ASN1Free_TransportChannelInfo(&(val)->rtcpAddress);
	ASN1ztcharstring_free((val)->cname);
	ASN1Free_RTPSession_associatedSessionIds(&(val)->associatedSessionIds);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_data *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_data val)
{
    if (!ASN1Enc_TransportChannelInfo(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_data *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_data val)
{
    if (!ASN1Dec_TransportChannelInfo(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_data(PInfoRequestResponse_perCallInfo_Seq_data *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_data_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(PInfoRequestResponse_perCallInfo_Seq_data val)
{
    if (val) {
	ASN1Free_TransportChannelInfo(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_video *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_video val)
{
    if (!ASN1Enc_RTPSession(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_video *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_video val)
{
    if (!ASN1Dec_RTPSession(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_video(PInfoRequestResponse_perCallInfo_Seq_video *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_video_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(PInfoRequestResponse_perCallInfo_Seq_video val)
{
    if (val) {
	ASN1Free_RTPSession(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_audio *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_audio val)
{
    if (!ASN1Enc_RTPSession(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_audio *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_audio val)
{
    if (!ASN1Dec_RTPSession(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio(PInfoRequestResponse_perCallInfo_Seq_audio *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(PInfoRequestResponse_perCallInfo_Seq_audio val)
{
    if (val) {
	ASN1Free_RTPSession(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq(ASN1encoding_t enc, InfoRequestResponse_perCallInfo_Seq *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    o[1] |= 0x10;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 5, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->callReferenceValue))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1PEREncBoolean(enc, (val)->originator))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio(enc, &(val)->audio))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video(enc, &(val)->video))
	    return 0;
    }
    if (o[0] & 0x8) {
	if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data(enc, &(val)->data))
	    return 0;
    }
    if (!ASN1Enc_TransportChannelInfo(enc, &(val)->h245))
	return 0;
    if (!ASN1Enc_TransportChannelInfo(enc, &(val)->callSignaling))
	return 0;
    if (!ASN1Enc_CallType(enc, &(val)->callType))
	return 0;
    l = ASN1uint32_uoctets((val)->bandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bandWidth))
	return 0;
    if (!ASN1Enc_CallModel(enc, &(val)->callModel))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 5, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(ee, &(val)->substituteConfIDs))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu(ee, &(val)->pdu))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq(ASN1decoding_t dec, InfoRequestResponse_perCallInfo_Seq *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->callReferenceValue))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecBoolean(dec, &(val)->originator))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio(dec, &(val)->audio))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video(dec, &(val)->video))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data(dec, &(val)->data))
	    return 0;
    }
    if (!ASN1Dec_TransportChannelInfo(dec, &(val)->h245))
	return 0;
    if (!ASN1Dec_TransportChannelInfo(dec, &(val)->callSignaling))
	return 0;
    if (!ASN1Dec_CallType(dec, &(val)->callType))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bandWidth))
	return 0;
    if (!ASN1Dec_CallModel(dec, &(val)->callModel))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(dd, &(val)->substituteConfIDs))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu(dd, &(val)->pdu))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq(InfoRequestResponse_perCallInfo_Seq *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio(&(val)->audio);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_video(&(val)->video);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_data(&(val)->data);
	}
	ASN1Free_TransportChannelInfo(&(val)->h245);
	ASN1Free_TransportChannelInfo(&(val)->callSignaling);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(&(val)->substituteConfIDs);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu(&(val)->pdu);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo val)
{
    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo val)
{
    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo(PInfoRequestResponse_perCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_ElmFn(PInfoRequestResponse_perCallInfo val)
{
    if (val) {
	ASN1Free_InfoRequestResponse_perCallInfo_Seq(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_callSignalAddress(ASN1encoding_t enc, PInfoRequestResponse_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_callSignalAddress_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_callSignalAddress(ASN1decoding_t dec, PInfoRequestResponse_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_callSignalAddress_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_callSignalAddress(PInfoRequestResponse_callSignalAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_callSignalAddress_ElmFn(PInfoRequestResponse_callSignalAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionReject_callSignalAddress(ASN1encoding_t enc, PAdmissionReject_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionReject_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionReject_callSignalAddress_ElmFn(ASN1encoding_t enc, PAdmissionReject_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionReject_callSignalAddress(ASN1decoding_t dec, PAdmissionReject_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionReject_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionReject_callSignalAddress_ElmFn(ASN1decoding_t dec, PAdmissionReject_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionReject_callSignalAddress(PAdmissionReject_callSignalAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionReject_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionReject_callSignalAddress_ElmFn(PAdmissionReject_callSignalAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_callSignalAddress(ASN1encoding_t enc, PUnregistrationRequest_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationRequest_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_callSignalAddress_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_callSignalAddress(ASN1decoding_t dec, PUnregistrationRequest_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationRequest_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_callSignalAddress_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest_callSignalAddress(PUnregistrationRequest_callSignalAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationRequest_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationRequest_callSignalAddress_ElmFn(PUnregistrationRequest_callSignalAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_alternateGatekeeper(ASN1encoding_t enc, PRegistrationConfirm_alternateGatekeeper *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationConfirm_alternateGatekeeper_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_alternateGatekeeper val)
{
    if (!ASN1Enc_AlternateGK(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_alternateGatekeeper(ASN1decoding_t dec, PRegistrationConfirm_alternateGatekeeper *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationConfirm_alternateGatekeeper_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_alternateGatekeeper val)
{
    if (!ASN1Dec_AlternateGK(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm_alternateGatekeeper(PRegistrationConfirm_alternateGatekeeper *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationConfirm_alternateGatekeeper_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationConfirm_alternateGatekeeper_ElmFn(PRegistrationConfirm_alternateGatekeeper val)
{
    if (val) {
	ASN1Free_AlternateGK(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_callSignalAddress(ASN1encoding_t enc, PRegistrationConfirm_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationConfirm_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_callSignalAddress_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_callSignalAddress(ASN1decoding_t dec, PRegistrationConfirm_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationConfirm_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_callSignalAddress_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm_callSignalAddress(PRegistrationConfirm_callSignalAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationConfirm_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationConfirm_callSignalAddress_ElmFn(PRegistrationConfirm_callSignalAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_rasAddress(ASN1encoding_t enc, PRegistrationRequest_rasAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_rasAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_rasAddress_ElmFn(ASN1encoding_t enc, PRegistrationRequest_rasAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_rasAddress(ASN1decoding_t dec, PRegistrationRequest_rasAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_rasAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_rasAddress_ElmFn(ASN1decoding_t dec, PRegistrationRequest_rasAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_rasAddress(PRegistrationRequest_rasAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_rasAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_rasAddress_ElmFn(PRegistrationRequest_rasAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_callSignalAddress(ASN1encoding_t enc, PRegistrationRequest_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_callSignalAddress_ElmFn(ASN1encoding_t enc, PRegistrationRequest_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_callSignalAddress(ASN1decoding_t dec, PRegistrationRequest_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_callSignalAddress_ElmFn(ASN1decoding_t dec, PRegistrationRequest_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_callSignalAddress(PRegistrationRequest_callSignalAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_callSignalAddress_ElmFn(PRegistrationRequest_callSignalAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_alternateGatekeeper(ASN1encoding_t enc, PGatekeeperConfirm_alternateGatekeeper *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperConfirm_alternateGatekeeper_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_alternateGatekeeper val)
{
    if (!ASN1Enc_AlternateGK(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_alternateGatekeeper(ASN1decoding_t dec, PGatekeeperConfirm_alternateGatekeeper *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperConfirm_alternateGatekeeper_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_alternateGatekeeper val)
{
    if (!ASN1Dec_AlternateGK(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_alternateGatekeeper(PGatekeeperConfirm_alternateGatekeeper *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperConfirm_alternateGatekeeper_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_alternateGatekeeper_ElmFn(PGatekeeperConfirm_alternateGatekeeper val)
{
    if (val) {
	ASN1Free_AlternateGK(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AltGKInfo_alternateGatekeeper(ASN1encoding_t enc, PAltGKInfo_alternateGatekeeper *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AltGKInfo_alternateGatekeeper_ElmFn);
}

static int ASN1CALL ASN1Enc_AltGKInfo_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PAltGKInfo_alternateGatekeeper val)
{
    if (!ASN1Enc_AlternateGK(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AltGKInfo_alternateGatekeeper(ASN1decoding_t dec, PAltGKInfo_alternateGatekeeper *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AltGKInfo_alternateGatekeeper_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AltGKInfo_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PAltGKInfo_alternateGatekeeper val)
{
    if (!ASN1Dec_AlternateGK(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AltGKInfo_alternateGatekeeper(PAltGKInfo_alternateGatekeeper *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AltGKInfo_alternateGatekeeper_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AltGKInfo_alternateGatekeeper_ElmFn(PAltGKInfo_alternateGatekeeper val)
{
    if (val) {
	ASN1Free_AlternateGK(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_rasAddress(ASN1encoding_t enc, PEndpoint_rasAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_rasAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_rasAddress_ElmFn(ASN1encoding_t enc, PEndpoint_rasAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_rasAddress(ASN1decoding_t dec, PEndpoint_rasAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_rasAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_rasAddress_ElmFn(ASN1decoding_t dec, PEndpoint_rasAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_rasAddress(PEndpoint_rasAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_rasAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_rasAddress_ElmFn(PEndpoint_rasAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_callSignalAddress(ASN1encoding_t enc, PEndpoint_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_callSignalAddress_ElmFn(ASN1encoding_t enc, PEndpoint_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_callSignalAddress(ASN1decoding_t dec, PEndpoint_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_callSignalAddress_ElmFn(ASN1decoding_t dec, PEndpoint_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_callSignalAddress(PEndpoint_callSignalAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_callSignalAddress_ElmFn(PEndpoint_callSignalAddress val)
{
    if (val) {
	ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_EndpointType(ASN1encoding_t enc, EndpointType *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_VendorIdentifier(enc, &(val)->vendor))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_GatekeeperInfo(enc, &(val)->gatekeeper))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_GatewayInfo(enc, &(val)->gateway))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_McuInfo(enc, &(val)->mcu))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_TerminalInfo(enc, &(val)->terminal))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->mc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->undefinedNode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EndpointType(ASN1decoding_t dec, EndpointType *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_VendorIdentifier(dec, &(val)->vendor))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_GatekeeperInfo(dec, &(val)->gatekeeper))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_GatewayInfo(dec, &(val)->gateway))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_McuInfo(dec, &(val)->mcu))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_TerminalInfo(dec, &(val)->terminal))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->mc))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->undefinedNode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EndpointType(EndpointType *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_VendorIdentifier(&(val)->vendor);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_GatekeeperInfo(&(val)->gatekeeper);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_GatewayInfo(&(val)->gateway);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_McuInfo(&(val)->mcu);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_TerminalInfo(&(val)->terminal);
	}
    }
}

static int ASN1CALL ASN1Enc_SupportedProtocols(ASN1encoding_t enc, SupportedProtocols *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 9))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H310Caps(enc, &(val)->u.h310))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H320Caps(enc, &(val)->u.h320))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_H321Caps(enc, &(val)->u.h321))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_H322Caps(enc, &(val)->u.h322))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_H323Caps(enc, &(val)->u.h323))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_H324Caps(enc, &(val)->u.h324))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_VoiceCaps(enc, &(val)->u.voice))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_T120OnlyCaps(enc, &(val)->u.t120_only))
	    return 0;
	break;
    case 10:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_NonStandardProtocol(ee, &(val)->u.nonStandardProtocol))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SupportedProtocols(ASN1decoding_t dec, SupportedProtocols *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 9))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H310Caps(dec, &(val)->u.h310))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H320Caps(dec, &(val)->u.h320))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_H321Caps(dec, &(val)->u.h321))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_H322Caps(dec, &(val)->u.h322))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_H323Caps(dec, &(val)->u.h323))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_H324Caps(dec, &(val)->u.h324))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_VoiceCaps(dec, &(val)->u.voice))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_T120OnlyCaps(dec, &(val)->u.t120_only))
	    return 0;
	break;
    case 10:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_NonStandardProtocol(dd, &(val)->u.nonStandardProtocol))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SupportedProtocols(SupportedProtocols *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	case 2:
	    ASN1Free_H310Caps(&(val)->u.h310);
	    break;
	case 3:
	    ASN1Free_H320Caps(&(val)->u.h320);
	    break;
	case 4:
	    ASN1Free_H321Caps(&(val)->u.h321);
	    break;
	case 5:
	    ASN1Free_H322Caps(&(val)->u.h322);
	    break;
	case 6:
	    ASN1Free_H323Caps(&(val)->u.h323);
	    break;
	case 7:
	    ASN1Free_H324Caps(&(val)->u.h324);
	    break;
	case 8:
	    ASN1Free_VoiceCaps(&(val)->u.voice);
	    break;
	case 9:
	    ASN1Free_T120OnlyCaps(&(val)->u.t120_only);
	    break;
	case 10:
	    ASN1Free_NonStandardProtocol(&(val)->u.nonStandardProtocol);
	    break;
	}
    }
}

static ASN1stringtableentry_t AliasAddress_e164_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t AliasAddress_e164_StringTable = {
    4, AliasAddress_e164_StringTableEntries
};

static int ASN1CALL ASN1Enc_AliasAddress(ASN1encoding_t enc, AliasAddress *val)
{
    ASN1uint32_t t;
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	t = lstrlenA((val)->u.e164);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.e164, 4, &AliasAddress_e164_StringTable))
	    return 0;
	break;
    case 2:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->u.h323_ID).length - 1))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->u.h323_ID).length, ((val)->u.h323_ID).value, 16))
	    return 0;
	break;
    case 3:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	t = lstrlenA((val)->u.url_ID);
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 16, t - 1))
	    return 0;
	if (!ASN1PEREncCharString(ee, t, (val)->u.url_ID, 8))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TransportAddress(ee, &(val)->u.transportID))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 5:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	t = lstrlenA((val)->u.email_ID);
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 16, t - 1))
	    return 0;
	if (!ASN1PEREncCharString(ee, t, (val)->u.email_ID, 8))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 6:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_PartyNumber(ee, &(val)->u.partyNumber))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AliasAddress(ASN1decoding_t dec, AliasAddress *val)
{
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);

        // SECURITY BUG: 782696
        if ( l >= sizeof( (val)->u.e164 ) )
        {
            ASN1DecSetError(dec, ASN1_ERR_LARGE);
            return 0;
        }

	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.e164, 4, &AliasAddress_e164_StringTable))
	    return 0;
	break;
    case 2:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->u.h323_ID).length))
	    return 0;
	((val)->u.h323_ID).length += 1;
	if (!ASN1PERDecChar16String(dec, ((val)->u.h323_ID).length, &((val)->u.h323_ID).value, 16))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU32Val(dd, 16, &l))
	    return 0;
	l += 1;

        // SECURITY BUG: 782696
        if ( l >= sizeof( (val)->u.url_ID ) )
        {
            ASN1DecSetError(dec, ASN1_ERR_LARGE);
            return 0;
        }

	if (!ASN1PERDecZeroCharStringNoAlloc(dd, l, (val)->u.url_ID, 8))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_TransportAddress(dd, &(val)->u.transportID))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 5:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU32Val(dd, 16, &l))
	    return 0;
	l += 1;
        
        // SECURITY BUG: 782696
        if ( l >= sizeof( (val)->u.email_ID ) )
        {
            ASN1DecSetError(dec, ASN1_ERR_LARGE);
            return 0;
        }

	if (!ASN1PERDecZeroCharStringNoAlloc(dd, l, (val)->u.email_ID, 8))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 6:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_PartyNumber(dd, &(val)->u.partyNumber))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AliasAddress(AliasAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	case 2:
	    ASN1char16string_free(&(val)->u.h323_ID);
	    break;
	case 3:
	    break;
	case 4:
	    ASN1Free_TransportAddress(&(val)->u.transportID);
	    break;
	case 5:
	    break;
	case 6:
	    ASN1Free_PartyNumber(&(val)->u.partyNumber);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_Endpoint(ASN1encoding_t enc, Endpoint *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 10, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Endpoint_aliasAddress(enc, &(val)->aliasAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_Endpoint_callSignalAddress(enc, &(val)->callSignalAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_Endpoint_rasAddress(enc, &(val)->rasAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_EndpointType(enc, &(val)->endpointType))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_Endpoint_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_Endpoint_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1PEREncBitVal(enc, 7, (val)->priority))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1Enc_Endpoint_remoteExtensionAddress(enc, &(val)->remoteExtensionAddress))
	    return 0;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1Enc_Endpoint_destExtraCallInfo(enc, &(val)->destExtraCallInfo))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint(ASN1decoding_t dec, Endpoint *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 10, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_Endpoint_aliasAddress(dec, &(val)->aliasAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_Endpoint_callSignalAddress(dec, &(val)->callSignalAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_Endpoint_rasAddress(dec, &(val)->rasAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_EndpointType(dec, &(val)->endpointType))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_Endpoint_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_Endpoint_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1PERDecU16Val(dec, 7, &(val)->priority))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1Dec_Endpoint_remoteExtensionAddress(dec, &(val)->remoteExtensionAddress))
	    return 0;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1Dec_Endpoint_destExtraCallInfo(dec, &(val)->destExtraCallInfo))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint(Endpoint *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Endpoint_aliasAddress(&(val)->aliasAddress);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_Endpoint_callSignalAddress(&(val)->callSignalAddress);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_Endpoint_rasAddress(&(val)->rasAddress);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_EndpointType(&(val)->endpointType);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_Endpoint_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1Free_Endpoint_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_Endpoint_remoteExtensionAddress(&(val)->remoteExtensionAddress);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_Endpoint_destExtraCallInfo(&(val)->destExtraCallInfo);
	}
    }
}

static int ASN1CALL ASN1Enc_SupportedPrefix(ASN1encoding_t enc, SupportedPrefix *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Enc_AliasAddress(enc, &(val)->prefix))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SupportedPrefix(ASN1decoding_t dec, SupportedPrefix *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Dec_AliasAddress(dec, &(val)->prefix))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SupportedPrefix(SupportedPrefix *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_AliasAddress(&(val)->prefix);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest(ASN1encoding_t enc, GatekeeperRequest *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(7, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Enc_TransportAddress(enc, &(val)->rasAddress))
	return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->endpointType))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_QseriesOptions(enc, &(val)->callServices))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_GatekeeperRequest_endpointAlias(enc, &(val)->endpointAlias))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 7, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_GatekeeperRequest_alternateEndpoints(ee, &(val)->alternateEndpoints))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_GatekeeperRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_GatekeeperRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_GatekeeperRequest_authenticationCapability(ee, &(val)->authenticationCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1Enc_GatekeeperRequest_algorithmOIDs(ee, &(val)->algorithmOIDs))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1Enc_GatekeeperRequest_integrity(ee, &(val)->integrity))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest(ASN1decoding_t dec, GatekeeperRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1Dec_TransportAddress(dec, &(val)->rasAddress))
	return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->endpointType))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_QseriesOptions(dec, &(val)->callServices))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_GatekeeperRequest_endpointAlias(dec, &(val)->endpointAlias))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 7, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperRequest_alternateEndpoints(dd, &(val)->alternateEndpoints))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperRequest_authenticationCapability(dd, &(val)->authenticationCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperRequest_algorithmOIDs(dd, &(val)->algorithmOIDs))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_GatekeeperRequest_integrity(dd, &(val)->integrity))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest(GatekeeperRequest *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_TransportAddress(&(val)->rasAddress);
	ASN1Free_EndpointType(&(val)->endpointType);
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_GatekeeperRequest_endpointAlias(&(val)->endpointAlias);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_GatekeeperRequest_alternateEndpoints(&(val)->alternateEndpoints);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_GatekeeperRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_GatekeeperRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_GatekeeperRequest_authenticationCapability(&(val)->authenticationCapability);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_GatekeeperRequest_algorithmOIDs(&(val)->algorithmOIDs);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_GatekeeperRequest_integrity(&(val)->integrity);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest(ASN1encoding_t enc, RegistrationRequest *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    ASN1uint32_t l;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x4;
    o[1] |= 0x1;
    y = ASN1PEREncCheckExtensions(8, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 3, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->discoveryComplete))
	return 0;
    if (!ASN1Enc_RegistrationRequest_callSignalAddress(enc, &(val)->callSignalAddress))
	return 0;
    if (!ASN1Enc_RegistrationRequest_rasAddress(enc, &(val)->rasAddress))
	return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->terminalType))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_RegistrationRequest_terminalAlias(enc, &(val)->terminalAlias))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Enc_VendorIdentifier(enc, &(val)->endpointVendor))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 8, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_RegistrationRequest_alternateEndpoints(ee, &(val)->alternateEndpoints))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    l = ASN1uint32_uoctets((val)->timeToLive - 1);
	    if (!ASN1PEREncBitVal(ee, 2, l - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncBitVal(ee, l * 8, (val)->timeToLive - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_RegistrationRequest_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_RegistrationRequest_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1PEREncBoolean(ee, (val)->keepAlive))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1PEREncBitVal(ee, 7, ((val)->endpointIdentifier).length - 1))
		return 0;
	    ASN1PEREncAlignment(ee);
	    if (!ASN1PEREncChar16String(ee, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x1) {
	    if (!ASN1PEREncBoolean(ee, (val)->willSupplyUUIEs))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest(ASN1decoding_t dec, RegistrationRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t l;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->discoveryComplete))
	return 0;
    if (!ASN1Dec_RegistrationRequest_callSignalAddress(dec, &(val)->callSignalAddress))
	return 0;
    if (!ASN1Dec_RegistrationRequest_rasAddress(dec, &(val)->rasAddress))
	return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->terminalType))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_RegistrationRequest_terminalAlias(dec, &(val)->terminalAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
	    return 0;
	((val)->gatekeeperIdentifier).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
	    return 0;
    }
    if (!ASN1Dec_VendorIdentifier(dec, &(val)->endpointVendor))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 8, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationRequest_alternateEndpoints(dd, &(val)->alternateEndpoints))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 2, &l))
		return 0;
	    l += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecU32Val(dd, l * 8, &(val)->timeToLive))
		return 0;
	    (val)->timeToLive += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationRequest_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_RegistrationRequest_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->keepAlive))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecU32Val(dd, 7, &((val)->endpointIdentifier).length))
		return 0;
	    ((val)->endpointIdentifier).length += 1;
	    ASN1PERDecAlignment(dd);
	    if (!ASN1PERDecChar16String(dd, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->willSupplyUUIEs))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest(RegistrationRequest *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_RegistrationRequest_callSignalAddress(&(val)->callSignalAddress);
	ASN1Free_RegistrationRequest_rasAddress(&(val)->rasAddress);
	ASN1Free_EndpointType(&(val)->terminalType);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_RegistrationRequest_terminalAlias(&(val)->terminalAlias);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1char16string_free(&(val)->gatekeeperIdentifier);
	}
	ASN1Free_VendorIdentifier(&(val)->endpointVendor);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_RegistrationRequest_alternateEndpoints(&(val)->alternateEndpoints);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_RegistrationRequest_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_RegistrationRequest_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1char16string_free(&(val)->endpointIdentifier);
	}
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm(ASN1encoding_t enc, AdmissionConfirm *val)
{
    ASN1octet_t o[3];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 3);
    o[2] |= 0x40;
    o[2] |= 0x20;
    y = ASN1PEREncCheckExtensions(11, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    l = ASN1uint32_uoctets((val)->bandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bandWidth))
	return 0;
    if (!ASN1Enc_CallModel(enc, &(val)->callModel))
	return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->destCallSignalAddress))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->irrFrequency - 1))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 11, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_AdmissionConfirm_destinationInfo(ee, &(val)->destinationInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_AdmissionConfirm_destExtraCallInfo(ee, &(val)->destExtraCallInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_EndpointType(ee, &(val)->destinationType))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_AdmissionConfirm_remoteExtensionAddress(ee, &(val)->remoteExtensionAddress))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_AdmissionConfirm_alternateEndpoints(ee, &(val)->alternateEndpoints))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1Enc_AdmissionConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1Enc_AdmissionConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x1) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[2] & 0x80) {
	    if (!ASN1Enc_TransportQOS(ee, &(val)->transportQOS))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[2] & 0x40) {
	    if (!ASN1PEREncBoolean(ee, (val)->willRespondToIRR))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[2] & 0x20) {
	    if (!ASN1Enc_UUIEsRequested(ee, &(val)->uuiesRequested))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm(ASN1decoding_t dec, AdmissionConfirm *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bandWidth))
	return 0;
    if (!ASN1Dec_CallModel(dec, &(val)->callModel))
	return 0;
    if (!ASN1Dec_TransportAddress(dec, &(val)->destCallSignalAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->irrFrequency))
	    return 0;
	(val)->irrFrequency += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 2);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 11, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionConfirm_destinationInfo(dd, &(val)->destinationInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionConfirm_destExtraCallInfo(dd, &(val)->destExtraCallInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_EndpointType(dd, &(val)->destinationType))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionConfirm_remoteExtensionAddress(dd, &(val)->remoteExtensionAddress))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionConfirm_alternateEndpoints(dd, &(val)->alternateEndpoints))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AdmissionConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[2] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_TransportQOS(dd, &(val)->transportQOS))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[2] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->willRespondToIRR))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[2] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_UUIEsRequested(dd, &(val)->uuiesRequested))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm(AdmissionConfirm *val)
{
    if (val) {
	ASN1Free_TransportAddress(&(val)->destCallSignalAddress);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_AdmissionConfirm_destinationInfo(&(val)->destinationInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_AdmissionConfirm_destExtraCallInfo(&(val)->destExtraCallInfo);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_EndpointType(&(val)->destinationType);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_AdmissionConfirm_remoteExtensionAddress(&(val)->remoteExtensionAddress);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_AdmissionConfirm_alternateEndpoints(&(val)->alternateEndpoints);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_AdmissionConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_AdmissionConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x1) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm(ASN1encoding_t enc, LocationConfirm *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(8, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->callSignalAddress))
	return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->rasAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 8, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_LocationConfirm_destinationInfo(ee, &(val)->destinationInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_LocationConfirm_destExtraCallInfo(ee, &(val)->destExtraCallInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_EndpointType(ee, &(val)->destinationType))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1Enc_LocationConfirm_remoteExtensionAddress(ee, &(val)->remoteExtensionAddress))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1Enc_LocationConfirm_alternateEndpoints(ee, &(val)->alternateEndpoints))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1Enc_LocationConfirm_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1Enc_LocationConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm(ASN1decoding_t dec, LocationConfirm *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_TransportAddress(dec, &(val)->callSignalAddress))
	return 0;
    if (!ASN1Dec_TransportAddress(dec, &(val)->rasAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 8, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationConfirm_destinationInfo(dd, &(val)->destinationInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationConfirm_destExtraCallInfo(dd, &(val)->destExtraCallInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_EndpointType(dd, &(val)->destinationType))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationConfirm_remoteExtensionAddress(dd, &(val)->remoteExtensionAddress))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationConfirm_alternateEndpoints(dd, &(val)->alternateEndpoints))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationConfirm_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_LocationConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm(LocationConfirm *val)
{
    if (val) {
	ASN1Free_TransportAddress(&(val)->callSignalAddress);
	ASN1Free_TransportAddress(&(val)->rasAddress);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_LocationConfirm_destinationInfo(&(val)->destinationInfo);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_LocationConfirm_destExtraCallInfo(&(val)->destExtraCallInfo);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_EndpointType(&(val)->destinationType);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_LocationConfirm_remoteExtensionAddress(&(val)->remoteExtensionAddress);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_LocationConfirm_alternateEndpoints(&(val)->alternateEndpoints);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_LocationConfirm_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_LocationConfirm_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x1) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse(ASN1encoding_t enc, InfoRequestResponse *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x10;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 3, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
	return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->endpointType))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->rasAddress))
	return 0;
    if (!ASN1Enc_InfoRequestResponse_callSignalAddress(enc, &(val)->callSignalAddress))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_InfoRequestResponse_endpointAlias(enc, &(val)->endpointAlias))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1Enc_InfoRequestResponse_perCallInfo(enc, &(val)->perCallInfo))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_InfoRequestResponse_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_InfoRequestResponse_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1PEREncBoolean(ee, (val)->needResponse))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse(ASN1decoding_t dec, InfoRequestResponse *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
	return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_EndpointType(dec, &(val)->endpointType))
	return 0;
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
	return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
	return 0;
    if (!ASN1Dec_TransportAddress(dec, &(val)->rasAddress))
	return 0;
    if (!ASN1Dec_InfoRequestResponse_callSignalAddress(dec, &(val)->callSignalAddress))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_InfoRequestResponse_endpointAlias(dec, &(val)->endpointAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_InfoRequestResponse_perCallInfo(dec, &(val)->perCallInfo))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequestResponse_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_InfoRequestResponse_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->needResponse))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse(InfoRequestResponse *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	ASN1Free_EndpointType(&(val)->endpointType);
	ASN1char16string_free(&(val)->endpointIdentifier);
	ASN1Free_TransportAddress(&(val)->rasAddress);
	ASN1Free_InfoRequestResponse_callSignalAddress(&(val)->callSignalAddress);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_InfoRequestResponse_endpointAlias(&(val)->endpointAlias);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_InfoRequestResponse_perCallInfo(&(val)->perCallInfo);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_InfoRequestResponse_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_InfoRequestResponse_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_ICV(&(val)->integrityCheckValue);
	}
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_protocols(ASN1encoding_t enc, PResourcesAvailableIndicate_protocols *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ResourcesAvailableIndicate_protocols_ElmFn);
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_protocols_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_protocols val)
{
    if (!ASN1Enc_SupportedProtocols(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_protocols(ASN1decoding_t dec, PResourcesAvailableIndicate_protocols *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ResourcesAvailableIndicate_protocols_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_protocols_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_protocols val)
{
    if (!ASN1Dec_SupportedProtocols(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_protocols(PResourcesAvailableIndicate_protocols *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ResourcesAvailableIndicate_protocols_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_protocols_ElmFn(PResourcesAvailableIndicate_protocols val)
{
    if (val) {
	ASN1Free_SupportedProtocols(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_endpointAlias(ASN1encoding_t enc, PInfoRequestResponse_endpointAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_endpointAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_endpointAlias_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_endpointAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_endpointAlias(ASN1decoding_t dec, PInfoRequestResponse_endpointAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_endpointAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_endpointAlias_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_endpointAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_endpointAlias(PInfoRequestResponse_endpointAlias *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_endpointAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_endpointAlias_ElmFn(PInfoRequestResponse_endpointAlias val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_alternateEndpoints(ASN1encoding_t enc, PLocationConfirm_alternateEndpoints *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_alternateEndpoints_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_alternateEndpoints_ElmFn(ASN1encoding_t enc, PLocationConfirm_alternateEndpoints val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_alternateEndpoints(ASN1decoding_t dec, PLocationConfirm_alternateEndpoints *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_alternateEndpoints_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_alternateEndpoints_ElmFn(ASN1decoding_t dec, PLocationConfirm_alternateEndpoints val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_alternateEndpoints(PLocationConfirm_alternateEndpoints *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_alternateEndpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_alternateEndpoints_ElmFn(PLocationConfirm_alternateEndpoints val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_remoteExtensionAddress(ASN1encoding_t enc, PLocationConfirm_remoteExtensionAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_remoteExtensionAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PLocationConfirm_remoteExtensionAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_remoteExtensionAddress(ASN1decoding_t dec, PLocationConfirm_remoteExtensionAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_remoteExtensionAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PLocationConfirm_remoteExtensionAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_remoteExtensionAddress(PLocationConfirm_remoteExtensionAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_remoteExtensionAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_remoteExtensionAddress_ElmFn(PLocationConfirm_remoteExtensionAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_destExtraCallInfo(ASN1encoding_t enc, PLocationConfirm_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PLocationConfirm_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_destExtraCallInfo(ASN1decoding_t dec, PLocationConfirm_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PLocationConfirm_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_destExtraCallInfo(PLocationConfirm_destExtraCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_destExtraCallInfo_ElmFn(PLocationConfirm_destExtraCallInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_destinationInfo(ASN1encoding_t enc, PLocationConfirm_destinationInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_destinationInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_destinationInfo_ElmFn(ASN1encoding_t enc, PLocationConfirm_destinationInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_destinationInfo(ASN1decoding_t dec, PLocationConfirm_destinationInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_destinationInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_destinationInfo_ElmFn(ASN1decoding_t dec, PLocationConfirm_destinationInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_destinationInfo(PLocationConfirm_destinationInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_destinationInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_destinationInfo_ElmFn(PLocationConfirm_destinationInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationRequest_sourceInfo(ASN1encoding_t enc, PLocationRequest_sourceInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationRequest_sourceInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationRequest_sourceInfo_ElmFn(ASN1encoding_t enc, PLocationRequest_sourceInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRequest_sourceInfo(ASN1decoding_t dec, PLocationRequest_sourceInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationRequest_sourceInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationRequest_sourceInfo_ElmFn(ASN1decoding_t dec, PLocationRequest_sourceInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationRequest_sourceInfo(PLocationRequest_sourceInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationRequest_sourceInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationRequest_sourceInfo_ElmFn(PLocationRequest_sourceInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationRequest_destinationInfo(ASN1encoding_t enc, PLocationRequest_destinationInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationRequest_destinationInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationRequest_destinationInfo_ElmFn(ASN1encoding_t enc, PLocationRequest_destinationInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRequest_destinationInfo(ASN1decoding_t dec, PLocationRequest_destinationInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationRequest_destinationInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationRequest_destinationInfo_ElmFn(ASN1decoding_t dec, PLocationRequest_destinationInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationRequest_destinationInfo(PLocationRequest_destinationInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationRequest_destinationInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationRequest_destinationInfo_ElmFn(PLocationRequest_destinationInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_alternateEndpoints(ASN1encoding_t enc, PAdmissionConfirm_alternateEndpoints *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_alternateEndpoints_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_alternateEndpoints_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_alternateEndpoints val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_alternateEndpoints(ASN1decoding_t dec, PAdmissionConfirm_alternateEndpoints *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_alternateEndpoints_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_alternateEndpoints_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_alternateEndpoints val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_alternateEndpoints(PAdmissionConfirm_alternateEndpoints *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_alternateEndpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_alternateEndpoints_ElmFn(PAdmissionConfirm_alternateEndpoints val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_remoteExtensionAddress(ASN1encoding_t enc, PAdmissionConfirm_remoteExtensionAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_remoteExtensionAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_remoteExtensionAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_remoteExtensionAddress(ASN1decoding_t dec, PAdmissionConfirm_remoteExtensionAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_remoteExtensionAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_remoteExtensionAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_remoteExtensionAddress(PAdmissionConfirm_remoteExtensionAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_remoteExtensionAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_remoteExtensionAddress_ElmFn(PAdmissionConfirm_remoteExtensionAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_destExtraCallInfo(ASN1encoding_t enc, PAdmissionConfirm_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_destExtraCallInfo(ASN1decoding_t dec, PAdmissionConfirm_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_destExtraCallInfo(PAdmissionConfirm_destExtraCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_destExtraCallInfo_ElmFn(PAdmissionConfirm_destExtraCallInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_destinationInfo(ASN1encoding_t enc, PAdmissionConfirm_destinationInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_destinationInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_destinationInfo_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_destinationInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_destinationInfo(ASN1decoding_t dec, PAdmissionConfirm_destinationInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_destinationInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_destinationInfo_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_destinationInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_destinationInfo(PAdmissionConfirm_destinationInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_destinationInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_destinationInfo_ElmFn(PAdmissionConfirm_destinationInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destAlternatives(ASN1encoding_t enc, PAdmissionRequest_destAlternatives *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_destAlternatives_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destAlternatives_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destAlternatives val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destAlternatives(ASN1decoding_t dec, PAdmissionRequest_destAlternatives *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_destAlternatives_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destAlternatives_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destAlternatives val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_destAlternatives(PAdmissionRequest_destAlternatives *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_destAlternatives_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_destAlternatives_ElmFn(PAdmissionRequest_destAlternatives val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_srcAlternatives(ASN1encoding_t enc, PAdmissionRequest_srcAlternatives *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_srcAlternatives_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_srcAlternatives_ElmFn(ASN1encoding_t enc, PAdmissionRequest_srcAlternatives val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_srcAlternatives(ASN1decoding_t dec, PAdmissionRequest_srcAlternatives *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_srcAlternatives_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_srcAlternatives_ElmFn(ASN1decoding_t dec, PAdmissionRequest_srcAlternatives val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_srcAlternatives(PAdmissionRequest_srcAlternatives *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_srcAlternatives_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_srcAlternatives_ElmFn(PAdmissionRequest_srcAlternatives val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_srcInfo(ASN1encoding_t enc, PAdmissionRequest_srcInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_srcInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_srcInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_srcInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_srcInfo(ASN1decoding_t dec, PAdmissionRequest_srcInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_srcInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_srcInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_srcInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_srcInfo(PAdmissionRequest_srcInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_srcInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_srcInfo_ElmFn(PAdmissionRequest_srcInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destExtraCallInfo(ASN1encoding_t enc, PAdmissionRequest_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destExtraCallInfo(ASN1decoding_t dec, PAdmissionRequest_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_destExtraCallInfo(PAdmissionRequest_destExtraCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_destExtraCallInfo_ElmFn(PAdmissionRequest_destExtraCallInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destinationInfo(ASN1encoding_t enc, PAdmissionRequest_destinationInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_destinationInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destinationInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destinationInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destinationInfo(ASN1decoding_t dec, PAdmissionRequest_destinationInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_destinationInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destinationInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destinationInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_destinationInfo(PAdmissionRequest_destinationInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_destinationInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_destinationInfo_ElmFn(PAdmissionRequest_destinationInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_alternateEndpoints(ASN1encoding_t enc, PUnregistrationRequest_alternateEndpoints *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationRequest_alternateEndpoints_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_alternateEndpoints val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_alternateEndpoints(ASN1decoding_t dec, PUnregistrationRequest_alternateEndpoints *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationRequest_alternateEndpoints_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_alternateEndpoints val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest_alternateEndpoints(PUnregistrationRequest_alternateEndpoints *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationRequest_alternateEndpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationRequest_alternateEndpoints_ElmFn(PUnregistrationRequest_alternateEndpoints val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_endpointAlias(ASN1encoding_t enc, PUnregistrationRequest_endpointAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationRequest_endpointAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_endpointAlias_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_endpointAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_endpointAlias(ASN1decoding_t dec, PUnregistrationRequest_endpointAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationRequest_endpointAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_endpointAlias_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_endpointAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest_endpointAlias(PUnregistrationRequest_endpointAlias *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationRequest_endpointAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationRequest_endpointAlias_ElmFn(PUnregistrationRequest_endpointAlias val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRejectReason_duplicateAlias(ASN1encoding_t enc, PRegistrationRejectReason_duplicateAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRejectReason_duplicateAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRejectReason_duplicateAlias_ElmFn(ASN1encoding_t enc, PRegistrationRejectReason_duplicateAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRejectReason_duplicateAlias(ASN1decoding_t dec, PRegistrationRejectReason_duplicateAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRejectReason_duplicateAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRejectReason_duplicateAlias_ElmFn(ASN1decoding_t dec, PRegistrationRejectReason_duplicateAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRejectReason_duplicateAlias(PRegistrationRejectReason_duplicateAlias *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRejectReason_duplicateAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRejectReason_duplicateAlias_ElmFn(PRegistrationRejectReason_duplicateAlias val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_terminalAlias(ASN1encoding_t enc, PRegistrationConfirm_terminalAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationConfirm_terminalAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_terminalAlias_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_terminalAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_terminalAlias(ASN1decoding_t dec, PRegistrationConfirm_terminalAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationConfirm_terminalAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_terminalAlias_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_terminalAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm_terminalAlias(PRegistrationConfirm_terminalAlias *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationConfirm_terminalAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationConfirm_terminalAlias_ElmFn(PRegistrationConfirm_terminalAlias val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_alternateEndpoints(ASN1encoding_t enc, PRegistrationRequest_alternateEndpoints *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_alternateEndpoints_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PRegistrationRequest_alternateEndpoints val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_alternateEndpoints(ASN1decoding_t dec, PRegistrationRequest_alternateEndpoints *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_alternateEndpoints_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PRegistrationRequest_alternateEndpoints val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_alternateEndpoints(PRegistrationRequest_alternateEndpoints *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_alternateEndpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_alternateEndpoints_ElmFn(PRegistrationRequest_alternateEndpoints val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_terminalAlias(ASN1encoding_t enc, PRegistrationRequest_terminalAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_terminalAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_terminalAlias_ElmFn(ASN1encoding_t enc, PRegistrationRequest_terminalAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_terminalAlias(ASN1decoding_t dec, PRegistrationRequest_terminalAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_terminalAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_terminalAlias_ElmFn(ASN1decoding_t dec, PRegistrationRequest_terminalAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_terminalAlias(PRegistrationRequest_terminalAlias *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_terminalAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_terminalAlias_ElmFn(PRegistrationRequest_terminalAlias val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_alternateEndpoints(ASN1encoding_t enc, PGatekeeperRequest_alternateEndpoints *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_alternateEndpoints_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_alternateEndpoints val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_alternateEndpoints(ASN1decoding_t dec, PGatekeeperRequest_alternateEndpoints *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_alternateEndpoints_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_alternateEndpoints val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_alternateEndpoints(PGatekeeperRequest_alternateEndpoints *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_alternateEndpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_alternateEndpoints_ElmFn(PGatekeeperRequest_alternateEndpoints val)
{
    if (val) {
	ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_endpointAlias(ASN1encoding_t enc, PGatekeeperRequest_endpointAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_endpointAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_endpointAlias_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_endpointAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_endpointAlias(ASN1decoding_t dec, PGatekeeperRequest_endpointAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_endpointAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_endpointAlias_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_endpointAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_endpointAlias(PGatekeeperRequest_endpointAlias *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_endpointAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_endpointAlias_ElmFn(PGatekeeperRequest_endpointAlias val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CryptoH323Token_cryptoEPPwdHash(ASN1encoding_t enc, CryptoH323Token_cryptoEPPwdHash *val)
{
    ASN1uint32_t l;
    if (!ASN1Enc_AliasAddress(enc, &(val)->alias))
	return 0;
    l = ASN1uint32_uoctets((val)->timeStamp - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->timeStamp - 1))
	return 0;
    if (!ASN1Enc_HASHED(enc, &(val)->token))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoH323Token_cryptoEPPwdHash(ASN1decoding_t dec, CryptoH323Token_cryptoEPPwdHash *val)
{
    ASN1uint32_t l;
    if (!ASN1Dec_AliasAddress(dec, &(val)->alias))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->timeStamp))
	return 0;
    (val)->timeStamp += 1;
    if (!ASN1Dec_HASHED(dec, &(val)->token))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CryptoH323Token_cryptoEPPwdHash(CryptoH323Token_cryptoEPPwdHash *val)
{
    if (val) {
	ASN1Free_AliasAddress(&(val)->alias);
	ASN1Free_HASHED(&(val)->token);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_destExtraCallInfo(ASN1encoding_t enc, PEndpoint_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PEndpoint_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_destExtraCallInfo(ASN1decoding_t dec, PEndpoint_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PEndpoint_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_destExtraCallInfo(PEndpoint_destExtraCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_destExtraCallInfo_ElmFn(PEndpoint_destExtraCallInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_remoteExtensionAddress(ASN1encoding_t enc, PEndpoint_remoteExtensionAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_remoteExtensionAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PEndpoint_remoteExtensionAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_remoteExtensionAddress(ASN1decoding_t dec, PEndpoint_remoteExtensionAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_remoteExtensionAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PEndpoint_remoteExtensionAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_remoteExtensionAddress(PEndpoint_remoteExtensionAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_remoteExtensionAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_remoteExtensionAddress_ElmFn(PEndpoint_remoteExtensionAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_aliasAddress(ASN1encoding_t enc, PEndpoint_aliasAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_aliasAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_aliasAddress_ElmFn(ASN1encoding_t enc, PEndpoint_aliasAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_aliasAddress(ASN1decoding_t dec, PEndpoint_aliasAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_aliasAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_aliasAddress_ElmFn(ASN1decoding_t dec, PEndpoint_aliasAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_aliasAddress(PEndpoint_aliasAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_aliasAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_aliasAddress_ElmFn(PEndpoint_aliasAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_NonStandardProtocol_supportedPrefixes(ASN1encoding_t enc, PNonStandardProtocol_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_NonStandardProtocol_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_NonStandardProtocol_supportedPrefixes_ElmFn(ASN1encoding_t enc, PNonStandardProtocol_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardProtocol_supportedPrefixes(ASN1decoding_t dec, PNonStandardProtocol_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_NonStandardProtocol_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_NonStandardProtocol_supportedPrefixes_ElmFn(ASN1decoding_t dec, PNonStandardProtocol_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardProtocol_supportedPrefixes(PNonStandardProtocol_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_NonStandardProtocol_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_NonStandardProtocol_supportedPrefixes_ElmFn(PNonStandardProtocol_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_T120OnlyCaps_supportedPrefixes(ASN1encoding_t enc, PT120OnlyCaps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_T120OnlyCaps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_T120OnlyCaps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PT120OnlyCaps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_T120OnlyCaps_supportedPrefixes(ASN1decoding_t dec, PT120OnlyCaps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_T120OnlyCaps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_T120OnlyCaps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PT120OnlyCaps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_T120OnlyCaps_supportedPrefixes(PT120OnlyCaps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_T120OnlyCaps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_T120OnlyCaps_supportedPrefixes_ElmFn(PT120OnlyCaps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_VoiceCaps_supportedPrefixes(ASN1encoding_t enc, PVoiceCaps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_VoiceCaps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_VoiceCaps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PVoiceCaps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VoiceCaps_supportedPrefixes(ASN1decoding_t dec, PVoiceCaps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_VoiceCaps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_VoiceCaps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PVoiceCaps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VoiceCaps_supportedPrefixes(PVoiceCaps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_VoiceCaps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_VoiceCaps_supportedPrefixes_ElmFn(PVoiceCaps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H324Caps_supportedPrefixes(ASN1encoding_t enc, PH324Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H324Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H324Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH324Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H324Caps_supportedPrefixes(ASN1decoding_t dec, PH324Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H324Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H324Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH324Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H324Caps_supportedPrefixes(PH324Caps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H324Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H324Caps_supportedPrefixes_ElmFn(PH324Caps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323Caps_supportedPrefixes(ASN1encoding_t enc, PH323Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H323Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H323Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH323Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323Caps_supportedPrefixes(ASN1decoding_t dec, PH323Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H323Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H323Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH323Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H323Caps_supportedPrefixes(PH323Caps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H323Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H323Caps_supportedPrefixes_ElmFn(PH323Caps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H322Caps_supportedPrefixes(ASN1encoding_t enc, PH322Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H322Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H322Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH322Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H322Caps_supportedPrefixes(ASN1decoding_t dec, PH322Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H322Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H322Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH322Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H322Caps_supportedPrefixes(PH322Caps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H322Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H322Caps_supportedPrefixes_ElmFn(PH322Caps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H321Caps_supportedPrefixes(ASN1encoding_t enc, PH321Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H321Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H321Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH321Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H321Caps_supportedPrefixes(ASN1decoding_t dec, PH321Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H321Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H321Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH321Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H321Caps_supportedPrefixes(PH321Caps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H321Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H321Caps_supportedPrefixes_ElmFn(PH321Caps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H320Caps_supportedPrefixes(ASN1encoding_t enc, PH320Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H320Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H320Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH320Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H320Caps_supportedPrefixes(ASN1decoding_t dec, PH320Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H320Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H320Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH320Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H320Caps_supportedPrefixes(PH320Caps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H320Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H320Caps_supportedPrefixes_ElmFn(PH320Caps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H310Caps_supportedPrefixes(ASN1encoding_t enc, PH310Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H310Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H310Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH310Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H310Caps_supportedPrefixes(ASN1decoding_t dec, PH310Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H310Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H310Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH310Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H310Caps_supportedPrefixes(PH310Caps_supportedPrefixes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H310Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H310Caps_supportedPrefixes_ElmFn(PH310Caps_supportedPrefixes val)
{
    if (val) {
	ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatewayInfo_protocol(ASN1encoding_t enc, PGatewayInfo_protocol *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatewayInfo_protocol_ElmFn);
}

static int ASN1CALL ASN1Enc_GatewayInfo_protocol_ElmFn(ASN1encoding_t enc, PGatewayInfo_protocol val)
{
    if (!ASN1Enc_SupportedProtocols(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatewayInfo_protocol(ASN1decoding_t dec, PGatewayInfo_protocol *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatewayInfo_protocol_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatewayInfo_protocol_ElmFn(ASN1decoding_t dec, PGatewayInfo_protocol val)
{
    if (!ASN1Dec_SupportedProtocols(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatewayInfo_protocol(PGatewayInfo_protocol *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatewayInfo_protocol_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatewayInfo_protocol_ElmFn(PGatewayInfo_protocol val)
{
    if (val) {
	ASN1Free_SupportedProtocols(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_destExtraCallInfo(ASN1encoding_t enc, PFacility_UUIE_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PFacility_UUIE_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_destExtraCallInfo(ASN1decoding_t dec, PFacility_UUIE_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PFacility_UUIE_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_destExtraCallInfo(PFacility_UUIE_destExtraCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_destExtraCallInfo_ElmFn(PFacility_UUIE_destExtraCallInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_alternativeAliasAddress(ASN1encoding_t enc, PFacility_UUIE_alternativeAliasAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_alternativeAliasAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_alternativeAliasAddress_ElmFn(ASN1encoding_t enc, PFacility_UUIE_alternativeAliasAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_alternativeAliasAddress(ASN1decoding_t dec, PFacility_UUIE_alternativeAliasAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_alternativeAliasAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_alternativeAliasAddress_ElmFn(ASN1decoding_t dec, PFacility_UUIE_alternativeAliasAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_alternativeAliasAddress(PFacility_UUIE_alternativeAliasAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_alternativeAliasAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_alternativeAliasAddress_ElmFn(PFacility_UUIE_alternativeAliasAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCallInfo(ASN1encoding_t enc, PSetup_UUIE_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCallInfo(ASN1decoding_t dec, PSetup_UUIE_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCallInfo(PSetup_UUIE_destExtraCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCallInfo_ElmFn(PSetup_UUIE_destExtraCallInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destinationAddress(ASN1encoding_t enc, PSetup_UUIE_destinationAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_destinationAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destinationAddress_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destinationAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destinationAddress(ASN1decoding_t dec, PSetup_UUIE_destinationAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_destinationAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destinationAddress_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destinationAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_destinationAddress(PSetup_UUIE_destinationAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_destinationAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_destinationAddress_ElmFn(PSetup_UUIE_destinationAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_sourceAddress(ASN1encoding_t enc, PSetup_UUIE_sourceAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_sourceAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_sourceAddress_ElmFn(ASN1encoding_t enc, PSetup_UUIE_sourceAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_sourceAddress(ASN1decoding_t dec, PSetup_UUIE_sourceAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_sourceAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_sourceAddress_ElmFn(ASN1decoding_t dec, PSetup_UUIE_sourceAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_sourceAddress(PSetup_UUIE_sourceAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_sourceAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_sourceAddress_ElmFn(PSetup_UUIE_sourceAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Alerting_UUIE(ASN1encoding_t enc, Alerting_UUIE *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->destinationInfo))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 5, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H245Security(ee, &(val)->h245SecurityMode))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_Alerting_UUIE_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_Alerting_UUIE_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_Alerting_UUIE_fastStart(ee, &(val)->fastStart))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Alerting_UUIE(ASN1decoding_t dec, Alerting_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->destinationInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H245Security(dd, &(val)->h245SecurityMode))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Alerting_UUIE_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Alerting_UUIE_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Alerting_UUIE_fastStart(dd, &(val)->fastStart))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_Alerting_UUIE(Alerting_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	ASN1Free_EndpointType(&(val)->destinationInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H245Security(&(val)->h245SecurityMode);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_Alerting_UUIE_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_Alerting_UUIE_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_Alerting_UUIE_fastStart(&(val)->fastStart);
	}
    }
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE(ASN1encoding_t enc, CallProceeding_UUIE *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->destinationInfo))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 5, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H245Security(ee, &(val)->h245SecurityMode))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_CallProceeding_UUIE_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_CallProceeding_UUIE_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_CallProceeding_UUIE_fastStart(ee, &(val)->fastStart))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE(ASN1decoding_t dec, CallProceeding_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->destinationInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H245Security(dd, &(val)->h245SecurityMode))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallProceeding_UUIE_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallProceeding_UUIE_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallProceeding_UUIE_fastStart(dd, &(val)->fastStart))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE(CallProceeding_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	ASN1Free_EndpointType(&(val)->destinationInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H245Security(&(val)->h245SecurityMode);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_CallProceeding_UUIE_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_CallProceeding_UUIE_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_CallProceeding_UUIE_fastStart(&(val)->fastStart);
	}
    }
}

static int ASN1CALL ASN1Enc_Connect_UUIE(ASN1encoding_t enc, Connect_UUIE *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
	    return 0;
    }
    if (!ASN1Enc_EndpointType(enc, &(val)->destinationInfo))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 5, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_H245Security(ee, &(val)->h245SecurityMode))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_Connect_UUIE_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_Connect_UUIE_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_Connect_UUIE_fastStart(ee, &(val)->fastStart))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Connect_UUIE(ASN1decoding_t dec, Connect_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
	    return 0;
    }
    if (!ASN1Dec_EndpointType(dec, &(val)->destinationInfo))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H245Security(dd, &(val)->h245SecurityMode))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Connect_UUIE_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Connect_UUIE_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Connect_UUIE_fastStart(dd, &(val)->fastStart))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_Connect_UUIE(Connect_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
	ASN1Free_EndpointType(&(val)->destinationInfo);
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H245Security(&(val)->h245SecurityMode);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_Connect_UUIE_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_Connect_UUIE_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_Connect_UUIE_fastStart(&(val)->fastStart);
	}
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE(ASN1encoding_t enc, Setup_UUIE *val)
{
    ASN1octet_t o[3];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 3);
    o[1] |= 0x20;
    o[1] |= 0x1;
    o[2] |= 0x80;
    y = ASN1PEREncCheckExtensions(9, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 7, o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1Enc_Setup_UUIE_sourceAddress(enc, &(val)->sourceAddress))
	    return 0;
    }
    if (!ASN1Enc_EndpointType(enc, &(val)->sourceInfo))
	return 0;
    if (o[0] & 0x20) {
	if (!ASN1Enc_Setup_UUIE_destinationAddress(enc, &(val)->destinationAddress))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->destCallSignalAddress))
	    return 0;
    }
    if (o[0] & 0x8) {
	if (!ASN1Enc_Setup_UUIE_destExtraCallInfo(enc, &(val)->destExtraCallInfo))
	    return 0;
    }
    if (o[0] & 0x4) {
	if (!ASN1Enc_Setup_UUIE_destExtraCRV(enc, &(val)->destExtraCRV))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->activeMC))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1Enc_Setup_UUIE_conferenceGoal(enc, &(val)->conferenceGoal))
	return 0;
    if (o[0] & 0x2) {
	if (!ASN1Enc_QseriesOptions(enc, &(val)->callServices))
	    return 0;
    }
    if (!ASN1Enc_CallType(enc, &(val)->callType))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 9, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_TransportAddress(ee, &(val)->sourceCallSignalAddress))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_AliasAddress(ee, &(val)->remoteExtensionAddress))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_Setup_UUIE_h245SecurityCapability(ee, &(val)->h245SecurityCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_Setup_UUIE_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1Enc_Setup_UUIE_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1Enc_Setup_UUIE_fastStart(ee, &(val)->fastStart))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x1) {
	    if (!ASN1PEREncBoolean(ee, (val)->mediaWaitForConnect))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[2] & 0x80) {
	    if (!ASN1PEREncBoolean(ee, (val)->canOverlapSend))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE(ASN1decoding_t dec, Setup_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_Setup_UUIE_sourceAddress(dec, &(val)->sourceAddress))
	    return 0;
    }
    if (!ASN1Dec_EndpointType(dec, &(val)->sourceInfo))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_Setup_UUIE_destinationAddress(dec, &(val)->destinationAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->destCallSignalAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_Setup_UUIE_destExtraCallInfo(dec, &(val)->destExtraCallInfo))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_Setup_UUIE_destExtraCRV(dec, &(val)->destExtraCRV))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->activeMC))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1Dec_Setup_UUIE_conferenceGoal(dec, &(val)->conferenceGoal))
	return 0;
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_QseriesOptions(dec, &(val)->callServices))
	    return 0;
    }
    if (!ASN1Dec_CallType(dec, &(val)->callType))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 2);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 9, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_TransportAddress(dd, &(val)->sourceCallSignalAddress))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AliasAddress(dd, &(val)->remoteExtensionAddress))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Setup_UUIE_h245SecurityCapability(dd, &(val)->h245SecurityCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Setup_UUIE_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Setup_UUIE_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Setup_UUIE_fastStart(dd, &(val)->fastStart))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->mediaWaitForConnect))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[2] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->canOverlapSend))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE(Setup_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Setup_UUIE_sourceAddress(&(val)->sourceAddress);
	}
	ASN1Free_EndpointType(&(val)->sourceInfo);
	if ((val)->o[0] & 0x20) {
	    ASN1Free_Setup_UUIE_destinationAddress(&(val)->destinationAddress);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_TransportAddress(&(val)->destCallSignalAddress);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_Setup_UUIE_destExtraCallInfo(&(val)->destExtraCallInfo);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_Setup_UUIE_destExtraCRV(&(val)->destExtraCRV);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->sourceCallSignalAddress);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_AliasAddress(&(val)->remoteExtensionAddress);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_Setup_UUIE_h245SecurityCapability(&(val)->h245SecurityCapability);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_Setup_UUIE_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_Setup_UUIE_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_Setup_UUIE_fastStart(&(val)->fastStart);
	}
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE(ASN1encoding_t enc, Facility_UUIE *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(8, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 3, o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->alternativeAddress))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1Enc_Facility_UUIE_alternativeAliasAddress(enc, &(val)->alternativeAliasAddress))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	    return 0;
    }
    if (!ASN1Enc_FacilityReason(enc, &(val)->reason))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 8, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1Enc_Facility_UUIE_destExtraCallInfo(ee, &(val)->destExtraCallInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_AliasAddress(ee, &(val)->remoteExtensionAddress))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_Facility_UUIE_tokens(ee, &(val)->tokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1Enc_Facility_UUIE_cryptoTokens(ee, &(val)->cryptoTokens))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1Enc_Facility_UUIE_conferences(ee, &(val)->conferences))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1Enc_TransportAddress(ee, &(val)->h245Address))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x1) {
	    if (!ASN1Enc_Facility_UUIE_fastStart(ee, &(val)->fastStart))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE(ASN1decoding_t dec, Facility_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->alternativeAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_Facility_UUIE_alternativeAliasAddress(dec, &(val)->alternativeAliasAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	    return 0;
    }
    if (!ASN1Dec_FacilityReason(dec, &(val)->reason))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 8, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Facility_UUIE_destExtraCallInfo(dd, &(val)->destExtraCallInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AliasAddress(dd, &(val)->remoteExtensionAddress))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Facility_UUIE_tokens(dd, &(val)->tokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Facility_UUIE_cryptoTokens(dd, &(val)->cryptoTokens))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Facility_UUIE_conferences(dd, &(val)->conferences))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_TransportAddress(dd, &(val)->h245Address))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_Facility_UUIE_fastStart(dd, &(val)->fastStart))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE(Facility_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->alternativeAddress);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Facility_UUIE_alternativeAliasAddress(&(val)->alternativeAliasAddress);
	}
	if ((val)->o[0] & 0x20) {
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_CallIdentifier(&(val)->callIdentifier);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_Facility_UUIE_destExtraCallInfo(&(val)->destExtraCallInfo);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_AliasAddress(&(val)->remoteExtensionAddress);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_Facility_UUIE_tokens(&(val)->tokens);
	}
	if ((val)->o[1] & 0x8) {
	    ASN1Free_Facility_UUIE_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[1] & 0x4) {
	    ASN1Free_Facility_UUIE_conferences(&(val)->conferences);
	}
	if ((val)->o[1] & 0x2) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
	if ((val)->o[1] & 0x1) {
	    ASN1Free_Facility_UUIE_fastStart(&(val)->fastStart);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceList(ASN1encoding_t enc, ConferenceList *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_AliasAddress(enc, &(val)->conferenceAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceList(ASN1decoding_t dec, ConferenceList *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_AliasAddress(dec, &(val)->conferenceAlias))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceList(ConferenceList *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_AliasAddress(&(val)->conferenceAlias);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_Progress_UUIE(ASN1encoding_t enc, Progress_UUIE *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->destinationInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
	    return 0;
    }
    if (!ASN1Enc_CallIdentifier(enc, &(val)->callIdentifier))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_H245Security(enc, &(val)->h245SecurityMode))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_Progress_UUIE_tokens(enc, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_Progress_UUIE_cryptoTokens(enc, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_Progress_UUIE_fastStart(enc, &(val)->fastStart))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Progress_UUIE(ASN1decoding_t dec, Progress_UUIE *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->destinationInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
	    return 0;
    }
    if (!ASN1Dec_CallIdentifier(dec, &(val)->callIdentifier))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_H245Security(dec, &(val)->h245SecurityMode))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_Progress_UUIE_tokens(dec, &(val)->tokens))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_Progress_UUIE_cryptoTokens(dec, &(val)->cryptoTokens))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_Progress_UUIE_fastStart(dec, &(val)->fastStart))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Progress_UUIE(Progress_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	ASN1Free_EndpointType(&(val)->destinationInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
	ASN1Free_CallIdentifier(&(val)->callIdentifier);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H245Security(&(val)->h245SecurityMode);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_Progress_UUIE_tokens(&(val)->tokens);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_Progress_UUIE_cryptoTokens(&(val)->cryptoTokens);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_Progress_UUIE_fastStart(&(val)->fastStart);
	}
    }
}

static int ASN1CALL ASN1Enc_CryptoH323Token(ASN1encoding_t enc, CryptoH323Token *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_CryptoH323Token_cryptoEPPwdHash(enc, &(val)->u.cryptoEPPwdHash))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_CryptoH323Token_cryptoGKPwdHash(enc, &(val)->u.cryptoGKPwdHash))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ENCRYPTED(enc, &(val)->u.cryptoEPPwdEncr))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ENCRYPTED(enc, &(val)->u.cryptoGKPwdEncr))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_SIGNED_EncodedPwdCertToken(enc, &(val)->u.cryptoEPCert))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_SIGNED_EncodedPwdCertToken(enc, &(val)->u.cryptoGKCert))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_SIGNED_EncodedFastStartToken(enc, &(val)->u.cryptoFastStart))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_CryptoToken(enc, &(val)->u.nestedcryptoToken))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoH323Token(ASN1decoding_t dec, CryptoH323Token *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_CryptoH323Token_cryptoEPPwdHash(dec, &(val)->u.cryptoEPPwdHash))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_CryptoH323Token_cryptoGKPwdHash(dec, &(val)->u.cryptoGKPwdHash))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ENCRYPTED(dec, &(val)->u.cryptoEPPwdEncr))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ENCRYPTED(dec, &(val)->u.cryptoGKPwdEncr))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_SIGNED_EncodedPwdCertToken(dec, &(val)->u.cryptoEPCert))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_SIGNED_EncodedPwdCertToken(dec, &(val)->u.cryptoGKCert))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_SIGNED_EncodedFastStartToken(dec, &(val)->u.cryptoFastStart))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_CryptoToken(dec, &(val)->u.nestedcryptoToken))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CryptoH323Token(CryptoH323Token *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_CryptoH323Token_cryptoEPPwdHash(&(val)->u.cryptoEPPwdHash);
	    break;
	case 2:
	    ASN1Free_CryptoH323Token_cryptoGKPwdHash(&(val)->u.cryptoGKPwdHash);
	    break;
	case 3:
	    ASN1Free_ENCRYPTED(&(val)->u.cryptoEPPwdEncr);
	    break;
	case 4:
	    ASN1Free_ENCRYPTED(&(val)->u.cryptoGKPwdEncr);
	    break;
	case 5:
	    ASN1Free_SIGNED_EncodedPwdCertToken(&(val)->u.cryptoEPCert);
	    break;
	case 6:
	    ASN1Free_SIGNED_EncodedPwdCertToken(&(val)->u.cryptoGKCert);
	    break;
	case 7:
	    ASN1Free_SIGNED_EncodedFastStartToken(&(val)->u.cryptoFastStart);
	    break;
	case 8:
	    ASN1Free_CryptoToken(&(val)->u.nestedcryptoToken);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RasMessage(ASN1encoding_t enc, RasMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 5, 25))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_GatekeeperRequest(enc, &(val)->u.gatekeeperRequest))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_GatekeeperConfirm(enc, &(val)->u.gatekeeperConfirm))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_GatekeeperReject(enc, &(val)->u.gatekeeperReject))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_RegistrationRequest(enc, &(val)->u.registrationRequest))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_RegistrationConfirm(enc, &(val)->u.registrationConfirm))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_RegistrationReject(enc, &(val)->u.registrationReject))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_UnregistrationRequest(enc, &(val)->u.unregistrationRequest))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_UnregistrationConfirm(enc, &(val)->u.unregistrationConfirm))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_UnregistrationReject(enc, &(val)->u.unregistrationReject))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_AdmissionRequest(enc, &(val)->u.admissionRequest))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_AdmissionConfirm(enc, &(val)->u.admissionConfirm))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_AdmissionReject(enc, &(val)->u.admissionReject))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_BandwidthRequest(enc, &(val)->u.bandwidthRequest))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_BandwidthConfirm(enc, &(val)->u.bandwidthConfirm))
	    return 0;
	break;
    case 15:
	if (!ASN1Enc_BandwidthReject(enc, &(val)->u.bandwidthReject))
	    return 0;
	break;
    case 16:
	if (!ASN1Enc_DisengageRequest(enc, &(val)->u.disengageRequest))
	    return 0;
	break;
    case 17:
	if (!ASN1Enc_DisengageConfirm(enc, &(val)->u.disengageConfirm))
	    return 0;
	break;
    case 18:
	if (!ASN1Enc_DisengageReject(enc, &(val)->u.disengageReject))
	    return 0;
	break;
    case 19:
	if (!ASN1Enc_LocationRequest(enc, &(val)->u.locationRequest))
	    return 0;
	break;
    case 20:
	if (!ASN1Enc_LocationConfirm(enc, &(val)->u.locationConfirm))
	    return 0;
	break;
    case 21:
	if (!ASN1Enc_LocationReject(enc, &(val)->u.locationReject))
	    return 0;
	break;
    case 22:
	if (!ASN1Enc_InfoRequest(enc, &(val)->u.infoRequest))
	    return 0;
	break;
    case 23:
	if (!ASN1Enc_InfoRequestResponse(enc, &(val)->u.infoRequestResponse))
	    return 0;
	break;
    case 24:
	if (!ASN1Enc_H225NonStandardMessage(enc, &(val)->u.nonStandardMessage))
	    return 0;
	break;
    case 25:
	if (!ASN1Enc_UnknownMessageResponse(enc, &(val)->u.unknownMessageResponse))
	    return 0;
	break;
    case 26:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_RequestInProgress(ee, &(val)->u.requestInProgress))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 27:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ResourcesAvailableIndicate(ee, &(val)->u.resourcesAvailableIndicate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 28:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ResourcesAvailableConfirm(ee, &(val)->u.resourcesAvailableConfirm))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 29:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_InfoRequestAck(ee, &(val)->u.infoRequestAck))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 30:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_InfoRequestNak(ee, &(val)->u.infoRequestNak))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RasMessage(ASN1decoding_t dec, RasMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 5, 25))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_GatekeeperRequest(dec, &(val)->u.gatekeeperRequest))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_GatekeeperConfirm(dec, &(val)->u.gatekeeperConfirm))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_GatekeeperReject(dec, &(val)->u.gatekeeperReject))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_RegistrationRequest(dec, &(val)->u.registrationRequest))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_RegistrationConfirm(dec, &(val)->u.registrationConfirm))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_RegistrationReject(dec, &(val)->u.registrationReject))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_UnregistrationRequest(dec, &(val)->u.unregistrationRequest))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_UnregistrationConfirm(dec, &(val)->u.unregistrationConfirm))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_UnregistrationReject(dec, &(val)->u.unregistrationReject))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_AdmissionRequest(dec, &(val)->u.admissionRequest))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_AdmissionConfirm(dec, &(val)->u.admissionConfirm))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_AdmissionReject(dec, &(val)->u.admissionReject))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_BandwidthRequest(dec, &(val)->u.bandwidthRequest))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_BandwidthConfirm(dec, &(val)->u.bandwidthConfirm))
	    return 0;
	break;
    case 15:
	if (!ASN1Dec_BandwidthReject(dec, &(val)->u.bandwidthReject))
	    return 0;
	break;
    case 16:
	if (!ASN1Dec_DisengageRequest(dec, &(val)->u.disengageRequest))
	    return 0;
	break;
    case 17:
	if (!ASN1Dec_DisengageConfirm(dec, &(val)->u.disengageConfirm))
	    return 0;
	break;
    case 18:
	if (!ASN1Dec_DisengageReject(dec, &(val)->u.disengageReject))
	    return 0;
	break;
    case 19:
	if (!ASN1Dec_LocationRequest(dec, &(val)->u.locationRequest))
	    return 0;
	break;
    case 20:
	if (!ASN1Dec_LocationConfirm(dec, &(val)->u.locationConfirm))
	    return 0;
	break;
    case 21:
	if (!ASN1Dec_LocationReject(dec, &(val)->u.locationReject))
	    return 0;
	break;
    case 22:
	if (!ASN1Dec_InfoRequest(dec, &(val)->u.infoRequest))
	    return 0;
	break;
    case 23:
	if (!ASN1Dec_InfoRequestResponse(dec, &(val)->u.infoRequestResponse))
	    return 0;
	break;
    case 24:
	if (!ASN1Dec_H225NonStandardMessage(dec, &(val)->u.nonStandardMessage))
	    return 0;
	break;
    case 25:
	if (!ASN1Dec_UnknownMessageResponse(dec, &(val)->u.unknownMessageResponse))
	    return 0;
	break;
    case 26:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_RequestInProgress(dd, &(val)->u.requestInProgress))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 27:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ResourcesAvailableIndicate(dd, &(val)->u.resourcesAvailableIndicate))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 28:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ResourcesAvailableConfirm(dd, &(val)->u.resourcesAvailableConfirm))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 29:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_InfoRequestAck(dd, &(val)->u.infoRequestAck))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 30:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_InfoRequestNak(dd, &(val)->u.infoRequestNak))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RasMessage(RasMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_GatekeeperRequest(&(val)->u.gatekeeperRequest);
	    break;
	case 2:
	    ASN1Free_GatekeeperConfirm(&(val)->u.gatekeeperConfirm);
	    break;
	case 3:
	    ASN1Free_GatekeeperReject(&(val)->u.gatekeeperReject);
	    break;
	case 4:
	    ASN1Free_RegistrationRequest(&(val)->u.registrationRequest);
	    break;
	case 5:
	    ASN1Free_RegistrationConfirm(&(val)->u.registrationConfirm);
	    break;
	case 6:
	    ASN1Free_RegistrationReject(&(val)->u.registrationReject);
	    break;
	case 7:
	    ASN1Free_UnregistrationRequest(&(val)->u.unregistrationRequest);
	    break;
	case 8:
	    ASN1Free_UnregistrationConfirm(&(val)->u.unregistrationConfirm);
	    break;
	case 9:
	    ASN1Free_UnregistrationReject(&(val)->u.unregistrationReject);
	    break;
	case 10:
	    ASN1Free_AdmissionRequest(&(val)->u.admissionRequest);
	    break;
	case 11:
	    ASN1Free_AdmissionConfirm(&(val)->u.admissionConfirm);
	    break;
	case 12:
	    ASN1Free_AdmissionReject(&(val)->u.admissionReject);
	    break;
	case 13:
	    ASN1Free_BandwidthRequest(&(val)->u.bandwidthRequest);
	    break;
	case 14:
	    ASN1Free_BandwidthConfirm(&(val)->u.bandwidthConfirm);
	    break;
	case 15:
	    ASN1Free_BandwidthReject(&(val)->u.bandwidthReject);
	    break;
	case 16:
	    ASN1Free_DisengageRequest(&(val)->u.disengageRequest);
	    break;
	case 17:
	    ASN1Free_DisengageConfirm(&(val)->u.disengageConfirm);
	    break;
	case 18:
	    ASN1Free_DisengageReject(&(val)->u.disengageReject);
	    break;
	case 19:
	    ASN1Free_LocationRequest(&(val)->u.locationRequest);
	    break;
	case 20:
	    ASN1Free_LocationConfirm(&(val)->u.locationConfirm);
	    break;
	case 21:
	    ASN1Free_LocationReject(&(val)->u.locationReject);
	    break;
	case 22:
	    ASN1Free_InfoRequest(&(val)->u.infoRequest);
	    break;
	case 23:
	    ASN1Free_InfoRequestResponse(&(val)->u.infoRequestResponse);
	    break;
	case 24:
	    ASN1Free_H225NonStandardMessage(&(val)->u.nonStandardMessage);
	    break;
	case 25:
	    ASN1Free_UnknownMessageResponse(&(val)->u.unknownMessageResponse);
	    break;
	case 26:
	    ASN1Free_RequestInProgress(&(val)->u.requestInProgress);
	    break;
	case 27:
	    ASN1Free_ResourcesAvailableIndicate(&(val)->u.resourcesAvailableIndicate);
	    break;
	case 28:
	    ASN1Free_ResourcesAvailableConfirm(&(val)->u.resourcesAvailableConfirm);
	    break;
	case 29:
	    ASN1Free_InfoRequestAck(&(val)->u.infoRequestAck);
	    break;
	case 30:
	    ASN1Free_InfoRequestNak(&(val)->u.infoRequestNak);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_cryptoTokens(ASN1encoding_t enc, PResourcesAvailableConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ResourcesAvailableConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_cryptoTokens(ASN1decoding_t dec, PResourcesAvailableConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ResourcesAvailableConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_cryptoTokens(PResourcesAvailableConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ResourcesAvailableConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_cryptoTokens_ElmFn(PResourcesAvailableConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_cryptoTokens(ASN1encoding_t enc, PResourcesAvailableIndicate_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ResourcesAvailableIndicate_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_cryptoTokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_cryptoTokens(ASN1decoding_t dec, PResourcesAvailableIndicate_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ResourcesAvailableIndicate_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_cryptoTokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_cryptoTokens(PResourcesAvailableIndicate_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ResourcesAvailableIndicate_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_cryptoTokens_ElmFn(PResourcesAvailableIndicate_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RequestInProgress_cryptoTokens(ASN1encoding_t enc, PRequestInProgress_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RequestInProgress_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RequestInProgress_cryptoTokens_ElmFn(ASN1encoding_t enc, PRequestInProgress_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestInProgress_cryptoTokens(ASN1decoding_t dec, PRequestInProgress_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RequestInProgress_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RequestInProgress_cryptoTokens_ElmFn(ASN1decoding_t dec, PRequestInProgress_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RequestInProgress_cryptoTokens(PRequestInProgress_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RequestInProgress_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RequestInProgress_cryptoTokens_ElmFn(PRequestInProgress_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnknownMessageResponse_cryptoTokens(ASN1encoding_t enc, PUnknownMessageResponse_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnknownMessageResponse_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnknownMessageResponse_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnknownMessageResponse_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnknownMessageResponse_cryptoTokens(ASN1decoding_t dec, PUnknownMessageResponse_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnknownMessageResponse_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnknownMessageResponse_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnknownMessageResponse_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnknownMessageResponse_cryptoTokens(PUnknownMessageResponse_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnknownMessageResponse_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnknownMessageResponse_cryptoTokens_ElmFn(PUnknownMessageResponse_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H225NonStandardMessage_cryptoTokens(ASN1encoding_t enc, PH225NonStandardMessage_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H225NonStandardMessage_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_H225NonStandardMessage_cryptoTokens_ElmFn(ASN1encoding_t enc, PH225NonStandardMessage_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardMessage_cryptoTokens(ASN1decoding_t dec, PH225NonStandardMessage_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H225NonStandardMessage_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H225NonStandardMessage_cryptoTokens_ElmFn(ASN1decoding_t dec, PH225NonStandardMessage_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardMessage_cryptoTokens(PH225NonStandardMessage_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H225NonStandardMessage_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H225NonStandardMessage_cryptoTokens_ElmFn(PH225NonStandardMessage_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestNak_cryptoTokens(ASN1encoding_t enc, PInfoRequestNak_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestNak_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestNak_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestNak_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestNak_cryptoTokens(ASN1decoding_t dec, PInfoRequestNak_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestNak_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestNak_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestNak_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestNak_cryptoTokens(PInfoRequestNak_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestNak_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestNak_cryptoTokens_ElmFn(PInfoRequestNak_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestAck_cryptoTokens(ASN1encoding_t enc, PInfoRequestAck_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestAck_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestAck_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestAck_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestAck_cryptoTokens(ASN1decoding_t dec, PInfoRequestAck_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestAck_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestAck_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestAck_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestAck_cryptoTokens(PInfoRequestAck_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestAck_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestAck_cryptoTokens_ElmFn(PInfoRequestAck_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_cryptoTokens(ASN1encoding_t enc, PInfoRequestResponse_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_cryptoTokens(ASN1decoding_t dec, PInfoRequestResponse_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_cryptoTokens(PInfoRequestResponse_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_cryptoTokens_ElmFn(PInfoRequestResponse_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequest_cryptoTokens(ASN1encoding_t enc, PInfoRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequest_cryptoTokens(ASN1decoding_t dec, PInfoRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequest_cryptoTokens(PInfoRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequest_cryptoTokens_ElmFn(PInfoRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageReject_cryptoTokens(ASN1encoding_t enc, PDisengageReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageReject_cryptoTokens(ASN1decoding_t dec, PDisengageReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageReject_cryptoTokens(PDisengageReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageReject_cryptoTokens_ElmFn(PDisengageReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageConfirm_cryptoTokens(ASN1encoding_t enc, PDisengageConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageConfirm_cryptoTokens(ASN1decoding_t dec, PDisengageConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageConfirm_cryptoTokens(PDisengageConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageConfirm_cryptoTokens_ElmFn(PDisengageConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageRequest_cryptoTokens(ASN1encoding_t enc, PDisengageRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageRequest_cryptoTokens(ASN1decoding_t dec, PDisengageRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageRequest_cryptoTokens(PDisengageRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageRequest_cryptoTokens_ElmFn(PDisengageRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationReject_cryptoTokens(ASN1encoding_t enc, PLocationReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationReject_cryptoTokens(ASN1decoding_t dec, PLocationReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationReject_cryptoTokens(PLocationReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationReject_cryptoTokens_ElmFn(PLocationReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_cryptoTokens(ASN1encoding_t enc, PLocationConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_cryptoTokens(ASN1decoding_t dec, PLocationConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_cryptoTokens(PLocationConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_cryptoTokens_ElmFn(PLocationConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationRequest_cryptoTokens(ASN1encoding_t enc, PLocationRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRequest_cryptoTokens(ASN1decoding_t dec, PLocationRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationRequest_cryptoTokens(PLocationRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationRequest_cryptoTokens_ElmFn(PLocationRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthReject_cryptoTokens(ASN1encoding_t enc, PBandwidthReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthReject_cryptoTokens(ASN1decoding_t dec, PBandwidthReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthReject_cryptoTokens(PBandwidthReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthReject_cryptoTokens_ElmFn(PBandwidthReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthConfirm_cryptoTokens(ASN1encoding_t enc, PBandwidthConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthConfirm_cryptoTokens(ASN1decoding_t dec, PBandwidthConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthConfirm_cryptoTokens(PBandwidthConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthConfirm_cryptoTokens_ElmFn(PBandwidthConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthRequest_cryptoTokens(ASN1encoding_t enc, PBandwidthRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthRequest_cryptoTokens(ASN1decoding_t dec, PBandwidthRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthRequest_cryptoTokens(PBandwidthRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthRequest_cryptoTokens_ElmFn(PBandwidthRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionReject_cryptoTokens(ASN1encoding_t enc, PAdmissionReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionReject_cryptoTokens(ASN1decoding_t dec, PAdmissionReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionReject_cryptoTokens(PAdmissionReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionReject_cryptoTokens_ElmFn(PAdmissionReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_cryptoTokens(ASN1encoding_t enc, PAdmissionConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_cryptoTokens(ASN1decoding_t dec, PAdmissionConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_cryptoTokens(PAdmissionConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_cryptoTokens_ElmFn(PAdmissionConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_cryptoTokens(ASN1encoding_t enc, PAdmissionRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_cryptoTokens(ASN1decoding_t dec, PAdmissionRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_cryptoTokens(PAdmissionRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_cryptoTokens_ElmFn(PAdmissionRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationReject_cryptoTokens(ASN1encoding_t enc, PUnregistrationReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationReject_cryptoTokens(ASN1decoding_t dec, PUnregistrationReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationReject_cryptoTokens(PUnregistrationReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationReject_cryptoTokens_ElmFn(PUnregistrationReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationConfirm_cryptoTokens(ASN1encoding_t enc, PUnregistrationConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationConfirm_cryptoTokens(ASN1decoding_t dec, PUnregistrationConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationConfirm_cryptoTokens(PUnregistrationConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationConfirm_cryptoTokens_ElmFn(PUnregistrationConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_cryptoTokens(ASN1encoding_t enc, PUnregistrationRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_cryptoTokens(ASN1decoding_t dec, PUnregistrationRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest_cryptoTokens(PUnregistrationRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationRequest_cryptoTokens_ElmFn(PUnregistrationRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationReject_cryptoTokens(ASN1encoding_t enc, PRegistrationReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationReject_cryptoTokens(ASN1decoding_t dec, PRegistrationReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationReject_cryptoTokens(PRegistrationReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationReject_cryptoTokens_ElmFn(PRegistrationReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_cryptoTokens(ASN1encoding_t enc, PRegistrationConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_cryptoTokens(ASN1decoding_t dec, PRegistrationConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm_cryptoTokens(PRegistrationConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationConfirm_cryptoTokens_ElmFn(PRegistrationConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_cryptoTokens(ASN1encoding_t enc, PRegistrationRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_cryptoTokens(ASN1decoding_t dec, PRegistrationRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_cryptoTokens(PRegistrationRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_cryptoTokens_ElmFn(PRegistrationRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperReject_cryptoTokens(ASN1encoding_t enc, PGatekeeperReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperReject_cryptoTokens(ASN1decoding_t dec, PGatekeeperReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperReject_cryptoTokens(PGatekeeperReject_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperReject_cryptoTokens_ElmFn(PGatekeeperReject_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_cryptoTokens(ASN1encoding_t enc, PGatekeeperConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_cryptoTokens(ASN1decoding_t dec, PGatekeeperConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_cryptoTokens(PGatekeeperConfirm_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_cryptoTokens_ElmFn(PGatekeeperConfirm_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_cryptoTokens(ASN1encoding_t enc, PGatekeeperRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_cryptoTokens(ASN1decoding_t dec, PGatekeeperRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_cryptoTokens(PGatekeeperRequest_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_cryptoTokens_ElmFn(PGatekeeperRequest_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_cryptoTokens(ASN1encoding_t enc, PEndpoint_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_cryptoTokens_ElmFn(ASN1encoding_t enc, PEndpoint_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_cryptoTokens(ASN1decoding_t dec, PEndpoint_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_cryptoTokens_ElmFn(ASN1decoding_t dec, PEndpoint_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_cryptoTokens(PEndpoint_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_cryptoTokens_ElmFn(PEndpoint_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Progress_UUIE_cryptoTokens(ASN1encoding_t enc, PProgress_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Progress_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Progress_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PProgress_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Progress_UUIE_cryptoTokens(ASN1decoding_t dec, PProgress_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Progress_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Progress_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PProgress_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Progress_UUIE_cryptoTokens(PProgress_UUIE_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Progress_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Progress_UUIE_cryptoTokens_ElmFn(PProgress_UUIE_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_conferences(ASN1encoding_t enc, PFacility_UUIE_conferences *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_conferences_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_conferences_ElmFn(ASN1encoding_t enc, PFacility_UUIE_conferences val)
{
    if (!ASN1Enc_ConferenceList(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_conferences(ASN1decoding_t dec, PFacility_UUIE_conferences *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_conferences_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_conferences_ElmFn(ASN1decoding_t dec, PFacility_UUIE_conferences val)
{
    if (!ASN1Dec_ConferenceList(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_conferences(PFacility_UUIE_conferences *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_conferences_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_conferences_ElmFn(PFacility_UUIE_conferences val)
{
    if (val) {
	ASN1Free_ConferenceList(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_cryptoTokens(ASN1encoding_t enc, PFacility_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PFacility_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_cryptoTokens(ASN1decoding_t dec, PFacility_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PFacility_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_cryptoTokens(PFacility_UUIE_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_cryptoTokens_ElmFn(PFacility_UUIE_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_cryptoTokens(ASN1encoding_t enc, PSetup_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PSetup_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_cryptoTokens(ASN1decoding_t dec, PSetup_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PSetup_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_cryptoTokens(PSetup_UUIE_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_cryptoTokens_ElmFn(PSetup_UUIE_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Connect_UUIE_cryptoTokens(ASN1encoding_t enc, PConnect_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Connect_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Connect_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PConnect_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Connect_UUIE_cryptoTokens(ASN1decoding_t dec, PConnect_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Connect_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Connect_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PConnect_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Connect_UUIE_cryptoTokens(PConnect_UUIE_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Connect_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Connect_UUIE_cryptoTokens_ElmFn(PConnect_UUIE_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_cryptoTokens(ASN1encoding_t enc, PCallProceeding_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CallProceeding_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_cryptoTokens(ASN1decoding_t dec, PCallProceeding_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CallProceeding_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_cryptoTokens(PCallProceeding_UUIE_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CallProceeding_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_cryptoTokens_ElmFn(PCallProceeding_UUIE_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_cryptoTokens(ASN1encoding_t enc, PAlerting_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Alerting_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_cryptoTokens(ASN1decoding_t dec, PAlerting_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Alerting_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Alerting_UUIE_cryptoTokens(PAlerting_UUIE_cryptoTokens *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Alerting_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Alerting_UUIE_cryptoTokens_ElmFn(PAlerting_UUIE_cryptoTokens val)
{
    if (val) {
	ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h323_message_body(ASN1encoding_t enc, H323_UU_PDU_h323_message_body *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_Setup_UUIE(enc, &(val)->u.setup))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_CallProceeding_UUIE(enc, &(val)->u.callProceeding))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_Connect_UUIE(enc, &(val)->u.connect))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_Alerting_UUIE(enc, &(val)->u.alerting))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_Information_UUIE(enc, &(val)->u.information))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_ReleaseComplete_UUIE(enc, &(val)->u.releaseComplete))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_Facility_UUIE(enc, &(val)->u.facility))
	    return 0;
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_Progress_UUIE(ee, &(val)->u.progress))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h323_message_body(ASN1decoding_t dec, H323_UU_PDU_h323_message_body *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_Setup_UUIE(dec, &(val)->u.setup))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_CallProceeding_UUIE(dec, &(val)->u.callProceeding))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_Connect_UUIE(dec, &(val)->u.connect))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_Alerting_UUIE(dec, &(val)->u.alerting))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_Information_UUIE(dec, &(val)->u.information))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_ReleaseComplete_UUIE(dec, &(val)->u.releaseComplete))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_Facility_UUIE(dec, &(val)->u.facility))
	    return 0;
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_Progress_UUIE(dd, &(val)->u.progress))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h323_message_body(H323_UU_PDU_h323_message_body *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_Setup_UUIE(&(val)->u.setup);
	    break;
	case 2:
	    ASN1Free_CallProceeding_UUIE(&(val)->u.callProceeding);
	    break;
	case 3:
	    ASN1Free_Connect_UUIE(&(val)->u.connect);
	    break;
	case 4:
	    ASN1Free_Alerting_UUIE(&(val)->u.alerting);
	    break;
	case 5:
	    ASN1Free_Information_UUIE(&(val)->u.information);
	    break;
	case 6:
	    ASN1Free_ReleaseComplete_UUIE(&(val)->u.releaseComplete);
	    break;
	case 7:
	    ASN1Free_Facility_UUIE(&(val)->u.facility);
	    break;
	case 8:
	    ASN1Free_Progress_UUIE(&(val)->u.progress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU(ASN1encoding_t enc, H323_UU_PDU *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (!ASN1Enc_H323_UU_PDU_h323_message_body(enc, &(val)->h323_message_body))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1Enc_H323_UU_PDU_h4501SupplementaryService(ee, &(val)->h4501SupplementaryService))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1PEREncBoolean(ee, (val)->h245Tunneling))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1Enc_H323_UU_PDU_h245Control(ee, &(val)->h245Control))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1Enc_H323_UU_PDU_nonStandardControl(ee, &(val)->nonStandardControl))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU(ASN1decoding_t dec, H323_UU_PDU *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_H323_UU_PDU_h323_message_body(dec, &(val)->h323_message_body))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H323_UU_PDU_h4501SupplementaryService(dd, &(val)->h4501SupplementaryService))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->h245Tunneling))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H323_UU_PDU_h245Control(dd, &(val)->h245Control))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H323_UU_PDU_nonStandardControl(dd, &(val)->nonStandardControl))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU(H323_UU_PDU *val)
{
    if (val) {
	ASN1Free_H323_UU_PDU_h323_message_body(&(val)->h323_message_body);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_H323_UU_PDU_h4501SupplementaryService(&(val)->h4501SupplementaryService);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_H323_UU_PDU_h245Control(&(val)->h245Control);
	}
	if ((val)->o[1] & 0x10) {
	    ASN1Free_H323_UU_PDU_nonStandardControl(&(val)->nonStandardControl);
	}
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(ASN1encoding_t enc, InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val)
{
    if (!ASN1Enc_H323_UU_PDU(enc, &(val)->h323pdu))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->sent))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(ASN1decoding_t dec, InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val)
{
    if (!ASN1Dec_H323_UU_PDU(dec, &(val)->h323pdu))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->sent))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val)
{
    if (val) {
	ASN1Free_H323_UU_PDU(&(val)->h323pdu);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_pdu *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_pdu val)
{
    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_pdu *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_pdu val)
{
    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu(PInfoRequestResponse_perCallInfo_Seq_pdu *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(PInfoRequestResponse_perCallInfo_Seq_pdu val)
{
    if (val) {
	ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UserInformation(ASN1encoding_t enc, H323_UserInformation *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_H323_UU_PDU(enc, &(val)->h323_uu_pdu))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H323_UserInformation_user_data(enc, &(val)->user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UserInformation(ASN1decoding_t dec, H323_UserInformation *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_H323_UU_PDU(dec, &(val)->h323_uu_pdu))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H323_UserInformation_user_data(dec, &(val)->user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323_UserInformation(H323_UserInformation *val)
{
    if (val) {
	ASN1Free_H323_UU_PDU(&(val)->h323_uu_pdu);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H323_UserInformation_user_data(&(val)->user_data);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\h323ics.h ===
#ifndef	__h323ics_h
#define	__h323ics_h

// relative to HKEY_LOCAL_MACHINE
#define H323ICS_SERVICE_NAME                    _T("SharedAccess")
#define	H323ICS_SERVICE_KEY_PATH				_T("System\\CurrentControlSet\\Services\\") H323ICS_SERVICE_NAME
#define	H323ICS_SERVICE_PARAMETERS_KEY_PATH	H323ICS_SERVICE_KEY_PATH _T("\\Parameters")

// values which may be set in H323ICS_SERVICE_PARAMETERS_KEY_PATH
#define H323ICS_REG_VAL_LOCAL_H323_ROUTING      _T("LocalH323Routing")		    // REG_DWORD, 0 or 1
#define H323ICS_REG_VAL_DEFAULT_LOCAL_DEST_ADDR _T("DefaultQ931Destination")	// REG_SZ, textual IP address

#endif // __h323ics_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\h323icsp.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    h323icsp.h

Abstract:

    This module defines the interface between the H.323 proxy (H323ICS.LIB)
    and ICS (IPNATHLP.DLL). The routines whose prototypes appear here are
    invoked by ICS from within the RRAS stub created for the H.323 proxy.
    (See 'MS_IP_H323' in 'ROUTPROT.H'.)

Author:

    Abolade Gbadegesin (aboladeg)   22-Jun-1999

Revision History:
    03/06/2000 - changed prototype of H323ProxyActivateInterface so that 
                 the function takes a parameter identifying whether the
                 interface is public or private  ---  Ilya Kleyman (ilyak)

--*/

#ifndef _H323ICSP_H_
#define _H323ICSP_H_

#ifndef	EXTERN_C
#ifdef	__cplusplus
#define	EXTERN_C	extern "C"
#else
#define	EXTERN_C
#endif
#endif

#define INVALID_INTERFACE_INDEX     ((ULONG)-1)

typedef enum {
    H323_INTERFACE_PUBLIC,
    H323_INTERFACE_PUBLIC_FIREWALLED,
    H323_INTERFACE_PRIVATE
} H323_INTERFACE_TYPE;

EXTERN_C BOOLEAN
H323ProxyInitializeModule(
    VOID
    );

EXTERN_C VOID
H323ProxyCleanupModule(
    VOID
    );

EXTERN_C ULONG
H323ProxyStartService(
    VOID
    );

EXTERN_C VOID
H323ProxyStopService(
    VOID
    );

EXTERN_C ULONG
H323ProxyActivateInterface(
    ULONG Index,
    H323_INTERFACE_TYPE InterfaceType,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    );

EXTERN_C VOID
H323ProxyDeactivateInterface(
    ULONG Index
    );

#endif // _H323ICSP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\h323asn1.h ===
#ifndef	__h323ics_h323asn1_h
#define	__h323ics_h323asn1_h

#include "q931msg.h"

DWORD H225EncodePdu (
	IN	DWORD		PduType,
	IN	PVOID		PduStructure,
	OUT	PUCHAR *	ReturnBuffer,
	OUT	PDWORD		ReturnBufferLength);

DWORD H225DecodePdu (
	IN	PUCHAR		Buffer,
	IN	DWORD		BufferLength,
	IN	DWORD		PduType,
	OUT	PVOID *		ReturnPduStructure);

DWORD H225FreePdu (
	IN	DWORD		PduType,
	IN	PVOID		PduStructure);

DWORD H225FreeBuffer (
	IN	PUCHAR		Buffer);

DWORD H245EncodePdu (
	IN	DWORD		PduType,
	IN	PVOID		PduStructure,
	OUT	PUCHAR *	ReturnBuffer,
	OUT	PDWORD		ReturnBufferLength);

DWORD H245DecodePdu (
	IN	PUCHAR		Buffer,
	IN	DWORD		BufferLength,
	IN	DWORD		PduType,
	OUT	PVOID *		ReturnPduStructure);

DWORD H245FreePdu (
	IN	DWORD		PduType,
	IN	PVOID		PduStructure);

DWORD H245FreeBuffer (
	IN	PUCHAR		Buffer);

// These macros define declarations for inline functions.
// This provides type safety when encoding and decoding certain PDUs.

#define	DECLARE_CODER_FUNCS(MODULE,STRUCTURE) \
/* static */ __inline DWORD MODULE ## EncodePdu_ ## STRUCTURE	\
	(STRUCTURE * PduStructure, OUT PUCHAR * ReturnBuffer, OUT PDWORD ReturnBufferLength)	\
	{ return MODULE ## EncodePdu (STRUCTURE ## _PDU, PduStructure, ReturnBuffer, ReturnBufferLength); }	\
/* static */ __inline DWORD MODULE ## DecodePdu_ ## STRUCTURE	\
	(IN PUCHAR Buffer, IN DWORD BufferLength, OUT STRUCTURE ** ReturnPduStructure)	\
	{ return MODULE ## DecodePdu (Buffer, BufferLength, STRUCTURE ## _PDU, (PVOID *) ReturnPduStructure); }	\
/* static */ __inline DWORD MODULE ## FreePdu_ ## STRUCTURE	\
	(IN STRUCTURE * PduStructure)	\
	{ return MODULE ## FreePdu (STRUCTURE ## _PDU, PduStructure); }

DECLARE_CODER_FUNCS (H225, RasMessage)
DECLARE_CODER_FUNCS (H225, H323_UserInformation)
DECLARE_CODER_FUNCS (H245, MultimediaSystemControlMessage)

void	H323ASN1Initialize	(void);
void	H323ASN1Shutdown	(void);


HRESULT EncodeQ931PDU(
        IN  Q931_MESSAGE           *pQ931msg,
        IN  H323_UserInformation   *pUserInformation,
        OUT BYTE                  **ppReturnEncodedData,
        OUT DWORD				   *pReturnEncodedDataLength
        );

HRESULT EncodeH245PDU(
	IN	MultimediaSystemControlMessage &rH245pdu,
	OUT	BYTE                          **ppReturnEncodedData,
	OUT	DWORD                          *pReturnEncodedDataLength);

HRESULT DecodeQ931PDU(
        IN  BYTE                       *pbData,
        IN  DWORD                       dwDataLen,
        OUT Q931_MESSAGE             **ppReturnQ931msg,
        OUT H323_UserInformation      **ppReturnH323UserInfo);

HRESULT DecodeH245PDU(
	IN  LPBYTE                              Data,
	IN  DWORD                               DataLength,
	OUT MultimediaSystemControlMessage    **ppReturnH245pdu);

HRESULT Q931EncodeCallProceedingMessage(
    IN      WORD                    CallRefVal,
    IN OUT  Q931_MESSAGE           *pReturnQ931msg,
    IN OUT  H323_UserInformation   *pReturnH323UserInfo);

HRESULT Q931EncodeReleaseCompleteMessage(
    IN      WORD                    CallRefVal,
    IN OUT  Q931_MESSAGE           *pReturnQ931msg,
    IN OUT  H323_UserInformation   *pReturnH323UserInfo);

// These functions should only be used for PDU structures generated
// using the decode functions.
// If you allocate the PDU structures yourself (for eg. CallProceeding PDU)
// then you need to free it yourself depending on how you allocated the
// structure.
void FreeQ931PDU(
     IN Q931_MESSAGE           *pQ931msg,
     IN H323_UserInformation   *pH323UserInformation);

void FreeH245PDU(
     MultimediaSystemControlMessage *pH245pdu);


#endif // __h323ics_h323asn1_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\h245pp.h ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for Multimedia System Control (H.245) */

#ifndef _H245PP_Module_H_
#define _H245PP_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct UnicastAddress_iPSourceRouteAddress_route * PUnicastAddress_iPSourceRouteAddress_route;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers * PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers;

typedef struct RedundancyEncodingCapability_secondaryEncoding * PRedundancyEncodingCapability_secondaryEncoding;

typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom * PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom;

typedef struct MultiplexElement_type_subElementList * PMultiplexElement_type_subElementList;

typedef struct RequestAllTerminalIDsResponse_terminalInformation * PRequestAllTerminalIDsResponse_terminalInformation;

typedef struct EncryptionSync_escrowentry * PEncryptionSync_escrowentry;

typedef struct H263Options_customPictureFormat * PH263Options_customPictureFormat;

typedef struct H263Options_customPictureClockFrequency * PH263Options_customPictureClockFrequency;

typedef struct MultipointCapability_mediaDistributionCapability * PMultipointCapability_mediaDistributionCapability;

typedef struct H222Capability_vcCapability * PH222Capability_vcCapability;

typedef struct CapabilityDescriptor_simultaneousCapabilities * PCapabilityDescriptor_simultaneousCapabilities;

typedef struct CertSelectionCriteria * PCertSelectionCriteria;

typedef struct CommunicationModeTableEntry_nonStandard * PCommunicationModeTableEntry_nonStandard;

typedef struct MultiplexEntrySend_multiplexEntryDescriptors * PMultiplexEntrySend_multiplexEntryDescriptors;

typedef struct H2250LogicalChannelAckParameters_nonStandard * PH2250LogicalChannelAckParameters_nonStandard;

typedef struct H2250LogicalChannelParameters_nonStandard * PH2250LogicalChannelParameters_nonStandard;

typedef struct ConferenceCapability_nonStandardData * PConferenceCapability_nonStandardData;

typedef struct H263Options_modeCombos * PH263Options_modeCombos;

typedef struct TransportCapability_qOSCapabilities * PTransportCapability_qOSCapabilities;

typedef struct EncryptionCapability * PEncryptionCapability;

typedef struct EnhancementLayerInfo_spatialEnhancement * PEnhancementLayerInfo_spatialEnhancement;

typedef struct EnhancementLayerInfo_snrEnhancement * PEnhancementLayerInfo_snrEnhancement;

typedef struct H2250Capability_redundancyEncodingCapability * PH2250Capability_redundancyEncodingCapability;

typedef struct EnhancementLayerInfo_bPictureEnhancement * PEnhancementLayerInfo_bPictureEnhancement;

typedef struct MediaDistributionCapability_distributedData * PMediaDistributionCapability_distributedData;

typedef struct MediaDistributionCapability_centralizedData * PMediaDistributionCapability_centralizedData;

typedef struct CommunicationModeResponse_communicationModeTable * PCommunicationModeResponse_communicationModeTable;

typedef struct CommunicationModeCommand_communicationModeTable * PCommunicationModeCommand_communicationModeTable;

typedef struct TerminalCapabilitySet_capabilityTable * PTerminalCapabilitySet_capabilityTable;

typedef struct RequestMode_requestedModes * PRequestMode_requestedModes;

typedef struct UnicastAddress_iPSourceRouteAddress_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} UnicastAddress_iPSourceRouteAddress_route_Seq;

typedef ASN1uint16_t CustomPictureFormat_pixelAspectInformation_pixelAspectCode_Set;

typedef ASN1uint16_t RTPH263VideoRedundancyEncoding_containedThreads_Seq;

typedef ASN1uint16_t RTPH263VideoRedundancyFrameMapping_frameSequence_Seq;

typedef ASN1uint16_t SequenceNumber;

typedef ASN1uint16_t CapabilityTableEntryNumber;

typedef ASN1uint16_t CapabilityDescriptorNumber;

typedef ASN1uint16_t LogicalChannelNumber;

typedef ASN1uint16_t MultiplexTableEntryNumber;

typedef ASN1uint16_t McuNumber;

typedef ASN1uint16_t TerminalNumber;

typedef struct TerminalID {
    ASN1uint32_t length;
    ASN1octet_t value[128];
} TerminalID;

typedef struct ConferenceID {
    ASN1uint32_t length;
    ASN1octet_t value[32];
} ConferenceID;

typedef struct H245Password {
    ASN1uint32_t length;
    ASN1octet_t value[32];
} H245Password;

typedef struct NewATMVCIndication_aal_aal1_errorCorrection {
    ASN1choice_t choice;
#   define nullErrorCorrection_chosen 1
#   define longInterleaver_chosen 2
#   define shortInterleaver_chosen 3
#   define errorCorrectionOnly_chosen 4
} NewATMVCIndication_aal_aal1_errorCorrection;

typedef struct NewATMVCIndication_aal_aal1_clockRecovery {
    ASN1choice_t choice;
#   define nullClockRecovery_chosen 1
#   define srtsClockRecovery_chosen 2
#   define adaptiveClockRecovery_chosen 3
} NewATMVCIndication_aal_aal1_clockRecovery;

typedef struct MiscellaneousCommand_type_progressiveRefinementStart_repeatCount {
    ASN1choice_t choice;
#   define doOneProgression_chosen 1
#   define doContinuousProgressions_chosen 2
#   define doOneIndependentProgression_chosen 3
#   define doContinuousIndependentProgressions_chosen 4
} MiscellaneousCommand_type_progressiveRefinementStart_repeatCount;

typedef struct V76LogicalChannelParameters_mode_eRM_recovery {
    ASN1choice_t choice;
#   define rej_chosen 1
#   define sREJ_chosen 2
#   define mSREJ_chosen 3
} V76LogicalChannelParameters_mode_eRM_recovery;

typedef struct CustomPictureFormat_pixelAspectInformation_extendedPAR_Set {
    ASN1uint16_t width;
    ASN1uint16_t height;
} CustomPictureFormat_pixelAspectInformation_extendedPAR_Set;

typedef struct CustomPictureFormat_mPI_customPCF_Set {
    ASN1uint16_t clockConversionCode;
    ASN1uint16_t clockDivisor;
    ASN1uint16_t customMPI;
} CustomPictureFormat_mPI_customPCF_Set;

typedef struct VCCapability_availableBitRates_type_rangeOfBitRates {
    ASN1uint16_t lowerBitRate;
    ASN1uint16_t higherBitRate;
} VCCapability_availableBitRates_type_rangeOfBitRates;

typedef struct TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded {
    ASN1choice_t choice;
    union {
#	define highestEntryNumberProcessed_chosen 1
	CapabilityTableEntryNumber highestEntryNumberProcessed;
#	define noneProcessed_chosen 2
    } u;
} TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded;

typedef struct VCCapability_availableBitRates_type {
    ASN1choice_t choice;
    union {
#	define singleBitRate_chosen 1
	ASN1uint16_t singleBitRate;
#	define rangeOfBitRates_chosen 2
	VCCapability_availableBitRates_type_rangeOfBitRates rangeOfBitRates;
    } u;
} VCCapability_availableBitRates_type;

typedef struct H223Capability_h223MultiplexTableCapability_enhanced {
    ASN1uint16_t maximumNestingDepth;
    ASN1uint16_t maximumElementListSize;
    ASN1uint16_t maximumSubElementListSize;
} H223Capability_h223MultiplexTableCapability_enhanced;

typedef struct CustomPictureFormat_mPI_customPCF {
    ASN1uint32_t count;
    CustomPictureFormat_mPI_customPCF_Set value[16];
} CustomPictureFormat_mPI_customPCF;

typedef struct CustomPictureFormat_pixelAspectInformation_extendedPAR {
    ASN1uint32_t count;
    CustomPictureFormat_pixelAspectInformation_extendedPAR_Set value[256];
} CustomPictureFormat_pixelAspectInformation_extendedPAR;

typedef struct CustomPictureFormat_pixelAspectInformation_pixelAspectCode {
    ASN1uint32_t count;
    CustomPictureFormat_pixelAspectInformation_pixelAspectCode_Set value[14];
} CustomPictureFormat_pixelAspectInformation_pixelAspectCode;

typedef struct H223LogicalChannelParameters_adaptationLayerType_al3 {
    ASN1uint16_t controlFieldOctets;
    ASN1uint32_t sendBufferSize;
} H223LogicalChannelParameters_adaptationLayerType_al3;

typedef struct V76LogicalChannelParameters_mode_eRM {
    ASN1uint16_t windowSize;
    V76LogicalChannelParameters_mode_eRM_recovery recovery;
} V76LogicalChannelParameters_mode_eRM;

typedef struct UnicastAddress_iPSourceRouteAddress_route {
    PUnicastAddress_iPSourceRouteAddress_route next;
    UnicastAddress_iPSourceRouteAddress_route_Seq value;
} UnicastAddress_iPSourceRouteAddress_route_Element;

typedef struct UnicastAddress_iPSourceRouteAddress_routing {
    ASN1choice_t choice;
#   define strict_chosen 1
#   define loose_chosen 2
} UnicastAddress_iPSourceRouteAddress_routing;

typedef struct H223ModeParameters_adaptationLayerType_al3 {
    ASN1uint16_t controlFieldOctets;
    ASN1uint32_t sendBufferSize;
} H223ModeParameters_adaptationLayerType_al3;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers {
    ASN1uint32_t count;
    CapabilityDescriptorNumber value[256];
} SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers {
    PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers next;
    CapabilityTableEntryNumber value;
} SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_Element;

typedef struct MiscellaneousCommand_type_progressiveRefinementStart {
    MiscellaneousCommand_type_progressiveRefinementStart_repeatCount repeatCount;
} MiscellaneousCommand_type_progressiveRefinementStart;

typedef struct MiscellaneousCommand_type_videoFastUpdateMB {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define firstGOB_present 0x80
    ASN1uint16_t firstGOB;
#   define firstMB_present 0x40
    ASN1uint16_t firstMB;
    ASN1uint16_t numberOfMBs;
} MiscellaneousCommand_type_videoFastUpdateMB;

typedef struct MiscellaneousCommand_type_videoFastUpdateGOB {
    ASN1uint16_t firstGOB;
    ASN1uint16_t numberOfGOBs;
} MiscellaneousCommand_type_videoFastUpdateGOB;

typedef struct MiscellaneousIndication_type_videoNotDecodedMBs {
    ASN1uint16_t firstMB;
    ASN1uint16_t numberOfMBs;
    ASN1uint16_t temporalReference;
} MiscellaneousIndication_type_videoNotDecodedMBs;

typedef struct NewATMVCIndication_aal_aal5 {
    ASN1uint16_t forwardMaximumSDUSize;
    ASN1uint16_t backwardMaximumSDUSize;
} NewATMVCIndication_aal_aal5;

typedef struct NewATMVCIndication_aal_aal1 {
    NewATMVCIndication_aal_aal1_clockRecovery clockRecovery;
    NewATMVCIndication_aal_aal1_errorCorrection errorCorrection;
    ASN1bool_t structuredDataTransfer;
    ASN1bool_t partiallyFilledCells;
} NewATMVCIndication_aal_aal1;

typedef struct NewATMVCIndication_reverseParameters_multiplex {
    ASN1choice_t choice;
#   define NewATMVCIndication_reverseParameters_multiplex_noMultiplex_chosen 1
#   define NewATMVCIndication_reverseParameters_multiplex_transportStream_chosen 2
#   define NewATMVCIndication_reverseParameters_multiplex_programStream_chosen 3
} NewATMVCIndication_reverseParameters_multiplex;

typedef struct UserInputIndication_signal_rtp {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define timestamp_present 0x80
    ASN1uint32_t timestamp;
#   define expirationTime_present 0x40
    ASN1uint32_t expirationTime;
    LogicalChannelNumber logicalChannelNumber;
} UserInputIndication_signal_rtp;

typedef struct UserInputIndication_signalUpdate_rtp {
    LogicalChannelNumber logicalChannelNumber;
} UserInputIndication_signalUpdate_rtp;

typedef struct UserInputIndication_signalUpdate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t duration;
#   define UserInputIndication_signalUpdate_rtp_present 0x80
    UserInputIndication_signalUpdate_rtp rtp;
} UserInputIndication_signalUpdate;

typedef struct UserInputIndication_signal {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1char_t signalType[2];
#   define duration_present 0x80
    ASN1uint16_t duration;
#   define UserInputIndication_signal_rtp_present 0x40
    UserInputIndication_signal_rtp rtp;
} UserInputIndication_signal;

typedef struct NewATMVCIndication_reverseParameters {
    ASN1uint16_t bitRate;
    ASN1bool_t bitRateLockedToPCRClock;
    ASN1bool_t bitRateLockedToNetworkClock;
    NewATMVCIndication_reverseParameters_multiplex multiplex;
} NewATMVCIndication_reverseParameters;

typedef struct NewATMVCIndication_multiplex {
    ASN1choice_t choice;
#   define NewATMVCIndication_multiplex_noMultiplex_chosen 1
#   define NewATMVCIndication_multiplex_transportStream_chosen 2
#   define NewATMVCIndication_multiplex_programStream_chosen 3
} NewATMVCIndication_multiplex;

typedef struct NewATMVCIndication_aal {
    ASN1choice_t choice;
    union {
#	define aal1_chosen 1
	NewATMVCIndication_aal_aal1 aal1;
#	define aal5_chosen 2
	NewATMVCIndication_aal_aal5 aal5;
    } u;
} NewATMVCIndication_aal;

typedef struct JitterIndication_scope {
    ASN1choice_t choice;
    union {
#	define JitterIndication_scope_logicalChannelNumber_chosen 1
	LogicalChannelNumber logicalChannelNumber;
#	define JitterIndication_scope_resourceID_chosen 2
	ASN1uint16_t resourceID;
#	define JitterIndication_scope_wholeMultiplex_chosen 3
    } u;
} JitterIndication_scope;

typedef struct FunctionNotSupported_cause {
    ASN1choice_t choice;
#   define syntaxError_chosen 1
#   define semanticError_chosen 2
#   define unknownFunction_chosen 3
} FunctionNotSupported_cause;

typedef struct H223MultiplexReconfiguration_h223AnnexADoubleFlag {
    ASN1choice_t choice;
#   define start_chosen 1
#   define stop_chosen 2
} H223MultiplexReconfiguration_h223AnnexADoubleFlag;

typedef struct H223MultiplexReconfiguration_h223ModeChange {
    ASN1choice_t choice;
#   define toLevel0_chosen 1
#   define toLevel1_chosen 2
#   define toLevel2_chosen 3
#   define toLevel2withOptionalHeader_chosen 4
} H223MultiplexReconfiguration_h223ModeChange;

typedef struct EndSessionCommand_isdnOptions {
    ASN1choice_t choice;
#   define EndSessionCommand_isdnOptions_telephonyMode_chosen 1
#   define v140_chosen 2
#   define terminalOnHold_chosen 3
} EndSessionCommand_isdnOptions;

typedef struct EndSessionCommand_gstnOptions {
    ASN1choice_t choice;
#   define EndSessionCommand_gstnOptions_telephonyMode_chosen 1
#   define v8bis_chosen 2
#   define v34DSVD_chosen 3
#   define v34DuplexFAX_chosen 4
#   define v34H324_chosen 5
} EndSessionCommand_gstnOptions;

typedef struct FlowControlCommand_restriction {
    ASN1choice_t choice;
    union {
#	define maximumBitRate_chosen 1
	ASN1uint32_t maximumBitRate;
#	define noRestriction_chosen 2
    } u;
} FlowControlCommand_restriction;

typedef struct FlowControlCommand_scope {
    ASN1choice_t choice;
    union {
#	define FlowControlCommand_scope_logicalChannelNumber_chosen 1
	LogicalChannelNumber logicalChannelNumber;
#	define FlowControlCommand_scope_resourceID_chosen 2
	ASN1uint16_t resourceID;
#	define FlowControlCommand_scope_wholeMultiplex_chosen 3
    } u;
} FlowControlCommand_scope;

typedef struct SendTerminalCapabilitySet_specificRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t multiplexCapability;
#   define capabilityTableEntryNumbers_present 0x80
    PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers capabilityTableEntryNumbers;
#   define capabilityDescriptorNumbers_present 0x40
    SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers capabilityDescriptorNumbers;
} SendTerminalCapabilitySet_specificRequest;

typedef struct RemoteMCResponse_reject {
    ASN1choice_t choice;
#   define RemoteMCResponse_reject_unspecified_chosen 1
#   define RemoteMCResponse_reject_functionNotSupported_chosen 2
} RemoteMCResponse_reject;

typedef struct ConferenceResponse_sendThisSourceResponse {
    ASN1choice_t choice;
#   define grantedSendThisSource_chosen 1
#   define deniedSendThisSource_chosen 2
} ConferenceResponse_sendThisSourceResponse;

typedef struct ConferenceResponse_makeTerminalBroadcasterResponse {
    ASN1choice_t choice;
#   define grantedMakeTerminalBroadcaster_chosen 1
#   define deniedMakeTerminalBroadcaster_chosen 2
} ConferenceResponse_makeTerminalBroadcasterResponse;

typedef struct ConferenceResponse_broadcastMyLogicalChannelResponse {
    ASN1choice_t choice;
#   define grantedBroadcastMyLogicalChannel_chosen 1
#   define deniedBroadcastMyLogicalChannel_chosen 2
} ConferenceResponse_broadcastMyLogicalChannelResponse;

typedef struct ConferenceResponse_extensionAddressResponse {
    TerminalID extensionAddress;
} ConferenceResponse_extensionAddressResponse;

typedef struct ConferenceResponse_makeMeChairResponse {
    ASN1choice_t choice;
#   define grantedChairToken_chosen 1
#   define deniedChairToken_chosen 2
} ConferenceResponse_makeMeChairResponse;

typedef struct MaintenanceLoopReject_cause {
    ASN1choice_t choice;
#   define canNotPerformLoop_chosen 1
} MaintenanceLoopReject_cause;

typedef struct MaintenanceLoopReject_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopReject_type_systemLoop_chosen 1
#	define MaintenanceLoopReject_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopReject_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopReject_type;

typedef struct MaintenanceLoopAck_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopAck_type_systemLoop_chosen 1
#	define MaintenanceLoopAck_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopAck_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopAck_type;

typedef struct MaintenanceLoopRequest_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopRequest_type_systemLoop_chosen 1
#	define MaintenanceLoopRequest_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopRequest_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopRequest_type;

typedef struct G7231AnnexCMode_g723AnnexCAudioMode {
    ASN1uint16_t highRateMode0;
    ASN1uint16_t highRateMode1;
    ASN1uint16_t lowRateMode0;
    ASN1uint16_t lowRateMode1;
    ASN1uint16_t sidMode0;
    ASN1uint16_t sidMode1;
} G7231AnnexCMode_g723AnnexCAudioMode;

typedef struct IS13818AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS13818AudioMode_multichannelType_singleChannel_chosen 1
#   define IS13818AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS13818AudioMode_multichannelType_twoChannelDual_chosen 3
#   define threeChannels2_1_chosen 4
#   define threeChannels3_0_chosen 5
#   define fourChannels2_0_2_0_chosen 6
#   define fourChannels2_2_chosen 7
#   define fourChannels3_1_chosen 8
#   define fiveChannels3_0_2_0_chosen 9
#   define fiveChannels3_2_chosen 10
} IS13818AudioMode_multichannelType;

typedef struct IS13818AudioMode_audioSampling {
    ASN1choice_t choice;
#   define audioSampling16k_chosen 1
#   define audioSampling22k05_chosen 2
#   define audioSampling24k_chosen 3
#   define IS13818AudioMode_audioSampling_audioSampling32k_chosen 4
#   define IS13818AudioMode_audioSampling_audioSampling44k1_chosen 5
#   define IS13818AudioMode_audioSampling_audioSampling48k_chosen 6
} IS13818AudioMode_audioSampling;

typedef struct IS13818AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS13818AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS13818AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS13818AudioMode_audioLayer_audioLayer3_chosen 3
} IS13818AudioMode_audioLayer;

typedef struct IS11172AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS11172AudioMode_multichannelType_singleChannel_chosen 1
#   define IS11172AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS11172AudioMode_multichannelType_twoChannelDual_chosen 3
} IS11172AudioMode_multichannelType;

typedef struct IS11172AudioMode_audioSampling {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioSampling_audioSampling32k_chosen 1
#   define IS11172AudioMode_audioSampling_audioSampling44k1_chosen 2
#   define IS11172AudioMode_audioSampling_audioSampling48k_chosen 3
} IS11172AudioMode_audioSampling;

typedef struct IS11172AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS11172AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS11172AudioMode_audioLayer_audioLayer3_chosen 3
} IS11172AudioMode_audioLayer;

typedef struct AudioMode_g7231 {
    ASN1choice_t choice;
#   define noSilenceSuppressionLowRate_chosen 1
#   define noSilenceSuppressionHighRate_chosen 2
#   define silenceSuppressionLowRate_chosen 3
#   define silenceSuppressionHighRate_chosen 4
} AudioMode_g7231;

typedef struct H263VideoMode_resolution {
    ASN1choice_t choice;
#   define sqcif_chosen 1
#   define H263VideoMode_resolution_qcif_chosen 2
#   define H263VideoMode_resolution_cif_chosen 3
#   define cif4_chosen 4
#   define cif16_chosen 5
} H263VideoMode_resolution;

typedef struct H262VideoMode_profileAndLevel {
    ASN1choice_t choice;
#   define profileAndLevel_SPatML_chosen 1
#   define profileAndLevel_MPatLL_chosen 2
#   define profileAndLevel_MPatML_chosen 3
#   define profileAndLevel_MPatH_14_chosen 4
#   define profileAndLevel_MPatHL_chosen 5
#   define profileAndLevel_SNRatLL_chosen 6
#   define profileAndLevel_SNRatML_chosen 7
#   define profileAndLevel_SpatialatH_14_chosen 8
#   define profileAndLevel_HPatML_chosen 9
#   define profileAndLevel_HPatH_14_chosen 10
#   define profileAndLevel_HPatHL_chosen 11
} H262VideoMode_profileAndLevel;

typedef struct H261VideoMode_resolution {
    ASN1choice_t choice;
#   define H261VideoMode_resolution_qcif_chosen 1
#   define H261VideoMode_resolution_cif_chosen 2
} H261VideoMode_resolution;

typedef struct RequestModeReject_cause {
    ASN1choice_t choice;
#   define modeUnavailable_chosen 1
#   define multipointConstraint_chosen 2
#   define requestDenied_chosen 3
} RequestModeReject_cause;

typedef struct RequestModeAck_response {
    ASN1choice_t choice;
#   define willTransmitMostPreferredMode_chosen 1
#   define willTransmitLessPreferredMode_chosen 2
} RequestModeAck_response;

typedef struct RequestMultiplexEntryRelease_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryRelease_entryNumbers;

typedef struct RequestMultiplexEntryRejectionDescriptions_cause {
    ASN1choice_t choice;
#   define RequestMultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen 1
} RequestMultiplexEntryRejectionDescriptions_cause;

typedef struct RequestMultiplexEntryReject_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryReject_entryNumbers;

typedef struct RequestMultiplexEntryAck_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryAck_entryNumbers;

typedef struct RequestMultiplexEntry_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntry_entryNumbers;

typedef struct MultiplexEntrySendRelease_multiplexTableEntryNumber {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} MultiplexEntrySendRelease_multiplexTableEntryNumber;

typedef struct MultiplexEntryRejectionDescriptions_cause {
    ASN1choice_t choice;
#   define MultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen 1
#   define descriptorTooComplex_chosen 2
} MultiplexEntryRejectionDescriptions_cause;

typedef struct MultiplexEntrySendAck_multiplexTableEntryNumber {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} MultiplexEntrySendAck_multiplexTableEntryNumber;

typedef struct MultiplexElement_repeatCount {
    ASN1choice_t choice;
    union {
#	define MultiplexElement_repeatCount_finite_chosen 1
	ASN1uint16_t finite;
#	define untilClosingFlag_chosen 2
    } u;
} MultiplexElement_repeatCount;

typedef struct MultiplexElement_type {
    ASN1choice_t choice;
    union {
#	define MultiplexElement_type_logicalChannelNumber_chosen 1
	ASN1uint16_t logicalChannelNumber;
#	define subElementList_chosen 2
	PMultiplexElement_type_subElementList subElementList;
    } u;
} MultiplexElement_type;

typedef struct RequestChannelCloseReject_cause {
    ASN1choice_t choice;
#   define RequestChannelCloseReject_cause_unspecified_chosen 1
} RequestChannelCloseReject_cause;

typedef struct RequestChannelClose_reason {
    ASN1choice_t choice;
#   define RequestChannelClose_reason_unknown_chosen 1
#   define normal_chosen 2
#   define RequestChannelClose_reason_reopen_chosen 3
#   define RequestChannelClose_reason_reservationFailure_chosen 4
} RequestChannelClose_reason;

typedef struct CloseLogicalChannel_reason {
    ASN1choice_t choice;
#   define CloseLogicalChannel_reason_unknown_chosen 1
#   define CloseLogicalChannel_reason_reopen_chosen 2
#   define CloseLogicalChannel_reason_reservationFailure_chosen 3
} CloseLogicalChannel_reason;

typedef struct CloseLogicalChannel_source {
    ASN1choice_t choice;
#   define user_chosen 1
#   define lcse_chosen 2
} CloseLogicalChannel_source;

typedef struct OpenLogicalChannelReject_cause {
    ASN1choice_t choice;
#   define OpenLogicalChannelReject_cause_unspecified_chosen 1
#   define unsuitableReverseParameters_chosen 2
#   define dataTypeNotSupported_chosen 3
#   define dataTypeNotAvailable_chosen 4
#   define unknownDataType_chosen 5
#   define dataTypeALCombinationNotSupported_chosen 6
#   define multicastChannelNotAllowed_chosen 7
#   define insufficientBandwidth_chosen 8
#   define separateStackEstablishmentFailed_chosen 9
#   define invalidSessionID_chosen 10
#   define masterSlaveConflict_chosen 11
#   define waitForCommunicationMode_chosen 12
#   define invalidDependentChannel_chosen 13
#   define replacementForRejected_chosen 14
} OpenLogicalChannelReject_cause;

typedef struct MulticastAddress_iP6Address {
    struct MulticastAddress_iP6Address_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } network;
    ASN1uint16_t tsapIdentifier;
} MulticastAddress_iP6Address;

typedef struct MulticastAddress_iPAddress {
    struct MulticastAddress_iPAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
} MulticastAddress_iPAddress;

typedef struct UnicastAddress_iPSourceRouteAddress {
    UnicastAddress_iPSourceRouteAddress_routing routing;
    struct UnicastAddress_iPSourceRouteAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
    PUnicastAddress_iPSourceRouteAddress_route route;
} UnicastAddress_iPSourceRouteAddress;

typedef struct UnicastAddress_iP6Address {
    struct UnicastAddress_iP6Address_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } network;
    ASN1uint16_t tsapIdentifier;
} UnicastAddress_iP6Address;

typedef struct UnicastAddress_iPXAddress {
    struct UnicastAddress_iPXAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct UnicastAddress_iPXAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct UnicastAddress_iPXAddress_tsapIdentifier_tsapIdentifier {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } tsapIdentifier;
} UnicastAddress_iPXAddress;

typedef struct UnicastAddress_iPAddress {
    struct UnicastAddress_iPAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
} UnicastAddress_iPAddress;

typedef struct V76LogicalChannelParameters_mode {
    ASN1choice_t choice;
    union {
#	define eRM_chosen 1
	V76LogicalChannelParameters_mode_eRM eRM;
#	define uNERM_chosen 2
    } u;
} V76LogicalChannelParameters_mode;

typedef struct V76LogicalChannelParameters_suspendResume {
    ASN1choice_t choice;
#   define noSuspendResume_chosen 1
#   define V76LogicalChannelParameters_suspendResume_suspendResumewAddress_chosen 2
#   define V76LogicalChannelParameters_suspendResume_suspendResumewoAddress_chosen 3
} V76LogicalChannelParameters_suspendResume;

typedef struct H223AnnexCArqParameters_numberOfRetransmissions {
    ASN1choice_t choice;
    union {
#	define H223AnnexCArqParameters_numberOfRetransmissions_finite_chosen 1
	ASN1uint16_t finite;
#	define infinite_chosen 2
    } u;
} H223AnnexCArqParameters_numberOfRetransmissions;

typedef struct H223AL3MParameters_crcLength {
    ASN1choice_t choice;
#   define H223AL3MParameters_crcLength_crc4bit_chosen 1
#   define H223AL3MParameters_crcLength_crc12bit_chosen 2
#   define H223AL3MParameters_crcLength_crc20bit_chosen 3
#   define H223AL3MParameters_crcLength_crc28bit_chosen 4
} H223AL3MParameters_crcLength;

typedef struct H223AL3MParameters_headerFormat {
    ASN1choice_t choice;
#   define H223AL3MParameters_headerFormat_sebch16_7_chosen 1
#   define H223AL3MParameters_headerFormat_golay24_12_chosen 2
} H223AL3MParameters_headerFormat;

typedef struct H223AL2MParameters_headerFEC {
    ASN1choice_t choice;
#   define sebch16_5_chosen 1
#   define H223AL2MParameters_headerFEC_golay24_12_chosen 2
} H223AL2MParameters_headerFEC;

typedef struct H223AL1MParameters_crcLength {
    ASN1choice_t choice;
#   define H223AL1MParameters_crcLength_crc4bit_chosen 1
#   define H223AL1MParameters_crcLength_crc12bit_chosen 2
#   define H223AL1MParameters_crcLength_crc20bit_chosen 3
#   define H223AL1MParameters_crcLength_crc28bit_chosen 4
} H223AL1MParameters_crcLength;

typedef struct H223AL1MParameters_headerFEC {
    ASN1choice_t choice;
#   define H223AL1MParameters_headerFEC_sebch16_7_chosen 1
#   define H223AL1MParameters_headerFEC_golay24_12_chosen 2
} H223AL1MParameters_headerFEC;

typedef struct H223AL1MParameters_transferMode {
    ASN1choice_t choice;
#   define framed_chosen 1
#   define unframed_chosen 2
} H223AL1MParameters_transferMode;

typedef struct Q2931Address_address {
    ASN1choice_t choice;
    union {
#	define internationalNumber_chosen 1
	ASN1char_t internationalNumber[17];
#	define nsapAddress_chosen 2
	struct Q2931Address_address_nsapAddress_nsapAddress {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsapAddress;
    } u;
} Q2931Address_address;

typedef struct NetworkAccessParameters_t120SetupProcedure {
    ASN1choice_t choice;
#   define originateCall_chosen 1
#   define waitForCall_chosen 2
#   define issueQuery_chosen 3
} NetworkAccessParameters_t120SetupProcedure;

typedef struct NetworkAccessParameters_distribution {
    ASN1choice_t choice;
#   define unicast_chosen 1
#   define multicast_chosen 2
} NetworkAccessParameters_distribution;

typedef struct T84Profile_t84Restricted {
    ASN1bool_t qcif;
    ASN1bool_t cif;
    ASN1bool_t ccir601Seq;
    ASN1bool_t ccir601Prog;
    ASN1bool_t hdtvSeq;
    ASN1bool_t hdtvProg;
    ASN1bool_t g3FacsMH200x100;
    ASN1bool_t g3FacsMH200x200;
    ASN1bool_t g4FacsMMR200x100;
    ASN1bool_t g4FacsMMR200x200;
    ASN1bool_t jbig200x200Seq;
    ASN1bool_t jbig200x200Prog;
    ASN1bool_t jbig300x300Seq;
    ASN1bool_t jbig300x300Prog;
    ASN1bool_t digPhotoLow;
    ASN1bool_t digPhotoMedSeq;
    ASN1bool_t digPhotoMedProg;
    ASN1bool_t digPhotoHighSeq;
    ASN1bool_t digPhotoHighProg;
} T84Profile_t84Restricted;

typedef struct G7231AnnexCCapability_g723AnnexCAudioMode {
    ASN1uint16_t highRateMode0;
    ASN1uint16_t highRateMode1;
    ASN1uint16_t lowRateMode0;
    ASN1uint16_t lowRateMode1;
    ASN1uint16_t sidMode0;
    ASN1uint16_t sidMode1;
} G7231AnnexCCapability_g723AnnexCAudioMode;

typedef struct AudioCapability_g7231 {
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
} AudioCapability_g7231;

typedef struct CustomPictureFormat_pixelAspectInformation {
    ASN1choice_t choice;
    union {
#	define anyPixelAspectRatio_chosen 1
	ASN1bool_t anyPixelAspectRatio;
#	define pixelAspectCode_chosen 2
	CustomPictureFormat_pixelAspectInformation_pixelAspectCode pixelAspectCode;
#	define extendedPAR_chosen 3
	CustomPictureFormat_pixelAspectInformation_extendedPAR extendedPAR;
    } u;
} CustomPictureFormat_pixelAspectInformation;

typedef struct CustomPictureFormat_mPI {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define standardMPI_present 0x80
    ASN1uint16_t standardMPI;
#   define customPCF_present 0x40
    CustomPictureFormat_mPI_customPCF customPCF;
} CustomPictureFormat_mPI;

typedef struct RefPictureSelection_videoBackChannelSend {
    ASN1choice_t choice;
#   define RefPictureSelection_videoBackChannelSend_none_chosen 1
#   define ackMessageOnly_chosen 2
#   define nackMessageOnly_chosen 3
#   define ackOrNackMessageOnly_chosen 4
#   define ackAndNackMessage_chosen 5
} RefPictureSelection_videoBackChannelSend;

typedef struct RefPictureSelection_additionalPictureMemory {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define sqcifAdditionalPictureMemory_present 0x80
    ASN1uint16_t sqcifAdditionalPictureMemory;
#   define qcifAdditionalPictureMemory_present 0x40
    ASN1uint16_t qcifAdditionalPictureMemory;
#   define cifAdditionalPictureMemory_present 0x20
    ASN1uint16_t cifAdditionalPictureMemory;
#   define cif4AdditionalPictureMemory_present 0x10
    ASN1uint16_t cif4AdditionalPictureMemory;
#   define cif16AdditionalPictureMemory_present 0x8
    ASN1uint16_t cif16AdditionalPictureMemory;
#   define bigCpfAdditionalPictureMemory_present 0x4
    ASN1uint16_t bigCpfAdditionalPictureMemory;
} RefPictureSelection_additionalPictureMemory;

typedef struct RTPH263VideoRedundancyFrameMapping_frameSequence {
    ASN1uint32_t count;
    RTPH263VideoRedundancyFrameMapping_frameSequence_Seq value[256];
} RTPH263VideoRedundancyFrameMapping_frameSequence;

typedef struct RTPH263VideoRedundancyEncoding_containedThreads {
    ASN1uint32_t count;
    RTPH263VideoRedundancyEncoding_containedThreads_Seq value[256];
} RTPH263VideoRedundancyEncoding_containedThreads;

typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping {
    ASN1choice_t choice;
    union {
#	define roundrobin_chosen 1
#	define custom_chosen 2
	PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom custom;
    } u;
} RTPH263VideoRedundancyEncoding_frameToThreadMapping;

typedef struct RedundancyEncodingCapability_secondaryEncoding {
    PRedundancyEncodingCapability_secondaryEncoding next;
    CapabilityTableEntryNumber value;
} RedundancyEncodingCapability_secondaryEncoding_Element;

typedef struct H2250Capability_mcCapability {
    ASN1bool_t centralizedConferenceMC;
    ASN1bool_t decentralizedConferenceMC;
} H2250Capability_mcCapability;

typedef struct H223Capability_mobileOperationTransmitCapability {
    ASN1bool_t modeChangeCapability;
    ASN1bool_t h223AnnexA;
    ASN1bool_t h223AnnexADoubleFlag;
    ASN1bool_t h223AnnexB;
    ASN1bool_t h223AnnexBwithHeader;
} H223Capability_mobileOperationTransmitCapability;

typedef struct H223Capability_h223MultiplexTableCapability {
    ASN1choice_t choice;
    union {
#	define basic_chosen 1
#	define enhanced_chosen 2
	H223Capability_h223MultiplexTableCapability_enhanced enhanced;
    } u;
} H223Capability_h223MultiplexTableCapability;

typedef struct VCCapability_availableBitRates {
    VCCapability_availableBitRates_type type;
} VCCapability_availableBitRates;

typedef struct VCCapability_aal5 {
    ASN1uint16_t forwardMaximumSDUSize;
    ASN1uint16_t backwardMaximumSDUSize;
} VCCapability_aal5;

typedef struct VCCapability_aal1 {
    ASN1bool_t nullClockRecovery;
    ASN1bool_t srtsClockRecovery;
    ASN1bool_t adaptiveClockRecovery;
    ASN1bool_t nullErrorCorrection;
    ASN1bool_t longInterleaver;
    ASN1bool_t shortInterleaver;
    ASN1bool_t errorCorrectionOnly;
    ASN1bool_t structuredDataTransfer;
    ASN1bool_t partiallyFilledCells;
} VCCapability_aal1;

typedef struct Capability_h233EncryptionReceiveCapability {
    ASN1uint16_t h233IVResponseTime;
} Capability_h233EncryptionReceiveCapability;

typedef struct TerminalCapabilitySetReject_cause {
    ASN1choice_t choice;
    union {
#	define TerminalCapabilitySetReject_cause_unspecified_chosen 1
#	define undefinedTableEntryUsed_chosen 2
#	define descriptorCapacityExceeded_chosen 3
#	define tableEntryCapacityExceeded_chosen 4
	TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded tableEntryCapacityExceeded;
    } u;
} TerminalCapabilitySetReject_cause;

typedef struct MasterSlaveDeterminationReject_cause {
    ASN1choice_t choice;
#   define identicalNumbers_chosen 1
} MasterSlaveDeterminationReject_cause;

typedef struct MasterSlaveDeterminationAck_decision {
    ASN1choice_t choice;
#   define master_chosen 1
#   define slave_chosen 2
} MasterSlaveDeterminationAck_decision;

typedef struct NonStandardIdentifier_h221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} NonStandardIdentifier_h221NonStandard;

typedef struct NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221NonStandard_chosen 2
	NonStandardIdentifier_h221NonStandard h221NonStandard;
    } u;
} NonStandardIdentifier;

typedef struct MasterSlaveDetermination {
    ASN1uint16_t terminalType;
    ASN1uint32_t statusDeterminationNumber;
} MasterSlaveDetermination;

typedef struct MasterSlaveDeterminationAck {
    MasterSlaveDeterminationAck_decision decision;
} MasterSlaveDeterminationAck;

typedef struct MasterSlaveDeterminationReject {
    MasterSlaveDeterminationReject_cause cause;
} MasterSlaveDeterminationReject;

typedef struct MasterSlaveDeterminationRelease {
    char placeholder;
} MasterSlaveDeterminationRelease;

typedef struct CapabilityDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityDescriptorNumber capabilityDescriptorNumber;
#   define simultaneousCapabilities_present 0x80
    PCapabilityDescriptor_simultaneousCapabilities simultaneousCapabilities;
} CapabilityDescriptor;

typedef struct AlternativeCapabilitySet {
    ASN1uint32_t count;
    CapabilityTableEntryNumber value[256];
} AlternativeCapabilitySet;

typedef struct TerminalCapabilitySetAck {
    SequenceNumber sequenceNumber;
} TerminalCapabilitySetAck;

typedef struct TerminalCapabilitySetReject {
    SequenceNumber sequenceNumber;
    TerminalCapabilitySetReject_cause cause;
} TerminalCapabilitySetReject;

typedef struct TerminalCapabilitySetRelease {
    char placeholder;
} TerminalCapabilitySetRelease;

typedef struct H222Capability {
    ASN1uint16_t numberOfVCs;
    PH222Capability_vcCapability vcCapability;
} H222Capability;

typedef struct VCCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define aal1_present 0x80
    VCCapability_aal1 aal1;
#   define aal5_present 0x40
    VCCapability_aal5 aal5;
    ASN1bool_t transportStream;
    ASN1bool_t programStream;
    VCCapability_availableBitRates availableBitRates;
} VCCapability;

typedef struct H223AnnexCCapability {
    ASN1bool_t videoWithAL1M;
    ASN1bool_t videoWithAL2M;
    ASN1bool_t videoWithAL3M;
    ASN1bool_t audioWithAL1M;
    ASN1bool_t audioWithAL2M;
    ASN1bool_t audioWithAL3M;
    ASN1bool_t dataWithAL1M;
    ASN1bool_t dataWithAL2M;
    ASN1bool_t dataWithAL3M;
    ASN1bool_t alpduInterleaving;
    ASN1uint16_t maximumAL1MPDUSize;
    ASN1uint16_t maximumAL2MSDUSize;
    ASN1uint16_t maximumAL3MSDUSize;
} H223AnnexCCapability;

typedef struct V75Capability {
    ASN1bool_t audioHeader;
} V75Capability;

typedef struct QOSMode {
    ASN1choice_t choice;
#   define guaranteedQOS_chosen 1
#   define controlledLoad_chosen 2
} QOSMode;

typedef struct ATMParameters {
    ASN1uint16_t maxNTUSize;
    ASN1bool_t atmUBR;
    ASN1bool_t atmrtVBR;
    ASN1bool_t atmnrtVBR;
    ASN1bool_t atmABR;
    ASN1bool_t atmCBR;
} ATMParameters;

typedef struct MediaTransportType {
    ASN1choice_t choice;
#   define ip_UDP_chosen 1
#   define ip_TCP_chosen 2
#   define atm_AAL5_UNIDIR_chosen 3
#   define atm_AAL5_BIDIR_chosen 4
} MediaTransportType;

typedef struct MediaChannelCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define mediaTransport_present 0x80
    MediaTransportType mediaTransport;
} MediaChannelCapability;

typedef struct RTPH263VideoRedundancyEncoding {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t numberOfThreads;
    ASN1uint16_t framesBetweenSyncPoints;
    RTPH263VideoRedundancyEncoding_frameToThreadMapping frameToThreadMapping;
#   define containedThreads_present 0x80
    RTPH263VideoRedundancyEncoding_containedThreads containedThreads;
} RTPH263VideoRedundancyEncoding;

typedef struct RTPH263VideoRedundancyFrameMapping {
    ASN1uint16_t threadNumber;
    RTPH263VideoRedundancyFrameMapping_frameSequence frameSequence;
} RTPH263VideoRedundancyFrameMapping;

typedef struct MultipointCapability {
    ASN1bool_t multicastCapability;
    ASN1bool_t multiUniCastConference;
    PMultipointCapability_mediaDistributionCapability mediaDistributionCapability;
} MultipointCapability;

typedef struct MediaDistributionCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t centralizedControl;
    ASN1bool_t distributedControl;
    ASN1bool_t centralizedAudio;
    ASN1bool_t distributedAudio;
    ASN1bool_t centralizedVideo;
    ASN1bool_t distributedVideo;
#   define centralizedData_present 0x80
    PMediaDistributionCapability_centralizedData centralizedData;
#   define distributedData_present 0x40
    PMediaDistributionCapability_distributedData distributedData;
} MediaDistributionCapability;

typedef struct H261VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H261VideoCapability_qcifMPI_present 0x80
    ASN1uint16_t qcifMPI;
#   define H261VideoCapability_cifMPI_present 0x40
    ASN1uint16_t cifMPI;
    ASN1bool_t temporalSpatialTradeOffCapability;
    ASN1uint16_t maxBitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoCapability;

typedef struct H262VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t profileAndLevel_SPatML;
    ASN1bool_t profileAndLevel_MPatLL;
    ASN1bool_t profileAndLevel_MPatML;
    ASN1bool_t profileAndLevel_MPatH_14;
    ASN1bool_t profileAndLevel_MPatHL;
    ASN1bool_t profileAndLevel_SNRatLL;
    ASN1bool_t profileAndLevel_SNRatML;
    ASN1bool_t profileAndLevel_SpatialatH_14;
    ASN1bool_t profileAndLevel_HPatML;
    ASN1bool_t profileAndLevel_HPatH_14;
    ASN1bool_t profileAndLevel_HPatHL;
#   define H262VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoCapability_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoCapability;

typedef struct EnhancementLayerInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t baseBitRateConstrained;
#   define snrEnhancement_present 0x80
    PEnhancementLayerInfo_snrEnhancement snrEnhancement;
#   define spatialEnhancement_present 0x40
    PEnhancementLayerInfo_spatialEnhancement spatialEnhancement;
#   define bPictureEnhancement_present 0x20
    PEnhancementLayerInfo_bPictureEnhancement bPictureEnhancement;
} EnhancementLayerInfo;

typedef struct TransparencyParameters {
    ASN1uint16_t presentationOrder;
    ASN1int32_t offset_x;
    ASN1int32_t offset_y;
    ASN1uint16_t scale_x;
    ASN1uint16_t scale_y;
} TransparencyParameters;

typedef struct RefPictureSelection {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define additionalPictureMemory_present 0x80
    RefPictureSelection_additionalPictureMemory additionalPictureMemory;
    ASN1bool_t videoMux;
    RefPictureSelection_videoBackChannelSend videoBackChannelSend;
} RefPictureSelection;

typedef struct CustomPictureClockFrequency {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t clockConversionCode;
    ASN1uint16_t clockDivisor;
#   define CustomPictureClockFrequency_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define CustomPictureClockFrequency_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define CustomPictureClockFrequency_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define CustomPictureClockFrequency_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define CustomPictureClockFrequency_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
} CustomPictureClockFrequency;

typedef struct CustomPictureFormat {
    ASN1uint16_t maxCustomPictureWidth;
    ASN1uint16_t maxCustomPictureHeight;
    ASN1uint16_t minCustomPictureWidth;
    ASN1uint16_t minCustomPictureHeight;
    CustomPictureFormat_mPI mPI;
    CustomPictureFormat_pixelAspectInformation pixelAspectInformation;
} CustomPictureFormat;

typedef struct H263ModeComboFlags {
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
    ASN1bool_t advancedIntraCodingMode;
    ASN1bool_t deblockingFilterMode;
    ASN1bool_t unlimitedMotionVectors;
    ASN1bool_t slicesInOrder_NonRect;
    ASN1bool_t slicesInOrder_Rect;
    ASN1bool_t slicesNoOrder_NonRect;
    ASN1bool_t slicesNoOrder_Rect;
    ASN1bool_t improvedPBFramesMode;
    ASN1bool_t referencePicSelect;
    ASN1bool_t dynamicPictureResizingByFour;
    ASN1bool_t dynamicPictureResizingSixteenthPel;
    ASN1bool_t dynamicWarpingHalfPel;
    ASN1bool_t dynamicWarpingSixteenthPel;
    ASN1bool_t reducedResolutionUpdate;
    ASN1bool_t independentSegmentDecoding;
    ASN1bool_t alternateInterVLCMode;
    ASN1bool_t modifiedQuantizationMode;
} H263ModeComboFlags;

typedef struct IS11172VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoCapability_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoCapability;

typedef struct G7231AnnexCCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
#   define g723AnnexCAudioMode_present 0x80
    G7231AnnexCCapability_g723AnnexCAudioMode g723AnnexCAudioMode;
} G7231AnnexCCapability;

typedef struct IS11172AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1uint16_t bitRate;
} IS11172AudioCapability;

typedef struct IS13818AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling16k;
    ASN1bool_t audioSampling22k05;
    ASN1bool_t audioSampling24k;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1bool_t threeChannels2_1;
    ASN1bool_t threeChannels3_0;
    ASN1bool_t fourChannels2_0_2_0;
    ASN1bool_t fourChannels2_2;
    ASN1bool_t fourChannels3_1;
    ASN1bool_t fiveChannels3_0_2_0;
    ASN1bool_t fiveChannels3_2;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioCapability;

typedef struct GSMAudioCapability {
    ASN1uint16_t audioUnitSize;
    ASN1bool_t comfortNoise;
    ASN1bool_t scrambled;
} GSMAudioCapability;

typedef struct V42bis {
    ASN1uint32_t numberOfCodewords;
    ASN1uint16_t maximumStringLength;
} V42bis;

typedef struct T84Profile {
    ASN1choice_t choice;
    union {
#	define t84Unrestricted_chosen 1
#	define t84Restricted_chosen 2
	T84Profile_t84Restricted t84Restricted;
    } u;
} T84Profile;

typedef struct ConferenceCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define ConferenceCapability_nonStandardData_present 0x80
    PConferenceCapability_nonStandardData nonStandardData;
    ASN1bool_t chairControlCapability;
#   define videoIndicateMixingCapability_present 0x8000
    ASN1bool_t videoIndicateMixingCapability;
} ConferenceCapability;

typedef struct Q2931Address {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Q2931Address_address address;
#   define subaddress_present 0x80
    struct Q2931Address_subaddress_subaddress {
	ASN1uint32_t length;
	ASN1octet_t value[20];
    } subaddress;
} Q2931Address;

typedef struct V75Parameters {
    ASN1bool_t audioHeaderPresent;
} V75Parameters;

typedef struct H222LogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t resourceID;
    ASN1uint16_t subChannelID;
#   define pcr_pid_present 0x80
    ASN1uint16_t pcr_pid;
#   define programDescriptors_present 0x40
    ASN1octetstring_t programDescriptors;
#   define streamDescriptors_present 0x20
    ASN1octetstring_t streamDescriptors;
} H222LogicalChannelParameters;

typedef struct H223AL2MParameters {
    H223AL2MParameters_headerFEC headerFEC;
    ASN1bool_t alpduInterleaving;
} H223AL2MParameters;

typedef struct H223AnnexCArqParameters {
    H223AnnexCArqParameters_numberOfRetransmissions numberOfRetransmissions;
    ASN1uint32_t sendBufferSize;
} H223AnnexCArqParameters;

typedef struct CRCLength {
    ASN1choice_t choice;
#   define crc8bit_chosen 1
#   define crc16bit_chosen 2
#   define crc32bit_chosen 3
} CRCLength;

typedef struct EscrowData {
    ASN1objectidentifier_t escrowID;
    ASN1bitstring_t escrowValue;
} EscrowData;

typedef struct OpenLogicalChannelReject {
    LogicalChannelNumber forwardLogicalChannelNumber;
    OpenLogicalChannelReject_cause cause;
} OpenLogicalChannelReject;

typedef struct OpenLogicalChannelConfirm {
    LogicalChannelNumber forwardLogicalChannelNumber;
} OpenLogicalChannelConfirm;

typedef struct CloseLogicalChannel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
    CloseLogicalChannel_source source;
#   define CloseLogicalChannel_reason_present 0x80
    CloseLogicalChannel_reason reason;
} CloseLogicalChannel;

typedef struct CloseLogicalChannelAck {
    LogicalChannelNumber forwardLogicalChannelNumber;
} CloseLogicalChannelAck;

typedef struct RequestChannelCloseAck {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelCloseAck;

typedef struct RequestChannelCloseReject {
    LogicalChannelNumber forwardLogicalChannelNumber;
    RequestChannelCloseReject_cause cause;
} RequestChannelCloseReject;

typedef struct RequestChannelCloseRelease {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelCloseRelease;

typedef struct MultiplexEntrySend {
    SequenceNumber sequenceNumber;
    PMultiplexEntrySend_multiplexEntryDescriptors multiplexEntryDescriptors;
} MultiplexEntrySend;

typedef struct MultiplexElement {
    MultiplexElement_type type;
    MultiplexElement_repeatCount repeatCount;
} MultiplexElement;

typedef struct MultiplexEntrySendAck {
    SequenceNumber sequenceNumber;
    MultiplexEntrySendAck_multiplexTableEntryNumber multiplexTableEntryNumber;
} MultiplexEntrySendAck;

typedef struct MultiplexEntryRejectionDescriptions {
    MultiplexTableEntryNumber multiplexTableEntryNumber;
    MultiplexEntryRejectionDescriptions_cause cause;
} MultiplexEntryRejectionDescriptions;

typedef struct MultiplexEntrySendRelease {
    MultiplexEntrySendRelease_multiplexTableEntryNumber multiplexTableEntryNumber;
} MultiplexEntrySendRelease;

typedef struct RequestMultiplexEntry {
    RequestMultiplexEntry_entryNumbers entryNumbers;
} RequestMultiplexEntry;

typedef struct RequestMultiplexEntryAck {
    RequestMultiplexEntryAck_entryNumbers entryNumbers;
} RequestMultiplexEntryAck;

typedef struct RequestMultiplexEntryRejectionDescriptions {
    MultiplexTableEntryNumber multiplexTableEntryNumber;
    RequestMultiplexEntryRejectionDescriptions_cause cause;
} RequestMultiplexEntryRejectionDescriptions;

typedef struct RequestMultiplexEntryRelease {
    RequestMultiplexEntryRelease_entryNumbers entryNumbers;
} RequestMultiplexEntryRelease;

typedef struct RequestMode {
    SequenceNumber sequenceNumber;
    PRequestMode_requestedModes requestedModes;
} RequestMode;

typedef struct RequestModeAck {
    SequenceNumber sequenceNumber;
    RequestModeAck_response response;
} RequestModeAck;

typedef struct RequestModeReject {
    SequenceNumber sequenceNumber;
    RequestModeReject_cause cause;
} RequestModeReject;

typedef struct RequestModeRelease {
    char placeholder;
} RequestModeRelease;

typedef struct V76ModeParameters {
    ASN1choice_t choice;
#   define V76ModeParameters_suspendResumewAddress_chosen 1
#   define V76ModeParameters_suspendResumewoAddress_chosen 2
} V76ModeParameters;

typedef struct H261VideoMode {
    H261VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoMode;

typedef struct H262VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H262VideoMode_profileAndLevel profileAndLevel;
#   define H262VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoMode_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoMode;

typedef struct IS11172VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoMode_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoMode;

typedef struct IS11172AudioMode {
    IS11172AudioMode_audioLayer audioLayer;
    IS11172AudioMode_audioSampling audioSampling;
    IS11172AudioMode_multichannelType multichannelType;
    ASN1uint16_t bitRate;
} IS11172AudioMode;

typedef struct IS13818AudioMode {
    IS13818AudioMode_audioLayer audioLayer;
    IS13818AudioMode_audioSampling audioSampling;
    IS13818AudioMode_multichannelType multichannelType;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioMode;

typedef struct G7231AnnexCMode {
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
    G7231AnnexCMode_g723AnnexCAudioMode g723AnnexCAudioMode;
} G7231AnnexCMode;

typedef struct RoundTripDelayRequest {
    SequenceNumber sequenceNumber;
} RoundTripDelayRequest;

typedef struct RoundTripDelayResponse {
    SequenceNumber sequenceNumber;
} RoundTripDelayResponse;

typedef struct MaintenanceLoopRequest {
    MaintenanceLoopRequest_type type;
} MaintenanceLoopRequest;

typedef struct MaintenanceLoopAck {
    MaintenanceLoopAck_type type;
} MaintenanceLoopAck;

typedef struct MaintenanceLoopReject {
    MaintenanceLoopReject_type type;
    MaintenanceLoopReject_cause cause;
} MaintenanceLoopReject;

typedef struct MaintenanceLoopOffCommand {
    char placeholder;
} MaintenanceLoopOffCommand;

typedef struct CommunicationModeCommand {
    PCommunicationModeCommand_communicationModeTable communicationModeTable;
} CommunicationModeCommand;

typedef struct CommunicationModeRequest {
    char placeholder;
} CommunicationModeRequest;

typedef struct CommunicationModeResponse {
    ASN1choice_t choice;
    union {
#	define communicationModeTable_chosen 1
	PCommunicationModeResponse_communicationModeTable communicationModeTable;
    } u;
} CommunicationModeResponse;

typedef struct Criteria {
    ASN1objectidentifier_t field;
    struct Criteria_value_value {
	ASN1uint32_t length;
	ASN1octet_t value[65535];
    } value;
} Criteria;

typedef struct TerminalLabel {
    McuNumber mcuNumber;
    TerminalNumber terminalNumber;
} TerminalLabel;

typedef struct RequestAllTerminalIDsResponse {
    PRequestAllTerminalIDsResponse_terminalInformation terminalInformation;
} RequestAllTerminalIDsResponse;

typedef struct TerminalInformation {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} TerminalInformation;

typedef struct RemoteMCRequest {
    ASN1choice_t choice;
#   define masterActivate_chosen 1
#   define slaveActivate_chosen 2
#   define deActivate_chosen 3
} RemoteMCRequest;

typedef struct RemoteMCResponse {
    ASN1choice_t choice;
    union {
#	define accept_chosen 1
#	define reject_chosen 2
	RemoteMCResponse_reject reject;
    } u;
} RemoteMCResponse;

typedef struct SendTerminalCapabilitySet {
    ASN1choice_t choice;
    union {
#	define specificRequest_chosen 1
	SendTerminalCapabilitySet_specificRequest specificRequest;
#	define genericRequest_chosen 2
    } u;
} SendTerminalCapabilitySet;

typedef struct FlowControlCommand {
    FlowControlCommand_scope scope;
    FlowControlCommand_restriction restriction;
} FlowControlCommand;

typedef struct SubstituteConferenceIDCommand {
    struct SubstituteConferenceIDCommand_conferenceIdentifier_conferenceIdentifier {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } conferenceIdentifier;
} SubstituteConferenceIDCommand;

typedef struct KeyProtectionMethod {
    ASN1bool_t secureChannel;
    ASN1bool_t sharedSecret;
    ASN1bool_t certProtectedKey;
} KeyProtectionMethod;

typedef struct EncryptionUpdateRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define keyProtectionMethod_present 0x80
    KeyProtectionMethod keyProtectionMethod;
} EncryptionUpdateRequest;

typedef struct H223MultiplexReconfiguration {
    ASN1choice_t choice;
    union {
#	define h223ModeChange_chosen 1
	H223MultiplexReconfiguration_h223ModeChange h223ModeChange;
#	define h223AnnexADoubleFlag_chosen 2
	H223MultiplexReconfiguration_h223AnnexADoubleFlag h223AnnexADoubleFlag;
    } u;
} H223MultiplexReconfiguration;

typedef struct FunctionNotSupported {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    FunctionNotSupported_cause cause;
#   define returnedFunction_present 0x80
    ASN1octetstring_t returnedFunction;
} FunctionNotSupported;

typedef struct TerminalYouAreSeeingInSubPictureNumber {
    TerminalNumber terminalNumber;
    ASN1uint16_t subPictureNumber;
} TerminalYouAreSeeingInSubPictureNumber;

typedef struct VideoIndicateCompose {
    ASN1uint16_t compositionNumber;
} VideoIndicateCompose;

typedef struct ConferenceIndication {
    ASN1choice_t choice;
    union {
#	define sbeNumber_chosen 1
	ASN1uint16_t sbeNumber;
#	define terminalNumberAssign_chosen 2
	TerminalLabel terminalNumberAssign;
#	define terminalJoinedConference_chosen 3
	TerminalLabel terminalJoinedConference;
#	define terminalLeftConference_chosen 4
	TerminalLabel terminalLeftConference;
#	define seenByAtLeastOneOther_chosen 5
#	define cancelSeenByAtLeastOneOther_chosen 6
#	define seenByAll_chosen 7
#	define cancelSeenByAll_chosen 8
#	define terminalYouAreSeeing_chosen 9
	TerminalLabel terminalYouAreSeeing;
#	define requestForFloor_chosen 10
#	define withdrawChairToken_chosen 11
#	define floorRequested_chosen 12
	TerminalLabel floorRequested;
#	define terminalYouAreSeeingInSubPictureNumber_chosen 13
	TerminalYouAreSeeingInSubPictureNumber terminalYouAreSeeingInSubPictureNumber;
#	define videoIndicateCompose_chosen 14
	VideoIndicateCompose videoIndicateCompose;
    } u;
} ConferenceIndication;

typedef struct JitterIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    JitterIndication_scope scope;
    ASN1uint16_t estimatedReceivedJitterMantissa;
    ASN1uint16_t estimatedReceivedJitterExponent;
#   define skippedFrameCount_present 0x80
    ASN1uint16_t skippedFrameCount;
#   define additionalDecoderBuffer_present 0x40
    ASN1uint32_t additionalDecoderBuffer;
} JitterIndication;

typedef struct H223SkewIndication {
    LogicalChannelNumber logicalChannelNumber1;
    LogicalChannelNumber logicalChannelNumber2;
    ASN1uint16_t skew;
} H223SkewIndication;

typedef struct H2250MaximumSkewIndication {
    LogicalChannelNumber logicalChannelNumber1;
    LogicalChannelNumber logicalChannelNumber2;
    ASN1uint16_t maximumSkew;
} H2250MaximumSkewIndication;

typedef struct VendorIdentification {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    NonStandardIdentifier vendor;
#   define productNumber_present 0x80
    struct VendorIdentification_productNumber_productNumber {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } productNumber;
#   define versionNumber_present 0x40
    struct VendorIdentification_versionNumber_versionNumber {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } versionNumber;
} VendorIdentification;

typedef struct NewATMVCIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t resourceID;
    ASN1uint16_t bitRate;
    ASN1bool_t bitRateLockedToPCRClock;
    ASN1bool_t bitRateLockedToNetworkClock;
    NewATMVCIndication_aal aal;
    NewATMVCIndication_multiplex multiplex;
#   define reverseParameters_present 0x80
    NewATMVCIndication_reverseParameters reverseParameters;
} NewATMVCIndication;

typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom {
    PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom next;
    RTPH263VideoRedundancyFrameMapping value;
} RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_Element;

typedef struct MultiplexElement_type_subElementList {
    ASN1uint32_t count;
    MultiplexElement value[255];
} MultiplexElement_type_subElementList;

typedef struct RequestAllTerminalIDsResponse_terminalInformation {
    PRequestAllTerminalIDsResponse_terminalInformation next;
    TerminalInformation value;
} RequestAllTerminalIDsResponse_terminalInformation_Element;

typedef struct ConferenceResponse_terminalCertificateResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ConferenceResponse_terminalCertificateResponse_terminalLabel_present 0x80
    TerminalLabel terminalLabel;
#   define certificateResponse_present 0x40
    struct ConferenceResponse_terminalCertificateResponse_certificateResponse_certificateResponse {
	ASN1uint32_t length;
	ASN1octet_t value[65535];
    } certificateResponse;
} ConferenceResponse_terminalCertificateResponse;

typedef struct ConferenceResponse_chairTokenOwnerResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_chairTokenOwnerResponse;

typedef struct ConferenceResponse_terminalListResponse {
    ASN1uint32_t count;
    TerminalLabel value[256];
} ConferenceResponse_terminalListResponse;

typedef struct ConferenceResponse_passwordResponse {
    TerminalLabel terminalLabel;
    H245Password password;
} ConferenceResponse_passwordResponse;

typedef struct ConferenceResponse_conferenceIDResponse {
    TerminalLabel terminalLabel;
    ConferenceID conferenceID;
} ConferenceResponse_conferenceIDResponse;

typedef struct ConferenceResponse_terminalIDResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_terminalIDResponse;

typedef struct ConferenceResponse_mCTerminalIDResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_mCTerminalIDResponse;

typedef struct ConferenceRequest_requestTerminalCertificate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ConferenceRequest_requestTerminalCertificate_terminalLabel_present 0x80
    TerminalLabel terminalLabel;
#   define certSelectionCriteria_present 0x40
    PCertSelectionCriteria certSelectionCriteria;
#   define sRandom_present 0x20
    ASN1uint32_t sRandom;
} ConferenceRequest_requestTerminalCertificate;

typedef struct RequestMultiplexEntryReject_rejectionDescriptions {
    ASN1uint32_t count;
    RequestMultiplexEntryRejectionDescriptions value[15];
} RequestMultiplexEntryReject_rejectionDescriptions;

typedef struct MultiplexEntrySendReject_rejectionDescriptions {
    ASN1uint32_t count;
    MultiplexEntryRejectionDescriptions value[15];
} MultiplexEntrySendReject_rejectionDescriptions;

typedef struct MultiplexEntryDescriptor_elementList {
    ASN1uint32_t count;
    MultiplexElement value[256];
} MultiplexEntryDescriptor_elementList;

typedef struct EncryptionSync_escrowentry {
    PEncryptionSync_escrowentry next;
    EscrowData value;
} EncryptionSync_escrowentry_Element;

typedef struct H223AL3MParameters_arqType {
    ASN1choice_t choice;
    union {
#	define H223AL3MParameters_arqType_noArq_chosen 1
#	define H223AL3MParameters_arqType_typeIArq_chosen 2
	H223AnnexCArqParameters typeIArq;
#	define H223AL3MParameters_arqType_typeIIArq_chosen 3
	H223AnnexCArqParameters typeIIArq;
    } u;
} H223AL3MParameters_arqType;

typedef struct H223AL1MParameters_arqType {
    ASN1choice_t choice;
    union {
#	define H223AL1MParameters_arqType_noArq_chosen 1
#	define H223AL1MParameters_arqType_typeIArq_chosen 2
	H223AnnexCArqParameters typeIArq;
#	define H223AL1MParameters_arqType_typeIIArq_chosen 3
	H223AnnexCArqParameters typeIIArq;
    } u;
} H223AL1MParameters_arqType;

typedef struct H263VideoModeCombos_h263VideoCoupledModes {
    ASN1uint32_t count;
    H263ModeComboFlags value[16];
} H263VideoModeCombos_h263VideoCoupledModes;

typedef struct H263Options_customPictureFormat {
    PH263Options_customPictureFormat next;
    CustomPictureFormat value;
} H263Options_customPictureFormat_Element;

typedef struct H263Options_customPictureClockFrequency {
    PH263Options_customPictureClockFrequency next;
    CustomPictureClockFrequency value;
} H263Options_customPictureClockFrequency_Element;

typedef struct MultipointCapability_mediaDistributionCapability {
    PMultipointCapability_mediaDistributionCapability next;
    MediaDistributionCapability value;
} MultipointCapability_mediaDistributionCapability_Element;

typedef struct TransportCapability_mediaChannelCapabilities {
    ASN1uint32_t count;
    MediaChannelCapability value[256];
} TransportCapability_mediaChannelCapabilities;

typedef struct H222Capability_vcCapability {
    PH222Capability_vcCapability next;
    VCCapability value;
} H222Capability_vcCapability_Element;

typedef struct CapabilityDescriptor_simultaneousCapabilities {
    PCapabilityDescriptor_simultaneousCapabilities next;
    AlternativeCapabilitySet value;
} CapabilityDescriptor_simultaneousCapabilities_Element;

typedef struct TerminalCapabilitySet_capabilityDescriptors {
    ASN1uint32_t count;
    CapabilityDescriptor value[256];
} TerminalCapabilitySet_capabilityDescriptors;

typedef struct NonStandardParameter {
    NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} NonStandardParameter;

typedef struct H223Capability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t transportWithI_frames;
    ASN1bool_t videoWithAL1;
    ASN1bool_t videoWithAL2;
    ASN1bool_t videoWithAL3;
    ASN1bool_t audioWithAL1;
    ASN1bool_t audioWithAL2;
    ASN1bool_t audioWithAL3;
    ASN1bool_t dataWithAL1;
    ASN1bool_t dataWithAL2;
    ASN1bool_t dataWithAL3;
    ASN1uint16_t maximumAl2SDUSize;
    ASN1uint16_t maximumAl3SDUSize;
    ASN1uint16_t maximumDelayJitter;
    H223Capability_h223MultiplexTableCapability h223MultiplexTableCapability;
#   define maxMUXPDUSizeCapability_present 0x80
    ASN1bool_t maxMUXPDUSizeCapability;
#   define nsrpSupport_present 0x40
    ASN1bool_t nsrpSupport;
#   define mobileOperationTransmitCapability_present 0x20
    H223Capability_mobileOperationTransmitCapability mobileOperationTransmitCapability;
#   define h223AnnexCCapability_present 0x10
    H223AnnexCCapability h223AnnexCCapability;
} H223Capability;

typedef struct V76Capability {
    ASN1bool_t suspendResumeCapabilitywAddress;
    ASN1bool_t suspendResumeCapabilitywoAddress;
    ASN1bool_t rejCapability;
    ASN1bool_t sREJCapability;
    ASN1bool_t mREJCapability;
    ASN1bool_t crc8bitCapability;
    ASN1bool_t crc16bitCapability;
    ASN1bool_t crc32bitCapability;
    ASN1bool_t uihCapability;
    ASN1uint16_t numOfDLCS;
    ASN1bool_t twoOctetAddressFieldCapability;
    ASN1bool_t loopBackTestCapability;
    ASN1uint16_t n401Capability;
    ASN1uint16_t maxWindowSizeCapability;
    V75Capability v75Capability;
} V76Capability;

typedef struct RSVPParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define qosMode_present 0x80
    QOSMode qosMode;
#   define tokenRate_present 0x40
    ASN1uint32_t tokenRate;
#   define bucketSize_present 0x20
    ASN1uint32_t bucketSize;
#   define peakRate_present 0x10
    ASN1uint32_t peakRate;
#   define minPoliced_present 0x8
    ASN1uint32_t minPoliced;
#   define maxPktSize_present 0x4
    ASN1uint32_t maxPktSize;
} RSVPParameters;

typedef struct QOSCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define QOSCapability_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
#   define rsvpParameters_present 0x40
    RSVPParameters rsvpParameters;
#   define atmParameters_present 0x20
    ATMParameters atmParameters;
} QOSCapability;

typedef struct TransportCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define TransportCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
#   define qOSCapabilities_present 0x40
    PTransportCapability_qOSCapabilities qOSCapabilities;
#   define mediaChannelCapabilities_present 0x20
    TransportCapability_mediaChannelCapabilities mediaChannelCapabilities;
} TransportCapability;

typedef struct RedundancyEncodingMethod {
    ASN1choice_t choice;
    union {
#	define RedundancyEncodingMethod_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define rtpAudioRedundancyEncoding_chosen 2
#	define rtpH263VideoRedundancyEncoding_chosen 3
	RTPH263VideoRedundancyEncoding rtpH263VideoRedundancyEncoding;
    } u;
} RedundancyEncodingMethod;

typedef struct H263Options {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t advancedIntraCodingMode;
    ASN1bool_t deblockingFilterMode;
    ASN1bool_t improvedPBFramesMode;
    ASN1bool_t unlimitedMotionVectors;
    ASN1bool_t fullPictureFreeze;
    ASN1bool_t partialPictureFreezeAndRelease;
    ASN1bool_t resizingPartPicFreezeAndRelease;
    ASN1bool_t fullPictureSnapshot;
    ASN1bool_t partialPictureSnapshot;
    ASN1bool_t videoSegmentTagging;
    ASN1bool_t progressiveRefinement;
    ASN1bool_t dynamicPictureResizingByFour;
    ASN1bool_t dynamicPictureResizingSixteenthPel;
    ASN1bool_t dynamicWarpingHalfPel;
    ASN1bool_t dynamicWarpingSixteenthPel;
    ASN1bool_t independentSegmentDecoding;
    ASN1bool_t slicesInOrder_NonRect;
    ASN1bool_t slicesInOrder_Rect;
    ASN1bool_t slicesNoOrder_NonRect;
    ASN1bool_t slicesNoOrder_Rect;
    ASN1bool_t alternateInterVLCMode;
    ASN1bool_t modifiedQuantizationMode;
    ASN1bool_t reducedResolutionUpdate;
#   define transparencyParameters_present 0x80
    TransparencyParameters transparencyParameters;
    ASN1bool_t separateVideoBackChannel;
#   define refPictureSelection_present 0x40
    RefPictureSelection refPictureSelection;
#   define customPictureClockFrequency_present 0x20
    PH263Options_customPictureClockFrequency customPictureClockFrequency;
#   define customPictureFormat_present 0x10
    PH263Options_customPictureFormat customPictureFormat;
#   define modeCombos_present 0x8
    PH263Options_modeCombos modeCombos;
} H263Options;

typedef struct H263VideoModeCombos {
    H263ModeComboFlags h263VideoUncoupledModes;
    H263VideoModeCombos_h263VideoCoupledModes h263VideoCoupledModes;
} H263VideoModeCombos;

typedef struct AudioCapability {
    ASN1choice_t choice;
    union {
#	define AudioCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioCapability_g711Alaw64k_chosen 2
	ASN1uint16_t g711Alaw64k;
#	define AudioCapability_g711Alaw56k_chosen 3
	ASN1uint16_t g711Alaw56k;
#	define AudioCapability_g711Ulaw64k_chosen 4
	ASN1uint16_t g711Ulaw64k;
#	define AudioCapability_g711Ulaw56k_chosen 5
	ASN1uint16_t g711Ulaw56k;
#	define AudioCapability_g722_64k_chosen 6
	ASN1uint16_t g722_64k;
#	define AudioCapability_g722_56k_chosen 7
	ASN1uint16_t g722_56k;
#	define AudioCapability_g722_48k_chosen 8
	ASN1uint16_t g722_48k;
#	define AudioCapability_g7231_chosen 9
	AudioCapability_g7231 g7231;
#	define AudioCapability_g728_chosen 10
	ASN1uint16_t g728;
#	define AudioCapability_g729_chosen 11
	ASN1uint16_t g729;
#	define AudioCapability_g729AnnexA_chosen 12
	ASN1uint16_t g729AnnexA;
#	define is11172AudioCapability_chosen 13
	IS11172AudioCapability is11172AudioCapability;
#	define is13818AudioCapability_chosen 14
	IS13818AudioCapability is13818AudioCapability;
#	define AudioCapability_g729wAnnexB_chosen 15
	ASN1uint16_t g729wAnnexB;
#	define AudioCapability_g729AnnexAwAnnexB_chosen 16
	ASN1uint16_t g729AnnexAwAnnexB;
#	define g7231AnnexCCapability_chosen 17
	G7231AnnexCCapability g7231AnnexCCapability;
#	define AudioCapability_gsmFullRate_chosen 18
	GSMAudioCapability gsmFullRate;
#	define AudioCapability_gsmHalfRate_chosen 19
	GSMAudioCapability gsmHalfRate;
#	define AudioCapability_gsmEnhancedFullRate_chosen 20
	GSMAudioCapability gsmEnhancedFullRate;
    } u;
} AudioCapability;

typedef struct CompressionType {
    ASN1choice_t choice;
    union {
#	define v42bis_chosen 1
	V42bis v42bis;
    } u;
} CompressionType;

typedef struct MediaEncryptionAlgorithm {
    ASN1choice_t choice;
    union {
#	define MediaEncryptionAlgorithm_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define algorithm_chosen 2
	ASN1objectidentifier_t algorithm;
    } u;
} MediaEncryptionAlgorithm;

typedef struct AuthenticationCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define AuthenticationCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
} AuthenticationCapability;

typedef struct IntegrityCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define IntegrityCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
} IntegrityCapability;

typedef struct H223AL1MParameters {
    H223AL1MParameters_transferMode transferMode;
    H223AL1MParameters_headerFEC headerFEC;
    H223AL1MParameters_crcLength crcLength;
    ASN1uint16_t rcpcCodeRate;
    H223AL1MParameters_arqType arqType;
    ASN1bool_t alpduInterleaving;
    ASN1bool_t alsduSplitting;
} H223AL1MParameters;

typedef struct H223AL3MParameters {
    H223AL3MParameters_headerFormat headerFormat;
    H223AL3MParameters_crcLength crcLength;
    ASN1uint16_t rcpcCodeRate;
    H223AL3MParameters_arqType arqType;
    ASN1bool_t alpduInterleaving;
} H223AL3MParameters;

typedef struct V76HDLCParameters {
    CRCLength crcLength;
    ASN1uint16_t n401;
    ASN1bool_t loopbackTestProcedure;
} V76HDLCParameters;

typedef struct UnicastAddress {
    ASN1choice_t choice;
    union {
#	define UnicastAddress_iPAddress_chosen 1
	UnicastAddress_iPAddress iPAddress;
#	define iPXAddress_chosen 2
	UnicastAddress_iPXAddress iPXAddress;
#	define UnicastAddress_iP6Address_chosen 3
	UnicastAddress_iP6Address iP6Address;
#	define netBios_chosen 4
	struct UnicastAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define iPSourceRouteAddress_chosen 5
	UnicastAddress_iPSourceRouteAddress iPSourceRouteAddress;
#	define UnicastAddress_nsap_chosen 6
	struct UnicastAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define UnicastAddress_nonStandardAddress_chosen 7
	NonStandardParameter nonStandardAddress;
    } u;
} UnicastAddress;

typedef struct MulticastAddress {
    ASN1choice_t choice;
    union {
#	define MulticastAddress_iPAddress_chosen 1
	MulticastAddress_iPAddress iPAddress;
#	define MulticastAddress_iP6Address_chosen 2
	MulticastAddress_iP6Address iP6Address;
#	define MulticastAddress_nsap_chosen 3
	struct MulticastAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define MulticastAddress_nonStandardAddress_chosen 4
	NonStandardParameter nonStandardAddress;
    } u;
} MulticastAddress;

typedef struct EncryptionSync {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define EncryptionSync_nonStandard_present 0x80
    NonStandardParameter nonStandard;
    ASN1uint16_t synchFlag;
    struct EncryptionSync_h235Key_h235Key {
	ASN1uint32_t length;
	ASN1octet_t value[65535];
    } h235Key;
#   define escrowentry_present 0x40
    PEncryptionSync_escrowentry escrowentry;
} EncryptionSync;

typedef struct RequestChannelClose {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
#   define qosCapability_present 0x80
    QOSCapability qosCapability;
#   define RequestChannelClose_reason_present 0x40
    RequestChannelClose_reason reason;
} RequestChannelClose;

typedef struct MultiplexEntryDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    MultiplexTableEntryNumber multiplexTableEntryNumber;
#   define elementList_present 0x80
    MultiplexEntryDescriptor_elementList elementList;
} MultiplexEntryDescriptor;

typedef struct MultiplexEntrySendReject {
    SequenceNumber sequenceNumber;
    MultiplexEntrySendReject_rejectionDescriptions rejectionDescriptions;
} MultiplexEntrySendReject;

typedef struct RequestMultiplexEntryReject {
    RequestMultiplexEntryReject_entryNumbers entryNumbers;
    RequestMultiplexEntryReject_rejectionDescriptions rejectionDescriptions;
} RequestMultiplexEntryReject;

typedef struct H263VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H263VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
#   define H263VideoMode_errorCompensation_present 0x80
    ASN1bool_t errorCompensation;
#   define H263VideoMode_enhancementLayerInfo_present 0x40
    EnhancementLayerInfo enhancementLayerInfo;
#   define H263VideoMode_h263Options_present 0x20
    H263Options h263Options;
} H263VideoMode;

typedef struct AudioMode {
    ASN1choice_t choice;
    union {
#	define AudioMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioMode_g711Alaw64k_chosen 2
#	define AudioMode_g711Alaw56k_chosen 3
#	define AudioMode_g711Ulaw64k_chosen 4
#	define AudioMode_g711Ulaw56k_chosen 5
#	define AudioMode_g722_64k_chosen 6
#	define AudioMode_g722_56k_chosen 7
#	define AudioMode_g722_48k_chosen 8
#	define AudioMode_g728_chosen 9
#	define AudioMode_g729_chosen 10
#	define AudioMode_g729AnnexA_chosen 11
#	define AudioMode_g7231_chosen 12
	AudioMode_g7231 g7231;
#	define is11172AudioMode_chosen 13
	IS11172AudioMode is11172AudioMode;
#	define is13818AudioMode_chosen 14
	IS13818AudioMode is13818AudioMode;
#	define AudioMode_g729wAnnexB_chosen 15
	ASN1uint16_t g729wAnnexB;
#	define AudioMode_g729AnnexAwAnnexB_chosen 16
	ASN1uint16_t g729AnnexAwAnnexB;
#	define g7231AnnexCMode_chosen 17
	G7231AnnexCMode g7231AnnexCMode;
#	define AudioMode_gsmFullRate_chosen 18
	GSMAudioCapability gsmFullRate;
#	define AudioMode_gsmHalfRate_chosen 19
	GSMAudioCapability gsmHalfRate;
#	define AudioMode_gsmEnhancedFullRate_chosen 20
	GSMAudioCapability gsmEnhancedFullRate;
    } u;
} AudioMode;

typedef struct EncryptionMode {
    ASN1choice_t choice;
    union {
#	define EncryptionMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h233Encryption_chosen 2
    } u;
} EncryptionMode;

typedef struct ConferenceRequest {
    ASN1choice_t choice;
    union {
#	define terminalListRequest_chosen 1
#	define makeMeChair_chosen 2
#	define cancelMakeMeChair_chosen 3
#	define dropTerminal_chosen 4
	TerminalLabel dropTerminal;
#	define requestTerminalID_chosen 5
	TerminalLabel requestTerminalID;
#	define enterH243Password_chosen 6
#	define enterH243TerminalID_chosen 7
#	define enterH243ConferenceID_chosen 8
#	define enterExtensionAddress_chosen 9
#	define requestChairTokenOwner_chosen 10
#	define requestTerminalCertificate_chosen 11
	ConferenceRequest_requestTerminalCertificate requestTerminalCertificate;
#	define ConferenceRequest_broadcastMyLogicalChannel_chosen 12
	LogicalChannelNumber broadcastMyLogicalChannel;
#	define ConferenceRequest_makeTerminalBroadcaster_chosen 13
	TerminalLabel makeTerminalBroadcaster;
#	define ConferenceRequest_sendThisSource_chosen 14
	TerminalLabel sendThisSource;
#	define requestAllTerminalIDs_chosen 15
#	define remoteMCRequest_chosen 16
	RemoteMCRequest remoteMCRequest;
    } u;
} ConferenceRequest;

typedef struct CertSelectionCriteria {
    PCertSelectionCriteria next;
    Criteria value;
} CertSelectionCriteria_Element;

typedef struct ConferenceResponse {
    ASN1choice_t choice;
    union {
#	define mCTerminalIDResponse_chosen 1
	ConferenceResponse_mCTerminalIDResponse mCTerminalIDResponse;
#	define terminalIDResponse_chosen 2
	ConferenceResponse_terminalIDResponse terminalIDResponse;
#	define conferenceIDResponse_chosen 3
	ConferenceResponse_conferenceIDResponse conferenceIDResponse;
#	define passwordResponse_chosen 4
	ConferenceResponse_passwordResponse passwordResponse;
#	define terminalListResponse_chosen 5
	ConferenceResponse_terminalListResponse terminalListResponse;
#	define videoCommandReject_chosen 6
#	define terminalDropReject_chosen 7
#	define makeMeChairResponse_chosen 8
	ConferenceResponse_makeMeChairResponse makeMeChairResponse;
#	define extensionAddressResponse_chosen 9
	ConferenceResponse_extensionAddressResponse extensionAddressResponse;
#	define chairTokenOwnerResponse_chosen 10
	ConferenceResponse_chairTokenOwnerResponse chairTokenOwnerResponse;
#	define terminalCertificateResponse_chosen 11
	ConferenceResponse_terminalCertificateResponse terminalCertificateResponse;
#	define broadcastMyLogicalChannelResponse_chosen 12
	ConferenceResponse_broadcastMyLogicalChannelResponse broadcastMyLogicalChannelResponse;
#	define makeTerminalBroadcasterResponse_chosen 13
	ConferenceResponse_makeTerminalBroadcasterResponse makeTerminalBroadcasterResponse;
#	define sendThisSourceResponse_chosen 14
	ConferenceResponse_sendThisSourceResponse sendThisSourceResponse;
#	define requestAllTerminalIDsResponse_chosen 15
	RequestAllTerminalIDsResponse requestAllTerminalIDsResponse;
#	define remoteMCResponse_chosen 16
	RemoteMCResponse remoteMCResponse;
    } u;
} ConferenceResponse;

typedef struct EndSessionCommand {
    ASN1choice_t choice;
    union {
#	define EndSessionCommand_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define disconnect_chosen 2
#	define gstnOptions_chosen 3
	EndSessionCommand_gstnOptions gstnOptions;
#	define isdnOptions_chosen 4
	EndSessionCommand_isdnOptions isdnOptions;
    } u;
} EndSessionCommand;

typedef struct ConferenceCommand {
    ASN1choice_t choice;
    union {
#	define ConferenceCommand_broadcastMyLogicalChannel_chosen 1
	LogicalChannelNumber broadcastMyLogicalChannel;
#	define cancelBroadcastMyLogicalChannel_chosen 2
	LogicalChannelNumber cancelBroadcastMyLogicalChannel;
#	define ConferenceCommand_makeTerminalBroadcaster_chosen 3
	TerminalLabel makeTerminalBroadcaster;
#	define cancelMakeTerminalBroadcaster_chosen 4
#	define ConferenceCommand_sendThisSource_chosen 5
	TerminalLabel sendThisSource;
#	define cancelSendThisSource_chosen 6
#	define dropConference_chosen 7
#	define substituteConferenceIDCommand_chosen 8
	SubstituteConferenceIDCommand substituteConferenceIDCommand;
    } u;
} ConferenceCommand;

typedef struct UserInputIndication_userInputSupportIndication {
    ASN1choice_t choice;
    union {
#	define UserInputIndication_userInputSupportIndication_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define UserInputIndication_userInputSupportIndication_basicString_chosen 2
#	define UserInputIndication_userInputSupportIndication_iA5String_chosen 3
#	define UserInputIndication_userInputSupportIndication_generalString_chosen 4
    } u;
} UserInputIndication_userInputSupportIndication;

typedef struct MiscellaneousIndication_type {
    ASN1choice_t choice;
    union {
#	define logicalChannelActive_chosen 1
#	define logicalChannelInactive_chosen 2
#	define multipointConference_chosen 3
#	define cancelMultipointConference_chosen 4
#	define multipointZeroComm_chosen 5
#	define cancelMultipointZeroComm_chosen 6
#	define multipointSecondaryStatus_chosen 7
#	define cancelMultipointSecondaryStatus_chosen 8
#	define videoIndicateReadyToActivate_chosen 9
#	define MiscellaneousIndication_type_videoTemporalSpatialTradeOff_chosen 10
	ASN1uint16_t videoTemporalSpatialTradeOff;
#	define videoNotDecodedMBs_chosen 11
	MiscellaneousIndication_type_videoNotDecodedMBs videoNotDecodedMBs;
#	define transportCapability_chosen 12
	TransportCapability transportCapability;
    } u;
} MiscellaneousIndication_type;

typedef struct MiscellaneousCommand_type {
    ASN1choice_t choice;
    union {
#	define equaliseDelay_chosen 1
#	define zeroDelay_chosen 2
#	define multipointModeCommand_chosen 3
#	define cancelMultipointModeCommand_chosen 4
#	define videoFreezePicture_chosen 5
#	define videoFastUpdatePicture_chosen 6
#	define videoFastUpdateGOB_chosen 7
	MiscellaneousCommand_type_videoFastUpdateGOB videoFastUpdateGOB;
#	define MiscellaneousCommand_type_videoTemporalSpatialTradeOff_chosen 8
	ASN1uint16_t videoTemporalSpatialTradeOff;
#	define videoSendSyncEveryGOB_chosen 9
#	define videoSendSyncEveryGOBCancel_chosen 10
#	define videoFastUpdateMB_chosen 11
	MiscellaneousCommand_type_videoFastUpdateMB videoFastUpdateMB;
#	define maxH223MUXPDUsize_chosen 12
	ASN1uint16_t maxH223MUXPDUsize;
#	define encryptionUpdate_chosen 13
	EncryptionSync encryptionUpdate;
#	define encryptionUpdateRequest_chosen 14
	EncryptionUpdateRequest encryptionUpdateRequest;
#	define switchReceiveMediaOff_chosen 15
#	define switchReceiveMediaOn_chosen 16
#	define progressiveRefinementStart_chosen 17
	MiscellaneousCommand_type_progressiveRefinementStart progressiveRefinementStart;
#	define progressiveRefinementAbortOne_chosen 18
#	define progressiveRefinementAbortContinuous_chosen 19
    } u;
} MiscellaneousCommand_type;

typedef struct EncryptionCommand_encryptionAlgorithmID {
    SequenceNumber h233AlgorithmIdentifier;
    NonStandardParameter associatedAlgorithm;
} EncryptionCommand_encryptionAlgorithmID;

typedef struct CommunicationModeTableEntry_nonStandard {
    PCommunicationModeTableEntry_nonStandard next;
    NonStandardParameter value;
} CommunicationModeTableEntry_nonStandard_Element;

typedef struct RedundancyEncodingMode_secondaryEncoding {
    ASN1choice_t choice;
    union {
#	define RedundancyEncodingMode_secondaryEncoding_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define RedundancyEncodingMode_secondaryEncoding_audioData_chosen 2
	AudioMode audioData;
    } u;
} RedundancyEncodingMode_secondaryEncoding;

typedef struct H223ModeParameters_adaptationLayerType {
    ASN1choice_t choice;
    union {
#	define H223ModeParameters_adaptationLayerType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223ModeParameters_adaptationLayerType_al1Framed_chosen 2
#	define H223ModeParameters_adaptationLayerType_al1NotFramed_chosen 3
#	define H223ModeParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen 4
#	define H223ModeParameters_adaptationLayerType_al2WithSequenceNumbers_chosen 5
#	define H223ModeParameters_adaptationLayerType_al3_chosen 6
	H223ModeParameters_adaptationLayerType_al3 al3;
#	define H223ModeParameters_adaptationLayerType_al1M_chosen 7
	H223AL1MParameters al1M;
#	define H223ModeParameters_adaptationLayerType_al2M_chosen 8
	H223AL2MParameters al2M;
#	define H223ModeParameters_adaptationLayerType_al3M_chosen 9
	H223AL3MParameters al3M;
    } u;
} H223ModeParameters_adaptationLayerType;

typedef struct MultiplexEntrySend_multiplexEntryDescriptors {
    PMultiplexEntrySend_multiplexEntryDescriptors next;
    MultiplexEntryDescriptor value;
} MultiplexEntrySend_multiplexEntryDescriptors_Element;

typedef struct H2250LogicalChannelAckParameters_nonStandard {
    PH2250LogicalChannelAckParameters_nonStandard next;
    NonStandardParameter value;
} H2250LogicalChannelAckParameters_nonStandard_Element;

typedef struct RTPPayloadType_payloadDescriptor {
    ASN1choice_t choice;
    union {
#	define nonStandardIdentifier_chosen 1
	NonStandardParameter nonStandardIdentifier;
#	define rfc_number_chosen 2
	ASN1uint16_t rfc_number;
#	define oid_chosen 3
	ASN1objectidentifier_t oid;
    } u;
} RTPPayloadType_payloadDescriptor;

typedef struct H2250LogicalChannelParameters_nonStandard {
    PH2250LogicalChannelParameters_nonStandard next;
    NonStandardParameter value;
} H2250LogicalChannelParameters_nonStandard_Element;

typedef struct H223LogicalChannelParameters_adaptationLayerType {
    ASN1choice_t choice;
    union {
#	define H223LogicalChannelParameters_adaptationLayerType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223LogicalChannelParameters_adaptationLayerType_al1Framed_chosen 2
#	define H223LogicalChannelParameters_adaptationLayerType_al1NotFramed_chosen 3
#	define H223LogicalChannelParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen 4
#	define H223LogicalChannelParameters_adaptationLayerType_al2WithSequenceNumbers_chosen 5
#	define H223LogicalChannelParameters_adaptationLayerType_al3_chosen 6
	H223LogicalChannelParameters_adaptationLayerType_al3 al3;
#	define H223LogicalChannelParameters_adaptationLayerType_al1M_chosen 7
	H223AL1MParameters al1M;
#	define H223LogicalChannelParameters_adaptationLayerType_al2M_chosen 8
	H223AL2MParameters al2M;
#	define H223LogicalChannelParameters_adaptationLayerType_al3M_chosen 9
	H223AL3MParameters al3M;
    } u;
} H223LogicalChannelParameters_adaptationLayerType;

typedef struct ConferenceCapability_nonStandardData {
    PConferenceCapability_nonStandardData next;
    NonStandardParameter value;
} ConferenceCapability_nonStandardData_Element;

typedef struct UserInputCapability_nonStandard {
    ASN1uint32_t count;
    NonStandardParameter value[16];
} UserInputCapability_nonStandard;

typedef struct DataProtocolCapability_v76wCompression {
    ASN1choice_t choice;
    union {
#	define transmitCompression_chosen 1
	CompressionType transmitCompression;
#	define receiveCompression_chosen 2
	CompressionType receiveCompression;
#	define transmitAndReceiveCompression_chosen 3
	CompressionType transmitAndReceiveCompression;
    } u;
} DataProtocolCapability_v76wCompression;

typedef struct H263Options_modeCombos {
    PH263Options_modeCombos next;
    H263VideoModeCombos value;
} H263Options_modeCombos_Element;

typedef struct TransportCapability_qOSCapabilities {
    PTransportCapability_qOSCapabilities next;
    QOSCapability value;
} TransportCapability_qOSCapabilities_Element;

typedef struct NonStandardMessage {
    NonStandardParameter nonStandardData;
} NonStandardMessage;

typedef struct RedundancyEncodingCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RedundancyEncodingMethod redundancyEncodingMethod;
    CapabilityTableEntryNumber primaryEncoding;
#   define RedundancyEncodingCapability_secondaryEncoding_present 0x80
    PRedundancyEncodingCapability_secondaryEncoding secondaryEncoding;
} RedundancyEncodingCapability;

typedef struct H263VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H263VideoCapability_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define H263VideoCapability_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define H263VideoCapability_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define H263VideoCapability_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define H263VideoCapability_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
    ASN1uint32_t maxBitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
    ASN1bool_t temporalSpatialTradeOffCapability;
#   define hrd_B_present 0x4
    ASN1uint32_t hrd_B;
#   define bppMaxKb_present 0x2
    ASN1uint16_t bppMaxKb;
#   define H263VideoCapability_slowSqcifMPI_present 0x8000
    ASN1uint16_t slowSqcifMPI;
#   define H263VideoCapability_slowQcifMPI_present 0x4000
    ASN1uint16_t slowQcifMPI;
#   define H263VideoCapability_slowCifMPI_present 0x2000
    ASN1uint16_t slowCifMPI;
#   define H263VideoCapability_slowCif4MPI_present 0x1000
    ASN1uint16_t slowCif4MPI;
#   define H263VideoCapability_slowCif16MPI_present 0x800
    ASN1uint16_t slowCif16MPI;
#   define H263VideoCapability_errorCompensation_present 0x400
    ASN1bool_t errorCompensation;
#   define H263VideoCapability_enhancementLayerInfo_present 0x200
    EnhancementLayerInfo enhancementLayerInfo;
#   define H263VideoCapability_h263Options_present 0x100
    H263Options h263Options;
} H263VideoCapability;

typedef struct EnhancementOptions {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define EnhancementOptions_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define EnhancementOptions_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define EnhancementOptions_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define EnhancementOptions_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define EnhancementOptions_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
    ASN1uint32_t maxBitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t temporalSpatialTradeOffCapability;
#   define EnhancementOptions_slowSqcifMPI_present 0x4
    ASN1uint16_t slowSqcifMPI;
#   define EnhancementOptions_slowQcifMPI_present 0x2
    ASN1uint16_t slowQcifMPI;
#   define EnhancementOptions_slowCifMPI_present 0x1
    ASN1uint16_t slowCifMPI;
#   define EnhancementOptions_slowCif4MPI_present 0x8000
    ASN1uint16_t slowCif4MPI;
#   define EnhancementOptions_slowCif16MPI_present 0x4000
    ASN1uint16_t slowCif16MPI;
    ASN1bool_t errorCompensation;
#   define EnhancementOptions_h263Options_present 0x2000
    H263Options h263Options;
} EnhancementOptions;

typedef struct DataProtocolCapability {
    ASN1choice_t choice;
    union {
#	define DataProtocolCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define v14buffered_chosen 2
#	define v42lapm_chosen 3
#	define hdlcFrameTunnelling_chosen 4
#	define h310SeparateVCStack_chosen 5
#	define h310SingleVCStack_chosen 6
#	define transparent_chosen 7
#	define segmentationAndReassembly_chosen 8
#	define hdlcFrameTunnelingwSAR_chosen 9
#	define v120_chosen 10
#	define separateLANStack_chosen 11
#	define v76wCompression_chosen 12
	DataProtocolCapability_v76wCompression v76wCompression;
    } u;
} DataProtocolCapability;

typedef struct EncryptionAuthenticationAndIntegrity {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define encryptionCapability_present 0x80
    PEncryptionCapability encryptionCapability;
#   define authenticationCapability_present 0x40
    AuthenticationCapability authenticationCapability;
#   define integrityCapability_present 0x20
    IntegrityCapability integrityCapability;
} EncryptionAuthenticationAndIntegrity;

typedef struct EncryptionCapability {
    PEncryptionCapability next;
    MediaEncryptionAlgorithm value;
} EncryptionCapability_Element;

typedef struct UserInputCapability {
    ASN1choice_t choice;
    union {
#	define UserInputCapability_nonStandard_chosen 1
	UserInputCapability_nonStandard nonStandard;
#	define UserInputCapability_basicString_chosen 2
#	define UserInputCapability_iA5String_chosen 3
#	define UserInputCapability_generalString_chosen 4
#	define dtmf_chosen 5
#	define hookflash_chosen 6
    } u;
} UserInputCapability;

typedef struct H223LogicalChannelParameters {
    H223LogicalChannelParameters_adaptationLayerType adaptationLayerType;
    ASN1bool_t segmentableFlag;
} H223LogicalChannelParameters;

typedef struct V76LogicalChannelParameters {
    V76HDLCParameters hdlcParameters;
    V76LogicalChannelParameters_suspendResume suspendResume;
    ASN1bool_t uIH;
    V76LogicalChannelParameters_mode mode;
    V75Parameters v75Parameters;
} V76LogicalChannelParameters;

typedef struct RTPPayloadType {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RTPPayloadType_payloadDescriptor payloadDescriptor;
#   define payloadType_present 0x80
    ASN1uint16_t payloadType;
} RTPPayloadType;

typedef struct H245TransportAddress {
    ASN1choice_t choice;
    union {
#	define unicastAddress_chosen 1
	UnicastAddress unicastAddress;
#	define multicastAddress_chosen 2
	MulticastAddress multicastAddress;
    } u;
} H245TransportAddress;

typedef struct H2250LogicalChannelAckParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H2250LogicalChannelAckParameters_nonStandard_present 0x80
    PH2250LogicalChannelAckParameters_nonStandard nonStandard;
#   define sessionID_present 0x40
    ASN1uint16_t sessionID;
#   define H2250LogicalChannelAckParameters_mediaChannel_present 0x20
    H245TransportAddress mediaChannel;
#   define H2250LogicalChannelAckParameters_mediaControlChannel_present 0x10
    H245TransportAddress mediaControlChannel;
#   define H2250LogicalChannelAckParameters_dynamicRTPPayloadType_present 0x8
    ASN1uint16_t dynamicRTPPayloadType;
#   define flowControlToZero_present 0x8000
    ASN1bool_t flowControlToZero;
#   define H2250LogicalChannelAckParameters_portNumber_present 0x4000
    ASN1uint16_t portNumber;
} H2250LogicalChannelAckParameters;

typedef struct H223ModeParameters {
    H223ModeParameters_adaptationLayerType adaptationLayerType;
    ASN1bool_t segmentableFlag;
} H223ModeParameters;

typedef struct RedundancyEncodingMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RedundancyEncodingMethod redundancyEncodingMethod;
#   define RedundancyEncodingMode_secondaryEncoding_present 0x80
    RedundancyEncodingMode_secondaryEncoding secondaryEncoding;
} RedundancyEncodingMode;

typedef struct VideoMode {
    ASN1choice_t choice;
    union {
#	define VideoMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoMode_chosen 2
	H261VideoMode h261VideoMode;
#	define h262VideoMode_chosen 3
	H262VideoMode h262VideoMode;
#	define h263VideoMode_chosen 4
	H263VideoMode h263VideoMode;
#	define is11172VideoMode_chosen 5
	IS11172VideoMode is11172VideoMode;
    } u;
} VideoMode;

typedef struct EncryptionCommand {
    ASN1choice_t choice;
    union {
#	define encryptionSE_chosen 1
	ASN1octetstring_t encryptionSE;
#	define encryptionIVRequest_chosen 2
#	define encryptionAlgorithmID_chosen 3
	EncryptionCommand_encryptionAlgorithmID encryptionAlgorithmID;
    } u;
} EncryptionCommand;

typedef struct MiscellaneousCommand {
    LogicalChannelNumber logicalChannelNumber;
    MiscellaneousCommand_type type;
} MiscellaneousCommand;

typedef struct MiscellaneousIndication {
    LogicalChannelNumber logicalChannelNumber;
    MiscellaneousIndication_type type;
} MiscellaneousIndication;

typedef struct MCLocationIndication {
    H245TransportAddress signalAddress;
} MCLocationIndication;

typedef struct UserInputIndication {
    ASN1choice_t choice;
    union {
#	define UserInputIndication_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define alphanumeric_chosen 2
	ASN1ztcharstring_t alphanumeric;
#	define userInputSupportIndication_chosen 3
	UserInputIndication_userInputSupportIndication userInputSupportIndication;
#	define signal_chosen 4
	UserInputIndication_signal signal;
#	define signalUpdate_chosen 5
	UserInputIndication_signalUpdate signalUpdate;
    } u;
} UserInputIndication;

typedef struct DataApplicationCapability_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataApplicationCapability_application_nlpid;

typedef struct DataApplicationCapability_application_t84 {
    DataProtocolCapability t84Protocol;
    T84Profile t84Profile;
} DataApplicationCapability_application_t84;

typedef struct DataMode_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataMode_application_nlpid;

typedef struct DataMode_application {
    ASN1choice_t choice;
    union {
#	define DataMode_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataMode_application_t120_chosen 2
	DataProtocolCapability t120;
#	define DataMode_application_dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataMode_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataMode_application_t84_chosen 5
	DataProtocolCapability t84;
#	define DataMode_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataMode_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataMode_application_nlpid_chosen 8
	DataMode_application_nlpid nlpid;
#	define DataMode_application_dsvdControl_chosen 9
#	define DataMode_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
#	define DataMode_application_t30fax_chosen 11
	DataProtocolCapability t30fax;
#	define DataMode_application_t140_chosen 12
	DataProtocolCapability t140;
    } u;
} DataMode_application;

typedef struct OpenLogicalChannelAck_forwardMultiplexAckParameters {
    ASN1choice_t choice;
    union {
#	define h2250LogicalChannelAckParameters_chosen 1
	H2250LogicalChannelAckParameters h2250LogicalChannelAckParameters;
    } u;
} OpenLogicalChannelAck_forwardMultiplexAckParameters;

typedef struct H2250LogicalChannelParameters_mediaPacketization {
    ASN1choice_t choice;
    union {
#	define h261aVideoPacketization_chosen 1
#	define rtpPayloadType_chosen 2
	RTPPayloadType rtpPayloadType;
    } u;
} H2250LogicalChannelParameters_mediaPacketization;

typedef struct NetworkAccessParameters_networkAddress {
    ASN1choice_t choice;
    union {
#	define q2931Address_chosen 1
	Q2931Address q2931Address;
#	define e164Address_chosen 2
	ASN1char_t e164Address[129];
#	define localAreaAddress_chosen 3
	H245TransportAddress localAreaAddress;
    } u;
} NetworkAccessParameters_networkAddress;

typedef struct DataApplicationCapability_application {
    ASN1choice_t choice;
    union {
#	define DataApplicationCapability_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataApplicationCapability_application_t120_chosen 2
	DataProtocolCapability t120;
#	define DataApplicationCapability_application_dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataApplicationCapability_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataApplicationCapability_application_t84_chosen 5
	DataApplicationCapability_application_t84 t84;
#	define DataApplicationCapability_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataApplicationCapability_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataApplicationCapability_application_nlpid_chosen 8
	DataApplicationCapability_application_nlpid nlpid;
#	define DataApplicationCapability_application_dsvdControl_chosen 9
#	define DataApplicationCapability_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
#	define DataApplicationCapability_application_t30fax_chosen 11
	DataProtocolCapability t30fax;
#	define DataApplicationCapability_application_t140_chosen 12
	DataProtocolCapability t140;
    } u;
} DataApplicationCapability_application;

typedef struct EnhancementLayerInfo_spatialEnhancement {
    PEnhancementLayerInfo_spatialEnhancement next;
    EnhancementOptions value;
} EnhancementLayerInfo_spatialEnhancement_Element;

typedef struct EnhancementLayerInfo_snrEnhancement {
    PEnhancementLayerInfo_snrEnhancement next;
    EnhancementOptions value;
} EnhancementLayerInfo_snrEnhancement_Element;

typedef struct MediaPacketizationCapability_rtpPayloadType {
    ASN1uint32_t count;
    RTPPayloadType value[256];
} MediaPacketizationCapability_rtpPayloadType;

typedef struct H2250Capability_redundancyEncodingCapability {
    PH2250Capability_redundancyEncodingCapability next;
    RedundancyEncodingCapability value;
} H2250Capability_redundancyEncodingCapability_Element;

typedef struct CommandMessage {
    ASN1choice_t choice;
    union {
#	define CommandMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define maintenanceLoopOffCommand_chosen 2
	MaintenanceLoopOffCommand maintenanceLoopOffCommand;
#	define sendTerminalCapabilitySet_chosen 3
	SendTerminalCapabilitySet sendTerminalCapabilitySet;
#	define encryptionCommand_chosen 4
	EncryptionCommand encryptionCommand;
#	define flowControlCommand_chosen 5
	FlowControlCommand flowControlCommand;
#	define endSessionCommand_chosen 6
	EndSessionCommand endSessionCommand;
#	define miscellaneousCommand_chosen 7
	MiscellaneousCommand miscellaneousCommand;
#	define communicationModeCommand_chosen 8
	CommunicationModeCommand communicationModeCommand;
#	define conferenceCommand_chosen 9
	ConferenceCommand conferenceCommand;
#	define h223MultiplexReconfiguration_chosen 10
	H223MultiplexReconfiguration h223MultiplexReconfiguration;
    } u;
} CommandMessage;

typedef struct H235SecurityCapability {
    EncryptionAuthenticationAndIntegrity encryptionAuthenticationAndIntegrity;
    CapabilityTableEntryNumber mediaCapability;
} H235SecurityCapability;

typedef struct MediaPacketizationCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t h261aVideoPacketization;
#   define rtpPayloadType_present 0x80
    MediaPacketizationCapability_rtpPayloadType rtpPayloadType;
} MediaPacketizationCapability;

typedef struct VideoCapability {
    ASN1choice_t choice;
    union {
#	define VideoCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoCapability_chosen 2
	H261VideoCapability h261VideoCapability;
#	define h262VideoCapability_chosen 3
	H262VideoCapability h262VideoCapability;
#	define h263VideoCapability_chosen 4
	H263VideoCapability h263VideoCapability;
#	define is11172VideoCapability_chosen 5
	IS11172VideoCapability is11172VideoCapability;
    } u;
} VideoCapability;

typedef struct BEnhancementParameters {
    EnhancementOptions enhancementOptions;
    ASN1uint16_t numberOfBPictures;
} BEnhancementParameters;

typedef struct DataApplicationCapability {
    DataApplicationCapability_application application;
    ASN1uint32_t maxBitRate;
} DataApplicationCapability;

typedef struct NetworkAccessParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define distribution_present 0x80
    NetworkAccessParameters_distribution distribution;
    NetworkAccessParameters_networkAddress networkAddress;
    ASN1bool_t associateConference;
#   define externalReference_present 0x40
    struct NetworkAccessParameters_externalReference_externalReference {
	ASN1uint32_t length;
	ASN1octet_t value[255];
    } externalReference;
#   define t120SetupProcedure_present 0x8000
    NetworkAccessParameters_t120SetupProcedure t120SetupProcedure;
} NetworkAccessParameters;

typedef struct H2250ModeParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define redundancyEncodingMode_present 0x80
    RedundancyEncodingMode redundancyEncodingMode;
} H2250ModeParameters;

typedef struct DataMode {
    DataMode_application application;
    ASN1uint32_t bitRate;
} DataMode;

typedef struct CommunicationModeTableEntry_dataType {
    ASN1choice_t choice;
    union {
#	define CommunicationModeTableEntry_dataType_videoData_chosen 1
	VideoCapability videoData;
#	define CommunicationModeTableEntry_dataType_audioData_chosen 2
	AudioCapability audioData;
#	define CommunicationModeTableEntry_dataType_data_chosen 3
	DataApplicationCapability data;
    } u;
} CommunicationModeTableEntry_dataType;

typedef struct H235Mode_mediaMode {
    ASN1choice_t choice;
    union {
#	define H235Mode_mediaMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H235Mode_mediaMode_videoMode_chosen 2
	VideoMode videoMode;
#	define H235Mode_mediaMode_audioMode_chosen 3
	AudioMode audioMode;
#	define H235Mode_mediaMode_dataMode_chosen 4
	DataMode dataMode;
    } u;
} H235Mode_mediaMode;

typedef struct H235Media_mediaType {
    ASN1choice_t choice;
    union {
#	define H235Media_mediaType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H235Media_mediaType_videoData_chosen 2
	VideoCapability videoData;
#	define H235Media_mediaType_audioData_chosen 3
	AudioCapability audioData;
#	define H235Media_mediaType_data_chosen 4
	DataApplicationCapability data;
    } u;
} H235Media_mediaType;

typedef struct EnhancementLayerInfo_bPictureEnhancement {
    PEnhancementLayerInfo_bPictureEnhancement next;
    BEnhancementParameters value;
} EnhancementLayerInfo_bPictureEnhancement_Element;

typedef struct MediaDistributionCapability_distributedData {
    PMediaDistributionCapability_distributedData next;
    DataApplicationCapability value;
} MediaDistributionCapability_distributedData_Element;

typedef struct MediaDistributionCapability_centralizedData {
    PMediaDistributionCapability_centralizedData next;
    DataApplicationCapability value;
} MediaDistributionCapability_centralizedData_Element;

typedef struct Capability {
    ASN1choice_t choice;
    union {
#	define Capability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define receiveVideoCapability_chosen 2
	VideoCapability receiveVideoCapability;
#	define transmitVideoCapability_chosen 3
	VideoCapability transmitVideoCapability;
#	define receiveAndTransmitVideoCapability_chosen 4
	VideoCapability receiveAndTransmitVideoCapability;
#	define receiveAudioCapability_chosen 5
	AudioCapability receiveAudioCapability;
#	define transmitAudioCapability_chosen 6
	AudioCapability transmitAudioCapability;
#	define receiveAndTransmitAudioCapability_chosen 7
	AudioCapability receiveAndTransmitAudioCapability;
#	define receiveDataApplicationCapability_chosen 8
	DataApplicationCapability receiveDataApplicationCapability;
#	define transmitDataApplicationCapability_chosen 9
	DataApplicationCapability transmitDataApplicationCapability;
#	define receiveAndTransmitDataApplicationCapability_chosen 10
	DataApplicationCapability receiveAndTransmitDataApplicationCapability;
#	define h233EncryptionTransmitCapability_chosen 11
	ASN1bool_t h233EncryptionTransmitCapability;
#	define h233EncryptionReceiveCapability_chosen 12
	Capability_h233EncryptionReceiveCapability h233EncryptionReceiveCapability;
#	define conferenceCapability_chosen 13
	ConferenceCapability conferenceCapability;
#	define h235SecurityCapability_chosen 14
	H235SecurityCapability h235SecurityCapability;
#	define maxPendingReplacementFor_chosen 15
	ASN1uint16_t maxPendingReplacementFor;
#	define receiveUserInputCapability_chosen 16
	UserInputCapability receiveUserInputCapability;
#	define transmitUserInputCapability_chosen 17
	UserInputCapability transmitUserInputCapability;
#	define receiveAndTransmitUserInputCapability_chosen 18
	UserInputCapability receiveAndTransmitUserInputCapability;
    } u;
} Capability;

typedef struct H2250Capability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t maximumAudioDelayJitter;
    MultipointCapability receiveMultipointCapability;
    MultipointCapability transmitMultipointCapability;
    MultipointCapability receiveAndTransmitMultipointCapability;
    H2250Capability_mcCapability mcCapability;
    ASN1bool_t rtcpVideoControlCapability;
    MediaPacketizationCapability mediaPacketizationCapability;
#   define H2250Capability_transportCapability_present 0x80
    TransportCapability transportCapability;
#   define redundancyEncodingCapability_present 0x40
    PH2250Capability_redundancyEncodingCapability redundancyEncodingCapability;
#   define logicalChannelSwitchingCapability_present 0x20
    ASN1bool_t logicalChannelSwitchingCapability;
#   define t120DynamicPortCapability_present 0x10
    ASN1bool_t t120DynamicPortCapability;
} H2250Capability;

typedef struct H235Media {
    EncryptionAuthenticationAndIntegrity encryptionAuthenticationAndIntegrity;
    H235Media_mediaType mediaType;
} H235Media;

typedef struct H235Mode {
    EncryptionAuthenticationAndIntegrity encryptionAuthenticationAndIntegrity;
    H235Mode_mediaMode mediaMode;
} H235Mode;

typedef struct ModeElement_type {
    ASN1choice_t choice;
    union {
#	define ModeElement_type_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define ModeElement_type_videoMode_chosen 2
	VideoMode videoMode;
#	define ModeElement_type_audioMode_chosen 3
	AudioMode audioMode;
#	define ModeElement_type_dataMode_chosen 4
	DataMode dataMode;
#	define encryptionMode_chosen 5
	EncryptionMode encryptionMode;
#	define h235Mode_chosen 6
	H235Mode h235Mode;
    } u;
} ModeElement_type;

typedef struct CapabilityTableEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityTableEntryNumber capabilityTableEntryNumber;
#   define capability_present 0x80
    Capability capability;
} CapabilityTableEntry;

typedef struct MultiplexCapability {
    ASN1choice_t choice;
    union {
#	define MultiplexCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h222Capability_chosen 2
	H222Capability h222Capability;
#	define h223Capability_chosen 3
	H223Capability h223Capability;
#	define v76Capability_chosen 4
	V76Capability v76Capability;
#	define h2250Capability_chosen 5
	H2250Capability h2250Capability;
    } u;
} MultiplexCapability;

typedef struct DataType {
    ASN1choice_t choice;
    union {
#	define DataType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define nullData_chosen 2
#	define DataType_videoData_chosen 3
	VideoCapability videoData;
#	define DataType_audioData_chosen 4
	AudioCapability audioData;
#	define DataType_data_chosen 5
	DataApplicationCapability data;
#	define encryptionData_chosen 6
	EncryptionMode encryptionData;
#	define h235Control_chosen 7
	NonStandardParameter h235Control;
#	define h235Media_chosen 8
	H235Media h235Media;
    } u;
} DataType;

typedef struct RedundancyEncoding {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RedundancyEncodingMethod redundancyEncodingMethod;
#   define RedundancyEncoding_secondaryEncoding_present 0x80
    DataType secondaryEncoding;
} RedundancyEncoding;

typedef struct ModeElement {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ModeElement_type type;
#   define h223ModeParameters_present 0x80
    H223ModeParameters h223ModeParameters;
#   define v76ModeParameters_present 0x8000
    V76ModeParameters v76ModeParameters;
#   define h2250ModeParameters_present 0x4000
    H2250ModeParameters h2250ModeParameters;
} ModeElement;

typedef struct CommunicationModeTableEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define CommunicationModeTableEntry_nonStandard_present 0x80
    PCommunicationModeTableEntry_nonStandard nonStandard;
    ASN1uint16_t sessionID;
#   define CommunicationModeTableEntry_associatedSessionID_present 0x40
    ASN1uint16_t associatedSessionID;
#   define CommunicationModeTableEntry_terminalLabel_present 0x20
    TerminalLabel terminalLabel;
    ASN1char16string_t sessionDescription;
    CommunicationModeTableEntry_dataType dataType;
#   define CommunicationModeTableEntry_mediaChannel_present 0x10
    H245TransportAddress mediaChannel;
#   define CommunicationModeTableEntry_mediaGuaranteedDelivery_present 0x8
    ASN1bool_t mediaGuaranteedDelivery;
#   define CommunicationModeTableEntry_mediaControlChannel_present 0x4
    H245TransportAddress mediaControlChannel;
#   define CommunicationModeTableEntry_mediaControlGuaranteedDelivery_present 0x2
    ASN1bool_t mediaControlGuaranteedDelivery;
#   define CommunicationModeTableEntry_redundancyEncoding_present 0x8000
    RedundancyEncoding redundancyEncoding;
#   define sessionDependency_present 0x4000
    ASN1uint16_t sessionDependency;
#   define CommunicationModeTableEntry_destination_present 0x2000
    TerminalLabel destination;
} CommunicationModeTableEntry;

typedef struct CommunicationModeResponse_communicationModeTable {
    PCommunicationModeResponse_communicationModeTable next;
    CommunicationModeTableEntry value;
} CommunicationModeResponse_communicationModeTable_Element;

typedef struct CommunicationModeCommand_communicationModeTable {
    PCommunicationModeCommand_communicationModeTable next;
    CommunicationModeTableEntry value;
} CommunicationModeCommand_communicationModeTable_Element;

typedef struct TerminalCapabilitySet_capabilityTable {
    PTerminalCapabilitySet_capabilityTable next;
    CapabilityTableEntry value;
} TerminalCapabilitySet_capabilityTable_Element;

typedef struct TerminalCapabilitySet {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SequenceNumber sequenceNumber;
    ASN1objectidentifier_t protocolIdentifier;
#   define multiplexCapability_present 0x80
    MultiplexCapability multiplexCapability;
#   define capabilityTable_present 0x40
    PTerminalCapabilitySet_capabilityTable capabilityTable;
#   define capabilityDescriptors_present 0x20
    TerminalCapabilitySet_capabilityDescriptors capabilityDescriptors;
} TerminalCapabilitySet;

typedef struct H2250LogicalChannelParameters {
    union {
	ASN1uint32_t bit_mask;
	ASN1octet_t o[3];
    };
#   define H2250LogicalChannelParameters_nonStandard_present 0x80
    PH2250LogicalChannelParameters_nonStandard nonStandard;
    ASN1uint16_t sessionID;
#   define H2250LogicalChannelParameters_associatedSessionID_present 0x40
    ASN1uint16_t associatedSessionID;
#   define H2250LogicalChannelParameters_mediaChannel_present 0x20
    H245TransportAddress mediaChannel;
#   define H2250LogicalChannelParameters_mediaGuaranteedDelivery_present 0x10
    ASN1bool_t mediaGuaranteedDelivery;
#   define H2250LogicalChannelParameters_mediaControlChannel_present 0x8
    H245TransportAddress mediaControlChannel;
#   define H2250LogicalChannelParameters_mediaControlGuaranteedDelivery_present 0x4
    ASN1bool_t mediaControlGuaranteedDelivery;
#   define silenceSuppression_present 0x2
    ASN1bool_t silenceSuppression;
#   define H2250LogicalChannelParameters_destination_present 0x1
    TerminalLabel destination;
#   define H2250LogicalChannelParameters_dynamicRTPPayloadType_present 0x8000
    ASN1uint16_t dynamicRTPPayloadType;
#   define mediaPacketization_present 0x4000
    H2250LogicalChannelParameters_mediaPacketization mediaPacketization;
#   define H2250LogicalChannelParameters_transportCapability_present 0x800000
    TransportCapability transportCapability;
#   define H2250LogicalChannelParameters_redundancyEncoding_present 0x400000
    RedundancyEncoding redundancyEncoding;
#   define source_present 0x200000
    TerminalLabel source;
} H2250LogicalChannelParameters;

typedef struct ModeDescription {
    ASN1uint32_t count;
    ModeElement value[256];
} ModeDescription;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen 1
	H222LogicalChannelParameters h222LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen 2
	H223LogicalChannelParameters h223LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen 3
	V76LogicalChannelParameters v76LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 4
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_none_chosen 5
    } u;
} OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen 1
	H223LogicalChannelParameters h223LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen 2
	V76LogicalChannelParameters v76LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 3
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
    } u;
} OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen 1
	H222LogicalChannelParameters h222LogicalChannelParameters;
#	define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 2
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
    } u;
} OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters;

typedef struct RequestMode_requestedModes {
    PRequestMode_requestedModes next;
    ModeDescription value;
} RequestMode_requestedModes_Element;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber reverseLogicalChannelNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber_present 0x80
    ASN1uint16_t portNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_present 0x40
    OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_replacementFor_present 0x8000
    LogicalChannelNumber replacementFor;
} OpenLogicalChannelAck_reverseLogicalChannelParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    DataType dataType;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_present 0x80
    OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
#   define reverseLogicalChannelDependency_present 0x8000
    LogicalChannelNumber reverseLogicalChannelDependency;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_replacementFor_present 0x4000
    LogicalChannelNumber replacementFor;
} OpenLogicalChannel_reverseLogicalChannelParameters;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define OpenLogicalChannel_forwardLogicalChannelParameters_portNumber_present 0x80
    ASN1uint16_t portNumber;
    DataType dataType;
    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters multiplexParameters;
#   define forwardLogicalChannelDependency_present 0x8000
    LogicalChannelNumber forwardLogicalChannelDependency;
#   define OpenLogicalChannel_forwardLogicalChannelParameters_replacementFor_present 0x4000
    LogicalChannelNumber replacementFor;
} OpenLogicalChannel_forwardLogicalChannelParameters;

typedef struct OpenLogicalChannel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
    OpenLogicalChannel_forwardLogicalChannelParameters forwardLogicalChannelParameters;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_present 0x80
    OpenLogicalChannel_reverseLogicalChannelParameters reverseLogicalChannelParameters;
#   define OpenLogicalChannel_separateStack_present 0x8000
    NetworkAccessParameters separateStack;
#   define OpenLogicalChannel_encryptionSync_present 0x4000
    EncryptionSync encryptionSync;
} OpenLogicalChannel;

typedef struct OpenLogicalChannelAck {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_present 0x80
    OpenLogicalChannelAck_reverseLogicalChannelParameters reverseLogicalChannelParameters;
#   define OpenLogicalChannelAck_separateStack_present 0x8000
    NetworkAccessParameters separateStack;
#   define forwardMultiplexAckParameters_present 0x4000
    OpenLogicalChannelAck_forwardMultiplexAckParameters forwardMultiplexAckParameters;
#   define OpenLogicalChannelAck_encryptionSync_present 0x2000
    EncryptionSync encryptionSync;
} OpenLogicalChannelAck;

typedef struct RequestMessage {
    ASN1choice_t choice;
    union {
#	define RequestMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define masterSlaveDetermination_chosen 2
	MasterSlaveDetermination masterSlaveDetermination;
#	define terminalCapabilitySet_chosen 3
	TerminalCapabilitySet terminalCapabilitySet;
#	define openLogicalChannel_chosen 4
	OpenLogicalChannel openLogicalChannel;
#	define closeLogicalChannel_chosen 5
	CloseLogicalChannel closeLogicalChannel;
#	define requestChannelClose_chosen 6
	RequestChannelClose requestChannelClose;
#	define multiplexEntrySend_chosen 7
	MultiplexEntrySend multiplexEntrySend;
#	define requestMultiplexEntry_chosen 8
	RequestMultiplexEntry requestMultiplexEntry;
#	define requestMode_chosen 9
	RequestMode requestMode;
#	define roundTripDelayRequest_chosen 10
	RoundTripDelayRequest roundTripDelayRequest;
#	define maintenanceLoopRequest_chosen 11
	MaintenanceLoopRequest maintenanceLoopRequest;
#	define communicationModeRequest_chosen 12
	CommunicationModeRequest communicationModeRequest;
#	define conferenceRequest_chosen 13
	ConferenceRequest conferenceRequest;
    } u;
} RequestMessage;

typedef struct ResponseMessage {
    ASN1choice_t choice;
    union {
#	define ResponseMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define masterSlaveDeterminationAck_chosen 2
	MasterSlaveDeterminationAck masterSlaveDeterminationAck;
#	define masterSlaveDeterminationReject_chosen 3
	MasterSlaveDeterminationReject masterSlaveDeterminationReject;
#	define terminalCapabilitySetAck_chosen 4
	TerminalCapabilitySetAck terminalCapabilitySetAck;
#	define terminalCapabilitySetReject_chosen 5
	TerminalCapabilitySetReject terminalCapabilitySetReject;
#	define openLogicalChannelAck_chosen 6
	OpenLogicalChannelAck openLogicalChannelAck;
#	define openLogicalChannelReject_chosen 7
	OpenLogicalChannelReject openLogicalChannelReject;
#	define closeLogicalChannelAck_chosen 8
	CloseLogicalChannelAck closeLogicalChannelAck;
#	define requestChannelCloseAck_chosen 9
	RequestChannelCloseAck requestChannelCloseAck;
#	define requestChannelCloseReject_chosen 10
	RequestChannelCloseReject requestChannelCloseReject;
#	define multiplexEntrySendAck_chosen 11
	MultiplexEntrySendAck multiplexEntrySendAck;
#	define multiplexEntrySendReject_chosen 12
	MultiplexEntrySendReject multiplexEntrySendReject;
#	define requestMultiplexEntryAck_chosen 13
	RequestMultiplexEntryAck requestMultiplexEntryAck;
#	define requestMultiplexEntryReject_chosen 14
	RequestMultiplexEntryReject requestMultiplexEntryReject;
#	define requestModeAck_chosen 15
	RequestModeAck requestModeAck;
#	define requestModeReject_chosen 16
	RequestModeReject requestModeReject;
#	define roundTripDelayResponse_chosen 17
	RoundTripDelayResponse roundTripDelayResponse;
#	define maintenanceLoopAck_chosen 18
	MaintenanceLoopAck maintenanceLoopAck;
#	define maintenanceLoopReject_chosen 19
	MaintenanceLoopReject maintenanceLoopReject;
#	define communicationModeResponse_chosen 20
	CommunicationModeResponse communicationModeResponse;
#	define conferenceResponse_chosen 21
	ConferenceResponse conferenceResponse;
    } u;
} ResponseMessage;

typedef OpenLogicalChannel FastConnectOLC;
#define FastConnectOLC_PDU 0
#define SIZE_H245PP_Module_PDU_0 sizeof(FastConnectOLC)

typedef struct FunctionNotUnderstood {
    ASN1choice_t choice;
    union {
#	define FunctionNotUnderstood_request_chosen 1
	RequestMessage request;
#	define FunctionNotUnderstood_response_chosen 2
	ResponseMessage response;
#	define FunctionNotUnderstood_command_chosen 3
	CommandMessage command;
    } u;
} FunctionNotUnderstood;

typedef struct IndicationMessage {
    ASN1choice_t choice;
    union {
#	define IndicationMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define functionNotUnderstood_chosen 2
	FunctionNotUnderstood functionNotUnderstood;
#	define masterSlaveDeterminationRelease_chosen 3
	MasterSlaveDeterminationRelease masterSlaveDeterminationRelease;
#	define terminalCapabilitySetRelease_chosen 4
	TerminalCapabilitySetRelease terminalCapabilitySetRelease;
#	define openLogicalChannelConfirm_chosen 5
	OpenLogicalChannelConfirm openLogicalChannelConfirm;
#	define requestChannelCloseRelease_chosen 6
	RequestChannelCloseRelease requestChannelCloseRelease;
#	define multiplexEntrySendRelease_chosen 7
	MultiplexEntrySendRelease multiplexEntrySendRelease;
#	define requestMultiplexEntryRelease_chosen 8
	RequestMultiplexEntryRelease requestMultiplexEntryRelease;
#	define requestModeRelease_chosen 9
	RequestModeRelease requestModeRelease;
#	define miscellaneousIndication_chosen 10
	MiscellaneousIndication miscellaneousIndication;
#	define jitterIndication_chosen 11
	JitterIndication jitterIndication;
#	define h223SkewIndication_chosen 12
	H223SkewIndication h223SkewIndication;
#	define newATMVCIndication_chosen 13
	NewATMVCIndication newATMVCIndication;
#	define userInput_chosen 14
	UserInputIndication userInput;
#	define h2250MaximumSkewIndication_chosen 15
	H2250MaximumSkewIndication h2250MaximumSkewIndication;
#	define mcLocationIndication_chosen 16
	MCLocationIndication mcLocationIndication;
#	define conferenceIndication_chosen 17
	ConferenceIndication conferenceIndication;
#	define vendorIdentification_chosen 18
	VendorIdentification vendorIdentification;
#	define IndicationMessage_functionNotSupported_chosen 19
	FunctionNotSupported functionNotSupported;
    } u;
} IndicationMessage;

typedef struct MultimediaSystemControlMessage {
    ASN1choice_t choice;
    union {
#	define MultimediaSystemControlMessage_request_chosen 1
	RequestMessage request;
#	define MultimediaSystemControlMessage_response_chosen 2
	ResponseMessage response;
#	define MultimediaSystemControlMessage_command_chosen 3
	CommandMessage command;
#	define indication_chosen 4
	IndicationMessage indication;
    } u;
} MultimediaSystemControlMessage;
#define MultimediaSystemControlMessage_PDU 1
#define SIZE_H245PP_Module_PDU_1 sizeof(MultimediaSystemControlMessage)


extern ASN1module_t H245PP_Module;
extern void ASN1CALL H245PP_Module_Startup(void);
extern void ASN1CALL H245PP_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route val);
	extern void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn(PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
	extern void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern int ASN1CALL ASN1Enc_RedundancyEncodingCapability_secondaryEncoding_ElmFn(ASN1encoding_t enc, PRedundancyEncodingCapability_secondaryEncoding val);
    extern int ASN1CALL ASN1Dec_RedundancyEncodingCapability_secondaryEncoding_ElmFn(ASN1decoding_t dec, PRedundancyEncodingCapability_secondaryEncoding val);
	extern void ASN1CALL ASN1Free_RedundancyEncodingCapability_secondaryEncoding_ElmFn(PRedundancyEncodingCapability_secondaryEncoding val);
    extern int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(ASN1encoding_t enc, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val);
    extern int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(ASN1decoding_t dec, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val);
	extern void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val);
    extern int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(ASN1encoding_t enc, PRequestAllTerminalIDsResponse_terminalInformation val);
    extern int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(ASN1decoding_t dec, PRequestAllTerminalIDsResponse_terminalInformation val);
	extern void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(PRequestAllTerminalIDsResponse_terminalInformation val);
    extern int ASN1CALL ASN1Enc_EncryptionSync_escrowentry_ElmFn(ASN1encoding_t enc, PEncryptionSync_escrowentry val);
    extern int ASN1CALL ASN1Dec_EncryptionSync_escrowentry_ElmFn(ASN1decoding_t dec, PEncryptionSync_escrowentry val);
	extern void ASN1CALL ASN1Free_EncryptionSync_escrowentry_ElmFn(PEncryptionSync_escrowentry val);
    extern int ASN1CALL ASN1Enc_H263Options_customPictureFormat_ElmFn(ASN1encoding_t enc, PH263Options_customPictureFormat val);
    extern int ASN1CALL ASN1Dec_H263Options_customPictureFormat_ElmFn(ASN1decoding_t dec, PH263Options_customPictureFormat val);
	extern void ASN1CALL ASN1Free_H263Options_customPictureFormat_ElmFn(PH263Options_customPictureFormat val);
    extern int ASN1CALL ASN1Enc_H263Options_customPictureClockFrequency_ElmFn(ASN1encoding_t enc, PH263Options_customPictureClockFrequency val);
    extern int ASN1CALL ASN1Dec_H263Options_customPictureClockFrequency_ElmFn(ASN1decoding_t dec, PH263Options_customPictureClockFrequency val);
	extern void ASN1CALL ASN1Free_H263Options_customPictureClockFrequency_ElmFn(PH263Options_customPictureClockFrequency val);
    extern int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability val);
	extern void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn(PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Enc_H222Capability_vcCapability_ElmFn(ASN1encoding_t enc, PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Dec_H222Capability_vcCapability_ElmFn(ASN1decoding_t dec, PH222Capability_vcCapability val);
	extern void ASN1CALL ASN1Free_H222Capability_vcCapability_ElmFn(PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities val);
    extern int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities val);
	extern void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities_ElmFn(PCapabilityDescriptor_simultaneousCapabilities val);
    extern int ASN1CALL ASN1Enc_CertSelectionCriteria_ElmFn(ASN1encoding_t enc, PCertSelectionCriteria val);
    extern int ASN1CALL ASN1Dec_CertSelectionCriteria_ElmFn(ASN1decoding_t dec, PCertSelectionCriteria val);
	extern void ASN1CALL ASN1Free_CertSelectionCriteria_ElmFn(PCertSelectionCriteria val);
    extern int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard val);
    extern int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard val);
	extern void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard_ElmFn(PCommunicationModeTableEntry_nonStandard val);
    extern int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors val);
	extern void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard val);
	extern void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard_ElmFn(PH2250LogicalChannelAckParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard val);
	extern void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn(PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData_ElmFn(ASN1encoding_t enc, PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData_ElmFn(ASN1decoding_t dec, PConferenceCapability_nonStandardData val);
	extern void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData_ElmFn(PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Enc_H263Options_modeCombos_ElmFn(ASN1encoding_t enc, PH263Options_modeCombos val);
    extern int ASN1CALL ASN1Dec_H263Options_modeCombos_ElmFn(ASN1decoding_t dec, PH263Options_modeCombos val);
	extern void ASN1CALL ASN1Free_H263Options_modeCombos_ElmFn(PH263Options_modeCombos val);
    extern int ASN1CALL ASN1Enc_TransportCapability_qOSCapabilities_ElmFn(ASN1encoding_t enc, PTransportCapability_qOSCapabilities val);
    extern int ASN1CALL ASN1Dec_TransportCapability_qOSCapabilities_ElmFn(ASN1decoding_t dec, PTransportCapability_qOSCapabilities val);
	extern void ASN1CALL ASN1Free_TransportCapability_qOSCapabilities_ElmFn(PTransportCapability_qOSCapabilities val);
    extern int ASN1CALL ASN1Enc_EncryptionCapability_ElmFn(ASN1encoding_t enc, PEncryptionCapability val);
    extern int ASN1CALL ASN1Dec_EncryptionCapability_ElmFn(ASN1decoding_t dec, PEncryptionCapability val);
	extern void ASN1CALL ASN1Free_EncryptionCapability_ElmFn(PEncryptionCapability val);
    extern int ASN1CALL ASN1Enc_EnhancementLayerInfo_spatialEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_spatialEnhancement val);
    extern int ASN1CALL ASN1Dec_EnhancementLayerInfo_spatialEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_spatialEnhancement val);
	extern void ASN1CALL ASN1Free_EnhancementLayerInfo_spatialEnhancement_ElmFn(PEnhancementLayerInfo_spatialEnhancement val);
    extern int ASN1CALL ASN1Enc_EnhancementLayerInfo_snrEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_snrEnhancement val);
    extern int ASN1CALL ASN1Dec_EnhancementLayerInfo_snrEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_snrEnhancement val);
	extern void ASN1CALL ASN1Free_EnhancementLayerInfo_snrEnhancement_ElmFn(PEnhancementLayerInfo_snrEnhancement val);
    extern int ASN1CALL ASN1Enc_H2250Capability_redundancyEncodingCapability_ElmFn(ASN1encoding_t enc, PH2250Capability_redundancyEncodingCapability val);
    extern int ASN1CALL ASN1Dec_H2250Capability_redundancyEncodingCapability_ElmFn(ASN1decoding_t dec, PH2250Capability_redundancyEncodingCapability val);
	extern void ASN1CALL ASN1Free_H2250Capability_redundancyEncodingCapability_ElmFn(PH2250Capability_redundancyEncodingCapability val);
    extern int ASN1CALL ASN1Enc_EnhancementLayerInfo_bPictureEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_bPictureEnhancement val);
    extern int ASN1CALL ASN1Dec_EnhancementLayerInfo_bPictureEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_bPictureEnhancement val);
	extern void ASN1CALL ASN1Free_EnhancementLayerInfo_bPictureEnhancement_ElmFn(PEnhancementLayerInfo_bPictureEnhancement val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_distributedData val);
	extern void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData_ElmFn(PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData val);
	extern void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData_ElmFn(PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable val);
    extern int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable val);
	extern void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable_ElmFn(PCommunicationModeResponse_communicationModeTable val);
    extern int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable val);
    extern int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable val);
	extern void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable_ElmFn(PCommunicationModeCommand_communicationModeTable val);
    extern int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable val);
    extern int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable val);
	extern void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable_ElmFn(PTerminalCapabilitySet_capabilityTable val);
    extern int ASN1CALL ASN1Enc_RequestMode_requestedModes_ElmFn(ASN1encoding_t enc, PRequestMode_requestedModes val);
    extern int ASN1CALL ASN1Dec_RequestMode_requestedModes_ElmFn(ASN1decoding_t dec, PRequestMode_requestedModes val);
	extern void ASN1CALL ASN1Free_RequestMode_requestedModes_ElmFn(PRequestMode_requestedModes val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _H245PP_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\h323asn1.cpp ===
#include "stdafx.h"
#include "h323asn1.h"

struct	SAFE_ENCODER
{
public:

	CRITICAL_SECTION	CriticalSection;
	ASN1encoding_t		Encoder;

private:

	void	Lock	(void)	{ EnterCriticalSection (&CriticalSection); }
	void	Unlock	(void)	{ LeaveCriticalSection (&CriticalSection); }

public:

	SAFE_ENCODER	(void);
	~SAFE_ENCODER	(void);

	BOOL	Create		(ASN1module_t);
	void	Close		(void);

	DWORD	Encode		(
		IN	DWORD		PduType,
		IN	PVOID		PduStructure,
		OUT	PUCHAR *	ReturnBuffer,
		OUT	PDWORD		ReturnBufferLength);

	void	FreeBuffer	(
		IN	PUCHAR		Buffer);
};

class	SAFE_DECODER
{
public:

	CRITICAL_SECTION	CriticalSection;
	ASN1decoding_t		Decoder;

private:

	void	Lock	(void)	{ EnterCriticalSection (&CriticalSection); }
	void	Unlock	(void)	{ LeaveCriticalSection (&CriticalSection); }

public:

	SAFE_DECODER	(void);
	~SAFE_DECODER	(void);

	BOOL	Create	(ASN1module_t Module);
	void	Close	(void);

	DWORD	Decode	(
		IN	PUCHAR		Buffer,
		IN	DWORD		BufferLength,
		IN	DWORD		PduType,
		OUT	PVOID *		PduStructure);

	void	FreePdu	(
		IN	DWORD		PduType,
		IN	PVOID		PduStructure);
};







static	SAFE_ENCODER		H225Encoder;
static	SAFE_DECODER		H225Decoder;
static	SAFE_ENCODER		H245Encoder;
static	SAFE_DECODER		H245Decoder;

void H323ASN1Initialize (void)
{
	ASN1error_e		Error;

	H225PP_Module_Startup();
	H245PP_Module_Startup();

	H225Encoder.Create (H225PP_Module);
	H225Decoder.Create (H225PP_Module);
	H245Encoder.Create (H245PP_Module);
	H245Decoder.Create (H245PP_Module);
}

void H323ASN1Shutdown (void)
{
	H225Encoder.Close();
	H225Decoder.Close();
	H245Encoder.Close();
	H245Decoder.Close();

	H225PP_Module_Cleanup();
	H245PP_Module_Cleanup();
}

DWORD H225EncodePdu (
	IN	DWORD		PduType,
	IN	PVOID		PduStructure,
	OUT	PUCHAR *	ReturnBuffer,
	OUT	PDWORD		ReturnBufferLength)
{
	return H225Encoder.Encode (PduType, PduStructure, ReturnBuffer, ReturnBufferLength);
}

DWORD H225DecodePdu (
	IN	PUCHAR		Buffer,
	IN	DWORD		BufferLength,
	IN	DWORD		PduType,
	OUT	PVOID *		ReturnPduStructure)
{
	return H225Decoder.Decode (Buffer, BufferLength, PduType, ReturnPduStructure);
}

DWORD H225FreePdu (
	IN	DWORD		PduType,
	IN	PVOID		PduStructure)
{
	H225Decoder.FreePdu (PduType, PduStructure);
	return ERROR_SUCCESS;
}

DWORD H225FreeBuffer (
	IN	PUCHAR		Buffer)
{
	H225Encoder.FreeBuffer (Buffer);
	return ERROR_SUCCESS;
}

DWORD H245EncodePdu (
	IN	DWORD		PduType,
	IN	PVOID		PduStructure,
	OUT	PUCHAR *	ReturnBuffer,
	OUT	PDWORD		ReturnBufferLength)
{
	return H245Encoder.Encode (PduType, PduStructure, ReturnBuffer, ReturnBufferLength);
}

DWORD H245DecodePdu (
	IN	PUCHAR		Buffer,
	IN	DWORD		BufferLength,
	IN	DWORD		PduType,
	OUT	PVOID *		ReturnPduStructure)
{
	return H245Decoder.Decode (Buffer, BufferLength, PduType, ReturnPduStructure);
}

DWORD H245FreePdu (
	IN	DWORD		PduType,
	IN	PVOID		PduStructure)
{
	H245Decoder.FreePdu (PduType, PduStructure);
	return ERROR_SUCCESS;
}

DWORD H245FreeBuffer (
	IN	PUCHAR		Buffer)
{
	H245Encoder.FreeBuffer (Buffer);
	return ERROR_SUCCESS;
}

// SAFE_ENCODER ----------------------------------------------------------------------

SAFE_ENCODER::SAFE_ENCODER (void)
{
	InitializeCriticalSection (&CriticalSection);
	Encoder = NULL;
}

SAFE_ENCODER::~SAFE_ENCODER (void)
{
	DeleteCriticalSection (&CriticalSection);
	assert (!Encoder);
}

BOOL SAFE_ENCODER::Create (ASN1module_t Module)
{
	ASN1error_e		Error;

	if (Encoder)
		return TRUE;

	Error = ASN1_CreateEncoder (Module, &Encoder, NULL, 0, NULL);
	if (ASN1_FAILED (Error))
		DebugF (_T("SAFE_ENCODER::Create: failed to create ASN.1 encoder, error %d\n"), Error);

	return ASN1_SUCCEEDED (Error);
}

void SAFE_ENCODER::Close (void)
{
	if (Encoder) {
		ASN1_CloseEncoder (Encoder);
		Encoder = NULL;
	}
}

DWORD SAFE_ENCODER::Encode (
	IN	DWORD		PduType,
	IN	PVOID		PduStructure,
	OUT	PUCHAR *	ReturnBuffer,
	OUT	PDWORD		ReturnBufferLength)
{
	ASN1error_e		Error;

	Lock();

	Error = ASN1_Encode (Encoder, PduStructure, PduType, ASN1ENCODE_ALLOCATEBUFFER, NULL, 0);

	if (ASN1_SUCCEEDED (Error)) {
		*ReturnBuffer = Encoder -> buf;
		*ReturnBufferLength = Encoder -> len;
	}
#if 0
	else
		DebugError (Error, _T("SAFE_ENCODER::Encode: failed to encode pdu\n"));
#endif

	Unlock();

	return Error;
}

void SAFE_ENCODER::FreeBuffer (IN PUCHAR Buffer)
{
	assert (Encoder);

	Lock();

	ASN1_FreeEncoded (Encoder, Buffer);

	Unlock();
}

// SAFE_DECODER -----------------------------------------------------------------------

SAFE_DECODER::SAFE_DECODER (void)
{
	InitializeCriticalSection (&CriticalSection);
	Decoder = NULL;
}

SAFE_DECODER::~SAFE_DECODER (void)
{
	DeleteCriticalSection (&CriticalSection);
	assert (!Decoder);
}

BOOL SAFE_DECODER::Create (ASN1module_t Module)
{
	ASN1error_e		Error;

	if (Decoder)
		return TRUE;

	Error = ASN1_CreateDecoder (Module, &Decoder, NULL, 0, NULL);
	if (ASN1_FAILED (Error))
		DebugF (_T("SAFE_DECODER::Create: failed to create ASN.1 decoder, error %d\n"), Error);

	return ASN1_SUCCEEDED (Error);
}

void SAFE_DECODER::Close (void)
{
	if (Decoder) {
		ASN1_CloseDecoder (Decoder);
		Decoder = NULL;
	}
}

void SAFE_DECODER::FreePdu (IN DWORD PduType, IN PVOID PduStructure)
{
	assert (Decoder);

	Lock();

	ASN1_FreeDecoded (Decoder, PduStructure, PduType);

	Unlock();
}

DWORD SAFE_DECODER::Decode (
	IN	PUCHAR		Buffer,
	IN	DWORD		BufferLength,
	IN	DWORD		PduType,
	OUT	PVOID *		ReturnPduStructure)
{
	ASN1error_e		Error;

	Lock();

	Error = ASN1_Decode (Decoder, ReturnPduStructure, PduType, ASN1DECODE_SETBUFFER, Buffer, BufferLength);

	Unlock();

#if 0
	if (ASN1_FAILED (Error))
		DebugError (Error, _T("SAFE_DECODER::Decode: failed to decode pdu\n"));
#endif

	return Error;
}


// formerly from pdu.cpp -----------------------------------------------------------------




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Q.931 PDUs                                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

/*++

Routine Description:

    Encodes the Non-ASN and ASN parts together into a buffer which
    is sent on the wire.

Arguments:
    
    None.

Return Values:

    Returns S_OK in case of success or an error in case of failure.

--*/

#define DEFAULT_Q931_BUF_SIZE 300

HRESULT EncodeQ931PDU(
        IN  Q931_MESSAGE           *pQ931msg,
        IN  H323_UserInformation   *pUserInformation OPTIONAL,
        OUT BYTE                  **ppReturnEncodedData,
        OUT DWORD				   *pReturnEncodedDataLength)
{
	HRESULT  HResult;
    BYTE    *Buffer;
    DWORD    BufLen;

	_ASSERTE(pUserInformation);
	_ASSERTE(pQ931msg);
	_ASSERTE(ppReturnEncodedData);
	_ASSERTE(pReturnEncodedDataLength);

	*ppReturnEncodedData = NULL;
	*pReturnEncodedDataLength = 0;

    Buffer = (BYTE *) EM_MALLOC(sizeof(BYTE)*DEFAULT_Q931_BUF_SIZE);

    if (!Buffer) {

        return E_OUTOFMEMORY;

    }

    // 4 bytes for TPKT header
    BufLen = DEFAULT_Q931_BUF_SIZE - 4;
    
    // Encode the PDU
    HResult = pQ931msg->EncodePdu(Buffer + 4, &BufLen);

    if (HRESULT_FROM_WIN32 (ERROR_MORE_DATA) == HResult)
    {
        // CODEWORK: Use Realloc ??
        EM_FREE(Buffer);
        Buffer = (BYTE *) EM_MALLOC(sizeof(BYTE)*(BufLen + 4));

        if (!Buffer) {
            return E_OUTOFMEMORY;
        }

        HResult = pQ931msg->EncodePdu(Buffer + 4, &BufLen);
        if (FAILED(HResult))
        {
            EM_FREE(Buffer);
            return HResult;
        }
    }

    SetupTPKTHeader(Buffer, BufLen);
    *ppReturnEncodedData = Buffer;
    *pReturnEncodedDataLength = BufLen + 4;
    
    return S_OK;
}


HRESULT DecodeQ931PDU(
        IN  BYTE *                      pbData,
        IN  DWORD                       dwDataLen,
        OUT Q931_MESSAGE**              ppReturnQ931msg,
        OUT H323_UserInformation **     ppReturnH323UserInfo
        )
{
    Q931_MESSAGE         *pQ931msg = NULL;
    H323_UserInformation *pDecodedH323UserInfo = NULL;
    HRESULT               HResult;
    
    *ppReturnQ931msg = NULL;
    *ppReturnH323UserInfo = NULL;

    pQ931msg = new Q931_MESSAGE();
    if (pQ931msg == NULL)
    {
        DebugF( _T("HandleRecvCompletion(): allocating pQ931msg failed\n"));
        return E_OUTOFMEMORY;
    }

    // Decode the PDU

    // This call "attaches" pbData to pQ931msg
    HResult = pQ931msg->AttachDecodePdu(
                  pbData, dwDataLen,
                  FALSE // Q931_MESSAGE should not free this buffer
                  );

    if (FAILED(HResult))
    {
        DebugF( _T("Decoding the Q.931 PDU Failed : 0x%x\n"), HResult);
        delete pQ931msg;
        return HResult;
    }

    // Get UUIE part
    
    Q931_IE *pInfoElement;

    // CODEWORK: We need a separate error to see if the UUIE element
    // is not present.
    HResult = pQ931msg->FindInfoElement(Q931_IE_USER_TO_USER, &pInfoElement);
    if (HResult != S_OK)
    {
        DebugF(_T("Decoding the Q.931 PDU Failed : 0x%x\n"), HResult);
        delete pQ931msg;
        return E_FAIL; // HResult;
    }

    _ASSERTE(pInfoElement != NULL);
    _ASSERTE(pInfoElement->Identifier == Q931_IE_USER_TO_USER);
    *ppReturnH323UserInfo = pInfoElement->Data.UserToUser.PduStructure;
    *ppReturnQ931msg = pQ931msg;

    return S_OK;

} // DecodeQ931PDU()


// CODEWORK: Move all the FreePDU functions into a
// separate file and share it in both
// emsend.cpp/emrecv.cpp
void FreeQ931PDU(
     IN Q931_MESSAGE           *pQ931msg,
     IN H323_UserInformation   *pH323UserInformation
     )
{
    HRESULT HResult;
    BYTE *Buffer = NULL;
    DWORD BufLen = 0;
    
    _ASSERTE(pQ931msg != NULL);

    // The buffer is attached to the Q931_MESSAGE structure and we
    // need to free it.
    HResult = pQ931msg->Detach(&Buffer, &BufLen);
    if (HResult == S_OK && Buffer != NULL)
    {
        EM_FREE(Buffer);
    }
    
    // pH323UserInformation is also freed by the destructor
    delete pQ931msg;
}

//////////////////////// CALL PROCEEDING PDU

// Static members used in encoding the CallProceeding PDU
// Note that the CallProceeding UUIE structure created holds
// pointers to these structures and someone freeing the structure
// should NEVER try free those pointers.
#if 0  // 0 ******* Region Commented Out Begins *******
const struct GatewayInfo_protocol GatewayProtocol = {
    NULL, 
};
#endif // 0 ******* Region Commented Out Ends   *******

#define OID_ELEMENT_LAST(Value) { NULL, Value }
#define OID_ELEMENT(Index,Value) { (ASN1objectidentifier_s *) &_OID_Q931ProtocolIdentifierV2 [Index], Value },

// this stores an unrolled constant linked list
const ASN1objectidentifier_s    _OID_Q931ProtocolIdentifierV2 [] = {
    OID_ELEMENT(1, 0)           // 0 = ITU-T
    OID_ELEMENT(2, 0)           // 0 = Recommendation
    OID_ELEMENT(3, 8)           // 8 = H Series
    OID_ELEMENT(4, 2250)        // 2250 = H.225.0
    OID_ELEMENT(5, 0)           // 0 = Version
    OID_ELEMENT_LAST(2)         // 2 = V2
};

/*++

  The user of this function needs to pass in pReturnQ931msg and
  pReturnH323UserInfo (probably allocated on the stack.

  // OLD OLD
  pReturnH323UserInfo is already added as UUIE to pReturnQ931msg.
  It is returned from this function so as to enable the caller to
  free it after sending the PDU.

  The user of this function needs to call
  delete *ppReturnQ931msg; and EM_FREE *ppReturnH323UserInfo;
  to free the allocated data.
  
  --*/
HRESULT Q931EncodeCallProceedingMessage(
    IN      WORD                    CallRefVal,
    IN OUT  Q931_MESSAGE           *pReturnQ931msg,
    IN OUT  H323_UserInformation   *pReturnH323UserInfo
    )
{
    HRESULT HResult;
    
    pReturnQ931msg->MessageType         = Q931_MESSAGE_TYPE_CALL_PROCEEDING;
    pReturnQ931msg->CallReferenceValue  = CallRefVal;

    // Fill in the ASN.1 UUIE part
    
    // This should zero out all the bit_masks and we set only what
    // are necessary.
    ZeroMemory(pReturnH323UserInfo, sizeof(H323_UserInformation));
    pReturnH323UserInfo->h323_uu_pdu.h323_message_body.choice =
        callProceeding_chosen;
        
    CallProceeding_UUIE *pCallProceedingPdu = 
        &pReturnH323UserInfo->h323_uu_pdu.h323_message_body.u.callProceeding;
    pCallProceedingPdu->protocolIdentifier =
        const_cast <ASN1objectidentifier_t> (_OID_Q931ProtocolIdentifierV2);
#if 0  // 0 ******* Region Commented Out Begins *******
    pCallProceedingPdu->destinationInfo.bit_mask = gateway_present;
    pCallProceedingPdu->destinationInfo.gateway.bit_mask = protocol_present;
#endif // 0 ******* Region Commented Out Ends   *******
    pCallProceedingPdu->destinationInfo.mc = FALSE;
    pCallProceedingPdu->destinationInfo.undefinedNode = FALSE;
    
    // Append the Information element.
    
    Q931_IE InfoElement;
    InfoElement.Identifier = Q931_IE_USER_TO_USER;
    InfoElement.Data.UserToUser.Type = Q931_UUIE_X208;
    InfoElement.Data.UserToUser.PduStructure = pReturnH323UserInfo;
    // Don't delete the PduStructure
    InfoElement.Data.UserToUser.IsOwner = FALSE;

    HResult = pReturnQ931msg->AppendInfoElement(&InfoElement);
    if (FAILED(HResult))
    {
        DebugF(_T("Failed to Append UUIE info element to CallProceeding PDU : 0x%x\n"),
                HResult);
        return HResult;
    }    

    return S_OK;
}


/*++

  The user of this function needs to pass in pReturnQ931msg and
  pReturnH323UserInfo (probably allocated on the stack.

  // OLD OLD
  pReturnH323UserInfo is already added as UUIE to pReturnQ931msg.
  It is returned from this function so as to enable the caller to
  free it after sending the PDU.

  The user of this function needs to call
  delete *ppReturnQ931msg; and EM_FREE *ppReturnH323UserInfo;
  to free the allocated data.
  
  --*/
HRESULT Q931EncodeReleaseCompleteMessage(
    IN      WORD                    CallRefVal,
    IN OUT  Q931_MESSAGE           *pReturnQ931msg,
    IN OUT  H323_UserInformation   *pReturnH323UserInfo
    )
{
    HRESULT HResult;
    
    pReturnQ931msg->MessageType         = Q931_MESSAGE_TYPE_RELEASE_COMPLETE;
    pReturnQ931msg->CallReferenceValue  = CallRefVal;

    // Fill in the ASN.1 UUIE part
    
    // This should zero out all the bit_masks and we set only what
    // are necessary.
    ZeroMemory(pReturnH323UserInfo, sizeof(H323_UserInformation));
    pReturnH323UserInfo->h323_uu_pdu.h323_message_body.choice =
        releaseComplete_chosen;
        
    ReleaseComplete_UUIE *pReleaseCompletePdu = 
        &pReturnH323UserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete;
    pReleaseCompletePdu->protocolIdentifier =
        const_cast <ASN1objectidentifier_t> (_OID_Q931ProtocolIdentifierV2);

    pReleaseCompletePdu->bit_mask |= ReleaseComplete_UUIE_reason_present;
    pReleaseCompletePdu->reason.choice =
        ReleaseCompleteReason_undefinedReason_chosen;
    
    // Append the Information element.
    
    Q931_IE InfoElement;
    InfoElement.Identifier = Q931_IE_USER_TO_USER;
    InfoElement.Data.UserToUser.Type = Q931_UUIE_X208;
    InfoElement.Data.UserToUser.PduStructure = pReturnH323UserInfo;
    // Don't delete the PduStructure
    InfoElement.Data.UserToUser.IsOwner = FALSE;

    HResult = pReturnQ931msg->AppendInfoElement(&InfoElement);
    if (FAILED(HResult))
    {
        DebugF(_T("Failed to Append UUIE info element to CallProceeding PDU : 0x%x\n"),
                HResult);
        return HResult;
    }    

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// H.245 PDUs                                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


/*++

Routine Description:

    Encodes the ASN part into a buffer which is sent on the wire.

Arguments:
    
    None.

Return Values:

    Returns S_OK in case of success or an error in case of failure.

--*/

HRESULT EncodeH245PDU(
	IN	MultimediaSystemControlMessage &rH245pdu,
	OUT	BYTE                          **ppReturnEncodedData,
	OUT	DWORD                          *pReturnEncodedDataLength)
{
	DWORD	Status;
    BYTE   *pH245Buf, *pBuf;
    DWORD   BufLen;

    // Initialize default return values.
    *ppReturnEncodedData        = NULL;
    *pReturnEncodedDataLength   = 0;
    
    _ASSERTE(ppReturnEncodedData != NULL);
    _ASSERTE(pReturnEncodedDataLength != NULL);
    
	Status = H245EncodePdu_MultimediaSystemControlMessage(
                  &rH245pdu,
                  &pH245Buf,
                  &BufLen);
    
	if (Status != NO_ERROR)
    {
        DebugF (_T("EncodeH245PDU: failed to encode H.245 pdu error: %d(0x%x)\n"),
                Status, Status);
        return HRESULT_FROM_WIN32(Status);
	}

    pBuf = (BYTE *) EM_MALLOC(BufLen + 4);

    if (pBuf == NULL)
    {
        DebugF (_T("EncodeH245PDU: failed to allocate buffer\n"));
        return E_OUTOFMEMORY;
    }
    
    CopyMemory(pBuf + 4, pH245Buf, BufLen);
    SetupTPKTHeader(pBuf, BufLen);
    H245FreeBuffer(pH245Buf);
    
    *ppReturnEncodedData = pBuf;
    *pReturnEncodedDataLength = BufLen + 4;

    return S_OK;
}


HRESULT DecodeH245PDU (
	IN  LPBYTE                              Data,
	IN  DWORD                               DataLength,
	OUT MultimediaSystemControlMessage    **ppReturnH245pdu)
{
	DWORD	Status;
    MultimediaSystemControlMessage *pDecodedH245pdu = NULL;

    *ppReturnH245pdu = NULL;

	Status = H245DecodePdu_MultimediaSystemControlMessage(Data,
                                                          DataLength,
                                                          &pDecodedH245pdu
                                                          );
    if (ASN1_FAILED (Status))
    {
        DebugF( _T("DecodeH245PDU: Failed to decode H.245 pdu length: ")
                _T("%d error: %d(0x%x)\n"),
                DataLength, Status, Status);

        DumpMemory (Data, DataLength);

        return HRESULT_FROM_WIN32(Status);
    }

    *ppReturnH245pdu = pDecodedH245pdu;
	return S_OK;
}


void FreeH245PDU(
     MultimediaSystemControlMessage *pH245pdu
     )
{
    if (pH245pdu != NULL)
    {
		H245FreePdu_MultimediaSystemControlMessage(pH245pdu);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\iocompl.h ===
void HandleSendCompletion(PSendRecvContext pSendCtxt, DWORD dwNumRead,
			 DWORD status);
void HandleRecvCompletion(PSendRecvContext pRecvCtxt, DWORD dwNumRead,
			 DWORD status);
void HandleAcceptCompletion(PAcceptContext pAcceptCtxt, DWORD status);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\intfc.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
        intfc.h

Abstract:
        Declarations of data types and constants used to provide
        multiple-interface support in H.323/LDAP proxy.
        

Revision History:
        03/01/2000      File creation.      Ilya Kleyman (IlyaK)
    
--*/
#ifndef	__nath323_intfc_h
#define	__nath323_intfc_h

class PROXY_INTERFACE {
    
    friend class PROXY_INTERFACE_ARRAY;

private:

    H323_INTERFACE_TYPE InterfaceType;  // public or private
    ULONG               Index;
    DWORD			    Address;		// host order
    DWORD			    Mask;			// host order
    ULONG               AdapterIndex;

    HANDLE              Q931RedirectHandle;
    HANDLE              LdapRedirectHandle1;
    HANDLE              LdapRedirectHandle2;

    HANDLE              Q931LocalRedirectHandle;
    HANDLE              LdapLocalRedirectHandle1;
    HANDLE              LdapLocalRedirectHandle2;

    IP_NAT_PORT_MAPPING Q931PortMapping;
    IP_NAT_PORT_MAPPING LdapPortMapping;
    IP_NAT_PORT_MAPPING LdapAltPortMapping;

private:

    ULONG 
    StartNatRedirects (
        void
        );

    void 
    StopNatRedirects (
        void
        );

    ULONG
    StartQ931ReceiveRedirect (
        void
        );

    void
    StopQ931ReceiveRedirect (
        void
        );

public:

    PROXY_INTERFACE (
        IN ULONG ArgIndex,
        IN H323_INTERFACE_TYPE ArgInterfaceType,
        IN PIP_ADAPTER_BINDING_INFO BindingInfo
        );

    ~PROXY_INTERFACE (
        void
        );

    DWORD 
    GetIndex (
        void
        ) const 
    { 
        return Index; 
    }

    ULONG 
    Start (
        void
        );

    void 
    Stop ( 
        void
        );

    BOOL
    IsFirewalled (
        void
        );

    BOOL 
    IsPrivate (
        void
        );

    BOOL 
    IsPublic (
        void
        );

    BOOL
    HasQ931PortMapping (
        void
        );

    BOOL
    HasLdapPortMapping (
        void
        );

    BOOL
    HasLdapAltPortMapping (
        void
        );

    ULONG
    GetQ931PortMappingDestination (
        void
        );

    ULONG
    GetLdapPortMappingDestination (
        void
        );

    ULONG
    GetLdapAltPortMappingDestination (
        void
        );
};


class PROXY_INTERFACE_ARRAY :
public SIMPLE_CRITICAL_SECTION_BASE {
private:
    DYNAMIC_ARRAY <PROXY_INTERFACE *> Array;
    LONG Q931ReceiveRedirectStartCount; 

private:

    HRESULT 
    Add (
        IN PROXY_INTERFACE * Interface
        );

    PROXY_INTERFACE * 
    RemoveByIndex ( 
        IN DWORD Index
        );

    PROXY_INTERFACE ** 
    FindByIndex (
        IN DWORD InterfaceIndex
        );

public:

    PROXY_INTERFACE_ARRAY ()
    {

        Q931ReceiveRedirectStartCount = 0;

    }

	// only called during service shutdown to assert that all 
	// interfaces have been previously deactivated
	void 
    AssertShutdownReady (
        void
        ) 
    {
		assert (Array.GetLength() == 0);
	}

    HRESULT 
    IsPrivateAddress (
        IN	DWORD	Address,			// host order
        OUT BOOL  * IsPrivate
        );

    HRESULT 
    IsPublicAddress (
        IN	DWORD	Address,			// host order
        OUT BOOL *  IsPublic
        ); 

    ULONG 
    AddStartInterface (
        IN ULONG Index,
        IN H323_INTERFACE_TYPE InterfaceType,
        IN PIP_ADAPTER_BINDING_INFO BindingInfo
        );

    void 
    RemoveStopInterface (
        IN DWORD Index
        );

    void 
    Stop (
        void
        );

    void
    StartQ931ReceiveRedirects (
        void
        );

    void
    StopQ931ReceiveRedirects (
        void
        );
};

extern PROXY_INTERFACE_ARRAY InterfaceArray;

HRESULT
IsPrivateAddress (
    IN DWORD   Address,
    OUT BOOL * IsPrivate
    );

HRESULT
IsPublicAddress (
    IN DWORD   Address,
    OUT BOOL * IsPublic
    );

#endif // __nath323_intfc_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\ldap.c ===
#include <windows.h>
#include "ldap.h"

ASN1module_t LDAP_Module = NULL;

static int ASN1CALL ASN1Enc_SearchResponse_entry_attributes_Seq_values(ASN1encoding_t enc, ASN1uint32_t tag, PSearchResponse_entry_attributes_Seq_values *val);
static int ASN1CALL ASN1Enc_ModifyRequest_modifications_Seq_modification_values(ASN1encoding_t enc, ASN1uint32_t tag, PModifyRequest_modifications_Seq_modification_values *val);
static int ASN1CALL ASN1Enc_AddRequest_attrs_Seq_values(ASN1encoding_t enc, ASN1uint32_t tag, PAddRequest_attrs_Seq_values *val);
static int ASN1CALL ASN1Enc_ModifyRequest_modifications_Seq_modification(ASN1encoding_t enc, ASN1uint32_t tag, ModifyRequest_modifications_Seq_modification *val);
static int ASN1CALL ASN1Enc_SearchResponse_entry_attributes_Seq(ASN1encoding_t enc, ASN1uint32_t tag, SearchResponse_entry_attributes_Seq *val);
static int ASN1CALL ASN1Enc_SearchResponse_entry_attributes(ASN1encoding_t enc, ASN1uint32_t tag, PSearchResponse_entry_attributes *val);
static int ASN1CALL ASN1Enc_ModifyRequest_modifications_Seq(ASN1encoding_t enc, ASN1uint32_t tag, ModifyRequest_modifications_Seq *val);
static int ASN1CALL ASN1Enc_AddRequest_attrs_Seq(ASN1encoding_t enc, ASN1uint32_t tag, AddRequest_attrs_Seq *val);
static int ASN1CALL ASN1Enc_SubstringFilter_attributes_Seq(ASN1encoding_t enc, ASN1uint32_t tag, SubstringFilter_attributes_Seq *val);
static int ASN1CALL ASN1Enc_SubstringFilter_attributes(ASN1encoding_t enc, ASN1uint32_t tag, PSubstringFilter_attributes *val);
static int ASN1CALL ASN1Enc_AddRequest_attrs(ASN1encoding_t enc, ASN1uint32_t tag, PAddRequest_attrs *val);
static int ASN1CALL ASN1Enc_ModifyRequest_modifications(ASN1encoding_t enc, ASN1uint32_t tag, PModifyRequest_modifications *val);
static int ASN1CALL ASN1Enc_SearchResponse_entry(ASN1encoding_t enc, ASN1uint32_t tag, SearchResponse_entry *val);
static int ASN1CALL ASN1Enc_SearchRequest_attributes(ASN1encoding_t enc, ASN1uint32_t tag, PSearchRequest_attributes *val);
static int ASN1CALL ASN1Enc_SaslCredentials(ASN1encoding_t enc, ASN1uint32_t tag, SaslCredentials *val);
static int ASN1CALL ASN1Enc_ModifyRequest(ASN1encoding_t enc, ASN1uint32_t tag, ModifyRequest *val);
static int ASN1CALL ASN1Enc_AddRequest(ASN1encoding_t enc, ASN1uint32_t tag, AddRequest *val);
static int ASN1CALL ASN1Enc_ModifyRDNRequest(ASN1encoding_t enc, ASN1uint32_t tag, ModifyRDNRequest *val);
static int ASN1CALL ASN1Enc_LDAPResult(ASN1encoding_t enc, ASN1uint32_t tag, LDAPResult *val);
static int ASN1CALL ASN1Enc_AttributeValueAssertion(ASN1encoding_t enc, ASN1uint32_t tag, AttributeValueAssertion *val);
static int ASN1CALL ASN1Enc_SubstringFilter(ASN1encoding_t enc, ASN1uint32_t tag, SubstringFilter *val);
static int ASN1CALL ASN1Enc_AuthenticationChoice(ASN1encoding_t enc, ASN1uint32_t tag, AuthenticationChoice *val);
static int ASN1CALL ASN1Enc_BindResponse(ASN1encoding_t enc, ASN1uint32_t tag, BindResponse *val);
static int ASN1CALL ASN1Enc_SearchResponse(ASN1encoding_t enc, ASN1uint32_t tag, SearchResponse *val);
static int ASN1CALL ASN1Enc_ModifyResponse(ASN1encoding_t enc, ASN1uint32_t tag, ModifyResponse *val);
static int ASN1CALL ASN1Enc_AddResponse(ASN1encoding_t enc, ASN1uint32_t tag, AddResponse *val);
static int ASN1CALL ASN1Enc_DelResponse(ASN1encoding_t enc, ASN1uint32_t tag, DelResponse *val);
static int ASN1CALL ASN1Enc_ModifyRDNResponse(ASN1encoding_t enc, ASN1uint32_t tag, ModifyRDNResponse *val);
static int ASN1CALL ASN1Enc_CompareRequest(ASN1encoding_t enc, ASN1uint32_t tag, CompareRequest *val);
static int ASN1CALL ASN1Enc_CompareResponse(ASN1encoding_t enc, ASN1uint32_t tag, CompareResponse *val);
static int ASN1CALL ASN1Enc_Filter(ASN1encoding_t enc, ASN1uint32_t tag, Filter *val);
static int ASN1CALL ASN1Enc_Filter_or(ASN1encoding_t enc, ASN1uint32_t tag, PFilter_or *val);
static int ASN1CALL ASN1Enc_Filter_and(ASN1encoding_t enc, ASN1uint32_t tag, PFilter_and *val);
static int ASN1CALL ASN1Enc_BindRequest(ASN1encoding_t enc, ASN1uint32_t tag, BindRequest *val);
static int ASN1CALL ASN1Enc_SearchRequest(ASN1encoding_t enc, ASN1uint32_t tag, SearchRequest *val);
static int ASN1CALL ASN1Enc_LDAPMessage_protocolOp(ASN1encoding_t enc, ASN1uint32_t tag, LDAPMessage_protocolOp *val);
static int ASN1CALL ASN1Enc_LDAPMessage(ASN1encoding_t enc, ASN1uint32_t tag, LDAPMessage *val);
static int ASN1CALL ASN1Dec_SearchResponse_entry_attributes_Seq_values(ASN1decoding_t dec, ASN1uint32_t tag, PSearchResponse_entry_attributes_Seq_values *val);
static int ASN1CALL ASN1Dec_ModifyRequest_modifications_Seq_modification_values(ASN1decoding_t dec, ASN1uint32_t tag, PModifyRequest_modifications_Seq_modification_values *val);
static int ASN1CALL ASN1Dec_AddRequest_attrs_Seq_values(ASN1decoding_t dec, ASN1uint32_t tag, PAddRequest_attrs_Seq_values *val);
static int ASN1CALL ASN1Dec_ModifyRequest_modifications_Seq_modification(ASN1decoding_t dec, ASN1uint32_t tag, ModifyRequest_modifications_Seq_modification *val);
static int ASN1CALL ASN1Dec_SearchResponse_entry_attributes_Seq(ASN1decoding_t dec, ASN1uint32_t tag, SearchResponse_entry_attributes_Seq *val);
static int ASN1CALL ASN1Dec_SearchResponse_entry_attributes(ASN1decoding_t dec, ASN1uint32_t tag, PSearchResponse_entry_attributes *val);
static int ASN1CALL ASN1Dec_ModifyRequest_modifications_Seq(ASN1decoding_t dec, ASN1uint32_t tag, ModifyRequest_modifications_Seq *val);
static int ASN1CALL ASN1Dec_AddRequest_attrs_Seq(ASN1decoding_t dec, ASN1uint32_t tag, AddRequest_attrs_Seq *val);
static int ASN1CALL ASN1Dec_SubstringFilter_attributes_Seq(ASN1decoding_t dec, ASN1uint32_t tag, SubstringFilter_attributes_Seq *val);
static int ASN1CALL ASN1Dec_SubstringFilter_attributes(ASN1decoding_t dec, ASN1uint32_t tag, PSubstringFilter_attributes *val);
static int ASN1CALL ASN1Dec_AddRequest_attrs(ASN1decoding_t dec, ASN1uint32_t tag, PAddRequest_attrs *val);
static int ASN1CALL ASN1Dec_ModifyRequest_modifications(ASN1decoding_t dec, ASN1uint32_t tag, PModifyRequest_modifications *val);
static int ASN1CALL ASN1Dec_SearchResponse_entry(ASN1decoding_t dec, ASN1uint32_t tag, SearchResponse_entry *val);
static int ASN1CALL ASN1Dec_SearchRequest_attributes(ASN1decoding_t dec, ASN1uint32_t tag, PSearchRequest_attributes *val);
static int ASN1CALL ASN1Dec_SaslCredentials(ASN1decoding_t dec, ASN1uint32_t tag, SaslCredentials *val);
static int ASN1CALL ASN1Dec_ModifyRequest(ASN1decoding_t dec, ASN1uint32_t tag, ModifyRequest *val);
static int ASN1CALL ASN1Dec_AddRequest(ASN1decoding_t dec, ASN1uint32_t tag, AddRequest *val);
static int ASN1CALL ASN1Dec_ModifyRDNRequest(ASN1decoding_t dec, ASN1uint32_t tag, ModifyRDNRequest *val);
static int ASN1CALL ASN1Dec_LDAPResult(ASN1decoding_t dec, ASN1uint32_t tag, LDAPResult *val);
static int ASN1CALL ASN1Dec_AttributeValueAssertion(ASN1decoding_t dec, ASN1uint32_t tag, AttributeValueAssertion *val);
static int ASN1CALL ASN1Dec_SubstringFilter(ASN1decoding_t dec, ASN1uint32_t tag, SubstringFilter *val);
static int ASN1CALL ASN1Dec_AuthenticationChoice(ASN1decoding_t dec, ASN1uint32_t tag, AuthenticationChoice *val);
static int ASN1CALL ASN1Dec_BindResponse(ASN1decoding_t dec, ASN1uint32_t tag, BindResponse *val);
static int ASN1CALL ASN1Dec_SearchResponse(ASN1decoding_t dec, ASN1uint32_t tag, SearchResponse *val);
static int ASN1CALL ASN1Dec_ModifyResponse(ASN1decoding_t dec, ASN1uint32_t tag, ModifyResponse *val);
static int ASN1CALL ASN1Dec_AddResponse(ASN1decoding_t dec, ASN1uint32_t tag, AddResponse *val);
static int ASN1CALL ASN1Dec_DelResponse(ASN1decoding_t dec, ASN1uint32_t tag, DelResponse *val);
static int ASN1CALL ASN1Dec_ModifyRDNResponse(ASN1decoding_t dec, ASN1uint32_t tag, ModifyRDNResponse *val);
static int ASN1CALL ASN1Dec_CompareRequest(ASN1decoding_t dec, ASN1uint32_t tag, CompareRequest *val);
static int ASN1CALL ASN1Dec_CompareResponse(ASN1decoding_t dec, ASN1uint32_t tag, CompareResponse *val);
static int ASN1CALL ASN1Dec_Filter(ASN1decoding_t dec, ASN1uint32_t tag, Filter *val);
static int ASN1CALL ASN1Dec_Filter_or(ASN1decoding_t dec, ASN1uint32_t tag, PFilter_or *val);
static int ASN1CALL ASN1Dec_Filter_and(ASN1decoding_t dec, ASN1uint32_t tag, PFilter_and *val);
static int ASN1CALL ASN1Dec_BindRequest(ASN1decoding_t dec, ASN1uint32_t tag, BindRequest *val);
static int ASN1CALL ASN1Dec_SearchRequest(ASN1decoding_t dec, ASN1uint32_t tag, SearchRequest *val);
static int ASN1CALL ASN1Dec_LDAPMessage_protocolOp(ASN1decoding_t dec, ASN1uint32_t tag, LDAPMessage_protocolOp *val);
static int ASN1CALL ASN1Dec_LDAPMessage(ASN1decoding_t dec, ASN1uint32_t tag, LDAPMessage *val);
static void ASN1CALL ASN1Free_SearchResponse_entry_attributes_Seq_values(PSearchResponse_entry_attributes_Seq_values *val);
static void ASN1CALL ASN1Free_ModifyRequest_modifications_Seq_modification_values(PModifyRequest_modifications_Seq_modification_values *val);
static void ASN1CALL ASN1Free_AddRequest_attrs_Seq_values(PAddRequest_attrs_Seq_values *val);
static void ASN1CALL ASN1Free_ModifyRequest_modifications_Seq_modification(ModifyRequest_modifications_Seq_modification *val);
static void ASN1CALL ASN1Free_SearchResponse_entry_attributes_Seq(SearchResponse_entry_attributes_Seq *val);
static void ASN1CALL ASN1Free_SearchResponse_entry_attributes(PSearchResponse_entry_attributes *val);
static void ASN1CALL ASN1Free_ModifyRequest_modifications_Seq(ModifyRequest_modifications_Seq *val);
static void ASN1CALL ASN1Free_AddRequest_attrs_Seq(AddRequest_attrs_Seq *val);
static void ASN1CALL ASN1Free_SubstringFilter_attributes_Seq(SubstringFilter_attributes_Seq *val);
static void ASN1CALL ASN1Free_SubstringFilter_attributes(PSubstringFilter_attributes *val);
static void ASN1CALL ASN1Free_AddRequest_attrs(PAddRequest_attrs *val);
static void ASN1CALL ASN1Free_ModifyRequest_modifications(PModifyRequest_modifications *val);
static void ASN1CALL ASN1Free_SearchResponse_entry(SearchResponse_entry *val);
static void ASN1CALL ASN1Free_SearchRequest_attributes(PSearchRequest_attributes *val);
static void ASN1CALL ASN1Free_SaslCredentials(SaslCredentials *val);
static void ASN1CALL ASN1Free_ModifyRequest(ModifyRequest *val);
static void ASN1CALL ASN1Free_AddRequest(AddRequest *val);
static void ASN1CALL ASN1Free_ModifyRDNRequest(ModifyRDNRequest *val);
static void ASN1CALL ASN1Free_LDAPResult(LDAPResult *val);
static void ASN1CALL ASN1Free_AttributeValueAssertion(AttributeValueAssertion *val);
static void ASN1CALL ASN1Free_SubstringFilter(SubstringFilter *val);
static void ASN1CALL ASN1Free_AuthenticationChoice(AuthenticationChoice *val);
static void ASN1CALL ASN1Free_BindResponse(BindResponse *val);
static void ASN1CALL ASN1Free_SearchResponse(SearchResponse *val);
static void ASN1CALL ASN1Free_ModifyResponse(ModifyResponse *val);
static void ASN1CALL ASN1Free_AddResponse(AddResponse *val);
static void ASN1CALL ASN1Free_DelResponse(DelResponse *val);
static void ASN1CALL ASN1Free_ModifyRDNResponse(ModifyRDNResponse *val);
static void ASN1CALL ASN1Free_CompareRequest(CompareRequest *val);
static void ASN1CALL ASN1Free_CompareResponse(CompareResponse *val);
static void ASN1CALL ASN1Free_Filter(Filter *val);
static void ASN1CALL ASN1Free_Filter_or(PFilter_or *val);
static void ASN1CALL ASN1Free_Filter_and(PFilter_and *val);
static void ASN1CALL ASN1Free_BindRequest(BindRequest *val);
static void ASN1CALL ASN1Free_SearchRequest(SearchRequest *val);
static void ASN1CALL ASN1Free_LDAPMessage_protocolOp(LDAPMessage_protocolOp *val);
static void ASN1CALL ASN1Free_LDAPMessage(LDAPMessage *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[1] = {
    (ASN1EncFun_t) ASN1Enc_LDAPMessage,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[1] = {
    (ASN1DecFun_t) ASN1Dec_LDAPMessage,
};
static const ASN1FreeFun_t freefntab[1] = {
    (ASN1FreeFun_t) ASN1Free_LDAPMessage,
};
static const ULONG sizetab[1] = {
    SIZE_LDAP_Module_ID_0,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */
ASN1int32_t maxInt = 2147483647;

void ASN1CALL LDAP_Module_Startup(void)
{
    LDAP_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_BER, ASN1FLAGS_NONE, 1, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x0);
}

void ASN1CALL LDAP_Module_Cleanup(void)
{
    ASN1_CloseModule(LDAP_Module);
    LDAP_Module = NULL;
}

static int ASN1CALL ASN1Enc_SearchResponse_entry_attributes_Seq_values(ASN1encoding_t enc, ASN1uint32_t tag, PSearchResponse_entry_attributes_Seq_values *val)
{
    PSearchResponse_entry_attributes_Seq_values f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncOctetString(enc, 0x4, (f->value).length, (f->value).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SearchResponse_entry_attributes_Seq_values(ASN1decoding_t dec, ASN1uint32_t tag, PSearchResponse_entry_attributes_Seq_values *val)
{
    PSearchResponse_entry_attributes_Seq_values *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PSearchResponse_entry_attributes_Seq_values)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecOctetString(dd, 0x4, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SearchResponse_entry_attributes_Seq_values(PSearchResponse_entry_attributes_Seq_values *val)
{
    PSearchResponse_entry_attributes_Seq_values f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1octetstring_free(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_ModifyRequest_modifications_Seq_modification_values(ASN1encoding_t enc, ASN1uint32_t tag, PModifyRequest_modifications_Seq_modification_values *val)
{
    PModifyRequest_modifications_Seq_modification_values f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncOctetString(enc, 0x4, (f->value).length, (f->value).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ModifyRequest_modifications_Seq_modification_values(ASN1decoding_t dec, ASN1uint32_t tag, PModifyRequest_modifications_Seq_modification_values *val)
{
    PModifyRequest_modifications_Seq_modification_values *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PModifyRequest_modifications_Seq_modification_values)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecOctetString(dd, 0x4, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ModifyRequest_modifications_Seq_modification_values(PModifyRequest_modifications_Seq_modification_values *val)
{
    PModifyRequest_modifications_Seq_modification_values f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1octetstring_free(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_AddRequest_attrs_Seq_values(ASN1encoding_t enc, ASN1uint32_t tag, PAddRequest_attrs_Seq_values *val)
{
    PAddRequest_attrs_Seq_values f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncOctetString(enc, 0x4, (f->value).length, (f->value).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AddRequest_attrs_Seq_values(ASN1decoding_t dec, ASN1uint32_t tag, PAddRequest_attrs_Seq_values *val)
{
    PAddRequest_attrs_Seq_values *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PAddRequest_attrs_Seq_values)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecOctetString(dd, 0x4, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AddRequest_attrs_Seq_values(PAddRequest_attrs_Seq_values *val)
{
    PAddRequest_attrs_Seq_values f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1octetstring_free(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_ModifyRequest_modifications_Seq_modification(ASN1encoding_t enc, ASN1uint32_t tag, ModifyRequest_modifications_Seq_modification *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->type).length, ((val)->type).value))
	return 0;
    if (!ASN1Enc_ModifyRequest_modifications_Seq_modification_values(enc, 0, &(val)->values))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ModifyRequest_modifications_Seq_modification(ASN1decoding_t dec, ASN1uint32_t tag, ModifyRequest_modifications_Seq_modification *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->type))
	return 0;
    if (!ASN1Dec_ModifyRequest_modifications_Seq_modification_values(dd, 0, &(val)->values))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ModifyRequest_modifications_Seq_modification(ModifyRequest_modifications_Seq_modification *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->type);
	ASN1Free_ModifyRequest_modifications_Seq_modification_values(&(val)->values);
    }
}

static int ASN1CALL ASN1Enc_SearchResponse_entry_attributes_Seq(ASN1encoding_t enc, ASN1uint32_t tag, SearchResponse_entry_attributes_Seq *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->type).length, ((val)->type).value))
	return 0;
    if (!ASN1Enc_SearchResponse_entry_attributes_Seq_values(enc, 0, &(val)->values))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SearchResponse_entry_attributes_Seq(ASN1decoding_t dec, ASN1uint32_t tag, SearchResponse_entry_attributes_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->type))
	return 0;
    if (!ASN1Dec_SearchResponse_entry_attributes_Seq_values(dd, 0, &(val)->values))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SearchResponse_entry_attributes_Seq(SearchResponse_entry_attributes_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->type);
	ASN1Free_SearchResponse_entry_attributes_Seq_values(&(val)->values);
    }
}

static int ASN1CALL ASN1Enc_SearchResponse_entry_attributes(ASN1encoding_t enc, ASN1uint32_t tag, PSearchResponse_entry_attributes *val)
{
    PSearchResponse_entry_attributes f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_SearchResponse_entry_attributes_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SearchResponse_entry_attributes(ASN1decoding_t dec, ASN1uint32_t tag, PSearchResponse_entry_attributes *val)
{
    PSearchResponse_entry_attributes *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PSearchResponse_entry_attributes)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_SearchResponse_entry_attributes_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SearchResponse_entry_attributes(PSearchResponse_entry_attributes *val)
{
    PSearchResponse_entry_attributes f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_SearchResponse_entry_attributes_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_ModifyRequest_modifications_Seq(ASN1encoding_t enc, ASN1uint32_t tag, ModifyRequest_modifications_Seq *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0xa, (val)->operation))
	return 0;
    if (!ASN1Enc_ModifyRequest_modifications_Seq_modification(enc, 0, &(val)->modification))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ModifyRequest_modifications_Seq(ASN1decoding_t dec, ASN1uint32_t tag, ModifyRequest_modifications_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0xa, (ASN1uint32_t *) &(val)->operation))
	return 0;
    if (!ASN1Dec_ModifyRequest_modifications_Seq_modification(dd, 0, &(val)->modification))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ModifyRequest_modifications_Seq(ModifyRequest_modifications_Seq *val)
{
    if (val) {
	ASN1Free_ModifyRequest_modifications_Seq_modification(&(val)->modification);
    }
}

static int ASN1CALL ASN1Enc_AddRequest_attrs_Seq(ASN1encoding_t enc, ASN1uint32_t tag, AddRequest_attrs_Seq *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->type).length, ((val)->type).value))
	return 0;
    if (!ASN1Enc_AddRequest_attrs_Seq_values(enc, 0, &(val)->values))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AddRequest_attrs_Seq(ASN1decoding_t dec, ASN1uint32_t tag, AddRequest_attrs_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->type))
	return 0;
    if (!ASN1Dec_AddRequest_attrs_Seq_values(dd, 0, &(val)->values))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AddRequest_attrs_Seq(AddRequest_attrs_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->type);
	ASN1Free_AddRequest_attrs_Seq_values(&(val)->values);
    }
}

static int ASN1CALL ASN1Enc_SubstringFilter_attributes_Seq(ASN1encoding_t enc, ASN1uint32_t tag, SubstringFilter_attributes_Seq *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncOctetString(enc, 0x80000000, ((val)->u.initial).length, ((val)->u.initial).value))
	    return 0;
	break;
    case 2:
	if (!ASN1BEREncOctetString(enc, 0x80000001, ((val)->u.any).length, ((val)->u.any).value))
	    return 0;
	break;
    case 3:
	if (!ASN1BEREncOctetString(enc, 0x80000002, ((val)->u.final).length, ((val)->u.final).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SubstringFilter_attributes_Seq(ASN1decoding_t dec, ASN1uint32_t tag, SubstringFilter_attributes_Seq *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecOctetString(dec, 0x80000000, &(val)->u.initial))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000001, &(val)->u.any))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1BERDecOctetString(dec, 0x80000002, &(val)->u.final))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SubstringFilter_attributes_Seq(SubstringFilter_attributes_Seq *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1octetstring_free(&(val)->u.initial);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.any);
	    break;
	case 3:
	    ASN1octetstring_free(&(val)->u.final);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_SubstringFilter_attributes(ASN1encoding_t enc, ASN1uint32_t tag, PSubstringFilter_attributes *val)
{
    PSubstringFilter_attributes f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_SubstringFilter_attributes_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SubstringFilter_attributes(ASN1decoding_t dec, ASN1uint32_t tag, PSubstringFilter_attributes *val)
{
    PSubstringFilter_attributes *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PSubstringFilter_attributes)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_SubstringFilter_attributes_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SubstringFilter_attributes(PSubstringFilter_attributes *val)
{
    PSubstringFilter_attributes f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_SubstringFilter_attributes_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_AddRequest_attrs(ASN1encoding_t enc, ASN1uint32_t tag, PAddRequest_attrs *val)
{
    PAddRequest_attrs f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_AddRequest_attrs_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AddRequest_attrs(ASN1decoding_t dec, ASN1uint32_t tag, PAddRequest_attrs *val)
{
    PAddRequest_attrs *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PAddRequest_attrs)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_AddRequest_attrs_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AddRequest_attrs(PAddRequest_attrs *val)
{
    PAddRequest_attrs f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_AddRequest_attrs_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_ModifyRequest_modifications(ASN1encoding_t enc, ASN1uint32_t tag, PModifyRequest_modifications *val)
{
    PModifyRequest_modifications f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_ModifyRequest_modifications_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ModifyRequest_modifications(ASN1decoding_t dec, ASN1uint32_t tag, PModifyRequest_modifications *val)
{
    PModifyRequest_modifications *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PModifyRequest_modifications)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_ModifyRequest_modifications_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ModifyRequest_modifications(PModifyRequest_modifications *val)
{
    PModifyRequest_modifications f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_ModifyRequest_modifications_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_SearchResponse_entry(ASN1encoding_t enc, ASN1uint32_t tag, SearchResponse_entry *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000004, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->objectName).length, ((val)->objectName).value))
	return 0;
    if (!ASN1Enc_SearchResponse_entry_attributes(enc, 0, &(val)->attributes))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SearchResponse_entry(ASN1decoding_t dec, ASN1uint32_t tag, SearchResponse_entry *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000004, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->objectName))
	return 0;
    if (!ASN1Dec_SearchResponse_entry_attributes(dd, 0, &(val)->attributes))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SearchResponse_entry(SearchResponse_entry *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->objectName);
	ASN1Free_SearchResponse_entry_attributes(&(val)->attributes);
    }
}

static int ASN1CALL ASN1Enc_SearchRequest_attributes(ASN1encoding_t enc, ASN1uint32_t tag, PSearchRequest_attributes *val)
{
    PSearchRequest_attributes f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncOctetString(enc, 0x4, (f->value).length, (f->value).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SearchRequest_attributes(ASN1decoding_t dec, ASN1uint32_t tag, PSearchRequest_attributes *val)
{
    PSearchRequest_attributes *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PSearchRequest_attributes)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecOctetString(dd, 0x4, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SearchRequest_attributes(PSearchRequest_attributes *val)
{
    PSearchRequest_attributes f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1octetstring_free(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_SaslCredentials(ASN1encoding_t enc, ASN1uint32_t tag, SaslCredentials *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->mechanism).length, ((val)->mechanism).value))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->credentials).length, ((val)->credentials).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SaslCredentials(ASN1decoding_t dec, ASN1uint32_t tag, SaslCredentials *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->mechanism))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->credentials))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SaslCredentials(SaslCredentials *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->mechanism);
	ASN1octetstring_free(&(val)->credentials);
    }
}

static int ASN1CALL ASN1Enc_ModifyRequest(ASN1encoding_t enc, ASN1uint32_t tag, ModifyRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000006, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->object).length, ((val)->object).value))
	return 0;
    if (!ASN1Enc_ModifyRequest_modifications(enc, 0, &(val)->modifications))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ModifyRequest(ASN1decoding_t dec, ASN1uint32_t tag, ModifyRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000006, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->object))
	return 0;
    if (!ASN1Dec_ModifyRequest_modifications(dd, 0, &(val)->modifications))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ModifyRequest(ModifyRequest *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->object);
	ASN1Free_ModifyRequest_modifications(&(val)->modifications);
    }
}

static int ASN1CALL ASN1Enc_AddRequest(ASN1encoding_t enc, ASN1uint32_t tag, AddRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000008, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->entry).length, ((val)->entry).value))
	return 0;
    if (!ASN1Enc_AddRequest_attrs(enc, 0, &(val)->attrs))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AddRequest(ASN1decoding_t dec, ASN1uint32_t tag, AddRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000008, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->entry))
	return 0;
    if (!ASN1Dec_AddRequest_attrs(dd, 0, &(val)->attrs))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AddRequest(AddRequest *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->entry);
	ASN1Free_AddRequest_attrs(&(val)->attrs);
    }
}

static int ASN1CALL ASN1Enc_ModifyRDNRequest(ASN1encoding_t enc, ASN1uint32_t tag, ModifyRDNRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000c, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->entry).length, ((val)->entry).value))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->newrdn).length, ((val)->newrdn).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ModifyRDNRequest(ASN1decoding_t dec, ASN1uint32_t tag, ModifyRDNRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000c, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->entry))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->newrdn))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ModifyRDNRequest(ModifyRDNRequest *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->entry);
	ASN1octetstring_free(&(val)->newrdn);
    }
}

static int ASN1CALL ASN1Enc_LDAPResult(ASN1encoding_t enc, ASN1uint32_t tag, LDAPResult *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0xa, (val)->resultCode))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->matchedDN).length, ((val)->matchedDN).value))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->errorMessage).length, ((val)->errorMessage).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LDAPResult(ASN1decoding_t dec, ASN1uint32_t tag, LDAPResult *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0xa, (ASN1uint32_t *) &(val)->resultCode))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->matchedDN))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->errorMessage))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LDAPResult(LDAPResult *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->matchedDN);
	ASN1octetstring_free(&(val)->errorMessage);
    }
}

static int ASN1CALL ASN1Enc_AttributeValueAssertion(ASN1encoding_t enc, ASN1uint32_t tag, AttributeValueAssertion *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->attributeType).length, ((val)->attributeType).value))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->attributeValue).length, ((val)->attributeValue).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeValueAssertion(ASN1decoding_t dec, ASN1uint32_t tag, AttributeValueAssertion *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->attributeType))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->attributeValue))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeValueAssertion(AttributeValueAssertion *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->attributeType);
	ASN1octetstring_free(&(val)->attributeValue);
    }
}

static int ASN1CALL ASN1Enc_SubstringFilter(ASN1encoding_t enc, ASN1uint32_t tag, SubstringFilter *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->type).length, ((val)->type).value))
	return 0;
    if (!ASN1Enc_SubstringFilter_attributes(enc, 0, &(val)->attributes))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SubstringFilter(ASN1decoding_t dec, ASN1uint32_t tag, SubstringFilter *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->type))
	return 0;
    if (!ASN1Dec_SubstringFilter_attributes(dd, 0, &(val)->attributes))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SubstringFilter(SubstringFilter *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->type);
	ASN1Free_SubstringFilter_attributes(&(val)->attributes);
    }
}

static int ASN1CALL ASN1Enc_AuthenticationChoice(ASN1encoding_t enc, ASN1uint32_t tag, AuthenticationChoice *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncOctetString(enc, 0x80000000, ((val)->u.simple).length, ((val)->u.simple).value))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_SaslCredentials(enc, 0x80000003, &(val)->u.sasl))
	    return 0;
	break;
    case 3:
	if (!ASN1BEREncOctetString(enc, 0x80000009, ((val)->u.sicilyNegotiate).length, ((val)->u.sicilyNegotiate).value))
	    return 0;
	break;
    case 4:
	if (!ASN1BEREncOctetString(enc, 0x8000000a, ((val)->u.sicilyInitial).length, ((val)->u.sicilyInitial).value))
	    return 0;
	break;
    case 5:
	if (!ASN1BEREncOctetString(enc, 0x8000000b, ((val)->u.sicilySubsequent).length, ((val)->u.sicilySubsequent).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AuthenticationChoice(ASN1decoding_t dec, ASN1uint32_t tag, AuthenticationChoice *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecOctetString(dec, 0x80000000, &(val)->u.simple))
	    return 0;
	break;
    case 0x80000003:
	(val)->choice = 2;
	if (!ASN1Dec_SaslCredentials(dec, 0x80000003, &(val)->u.sasl))
	    return 0;
	break;
    case 0x80000009:
	(val)->choice = 3;
	if (!ASN1BERDecOctetString(dec, 0x80000009, &(val)->u.sicilyNegotiate))
	    return 0;
	break;
    case 0x8000000a:
	(val)->choice = 4;
	if (!ASN1BERDecOctetString(dec, 0x8000000a, &(val)->u.sicilyInitial))
	    return 0;
	break;
    case 0x8000000b:
	(val)->choice = 5;
	if (!ASN1BERDecOctetString(dec, 0x8000000b, &(val)->u.sicilySubsequent))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AuthenticationChoice(AuthenticationChoice *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1octetstring_free(&(val)->u.simple);
	    break;
	case 2:
	    ASN1Free_SaslCredentials(&(val)->u.sasl);
	    break;
	case 3:
	    ASN1octetstring_free(&(val)->u.sicilyNegotiate);
	    break;
	case 4:
	    ASN1octetstring_free(&(val)->u.sicilyInitial);
	    break;
	case 5:
	    ASN1octetstring_free(&(val)->u.sicilySubsequent);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BindResponse(ASN1encoding_t enc, ASN1uint32_t tag, BindResponse *val)
{
    if (!ASN1Enc_LDAPResult(enc, tag ? tag : 0x40000001, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BindResponse(ASN1decoding_t dec, ASN1uint32_t tag, BindResponse *val)
{
    if (!ASN1Dec_LDAPResult(dec, tag ? tag : 0x40000001, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BindResponse(BindResponse *val)
{
    if (val) {
	ASN1Free_LDAPResult(val);
    }
}

static int ASN1CALL ASN1Enc_SearchResponse(ASN1encoding_t enc, ASN1uint32_t tag, SearchResponse *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_SearchResponse_entry(enc, 0, &(val)->u.entry))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_LDAPResult(enc, 0x40000005, &(val)->u.resultCode))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SearchResponse(ASN1decoding_t dec, ASN1uint32_t tag, SearchResponse *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x40000004:
	(val)->choice = 1;
	if (!ASN1Dec_SearchResponse_entry(dec, 0, &(val)->u.entry))
	    return 0;
	break;
    case 0x40000005:
	(val)->choice = 2;
	if (!ASN1Dec_LDAPResult(dec, 0x40000005, &(val)->u.resultCode))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SearchResponse(SearchResponse *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_SearchResponse_entry(&(val)->u.entry);
	    break;
	case 2:
	    ASN1Free_LDAPResult(&(val)->u.resultCode);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ModifyResponse(ASN1encoding_t enc, ASN1uint32_t tag, ModifyResponse *val)
{
    if (!ASN1Enc_LDAPResult(enc, tag ? tag : 0x40000007, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ModifyResponse(ASN1decoding_t dec, ASN1uint32_t tag, ModifyResponse *val)
{
    if (!ASN1Dec_LDAPResult(dec, tag ? tag : 0x40000007, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ModifyResponse(ModifyResponse *val)
{
    if (val) {
	ASN1Free_LDAPResult(val);
    }
}

static int ASN1CALL ASN1Enc_AddResponse(ASN1encoding_t enc, ASN1uint32_t tag, AddResponse *val)
{
    if (!ASN1Enc_LDAPResult(enc, tag ? tag : 0x40000009, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AddResponse(ASN1decoding_t dec, ASN1uint32_t tag, AddResponse *val)
{
    if (!ASN1Dec_LDAPResult(dec, tag ? tag : 0x40000009, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AddResponse(AddResponse *val)
{
    if (val) {
	ASN1Free_LDAPResult(val);
    }
}

static int ASN1CALL ASN1Enc_DelResponse(ASN1encoding_t enc, ASN1uint32_t tag, DelResponse *val)
{
    if (!ASN1Enc_LDAPResult(enc, tag ? tag : 0x4000000b, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DelResponse(ASN1decoding_t dec, ASN1uint32_t tag, DelResponse *val)
{
    if (!ASN1Dec_LDAPResult(dec, tag ? tag : 0x4000000b, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DelResponse(DelResponse *val)
{
    if (val) {
	ASN1Free_LDAPResult(val);
    }
}

static int ASN1CALL ASN1Enc_ModifyRDNResponse(ASN1encoding_t enc, ASN1uint32_t tag, ModifyRDNResponse *val)
{
    if (!ASN1Enc_LDAPResult(enc, tag ? tag : 0x4000000d, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ModifyRDNResponse(ASN1decoding_t dec, ASN1uint32_t tag, ModifyRDNResponse *val)
{
    if (!ASN1Dec_LDAPResult(dec, tag ? tag : 0x4000000d, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ModifyRDNResponse(ModifyRDNResponse *val)
{
    if (val) {
	ASN1Free_LDAPResult(val);
    }
}

static int ASN1CALL ASN1Enc_CompareRequest(ASN1encoding_t enc, ASN1uint32_t tag, CompareRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000e, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->entry).length, ((val)->entry).value))
	return 0;
    if (!ASN1Enc_AttributeValueAssertion(enc, 0, &(val)->ava))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CompareRequest(ASN1decoding_t dec, ASN1uint32_t tag, CompareRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000e, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->entry))
	return 0;
    if (!ASN1Dec_AttributeValueAssertion(dd, 0, &(val)->ava))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CompareRequest(CompareRequest *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->entry);
	ASN1Free_AttributeValueAssertion(&(val)->ava);
    }
}

static int ASN1CALL ASN1Enc_CompareResponse(ASN1encoding_t enc, ASN1uint32_t tag, CompareResponse *val)
{
    if (!ASN1Enc_LDAPResult(enc, tag ? tag : 0x4000000f, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CompareResponse(ASN1decoding_t dec, ASN1uint32_t tag, CompareResponse *val)
{
    if (!ASN1Dec_LDAPResult(dec, tag ? tag : 0x4000000f, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CompareResponse(CompareResponse *val)
{
    if (val) {
	ASN1Free_LDAPResult(val);
    }
}

static int ASN1CALL ASN1Enc_Filter(ASN1encoding_t enc, ASN1uint32_t tag, Filter *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_Filter_and(enc, 0, &(val)->u.and))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_Filter_or(enc, 0, &(val)->u.or))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_AttributeValueAssertion(enc, 0x80000003, &(val)->u.equalityMatch))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_SubstringFilter(enc, 0x80000004, &(val)->u.substrings))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_AttributeValueAssertion(enc, 0x80000005, &(val)->u.greaterOrEqual))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_AttributeValueAssertion(enc, 0x80000006, &(val)->u.lessOrEqual))
	    return 0;
	break;
    case 7:
	if (!ASN1BEREncOctetString(enc, 0x80000007, ((val)->u.present).length, ((val)->u.present).value))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_AttributeValueAssertion(enc, 0x80000008, &(val)->u.approxMatch))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Filter(ASN1decoding_t dec, ASN1uint32_t tag, Filter *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1Dec_Filter_and(dec, 0, &(val)->u.and))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1Dec_Filter_or(dec, 0, &(val)->u.or))
	    return 0;
	break;
    case 0x80000003:
	(val)->choice = 3;
	if (!ASN1Dec_AttributeValueAssertion(dec, 0x80000003, &(val)->u.equalityMatch))
	    return 0;
	break;
    case 0x80000004:
	(val)->choice = 4;
	if (!ASN1Dec_SubstringFilter(dec, 0x80000004, &(val)->u.substrings))
	    return 0;
	break;
    case 0x80000005:
	(val)->choice = 5;
	if (!ASN1Dec_AttributeValueAssertion(dec, 0x80000005, &(val)->u.greaterOrEqual))
	    return 0;
	break;
    case 0x80000006:
	(val)->choice = 6;
	if (!ASN1Dec_AttributeValueAssertion(dec, 0x80000006, &(val)->u.lessOrEqual))
	    return 0;
	break;
    case 0x80000007:
	(val)->choice = 7;
	if (!ASN1BERDecOctetString(dec, 0x80000007, &(val)->u.present))
	    return 0;
	break;
    case 0x80000008:
	(val)->choice = 8;
	if (!ASN1Dec_AttributeValueAssertion(dec, 0x80000008, &(val)->u.approxMatch))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Filter(Filter *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_Filter_and(&(val)->u.and);
	    break;
	case 2:
	    ASN1Free_Filter_or(&(val)->u.or);
	    break;
	case 3:
	    ASN1Free_AttributeValueAssertion(&(val)->u.equalityMatch);
	    break;
	case 4:
	    ASN1Free_SubstringFilter(&(val)->u.substrings);
	    break;
	case 5:
	    ASN1Free_AttributeValueAssertion(&(val)->u.greaterOrEqual);
	    break;
	case 6:
	    ASN1Free_AttributeValueAssertion(&(val)->u.lessOrEqual);
	    break;
	case 7:
	    ASN1octetstring_free(&(val)->u.present);
	    break;
	case 8:
	    ASN1Free_AttributeValueAssertion(&(val)->u.approxMatch);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_Filter_or(ASN1encoding_t enc, ASN1uint32_t tag, PFilter_or *val)
{
    PFilter_or f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_Filter(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Filter_or(ASN1decoding_t dec, ASN1uint32_t tag, PFilter_or *val)
{
    PFilter_or *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PFilter_or)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_Filter(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Filter_or(PFilter_or *val)
{
    PFilter_or f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_Filter(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_Filter_and(ASN1encoding_t enc, ASN1uint32_t tag, PFilter_and *val)
{
    PFilter_and f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000000, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_Filter(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Filter_and(ASN1decoding_t dec, ASN1uint32_t tag, PFilter_and *val)
{
    PFilter_and *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000000, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PFilter_and)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_Filter(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Filter_and(PFilter_and *val)
{
    PFilter_and f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_Filter(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_BindRequest(ASN1encoding_t enc, ASN1uint32_t tag, BindRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000000, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->name).length, ((val)->name).value))
	return 0;
    if (!ASN1Enc_AuthenticationChoice(enc, 0, &(val)->authentication))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BindRequest(ASN1decoding_t dec, ASN1uint32_t tag, BindRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000000, &dd, &di))
	return 0;
    if (!ASN1BERDecU16Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->name))
	return 0;
    if (!ASN1Dec_AuthenticationChoice(dd, 0, &(val)->authentication))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BindRequest(BindRequest *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->name);
	ASN1Free_AuthenticationChoice(&(val)->authentication);
    }
}

static int ASN1CALL ASN1Enc_SearchRequest(ASN1encoding_t enc, ASN1uint32_t tag, SearchRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000003, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->baseObject).length, ((val)->baseObject).value))
	return 0;
    if (!ASN1BEREncU32(enc, 0xa, (val)->scope))
	return 0;
    if (!ASN1BEREncU32(enc, 0xa, (val)->derefAliases))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->sizeLimit))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->timeLimit))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->attrsOnly))
	return 0;
    if (!ASN1Enc_Filter(enc, 0, &(val)->filter))
	return 0;
    if (!ASN1Enc_SearchRequest_attributes(enc, 0, &(val)->attributes))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SearchRequest(ASN1decoding_t dec, ASN1uint32_t tag, SearchRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000003, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->baseObject))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0xa, (ASN1uint32_t *) &(val)->scope))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0xa, (ASN1uint32_t *) &(val)->derefAliases))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->sizeLimit))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->timeLimit))
	return 0;
    if (!ASN1BERDecBool(dd, 0x1, &(val)->attrsOnly))
	return 0;
    if (!ASN1Dec_Filter(dd, 0, &(val)->filter))
	return 0;
    if (!ASN1Dec_SearchRequest_attributes(dd, 0, &(val)->attributes))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SearchRequest(SearchRequest *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->baseObject);
	ASN1Free_Filter(&(val)->filter);
	ASN1Free_SearchRequest_attributes(&(val)->attributes);
    }
}

static int ASN1CALL ASN1Enc_LDAPMessage_protocolOp(ASN1encoding_t enc, ASN1uint32_t tag, LDAPMessage_protocolOp *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_BindRequest(enc, 0, &(val)->u.bindRequest))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_BindResponse(enc, 0, &(val)->u.bindResponse))
	    return 0;
	break;
    case 3:
	if (!ASN1BEREncNull(enc, 0x40000002))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_SearchRequest(enc, 0, &(val)->u.searchRequest))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_SearchResponse(enc, 0, &(val)->u.searchResponse))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_ModifyRequest(enc, 0, &(val)->u.modifyRequest))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_ModifyResponse(enc, 0, &(val)->u.modifyResponse))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_AddRequest(enc, 0, &(val)->u.addRequest))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_AddResponse(enc, 0, &(val)->u.addResponse))
	    return 0;
	break;
    case 10:
	if (!ASN1BEREncOctetString(enc, 0x4000000a, ((val)->u.delRequest).length, ((val)->u.delRequest).value))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_DelResponse(enc, 0, &(val)->u.delResponse))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_ModifyRDNRequest(enc, 0, &(val)->u.modifyRDNRequest))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_ModifyRDNResponse(enc, 0, &(val)->u.modifyRDNResponse))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_CompareRequest(enc, 0, &(val)->u.compareDNRequest))
	    return 0;
	break;
    case 15:
	if (!ASN1Enc_CompareResponse(enc, 0, &(val)->u.compareDNResponse))
	    return 0;
	break;
    case 16:
	if (!ASN1BEREncU32(enc, 0x40000010, (val)->u.abandonRequest))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_LDAPMessage_protocolOp(ASN1decoding_t dec, ASN1uint32_t tag, LDAPMessage_protocolOp *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x40000000:
	(val)->choice = 1;
	if (!ASN1Dec_BindRequest(dec, 0, &(val)->u.bindRequest))
	    return 0;
	break;
    case 0x40000001:
	(val)->choice = 2;
	if (!ASN1Dec_BindResponse(dec, 0, &(val)->u.bindResponse))
	    return 0;
	break;
    case 0x40000002:
	(val)->choice = 3;
	if (!ASN1BERDecNull(dec, 0x40000002))
	    return 0;
	break;
    case 0x40000003:
	(val)->choice = 4;
	if (!ASN1Dec_SearchRequest(dec, 0, &(val)->u.searchRequest))
	    return 0;
	break;
    case 0x40000004:
    case 0x40000005:
	(val)->choice = 5;
	if (!ASN1Dec_SearchResponse(dec, 0, &(val)->u.searchResponse))
	    return 0;
	break;
    case 0x40000006:
	(val)->choice = 6;
	if (!ASN1Dec_ModifyRequest(dec, 0, &(val)->u.modifyRequest))
	    return 0;
	break;
    case 0x40000007:
	(val)->choice = 7;
	if (!ASN1Dec_ModifyResponse(dec, 0, &(val)->u.modifyResponse))
	    return 0;
	break;
    case 0x40000008:
	(val)->choice = 8;
	if (!ASN1Dec_AddRequest(dec, 0, &(val)->u.addRequest))
	    return 0;
	break;
    case 0x40000009:
	(val)->choice = 9;
	if (!ASN1Dec_AddResponse(dec, 0, &(val)->u.addResponse))
	    return 0;
	break;
    case 0x4000000a:
	(val)->choice = 10;
	if (!ASN1BERDecOctetString(dec, 0x4000000a, &(val)->u.delRequest))
	    return 0;
	break;
    case 0x4000000b:
	(val)->choice = 11;
	if (!ASN1Dec_DelResponse(dec, 0, &(val)->u.delResponse))
	    return 0;
	break;
    case 0x4000000c:
	(val)->choice = 12;
	if (!ASN1Dec_ModifyRDNRequest(dec, 0, &(val)->u.modifyRDNRequest))
	    return 0;
	break;
    case 0x4000000d:
	(val)->choice = 13;
	if (!ASN1Dec_ModifyRDNResponse(dec, 0, &(val)->u.modifyRDNResponse))
	    return 0;
	break;
    case 0x4000000e:
	(val)->choice = 14;
	if (!ASN1Dec_CompareRequest(dec, 0, &(val)->u.compareDNRequest))
	    return 0;
	break;
    case 0x4000000f:
	(val)->choice = 15;
	if (!ASN1Dec_CompareResponse(dec, 0, &(val)->u.compareDNResponse))
	    return 0;
	break;
    case 0x40000010:
	(val)->choice = 16;
	if (!ASN1BERDecU32Val(dec, 0x40000010, (ASN1uint32_t *) &(val)->u.abandonRequest))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_LDAPMessage_protocolOp(LDAPMessage_protocolOp *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_BindRequest(&(val)->u.bindRequest);
	    break;
	case 2:
	    ASN1Free_BindResponse(&(val)->u.bindResponse);
	    break;
	case 4:
	    ASN1Free_SearchRequest(&(val)->u.searchRequest);
	    break;
	case 5:
	    ASN1Free_SearchResponse(&(val)->u.searchResponse);
	    break;
	case 6:
	    ASN1Free_ModifyRequest(&(val)->u.modifyRequest);
	    break;
	case 7:
	    ASN1Free_ModifyResponse(&(val)->u.modifyResponse);
	    break;
	case 8:
	    ASN1Free_AddRequest(&(val)->u.addRequest);
	    break;
	case 9:
	    ASN1Free_AddResponse(&(val)->u.addResponse);
	    break;
	case 10:
	    ASN1octetstring_free(&(val)->u.delRequest);
	    break;
	case 11:
	    ASN1Free_DelResponse(&(val)->u.delResponse);
	    break;
	case 12:
	    ASN1Free_ModifyRDNRequest(&(val)->u.modifyRDNRequest);
	    break;
	case 13:
	    ASN1Free_ModifyRDNResponse(&(val)->u.modifyRDNResponse);
	    break;
	case 14:
	    ASN1Free_CompareRequest(&(val)->u.compareDNRequest);
	    break;
	case 15:
	    ASN1Free_CompareResponse(&(val)->u.compareDNResponse);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_LDAPMessage(ASN1encoding_t enc, ASN1uint32_t tag, LDAPMessage *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->messageID))
	return 0;
    if (!ASN1Enc_LDAPMessage_protocolOp(enc, 0, &(val)->protocolOp))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LDAPMessage(ASN1decoding_t dec, ASN1uint32_t tag, LDAPMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->messageID))
	return 0;
    if (!ASN1Dec_LDAPMessage_protocolOp(dd, 0, &(val)->protocolOp))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LDAPMessage(LDAPMessage *val)
{
    if (val) {
	ASN1Free_LDAPMessage_protocolOp(&(val)->protocolOp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\intfc.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
        intfc.h

Abstract:
        Definitions of data types and corresponding methods used to provide
        multiple-interface support in H.323/LDAP proxy.
        

Revision History:
        03/01/2000      File creation.      Ilya Kleyman (IlyaK)
    
--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
PROXY_INTERFACE_ARRAY InterfaceArray;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Static definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
static 
int 
__cdecl 
CompareInterfacesByIndex (
    IN PROXY_INTERFACE * const * InterfaceA,
    IN PROXY_INTERFACE * const * InterfaceB
    ); 

static 
INT 
SearchInterfaceByIndex (
    IN const DWORD * Index,
    IN PROXY_INTERFACE *const* Comparand
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Definitions                                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// PROXY_INTERFACE ------------------------------------------------------------


PROXY_INTERFACE::PROXY_INTERFACE (
    IN ULONG ArgIndex,
    IN H323_INTERFACE_TYPE ArgInterfaceType,
    IN PIP_ADAPTER_BINDING_INFO BindingInfo
    )

/*++

Routine Description:
    Constructor for PROXY_INTERFACE class

Arguments:
    ArgIndex         - Index of the interface
    ArgInterfaceType - Interface type (public or private)
    BindingInfo      - Binding information for the interface

Return Values:
    None

Notes:

--*/

{

    Address = ntohl (BindingInfo -> Address[0].Address);
    Mask    = ntohl (BindingInfo -> Address[0].Mask);
    Index   = ArgIndex;
    InterfaceType = ArgInterfaceType;
    AdapterIndex = 0;

    Q931RedirectHandle       = NULL;
    LdapRedirectHandle1      = NULL;
    LdapRedirectHandle2      = NULL;
    Q931LocalRedirectHandle  = NULL;
    LdapLocalRedirectHandle1 = NULL;
    LdapLocalRedirectHandle2 = NULL;

    ::ZeroMemory (&Q931PortMapping, sizeof (Q931PortMapping));
    ::ZeroMemory (&LdapPortMapping, sizeof (LdapPortMapping));
    ::ZeroMemory (&LdapAltPortMapping, sizeof (LdapAltPortMapping));

} // PROXY_INTERFACE::PROXY_INTERFACE


PROXY_INTERFACE::~PROXY_INTERFACE (
    void
    )

/*++

Routine Description:
    Destructor for PROXY_INTERFACE class

Arguments:
    None

Return Values:
    None

Notes:

--*/

{
    assert (!Q931RedirectHandle);
    assert (!LdapRedirectHandle1);
    assert (!LdapRedirectHandle2);
    assert (!Q931LocalRedirectHandle);
    assert (!LdapLocalRedirectHandle1);
    assert (!LdapLocalRedirectHandle2);

} // PROXY_INTERFACE::~PROXY_INTERFACE


ULONG 
PROXY_INTERFACE::StartNatRedirects (
    void
    ) 

/*++

Routine Description:
    Creates two types of adapter-restricted NAT redirects:
        Type 1 -- for connections incoming on the interface
        Type 2 -- for locally-originated connections (NOT destined to 
                    the local machine) through the interface
    
Arguments:
    None

Return Values:
    Win32 error indicating what (if anything) went wrong
    when trying to set up the NAT redirects.

Notes:
    Total number of redirects created is 6:
        2 Type 1 redirects for LDAP
        2 Type 2 redirects for LDAP
        1 Type 1 redirect for Q.931
        1 Type 2 redirect for Q.931

--*/

{

    ULONG Status;

    assert (!Q931RedirectHandle);
    assert (!LdapRedirectHandle1);
    assert (!LdapRedirectHandle2);
    assert (!Q931LocalRedirectHandle);
    assert (!LdapLocalRedirectHandle1);
    assert (!LdapLocalRedirectHandle2);

    // Type 1 redirects -- for redirecting inbound connections

    if (!IsFirewalled () || HasQ931PortMapping ())
    {
    
        Status = StartQ931ReceiveRedirect ();

    }

    if (!IsFirewalled () || HasLdapPortMapping ())
    {

        Status = NatCreateDynamicAdapterRestrictedPortRedirect ( 
            0,
            IPPROTO_TCP,
            htons (LDAP_STANDARD_PORT),
            LdapListenSocketAddress.sin_addr.s_addr,
            LdapListenSocketAddress.sin_port,
            AdapterIndex,
            MAX_LISTEN_BACKLOG,
            &LdapRedirectHandle1
            );

        if (Status != STATUS_SUCCESS) 
        {

            DebugError (Status, _T("LDAP: Failed to create receive redirect #1 for LDAP.\n"));

            return  Status;
        }

        DebugF (_T ("LDAP: Incoming connections to %08X:%04X will be redirected to %08X:%04X.\n"),
                    Address,
                    LDAP_STANDARD_PORT,
                    ntohl (LdapListenSocketAddress.sin_addr.s_addr),
                    ntohs (LdapListenSocketAddress.sin_port));

    }

    if (!IsFirewalled () || HasLdapAltPortMapping ())
    {
    
        Status = NatCreateDynamicAdapterRestrictedPortRedirect ( 
            0,
            IPPROTO_TCP,
            htons (LDAP_ALTERNATE_PORT),
            LdapListenSocketAddress.sin_addr.s_addr,
            LdapListenSocketAddress.sin_port,
            AdapterIndex,
            MAX_LISTEN_BACKLOG,
            &LdapRedirectHandle2
            );

        if (Status != STATUS_SUCCESS) 
        {

            DebugError (Status, _T("LDAP: Failed to create receive redirect #2 for LDAP.\n"));

            return Status;
        }

        DebugF (_T ("LDAP: Incoming connections to %08X:%04X will be redirected to %08X:%04X.\n"),
                    Address,
                    LDAP_ALTERNATE_PORT,
                    ntohl (LdapListenSocketAddress.sin_addr.s_addr),
                    ntohs (LdapListenSocketAddress.sin_port));

    }


    // Type 2 redirects (for locally-originated traffic, NOT destined to the local machine)
    Status = NatCreateDynamicAdapterRestrictedPortRedirect ( 
        NatRedirectFlagSendOnly, 
        IPPROTO_TCP,
        htons (Q931_TSAP_IP_TCP),
        Q931ListenSocketAddress.sin_addr.s_addr,
        Q931ListenSocketAddress.sin_port,
        AdapterIndex,
        MAX_LISTEN_BACKLOG,
        &Q931LocalRedirectHandle
        );

    if (Status != STATUS_SUCCESS) 
    {

        DebugError (Status, _T("Q931: Failed to create send redirect for Q.931.\n"));

        return Status;
    }

    DebugF (_T ("Q931: Locally-originated connections through %08X:%04X will be redirected to %08X:%04X.\n"),
                Address,
                Q931_TSAP_IP_TCP,
                ntohl (Q931ListenSocketAddress.sin_addr.s_addr),
                ntohs (Q931ListenSocketAddress.sin_port));

    Status = NatCreateDynamicAdapterRestrictedPortRedirect ( 
        NatRedirectFlagSendOnly, 
        IPPROTO_TCP,
        htons (LDAP_STANDARD_PORT),
        LdapListenSocketAddress.sin_addr.s_addr,
        LdapListenSocketAddress.sin_port,
        AdapterIndex,
        MAX_LISTEN_BACKLOG,
        &LdapLocalRedirectHandle1
        );

    if (Status != STATUS_SUCCESS) 
    {

        DebugError (Status, _T("LDAP: Failed to create send redirect #1 for LDAP.\n"));

        return Status;
    }

    DebugF (_T ("LDAP: Locally-originated connections through %08X:%04X will be redirected to %08X:%04X.\n"),
                Address,
                LDAP_STANDARD_PORT,
                ntohl (LdapListenSocketAddress.sin_addr.s_addr),
                ntohs (LdapListenSocketAddress.sin_port));

    Status = NatCreateDynamicAdapterRestrictedPortRedirect ( 
        NatRedirectFlagSendOnly, 
        IPPROTO_TCP,
        htons (LDAP_ALTERNATE_PORT),
        LdapListenSocketAddress.sin_addr.s_addr,
        LdapListenSocketAddress.sin_port,
        AdapterIndex,
        MAX_LISTEN_BACKLOG,
        &LdapLocalRedirectHandle2
        );

    if (Status != STATUS_SUCCESS) 
    {

        DebugError (Status, _T("LDAP: Failed to create send redirect #2 for LDAP.\n"));

        return Status;
    }

    DebugF (_T ("LDAP: Locally-originated connections through %08X:%04X will be redirected to %08X:%04X.\n"),
                Address,
                LDAP_ALTERNATE_PORT,
                ntohl (LdapListenSocketAddress.sin_addr.s_addr),
                ntohs (LdapListenSocketAddress.sin_port));

    return  Status;

} // PROXY_INTERFACE::StartNatRedirects


ULONG 
PROXY_INTERFACE::Start (
    void
    )

/*++

Routine Description:
    Starts an interface

Arguments:
    None

Return Values:
    Win32 error indicating what (if anything) went wrong when
    the interface was being started.

Notes:

--*/

{ 
    ULONG Status;

    assert (0 == AdapterIndex);
    assert (0 == Q931PortMapping.PrivateAddress);
    assert (0 == LdapPortMapping.PrivateAddress);
    assert (0 == LdapAltPortMapping.PrivateAddress);

    AdapterIndex = ::NhMapAddressToAdapter (htonl (Address));

    if (INVALID_INTERFACE_INDEX == AdapterIndex)
    {
        AdapterIndex = 0;
        
        Status = ERROR_CAN_NOT_COMPLETE;
        
        DebugF (_T ("PROXY_INTERFACE: Unable to map %08X to an adapter index\n"),
                    Address);

        return Status;
    }

    //
    // Load the port mappings for this interface. Since more often than not
    // there won't be a port mapping, we expect these routines to return
    // errors, and thus don't check for them. NatLookupPortMappingAdapter
    // will modify the out parameter (i.e., the port mapping structure) only
    // on success.
    //

    ::NatLookupPortMappingAdapter (
        AdapterIndex,
        NAT_PROTOCOL_TCP,
        IP_NAT_ADDRESS_UNSPECIFIED,
        htons (Q931_TSAP_IP_TCP),
        &Q931PortMapping
        );

    ::NatLookupPortMappingAdapter (
        AdapterIndex,
        NAT_PROTOCOL_TCP,
        IP_NAT_ADDRESS_UNSPECIFIED,
        htons (LDAP_STANDARD_PORT),
        &LdapPortMapping
        );

    ::NatLookupPortMappingAdapter (
        AdapterIndex,
        NAT_PROTOCOL_TCP,
        IP_NAT_ADDRESS_UNSPECIFIED,
        htons (LDAP_ALTERNATE_PORT),
        &LdapAltPortMapping
        );

    Status = StartNatRedirects ();

    if (STATUS_SUCCESS != Status) 
    {

        StopNatRedirects ();

    }

    return Status;

} // PROXY_INTERFACE::Start


void 
PROXY_INTERFACE::StopNatRedirects (
    void
    )

/*++

Routine Description:
    Removes all NAT redirects created for the interface

Arguments:
    None

Return Values:
    None

Notes:

--*/

{
    if (Q931RedirectHandle) 
    {

        NatCancelDynamicRedirect (Q931RedirectHandle);

        Q931RedirectHandle       = NULL;

    }

    if (LdapRedirectHandle1) 
    {

        NatCancelDynamicRedirect (LdapRedirectHandle1);

        LdapRedirectHandle1      = NULL;

    }

    if (LdapRedirectHandle2) 
    {

        NatCancelDynamicRedirect (LdapRedirectHandle2);

        LdapRedirectHandle2      = NULL;

    }

    if (Q931LocalRedirectHandle) 
    {

        NatCancelDynamicRedirect (Q931LocalRedirectHandle);

        Q931LocalRedirectHandle  = NULL;

    }

    if (LdapLocalRedirectHandle1) 
    {

        NatCancelDynamicRedirect (LdapLocalRedirectHandle1);

        LdapLocalRedirectHandle1 = NULL;

    }

    if (LdapLocalRedirectHandle2) 
    {

        NatCancelDynamicRedirect (LdapLocalRedirectHandle2);

        LdapLocalRedirectHandle2 = NULL;

    }

} // PROXY_INTERFACE::StopNatRedirects


ULONG
PROXY_INTERFACE::StartQ931ReceiveRedirect (
    void
    )

/*++

Routine Description:
    Creates the type 1 (receive) redirect for Q931 traffic,
    if this has not already been done on the interface.
    
Arguments:
    None

Return Values:
    Win32 error indicating what (if anything) went wrong
    when trying to set up the redirect.

--*/

{
    ULONG Status = STATUS_SUCCESS;

    if (NULL == Q931RedirectHandle)
    {
    
        Status = NatCreateDynamicAdapterRestrictedPortRedirect ( 
            0,
            IPPROTO_TCP,
            htons (Q931_TSAP_IP_TCP),
            Q931ListenSocketAddress.sin_addr.s_addr,
            Q931ListenSocketAddress.sin_port,
            AdapterIndex,
            MAX_LISTEN_BACKLOG,
            &Q931RedirectHandle
            );

        if (Status != STATUS_SUCCESS) 
        {

            DebugError (Status, _T("Q931: Failed to create receive redirect for Q.931.\n"));

            return Status;
        }

        DebugF (_T ("Q931: Incoming connections to %08X:%04X will be redirected to %08X:%04X.\n"),
                    Address,
                    Q931_TSAP_IP_TCP,
                    ntohl (Q931ListenSocketAddress.sin_addr.s_addr),
                    ntohs (Q931ListenSocketAddress.sin_port));

    }

    return Status;

} // PROXY_INTERFACE::StartQ931ReceiveRedirect


void
PROXY_INTERFACE::StopQ931ReceiveRedirect (
    void
    )

/*++

Routine Description:
    Stops the Q931 receive redirect, if it has been created.
    
Arguments:
    None

Return Values:
    None

--*/

{

    if (Q931RedirectHandle) 
    {

        NatCancelDynamicRedirect (Q931RedirectHandle);

        Q931RedirectHandle       = NULL;

    }
    
} // PROXY_INTERFACE::StopQ931ReceiveRedirect



void 
PROXY_INTERFACE::Stop (
    void
    )

/*++

Routine Description:
    1. Terminate all connections through the interface.
    2. Remove all translation entries registered via the interface.
    3. Stop all NAT redirects created for this interface.

Arguments:
    None

Return Values:
    None

Notes:
    The caller of this method should first remove the
    interface from the global array.

--*/

{ 
    CallBridgeList.OnInterfaceShutdown       (Address);

    LdapConnectionArray.OnInterfaceShutdown  (Address);

    LdapTranslationTable.OnInterfaceShutdown (Address);

    StopNatRedirects ();

    ::ZeroMemory (&Q931PortMapping, sizeof (Q931PortMapping));
    ::ZeroMemory (&LdapPortMapping, sizeof (LdapPortMapping));
    ::ZeroMemory (&LdapAltPortMapping, sizeof (LdapAltPortMapping));
    AdapterIndex = 0;

} // PROXY_INTERFACE::Stop


BOOL 
PROXY_INTERFACE::IsFirewalled (
    void
    ) 

/*++

Routine Description:
    Determines whether the interface was created as firewalled.

Arguments:
    None

Return Values:
    TRUE - if the interface was created as firewalled.
    FALSE - if the interface was created as non-firewalled.

Notes:

--*/

{

    return InterfaceType == H323_INTERFACE_PUBLIC_FIREWALLED;

} // PROXY_INTERFACE::IsFirewalled
      

BOOL 
PROXY_INTERFACE::IsPrivate (
    void
    ) 

/*++

Routine Description:
    Determines whether the interface was created as private.

Arguments:
    None

Return Values:
    TRUE if the interface was created as private
    FALSE if the interface was created as non-private

Notes:

--*/

{

    return InterfaceType == H323_INTERFACE_PRIVATE;

} // PROXY_INTERFACE::IsPrivate


BOOL 
PROXY_INTERFACE::IsPublic (
    void
    ) 

/*++

Routine Description:
    Determines whether the interface was created as public.

Arguments:
    None

Return Values:
    TRUE - if the interface was created as public.
    FALSE - if the interface was created as non-public.

Notes:

--*/

{

    return InterfaceType == H323_INTERFACE_PUBLIC
            || InterfaceType == H323_INTERFACE_PUBLIC_FIREWALLED;

} // PROXY_INTERFACE::IsPublic



BOOL
PROXY_INTERFACE::HasQ931PortMapping (
    void
    )

/*++

Routine Description:
    Determines whether the interface has a valid Q931 port mapping.

Arguments:
    None

Return Values:
    TRUE if the interface has a valid Q931 port mapping
    FALSE if the interface does not have a valid Q931 port mapping

Notes:

--*/

{

    return Q931PortMapping.PrivateAddress != 0;

} // PROXY_INTERFACE::HasQ931PortMapping


BOOL
PROXY_INTERFACE::HasLdapPortMapping (
    void
    )

/*++

Routine Description:
    Determines whether the interface has a valid Ldap port mapping.

Arguments:
    None

Return Values:
    TRUE if the interface has a valid Ldap port mapping
    FALSE if the interface does not have a valid Ldap port mapping

Notes:

--*/

{

    return LdapPortMapping.PrivateAddress != 0;

} // PROXY_INTERFACE::HasLdapPortMapping


BOOL
PROXY_INTERFACE::HasLdapAltPortMapping (
    void
    )

/*++

Routine Description:
    Determines whether the interface has a valid Ldap (alt) port mapping.

Arguments:
    None

Return Values:
    TRUE if the interface has a valid Ldap (alt) port mapping
    FALSE if the interface does not have a valid Ldap (alt) port mapping

Notes:

--*/

{

    return LdapAltPortMapping.PrivateAddress != 0;

} // PROXY_INTERFACE::HasLdapAltPortMapping


ULONG
PROXY_INTERFACE::GetQ931PortMappingDestination (
    void
    )

/*++

Routine Description:
    Returns the destination address of the interfaces
    Q931 port mapping.

Arguments:
    None

Return Values:
    The destination address of the port mapping, in network
    byte order. Returns 0 if no port mapping exists.

Notes:

--*/


{

    return Q931PortMapping.PrivateAddress;
    
} // PROXY_INTERFACE::GetQ931PortMappingDestination


ULONG
PROXY_INTERFACE::GetLdapPortMappingDestination (
    void
    )

/*++

Routine Description:
    Returns the destination address of the interfaces
    Ldap port mapping.

Arguments:
    None

Return Values:
    The destination address of the port mapping, in network
    byte order. Returns 0 if no port mapping exists.

Notes:

--*/


{

    return LdapPortMapping.PrivateAddress;   

} // PROXY_INTERFACE::GetLdapPortMappingDestination


ULONG
PROXY_INTERFACE::GetLdapAltPortMappingDestination (
    void
    )

/*++

Routine Description:
    Returns the destination address of the interfaces
    Ldap-alt port mapping.

Arguments:
    None

Return Values:
    The destination address of the port mapping, in network
    byte order. Returns 0 if no port mapping exists.

Notes:

--*/

{

    return LdapAltPortMapping.PrivateAddress;   

} // PROXY_INTERFACE::GetLdapAltPortMappingDestination

// PROXY_INTERFACE_ARRAY ------------------------------------------------------


HRESULT 
PROXY_INTERFACE_ARRAY::Add (
    IN PROXY_INTERFACE* Interface
    ) 

/*++

Routine Description:
    Adds an interface to the array.

Arguments:
    Interface - interface to be added.

Return Values:
    Error code indicating whether the operation succeeded.

Notes:
    To be called from locked context.

--*/

{
    DWORD ReturnIndex;
    PROXY_INTERFACE** ElementPlaceholder;

    assert (Interface);

    if (Array.FindIndex (CompareInterfacesByIndex, &Interface, &ReturnIndex)) 
    {
        // Interface with this index already exists
        return E_FAIL;
    }

    ElementPlaceholder = Array.AllocAtPos (ReturnIndex);

    if (!ElementPlaceholder) 
        return E_OUTOFMEMORY;

    *ElementPlaceholder = Interface;

    return S_OK;

} // PROXY_INTERFACE_ARRAY::Add


PROXY_INTERFACE** 
PROXY_INTERFACE_ARRAY::FindByIndex (
    IN DWORD Index
    )

/*++

Routine Description:
    Finds an interface by the interface index.

Arguments:
    Index - index of the interface being searched for.

Return Values:
    Pointer to the entry associated with the interface, if interface
    with the index is in the array.
    NULL if the interface with the index is not in the array.

Notes:
    1. To be called from locked context
    2. Does not transfer ownership of the interface being searched for

--*/

{

    BOOL  SearchResult;
    DWORD ArrayIndex;

    SearchResult = Array.BinarySearch (
                    SearchInterfaceByIndex,
                    &Index,
                    &ArrayIndex);

    if (SearchResult) 
    {

        return &Array [ArrayIndex];
    }

    return NULL;

} // PROXY_INTERFACE_ARRAY::FindByIndex 


PROXY_INTERFACE * 
PROXY_INTERFACE_ARRAY::RemoveByIndex (
    IN DWORD Index
    ) 

/*++

Routine Description:
    Removes an interface with given index from the array.

Arguments:
    Index - index of the interface to be removed.

Return Values:
    Pointer to the removed interface, if interface with the
    index is in the array.
    NULL if interface with this index cannot be found in the
    array.

Notes:
    1. To be called from locked context
    2. Transfers ownership of the interface being removed

--*/

{

    PROXY_INTERFACE * ReturnInterface = NULL;
    PROXY_INTERFACE ** Interface;

    Interface = FindByIndex (Index);

    if (Interface) 
    {

        ReturnInterface = *Interface;
        Array.DeleteEntry (Interface);
    }

    return ReturnInterface;

} // PROXY_INTERFACE_ARRAY::RemoveByIndex


HRESULT 
PROXY_INTERFACE_ARRAY::IsPrivateAddress (
    IN	DWORD	Address,			// host order
    OUT BOOL  * IsPrivate
    )

/*++

Routine Description:
    Determines whether the address specified is
    reachable through a private interface.

Arguments:
    Address - IP address for which the determination
              is to be made.

    IsPrivate - Result of the determination (TRUE or FALSE)

Return Values:
    Error code indicating whether the query succeeded.

Notes:

--*/

{

    DWORD ArrayIndex;
    PROXY_INTERFACE * Interface;
    DWORD BestInterfaceAddress;
    ULONG Error;

    Error = GetBestInterfaceAddress (Address, &BestInterfaceAddress);

    if (ERROR_SUCCESS != Error)
    {

        return E_FAIL;

    }

    *IsPrivate = FALSE;

    Lock ();

    for (ArrayIndex = 0; ArrayIndex < Array.Length; ArrayIndex++)
    {

        Interface = Array [ArrayIndex];

        if (Interface -> Address == BestInterfaceAddress && Interface -> IsPrivate ())
        {

            *IsPrivate = TRUE;

            break;
        }    
    }
    
    Unlock ();

    return S_OK;

} // PROXY_INTERFACE_ARRAY::IsPrivateAddress
    

HRESULT 
PROXY_INTERFACE_ARRAY::IsPublicAddress (
    IN	DWORD	Address,			// host order
    OUT BOOL *  IsPublic
    )

/*++

Routine Description:
    Determines whether the address specified is
    reachable through a public interface.

Arguments:
    Address - IP address for which the determination
              is to be made.

    IsPrivate - Result of the determination (TRUE or FALSE)

Return Values:
    Error code indicating whether the query succeded.

Notes:

--*/

{

    DWORD ArrayIndex;
    PROXY_INTERFACE * Interface;
    DWORD BestInterfaceAddress;
    ULONG Error;

    Error = GetBestInterfaceAddress (Address, &BestInterfaceAddress);

    if (ERROR_SUCCESS != Error) 
    {

        return E_FAIL;
    }

    *IsPublic = FALSE;

    Lock ();

    for (ArrayIndex = 0; ArrayIndex < Array.Length; ArrayIndex++) 
    {

        Interface = Array [ArrayIndex];

        if (Interface -> Address == BestInterfaceAddress && Interface -> IsPublic ()) 
        {

            *IsPublic = TRUE;

            break;
        }    
    }
    
    Unlock ();

    return S_OK;

} // PROXY_INTERFACE_ARRAY::IsPublicAddress


void 
PROXY_INTERFACE_ARRAY::Stop (
    void
    )

/*++

Routine Description:
    Stops all interfaces (in the array) that were not previously stopped.

Arguments:
    None

Return Values:
    None

Notes:
    Normally, all the interfaces should have been individually stopped
    prior to calling this method, in which case it does nothing.
    If some interfaces were not stopped, when the method is called, it 
    will issue a warning and stop them.

--*/

{

    DWORD Index;
    
    Lock ();

    if (Array.Length) 
    {

        DebugF (_T("WARNING: Some interfaces are still active (should have already been deactivated). Starting deactivation procedures...\n"));

        for (Index = 0; Index < Array.Length; Index++) 
        {

            Array[Index] -> Stop ();

        }
	}

    Array.Free ();

    Unlock ();

} // PROXY_INTERFACE_ARRAY::Stop


ULONG 
PROXY_INTERFACE_ARRAY::AddStartInterface (
    IN ULONG Index,
    IN H323_INTERFACE_TYPE ArgInterfaceType,
    IN PIP_ADAPTER_BINDING_INFO BindingInfo
    )

/*++

Routine Description:
    Creates new interface, adds it to the array, and starts it.

Arguments:
    Index - Index of the interface to be created.
    ArgInterfaceType - Type of the interface to be created (PRIVATE
                       or PUBLIC)
    BindingInfo - Binding information for the interface (address, mask, and
                  adapter index)

Return Values:
    Win32 error code indicating success or failure of any of 
    the above three operations.

Notes:

--*/

{
    HRESULT Result;
    ULONG   Error = ERROR_NOT_READY; // anything but ERROR_SUCCESS
    PROXY_INTERFACE * Interface;

    Lock ();

    if (FindByIndex (Index)) 
    {

        Error = ERROR_INTERFACE_ALREADY_EXISTS;

    } else {

        Interface = new PROXY_INTERFACE (Index, ArgInterfaceType, BindingInfo);

        if (Interface) 
        {

            Result = Add (Interface);

            if (S_OK == Result) 
            {

                Error = Interface -> Start ();

                if (ERROR_SUCCESS == Error) 
                {

                    DebugF(_T("H323: Interface %S activated, index %d\n"),
                        INET_NTOA (BindingInfo -> Address[0].Address), Index);

                    if (Q931ReceiveRedirectStartCount > 0
                        && Interface -> IsFirewalled ()
                        && !Interface -> HasQ931PortMapping ())
                    {

                        Interface -> StartQ931ReceiveRedirect ();

                    }

                } else {
            
                    RemoveByIndex (Interface -> Index);

                    delete Interface;
                }

            } else {

                switch (Result) {

                case E_FAIL:
                    Error = ERROR_INTERFACE_ALREADY_EXISTS;
                break;

                case E_OUTOFMEMORY:
                    Error = ERROR_NOT_ENOUGH_MEMORY;
                break;

                default:
                    Error = ERROR_CAN_NOT_COMPLETE;
                break;

                }

                delete Interface;
            }
            

        }  else {

            Error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    Unlock ();

    return Error; 

} // PROXY_INTERFACE_ARRAY::AddStartInterface 


void 
PROXY_INTERFACE_ARRAY::RemoveStopInterface (
    IN DWORD Index
    )

/*++

Routine Description:
    Removes an interface from the array, and stops it.

Arguments:
    Index - index of the interface to be removed and stopped.

Return Values:
    None

Notes:

--*/

{

    PROXY_INTERFACE* Interface;

    Lock ();

    Interface = RemoveByIndex (Index);

    if (Interface) 
    {

        Interface -> Stop ();

        delete Interface;
        Interface = NULL;

    } else {

        DebugF (_T("PROXY_INTERFACE_ARRAY::StopRemoveByIndex -- Tried to deactivate interface (index %d), but it does not exist.\n"),
                Index);
    }

    Unlock ();

} // PROXY_INTERFACE_ARRAY::RemoveStopInterface

void
PROXY_INTERFACE_ARRAY::StartQ931ReceiveRedirects (
    void
    )

{

    Lock();
    
    if (0 == Q931ReceiveRedirectStartCount++)
    {

        for (DWORD dwIndex = 0; dwIndex < Array.Length; dwIndex++)
        {

            Array[dwIndex] -> StartQ931ReceiveRedirect ();

        }
    }

    Unlock();

} // PROXY_INTERFACE_ARRAY::StartQ931ReceiveRedirects

void
PROXY_INTERFACE_ARRAY::StopQ931ReceiveRedirects (
    void
    )

{

    Lock();

    assert (Q931ReceiveRedirectStartCount > 0);
    
    if (0 == --Q931ReceiveRedirectStartCount)
    {

        for (DWORD dwIndex = 0; dwIndex < Array.Length; dwIndex++)
        {

            if (Array[dwIndex] -> IsFirewalled ()
                && !Array[dwIndex] -> HasQ931PortMapping ())
            {

                Array[dwIndex] -> StopQ931ReceiveRedirect ();

            }

        }
    }

    Unlock();

} // PROXY_INTERFACE_ARRAY::StopQ931ReceiveRedirects

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Auxiliary Functions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


static 
int 
__cdecl 
CompareInterfacesByIndex (
    IN PROXY_INTERFACE * const * InterfaceA,
    IN PROXY_INTERFACE * const * InterfaceB
    ) 

/*++

Routine Description:
    Compares two interfaces by their corresponding indices.

Arguments:
    InterfaceA - first comparand
    InterfaceB - second comparand

Return Values:
    1 if InterfaceA is considered to be greater than InterfaceB
    0 if InterfaceA is considered to be equal to the InterfaceB
    -1 if InterfaceA is considered to be equal to the InterfaceB

Notes:

--*/

{

    assert (InterfaceA);
    assert (InterfaceB);
    assert (*InterfaceA);
    assert (*InterfaceB);

    if ((*InterfaceA) -> GetIndex () > (*InterfaceB) -> GetIndex ()) 
    {

        return 1;

    } else if ((*InterfaceA) -> GetIndex () < (*InterfaceB) -> GetIndex ()) {

        return -1;

    } else {

        return 0;

    }    

} // ::CompareInterfacesByIndex


static 
INT 
SearchInterfaceByIndex (
    IN const DWORD * Index, 
    IN PROXY_INTERFACE * const * Comparand
    ) 

/*++

Routine Description:
    Compares an interface and a key (index of the interface)

Arguments:
    Index - key to which the interface is to be compared
    Comparand - interface to be compared with the key

Return Values:
    1 if key is considered to be greater than the comparand
    0 if key is considered to be equal to the comparand
    -1 if key is considered to be less than the comparand

Notes:

--*/

{

    assert (Comparand);
    assert (*Comparand);
    assert (Index);

    if (*Index > (*Comparand) -> GetIndex ()) 
    {

        return 1;

    } else if (*Index < (*Comparand) -> GetIndex ()) {

        return -1;

    } else { 

        return 0;

    }

} // ::SearchInterfaceByIndex


HRESULT
IsPrivateAddress (
    IN DWORD   Address,
    OUT BOOL * IsPrivate
    ) 

/*++

Routine Description:
    Determines whether the address specified is
    reachable through a private interface.

Arguments:
    Address - IP address for which the determination
              is to be made.

    IsPrivate - Result of the determination (TRUE or FALSE)

Return Values:
    Error code indicating whether the query succeded.

Notes:

--*/

{

    assert (IsPrivate);

    return InterfaceArray.IsPrivateAddress (Address, IsPrivate);

} // ::IsPrivateAddress


HRESULT
IsPublicAddress (
    IN DWORD   Address,
    OUT BOOL * IsPublic
    ) 

/*++

Routine Description:
    Determines whether the address specified is
    reachable through a public interface.

Arguments:
    Address - IP address for which the determination
              is to be made.

    IsPrivate - Result of the determination (TRUE or FALSE)

Return Values:
    Error code indicating whether the query succeded.

Notes:

--*/

{

    assert (IsPublic);

    return InterfaceArray.IsPublicAddress (Address, IsPublic);

} // ::IsPublicAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\ldap.h ===
#ifndef _LDAP_Module_H_
#define _LDAP_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct SearchResponse_entry_attributes_Seq_values * PSearchResponse_entry_attributes_Seq_values;

typedef struct ModifyRequest_modifications_Seq_modification_values * PModifyRequest_modifications_Seq_modification_values;

typedef struct AddRequest_attrs_Seq_values * PAddRequest_attrs_Seq_values;

typedef struct SearchResponse_entry_attributes * PSearchResponse_entry_attributes;

typedef struct SubstringFilter_attributes * PSubstringFilter_attributes;

typedef struct AddRequest_attrs * PAddRequest_attrs;

typedef struct ModifyRequest_modifications * PModifyRequest_modifications;

typedef struct SearchRequest_attributes * PSearchRequest_attributes;

typedef struct Filter_or * PFilter_or;

typedef struct Filter_and * PFilter_and;

typedef struct UnbindRequest {
    char placeholder;
} UnbindRequest;

typedef ASN1uint32_t MessageID;

typedef ASN1octetstring_t AttributeValue;

typedef ASN1octetstring_t LDAPString;

typedef MessageID AbandonRequest;

typedef LDAPString LDAPDN;

typedef LDAPString RelativeLDAPDN;

typedef LDAPString AttributeType;

typedef LDAPDN DelRequest;

typedef struct SearchResponse_entry_attributes_Seq_values {
    PSearchResponse_entry_attributes_Seq_values next;
    AttributeValue value;
} SearchResponse_entry_attributes_Seq_values_Element;

typedef struct ModifyRequest_modifications_Seq_modification_values {
    PModifyRequest_modifications_Seq_modification_values next;
    AttributeValue value;
} ModifyRequest_modifications_Seq_modification_values_Element;

typedef struct AddRequest_attrs_Seq_values {
    PAddRequest_attrs_Seq_values next;
    AttributeValue value;
} AddRequest_attrs_Seq_values_Element;

typedef struct ModifyRequest_modifications_Seq_modification {
    AttributeType type;
    PModifyRequest_modifications_Seq_modification_values values;
} ModifyRequest_modifications_Seq_modification;

typedef struct SearchResponse_entry_attributes_Seq {
    AttributeType type;
    PSearchResponse_entry_attributes_Seq_values values;
} SearchResponse_entry_attributes_Seq;

typedef struct SearchResponse_entry_attributes {
    PSearchResponse_entry_attributes next;
    SearchResponse_entry_attributes_Seq value;
} SearchResponse_entry_attributes_Element;

typedef enum operation {
    add = 0,
    operation_delete = 1,
    replace = 2,
} operation;
typedef struct ModifyRequest_modifications_Seq {
    operation operation;
    ModifyRequest_modifications_Seq_modification modification;
} ModifyRequest_modifications_Seq;

typedef struct AddRequest_attrs_Seq {
    AttributeType type;
    PAddRequest_attrs_Seq_values values;
} AddRequest_attrs_Seq;

typedef struct SubstringFilter_attributes_Seq {
    ASN1choice_t choice;
    union {
#	define initial_choice 1
	LDAPString initial;
#	define any_choice 2
	LDAPString any;
#	define final_choice 3
	LDAPString final;
    } u;
} SubstringFilter_attributes_Seq;

typedef struct SubstringFilter_attributes {
    PSubstringFilter_attributes next;
    SubstringFilter_attributes_Seq value;
} SubstringFilter_attributes_Element;

typedef struct AddRequest_attrs {
    PAddRequest_attrs next;
    AddRequest_attrs_Seq value;
} AddRequest_attrs_Element;

typedef struct ModifyRequest_modifications {
    PModifyRequest_modifications next;
    ModifyRequest_modifications_Seq value;
} ModifyRequest_modifications_Element;

typedef struct SearchResponse_entry {
    LDAPDN objectName;
    PSearchResponse_entry_attributes attributes;
} SearchResponse_entry;

typedef struct SearchRequest_attributes {
    PSearchRequest_attributes next;
    AttributeType value;
} SearchRequest_attributes_Element;

typedef struct SaslCredentials {
    LDAPString mechanism;
    ASN1octetstring_t credentials;
} SaslCredentials;

typedef struct ModifyRequest {
    LDAPDN object;
    PModifyRequest_modifications modifications;
} ModifyRequest;

typedef struct AddRequest {
    LDAPDN entry;
    PAddRequest_attrs attrs;
} AddRequest;

typedef struct ModifyRDNRequest {
    LDAPDN entry;
    RelativeLDAPDN newrdn;
} ModifyRDNRequest;

typedef enum resultCode {
    success = 0,
    operationsError = 1,
    protocolError = 2,
    timeLimitExceeded = 3,
    sizeLimitExceeded = 4,
    compareFalse = 5,
    compareTrue = 6,
    authMethodNotSupported = 7,
    strongAuthRequired = 8,
    noSuchAttribute = 16,
    undefinedAttributeType = 17,
    inappropriateMatching = 18,
    constraintViolation = 19,
    attributeOrValueExists = 20,
    invalidAttributeSyntax = 21,
    noSuchObject = 32,
    aliasProblem = 33,
    invalidDNSyntax = 34,
    isLeaf = 35,
    aliasDereferencingProblem = 36,
    inappropriateAuthentication = 48,
    invalidCredentials = 49,
    insufficientAccessRights = 50,
    busy = 51,
    unavailable = 52,
    unwillingToPerform = 53,
    loopDetect = 54,
    namingViolation = 64,
    objectClassViolation = 65,
    notAllowedOnNonLeaf = 66,
    notAllowedOnRDN = 67,
    entryAlreadyExists = 68,
    objectClassModsProhibited = 69,
    other = 80,
} resultCode;
typedef struct LDAPResult {
    resultCode resultCode;
    LDAPDN matchedDN;
    LDAPString errorMessage;
} LDAPResult;

typedef struct AttributeValueAssertion {
    AttributeType attributeType;
    AttributeValue attributeValue;
} AttributeValueAssertion;

typedef struct SubstringFilter {
    AttributeType type;
    PSubstringFilter_attributes attributes;
} SubstringFilter;

typedef struct AuthenticationChoice {
    ASN1choice_t choice;
    union {
#	define simple_choice 1
	ASN1octetstring_t simple;
#	define sasl_choice 2
	SaslCredentials sasl;
#	define sicilyNegotiate_choice 3
	ASN1octetstring_t sicilyNegotiate;
#	define sicilyInitial_choice 4
	ASN1octetstring_t sicilyInitial;
#	define sicilySubsequent_choice 5
	ASN1octetstring_t sicilySubsequent;
    } u;
} AuthenticationChoice;

typedef LDAPResult BindResponse;

typedef struct SearchResponse {
    ASN1choice_t choice;
    union {
#	define entry_choice 1
	SearchResponse_entry entry;
#	define resultCode_choice 2
	LDAPResult resultCode;
    } u;
} SearchResponse;

typedef LDAPResult ModifyResponse;

typedef LDAPResult AddResponse;

typedef LDAPResult DelResponse;

typedef LDAPResult ModifyRDNResponse;

typedef struct CompareRequest {
    LDAPDN entry;
    AttributeValueAssertion ava;
} CompareRequest;

typedef LDAPResult CompareResponse;

typedef struct Filter {
    ASN1choice_t choice;
    union {
#	define and_choice 1
	PFilter_and and;
#	define or_choice 2
	PFilter_or or;
#	define equalityMatch_choice 3
	AttributeValueAssertion equalityMatch;
#	define substrings_choice 4
	SubstringFilter substrings;
#	define greaterOrEqual_choice 5
	AttributeValueAssertion greaterOrEqual;
#	define lessOrEqual_choice 6
	AttributeValueAssertion lessOrEqual;
#	define present_choice 7
	AttributeType present;
#	define approxMatch_choice 8
	AttributeValueAssertion approxMatch;
    } u;
} Filter;

typedef struct Filter_or {
    PFilter_or next;
    Filter value;
} Filter_or_Element;

typedef struct Filter_and {
    PFilter_and next;
    Filter value;
} Filter_and_Element;

typedef struct BindRequest {
    ASN1uint16_t version;
    LDAPDN name;
    AuthenticationChoice authentication;
} BindRequest;

typedef enum scope {
    baseObject = 0,
    singleLevel = 1,
    wholeSubtree = 2,
} scope;
typedef enum derefAliases {
    neverDerefAliases = 0,
    derefInSearching = 1,
    derefFindingBaseObj = 2,
    alwaysDerefAliases = 3,
} derefAliases;
typedef struct SearchRequest {
    LDAPDN baseObject;
    scope scope;
    derefAliases derefAliases;
    ASN1uint32_t sizeLimit;
    ASN1uint32_t timeLimit;
    ASN1bool_t attrsOnly;
    Filter filter;
    PSearchRequest_attributes attributes;
} SearchRequest;

typedef struct LDAPMessage_protocolOp {
    ASN1choice_t choice;
    union {
#	define bindRequest_choice 1
	BindRequest bindRequest;
#	define bindResponse_choice 2
	BindResponse bindResponse;
#	define unbindRequest_choice 3
	UnbindRequest unbindRequest;
#	define searchRequest_choice 4
	SearchRequest searchRequest;
#	define searchResponse_choice 5
	SearchResponse searchResponse;
#	define modifyRequest_choice 6
	ModifyRequest modifyRequest;
#	define modifyResponse_choice 7
	ModifyResponse modifyResponse;
#	define addRequest_choice 8
	AddRequest addRequest;
#	define addResponse_choice 9
	AddResponse addResponse;
#	define delRequest_choice 10
	DelRequest delRequest;
#	define delResponse_choice 11
	DelResponse delResponse;
#	define modifyRDNRequest_choice 12
	ModifyRDNRequest modifyRDNRequest;
#	define modifyRDNResponse_choice 13
	ModifyRDNResponse modifyRDNResponse;
#	define compareDNRequest_choice 14
	CompareRequest compareDNRequest;
#	define compareDNResponse_choice 15
	CompareResponse compareDNResponse;
#	define abandonRequest_choice 16
	AbandonRequest abandonRequest;
    } u;
} LDAPMessage_protocolOp;

typedef struct LDAPMessage {
    MessageID messageID;
    LDAPMessage_protocolOp protocolOp;
} LDAPMessage;
#define LDAPMessage_ID 0
#define SIZE_LDAP_Module_ID_0 sizeof(LDAPMessage)

extern ASN1int32_t maxInt;

extern ASN1module_t LDAP_Module;
extern void ASN1CALL LDAP_Module_Startup(void);
extern void ASN1CALL LDAP_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _LDAP_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\ldappx.cpp ===
/*++

Copyright (c) 1998 - 2000  Microsoft Corporation

Module Name:
    ldappx.cpp

Abstract:
    Defines methods utilized by abstract data types used in LDAP portion of the H.323/LDAP proxy.

    LDAP Proxy is designed as an addition to H.323 proxy. The main purpose of the
    LDAP proxy is to maintain LDAP Address Translation Table, which is used to map
    aliases of H.323 endpoints to their IP addresses. The proxy adds an entry when it
    intercepts an LDAP PDU from a client to directory server, and the PDU matches all
    predefined criteria.

Author(s):          ArlieD, IlyaK   14-Jul-1999

Revision History:
    07/14/1999      File creation                                  Arlie Davis  (ArlieD)
    08/20/1999      Improvement of processing of LDAP              Ilya Kleyman (IlyaK)
                    LDAP SearchRequests
    12/20/1999      Added prediction of receive sizes in           Ilya Kleyman (IlyaK)
                    non-interpretative data transfer mode
    02/20/2000      Added expiration policy of the entries         Ilya Kleyman (IlyaK)
                    in LDAP Address Translation Table
    03/12/2000      Added support for multiple private and         Ilya Kleyman (IlyaK)
                    multiple public interface for RRAS

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ber.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Constants                                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static    const    ANSI_STRING        LdapText_C                        = ANSI_STRING_INIT("c");
static    const    ANSI_STRING        LdapText_CN                       = ANSI_STRING_INIT("cn");
static    const    ANSI_STRING        LdapText_ObjectClass              = ANSI_STRING_INIT("objectClass");
static    const    ANSI_STRING        LdapText_O                        = ANSI_STRING_INIT("o");
static    const    ANSI_STRING        LdapText_OU                       = ANSI_STRING_INIT("ou");

static    const    ANSI_STRING        LdapText_RTPerson                 = ANSI_STRING_INIT("RTPerson");
static    const    ANSI_STRING        LdapText_Attribute_sipaddress     = ANSI_STRING_INIT("sipaddress");
static    const    ANSI_STRING        LdapText_Attribute_ipAddress      = ANSI_STRING_INIT("ipAddress");
static    const    ANSI_STRING        LdapText_Attribute_sttl           = ANSI_STRING_INIT("sttl");
static    const    ANSI_STRING        LdapText_Attribute_comment        = ANSI_STRING_INIT("comment");
static    const    ANSI_STRING        LdapText_Modify_EntryTTL          = ANSI_STRING_INIT("EntryTTL");

static    const    ANSI_STRING        LdapText_GeneratedByTAPI          = ANSI_STRING_INIT("Generated by TAPI3");
static    const    ANSI_STRING        LdapText_ModifiedByICS            = ANSI_STRING_INIT("Made possible by ICS");
static    const    ANSI_STRING        LdapText_TableSizeExceededMessage = ANSI_STRING_INIT("Resources on proxy used up.");

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SYNC_COUNTER           LdapSyncCounter;
LDAP_CONNECTION_ARRAY  LdapConnectionArray;
LDAP_TRANSLATION_TABLE LdapTranslationTable;
LDAP_CODER             LdapCoder;
LDAP_ACCEPT            LdapAccept;
SOCKADDR_IN            LdapListenSocketAddress;
DWORD                  EnableLocalH323Routing;

// utility functions ------------------------------------------------------------------

#if DBG
static BOOL BerDumpStopFn (VOID)
{
    return FALSE;
}

static void BerDumpOutputFn (char * Format, ...)
{
    if (DebugLevel > 0) {
        va_list    Va;
        CHAR    Text    [0x200];

        va_start (Va, Format);
        _vsnprintf (Text, 0x200, Format, Va);
        va_end (Va);

        OutputDebugStringA (Text);
    }
}

static void BerDump (IN LPBYTE Data, IN DWORD Length)
{
    ber_decode (BerDumpOutputFn, BerDumpStopFn, Data,
        0, // DECODE_NEST_OCTET_STRINGS,
        0, 0, Length, 0);
}

#endif // DBG

// LdapQueryTable queries the LDAP translation table for a given alias.
// The alias was one that was previously registered by a LDAP endpoint.
// We do not care about the type of the alias (h323_ID vs emailID, etc.) --
// the semantics of the alias type are left to the Q.931 code.
//
// returns S_OK on success
// returns S_FALSE if no entry was found
// returns an error code if an actual error occurred.

HRESULT LdapQueryTableByAlias (
    IN    ANSI_STRING *    Alias,
    OUT    DWORD *    ReturnClientAddress) // host order
{
    HRESULT        Result;
    IN_ADDR     Address;

    assert (Alias);
    assert (ReturnClientAddress);

    Result = LdapTranslationTable.QueryTableByAlias (Alias, &Address);
    if (Result == S_OK) {
        *ReturnClientAddress = ntohl (Address.s_addr);
        return Result;
    }

    Result = LdapTranslationTable.QueryTableByCN (Alias, &Address);
    if (Result == S_OK) {
        *ReturnClientAddress = ntohl (Address.s_addr);
        return Result;
    }

    return Result;
}

HRESULT LdapQueryTableByAliasServer (
    IN    ANSI_STRING *    Alias,
    IN  SOCKADDR_IN *   ServerAddress,
    OUT    DWORD *    ReturnClientAddress) // host order
{
    HRESULT        Result;
    IN_ADDR     Address;

    assert (Alias);
    assert (ReturnClientAddress);

    Result = LdapTranslationTable.QueryTableByAliasServer (Alias, ServerAddress, &Address);
    if (Result == S_OK) {
        *ReturnClientAddress = ntohl (Address.s_addr);
        return Result;
    }

    Result = LdapTranslationTable.QueryTableByCNServer (Alias, ServerAddress, &Address);
    if (Result == S_OK) {
        *ReturnClientAddress = ntohl (Address.s_addr);
        return Result;
    }

    return Result;
}
#if    DBG
void LdapPrintTable (void) {
    LdapTranslationTable.PrintTable ();
}
#endif // DBG

static DWORD LdapDeterminePacketBoundary (
    IN   LDAP_BUFFER * Buffer,
    IN   DWORD         PacketOffset,   
    OUT  DWORD *       NextPacketOffset,   // Points to the beginning of next packet only if function returns ERROR_SUCCESS 
    OUT     DWORD *       NextReceiveSize)    // Is only meaningful when function returns any value other than ERROR_SUCCESS
{
    DWORD    PayloadLength;
    DWORD    ASNHeaderLength = ASN_MIN_HEADER_LEN;
    DWORD    PacketSize;
    DWORD    ByteIndex;
    DWORD   Length;
    LPBYTE  Data;

    assert (Buffer);
    assert (Buffer -> Data.Data);

    Length = Buffer -> Data.Length - PacketOffset;
    Data   = Buffer -> Data.Data;
    
    // Pick reasonable default for the size of
    // next receive request. Will be changed if necessary

    *NextReceiveSize = LDAP_BUFFER_RECEIVE_SIZE;

    if (Length != 0) {

        if (Data [PacketOffset] == ASN_SEQUENCE_TAG) {

            if (Length >= ASN_MIN_HEADER_LEN) {
            
                if (Data [PacketOffset + 1] & ASN_LONG_HEADER_BIT) {
                    // Long (more than ASN_MIN_HEADER_LEN bytes) ASN header
                    // Size of the payload length field is indicated in the
                    // second nybble of second byte

                    ASNHeaderLength += Data [PacketOffset + 1] & ~ASN_LONG_HEADER_BIT;

                    // This is where the limit on payload length is established.
                    // The test below assures it won't be greater than 2 ^ sizeof (DWORD) (4 GBytes)
                    if (ASNHeaderLength <= ASN_MIN_HEADER_LEN + sizeof (DWORD)) {

                        if (Length >= ASNHeaderLength) {

                            PayloadLength  = 0;

                            for (ByteIndex = ASN_MIN_HEADER_LEN;
                                 ByteIndex < ASNHeaderLength; 
                                 ByteIndex++) {
                                
                                 PayloadLength *= 1 << CHAR_BIT;
                                 PayloadLength += (DWORD) Data [PacketOffset + ByteIndex];  
                            }

                        } else {

                            // Not enough data to even read the ASN header
                            return ERROR_MORE_DATA;

                        }

                    } else {

                        DebugF (_T("LDAP: Payload size field (%d bytes) is too big.\n"), ASNHeaderLength - ASN_MIN_HEADER_LEN);

                        return ERROR_INVALID_DATA;
                    }

                } else  {

                    // Short (Exactly ASN_MIN_HEADER_LEN bytes) ASN header
                    // Payload length is indicated in the second byte

                    PayloadLength = (DWORD) Data [PacketOffset + 1];
                }

                PacketSize = ASNHeaderLength + PayloadLength;

                if (Length >= PacketSize) {

                    *NextPacketOffset = PacketOffset + PacketSize;

                    return ERROR_SUCCESS;

                 } else {
                    
                    *NextReceiveSize = PacketSize - Length;
                }
            }

        } else {

            Debug (_T("LDAP: Failed to find ASN sequence tag.\n"));
            
            return ERROR_INVALID_DATA;
        }
    }

    return ERROR_MORE_DATA;
}

static BOOL FindChar (
    IN    ANSI_STRING *    String,
    IN    CHAR            Char,
    OUT    USHORT *        ReturnIndex)
{
    LPSTR    Pos;
    LPSTR    End;

    assert (String);
    assert (ReturnIndex);

    Pos = String -> Buffer;
    End = String -> Buffer + String -> Length / sizeof (CHAR);

    for (; Pos < End; Pos++) {
        if (*Pos == Char) {
            *ReturnIndex = (USHORT) (Pos - String -> Buffer);
            return TRUE;
        }
    }

    return FALSE;
}

static void ParseDirectoryPathElement (
    IN        ANSI_STRING *            Element,
    IN    OUT    LDAP_PATH_ELEMENTS *    PathElements)
{
    ANSI_STRING        Tag;
    ANSI_STRING        Value;
    USHORT            Index;

    if (FindChar (Element, LDAP_PATH_EQUAL_CHAR, &Index)) {
        assert (Index * sizeof (CHAR) < Element -> Length);

        Tag.Buffer = Element -> Buffer;
        Tag.Length = Index * sizeof (CHAR);

        Index++;        // step over separator

        Value.Buffer = Element -> Buffer + Index;
        Value.Length = Element -> Length - Index * sizeof (CHAR);

        if (RtlEqualStringConst (&Tag, &LdapText_C, TRUE))
            PathElements -> C = Value;
        else if (RtlEqualStringConst (&Tag, &LdapText_CN, TRUE))
            PathElements -> CN = Value;
        else if (RtlEqualStringConst (&Tag, &LdapText_ObjectClass, TRUE))
            PathElements -> ObjectClass = Value;
        else if (RtlEqualStringConst (&Tag, &LdapText_O, TRUE))
            PathElements -> O = Value;
    }
}

static void ParseDirectoryPath (
    IN    ANSI_STRING *            DirectoryPath,
    OUT    LDAP_PATH_ELEMENTS *    ReturnData)
{
    ANSI_STRING        SubString;
    USHORT            Index;
    ANSI_STRING        Element;

    assert (DirectoryPath);
    assert (ReturnData);
    assert (DirectoryPath -> Buffer);

    ZeroMemory (ReturnData, sizeof (LDAP_PATH_ELEMENTS));

    SubString = *DirectoryPath;

    while (FindChar (&SubString, LDAP_PATH_SEP_CHAR, &Index)) {
        assert (Index * sizeof (CHAR) < SubString.Length);

        Element.Buffer = SubString.Buffer;
        Element.Length = Index * sizeof (CHAR);

        Index++;        // step over separator

        SubString.Buffer += Index;
        SubString.Length -= Index * sizeof (CHAR);

        ParseDirectoryPathElement (&Element, ReturnData);
    }

    ParseDirectoryPathElement (&SubString, ReturnData);
}

static void ParseObjectNameElement (
    IN        ANSI_STRING *                Element,
    IN    OUT    LDAP_OBJECT_NAME_ELEMENTS *    ObjectNameElements)
{
    ANSI_STRING        Tag;
    ANSI_STRING        Value;
    USHORT            Index;

    if (FindChar (Element, LDAP_PATH_EQUAL_CHAR, &Index)) {
        assert (Index * sizeof (CHAR) < Element -> Length);

        Tag.Buffer = Element -> Buffer;
        Tag.Length = Index * sizeof (CHAR);

        Index++;        // step over separator

        Value.Buffer = Element -> Buffer + Index;
        Value.Length = Element -> Length - Index * sizeof (CHAR);

        if (RtlEqualStringConst (&Tag, &LdapText_CN, TRUE))
            ObjectNameElements -> CN = Value;
        else if (RtlEqualStringConst (&Tag, &LdapText_O, TRUE))
            ObjectNameElements -> O = Value;
        else if (RtlEqualStringConst (&Tag, &LdapText_OU, TRUE))
            ObjectNameElements -> OU = Value;
    }
}

static void ParseObjectName (
    IN    ANSI_STRING *                ObjectName,
    OUT    LDAP_OBJECT_NAME_ELEMENTS *    ReturnData)
{
    ANSI_STRING        SubString;
    USHORT            Index;
    ANSI_STRING        Element;

    assert (ObjectName);
    assert (ReturnData);
    assert (ObjectName -> Buffer);

    ZeroMemory (ReturnData, sizeof (LDAP_OBJECT_NAME_ELEMENTS));

    SubString = *ObjectName;

    while (FindChar (&SubString, LDAP_PATH_SEP_CHAR, &Index)) {
        assert (Index * sizeof (CHAR) < SubString.Length);

        Element.Buffer = SubString.Buffer;
        Element.Length = Index * sizeof (CHAR);

        Index++;        // step over separator

        SubString.Buffer += Index;
        SubString.Length -= Index * sizeof (CHAR);

        ParseObjectNameElement (&Element, ReturnData);
    }

    ParseObjectNameElement (&SubString, ReturnData);
}

// LDAP_TRANSLATION_ENTRY ------------------------------------------------


HRESULT 
LDAP_TRANSLATION_ENTRY::IsRegisteredViaInterface (
    IN DWORD InterfaceAddress,      // host order
    OUT BOOL *Result
    )
/*++

Routine Description:
    Determines whether the entry is registered via the
    interface specified

Arguments:
    InterfaceAddress - address of the interface for which
        the determination is to be made.

    Result (out)     - TRUE if entry was registered via the interface
                       FALSE if entry was not registered via the interface

Return Values:
    TRUE - if determination succeeded

    FALSE - if determination failed

Notes:

--*/

{
    DWORD BestInterfaceAddress;
    ULONG Error;

    Error = GetBestInterfaceAddress (ntohl (ClientAddress.s_addr), &BestInterfaceAddress);

    *Result = FALSE;

    if (ERROR_SUCCESS == Error) {

        *Result = (BestInterfaceAddress == InterfaceAddress);
    }

    return HRESULT_FROM_WIN32 (Error);
}

// LDAP_TRANSLATION_TABLE ------------------------------------------------

LDAP_TRANSLATION_TABLE::LDAP_TRANSLATION_TABLE (void)
{
    IsEnabled = FALSE;
    GarbageCollectorTimerHandle = NULL;
}

LDAP_TRANSLATION_TABLE::~LDAP_TRANSLATION_TABLE (void)
{
    assert (!IsEnabled);
    assert (Array.Length == 0);
}

void LDAP_TRANSLATION_TABLE::Stop (void)
{
    HRESULT Result;

    Lock();

    IsEnabled = FALSE;

    if (GarbageCollectorTimerHandle) {

        if (DeleteTimerQueueTimer(NATH323_TIMER_QUEUE, 
                                  GarbageCollectorTimerHandle,
                                  INVALID_HANDLE_VALUE))
        {

            DebugF (_T("LDAP: Garbage collection is deactivated.\n"));

        }
        else {

            Result = GetLastError ();

            DebugError (Result, _T("LDAP: Could not deactivate garbage collection.\n"));

        }

        GarbageCollectorTimerHandle = NULL;
    }

    Array.Free();

    Unlock ();
}

HRESULT LDAP_TRANSLATION_TABLE::Start (void)
{
    HRESULT Result;

    Lock ();

    assert (!GarbageCollectorTimerHandle);

    if (CreateTimerQueueTimer(&GarbageCollectorTimerHandle,
                               NATH323_TIMER_QUEUE,
                               GarbageCollectorCallback,
                               this,
                               LDAP_TRANSLATION_TABLE_GARBAGE_COLLECTION_PERIOD,
                               LDAP_TRANSLATION_TABLE_GARBAGE_COLLECTION_PERIOD,    // periodic timer
                               WT_EXECUTEINIOTHREAD)) {

        DebugF (_T("LDAP: Successfully activated garbage collection.\n"));

        IsEnabled = TRUE;

        Result = S_OK;
    }
    else {

        Result = GetLastError ();

        DebugLastError (_T("LDAP: Failed to activate garbage collection.\n"));
    }

    Unlock ();

    return Result;
}

// static
void LDAP_TRANSLATION_TABLE::GarbageCollectorCallback (
    PVOID Context,
    BOOLEAN TimerOrWaitFired) 
{
    LDAP_TRANSLATION_TABLE * Table;

    Table = (LDAP_TRANSLATION_TABLE *) Context;

    Table -> RemoveOldEntries ();
}

HRESULT LDAP_TRANSLATION_TABLE::RefreshEntry (
    IN ANSI_STRING * Alias,
    IN ANSI_STRING * DirectoryPath,
    IN IN_ADDR       ClientAddress,
    IN SOCKADDR_IN * ServerAddress,
    IN DWORD         TimeToLive) // in seconds
{
    DebugF (_T("LDAP: Refreshing local entry for (%.*S) @ %08X:%04X.\n"), 
                ANSI_STRING_PRINTF (Alias),
                SOCKADDR_IN_PRINTF (ServerAddress));

    return InsertEntry (Alias, DirectoryPath, ClientAddress, ServerAddress, TimeToLive);
}

void LDAP_TRANSLATION_TABLE::RemoveOldEntries (void)
{
    DWORD CurrentTime;

    DWORD  Index;

    Lock ();

    if (IsEnabled) {

        CurrentTime = GetTickCount () / 1000;

        DebugF (_T("LDAP: Garbage collection commenced at %d.\n"), CurrentTime);

        Index = 0;

        while (Index < Array.Length) {

            if (CurrentTime > Array [Index].TimeStamp) {

                DebugF (_T("LDAP: Expiring entry @%d, alias -- (%.*S) from translation table.\n"),
                     Index, ANSI_STRING_PRINTF (&Array [Index].Alias));

                Array[Index].FreeContents ();
                Array.DeleteAtPos (Index);

                InterfaceArray.StopQ931ReceiveRedirects ();

            } else {
                
                Index++;
            }
        }

        DebugF (_T("LDAP: Garbage collection completed.\n"));
    }

    Unlock ();
}
    
HRESULT LDAP_TRANSLATION_TABLE::QueryTableByAlias (
    IN    ANSI_STRING *    Alias,
    OUT    IN_ADDR *        ReturnClientAddress)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    DWORD        Index;
    HRESULT        Result;
    
    assert (Alias);
    assert (ReturnClientAddress);

    Lock();

    if (IsEnabled) {

        Result = S_FALSE;

        Array.GetExtents (&Pos, &End);
        for (; Pos < End; Pos++) {
            if (RtlEqualStringConst (&Pos -> Alias, Alias, TRUE)) {
                *ReturnClientAddress = Pos -> ClientAddress;
                Result = S_OK;
                break;
            }
        }

    }
    else {
        Result = S_FALSE;
    }

    Unlock();

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::QueryTableByCN (
    IN    ANSI_STRING *    CN,
    OUT    IN_ADDR *        ReturnClientAddress)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    HRESULT        Result;

    assert (CN);
    assert (ReturnClientAddress);

    Lock();

    if (IsEnabled) {

        Result = S_FALSE;

        Array.GetExtents (&Pos, &End);
        for (; Pos < End; Pos++) {
            if (RtlEqualStringConst (&Pos -> CN, CN, TRUE)) {
                *ReturnClientAddress = Pos -> ClientAddress;
                Result = S_OK;
                break;
            }
        }
    }
    else {

        Result = S_FALSE;
    }

    Unlock();

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::QueryTableByAliasServer (
    IN    ANSI_STRING *    Alias,
    IN  SOCKADDR_IN *   ServerAddress,
    OUT    IN_ADDR *        ReturnClientAddress)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    DWORD        Index;
    HRESULT        Result;
    BOOL        ServerIsSame;
    BOOL        AliasIsSame;
    
    assert (Alias);
    assert (ServerAddress);
    assert (ReturnClientAddress);

    Lock();

    if (IsEnabled) {

        Result = S_FALSE;

        Array.GetExtents (&Pos, &End);
        for (; Pos < End; Pos++) {

            AliasIsSame = RtlEqualStringConst (&Pos -> Alias, Alias, TRUE); 
            ServerIsSame = (ServerAddress -> sin_addr.s_addr == Pos -> ServerAddress.sin_addr.s_addr) // addresses are literally equal
                           ||
                           (    ::NhIsLocalAddress (ServerAddress -> sin_addr.s_addr)
                             && ::NhIsLocalAddress (Pos -> ServerAddress.sin_addr.s_addr));         // two addresses of the local machine

            if (AliasIsSame && ServerIsSame) {
                *ReturnClientAddress = Pos -> ClientAddress;
                Result = S_OK;
                break;
            }
        }

    }
    else {
        Result = S_FALSE;
    }

    Unlock();

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::QueryTableByCNServer (
    IN    ANSI_STRING *    CN,
    IN  SOCKADDR_IN *   ServerAddress,
    OUT    IN_ADDR *        ReturnClientAddress)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    HRESULT        Result;
    BOOL        ServerIsSame;
    BOOL        CN_IsSame;

    assert (CN);
    assert (ServerAddress);
    assert (ReturnClientAddress);

    Lock();

    if (IsEnabled) {

        Result = S_FALSE;

        Array.GetExtents (&Pos, &End);
        for (; Pos < End; Pos++) {
            CN_IsSame = RtlEqualStringConst (&Pos -> CN, CN, TRUE); 
            ServerIsSame = (ServerAddress -> sin_addr.s_addr == Pos -> ServerAddress.sin_addr.s_addr) // addresses are literally equal
                           ||
                           (    ::NhIsLocalAddress (ServerAddress -> sin_addr.s_addr)
                             && ::NhIsLocalAddress (Pos -> ServerAddress.sin_addr.s_addr));         // two addresses of the local machine

            if (CN_IsSame && ServerIsSame) {
                *ReturnClientAddress = Pos -> ClientAddress;
                Result = S_OK;
                break;
            }
        }
    }
    else {

        Result = S_FALSE;
    }

    Unlock();

    return Result;
}

#if DBG
void LDAP_TRANSLATION_TABLE::PrintTable (void)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;

    DebugF (_T("LDAP: Printing out Address Translation Table.\n"));
 
    Lock();

    if (IsEnabled) {

        Array.GetExtents (&Pos, &End);

        DebugF (_T("\n"));

        for (; Pos < End; Pos++) {
            DebugF (_T("\tEntry at %x:\n"), Pos);
            DebugF (_T ("\t\tAlias - %.*S\n"),
                 ANSI_STRING_PRINTF (&Pos -> Alias)); 
            DebugF (_T ("\t\tDirectoryPath - %.*S\n"),
                 ANSI_STRING_PRINTF (&Pos -> DirectoryPath)); 
            DebugF (_T ("\t\tCN - %.*S\n"),
                 ANSI_STRING_PRINTF (&Pos -> CN)); 
            DebugF (_T("\t\tClientAddress - %x\n"), ntohl(Pos->ClientAddress.s_addr));
            DebugF (_T("\t\tServerAddress - %x:%x\n"),
                SOCKADDR_IN_PRINTF (&Pos -> ServerAddress));
            DebugF (_T("\t\tTimeStamp - %u\n"), Pos -> TimeStamp);
        }

        DebugF (_T("\n"));
    }

    Unlock();
}
#endif

HRESULT LDAP_TRANSLATION_TABLE::InsertEntry (
    IN    ANSI_STRING *    Alias,
    IN    ANSI_STRING *    DirectoryPath,
    IN    IN_ADDR            ClientAddress,
    IN    SOCKADDR_IN *    ServerAddress,
    IN    DWORD            TimeToLive) // in seconds
{
    HRESULT  Result;

    assert (Alias);
    assert (Alias -> Buffer);
    assert (DirectoryPath);
     assert (DirectoryPath -> Buffer);
    assert (ServerAddress);

    Lock();

    Result = InsertEntryLocked (Alias, DirectoryPath, ClientAddress, ServerAddress, TimeToLive);

    Unlock();

#if DBG
    if (DebugLevel > 1) 
    {

        LdapPrintTable ();

    }
#endif // DBG

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::FindEntryByPathServer (
    IN    ANSI_STRING *    DirectoryPath,
    IN    SOCKADDR_IN *    ServerAddress,
    OUT    LDAP_TRANSLATION_ENTRY **    ReturnTranslationEntry)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    HRESULT        Result;

    Result = S_FALSE;

    Array.GetExtents (&Pos, &End);
    for (; Pos < End; Pos++) {

        if (RtlEqualStringConst (&Pos -> DirectoryPath, DirectoryPath, TRUE)
            && IsEqualSocketAddress (&Pos -> ServerAddress, ServerAddress)) {

            *ReturnTranslationEntry = Pos;
            Result = S_OK;
            break;
        }
    }

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::FindEntryByAliasServer (
    IN    ANSI_STRING *    Alias,
    IN    SOCKADDR_IN *    ServerAddress,
    OUT    LDAP_TRANSLATION_ENTRY **    ReturnTranslationEntry)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    HRESULT        Result;

    Result = S_FALSE;

    Array.GetExtents (&Pos, &End);
    for (; Pos < End; Pos++) {

        if (RtlEqualStringConst (&Pos -> Alias, Alias, TRUE)
            // && IsEqualSocketAddress (&Pos -> ServerAddress, ServerAddress)) {
            && Pos -> ServerAddress.sin_addr.s_addr == ServerAddress -> sin_addr.s_addr) {

            *ReturnTranslationEntry = Pos;
            Result = S_OK;
            break;
        }
    }

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::InsertEntryLocked (
    IN    ANSI_STRING *    Alias,
    IN    ANSI_STRING *    DirectoryPath,
    IN    IN_ADDR            ClientAddress,
    IN    SOCKADDR_IN *    ServerAddress,
    IN    DWORD            TimeToLive) // in seconds
{
    LDAP_TRANSLATION_ENTRY *    TranslationEntry;
    LDAP_PATH_ELEMENTS    PathElements;
    HRESULT            Result;
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;

    assert (Alias);
    assert (DirectoryPath);
    assert (ServerAddress);

    if (!IsEnabled)
        return S_FALSE;

    // locate any existing entry
    // the identity of the entry is determined by the tuple:
    //        < ServerAddress ClientAlias >

    if (FindEntryByAliasServer (Alias, ServerAddress, &TranslationEntry) == S_OK) {
        Debug (_T("LDAP: Replacing existing translation entry.\n"));

        TranslationEntry -> FreeContents();
    }
    else {
        Debug (_T("LDAP: Allocating new translation entry.\n"));

        TranslationEntry = Array.AllocAtEnd();
        if (!TranslationEntry) {
            Debug (_T("LDAP: Failed to allocate translation entry.\n"));
            return E_OUTOFMEMORY;
        }
    }

    TranslationEntry -> ClientAddress = ClientAddress;
    TranslationEntry -> ServerAddress = *ServerAddress;
    TranslationEntry -> TimeStamp  = GetTickCount () / 1000 + TimeToLive;

    // copy the strings
    CopyAnsiString (Alias, &TranslationEntry -> Alias);
    CopyAnsiString (DirectoryPath, &TranslationEntry -> DirectoryPath);

    if (TranslationEntry -> DirectoryPath.Buffer) {
        ParseDirectoryPath (&TranslationEntry -> DirectoryPath, &PathElements);
        if (PathElements.CN.Buffer) {
            TranslationEntry -> CN = PathElements.CN;
        }
        else {
            Debug (_T("LDAP: Cannot insert translation entry -- CN is not specified.\n"));
            TranslationEntry -> CN.Buffer = NULL;
        }
    }
    else {
        TranslationEntry -> CN.Buffer = NULL;
    }

    // test and make sure all allocation code paths succeeded
    if (TranslationEntry -> Alias.Buffer
        && TranslationEntry -> DirectoryPath.Buffer
        && TranslationEntry -> CN.Buffer) {

        Result = S_OK;

    } else {
        Debug (_T("LDAP: Failed to allocate memory (or failed to find CN).\n"));

        FreeAnsiString (&TranslationEntry -> Alias);
        FreeAnsiString (&TranslationEntry -> DirectoryPath);

        Array.DeleteEntry (TranslationEntry);

        Result = E_OUTOFMEMORY;
    }

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::RemoveEntry (
    IN    SOCKADDR_IN *    ServerAddress,
    IN    ANSI_STRING *    DirectoryPath)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    HRESULT        Result;
    
    Lock();

    assert (ServerAddress);
    assert (DirectoryPath);

    Result = S_FALSE;

    Array.GetExtents (&Pos, &End);
    for (; Pos < End; Pos++) {

        if (RtlEqualString (DirectoryPath, &Pos -> DirectoryPath, TRUE)
            && Compare_SOCKADDR_IN (ServerAddress, &Pos -> ServerAddress) == 0) {

            Pos -> FreeContents();

            Array.DeleteEntry (Pos);

            InterfaceArray.StopQ931ReceiveRedirects ();

            Result = S_OK;

            break;
        }
    }

    Unlock();

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::RemoveEntryByAliasServer (
    IN    ANSI_STRING *    Alias,
    IN  SOCKADDR_IN *   ServerAddress)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    HRESULT        Result;
    BOOL        AliasIsSame;
    BOOL        ServerIsSame;
    
    Lock ();

    assert (Alias);

    Result = S_FALSE;

    Array.GetExtents (&Pos, &End);
    for (; Pos < End; Pos++) {
        AliasIsSame = RtlEqualStringConst (&Pos -> Alias, Alias, TRUE); 
        ServerIsSame = (ServerAddress -> sin_addr.s_addr == Pos -> ServerAddress.sin_addr.s_addr) // addresses are literally equal
                       ||
                       (    ::NhIsLocalAddress (ServerAddress -> sin_addr.s_addr)
                         && ::NhIsLocalAddress (Pos -> ServerAddress.sin_addr.s_addr));         // two addresses of the local machine


        if (AliasIsSame && ServerIsSame) {

            Pos -> FreeContents();

            Array.DeleteEntry (Pos);

            InterfaceArray.StopQ931ReceiveRedirects ();

            Result = S_OK;

            break;
        }
    }

    Unlock ();

    return Result;
}
 

void 
LDAP_TRANSLATION_TABLE::OnInterfaceShutdown (
    IN DWORD          InterfaceAddress
    )
/*++

Routine Description:
    Removes all entries registered by the clients reachable
    thorough the interface specified, except for entries registered by
    a local client.

Arguments:
    InterfaceAddress - address of the interface for which
        the determination is to be made.

Return Values:
    None

Notes:

--*/

{
    DWORD ArrayIndex = 0;
    LDAP_TRANSLATION_ENTRY * Entry;
    BOOL  IsEntryToBeDeleted;
    HRESULT Result;

    Lock ();
    
    if (IsEnabled) {

        DebugF (_T("LDAP: Forcibly removing non-local translation entries registered via %08X.\n"), InterfaceAddress);

        while (ArrayIndex < Array.GetLength ()) {
            Entry = &Array [ArrayIndex];

            Result = Entry -> IsRegisteredViaInterface (InterfaceAddress, &IsEntryToBeDeleted);

            // Don't delete the entry if it was registered by a local client. This is because
            // the client will still be available for H.323 calls.
            IsEntryToBeDeleted = IsEntryToBeDeleted && !::NhIsLocalAddress (Entry -> ClientAddress.s_addr);

            if (S_OK == Result) {

                if (IsEntryToBeDeleted) {

                    DebugF (_T("LDAP: Forcibly removing entry (%.*S:%08X) @ %08X:%04X.\n"), 
                        ANSI_STRING_PRINTF (&Entry -> Alias), 
                        ntohl (Entry -> ClientAddress.s_addr),
                        SOCKADDR_IN_PRINTF (&Entry -> ServerAddress));

                    Entry -> FreeContents();

                    Array.DeleteEntry (Entry);

                    InterfaceArray.StopQ931ReceiveRedirects ();

                } else {

                    ArrayIndex++;

                }

            } else {
            
                // There probably was something wrong with just this entry. Skip it and continue 
                // searching for entries registered via the interface

                ArrayIndex++;

                DebugF (_T("LDAP: Failed to determine whether entry (%.*S:%08X) @ %08X:%04X was registered via interface %08X. Error=0x%x\n"),
                        ANSI_STRING_PRINTF (&Entry -> Alias), 
                        ntohl (Entry -> ClientAddress.s_addr),
                        SOCKADDR_IN_PRINTF (&Entry -> ServerAddress),
                        InterfaceAddress,
                        Result);
            }
        }
    }

    Unlock ();

} // LDAP_TRANSLATION_TABLE::RemoveEntriesForClientsOnInterface

BOOL LDAP_TRANSLATION_TABLE::ReachedMaximumSize (void) {
    DWORD NumberOfEntries;

    Lock ();

    NumberOfEntries = Array.Length;

    Unlock ();

    return NumberOfEntries >= LDAP_MAX_TRANSLATION_TABLE_SIZE;
}

// LDAP_SOCKET ----------------------------------------------

LDAP_SOCKET::LDAP_SOCKET (
    IN    LDAP_CONNECTION    *    ArgLdapConnection,
    IN    LDAP_PUMP *            ArgRecvPump,
    IN    LDAP_PUMP *            ArgSendPump)
{
    assert (ArgLdapConnection);
    assert (ArgRecvPump);
    assert (ArgSendPump);

    LdapConnection = ArgLdapConnection;
    RecvPump = ArgRecvPump;
    SendPump = ArgSendPump;

    State = STATE_NONE;
    BytesToReceive = LDAP_BUFFER_RECEIVE_SIZE;
    Socket = INVALID_SOCKET;

    ZeroMemory (&RecvOverlapped, sizeof RecvOverlapped);
    RecvOverlapped.Socket = this;
    RecvBuffer = NULL;
    InitializeListHead (&RecvBufferQueue);

    ZeroMemory (&SendOverlapped, sizeof SendOverlapped);
    SendOverlapped.Socket = this;
    SendBuffer = NULL;
    InitializeListHead (&SendBufferQueue);

    ConnectEvent = NULL;
    ConnectWaitHandle = NULL;
    AttemptAnotherConnect = TRUE;

    IsNatRedirectActive = FALSE;
}

LDAP_SOCKET::~LDAP_SOCKET (void)
{
    DeleteBufferList (&RecvBufferQueue);
    DeleteBufferList (&SendBufferQueue);

    if (RecvBuffer) {

        delete RecvBuffer;

        RecvBuffer = NULL;
    }

    assert (IsListEmpty (&RecvBufferQueue));
    assert (IsListEmpty (&SendBufferQueue));
    assert (!SendBuffer);
    assert (!ConnectEvent);
    assert (!ConnectWaitHandle);
}

void LDAP_SOCKET::DeleteBufferList (LIST_ENTRY * ListHead)
{
    LIST_ENTRY *    ListEntry;
    LDAP_BUFFER *    Buffer;

    while (!IsListEmpty (ListHead)) {
        ListEntry = RemoveHeadList (ListHead);
        Buffer = CONTAINING_RECORD (ListEntry, LDAP_BUFFER, ListEntry);
        delete Buffer;
    }
}

BOOL LDAP_SOCKET::RecvRemoveBuffer (
    OUT    LDAP_BUFFER **    ReturnBuffer)
{
    LIST_ENTRY *    ListEntry;

    assert (ReturnBuffer);

    if (IsListEmpty (&RecvBufferQueue))
        return FALSE;
    else {
        ListEntry = RemoveHeadList (&RecvBufferQueue);
        *ReturnBuffer = CONTAINING_RECORD (ListEntry, LDAP_BUFFER, ListEntry);
        return TRUE;
    }
}

void LDAP_SOCKET::RecvBuildBuffer (
    IN    LPBYTE    Data,
    IN    DWORD    Length)
{
    LDAP_BUFFER *    Buffer;

    assert (Data);
    AssertLocked();

    Buffer = new LDAP_BUFFER;

    if (!Buffer) {
        Debug (_T("LDAP: RecvBuildBuffer, allocation failure #1.\n"));
        return;
    }

    if (Buffer -> Data.Grow (Length)) {
        memcpy (Buffer -> Data.Data, Data, Length);
        Buffer -> Data.Length = Length;

        InsertTailList (&RecvBufferQueue, &Buffer -> ListEntry);
    }
    else {
        Debug (_T("LDAP: RecvBuildBuffer, allocation failure #2.\n"));

        delete Buffer;
    }
}

HRESULT LDAP_SOCKET::AcceptSocket (
    SOCKET LocalClientSocket)
{
    if (State != STATE_NONE) {

        Debug (_T("LDAP: Not in a valid state for AcceptSocket (State != STATE_NONE).\n"));
        return E_UNEXPECTED;
    }

    State  = STATE_CONNECTED;
    Socket = LocalClientSocket;

    // notify parent about state change
    LdapConnection -> OnStateChange (this, State);
    
    if (!BindIoCompletionCallback ((HANDLE) Socket, LDAP_SOCKET::IoCompletionCallback, 0)) {

        DebugLastError (_T("LDAP: Failed to bind I/O completion callback.\n"));

        return GetLastErrorAsResult ();
    }
        
    return S_OK;
}

HRESULT LDAP_SOCKET::IssueConnect (
    SOCKADDR_IN * DestinationAddress)
{

    HRESULT Status;
    HRESULT Result;
    ULONG   Error;
    INT     RealSourceAddrSize = sizeof (SOCKADDR_IN);
    DWORD   BestInterfaceAddress; // host order
    int     ConnectError;
    BOOL    KeepaliveOption;

    assert (DestinationAddress);

    if (State != STATE_NONE) {

        Debug (_T("LDAP: Not in a valid state for IssueConnect (State != STATE_NONE).\n"));
        
        return E_UNEXPECTED;
    }

    assert (Socket == INVALID_SOCKET);
    assert (!ConnectEvent);
    assert (!ConnectWaitHandle);

    ActualDestinationAddress = *DestinationAddress;

    // If ILS runs on a remote (public) machine, we need to determine on which public
    // interface we will connect to the server. This is so to override global interface-restricted
    // NAT redirect by creating a trivial NAT redirect to the server's address from
    // the address of the public interface determined.
    //
    // If server happens to run on the local machine, then we use loopback address
    // as this is the address from where we will be "connecting" to the server.
    if (!::NhIsLocalAddress (DestinationAddress -> sin_addr.s_addr)) {

        Error = GetBestInterfaceAddress (
                    ntohl (DestinationAddress -> sin_addr.s_addr),
                    &BestInterfaceAddress);
            
        if (ERROR_SUCCESS != Error) {
            
            Result = HRESULT_FROM_WIN32 (Error); 
        
            DebugErrorF (Error, _T("LDAP: Failed to get best interface address for %08X.\n"), 
                    ntohl (DestinationAddress -> sin_addr.s_addr));

            return Result;
        }

    } else {

        BestInterfaceAddress = INADDR_LOOPBACK;
    }

    RealSourceAddress.sin_family      = AF_INET;
    RealSourceAddress.sin_addr.s_addr = htonl (BestInterfaceAddress);
    RealSourceAddress.sin_port        = htons (0); 

    Socket = WSASocket (AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);

    if (Socket == INVALID_SOCKET) {

        Result = GetLastErrorAsResult ();

        DebugLastError (_T("LDAP: Failed to create destination socket.\n"));

    } else {

        // At this point we actually start the connect procedures. Everything before that
        // was just a preparation, so the socket stayed in the STATE_NONE.
        State = STATE_ISSUING_CONNECT;
    
        if (SOCKET_ERROR == bind(Socket, (PSOCKADDR)&RealSourceAddress, RealSourceAddrSize)) {

            Result = GetLastErrorAsResult();

            DebugLastError (_T("LDAP: Failed to bind destination socket.\n"));

        } else {

            // Set keepalive on the socket
            KeepaliveOption = TRUE;
            if (SOCKET_ERROR == setsockopt (Socket, SOL_SOCKET, SO_KEEPALIVE,
                                           (PCHAR) &KeepaliveOption, sizeof (KeepaliveOption)))
            {
                Result = GetLastErrorAsResult ();
                DebugLastError (_T("LDAP: Failed to set keepalive on destination socket.\n"));

            }  else {

                if (getsockname (Socket, (struct sockaddr *)&RealSourceAddress, &RealSourceAddrSize)) {

                    Result = GetLastErrorAsResult ();

                    DebugLastError (_T("LDAP: Failed to get name of TCP socket.\n"));

                } else {

                    DebugF (_T("LDAP: 0x%x setting up trivial redirect (%08X:%04X -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"), 
                        LdapConnection,
                        SOCKADDR_IN_PRINTF(&RealSourceAddress), SOCKADDR_IN_PRINTF(DestinationAddress),
                        SOCKADDR_IN_PRINTF(&RealSourceAddress), SOCKADDR_IN_PRINTF(DestinationAddress));

                    if( NO_ERROR != NatCreateRedirectEx ( 
                            NatHandle, 
                            NatRedirectFlagLoopback,
                            IPPROTO_TCP, 
                            DestinationAddress -> sin_addr.s_addr,
                            DestinationAddress -> sin_port,
                            RealSourceAddress.sin_addr.s_addr, 
                            RealSourceAddress.sin_port,
                            DestinationAddress -> sin_addr.s_addr,
                            DestinationAddress -> sin_port,
                            RealSourceAddress.sin_addr.s_addr, 
                            RealSourceAddress.sin_port, 
                            NULL,
                            NULL, 
                            NULL, 
                            NULL)) {
                        
                        Result = GetLastErrorAsResult();

                        DebugLastErrorF (_T("LDAP: 0x%x failed to create trivial redirect.\n"),  
                            LdapConnection);
                
                    } else {

                        // we have successfully created a redirect
                        IsNatRedirectActive = TRUE;

                        do
                        {
                            ConnectEvent = CreateEvent (NULL, FALSE, FALSE, NULL); 

                            if (!ConnectEvent) { 

                                Result = GetLastErrorAsResult();

                                DebugLastErrorF (_T("LDAP: 0x%x failed to create connect-event.\n"),
                                    LdapConnection);

                                break;
                            }

                            Status = WSAEventSelect (Socket, ConnectEvent, FD_CONNECT);

                            if (Status) {
                                Result = GetLastErrorAsResult();

                                DebugLastErrorF (_T("LDAP: 0x%x failed to select events on the socket.\n"),
                                    LdapConnection);
                                break;
                            }

                            LdapConnection -> AddRef ();

                            if (!RegisterWaitForSingleObject (
                                    &ConnectWaitHandle, 
                                    ConnectEvent, 
                                    LDAP_SOCKET::OnConnectCompletion,
                                    this,
                                    INFINITE,
                                    WT_EXECUTEDEFAULT)) {

                                Result = GetLastErrorAsResult();

                                DebugLastErrorF (_T("LDAP: 0x%x failed to RegisterWaitForSingleObject.\n"),
                                    LdapConnection);
                                
                                LdapConnection -> Release ();

                                break;
                            } 
                            
                            if (connect (Socket, (SOCKADDR *)DestinationAddress, sizeof (SOCKADDR_IN))) {

                                ConnectError = WSAGetLastError ();

                                if(ConnectError == WSAEWOULDBLOCK) {

                                    State = STATE_CONNECT_PENDING;

                                    LdapConnection->OnStateChange (this, State);

                                    Result = S_OK;

                                } else {

                                    // a real error
                        
                                    Result = GetLastErrorAsResult();
                                        
                                    DebugLastErrorF (_T("LDAP: 0x%x failed to issue async connect.\n"),
                                        LdapConnection);
                                    
                                    FreeConnectResources ();

                                    // If remote server refused to connect, make an attempt to 
                                    // connect on a different port. Don't try to do so 
                                    // for any other error.

                                    if ((WSAECONNREFUSED == ConnectError || WSAECONNRESET == ConnectError)
                                         && AttemptAnotherConnect) {

                                        AttemptAnotherConnect = FALSE;

                                        DebugF (_T ("LDAP: 0x%x cancels trivial redirect (%08X:%04X -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"), 
                                                    LdapConnection,
                                                    SOCKADDR_IN_PRINTF (&RealSourceAddress),
                                                    SOCKADDR_IN_PRINTF (&ActualDestinationAddress),
                                                    SOCKADDR_IN_PRINTF (&RealSourceAddress),
                                                    SOCKADDR_IN_PRINTF (&ActualDestinationAddress));

                                        NatCancelRedirect ( 
                                            NatHandle, 
                                            IPPROTO_TCP, 
                                            ActualDestinationAddress.sin_addr.s_addr,
                                            ActualDestinationAddress.sin_port,
                                            RealSourceAddress.sin_addr.s_addr, 
                                            RealSourceAddress.sin_port,
                                            ActualDestinationAddress.sin_addr.s_addr,
                                            ActualDestinationAddress.sin_port,
                                            RealSourceAddress.sin_addr.s_addr, 
                                            RealSourceAddress.sin_port); 

                                        IsNatRedirectActive = FALSE;

                                        closesocket (Socket);
                                        Socket = INVALID_SOCKET;
                                        
                                        State = STATE_NONE;

                                        Result = AttemptAlternateConnect (); // calls IssueConnect internally
                                    }

                                    LdapConnection -> Release ();
                                }

                                break;

                            } else {
                                // connect completed synchronously
                                // this should never occur

                                DebugF (_T("LDAP: 0x%x completed synchronously -- this should never occur.\n"),
                                    LdapConnection);

                                FreeConnectResources ();
                               
                                LdapConnection -> Release ();

                                Result = E_UNEXPECTED;

                            }
                       } while(FALSE);
                   }
                }
            }
        }
    }
            
    return Result;
}

// static
void LDAP_SOCKET::IoCompletionCallback (
    DWORD            Status, 
    DWORD            BytesTransferred, 
    LPOVERLAPPED    Overlapped)
{
    LDAP_OVERLAPPED *    LdapOverlapped;
    LDAP_CONNECTION *    Connection;

    LdapOverlapped = CONTAINING_RECORD (Overlapped, LDAP_OVERLAPPED, Overlapped);

    assert (LdapOverlapped -> Socket);

    Connection = LdapOverlapped -> Socket -> LdapConnection;

    LdapOverlapped -> Socket -> OnIoComplete (Status, BytesTransferred, LdapOverlapped);

    Connection -> Release();
}

void LDAP_SOCKET::OnIoComplete (
    DWORD                Status, 
    DWORD                BytesTransferred, 
    LDAP_OVERLAPPED *    Overlapped)
{
    Lock();

    assert (Overlapped -> IsPending);

    Overlapped -> IsPending = FALSE;
    Overlapped -> BytesTransferred = BytesTransferred;

    if (Overlapped == &RecvOverlapped)
        OnRecvComplete (Status);
    else if (Overlapped == &SendOverlapped)
        OnSendComplete (Status);
    else {
        AssertNeverReached();
    }

    Unlock();
}

// static
void LDAP_SOCKET::OnConnectCompletion (
    PVOID        Context,
    BOOLEAN        TimerOrWaitFired)
{
    LDAP_SOCKET *    LdapSocket;

    assert (Context);

    LdapSocket = (LDAP_SOCKET *) Context;

    LdapSocket -> Lock ();
    LdapSocket -> OnConnectCompletionLocked ();
    LdapSocket -> Unlock ();

    LdapSocket -> LdapConnection -> Release ();
}

void LDAP_SOCKET::OnRecvComplete (DWORD Status)
{
    DWORD StartOffset;
    DWORD NextPacketOffset;
    DWORD NextReceiveSize = 0;
    DWORD Result;

    LIST_ENTRY *    ListEntry;
    LDAP_BUFFER *    Buffer;


    if (Status != ERROR_SUCCESS) {

        if (State != STATE_TERMINATED) {

            Terminate();
        }

        return;
    }

    if (RecvOverlapped.BytesTransferred == 0) {

#if    DBG
        if (this == &LdapConnection -> ClientSocket)
        {
            DebugF (_T("LDAP: 0x%x client has closed transport socket.\n"), LdapConnection);
        }
        else if (this == &LdapConnection -> ServerSocket)
        {
            DebugF (_T("LDAP: 0x%x server has closed transport socket.\n"), LdapConnection);
        }
        else
            AssertNeverReached();
#endif

        Terminate();

        return;
    }

    assert (RecvBuffer);

    assert (RecvBuffer -> Data.Length + RecvOverlapped.BytesTransferred
        <= RecvBuffer -> Data.MaxLength);

    RecvBuffer -> Data.Length += RecvOverlapped.BytesTransferred;

    if (State == STATE_TERMINATED) {

        DebugF (_T("LDAP: 0x%x is terminating, no further processing will occur.\n"), LdapConnection);

        return;
    }

    if (RecvPump -> IsActivelyPassingData ()) {

        StartOffset = 0;

        for (;;) {

            assert (StartOffset <= RecvBuffer -> Data.Length);

            Result = LdapDeterminePacketBoundary (
                            RecvBuffer,
                            StartOffset, 
                            &NextPacketOffset,
                            &NextReceiveSize);

            if (Result == ERROR_SUCCESS) {

                RecvBuildBuffer (&RecvBuffer -> Data.Data [StartOffset], NextPacketOffset - StartOffset);

                StartOffset = NextPacketOffset;

            } else {

                RecvBuffer -> Data.DeleteRangeAtPos (0, StartOffset);

                if (Result == ERROR_INVALID_DATA) {

                    RecvPump -> StartPassiveDataTransfer ();

                    DebugF (_T("LDAP: 0x%x starts non-interpreting data transfer.\n"), LdapConnection);

                    InsertTailList (&RecvBufferQueue, &RecvBuffer -> ListEntry);

                    RecvBuffer = NULL;

                } 

                BytesToReceive = NextReceiveSize;

                break;

            } 

        }

    } else {
        LONG    PreviousRecvSize;
        LONG    PredictedRecvSize;
        HRESULT QueryResult;
        DWORD   BytesPreviouslyRequested = BytesToReceive;
        
        QueryResult = RecvSizePredictor.RetrieveOldSample (0, &PreviousRecvSize);

        if (ERROR_SUCCESS != RecvSizePredictor.AddSample ((LONG) RecvOverlapped.BytesTransferred)) {

            delete RecvBuffer;
            RecvBuffer = NULL;

            DebugErrorF (Status, _T("LDAP: 0x%x could not add sample to SamplePredictor.\n"), LdapConnection);

            Terminate();

            return;
        }

        if (BytesPreviouslyRequested == RecvOverlapped.BytesTransferred) {
            // Exact receive

            if (ERROR_SUCCESS != QueryResult) {

                BytesToReceive = (DWORD) (RecvOverlapped.BytesTransferred * 1.5);

            } else {

                PredictedRecvSize = RecvSizePredictor.PredictNextSample ();

                if (PredictedRecvSize < (LONG) RecvOverlapped.BytesTransferred) {

                    if ((DWORD) PreviousRecvSize < RecvOverlapped.BytesTransferred) {

                        BytesToReceive =  RecvOverlapped.BytesTransferred * 1000 / (DWORD) PreviousRecvSize * 
                                          RecvOverlapped.BytesTransferred        / 1000;

                    } else {

                        BytesToReceive = (DWORD) PreviousRecvSize;
                    }

                } else {
                    
                    BytesToReceive = (DWORD) PredictedRecvSize;
                }

            }

        } else {
            // Inexact receive
        
            PredictedRecvSize = RecvSizePredictor.PredictNextSample ();

            BytesToReceive = (PredictedRecvSize < LDAP_BUFFER_RECEIVE_SIZE) ? 
                              LDAP_BUFFER_RECEIVE_SIZE :
                             (DWORD) PredictedRecvSize;

        }

        if (BytesToReceive > LDAP_BUFFER_MAX_RECV_SIZE)  {

            DebugF (_T("LDAP: 0x%x intended to receive %d bytes. Lowering the number to %d bytes.\n"),
                    LdapConnection, BytesToReceive, LDAP_BUFFER_MAX_RECV_SIZE);

            BytesToReceive = LDAP_BUFFER_MAX_RECV_SIZE;
        }

        InsertTailList (&RecvBufferQueue, &RecvBuffer -> ListEntry);
            
        RecvBuffer = NULL;
    }


    while (!IsListEmpty (&RecvBufferQueue)) {

        ListEntry = RemoveHeadList (&RecvBufferQueue);

        Buffer = CONTAINING_RECORD (ListEntry, LDAP_BUFFER, ListEntry);

        RecvPump -> OnRecvBuffer (Buffer);
    }

    RecvIssue ();
}

void LDAP_SOCKET::OnSendComplete (DWORD Status)
{
    assert (SendBuffer);

    delete SendBuffer;
    SendBuffer = NULL;

    // before notifying the owning context, transmit any buffers
    // that are queued for send.

    if (SendNextBuffer())
        return;

    SendPump -> OnSendDrain();
}

void LDAP_SOCKET::OnConnectCompletionLocked (void) {

    WSANETWORKEVENTS NetworkEvents;
    HRESULT Result;
    int     ConnectError;

    AssertLocked();

    if (State != STATE_CONNECT_PENDING) {
        DebugF (_T("LDAP: 0x%x connect request completed, but socket is no longer interested.\n"), LdapConnection);
        return;
    }

    if (WSAEnumNetworkEvents (Socket, ConnectEvent, &NetworkEvents)) {

        DebugLastErrorF (_T("LDAP: 0x%x failed to retrieve network events.\n"), LdapConnection);

        Terminate();

        return;
    }

    if (!(NetworkEvents.lNetworkEvents & FD_CONNECT)) {

        DebugF (_T("LDAP: 0x%x connect event fired, but event mask does not indicate that connect completed -- internal error.\n"),
                LdapConnection);
        
        Terminate();

        return;
    }

    ConnectError = S_OK;

    if (NetworkEvents.iErrorCode [FD_CONNECT_BIT]) {
     
        ConnectError = NetworkEvents.iErrorCode [FD_CONNECT_BIT];
        DebugErrorF (ConnectError, _T("LDAP: 0x%x failed async connect request. "), LdapConnection);

        // If remote host refused to connect, we may attempt
        // a connection to an alternate port later, so we don't terminate 
        // the socket. All other error codes result in termination.
        if (WSAECONNRESET != ConnectError && WSAECONNREFUSED != ConnectError) {

            Terminate ();
            
            return;

        }
    }

    FreeConnectResources ();

    // If first attempt to connect fail, try to connect using an alternate port
    if ((WSAECONNREFUSED == ConnectError || WSAECONNRESET == ConnectError)
         && AttemptAnotherConnect) {

        AttemptAnotherConnect = FALSE;

        DebugF (_T ("LDAP: 0x%x cancels trivial redirect (%08X:%04X -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"), 
                    LdapConnection,
                    SOCKADDR_IN_PRINTF (&RealSourceAddress),
                    SOCKADDR_IN_PRINTF (&ActualDestinationAddress),
                    SOCKADDR_IN_PRINTF (&RealSourceAddress),
                    SOCKADDR_IN_PRINTF (&ActualDestinationAddress));

        NatCancelRedirect ( 
            NatHandle, 
            IPPROTO_TCP, 
            ActualDestinationAddress.sin_addr.s_addr,
            ActualDestinationAddress.sin_port,
            RealSourceAddress.sin_addr.s_addr, 
            RealSourceAddress.sin_port,
            ActualDestinationAddress.sin_addr.s_addr,
            ActualDestinationAddress.sin_port,
            RealSourceAddress.sin_addr.s_addr, 
            RealSourceAddress.sin_port); 

        IsNatRedirectActive = FALSE;

        closesocket (Socket);
        Socket = INVALID_SOCKET;
        
        State = STATE_NONE;

        Result = AttemptAlternateConnect ();

        if (S_OK != Result) {

            Terminate ();
        }

        return;
    }

    DebugF (_T("LDAP: 0x%x established connection to server %08X:%04X.\n"), LdapConnection, SOCKADDR_IN_PRINTF (&ActualDestinationAddress));

    if (!BindIoCompletionCallback ((HANDLE)Socket, LDAP_SOCKET::IoCompletionCallback, 0)) {
        DebugLastErrorF (_T("LDAP: 0x%x failed to bind I/O completion callback.\n"), LdapConnection);

        Terminate();

        return;
    }
    
    // Asynchronous connect succeeded
    State = STATE_CONNECTED;

    LdapConnection -> OnStateChange (this, State);
}

void LDAP_SOCKET::FreeConnectResources (void) {

    // refrain from receiving notifications of further transport events
    WSAEventSelect (Socket, ConnectEvent, 0);

    assert (ConnectWaitHandle);
    UnregisterWaitEx (ConnectWaitHandle, NULL);
    ConnectWaitHandle = NULL;

    assert (ConnectEvent);
    CloseHandle(ConnectEvent);
    ConnectEvent = NULL;
}


// assumes that connect resources for previous
// connect attempt were freed
HRESULT LDAP_SOCKET::AttemptAlternateConnect (void) {

    HRESULT Result;

    // switch connection port to the other alternative

    ActualDestinationAddress.sin_port = 
        (ActualDestinationAddress.sin_port == htons (LDAP_STANDARD_PORT)) ?
        htons (LDAP_ALTERNATE_PORT) :
        htons (LDAP_STANDARD_PORT);

    DebugF (_T("LDAP: 0x%x will try to connect on an alternate address %08X:%04X.\n"),
                LdapConnection,
                SOCKADDR_IN_PRINTF (&ActualDestinationAddress));

    // attempting to connect on an alternate port
    Result = IssueConnect (&ActualDestinationAddress);
    
    if (S_OK != Result) {

        DebugF (_T("LDAP: 0x%x failed to issue connect on an alternate address %08X:%04X.\n"),
                    LdapConnection,
                    SOCKADDR_IN_PRINTF (&ActualDestinationAddress));
    }

    return Result;
}

void LDAP_SOCKET::Terminate (void)
{
    switch (State) {

    case    STATE_TERMINATED:
        // nothing to do
        return;

    case    STATE_NONE:
        // a different kind of nothing to do
        break;

    default:
        // in all other states, the socket handle must be set
        assert (Socket != INVALID_SOCKET);

        State = STATE_TERMINATED;

        if (INVALID_SOCKET != Socket) {

            closesocket (Socket);
            Socket = INVALID_SOCKET;

        }

        if (IsNatRedirectActive) {
                DebugF (_T ("LDAP: 0x%x cancels trivial redirect (%08X:%04X -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"), 
                            LdapConnection,
                            SOCKADDR_IN_PRINTF (&RealSourceAddress),
                            SOCKADDR_IN_PRINTF (&ActualDestinationAddress),
                            SOCKADDR_IN_PRINTF (&RealSourceAddress),
                            SOCKADDR_IN_PRINTF (&ActualDestinationAddress));
             NatCancelRedirect ( 
                NatHandle, 
                IPPROTO_TCP, 
                ActualDestinationAddress.sin_addr.s_addr,
                ActualDestinationAddress.sin_port,
                RealSourceAddress.sin_addr.s_addr, 
                RealSourceAddress.sin_port,
                ActualDestinationAddress.sin_addr.s_addr,
                ActualDestinationAddress.sin_port,
                RealSourceAddress.sin_addr.s_addr, 
                RealSourceAddress.sin_port); 

            IsNatRedirectActive = FALSE;
        }

        if (ConnectWaitHandle) {

            if (UnregisterWaitEx (ConnectWaitHandle, NULL)) {

                // Take care of the case when the connection was terminated AFTER
                // async connect has been issued, but BEFORE the connect was completed. 
                // 
                // This should not normally happen.
                LdapConnection -> Release ();
                
            }

            ConnectWaitHandle = NULL;
        }

        if (ConnectEvent) {
            CloseHandle (ConnectEvent);
            ConnectEvent = NULL;
        }

        SendPump -> Terminate ();
        RecvPump -> Terminate ();

        break;
    }
    

    LdapConnection -> OnStateChange (this, State);
}

HRESULT LDAP_SOCKET::RecvIssue (void)
{
    WSABUF    BufferArray    [1];
    DWORD    Status;
    DWORD    BytesRequested;

    if (RecvOverlapped.IsPending) {
        DebugF (_T("LDAP: 0x%x receive is already pending.\n"), LdapConnection);
        return S_OK;
    }

    if (!RecvPump -> CanIssueRecv()) {
        // we gate the rate at which we receive data from the network on the
        // rate at which the other network connection consumes it.
        // this is how we preserve flow control.

        return S_OK;
    }

    if (!RecvBuffer) {

        RecvBuffer = new LDAP_BUFFER;

        if (!RecvBuffer) {

            DebugF (_T("LDAP: 0x%x RecvIssue allocation failure.\n"), LdapConnection);

            Terminate();

            return E_OUTOFMEMORY;
        }
    }

    BytesRequested = RecvBuffer -> Data.Length + BytesToReceive;

    if (!RecvBuffer -> Data.Grow (BytesRequested)) {

        DebugF (_T("LDAP: 0x%x failed to expand receive buffer to %d bytes.\n"), 
                LdapConnection, BytesRequested);

        Terminate();

        return E_OUTOFMEMORY;
    }

    BufferArray [0].len = BytesToReceive;
    BufferArray [0].buf = reinterpret_cast <char *>(RecvBuffer -> Data.Data) + RecvBuffer -> Data.Length;


    ZeroMemory (&RecvOverlapped.Overlapped, sizeof (OVERLAPPED));

    RecvFlags = 0;

    LdapConnection -> AddRef ();

    if (WSARecv (Socket, BufferArray, 1,
        &RecvOverlapped.BytesTransferred, &RecvFlags,
        &RecvOverlapped.Overlapped, NULL)) {

        Status = WSAGetLastError();

        if (Status != WSA_IO_PENDING) {
            // a true error, probably a transport failure
            
            LdapConnection -> Release ();

            DebugErrorF (Status, _T("LDAP: 0x%x failed to issue receive.\n"), LdapConnection);
            return HRESULT_FROM_WIN32 (Status);
        }
    }

    RecvOverlapped.IsPending = TRUE;

    return S_OK;
}

void LDAP_SOCKET::SendQueueBuffer (
    IN    LDAP_BUFFER *    Buffer)
{
    AssertLocked();

    assert (!IsInList (&SendBufferQueue, &Buffer -> ListEntry));
    InsertTailList (&SendBufferQueue, &Buffer -> ListEntry);

    SendNextBuffer();
}

BOOL LDAP_SOCKET::SendNextBuffer (void)
{
    WSABUF            BufferArray [1];
    LIST_ENTRY *    ListEntry;
    DWORD            Status;

    if (SendOverlapped.IsPending) {
        assert (SendBuffer);

//        Debug (_T("LDAP_SOCKET::SendNextMessage: already sending a message, must wait.\n"));
        return FALSE;
    }

    assert (!SendBuffer);

    // remove the next buffer to be sent from the queue

    if (IsListEmpty (&SendBufferQueue))
        return FALSE;

    ListEntry = RemoveHeadList (&SendBufferQueue);
    SendBuffer = CONTAINING_RECORD (ListEntry, LDAP_BUFFER, ListEntry);

    BufferArray [0].buf = reinterpret_cast<char *> (SendBuffer -> Data.Data);
    BufferArray [0].len = SendBuffer -> Data.Length;

    ZeroMemory (&SendOverlapped.Overlapped, sizeof (OVERLAPPED));

    LdapConnection -> AddRef ();

    if (WSASend (Socket, BufferArray, 1,
        &SendOverlapped.BytesTransferred, 0,
        &SendOverlapped.Overlapped, NULL)) {

        Status = WSAGetLastError();

        if (Status != WSA_IO_PENDING) {

            LdapConnection -> Release ();

            DebugError (Status, _T("LDAP: Failed to issue send.\n"));

            delete SendBuffer;
            SendBuffer = NULL;

            Terminate();

            // we return TRUE, because we did dequeue a buffer,
            // even if that buffer could not be transmitted.
            return TRUE;
        }
    }

    SendOverlapped.IsPending = TRUE;

    return TRUE;
}

BOOL LDAP_SOCKET::GetLocalAddress (
    OUT    SOCKADDR_IN *    ReturnAddress)
{
    INT            AddressLength;

    AssertLocked();

    if (State == STATE_CONNECTED) {
        AddressLength = sizeof (SOCKADDR_IN);

        if (getsockname (Socket, (SOCKADDR *) ReturnAddress, &AddressLength)) {
            DebugLastErrorF (_T("LDAP: 0x%x failed to retrieve socket address.\n"), LdapConnection);
            ZeroMemory (&ReturnAddress, sizeof (SOCKADDR_IN));

            return FALSE;
        }

        return TRUE;
    }
    else {
        return FALSE;
    }
}

BOOL LDAP_SOCKET::GetRemoteAddress (
    OUT    SOCKADDR_IN *    ReturnAddress)
{
    INT            AddressLength;

    AssertLocked();

    if (State == STATE_CONNECTED) {
        AddressLength = sizeof (SOCKADDR_IN);

        if (getpeername (Socket, (SOCKADDR *) ReturnAddress, &AddressLength)) {
            DebugLastErrorF (_T("LDAP: 0x%x failed to retrieve peer address.\n"), LdapConnection);
            ZeroMemory (&ReturnAddress, sizeof (SOCKADDR_IN));

            return FALSE;
        }

        return TRUE;
    }
    else {
        return FALSE;
    }
}

// LDAP_CONNECTION ---------------------------------------------------

LDAP_CONNECTION::LDAP_CONNECTION (NAT_KEY_SESSION_MAPPING_EX_INFORMATION * RedirectInformation)
: LIFETIME_CONTROLLER (&LdapSyncCounter) ,
    ClientSocket (this, &PumpClientToServer, &PumpServerToClient),
    ServerSocket   (this, &PumpServerToClient, &PumpClientToServer),
    PumpClientToServer    (this, &ClientSocket, &ServerSocket),
    PumpServerToClient    (this, &ServerSocket, &ClientSocket)
{
    SourceInterfaceAddress      = 0;
    DestinationInterfaceAddress = 0;

    State = STATE_NONE;

    DestinationAddress.sin_family      = AF_INET;
    DestinationAddress.sin_addr.s_addr = RedirectInformation -> DestinationAddress;
    DestinationAddress.sin_port        = RedirectInformation -> DestinationPort;

    SourceAddress.sin_family           = AF_INET;
    SourceAddress.sin_addr.s_addr      = RedirectInformation -> SourceAddress;
    SourceAddress.sin_port             = RedirectInformation -> SourcePort;

    DebugF (_T("LDAP: 0x%x created.\n"), this);
}

HRESULT LDAP_CONNECTION::Initialize (
    IN NAT_KEY_SESSION_MAPPING_EX_INFORMATION * RedirectInformation
    )
{
    
    HRESULT Result;

    Lock ();

    Result = InitializeLocked (RedirectInformation);

    Unlock ();

    return Result;
}

HRESULT LDAP_CONNECTION::InitializeLocked (
    IN NAT_KEY_SESSION_MAPPING_EX_INFORMATION * RedirectInformation
    )
{
    ULONG Error;

    DebugF (_T ("LDAP: 0x%x connection accepted on adapter %d.\n"), this, RedirectInformation -> AdapterIndex);

    SourceInterfaceAddress = H323MapAdapterToAddress (RedirectInformation -> AdapterIndex);

    if (INADDR_NONE == SourceInterfaceAddress) {

        DebugF (_T ("LDAP: 0x%x failed to get source interface address (via H323MapAdapterToAddress).\n"), this);

        return E_FAIL;

    }

    Error = GetBestInterfaceAddress (ntohl (DestinationAddress.sin_addr.s_addr), &DestinationInterfaceAddress);

    if (ERROR_SUCCESS != Error) {

        DebugErrorF (Error, _T ("LDAP: 0x%x failed to get destination interface address.\n"), this);

        return HRESULT_FROM_WIN32 (Error);

    }

    DebugF (_T("LDAP: 0x%x arrived on interface %08X.\n"), this, SourceInterfaceAddress);

    return S_OK;
}

LDAP_CONNECTION::~LDAP_CONNECTION (void)
{    
    DebugF (_T("LDAP: 0x%x destroyed.\n"), this);
}

void LDAP_CONNECTION::StartIo (void)
{
    PumpClientToServer.Start ();
    PumpServerToClient.Start ();
}

HRESULT LDAP_CONNECTION::AcceptSocket (
    IN    SOCKET           Socket,
    IN    SOCKADDR_IN *    LocalAddress,
    IN    SOCKADDR_IN *    RemoteAddress,
    IN    SOCKADDR_IN *    ArgActualDestinationAddress)
{
    HRESULT        Result;

    Lock();

    if (State == STATE_NONE) {

        Result = ClientSocket.AcceptSocket (Socket);

        if (Result == S_OK) {

            Result = ServerSocket.IssueConnect (ArgActualDestinationAddress);

            if (Result != S_OK) {

                DebugErrorF (Result, _T("LDAP: 0x%x failed to issue async connect to %08X:%04X.\n"),
                    this,
                    SOCKADDR_IN_PRINTF (ArgActualDestinationAddress));

                Terminate ();
            }
        }
        else {

            DebugErrorF (Result, _T("LDAP: 0x%x could not successfully complete accept.\n"), this);

            Terminate ();
        }            
    }
    else {

        DebugF (_T("LDAP: 0x%x is not in a valid state for accept (state != STATE_NONE).\n"), this);

        Result = E_UNEXPECTED;
    }

    Unlock();
        
    return Result;
}
    
HRESULT LDAP_CONNECTION::CreateOperation (
    IN    LDAP_OPERATION_TYPE        Type,
    IN    LDAP_MESSAGE_ID            MessageID,
    IN    ANSI_STRING *            DirectoryPath,
    IN    ANSI_STRING *            Alias,
    IN    IN_ADDR                    ClientAddress,
    IN    SOCKADDR_IN *            ServerAddress,
    IN    DWORD                    EntryTimeToLive  // in seconds
    )
{
    LDAP_OPERATION *    Operation;
    DWORD                Index;
    HRESULT                Result;

    if (FindOperationIndexByMessageID (MessageID, &Index)) {
        DebugF (_T("LDAP: 0x%x - an operation with message ID (%u) is already pending.\n"),
            this, 
            MessageID);
        return E_FAIL;
    }

    Operation = OperationArray.AllocAtPos (Index);
    if (!Operation) {
        DebugF (_T("LDAP: 0x%x - CreateOperation allocation failure #1.\n"), this);
        return E_OUTOFMEMORY;
    }

    Operation -> Type = Type;
    Operation -> MessageID = MessageID;
    Operation -> ClientAddress = ClientAddress;
    Operation -> ServerAddress = *ServerAddress;
    Operation -> EntryTimeToLive = EntryTimeToLive;

    CopyAnsiString (DirectoryPath, &Operation -> DirectoryPath);
    CopyAnsiString (Alias, &Operation -> Alias);

    if ((Operation -> DirectoryPath.Buffer
        && Operation -> Alias.Buffer)) {
        // all is well

        Result = S_OK;
    }
    else {
        DebugF (_T("LDAP: 0x%x - CreateOperation allocation failure #2.\n"), this);

        FreeAnsiString (&Operation -> DirectoryPath);
        FreeAnsiString (&Operation -> Alias);

        Result = E_OUTOFMEMORY;
    }

    return Result;
}


// Processing of LDAP messages ---------------------------------------

BOOL LDAP_CONNECTION::ProcessAddRequest (
    IN    LDAPMessage *    Message)
{
    AddRequest *        Request;
    ANSI_STRING            DirectoryPath;
    LDAP_PATH_ELEMENTS    PathElements;
    ANSI_STRING            AttributeTag;
    IN_ADDR                OldClientAddress;        // the address the client submitted in AddRequest
    IN_ADDR                NewClientAddress;        // the address we are replacing it with
    LDAP_OPERATION *    Operation;
    DWORD                OperationInsertionIndex;
    ASN1octetstring_t    IPAddressOldValue;
    SOCKADDR_IN            LocalToServerAddress;
    SOCKADDR_IN            LocalToClientAddress;
    SOCKADDR_IN            ServerAddress;
    INT                    AddressLength;
    BOOL                NeedObjectClass;
    ANSI_STRING            ClientAlias;

    AddRequest_attrs *                Iter;
    AddRequest_attrs_Seq *            Attribute;
    AddRequest_attrs_Seq_values *    ValueSequence;
    AttributeValue *                Attribute_Alias;
    AttributeValue *                Attribute_IPAddress;
    AttributeValue *                Attribute_ObjectClass;
    AttributeValue *                Attribute_Comment;
    AttributeValue                    Attribute_Comment_Old;
    ANSI_STRING            String;
                
    CHAR    IPAddressText    [0x20];
    USHORT    IPAddressTextLength;

    Request = &Message -> protocolOp.u.addRequest;

    // check to see if an existing operation with the same message id is pending.
    // if so, the client is in violation of the LDAP spec.
    // we'll just ignore the packet in this case.
    // at the same time, compute the insertion position for the new operation (for use later).

    if (FindOperationIndexByMessageID (Message -> messageID, &OperationInsertionIndex)) {
        DebugF (_T("LDAP: 0x%x - client has issued two requests with the same message ID (%u), LDAP protocol violation, packet will not be processed.\n"),
            this,
            Message -> messageID);

        return FALSE;
    }

    // NetMeeting supplies the objectClass in the directory path.
    // TAPI supplies the objectClass in the attribute set.
    // Don't you just love standards?

    InitializeAnsiString (&DirectoryPath, &Request -> entry);
    ParseDirectoryPath (&DirectoryPath, &PathElements);

    // make sure that the alias is present
    if (!PathElements.CN.Buffer) { 
        DebugF (_T("LDAP: 0x%x client %08X issued unqualified AddRequest (no alias present).\n"),
                    this,
                    ntohl (SourceAddress.sin_addr.s_addr)); 
        return FALSE;
    }

    ClientAlias = PathElements.CN;

    if (PathElements.ObjectClass.Buffer) {
        if (RtlEqualStringConst (&PathElements.ObjectClass, &LdapText_RTPerson, TRUE)) {
            NeedObjectClass = FALSE;
        }
        else {
            DebugF (_T("LDAP: 0x%x client %08X issued unqualified AddRequest (no object class (1)).\n"),
                        this,
                        ntohl (SourceAddress.sin_addr.s_addr)); 

            return FALSE;
        }
    }
    else {

        NeedObjectClass = TRUE;
    }

    // first, determine if the attributes of this object
    // match the set of objects we wish to modify.

    // scan through the set of attributes
    // find interesting data

    Attribute_IPAddress   = NULL;
    Attribute_ObjectClass = NULL;
    Attribute_Comment     = NULL;

    for (Iter = Request -> attrs; Iter; Iter = Iter -> next) {
        Attribute = &Iter -> value;

        InitializeAnsiString (&AttributeTag, &Attribute -> type);

        if (Attribute -> values) {
            // we are only concerned with single-value attributes
            // if it's one of the attributes that we want,
            // then store in local variable

            if (RtlEqualStringConst (&AttributeTag, &LdapText_Attribute_sipaddress, TRUE)
                || RtlEqualStringConst (&AttributeTag, &LdapText_Attribute_ipAddress, TRUE))
                Attribute_IPAddress = &Attribute -> values -> value;
            else if (RtlEqualStringConst (&AttributeTag, &LdapText_ObjectClass, TRUE))
                Attribute_ObjectClass = &Attribute -> values -> value;
            else if (RtlEqualStringConst (&AttributeTag, &LdapText_Attribute_comment, TRUE))
                Attribute_Comment = &Attribute -> values -> value;
            // else, we aren't interested in the attribute
        }
        else {
            // else, the attribute has no values
        }
    }

    // make sure that we found an objectClass value.
    // make sure that the objectClass = RTPerson

    if (NeedObjectClass) {

        if (!Attribute_ObjectClass) {
            DebugF (_T("LDAP: 0x%x client %08X issued unqualified AddRequest (no object class (2)).\n"),
                    this,
                    ntohl (SourceAddress.sin_addr.s_addr)); 

            return FALSE;
        }

        InitializeAnsiString (&String, Attribute_ObjectClass);
        if (!RtlEqualStringConst (&String, &LdapText_RTPerson, TRUE)) {
            DebugF (_T("LDAP: 0x%x client %08X issued unqualified AddRequest (not for RTPerson).\n"),
                    this,
                    ntohl (SourceAddress.sin_addr.s_addr)); 

            return FALSE;
        }
    }

    // if a comment field is present, and the comment is "Generated by TAPI3"
    // modify it so that it says "Generated by TAPI3, modified by ICS"

    if (Attribute_Comment) {
        Attribute_Comment_Old = *Attribute_Comment;

        InitializeAnsiString (&String, Attribute_Comment);
        if (RtlEqualStringConst (&String, &LdapText_GeneratedByTAPI, TRUE)) {
            Attribute_Comment -> value = (PUCHAR) LdapText_ModifiedByICS.Buffer;
            Attribute_Comment -> length = LdapText_ModifiedByICS.Length * sizeof (CHAR);
        }
    }

    // make sure ip address attribute is present
    // parse the address, build replacement address

    if (!Attribute_IPAddress) {
        DebugF (_T("LDAP: 0x%x client %08X issued unqualified AddRequest (IP address not present).\n"),
                this,
                ntohl (SourceAddress.sin_addr.s_addr)); 
        return FALSE;
    }

    if (LdapTranslationTable.ReachedMaximumSize ()) {
        LDAPMessage AddRequestFailed;

        DebugF(_T("LDAP: Size of LDAP Address Translation Table exceeded limit. Sending back AddResponse with an error code.\n"));

        AddRequestFailed.messageID = Message -> messageID;
        AddRequestFailed.protocolOp.choice = addResponse_choice;

        AddRequestFailed.protocolOp.u.addResponse.resultCode = sizeLimitExceeded;
        AddRequestFailed.protocolOp.u.addResponse.matchedDN.length = 0;
        AddRequestFailed.protocolOp.u.addResponse.matchedDN.value = NULL;
        AddRequestFailed.protocolOp.u.addResponse.errorMessage.length = LdapText_TableSizeExceededMessage.Length * sizeof (CHAR);
        AddRequestFailed.protocolOp.u.addResponse.errorMessage.value = (PUCHAR) LdapText_TableSizeExceededMessage.Buffer;

        PumpServerToClient.EncodeSendMessage (&AddRequestFailed);

    } else {

        if (!ServerSocket.GetRemoteAddress (&ServerAddress)) {
            return FALSE;
        }

        IPAddressTextLength = min (0x1F, (USHORT) Attribute_IPAddress -> length);
        IPAddressText [IPAddressTextLength] = 0;
        memcpy (IPAddressText, Attribute_IPAddress -> value, IPAddressTextLength * sizeof (CHAR));

        if (RtlCharToInteger (IPAddressText, 10, &OldClientAddress.s_addr) != STATUS_SUCCESS) {
            DebugF (_T("LDAP: 0x%x - AddRequest: bogus IP address value (%.*S).\n"),
                this,
                Attribute_IPAddress -> length,
                Attribute_IPAddress -> value);

            return FALSE;
        }

        // If ILS is running locally, we will not modify AddRequest sent by any private client.
        // Instead, we will later modify SearchResponse PDU if it turned out that
        // the name of the client being searched for is stored in LDAP Address Translation Table, and
        // the matching SearchRequest PDU came from a machine external to the client's local subnet.
        // The address we will put into the modified SearchResponse PDU will be that of the
        // interface on which SearchRequest was received (public interface, or another local interface)
        // If SearchRequest came from a private client located on the same subnet as the client we
        // are registering here, we won't modify it as those two clients can communicate directly 
        // and don't require any proxying by the NAT machine.
        
        if (!::NhIsLocalAddress (ServerAddress.sin_addr.s_addr)) {

            // get the address that we want to substitute (our external interface address)

            if (!ServerSocket.GetLocalAddress (&LocalToServerAddress)) {

                DebugF (_T("LDAP: 0x%x failed to get local address to server -- internal error.\n"), this);
                return FALSE;

            }

            // Convoluted code alert!
            // NetMeeting stores its IP address as an attribute on an LDAP object on an ILS server.
            // Makes sense. The attribute is encoded as a textual string, so they had to convert
            // the IP address to text.  Any sane person would have chosen the standard dotted-quad
            // format, but they chose to interpret the IP address as a 32-bit unsigned integer,
            // which is fair enough, and then to convert that integer to a single decimal text string.

            // That's all great, that's just fine.  But NetMeeting stores the attribute byte-swapped
            // -- they used ntohl one too many times.  Grrrrrrrr....  The value should have been stored
            // without swapping the bytes, since the interpretation was "unsigned integer" and not "octet sequence".

            OldClientAddress.s_addr = htonl (ByteSwap (OldClientAddress.s_addr));

            NewClientAddress = LocalToServerAddress.sin_addr;
                                            
            // believe me, this IS CORRECT.
            // see the long note above for more info. -- arlied

            if (RtlIntegerToChar (ByteSwap (ntohl (NewClientAddress.s_addr)),
                10, 0x1F, IPAddressText) != STATUS_SUCCESS) {
                DebugF (_T("LDAP: 0x%x failed to convert IP address to text -- internal error.\n"), this);

                return FALSE;
            }

            DebugF (_T("LDAP: 0x%x will register %08X on the ILS.\n"), this, ntohl (NewClientAddress.s_addr));

        } else {

            DebugF (_T("LDAP: 0x%x will register %08X on the ILS.\n"), this, ntohl (OldClientAddress.s_addr));

        }

        // allocate and build an LDAP_OPERATION structure.

        DebugF (_T("LDAP: 0x%x inserts valid AddRequest into operation table.\n"), this);

        CreateOperation (
            LDAP_OPERATION_ADD,
            Message -> messageID,
            &DirectoryPath,
            &ClientAlias,
            OldClientAddress,
            &ServerAddress,
            LDAP_TRANSLATION_TABLE_ENTRY_INITIAL_TIME_TO_LIVE);

        // the entry is now in the operation array
        // later, when the server sends the AddResponse,
        // we'll match the response with the request,
        // and modify the LDAP_TRANSLATION_TABLE

        // now, in-place, we modify the PDU structure,
        // reencode it, send it, undo the modification
        // (so ASN1Free_AddRequest doesn't act up)

        assert (Attribute_IPAddress);
        IPAddressOldValue = *Attribute_IPAddress;

        Attribute_IPAddress -> value = (PUCHAR) IPAddressText;
        Attribute_IPAddress -> length = strlen (IPAddressText);

        PumpClientToServer.EncodeSendMessage (Message);

        // switch back so we don't a/v when decoder frees pdu
        *Attribute_IPAddress = IPAddressOldValue;
        if (Attribute_Comment)
            *Attribute_Comment = Attribute_Comment_Old;
    }

    return TRUE;
}

BOOL LDAP_CONNECTION::ProcessModifyRequest (
    IN    LDAP_MESSAGE_ID    MessageID,
    IN    ModifyRequest *    Request)
{
    ModifyRequest_modifications *        ModificationIterator;
    ModifyRequest_modifications_Seq *    Modification;
    PModifyRequest_modifications_Seq_modification_values ModificationValue;

    LPCTSTR                  Op;
    ANSI_STRING              ModificationType;
    ANSI_STRING              TimeToLive;
    ANSI_STRING              DirectoryPath;
    ANSI_STRING              ClientAlias;

    DWORD                    OperationInsertionIndex;
    LDAP_PATH_ELEMENTS       PathElements;
    BOOL                     IsValidRefreshRequest = FALSE;
    SOCKADDR_IN              ServerAddress;

    DWORD                    EntryTimeToLive = 0;
    CHAR                     EntryTimeToLiveText [11];
    USHORT                   EntryTimeToLiveLength;

    // check to see if an existing operation with the same message id is pending.
    // if so, the client is in violation of the LDAP spec.
    // we'll just ignore the packet in this case.
    // at the same time, compute the insertion position for the new operation (for use later).

    if (FindOperationIndexByMessageID (MessageID, &OperationInsertionIndex)) {
        DebugF (_T("LDAP: 0x%x - ModifyRequest: client has issued two requests with the same message ID (%u), LDAP protocol violation, packet will not be processed.\n"),
            this,
            MessageID);

        return FALSE;
    }

    // Cover the case when ModifyRequest does not supply baseObject 
    if (Request -> object.value == NULL || Request -> object.length == 0) {

        DebugF (_T("LDAP: 0x%x client %08X issued unqualified ModifyRequest (no base object).\n"),
                    this,
                    ntohl (SourceAddress.sin_addr.s_addr)); 

        return FALSE;
    }

    InitializeAnsiString (&DirectoryPath, &Request -> object);
    ParseDirectoryPath (&DirectoryPath, &PathElements);

    ClientAlias = PathElements.CN;

    for (ModificationIterator = Request -> modifications; ModificationIterator; ModificationIterator = ModificationIterator -> next) {

        Modification = &ModificationIterator -> value;
        
        InitializeAnsiString (&ModificationType, &Modification -> modification.type);

        if (RtlEqualStringConst (&ModificationType, &LdapText_Modify_EntryTTL, TRUE) && Modification -> operation == replace) {
            IsValidRefreshRequest = TRUE;

            assert (Modification -> modification.values);

            ModificationValue = Modification -> modification.values;

            InitializeAnsiString (&TimeToLive, &ModificationValue -> value);

            EntryTimeToLiveLength = min (10, (USHORT) ModificationValue -> value.length);
            EntryTimeToLiveText [EntryTimeToLiveLength] = 0;
            memcpy (EntryTimeToLiveText, ModificationValue -> value.value, EntryTimeToLiveLength * sizeof (CHAR));

            if (RtlCharToInteger (&EntryTimeToLiveText [0], 10, &EntryTimeToLive) != STATUS_SUCCESS) {

                DebugF (_T("LDAP: 0x%x - ModifyRequest: bogus Time-To-Live value (%.*S).\n"),
                    this,
                    EntryTimeToLiveLength,
                    EntryTimeToLiveText);

                return FALSE;

            }

            DebugF (_T("LDAP: 0x%x %08X requested lifetime increase of %d seconds for (%.*S).\n"),
                 this, 
                 ntohl (SourceAddress.sin_addr.s_addr), 
                 EntryTimeToLive, // in seconds 
                 ANSI_STRING_PRINTF (&ClientAlias));

        }
    }

    // If type of the modification was 'replace', and the attribute to be modified was 'EntryTTL'
    // then we have just received a valid refresh request from PhoneDialer
    //
    if (!IsValidRefreshRequest) {

        DebugF (_T("LDAP: 0x%x client %08X issued unqualified ModifyRequest (not a refresh request).\n"),
                    this,
                    ntohl (SourceAddress.sin_addr.s_addr)); 

        return FALSE;
    }

    if (!ClientAlias.Buffer || ClientAlias.Length == 0) {

        DebugF (_T("LDAP: 0x%x client %08X issued unqualified ModifyRequest (no client alias in refresh request).\n"),
                    this,
                    ntohl (SourceAddress.sin_addr.s_addr)); 

        return FALSE;
    }

    if (!ServerSocket.GetRemoteAddress (&ServerAddress)) {
        DebugF (_T("LDAP: 0x%x ModifyRequest: failed to get server address -- internal error.\n"),
                    this,
                    ntohl (SourceAddress.sin_addr.s_addr)); 

        return FALSE;
    }

    DebugF (_T("LDAP: 0x%x inserts valid ModifyRequest into operation table.\n"), this);

    // Allocate and build an LDAP_OPERATION structure.
    CreateOperation (
        LDAP_OPERATION_MODIFY,
        MessageID,
        &DirectoryPath,
        &ClientAlias,
        SourceAddress.sin_addr,
        &ServerAddress,
        EntryTimeToLive
        );

    // The entry is now in the operation array
    // later, when the server sends the ModifyResponse,
    // we'll check whether it was successful.
    // If so, we will find and refresh matching
    // entry in the LDAP Address Translation Table
    
    return FALSE;
}

BOOL LDAP_CONNECTION::ProcessDeleteRequest (
    IN    LDAP_MESSAGE_ID    MessageID,
    IN    DelRequest *    Request)
{
    ANSI_STRING  DirectoryPath;
    HRESULT Result = S_FALSE;
    LDAP_PATH_ELEMENTS    PathElements;

    assert (Request);

    DirectoryPath.Buffer = (PCHAR) Request -> value;
    DirectoryPath.Length = (USHORT) Request -> length;
    DirectoryPath.MaximumLength = (USHORT) Request -> length;

    ParseDirectoryPath (&DirectoryPath, &PathElements);

    if (RtlEqualStringConst (&PathElements.ObjectClass, &LdapText_RTPerson, TRUE)) {

        Result = LdapTranslationTable.RemoveEntryByAliasServer (&PathElements.CN, &DestinationAddress);

        if (Result == S_OK) {

            DebugF (_T("LDAP: 0x%x removed entry (%.*S) from LDAP table.\n"),
                this,
                ANSI_STRING_PRINTF (&DirectoryPath));

        } else {
            
            DebugF (_T("LDAP: 0x%x attempted to remove entry (%.*S) from LDAP table, but it was not there.\n"),
                this,
                ANSI_STRING_PRINTF (&DirectoryPath));
        
        }

    } else {

        DebugF (_T("LDAP: 0x%x client %08X issued unqualified DeleteRequest.\n"),
                    this,
                    ntohl (SourceAddress.sin_addr.s_addr)); 
    }

    return FALSE;
}

BOOL LDAP_CONNECTION::ProcessSearchRequest (
    IN    LDAPMessage *    Message)
{
    SearchRequest            * Request;

    ANSI_STRING                DirectoryPath;
    ANSI_STRING                AttributeTag;
    ANSI_STRING                AttributeType;
    ANSI_STRING                AttributeValue;
    ANSI_STRING                RequestedForAlias;

    LDAP_PATH_ELEMENTS         PathElements;
    LDAP_OPERATION           * Operation;

    Filter                   * SearchFilter;
    Filter_and               * FilterIterator;
    SearchRequest_attributes * Iterator;
    AttributeValueAssertion  * EqualityAssertion;
                
    BOOL IsRequestForIPAddress     = FALSE;
    BOOL IsRequestForRTPerson      = FALSE;
    BOOL IsRequestForSttl          = FALSE;
    BOOL IsQualifiedRequest        = FALSE;
    BOOL IsRequestForSpecificAlias = FALSE;

    DWORD                      EntryTimeToLive = 0;
    CHAR                       EntryTimeToLiveText [11];
    USHORT                     EntryTimeToLiveLength;
                
    DWORD OperationInsertionIndex;

    Request = &Message -> protocolOp.u.searchRequest;

    // check to see if an existing operation with the same message id is pending.
    // if so, the client is in violation of the LDAP spec.
    // we'll just ignore the packet in this case.
    // at the same time, compute the insertion position for the new operation (for use later).

    if (FindOperationIndexByMessageID (Message -> messageID, &OperationInsertionIndex)) {
        DebugF (_T("LDAP: 0x%x - SearchRequest - client has issued two requests with the same message ID (%u), LDAP protocol violation, packet will not be processed.\n"),
            this,
            Message -> messageID);

        return FALSE;
    }

    // Cover the case when SearchRequest does not supply baseObject 
    if (Request -> baseObject.value == NULL || Request -> baseObject.length == 0) {

        DebugF (_T("LDAP: 0x%x client %08X issued unqualified SearchRequest (no base object).\n"),
                    this,
                    ntohl (SourceAddress.sin_addr.s_addr)); 

            return FALSE;

    }

    InitializeAnsiString (&DirectoryPath, &Request -> baseObject);
    ParseDirectoryPath (&DirectoryPath, &PathElements);

    // Determine whether we are interested in this request. 
    // 
    // This is what we are interested in from SearchRequests originated by NetMeeting:
    //    1. It searches for IP address (query to the server), or
    //    2. It searches for Sttl attribute, AND for RTPerson attribute (refresh request)
    //

    for (Iterator = Request -> attributes; Iterator; Iterator = Iterator -> next) {
       
        InitializeAnsiString (&AttributeValue, &Iterator -> value);

        if (RtlEqualStringConst (&AttributeValue, &LdapText_Attribute_sipaddress, TRUE)
            || RtlEqualStringConst (&AttributeValue, &LdapText_Attribute_ipAddress, TRUE)) {

            IsRequestForIPAddress = TRUE;

        }

        // else not interesting attribute
    }

    // Look closer at the composition of the filter. 
    //
    // NetMeeting specifies the following filter in SearchRequest:
    //
    // FilterType = AND
    //     FilterType = EqualityMatch
    //         AttributeType  = objectClass
    //         AttributeValue = RTPerson
    //     FilterType = EqualityMatch
    //         AttributeType  = cn
    //         AttributeValue = <...alias, for which IP address is searched, or refresh is requested...>
    //
    // NetMeeting may also add the following 'EqualityMatch' clause to the filter
    // if a Time-To-Live increase is requested
    //
    //     FilterType = EqualityMatch
    //         AttributeType  = sttl
    //         AttributeValue = <...increase in Time-To-Live, in minutes...>
    //
    // Phone Dialer DOES NOT query directory server to determine IP address of the called party.
    // It does the determination by some other means (DNS lookup, most certainly).

    SearchFilter = &Request -> filter;

    switch (SearchFilter -> choice) {
    case and_choice:
        for (FilterIterator = SearchFilter -> u.and; FilterIterator; FilterIterator = FilterIterator -> next) {
            switch (FilterIterator -> value.choice) {
            case equalityMatch_choice:

                EqualityAssertion = &FilterIterator -> value.u.equalityMatch;

                InitializeAnsiString (&AttributeType,  &EqualityAssertion -> attributeType);
                InitializeAnsiString (&AttributeValue, &EqualityAssertion -> attributeValue);

                if (RtlEqualStringConst (&AttributeType, &LdapText_Attribute_sttl, TRUE)) {

                    IsRequestForSttl = TRUE;

                    EntryTimeToLiveLength = min (10, (USHORT) AttributeValue.Length);
                    EntryTimeToLiveText [EntryTimeToLiveLength] = 0;
                    memcpy (EntryTimeToLiveText, AttributeValue.Buffer, EntryTimeToLiveLength * sizeof (CHAR));

                    if (RtlCharToInteger (&EntryTimeToLiveText [0], 10, &EntryTimeToLive) != STATUS_SUCCESS) {

                        DebugF (_T("LDAP: 0x%x - SearchRequest: bogus Time-To-Live value (%.*S).\n"),
                            this,
                            EntryTimeToLiveLength,
                            EntryTimeToLiveText);

                        return FALSE;

                    }

                }

                if (RtlEqualStringConst (&AttributeType, &LdapText_ObjectClass, TRUE)
                    || RtlEqualStringConst (&AttributeValue, &LdapText_RTPerson, TRUE)) {

                    IsRequestForRTPerson = TRUE;
                }

                if (RtlEqualStringConst (&AttributeType, &LdapText_CN, TRUE)) {

                    RequestedForAlias = AttributeValue;

                    IsRequestForSpecificAlias = TRUE;

                }
                
                break;

            default:

                break;
            }
        }
                
        break;

    default:

        break;
    }

    IsQualifiedRequest = IsRequestForIPAddress || (IsRequestForRTPerson && IsRequestForSttl);
        
    if (!IsQualifiedRequest) {
        DebugF (_T("LDAP: 0x%x client %08X issued unqualified SearchRequest.\n"),
                    this,
                    ntohl (SourceAddress.sin_addr.s_addr)); 

        return FALSE;
    }

    if (IsRequestForSttl) {

        DebugF (_T("LDAP: 0x%x %08X requested lifetime increase of %d seconds for (%.*S).\n"),
             this, 
             ntohl (SourceAddress.sin_addr.s_addr), 
             EntryTimeToLive * 60, // in seconds
             ANSI_STRING_PRINTF (&RequestedForAlias));
    }

    if (IsRequestForIPAddress) {

        if (IsRequestForSpecificAlias) {

            DebugF (_T("LDAP: 0x%x %08X requested IP address for (%.*S).\n"),
                 this, 
                 ntohl (SourceAddress.sin_addr.s_addr), 
                 ANSI_STRING_PRINTF (&RequestedForAlias));

        } else {

            DebugF (_T("LDAP: 0x%x %08X issued unspecified request for IP address.\n"),
                 this, 
                 ntohl (SourceAddress.sin_addr.s_addr) );
        }
    }

    DebugF (_T("LDAP: 0x%x inserts valid SearchRequest into operation table.\n"), this);

    // allocate and build an LDAP_OPERATION structure.
    CreateOperation (
        LDAP_OPERATION_SEARCH,
        Message -> messageID,
        &DirectoryPath,
        &PathElements.CN,
        SourceAddress.sin_addr,
        &DestinationAddress,
        EntryTimeToLive * 60); // in seconds

    // the entry is now in the operation array
    // later, when the server sends the SearchResponse,
    // we'll match the response with the request,
    // and modify the IP address if an entry with
    // the matching alias happens to be in the 
    // LDAP_TRANSLATION_TABLE. This would mean that 
    // the client running on the proxy machine itself
    // wishes to connect to a private subnet client.

    PumpClientToServer.EncodeSendMessage (Message);

    return TRUE;
}

// server to client messages

void LDAP_CONNECTION::ProcessAddResponse (
    IN    LDAPMessage *    Message)
{
    AddResponse *        Response;
    LDAP_OPERATION *    Operation;

    Response = &Message -> protocolOp.u.addResponse;

    AssertLocked();

    if (!FindOperationByMessageID (Message -> messageID, &Operation)) {

        return;
    }

    if (Operation -> Type == LDAP_OPERATION_ADD) {

        if (Response -> resultCode == success) {
            DebugF (_T("LDAP: 0x%x server has approved AddRequest for (%.*S).\n"), 
                this, ANSI_STRING_PRINTF (&Operation -> Alias));

            assert (Operation -> Alias.Buffer);
            assert (Operation -> DirectoryPath.Buffer);

            InterfaceArray.StartQ931ReceiveRedirects ();

            LdapTranslationTable.InsertEntry (
                &Operation -> Alias,
                &Operation -> DirectoryPath,
                Operation -> ClientAddress,
                &Operation -> ServerAddress,
                 Operation -> EntryTimeToLive);

        }
        else {
            DebugF (_T("LDAP: 0x%x Server has rejected AddRequest, result code (%u).\n"),
                this,
                Response -> resultCode);
        }
    }
    else {
        DebugF (_T("LDAP: 0x%x received AddResponse with message ID (%u), and found matching pending request, but the type of the request does not match (%d).\n"),
            this,
            Message -> messageID,
            Operation -> Type);
    }

    Operation -> FreeContents ();
                
    OperationArray.DeleteEntry (Operation);
}

void LDAP_CONNECTION::ProcessModifyResponse (
    IN    LDAP_MESSAGE_ID        MessageID,
    IN    ModifyResponse *    Response)
{
    LDAP_OPERATION *    Operation;

    AssertLocked();

    if (!FindOperationByMessageID (MessageID, &Operation)) {

        return;
    }

    if (Operation -> Type == LDAP_OPERATION_MODIFY) {

        if (Response -> resultCode == success) {
            assert (Operation -> Alias.Buffer);
            assert (Operation -> DirectoryPath.Buffer);

            DebugF (_T("LDAP: 0x%x server %08X has approved increase in lifetime of entry (%.*S) by %d seconds.\n"),
                    this,
                    ntohl (Operation -> ServerAddress.sin_addr.s_addr),
                    ANSI_STRING_PRINTF (&Operation -> Alias),
                    Operation -> EntryTimeToLive);

            LdapTranslationTable.RefreshEntry (&Operation -> Alias,
                                               &Operation -> DirectoryPath,
                                                Operation -> ClientAddress,
                                               &Operation -> ServerAddress,
                                                Operation -> EntryTimeToLive);

        }
        else {
            DebugF (_T("LDAP: 0x%x server %08X has rejected ModifyRequest, result code (%u).\n"),
                this,
                ntohl (Operation -> ServerAddress.sin_addr.s_addr), Response -> resultCode);
        }
    }
    else {
        DebugF (_T("LDAP: 0x%x received with message ID (%u), and found matching pending request, but the type of the request does not match (%d).\n"),
            this,
            MessageID,
            Operation -> Type);
    }

    Operation -> FreeContents ();
                
    OperationArray.DeleteEntry (Operation);
}

void LDAP_CONNECTION::ProcessDeleteResponse (
    IN    LDAP_MESSAGE_ID        MessageID,
    IN    DelResponse *        Response)
{
}

BOOL LDAP_CONNECTION::ProcessSearchResponse (
    IN    LDAPMessage *    Message)
{
    SearchResponse *    Response;
    ANSI_STRING         ObjectName;
    LDAP_OBJECT_NAME_ELEMENTS    ObjectNameElements = { 0 };
    ANSI_STRING         AttributeTag;
    ASN1octetstring_t   IPAddressOldValue;
    ANSI_STRING         ClientAlias;
    ANSI_STRING         String;
    ANSI_STRING         ErrorMessage;
    HRESULT             TranslationTableLookupResult;
    DWORD               LookupAddress;           // host order
    SOCKADDR_IN         ServerAddress;
    DWORD               LocalToRequestedAddress; // host order
    DWORD               AddressToReport;

    SearchResponse_entry_attributes             * Iter;
    SearchResponse_entry_attributes_Seq_values  * ValueSequence;
    SearchResponse_entry_attributes_Seq         * Attribute;
    AttributeValue *    Attribute_IPAddress;
    AttributeValue *    Attribute_Sttl;

    CHAR                IPAddressText    [0x20];
    BOOL                Result = FALSE;
    LDAP_OPERATION *    Operation;

    SOCKET UDP_Socket      = INVALID_SOCKET;

    assert (Message);

    Response = &Message -> protocolOp.u.searchResponse;

    AssertLocked();

    if (!FindOperationByMessageID (Message -> messageID, &Operation)) {

        return FALSE;
    }

    switch (Response -> choice) {
    case entry_choice:

        // Determine address of the server
        if (!ServerSocket.GetRemoteAddress (&ServerAddress)) {
            return FALSE;
        }
        
        if(Response -> choice == entry_choice) {

            if (Operation -> Type == LDAP_OPERATION_SEARCH) {
                // Parse this object's name to get alias and IP address
                InitializeAnsiString (&ObjectName, &Response -> u.entry.objectName);
                ParseObjectName (&ObjectName, &ObjectNameElements);

                // scan through the set of attributes
                // find the ones of interest

                Attribute_IPAddress = NULL;
                Attribute_Sttl      = NULL;

                for (Iter = Response -> u.entry.attributes; Iter; Iter = Iter -> next) {
                    Attribute = &Iter -> value;

                    InitializeAnsiString (&AttributeTag, &Attribute -> type);

                    if (Attribute -> values) {
                        if (RtlEqualStringConst (&AttributeTag, &LdapText_Attribute_sipaddress, TRUE)
                            || RtlEqualStringConst (&AttributeTag, &LdapText_Attribute_ipAddress, TRUE)) {

                            Attribute_IPAddress = &Attribute -> values -> value;

                        } else if (RtlEqualStringConst (&AttributeTag, &LdapText_Attribute_sttl, TRUE)) {

                            Attribute_Sttl = &Attribute -> values -> value;
                        }

                        // else, we aren't interested in the attribute
                    }
                    else {
                        // else, the attribute has no values
                    }
                }

                // make sure that the alias is present
                ClientAlias = ObjectNameElements.CN;

                if (ClientAlias.Length == 0) {
                    Result = FALSE;
                } else {
                    
                    if (Attribute_Sttl) {

                        // NetMeeting refreshes its registrations on an ILS by periodically sending a SearchRequest with 
                        // attribute "sttl"

                        DebugF (_T ("LDAP: 0x%x server %08X has approved increase in lifetime of entry (%.*S) by %d seconds.\n"),
                                    this, 
                                    ntohl (ServerAddress.sin_addr.s_addr), 
                                    ANSI_STRING_PRINTF (&ClientAlias), 
                                    Operation -> EntryTimeToLive);

                        LdapTranslationTable.RefreshEntry (&ClientAlias,
                                                           &ObjectName,
                                                            Operation -> ClientAddress,
                                                           &Operation -> ServerAddress, 
                                                            Operation -> EntryTimeToLive);

                    } else {
                        // make sure ip address attribute is present
                        if (!Attribute_IPAddress) {
                            Result = FALSE;
                        } else {
                            // see whether there is a registration entry in the translation table
                            // with the same alias
                            TranslationTableLookupResult = LdapQueryTableByAliasServer (&ClientAlias,
                                                                                   &Operation -> ServerAddress,
                                                                                   &LookupAddress);
                            // If an entry with the same alias is not in the table, 
                            // then we send the SearchResponse PDU unmodified to the requestor
                            if (S_OK != TranslationTableLookupResult) {

                                Result = FALSE;
                            
                            } else {
                                // Otherwise, we decide what would be the correct address
                                // to report to the requestor. We will either report the address
                                // read from the Address Translation Table, or the address
                                // of the interface requestor used to reach us. The decision will be
                                // made based on the interface address requestor used to reach us, and
                                // address of the interface we would use to reach the requestee.

                                if (INADDR_NONE == SourceInterfaceAddress) {
                                    DebugF (_T("LDAP: 0x%x failed to get best interface address for the requestor.\n"), this);
                                    return FALSE;
                                }

                                // Determine on which interface we would connect to the entity whose address was requested
                                if (GetBestInterfaceAddress (LookupAddress, &LocalToRequestedAddress)) {
                                    DebugF (_T("LDAP: 0x%x failed to get best interface address for the requestee.\n"), this);
                                    return FALSE;
                                }

                                // The default reporting behaviour is to report the address of the best interface to reach the requestor,
                                // thus shielding the requestor from the knowledge of the network internals.
                                //
                                // However, there are three exceptions to this rule, when we report the actual address stored
                                // in the Address Translation Table. These exceptions are as follows:
                                //
                                // 1. If the requestor is local.
                                //    In this case we assume that the requestor can directly reach the requestee, and thus
                                //    an H.323 call between them doesn't have to be routed via us.
                                //
                                // 2. If local H323 routing is enabled, AND the requestor and the requestee have the same address
                                //    This is necessary to allow the requestor to do something special with the calls to itself
                                //    (NetMeeting, for example, prohibits such calls).
                                // 
                                // 3. If local H323 routing is disabled, and requestor and requestee are reachable through the
                                //    same interface.
                                //    In these case we assume that the requestor and the requestee can directly reach one another,
                                //    and thus an H.323 call between them doesn't have to be routed via us.
                                //   
                        
                                if (::NhIsLocalAddress (SourceAddress.sin_addr.s_addr)) {

                                    AddressToReport = LookupAddress;

                                } else {

                                    if (EnableLocalH323Routing) {
                                    
                                        AddressToReport = (ntohl (SourceAddress.sin_addr.s_addr) == LookupAddress)  ?
                                                    LookupAddress            :
                                                    SourceInterfaceAddress;
                                    } else {

                                        AddressToReport = (SourceInterfaceAddress == LocalToRequestedAddress)       ?
                                                    LookupAddress            :
                                                    SourceInterfaceAddress;

                                    }
                                }

                                assert (Attribute_IPAddress);

                                if (RtlIntegerToChar (htonl (AddressToReport),
                                    10, 0x1F, IPAddressText) != STATUS_SUCCESS) {
                                    DebugF (_T("LDAP: 0x%x failed to convert IP address to text -- internal error.\n"), this);
                                    Result = FALSE;
                                } else {

                                    DebugF (_T("LDAP: 0x%x read %08X in table. Reporting  %08X to requestor %08X.\n"),
                                         this,
                                         LookupAddress, AddressToReport, ntohl (SourceAddress.sin_addr.s_addr));

                                    // Save the old value of the IP address, - we will need to restore
                                    // the PDU structure later.
                                    IPAddressOldValue = *Attribute_IPAddress;

                                    // now, in-place, we modify the PDU structure,
                                    // reencode it, send it, undo the modification
                                    // (so ASN1Free_SearchResponse doesn't act up)
                                    Attribute_IPAddress -> value = (PUCHAR) IPAddressText;
                                    Attribute_IPAddress -> length = strlen (IPAddressText);

                                    PumpServerToClient.EncodeSendMessage (Message);

                                    // switch back so we don't a/v when decoder frees pdu
                                    *Attribute_IPAddress = IPAddressOldValue;

                                    Result = TRUE;
                                }
                            }
                        }
                    }
                }
            } else {
                DebugF (_T("LDAP: 0x%x received response with message ID (%u), and found matching pending request, but the type of the request does not match (%d).\n"),
                    this,
                    Message -> messageID,
                    Operation -> Type);

                Result = FALSE;
            }
        } 
    break;

    case resultCode_choice:

        // We free the operation and associated memory on SearchResponses containing result
        // code, no matter whether the code indicated success or failure
        InitializeAnsiString (&ErrorMessage, &Response -> u.resultCode.errorMessage);

        DebugF (_T("LDAP: 0x%x result in SearchResponse (%d) (code=%d message=(%*.S)).\n"),
             this,
             Message -> messageID,
             Response -> u.resultCode.resultCode,
             ANSI_STRING_PRINTF (&ErrorMessage));

        Operation -> FreeContents ();
                
        OperationArray.DeleteEntry (Operation);

    break;

    default:

        AssertNeverReached ();
    }

    return Result;
}

// this method does not assume ownership of the LdapMessage structure,
// which has scope only of this call stack.

BOOL LDAP_CONNECTION::ProcessLdapMessage (
    IN    LDAP_PUMP *        Pump,
    IN    LDAPMessage *    LdapMessage)
{
    assert (Pump);
    assert (LdapMessage);

    if (Pump == &PumpClientToServer) {

        switch (LdapMessage -> protocolOp.choice) {
        case addRequest_choice:
            DebugF (_T("LDAP: 0x%x received AddRequest (%d).\n"), this, LdapMessage -> messageID);
            return ProcessAddRequest (LdapMessage);

        case modifyRequest_choice:
            DebugF (_T("LDAP: 0x%x received ModifyRequest (%d).\n"), this, LdapMessage -> messageID);
            return ProcessModifyRequest (LdapMessage -> messageID, &LdapMessage -> protocolOp.u.modifyRequest);

        case delRequest_choice:
            DebugF (_T("LDAP: 0x%x received DeleteRequest (%d).\n"), this, LdapMessage -> messageID);
            return ProcessDeleteRequest (LdapMessage -> messageID, &LdapMessage -> protocolOp.u.delRequest);

        case searchRequest_choice:
            DebugF (_T("LDAP: 0x%x received SearchRequest (%d).\n"), this, LdapMessage -> messageID);
            return ProcessSearchRequest (LdapMessage);

        case bindRequest_choice:
            DebugF (_T("LDAP: 0x%x received BindRequest (%d).\n"), this, LdapMessage -> messageID);
            return FALSE;

        case abandonRequest_choice:
            DebugF (_T("LDAP: 0x%x received AbandonRequest (%d).\n"), this, LdapMessage -> messageID);
            return FALSE;

        case unbindRequest_choice:
            DebugF (_T("LDAP: 0x%x received UnbindRequest (%d).\n"), this, LdapMessage -> messageID);
            return FALSE;

        case modifyRDNRequest_choice:
            DebugF (_T("LDAP: 0x%x received ModifyRDNRequest (%d).\n"), this, LdapMessage -> messageID);
            return FALSE;

        case compareDNRequest_choice:
            DebugF (_T("LDAP: 0x%x received CompareDNRequest (%d).\n"), this, LdapMessage -> messageID);
            return FALSE;

        default:
            return FALSE;
        }

        return FALSE;
    }
    else if (Pump == &PumpServerToClient) {

        switch (LdapMessage -> protocolOp.choice) {
        case    addResponse_choice:
            DebugF (_T("LDAP: 0x%x received AddResponse (%d).\n"), this, LdapMessage -> messageID);
            ProcessAddResponse (LdapMessage);
            break;

        case    modifyResponse_choice:
            DebugF (_T("LDAP: 0x%x received ModifyResponse (%d).\n"), this, LdapMessage -> messageID);
            ProcessModifyResponse (LdapMessage -> messageID, &LdapMessage -> protocolOp.u.modifyResponse);
            break;

        case    delResponse_choice:
            DebugF (_T("LDAP: 0x%x received DeleteResponse (%d).\n"), this, LdapMessage -> messageID);
            ProcessDeleteResponse (LdapMessage -> messageID, &LdapMessage -> protocolOp.u.delResponse);
            break;

        case    searchResponse_choice:
            DebugF (_T("LDAP: 0x%x received SearchResponse (%d).\n"), this, LdapMessage -> messageID);
            return ProcessSearchResponse (LdapMessage);
            break;

        case bindResponse_choice:
            DebugF (_T("LDAP: 0x%x received BindResponse (%d).\n"), this, LdapMessage -> messageID);
            return FALSE;

        case modifyRDNResponse_choice:
            DebugF (_T("LDAP: 0x%x received ModifyRDNResponse (%d).\n"), this, LdapMessage -> messageID);
            return FALSE;

        case compareDNResponse_choice:
            DebugF (_T("LDAP: 0x%x received CompareDNResponse (%d).\n"), this, LdapMessage -> messageID);
            return FALSE;

        default:
            break;
        }

        return FALSE;

    }
    else {
        AssertNeverReached();
        return FALSE;
    }
}

void LDAP_CONNECTION::ProcessBuffer (
    IN    LDAP_PUMP *        Pump,
    IN    LDAP_BUFFER *    Buffer)
{
    ASN1error_e        Error;
    LDAPMessage *    PduStructure;
    ASN1decoding_t    Decoder;

    assert (Pump);
    assert (Buffer);
        
    // decode the PDU

    Error = ASN1_CreateDecoder (LDAP_Module, &Decoder, Buffer -> Data.Data, Buffer -> Data.Length, NULL);

    if (Error == ASN1_SUCCESS) {

        PduStructure = NULL;
        Error = ASN1_Decode (Decoder, (PVOID *) &PduStructure, LDAPMessage_ID, 0, NULL, 0);

        if (ASN1_SUCCEEDED (Error)) {
            if (ProcessLdapMessage (Pump, PduStructure)) {
                // a TRUE return value indicates that ProcessLdapMessage interpreted
                // and acted on the contents of PduStructure.  therefore, the
                // original PDU is no longer needed, and is destroyed.

                delete Buffer;
            }
            else {
                // a FALSE return value indicates that ProcessLdapMessage did NOT
                // interpret the contents of PduStructure, and that no data has been
                // sent to the other socket.  In this case, we forward the original PDU.

                Pump -> SendQueueBuffer (Buffer);
            }

            ASN1_FreeDecoded (Decoder, PduStructure, LDAPMessage_ID);
        }
        else {
            DebugF (_T("LDAP: 0x%x failed to decode pdu, ASN.1 error %d, forwarding pdu without interpreting contents.\n"),
                this,
                Error);

#if    DBG
        if (DebugLevel > 1) {
            DumpMemory (Buffer -> Data.Data, Buffer -> Data.Length);
            BerDump (Buffer -> Data.Data, Buffer -> Data.Length);
            ASN1_Decode (Decoder, (PVOID *) &PduStructure, LDAPMessage_ID, 0, Buffer -> Data.Data, Buffer -> Data.Length);
        }
#endif
            Pump -> SendQueueBuffer (Buffer);
        }

        ASN1_CloseDecoder (Decoder);
    }
    else {
        DebugF (_T("LDAP: 0x%x failed to create ASN.1 decoder, ASN.1 error %08X, forwarding pdu without interpreting contents.\n"),
            this,
            Error);

        Pump -> SendQueueBuffer (Buffer);
    }
}

// static
INT LDAP_CONNECTION::BinarySearchOperationByMessageID (
    IN    const    LDAP_MESSAGE_ID *    SearchKey,
    IN    const    LDAP_OPERATION *    Comparand)
{
    if (*SearchKey < Comparand -> MessageID) return -1;
    if (*SearchKey > Comparand -> MessageID) return 1;

    return 0;
}

BOOL LDAP_CONNECTION::FindOperationIndexByMessageID (
    IN    LDAP_MESSAGE_ID    MessageID,
    OUT    DWORD *            ReturnIndex)
{
    return OperationArray.BinarySearch ((SEARCH_FUNC_LDAP_OPERATION)BinarySearchOperationByMessageID, &MessageID, ReturnIndex);
}

BOOL LDAP_CONNECTION::FindOperationByMessageID (
    IN    LDAP_MESSAGE_ID    MessageID,
    OUT    LDAP_OPERATION **    ReturnOperation)
{
    DWORD    Index;

    if (OperationArray.BinarySearch ((SEARCH_FUNC_LDAP_OPERATION)BinarySearchOperationByMessageID, &MessageID, &Index)) {
        *ReturnOperation = &OperationArray[Index];
        return TRUE;
    }
    else {
        *ReturnOperation = NULL;
        return FALSE;
    }
}

void LDAP_CONNECTION::OnStateChange (
    LDAP_SOCKET *        ContainedSocket,
    LDAP_SOCKET::STATE    NewSocketState)
{
    assert (ContainedSocket == &ClientSocket || ContainedSocket == &ServerSocket);

    AssertLocked();

    switch (NewSocketState) {

    case    LDAP_SOCKET::STATE_CONNECT_PENDING:
        // Client socket transitions directly from
        // STATE_NONE to STATE_CONNECTED
        assert (ContainedSocket != &ClientSocket);

        State = STATE_CONNECT_PENDING;

        break;

    case    LDAP_SOCKET::STATE_CONNECTED:

        if (ClientSocket.GetState() == LDAP_SOCKET::STATE_CONNECTED
            && ServerSocket.GetState() == LDAP_SOCKET::STATE_CONNECTED) {
            
            State = STATE_CONNECTED;

            StartIo();
        }

        break;

    case    LDAP_SOCKET::STATE_TERMINATED:

        Terminate ();

        break;
    }
}


void LDAP_CONNECTION::Terminate (void)
{
    switch (State) {
        
    case    STATE_TERMINATED:
        // nothing to do
        break;

    default:
        State = STATE_TERMINATED;

        ClientSocket.Terminate();
        ServerSocket.Terminate();
        PumpClientToServer.Terminate();
        PumpServerToClient.Terminate();

        LdapConnectionArray.RemoveConnection (this);
        
        break;
    }
}

void LDAP_CONNECTION::TerminateExternal (void) 
{
    Lock ();
    
    Terminate ();

    Unlock ();
}


BOOL
LDAP_CONNECTION::IsConnectionThrough (
    IN DWORD InterfaceAddress // host order
    )
/*++

Routine Description:
    Determines whether the connection goes through the
    interface specified

Arguments:
    InterfaceAddress - address of the interface for which
        the determination is to be made.

Return Values:
    TRUE - if the connection being proxied goes through the
        interface specified

    FALSE - if the connection being proxied does not go through the
        interface specified

Notes:

--*/

{
    BOOL IsThrough;
    
    IsThrough = (InterfaceAddress == SourceInterfaceAddress) || 
                (InterfaceAddress == DestinationInterfaceAddress);

    return IsThrough;

} // LDAP_CONNECTION::IsConnectionThrough

// LDAP_CONNECTION_ARRAY ----------------------------------------------
LDAP_CONNECTION_ARRAY::LDAP_CONNECTION_ARRAY (void) {        
    IsEnabled = FALSE;
}

void LDAP_CONNECTION_ARRAY::RemoveConnection (
    LDAP_CONNECTION *    LdapConnection)
{
    LDAP_CONNECTION **    Pos;
    LDAP_CONNECTION **    End;
    BOOL                DoRelease;

    Lock();

    // linear scan, yick

    DoRelease = FALSE;

    ConnectionArray.GetExtents (&Pos, &End);

    for (; Pos < End; Pos++) {
        if (*Pos == LdapConnection) {

            // swap with last entry
            // quick way to delete entry from table
            *Pos = *(End - 1);
            ConnectionArray.Length--;

            DoRelease = TRUE;
            break;
        }
    }

    Unlock();

    if (DoRelease) {

        LdapConnection -> Release();
    }
    else {
        // when could this happen?
        // perhaps a harmless race condition?

        DebugF (_T("LDAP: 0x%x could not be removed from table -- was not in table to begin with.\n"), LdapConnection);
    }
}

void LDAP_CONNECTION_ARRAY::OnInterfaceShutdown (
    IN DWORD InterfaceAddress) { // host order
    
    DWORD ArrayIndex = 0;
    LDAP_CONNECTION * Connection;
    LDAP_CONNECTION ** ConnectionHolder = NULL;
    DYNAMIC_ARRAY <LDAP_CONNECTION *> TempArray;

    Lock ();

    while (ArrayIndex < ConnectionArray.GetLength ()) {
        Connection = ConnectionArray [ArrayIndex];

        if (Connection -> IsConnectionThrough (InterfaceAddress)) {

            DebugF (_T("LDAP: 0x%x terminating (killing all connections through %08X).\n"), 
                Connection, InterfaceAddress);

            ConnectionHolder = TempArray.AllocAtEnd ();

            if (NULL == ConnectionHolder) {

                Debug (_T("LDAP_CONNECTION_ARRAY::OnInterfaceShutdown - unable to grow array.\n"));

            } else {

                Connection -> AddRef ();

                *ConnectionHolder = Connection;
            }
        }

        ArrayIndex++;
    }

    Unlock ();

    ArrayIndex = 0;

    while (ArrayIndex < TempArray.GetLength ()) {
        Connection = TempArray[ArrayIndex];

        Connection -> TerminateExternal ();

        Connection -> Release ();

        ArrayIndex++;
    }
}

void LDAP_CONNECTION_ARRAY::Start (void)
{        
    Lock ();

    IsEnabled = TRUE;

    Unlock ();
}

void LDAP_CONNECTION_ARRAY::Stop (void)
{
    LDAP_CONNECTION * LdapConnection;

    Lock ();

    IsEnabled = FALSE;

    while (ConnectionArray.GetLength()) {

        LdapConnection = ConnectionArray[0];

        LdapConnection -> AddRef ();

        Unlock ();

        LdapConnection -> TerminateExternal ();

        Lock ();

        LdapConnection -> Release ();
    }

    ConnectionArray.Free ();

    Unlock ();
}
    
HRESULT LDAP_CONNECTION_ARRAY::InsertConnection (
                                LDAP_CONNECTION * LdapConnection)
{
    LDAP_CONNECTION ** ConnectionHolder = NULL;
    HRESULT Result;

    Lock ();

    if (IsEnabled) {

        if (ConnectionArray.Length <= LDAP_MAX_CONNECTIONS) {

            ConnectionHolder = ConnectionArray.AllocAtEnd ();

            if (NULL == ConnectionHolder) {

                Result = E_OUTOFMEMORY;

            } else {

                LdapConnection -> AddRef ();

                *ConnectionHolder = LdapConnection;

                Result = S_OK;
            }

        } else {

            return E_ABORT;

        }

    } else {
    
        Result = E_FAIL;
    }

    Unlock ();

    return Result;
}

// LDAP_ACCEPT ----------------------------------------------

LDAP_ACCEPT::LDAP_ACCEPT (void)
{
}

// static
void 
LDAP_ACCEPT::AsyncAcceptFunction (
    IN    PVOID         Context,
    IN    SOCKET        Socket,
    IN    SOCKADDR_IN * LocalAddress,
    IN    SOCKADDR_IN * RemoteAddress
    )
{
    HRESULT Result;

    Result = AsyncAcceptFunctionInternal (
                Context,
                Socket,
                LocalAddress,
                RemoteAddress
                );

    if (S_OK != Result) {
    
        if (INVALID_SOCKET != Socket) {

            closesocket (Socket);

            Socket = INVALID_SOCKET;
        }
    }
}
   
// static
HRESULT 
LDAP_ACCEPT::AsyncAcceptFunctionInternal (
    IN    PVOID         Context,
    IN    SOCKET        Socket,
    IN    SOCKADDR_IN * LocalAddress,
    IN    SOCKADDR_IN * RemoteAddress
    )
{
    LDAP_CONNECTION *   LdapConnection;
    HRESULT             Result;
    NAT_KEY_SESSION_MAPPING_EX_INFORMATION RedirectInformation;
    ULONG               RedirectInformationLength;
    ULONG               Error;
    DWORD               BestInterfaceAddress;
    SOCKADDR_IN         DestinationAddress;

    DebugF (_T("LDAP: ----------------------------------------------------------------------\n"));

#if DBG
    ExposeTimingWindow ();
#endif

    // a new LDAP connection has been accepted from the network.
    // first, we determine the original addresses of the transport connection.
    // if the connection was redirected to our socket (due to NAT),
    // then the query of the NAT redirect table will yield the original transport addresses.
    // if an errant client has connected to our service, well, we really didn't
    // intend for that to happen, so we just immediately close the socket.

    RedirectInformationLength = sizeof RedirectInformation;

    Result = NatLookupAndQueryInformationSessionMapping (
        NatHandle,
        IPPROTO_TCP,
        LocalAddress -> sin_addr.s_addr,
        LocalAddress -> sin_port,
        RemoteAddress -> sin_addr.s_addr,
        RemoteAddress -> sin_port,
        &RedirectInformation,
        &RedirectInformationLength,
        NatKeySessionMappingExInformation);

    if (STATUS_SUCCESS != Result) {

        DebugErrorF (Result, _T("LDAP: new connection was accepted from (%08X:%04X), but it is not in the NAT redirect table -- rejecting connection.\n"),
            ntohl (RemoteAddress -> sin_addr.s_addr),
            ntohs (RemoteAddress -> sin_port));

        return Result;
    }

    Error = GetBestInterfaceAddress (ntohl (RedirectInformation.DestinationAddress), &BestInterfaceAddress);

    if (ERROR_SUCCESS != Error) {

        if (WSAEHOSTUNREACH == Error) {
    
            Error = RasAutoDialSharedConnection ();
        
            if (ERROR_SUCCESS != Error) {
                
                DebugF (_T("LDAP: RasAutoDialSharedConnection failed. Error=%d\n"), Error);
    
            }
    
        } else {

            DebugError (Error, _T("LDAP: Failed to get interface address for the destination.\n"));
            
            return HRESULT_FROM_WIN32 (Error);
        }
    }
    
#if DBG
    BOOL                IsPrivateOrLocalSource;
    BOOL                IsPublicDestination;

    Result = ::IsPrivateAddress (ntohl (RedirectInformation.SourceAddress), &IsPrivateOrLocalSource);

    if (S_OK != Result) {

        return Result;

    }

    IsPrivateOrLocalSource = IsPrivateOrLocalSource || ::NhIsLocalAddress (RedirectInformation.SourceAddress);

    Result = ::IsPublicAddress (ntohl (RedirectInformation.DestinationAddress), &IsPublicDestination);

    if (S_OK != Result) {

        return Result;

    }

    if (::NhIsLocalAddress (RedirectInformation.SourceAddress) &&
        ::NhIsLocalAddress (RedirectInformation.DestinationAddress))  {

        Debug (_T("LDAP: New LOCAL connection.\n"));

    } else {

        if (IsPrivateOrLocalSource && IsPublicDestination) {

            Debug (_T("LDAP: New OUTBOUND connection.\n"));

        } else {

            Debug (_T("LDAP: New INBOUND connection.\n"));
        }
    }
#endif // DBG

    DebugF (_T("LDAP: Connection redirected: (%08X:%04X -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"),
        ntohl (RedirectInformation.SourceAddress),
        ntohs (RedirectInformation.SourcePort),
        ntohl (RedirectInformation.DestinationAddress),
        ntohs (RedirectInformation.DestinationPort),
        ntohl (RedirectInformation.NewSourceAddress),
        ntohs (RedirectInformation.NewSourcePort),
        ntohl (RedirectInformation.NewDestinationAddress),
        ntohs (RedirectInformation.NewDestinationPort));

    // Create new LDAP_CONNECTION object
    LdapConnection = new LDAP_CONNECTION (&RedirectInformation);

    if (!LdapConnection) {

        DebugF(_T("LDAP: Failed to allocate LDAP_CONNECTION.\n"));

        return E_OUTOFMEMORY;
    }

    LdapConnection -> AddRef ();

    Result = LdapConnection -> Initialize (&RedirectInformation);

    if (S_OK == Result) {

        DestinationAddress.sin_family      = AF_INET;
        DestinationAddress.sin_addr.s_addr = RedirectInformation.DestinationAddress;
        DestinationAddress.sin_port        = RedirectInformation.DestinationPort; 

        if (S_OK == LdapConnectionArray.InsertConnection (LdapConnection)) {

            Result = LdapConnection -> AcceptSocket (Socket,
              LocalAddress,
              RemoteAddress,
              &DestinationAddress);

            if (S_OK != Result) {

                DebugF (_T("LDAP: 0x%x accepted new LDAP client, but failed to proceed.\n"), LdapConnection);

                // Probably there was something wrong with just this
                // Accept failure. Continue to accept more LDAP connections.
            }
        }

    } else {

        DebugF (_T("LDAP: 0x%x failed to initialize.\n"), LdapConnection);

    }

    LdapConnection -> Release (); 
    
    return Result;
}

HRESULT LDAP_ACCEPT::StartLoopbackNatRedirects (void) {

    NTSTATUS    Status;

    Status = NatCreateDynamicAdapterRestrictedPortRedirect (
        NatRedirectFlagLoopback | NatRedirectFlagSendOnly,
        IPPROTO_TCP,
        htons (LDAP_STANDARD_PORT),
        LdapListenSocketAddress.sin_addr.s_addr,
        LdapListenSocketAddress.sin_port,
        ::NhMapAddressToAdapter (htonl (INADDR_LOOPBACK)),
        MAX_LISTEN_BACKLOG,
        &LoopbackRedirectHandle1);

    if (Status != STATUS_SUCCESS) {
        LoopbackRedirectHandle1 = NULL;

        DebugError (Status, _T("LDAP: Failed to create local dynamic redirect #1.\n"));

        return (HRESULT) Status;
    }

    DebugF (_T ("LDAP: Connections traversing loopback interface to port %04X will be redirected to %08X:%04X.\n"),
                LDAP_STANDARD_PORT,
                ntohl (LdapListenSocketAddress.sin_addr.s_addr),
                ntohs (LdapListenSocketAddress.sin_port));

    Status = NatCreateDynamicAdapterRestrictedPortRedirect (
        NatRedirectFlagLoopback | NatRedirectFlagSendOnly,
        IPPROTO_TCP,
        htons (LDAP_ALTERNATE_PORT),
        LdapListenSocketAddress.sin_addr.s_addr,
        LdapListenSocketAddress.sin_port,
        ::NhMapAddressToAdapter (htonl (INADDR_LOOPBACK)),
        MAX_LISTEN_BACKLOG,
        &LoopbackRedirectHandle2); 

    if (Status != STATUS_SUCCESS) {

        NatCancelDynamicRedirect (LoopbackRedirectHandle1);

        LoopbackRedirectHandle1 = NULL;
        LoopbackRedirectHandle2 = NULL;

        DebugError (Status, _T("LDAP: Failed to create local dynamic redirect #2.\n"));

        return (HRESULT) Status;
    }

    DebugF (_T ("LDAP: Connections traversing loopback interface to port %04X will be redirected to %08X:%04X.\n"),
                LDAP_ALTERNATE_PORT,
                ntohl (LdapListenSocketAddress.sin_addr.s_addr),
                ntohs (LdapListenSocketAddress.sin_port));

    return (HRESULT) Status; 
} 

HRESULT LDAP_ACCEPT::CreateBindSocket (
    void) {

    HRESULT            Result;
    SOCKADDR_IN        SocketAddress;

    SocketAddress.sin_family      = AF_INET;
    SocketAddress.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
    SocketAddress.sin_port        = htons (0);             // request dynamic port

    Result = AsyncAcceptContext.StartIo (
        &SocketAddress,
        AsyncAcceptFunction,
        NULL);

    if (Result != S_OK) {

        DebugError (Result, _T("LDAP: Failed to create and bind socket.\n"));

        return Result;
    }

    DebugF (_T("LDAP: Asynchronous Accept started.\n"));

    Result = AsyncAcceptContext.GetListenSocketAddress (&LdapListenSocketAddress);

    if (Result != S_OK) {

        DebugError (Result, _T("LDAP: Failed to get listen socket address.\n"));

        return Result;
    }

    return S_OK;
}

HRESULT LDAP_ACCEPT::Start (void)
{
    HRESULT        Result;

    Result = CreateBindSocket ();

    if (S_OK == Result) {

        Result = StartLoopbackNatRedirects ();

        if (S_OK == Result) {

            return  S_OK;

        }

        CloseSocket ();
    }

    return Result;
}

void LDAP_ACCEPT::Stop (void) {

    StopLoopbackNatRedirects ();

    CloseSocket ();
}

void LDAP_ACCEPT::StopLoopbackNatRedirects (void) {

    if (LoopbackRedirectHandle1) {

        NatCancelDynamicRedirect (LoopbackRedirectHandle1);

        LoopbackRedirectHandle1 = NULL;

    }

    if (LoopbackRedirectHandle2) {

        NatCancelDynamicRedirect (LoopbackRedirectHandle2);

        LoopbackRedirectHandle2 = NULL;

    }
}

void LDAP_ACCEPT::CloseSocket (void) {

    ZeroMemory ((PVOID)&LdapListenSocketAddress, sizeof (SOCKADDR_IN));

    AsyncAcceptContext.StopWait ();
}

LDAP_BUFFER::LDAP_BUFFER (void) 
{
}

LDAP_BUFFER::~LDAP_BUFFER (void) 
{
}


// LDAP_CODER ---------------------------------------------------------------------

LDAP_CODER::LDAP_CODER (void)
{
    Encoder = NULL;
    Decoder = NULL;

    LDAP_Module_Startup();
}

LDAP_CODER::~LDAP_CODER (void)
{
    Encoder = NULL;
    Decoder = NULL;

    LDAP_Module_Cleanup();
}

DWORD LDAP_CODER::Start (void)
{
    DWORD    Status;
    ASN1error_e    Error;

    Lock();

    Status = ERROR_SUCCESS;

    Error = ASN1_CreateEncoder (LDAP_Module, &Encoder, NULL, 0, NULL);

    if (ASN1_FAILED (Error)) {
        DebugF (_T("LDAP: Failed to initialize LDAP ASN.1 BER encoder, 0x%08X.\n"), Error);
        Encoder = NULL;
        Status = ERROR_GEN_FAILURE;
    }

    Error = ASN1_CreateDecoder (LDAP_Module, &Decoder, NULL, 0, NULL);

    if (ASN1_FAILED (Error)) {
        DebugF (_T("LDAP: Failed to initialize LDAP ASN.1 BER decoder, 0x%08X.\n"), Error);
        Decoder = NULL;
        Status = ERROR_GEN_FAILURE;
    }

    Unlock();

    return Status;
}

void LDAP_CODER::Stop (void)
{
    Lock();

    if (Encoder) {
        ASN1_CloseEncoder (Encoder);
        Encoder = NULL;
    }

    if (Decoder) {
        ASN1_CloseDecoder (Decoder);
        Decoder = NULL;
    }

    Unlock();
}

ASN1error_e LDAP_CODER::Decode (
    IN    LPBYTE    Data,
    IN    DWORD    Length,
    OUT    LDAPMessage **    ReturnPduStructure,
    OUT    DWORD *    ReturnIndex)
{
    ASN1error_e        Error;

    assert (Data);
    assert (ReturnPduStructure);
    assert (ReturnIndex);

    Lock();

    if (Decoder) {

#if DBG
        BerDump (Data, Length);
#endif

        Error = ASN1_Decode (
            Decoder,
            (PVOID *) ReturnPduStructure,
            LDAPMessage_ID,
            ASN1DECODE_SETBUFFER,
            Data,
            Length);

        switch (Error) {
        case    ASN1_SUCCESS:
            // successfully decoded pdu

            *ReturnIndex = Decoder -> len;
            assert (*ReturnPduStructure);

            DebugF (_T("LDAP: Successfully decoded PDU, submitted buffer length %d, used %d bytes.\n"),
                Length,
                *ReturnIndex);

            break;

        case    ASN1_ERR_EOD:
            // not enough data has been accumulated yet

            *ReturnIndex = 0;
            *ReturnPduStructure = NULL;

            DebugF (_T("LDAP: Cannot yet decode PDU, not enough data submitted (%d bytes in buffer).\n"),
                Length);
            break;

        default:
            if (ASN1_FAILED (Error)) {
                DebugF (_T("LDAP: Failed to decode PDU, for unknown reasons, 0x%08X.\n"),
                    Error);
            }
            else {
                DebugF (_T("LDAP: PDU decoded, but with warning code, 0x%08X.\n"),
                    Error);
            
                *ReturnIndex = Decoder -> len;
            }
            break;
        }
    }
    else {
        Debug (_T("LDAP: cannot decode pdu, because decoder was not initialized.\n"));

        Error = ASN1_ERR_INTERNAL;
    }

    Unlock();

    return Error;
} 

// LDAP_PUMP --------------------------------------------------------------

LDAP_PUMP::LDAP_PUMP (
    IN    LDAP_CONNECTION *    ArgConnection,
    IN    LDAP_SOCKET *        ArgSource,
    IN    LDAP_SOCKET *        ArgDest)
{
    assert (ArgConnection);
    assert (ArgSource);
    assert (ArgDest);

    Connection = ArgConnection;
    Source = ArgSource;
    Dest = ArgDest;
    IsPassiveDataTransfer = FALSE;
}

LDAP_PUMP::~LDAP_PUMP (void)
{
}

void LDAP_PUMP::Terminate (void)
{
}

void LDAP_PUMP::Start (void)
{
    Source -> RecvIssue();
}

void LDAP_PUMP::Stop (void)
{
}

// called only by source socket OnRecvComplete
void LDAP_PUMP::OnRecvBuffer (
    IN    LDAP_BUFFER * Buffer)
{
    if (IsActivelyPassingData ()) {

        Connection -> ProcessBuffer (this, Buffer);
    
    } else {
        
        SendQueueBuffer (Buffer);
    }
}

void LDAP_PUMP::OnSendDrain (void)
{
    Source -> RecvIssue();
}

BOOL LDAP_PUMP::CanIssueRecv (void)
{
    return !Dest -> SendOverlapped.IsPending;
}

void LDAP_PUMP::SendQueueBuffer (
    IN    LDAP_BUFFER *    Buffer)
{
    Dest -> SendQueueBuffer (Buffer);
}

void LDAP_PUMP::EncodeSendMessage (
   IN    LDAPMessage *    Message)
{
    LDAP_BUFFER *    Buffer;
    ASN1encoding_t    Encoder;
    ASN1error_e        Error;

    Buffer = new LDAP_BUFFER;
    if (!Buffer) {
        Debug (_T("LDAP: EncodeSendMessage: allocation failure.\n"));
        return;
    }

    Error = ASN1_CreateEncoder (LDAP_Module, &Encoder, NULL, 0, NULL);
    if (ASN1_FAILED (Error)) {
        DebugF (_T("LDAP: EncodeSendMessage: failed to create ASN.1 encoder, error 0x%08X.\n"),
            Error);

        delete Buffer;
        return;
    }

    Error = ASN1_Encode (Encoder, Message, LDAPMessage_ID, ASN1ENCODE_ALLOCATEBUFFER, NULL, 0);
    if (ASN1_FAILED (Error)) {
        DebugF (_T("LDAP: Failed to encode LDAP message, error 0x%08X.\n"), Error);

        ASN1_CloseEncoder (Encoder);
        delete Buffer;
        return;
    }

    if (Buffer -> Data.Grow (Encoder -> len)) {

        memcpy (Buffer -> Data.Data, Encoder -> buf, Encoder -> len);
        Buffer -> Data.Length = Encoder -> len;

        ASN1_FreeEncoded (Encoder, Encoder -> buf);

        SendQueueBuffer (Buffer);
        Buffer = NULL;
    }
    else {

        delete Buffer;
    }

    ASN1_CloseEncoder (Encoder);
}

BOOL    LDAP_PUMP::IsActivelyPassingData (void) const {

    return !IsPassiveDataTransfer;

}

void LDAP_PUMP::StartPassiveDataTransfer (void) {

    IsPassiveDataTransfer = TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\logchan.cpp ===
#include "stdafx.h"
#include "portmgmt.h"
#include "timerval.h"
#include "cbridge.h"

void LOGICAL_CHANNEL::IncrementLifetimeCounter (void)  { GetCallBridge().AddRef (); }
void LOGICAL_CHANNEL::DecrementLifetimeCounter (void) { GetCallBridge().Release (); }

// Code common for both RTP and T.120 logical channels
// Only OpenLogicalChannel and OpenLogicalChannelAck need to
// be handled differently for RTP and T.120 logical channels


HRESULT
LOGICAL_CHANNEL::CreateTimer(DWORD TimeoutValue)
{
    DWORD RetCode;
	
    RetCode = TimprocCreateTimer (TimeoutValue);

    return HRESULT_FROM_WIN32(RetCode);
}

// the event manager tells us about timer expiry via this method
/* virtual */ void 
LOGICAL_CHANNEL::TimerCallback (void)
{
    CALL_BRIDGE *pCallBridge = &GetCallBridge();

    ///////////////////////////////
    //// LOCK the CALL_BRIDGE
    ///////////////////////////////
    pCallBridge->Lock ();

    // Clear the timer - Note that Terminate () will try to
    // cancel all the timers in this CALL_BRIDGE
    TimprocCancelTimer();
    DebugF (_T("LC  : 0x%x cancelled timer.\n"),
         &GetCallBridge ());
    
    // Don't do anything if the CALL_BRIDGE is already terminated.
    if (!pCallBridge->IsTerminated ())
    { 
		// CODE WORK *** TO DO
		// if the current state is LC_STATE_OPEN_RCVD, send close LC PDU to
		// both the source and the destination
    
		// if the current state is LC_STATE_CLOSE_RCVD or 
		// LC_STATE_OPENED_CLOSE_RCVD, send close LC PDU to just
		// the destination
    
		// delete self and remove the pointer from the logical channel array
		DeleteAndRemoveSelf ();
	}
    
    ///////////////////////////////
    //// UNLOCK the CALL_BRIDGE
    ///////////////////////////////
    pCallBridge -> Unlock ();

	pCallBridge -> Release ();

}



HRESULT
LOGICAL_CHANNEL::HandleCloseLogicalChannelPDU(
    IN      MultimediaSystemControlMessage   *pH245pdu
    )
{
	HRESULT HResult = E_FAIL;
	switch(m_LogicalChannelState)
	{
	case LC_STATE_OPEN_RCVD:
	case LC_STATE_OPEN_ACK_RCVD:
		{
#if 0  // 0 ******* Region Commented Out Begins *******
			// start timer, if we don't receive a response in this time,
			// we must close this logical channel
			HResult = CreateTimer(LC_POST_CLOSE_TIMER_VALUE);
			if (FAILED(HResult))
			{
				DebugF( _T("LOGICAL_CHANNEL::HandleCloseLogicalChannelPDU, ")
					_T("couldn't create timer, returning 0x%x\n"),
					HResult));
				return HResult;
			}
#endif // 0 ******* Region Commented Out Ends   *******

			// save the reason for closing the logical channel

			// forward the PDU to the other H245 instance
			HResult = m_pH245Info->GetOtherH245Info().ProcessMessage(pH245pdu);
			if (FAILED(HResult))
			{
				return HResult;
			}
			_ASSERTE(S_OK == HResult);

            // Don't wait for CLCAck. Just CLC is sufficient to delete the
            // logical channel. CLCAck is just forwarded without doing anything.
            // delete self and remove the pointer from the logical channel array
            DeleteAndRemoveSelf();

#if 0  // 0 ******* Region Commented Out Begins *******
			// state trasition
			if (LC_STATE_OPEN_ACK_RCVD == m_LogicalChannelState)
			{
				// we had opened the logical channel
				m_LogicalChannelState = LC_STATE_OPENED_CLOSE_RCVD;
			}
			else
			{
				// the logical channel was never opened
				m_LogicalChannelState = LC_STATE_CLOSE_RCVD;
			}
#endif // 0 ******* Region Commented Out Ends   *******

		}
		break;

	case LC_STATE_CLOSE_RCVD:
	case LC_STATE_OPENED_CLOSE_RCVD:
		{
			return E_INVALIDARG;
		}
		break;

	case LC_STATE_NOT_INIT:
	default:
		{
            _ASSERTE(FALSE);
			return E_UNEXPECTED;
		}
		break;
	};

    return HResult;
}


HRESULT
LOGICAL_CHANNEL::ProcessOpenLogicalChannelRejectPDU(
    IN      MultimediaSystemControlMessage   *pH245pdu
    )
{
    // delete self and remove the pointer from the logical channel array
    DeleteAndRemoveSelf();

    // shouldn't access any members of the logical channel as it may have
    // been destroyed already
	// NOTE: Since we return S_OK, the PDU gets forwarded to the other end

    return S_OK;
}


// Unused.

HRESULT
LOGICAL_CHANNEL::ProcessCloseLogicalChannelAckPDU(
    IN      MultimediaSystemControlMessage   *pH245pdu
    )
{
    DebugF( _T("LOGICAL_CHANNEL::ProcessCloseLogicalChannelAckPDU(&%x) called ")
            _T("m_LogicalChannelState: %d, LCN: %d\n"),
            pH245pdu,
            m_LogicalChannelState, m_LogicalChannelNumber);


    // cancel timer

    // CODEWORK: Make some checks on the PDU and current state ??
    
    // delete self and remove the pointer from the logical channel array
    DeleteAndRemoveSelf();

    // shouldn't access any members of the logical channel as it may have
    // been destroyed already
    DebugF( _T("LOGICAL_CHANNEL::ProcessCloseLogicalChannelAckPDU(&%x) ")
        _T("returning S_OK\n"),
        pH245pdu);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\ldappx.h ===
/*++

Copyright (c) 1998 - 2000  Microsoft Corporation

Module Name:
    ldappx.h

Abstract:
    Declares abstract data types and constants used in LDAP portion of the H.323/LDAP proxy.

    LDAP Proxy is designed as an addition to H.323 proxy. The main purpose of the
    LDAP proxy is to maintain LDAP Address Translation Table, which is used to map
    aliases of H.323 endpoints to their IP addresses. The proxy adds an entry when it
    intercepts an LDAP PDU from a client to directory server, and the PDU matches all
    predefined criteria.

Author(s):          ArlieD, IlyaK   14-Jul-1999

Revision History:
    07/14/1999      File creation                                  Arlie Davis  (ArlieD)
    08/20/1999      Improvement of processing of LDAP              Ilya Kleyman (IlyaK)
                    LDAP SearchRequests
    12/20/1999      Added prediction of receive sizes in           Ilya Kleyman (IlyaK)
                    non-interpretative data transfer mode
    02/20/2000      Added expiration policy of the entries         Ilya Kleyman (IlyaK)
                    in LDAP Address Translation Table
    03/12/2000      Added support for multiple private and         Ilya Kleyman (IlyaK)
                    multiple public interface for RRAS

--*/
#ifndef    __h323ics_ldappx_h
#define    __h323ics_ldappx_h

#define    LDAP_PATH_EQUAL_CHAR    '='
#define    LDAP_PATH_SEP_CHAR      ','

extern BOOLEAN NhIsLocalAddress      (ULONG Address);
extern ULONG   NhMapAddressToAdapter (ULONG Address);

typedef    MessageID    LDAP_MESSAGE_ID;

#define ASN_SEQUENCE_TAG                0x30
#define ASN_LONG_HEADER_BIT             0x80
#define ASN_MIN_HEADER_LEN              2          // This value is fixed

#define LDAP_STANDARD_PORT              389        // Well-known LDAP port
#define LDAP_ALTERNATE_PORT             1002       // Alternate (ILS) LDAP port
#define LDAP_BUFFER_RECEIVE_SIZE        0x400
#define LDAP_BUFFER_MAX_RECV_SIZE       0x80000UL  // Limit on maximum one-time receive size
#define LDAP_MAX_TRANSLATION_TABLE_SIZE 100000     // Maximum number of entries in translation table
#define LDAP_MAX_CONNECTIONS            50000      // Maximum number of concurrent connections through the proxy

// data structures -------------------------------------------------------------------

class    LDAP_SOCKET;
class    LDAP_CONNECTION;

struct   LDAP_TRANSLATION_ENTRY
{
// An entry in the LDAP Address Translation Table is 
// to be identified by three components:
// 1. Registered alias
// 2. Registered address
// 3. Directory server the alias is registered with
// 4. Directory path on the server
// 
// Currently only first three are used.
// 
    ANSI_STRING  Alias;                // Memory owned, use FreeAnsiString
    ANSI_STRING  DirectoryPath;        // Memory owned, use FreeAnsiString
    ANSI_STRING  CN;                   // Subset of DirectoryPath, NOT owned, do NOT free
    IN_ADDR      ClientAddress;
    SOCKADDR_IN  ServerAddress;
    DWORD        TimeStamp;            // In seconds, since the last machine reboot

    void    
    FreeContents (
        void
        )
    {
        FreeAnsiString (&Alias);
        FreeAnsiString (&DirectoryPath);

        CN.Buffer = NULL;
    }

    HRESULT 
    IsRegisteredViaInterface (
        IN DWORD InterfaceAddress,     // host order
        OUT BOOL *Result
        );
};

class    LDAP_TRANSLATION_TABLE :
public    SIMPLE_CRITICAL_SECTION_BASE
{
// LDAP Address Translation Table is a serialized 
// container for translation entries. The Table
// can conduct various types of searches, and has
// an expiration policy on old entries. The expiration
// is done by means of a periodic timer thread and
// timestamps on each entry. Entries are added when
// successful AddResponses are received in reply to
// valid AddRequests. Entries are refreshed when
// successful refresh SearchResponses are received for
// valid refresh SearchRequests (for NetMeeting); or when
// successful refresh ModifyResponses are received for
// valid refresh ModifyRequests (for Phone Dialer).
private:

    DYNAMIC_ARRAY <LDAP_TRANSLATION_ENTRY>        Array;
    HANDLE                  GarbageCollectorTimerHandle;
    BOOL                    IsEnabled;

private:

    HRESULT
    InsertEntryLocked (
        IN  ANSI_STRING * Alias,
        IN  ANSI_STRING * DirectoryPath,
        IN  IN_ADDR       ClientAddress,
        IN  SOCKADDR_IN * ServerAddress,
        IN  DWORD         TimeToLive    // in seconds
        );

    HRESULT
    FindEntryByPathServer (
        IN  ANSI_STRING * DirectoryPath,
        IN  SOCKADDR_IN * ServerAddress,
        OUT LDAP_TRANSLATION_ENTRY ** ReturnTranslationEntry
        );

    HRESULT    FindEntryByAliasServer (
        IN  ANSI_STRING * Alias,
        IN  SOCKADDR_IN * ServerAddress,
        OUT LDAP_TRANSLATION_ENTRY ** ReturnTranslationEntry
        );

public:

    LDAP_TRANSLATION_TABLE (
        void
        );

    ~LDAP_TRANSLATION_TABLE (
        void
        );

    HRESULT 
    Start (
        void
        );

    void 
    Stop (
        void
        );

#if DBG
    void 
    PrintTable (
        void
        );
#endif

#define LDAP_TRANSLATION_TABLE_GARBAGE_COLLECTION_PERIOD    (10 * 60 * 1000)   // Milliseconds
#define LDAP_TRANSLATION_TABLE_ENTRY_INITIAL_TIME_TO_LIVE   (10 * 60)          // Seconds

    static
    void
    GarbageCollectorCallback (
        IN PVOID Context,
        IN BOOLEAN TimerOrWaitFired
        );

    HRESULT
    RefreshEntry (
        IN ANSI_STRING * Alias,
        IN ANSI_STRING * DirectoryPath,
        IN IN_ADDR       ClientAddress,
        IN SOCKADDR_IN * ServerAddress,
        IN DWORD         TimeToLive
        );

    void
    RemoveOldEntries (
        void
        );

    HRESULT
    QueryTableByAlias (
        IN  ANSI_STRING * Alias,
        OUT IN_ADDR     * ReturnClientAddress
        );

    HRESULT
    QueryTableByCN (
        IN  ANSI_STRING * CN,
        OUT IN_ADDR     * ReturnClientAddress
        );

    HRESULT
    QueryTableByAliasServer (
        IN  ANSI_STRING * Alias,
        IN  SOCKADDR_IN * ServerAddress,
        OUT IN_ADDR     * ReturnClientAddress
        );

    HRESULT
    QueryTableByCNServer (
        IN  ANSI_STRING * CN,
        IN  SOCKADDR_IN * ServerAddress,
        OUT IN_ADDR     * ReturnClientAddress
        );

    HRESULT
    InsertEntry (
        IN  ANSI_STRING * Alias,
        IN  ANSI_STRING * DirectoryPath,
        IN  IN_ADDR       ClientAddress,
        IN  SOCKADDR_IN * ServerAddress,
        IN  DWORD         TimeToLive        // in seconds
        );

    HRESULT 
    RemoveEntry (
        IN  SOCKADDR_IN * ServerAddress,
        IN  ANSI_STRING * DirectoryPath
        );

    HRESULT 
    RemoveEntryByAliasServer (
        IN  ANSI_STRING * Alias,
        IN  SOCKADDR_IN * ServerAddress
        );

    void 
    OnInterfaceShutdown (
        IN DWORD          InterfaceAddress
        );

    BOOL  
    ReachedMaximumSize (
        void
        );
};


class    LDAP_BUFFER
{
// LDAP_BUFFER is a simple structure
// that can hold raw data and be chained
// to other LDAP_BUFFERs
public:
    LDAP_BUFFER (
        void
        );

    ~LDAP_BUFFER (
        void
        );

public:
    DYNAMIC_ARRAY <BYTE>  Data;
    LIST_ENTRY            ListEntry;
};

enum NOTIFY_REASON
{
    SOCKET_SEND_COMPLETE,
    SOCKET_RECEIVE_COMPLETE,
};

struct LDAP_OVERLAPPED
{
    OVERLAPPED    Overlapped;
    BOOL          IsPending;
    DWORD         BytesTransferred;
    LDAP_SOCKET * Socket;
};

class LDAP_PUMP
{
    friend    class    LDAP_CONNECTION;
    friend    class    LDAP_SOCKET;

private:
    LDAP_CONNECTION * Connection;
    LDAP_SOCKET     * Source;
    LDAP_SOCKET     * Dest;
    // When set, the pump works in raw data
    // transfer mode without modifications to
    // the payload
    BOOL              IsPassiveDataTransfer;

public:
    LDAP_PUMP (
        IN    LDAP_CONNECTION * ArgConnection,
        IN    LDAP_SOCKET     * ArgSource,
        IN    LDAP_SOCKET     * ArgDest
        );

    ~LDAP_PUMP (
        void
        );

    void Start (
        void
        );

    void Stop  (
        void
        );

    // source is indicating that it has received data
    void
    OnRecvBuffer (
        LDAP_BUFFER *
        );

    // destination is indicating that it has finished sending data
    void 
    OnSendDrain (
        void
        );

    void  
    SendQueueBuffer (
        IN  LDAP_BUFFER * Buffer
        );

    BOOL    
    CanIssueRecv (
        void
        );

    void
    Terminate (
        void
        );

    void 
    EncodeSendMessage (
        IN LDAPMessage * Message
        );

    void 
    StartPassiveDataTransfer (
        void
        );

    BOOL IsActivelyPassingData (
        void
        ) const;
};

class    LDAP_SOCKET
{
// LDAP_SOCKET is a wrapper class
// around Windows asynchrounous socket.
// An instance of LDAP_SOCKET can 
// asynchronously connect, send and receive

    friend class LDAP_CONNECTION;
    friend class LDAP_PUMP;

public:
    enum STATE {
        STATE_NONE,
        STATE_ISSUING_CONNECT,
        STATE_CONNECT_PENDING,
        STATE_CONNECTED,
        STATE_TERMINATED,
    };


private:

    SOCKADDR_IN          ActualDestinationAddress;
    SOCKADDR_IN          RealSourceAddress;

    BOOL                 IsNatRedirectActive;

    LDAP_CONNECTION    * LdapConnection;
    LDAP_PUMP          * RecvPump;
    LDAP_PUMP          * SendPump;
    SOCKET               Socket;
    STATE                State;

    // receive state
    LDAP_OVERLAPPED      RecvOverlapped;
    LDAP_BUFFER *        RecvBuffer;             // must be valid if RecvOverlapped.IsPending, must be null otherwise
    DWORD                RecvFlags;
    LIST_ENTRY           RecvBufferQueue;        // contains LDAP_BUFFER.ListEntry
    DWORD                BytesToReceive;
    SAMPLE_PREDICTOR <5> RecvSizePredictor;

    // send stat
    LDAP_OVERLAPPED      SendOverlapped;
    LDAP_BUFFER *        SendBuffer;             // must be valid if SendOverlapped.IsPending, must be null otherwise
    LIST_ENTRY           SendBufferQueue;        // contains LDAP_BUFFER.ListEntry

    // async connect state
    HANDLE               ConnectEvent;
    HANDLE               ConnectWaitHandle;
    BOOL                 AttemptAnotherConnect;

private:

    inline 
    void 
    Lock (
        void
        );

    inline 
    void 
    Unlock (
        void
        );

    inline 
    void 
    AssertLocked (
        void
        );

    void 
    OnConnectCompletionLocked (
        void
        );

    void 
    FreeConnectResources (
        void
        );

    HRESULT 
    AttemptAlternateConnect (
        void
        );

    void 
    OnIoComplete (
        IN  DWORD Status, 
        IN  DWORD BytesTransferred,
        IN  LDAP_OVERLAPPED *
        );

    void 
    OnRecvComplete (
        IN  DWORD Status
        );

    void
    OnSendComplete (
        IN  DWORD Status
        );

    void
    RecvBuildBuffer (
        IN  LPBYTE Data,
        IN  DWORD  Length
        );

    void DeleteBufferList (
        IN  LIST_ENTRY * ListHead
        );

    BOOL RecvRemoveBuffer (
        OUT LDAP_BUFFER ** ReturnBuffer
        );

    // returns TRUE if a message was dequeued
    BOOL SendNextBuffer (
        void
        );

public:

    LDAP_SOCKET (
        IN  LDAP_CONNECTION * ArgLdapConnection,
        IN  LDAP_PUMP       * ArgRecvPump,
        IN  LDAP_PUMP       * ArgSendPump
        );

    ~LDAP_SOCKET (
        void
        );

    HRESULT 
    RecvIssue (
        void
        );

    // may queue the buffer
    void
    SendQueueBuffer(
        IN LDAP_BUFFER * Buffer
        );

    static
    void
    IoCompletionCallback (
        IN DWORD Status,
        IN DWORD Length,
        IN LPOVERLAPPED Overlapped
        );

    static 
    void 
    OnConnectCompletion (
        IN PVOID Context,
        IN BOOLEAN TimerOrWaitFired
        );

    HRESULT 
    AcceptSocket (
        IN SOCKET LocalClientSocket
        );

    HRESULT 
    IssueConnect (
        IN SOCKADDR_IN * DestinationAddress
        );

    void
    OnIoCompletion  (
        IN LDAP_BUFFER * Message,
        IN DWORD Status,
        IN DWORD BytesTransferred
        );

    void 
    Terminate (
        void
        );

    STATE
    GetState (void) {

        AssertLocked ();

        return State;
    }

    // retrieve the remote address of the connection
    BOOL 
    GetRemoteAddress (
        OUT SOCKADDR_IN * ReturnAddress
        );

    // retrieve the local address of the connection
    BOOL    
    GetLocalAddress (
        OUT SOCKADDR_IN * ReturnAddress
        );
};


// this represents a single outstanding operation that the client has initiated.

enum    LDAP_OPERATION_TYPE
{
    LDAP_OPERATION_ADD,
    LDAP_OPERATION_SEARCH,
    LDAP_OPERATION_MODIFY,
    LDAP_OPERATION_DELETE,
};

struct    LDAP_OPERATION
{
// LDAP_OPERATIONs are created and queued when 
// a client issues a request to the server.
// The actual processing of the operation
// starts when server sends back response
// with data and/or status code.

    LDAP_MESSAGE_ID MessageID;
    DWORD           Type;
    ANSI_STRING     DirectoryPath;            // owned by process heap
    ANSI_STRING     Alias;                    // owned by process heap
    IN_ADDR         ClientAddress;
    SOCKADDR_IN     ServerAddress;
    DWORD           EntryTimeToLive;          // in seconds

    void 
    FreeContents (
        void
        )
    {

        FreeAnsiString (&DirectoryPath);

        FreeAnsiString (&Alias);
    }
};


class  LDAP_CONNECTION :
public SIMPLE_CRITICAL_SECTION_BASE,
public LIFETIME_CONTROLLER
{
// LDAP_CONNECTION represents two parts
// (public and private) of the connection
// being proxied by the LDAP proxy. In reflection
// of this it has easily distinguishable Server
// part and Client part
    friend class LDAP_SOCKET;

public:

    enum    STATE {
        STATE_NONE,
        STATE_CONNECT_PENDING,
        STATE_CONNECTED,
        STATE_TERMINATED,
    };

    LIST_ENTRY     ListEntry;

private:

    LDAP_SOCKET    ClientSocket;
    LDAP_SOCKET    ServerSocket;
    DWORD          SourceInterfaceAddress;      // address of the interface on which the conection was accepted, host order
    DWORD          DestinationInterfaceAddress; // address of the interface on which the conection was accepted, host order
    SOCKADDR_IN    SourceAddress;               // address of the source (originator of the connection)
    SOCKADDR_IN    DestinationAddress;          // address of the destination (recipeint of the connection)

    LDAP_PUMP      PumpClientToServer;
    LDAP_PUMP      PumpServerToClient;

    STATE          State;

    DYNAMIC_ARRAY <LDAP_OPERATION>    OperationArray;

private:

    void 
    StartIo (
        void
        );

    BOOL 
    ProcessLdapMessage (
        IN  LDAP_PUMP             * Pump,
        IN  LDAPMessage           * LdapMessage
        );

    // client to server messages

    BOOL    
    ProcessAddRequest (
        IN  LDAPMessage           * Message
        );

    BOOL 
    ProcessModifyRequest (
        IN  LDAP_MESSAGE_ID         MessageID,
        IN  ModifyRequest         * Request
        );

    BOOL 
    ProcessDeleteRequest (
        IN  LDAP_MESSAGE_ID         MessageID,
        IN  DelRequest            * Request
        );

    BOOL 
    ProcessSearchRequest (
        IN  LDAPMessage           * Message
        );

    // server to client messages

    void  
    ProcessAddResponse (
        IN  LDAPMessage           * Response
        );

    void    
    ProcessModifyResponse (
        IN  LDAP_MESSAGE_ID         MessageID,
        IN  ModifyResponse        * Response
        );

    void    
    ProcessDeleteResponse (
        IN  LDAP_MESSAGE_ID         MessageID,
        IN  DelResponse           * Response
        );

    BOOL    
    ProcessSearchResponse (
        IN  LDAPMessage           * Message
        );

    BOOL    
    FindOperationIndexByMessageID (
        IN  LDAP_MESSAGE_ID         MessageID,
        OUT DWORD                 * ReturnIndex
        );

    BOOL    
    FindOperationByMessageID    (
        IN  LDAP_MESSAGE_ID         MessageID,
        OUT LDAP_OPERATION       ** ReturnOperation
        );

    static 
    INT 
    BinarySearchOperationByMessageID (
        IN  const LDAP_MESSAGE_ID * SearchKey,
        IN  const LDAP_OPERATION  * Comparand
        );

    HRESULT    
    CreateOperation (
        IN  LDAP_OPERATION_TYPE     Type,
        IN  LDAP_MESSAGE_ID         MessageID,
        IN  ANSI_STRING           * DirectoryPath,
        IN  ANSI_STRING           * Alias,
        IN  IN_ADDR                 ClientAddress,
        IN  SOCKADDR_IN           * ServerAddress,
        IN  DWORD                   EntryTimeToLive // in seconds
        );

public:
    LDAP_CONNECTION (
        IN NAT_KEY_SESSION_MAPPING_EX_INFORMATION * RedirectInformation
        );

    ~LDAP_CONNECTION (
        void
        );

    HRESULT 
    Initialize (
        IN NAT_KEY_SESSION_MAPPING_EX_INFORMATION * RedirectInformation
        );

    HRESULT 
    InitializeLocked (
        IN NAT_KEY_SESSION_MAPPING_EX_INFORMATION * RedirectInformation
        );

    HRESULT 
    AcceptSocket (
        IN  SOCKET                  Socket,
        IN  SOCKADDR_IN           * LocalAddress,
        IN  SOCKADDR_IN           * RemoteAddress,
        IN  SOCKADDR_IN           * ArgActualDestinationAddress
        );

    // process a given LDAP message buffer
    // in the context of a given pump (direction)
    void 
    ProcessBuffer (
        IN  LDAP_PUMP             * Pump,
        IN  LDAP_BUFFER           * Buffer
        );

    void 
    OnStateChange (
        IN LDAP_SOCKET            * NotifyingSocket,
        IN LDAP_SOCKET::STATE       NewState
        );

    void 
    Terminate (
        void
        );

    void 
    TerminateExternal (
        void
        );

    BOOL 
    IsConnectionThrough (
        IN DWORD InterfaceAddress   // host order
        );

    // safe, external version
    STATE    
    GetState (
        void
        )
    {
        STATE    ReturnState;

        Lock ();

        ReturnState = State;

        Unlock ();

        return ReturnState;
    }
};

DECLARE_SEARCH_FUNC_CAST (LDAP_MESSAGE_ID, LDAP_OPERATION);

inline 
void 
LDAP_SOCKET::Lock (
    void
    )
{ 
    LdapConnection -> Lock ();
}

inline 
void 
LDAP_SOCKET::Unlock (
    void
    ) 
{ 
    LdapConnection -> Unlock ();      
}

inline 
void 
LDAP_SOCKET::AssertLocked (
    void
    ) 
{ 
    LdapConnection -> AssertLocked(); 
}

class   LDAP_CONNECTION_ARRAY :
public  SIMPLE_CRITICAL_SECTION_BASE {

private:

    // Contains set/array of LDAP_CONNECTION references
    DYNAMIC_ARRAY <LDAP_CONNECTION *> ConnectionArray;

    // Controls whether or not the structure will accept
    // new LDAP connections
    BOOL IsEnabled;

public:

    LDAP_CONNECTION_ARRAY (void);

    HRESULT 
    InsertConnection (
        IN LDAP_CONNECTION * LdapConnection
        );

    void  
    RemoveConnection (
        IN LDAP_CONNECTION * LdapConnection
        );

    void 
    OnInterfaceShutdown (
        IN DWORD InterfaceAddress // host order
        );

    void 
    Start (
        void
        );

    void 
    Stop (
        void
        );

};

class    LDAP_ACCEPT
{

private:

    // Contain accept context
    ASYNC_ACCEPT                    AsyncAcceptContext;

    // Handles for dynamic redirects from the standard and
    // alternate LDAP ports to the selected loopback port
    HANDLE                          LoopbackRedirectHandle1;
    HANDLE                          LoopbackRedirectHandle2;

private:

    HRESULT 
    CreateBindSocket (
        void
        );

    HRESULT 
    StartLoopbackNatRedirects (
        void
        );

    void 
    StopLoopbackNatRedirects (
        void
        );

    void 
    CloseSocket (
        void
        );

    static 
    void 
    AsyncAcceptFunction (
        IN  PVOID         Context,
        IN  SOCKET        Socket,
        IN  SOCKADDR_IN * LocalAddress,
        IN  SOCKADDR_IN * RemoteAddress
        );

    static
    HRESULT 
    LDAP_ACCEPT::AsyncAcceptFunctionInternal (
        IN    PVOID         Context,
        IN    SOCKET        Socket,
        IN    SOCKADDR_IN * LocalAddress,
        IN    SOCKADDR_IN * RemoteAddress
        );

public:

    LDAP_ACCEPT (
        void
        );

    HRESULT 
    Start (
        void
        );

    void 
    Stop(
        void
        );
};

class    LDAP_CODER :
public    SIMPLE_CRITICAL_SECTION_BASE
{
private:
    ASN1encoding_t                  Encoder;
    ASN1decoding_t                  Decoder;

public:
    LDAP_CODER  (
        void
        );

    ~LDAP_CODER (
        void
        );

    DWORD 
    Start (
        void
        );

    void 
    Stop (
        void
        );

    ASN1error_e Decode (
        IN  LPBYTE                  Data,
        IN  DWORD                   Length,
        OUT LDAPMessage          ** ReturnPduStructure,
        OUT DWORD                 * ReturnIndex
        );
};

struct    LDAP_PATH_ELEMENTS
{
    ANSI_STRING        CN;
    ANSI_STRING        C;
    ANSI_STRING        O;
    ANSI_STRING        ObjectClass;
};

struct    LDAP_OBJECT_NAME_ELEMENTS
{
    ANSI_STRING        CN;
    ANSI_STRING        O;
    ANSI_STRING        OU;
};

extern SYNC_COUNTER                 LdapSyncCounter;
extern LDAP_CONNECTION_ARRAY        LdapConnectionArray;
extern LDAP_TRANSLATION_TABLE       LdapTranslationTable;
extern LDAP_CODER                   LdapCoder;
extern LDAP_ACCEPT                  LdapAccept;
extern SOCKADDR_IN                  LdapListenSocketAddress;
extern DWORD                        EnableLocalH323Routing;

HRESULT 
LdapQueryTableByAlias (
  IN  ANSI_STRING               * Alias,
  OUT DWORD                     * ReturnClientAddress   // host order
    );

HRESULT 
LdapQueryTableByAliasServer (
  IN  ANSI_STRING               * Alias,
  IN  SOCKADDR_IN               * ServerAddress,
  OUT DWORD                     * ReturnClientAddress); // host order


#if    DBG
void 
LdapPrintTable (
    void
    );
#endif //    DBG

#endif // __h323ics_ldappx_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\logchan.h ===
#ifndef __h323ics_logchan_h
#define __h323ics_logchan_h

// This decides the maximum number of T120 TCP/IP Connections
// to be allowed. We create so many NAT redirects.
#define MAX_T120_TCP_CONNECTIONS_ALLOWED 5

// Logical channel states. These are
// H245 related but there is one per
// logical channel
// NOTE: there is no enum value for the final closed state
// as the logical channel is destroyed when that state is reached
enum LOGICAL_CHANNEL_STATE
{
    LC_STATE_NOT_INIT = 0,
    LC_STATE_OPEN_RCVD,
    LC_STATE_OPEN_ACK_RCVD,
    LC_STATE_CLOSE_RCVD,
    LC_STATE_OPENED_CLOSE_RCVD
};


// Media Types of the logical channels

enum MEDIA_TYPE
{
    MEDIA_TYPE_UNDEFINED    = 0,
    MEDIA_TYPE_RTP          = 0x1000,
    MEDIA_TYPE_T120         = 0x2000,
    MEDIA_TYPE_AUDIO        = MEDIA_TYPE_RTP  | 0x1, //0x1001
    MEDIA_TYPE_VIDEO        = MEDIA_TYPE_RTP  | 0x2, //0x1002
    MEDIA_TYPE_DATA         = MEDIA_TYPE_T120 | 0x1, //0x2000
};

inline BOOL IsMediaTypeRtp(MEDIA_TYPE MediaType)
{
    return (MediaType & MEDIA_TYPE_RTP);
}

inline BOOL IsMediaTypeT120(MEDIA_TYPE MediaType)
{
    return (MediaType & MEDIA_TYPE_T120);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Logical Channel                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


// This is an abstract base class which defines the operations
// for different types of logical channels.
// RTP_LOGICAL_CHANNEL and T120_LOGICAL_CHANNEL are derived from
// this class.

// Only OpenLogicalChannel and OpenLogicalChannelAck PDUs need
// to be handled differently for the RTP and T.120 Logical channels
// So all the other methods are defined in this class.

class LOGICAL_CHANNEL :
    public TIMER_PROCESSOR
{
    
public:

    inline LOGICAL_CHANNEL();

    HRESULT CreateTimer(DWORD TimeoutValue);

    // the event manager tells us about timer expiry via this method
    virtual void TimerCallback();

    virtual HRESULT HandleCloseLogicalChannelPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    // This is a pure virtual function which is different
    // for the RTP and T.120 logical channels.
    virtual HRESULT ProcessOpenLogicalChannelAckPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        )= 0;

    virtual HRESULT ProcessOpenLogicalChannelRejectPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    virtual HRESULT ProcessCloseLogicalChannelAckPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    // releases any pending associations
    virtual ~LOGICAL_CHANNEL();

    inline BYTE GetSessionId();

    inline WORD GetLogicalChannelNumber();

    inline MEDIA_TYPE GetMediaType();

    inline LOGICAL_CHANNEL_STATE GetLogicalChannelState();
    
	void IncrementLifetimeCounter  (void);
	void DecrementLifetimeCounter (void);

protected:

    // Initializes member variables
    inline void InitLogicalChannel(
        IN H245_INFO               *pH245Info,
        IN MEDIA_TYPE               MediaType,
        IN WORD                     LogicalChannelNumber,
        IN BYTE                     SessionId,
        IN LOGICAL_CHANNEL_STATE    LogicalChannelState
        );
    
    // returns a reference to the source H245 info
    inline H245_INFO &GetH245Info();

    inline CALL_BRIDGE &GetCallBridge();

    inline void DeleteAndRemoveSelf();

    // the logical channel belongs to this H245 channel
    // this supplies the ip addresses needed for NAT redirect
    H245_INFO *m_pH245Info;

    // handle for any active timers
    // TIMER_HANDLE m_TimerHandle;

    // state of the logical channel
    LOGICAL_CHANNEL_STATE   m_LogicalChannelState;

    // logical channel number
    // cannot be 0 as that is reserved for the h245 channel
    WORD    m_LogicalChannelNumber;

    // The type of the media (currently Audio/Video/Data)
    MEDIA_TYPE m_MediaType;

    // session id - this is used to associate with a 
    // logical  channel from the other end if any
    BYTE    m_SessionId;

}; // class LOGICAL_CHANNEL

inline 
LOGICAL_CHANNEL::LOGICAL_CHANNEL(
    )
{
    InitLogicalChannel(NULL, MEDIA_TYPE_UNDEFINED,
                       0,0,LC_STATE_NOT_INIT);
}

inline 
LOGICAL_CHANNEL::~LOGICAL_CHANNEL(
    )
{}

inline void
LOGICAL_CHANNEL::InitLogicalChannel(
    IN H245_INFO               *pH245Info,
    IN MEDIA_TYPE               MediaType,
    IN WORD                     LogicalChannelNumber,
    IN BYTE                     SessionId,
    IN LOGICAL_CHANNEL_STATE    LogicalChannelState
    )
{
    m_pH245Info             = pH245Info;
    m_MediaType             = MediaType;
    m_LogicalChannelNumber  = LogicalChannelNumber;
    m_SessionId             = SessionId;
    m_LogicalChannelState   = LogicalChannelState;
}


inline BYTE 
LOGICAL_CHANNEL::GetSessionId(
    )
{
    return m_SessionId;
}

inline WORD 
LOGICAL_CHANNEL::GetLogicalChannelNumber(
    )
{
    return m_LogicalChannelNumber;
}

inline MEDIA_TYPE 
LOGICAL_CHANNEL::GetMediaType(
    )
{

    return m_MediaType;
}

inline LOGICAL_CHANNEL_STATE 
LOGICAL_CHANNEL::GetLogicalChannelState(
    )
{
    return m_LogicalChannelState;
}

// returns a reference to the source H245 info
inline H245_INFO &
LOGICAL_CHANNEL::GetH245Info(
    )
{
    _ASSERTE(NULL != m_pH245Info);
    return *m_pH245Info;
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// RTP Logical Channel                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


class RTP_LOGICAL_CHANNEL :
    public LOGICAL_CHANNEL
{
public:

    inline RTP_LOGICAL_CHANNEL();

    // all of these are available in the OPEN LOGICAL CHANNEL message
    // except the associated logical channel, which if supplied provides
    // the member m_Own*RTP/RTCP Ports. If not, these are allocated.
    // the association is implied by a matching session id in a logical
    // channel in the other call state
    // it modifies the RTCP address information in the OLC PDU
    // and passes it on to the other H245 instance for forwarding.
    HRESULT HandleOpenLogicalChannelPDU(
        IN H245_INFO                            &H245Info,
        IN MEDIA_TYPE                           MediaType,
        IN DWORD                                LocalIPv4Address,
        IN DWORD                                RemoteIPv4Address,
        IN DWORD                                OtherLocalIPv4Address,
        IN DWORD                                OtherRemoteIPv4Address,
        IN WORD                                 LogicalChannelNumber,
        IN BYTE                                 SessionId,
        IN RTP_LOGICAL_CHANNEL                  *pAssocLogicalChannel,
		IN DWORD								SourceRTCPIPv4Address,
		IN WORD									SourceRTCPPort,
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    virtual HRESULT ProcessOpenLogicalChannelAckPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    // releases any pending associations
    virtual ~RTP_LOGICAL_CHANNEL();

    inline DWORD GetSourceRTCPIPv4Address();

    inline WORD GetSourceRTCPPort();

    inline WORD GetOwnSourceSendRTCPPort();

    inline WORD GetOwnSourceRecvRTCPPort();

    inline WORD GetOwnSourceRecvRTPPort();

    inline WORD GetOwnDestSendRTCPPort();

    inline WORD GetOwnDestRecvRTCPPort();

    inline WORD GetOwnDestSendRTPPort();

    inline DWORD GetDestRTCPIPv4Address();

    inline WORD GetDestRTCPPort();

    inline DWORD GetDestRTPIPv4Address();

    inline WORD GetDestRTPPort();


protected:

    // points to the associated logical channel from the other end if any
    // non-NULL iff associated
    // need to ensure that the AssocLogicalChannel also points
    // to this logical channel
    // CODEWORK: Do assertion checks for this condition.
    RTP_LOGICAL_CHANNEL *m_pAssocLogicalChannel;

    // local and remote addresses for the h245 instance this logical
    // channel is associated with (source side)
    DWORD   m_OwnSourceIPv4Address;
    DWORD   m_SourceIPv4Address;

    // local and remote addresses for the other h245 instance 
    // (dest side)
    DWORD   m_OwnDestIPv4Address;
    DWORD   m_DestIPv4Address;

    // these ports are negotiated in h245 OpenLogicalChannel and
    // OpenLogicalChannelAck. They are given to NAT for redirecting
    // RTP and RTCP traffic
    // while the RTP packets flow only one way (source->dest), RTCP
    // packets flow both ways

    // we only know the source's receive RTCP port. the send port
    // is not known
    DWORD   m_SourceRTCPIPv4Address;
    WORD    m_SourceRTCPPort;

    // these are the send/recv RTP/RTCP ports on the interface that 
    // communicates with the source. since we don't deal with the
    // reverse RTP stream, we don't need a send RTP port
    WORD    m_OwnSourceSendRTCPPort;
    WORD    m_OwnSourceRecvRTCPPort;
    WORD    m_OwnSourceRecvRTPPort;

    // these are the send/recv RTP/RTCP ports on the interface that 
    // communicates with the source. since we don't deal with the
    // reverse RTP stream, we don't need a recv RTP port
    WORD    m_OwnDestSendRTCPPort;
    WORD    m_OwnDestSendRTPPort;
    WORD    m_OwnDestRecvRTCPPort;

    WORD    m_OwnAssocLCRecvRTPPort; // this is used to allocate consecutive
                                     // ports for RTP/RTCP.
    WORD    m_OwnAssocLCSendRTPPort;
    
    // destination's RTCP ip address, port
    DWORD   m_DestRTCPIPv4Address;
    WORD    m_DestRTCPPort;

    // destination's RTP ip address, port
    DWORD   m_DestRTPIPv4Address;
    WORD    m_DestRTPPort;


    // SetAssociationRef, ResetAssociationRef methods can be accessed
    // by other LOGICAL_CHANNEL instances but not by other instances of
    // classes that are not derived from LOGICAL_CHANNEL

    inline void SetAssociationRef(
        IN RTP_LOGICAL_CHANNEL &LogicalChannel
        );

    inline void ResetAssociationRef();

    inline void ReleaseAssociationAndPorts();

private:
    
    // set the RTP and RTCP ports. if there is an associated channel,
    // we must share the RTCP ports
    HRESULT SetPorts();

    HRESULT CheckOpenLogicalChannelAckPDU(
        IN  MultimediaSystemControlMessage  &H245pdu,
        OUT BYTE                            &SessionId,
        OUT DWORD                           &DestRTPIPv4Address,
        OUT WORD                            &DestRTPPort,
        OUT DWORD                           &DestRTCPIPv4Address,
        OUT WORD                            &DestRTCPPort
        );

    // opens the forward RTP, forward RTCP and reverse RTCP streams
    HRESULT OpenNATMappings();

    // closes any NAT mappings
    void CloseNATMappings();
};

inline 
RTP_LOGICAL_CHANNEL::RTP_LOGICAL_CHANNEL(
    )
    : m_pAssocLogicalChannel(NULL),
      //m_TimerHandle(NULL),
      m_OwnSourceIPv4Address(0),
      m_SourceIPv4Address(0),
      m_OwnDestIPv4Address(0),
      m_DestIPv4Address(0),
      m_SourceRTCPIPv4Address(0),
      m_SourceRTCPPort(0),
      m_OwnSourceSendRTCPPort(0),
      m_OwnSourceRecvRTCPPort(0),
      m_OwnSourceRecvRTPPort(0),
      m_OwnDestSendRTCPPort(0),
      m_OwnDestRecvRTCPPort(0),
      m_OwnDestSendRTPPort(0),
      m_DestRTCPIPv4Address(0),
      m_DestRTCPPort(0),
      m_DestRTPIPv4Address(0),
      m_DestRTPPort(0)
{
    InitLogicalChannel(NULL, MEDIA_TYPE_UNDEFINED,
                       0,0,LC_STATE_NOT_INIT);
}

inline void 
RTP_LOGICAL_CHANNEL::SetAssociationRef(
    IN RTP_LOGICAL_CHANNEL &LogicalChannel
    )
{
    // if the source or dest terminal is generating two logical
    // channels (in the same direction) with the same session id, we'll
    // find a prior logical channel in the array with the same session id
    // and thus never reach here
    _ASSERTE(NULL == m_pAssocLogicalChannel);
    m_pAssocLogicalChannel = &LogicalChannel;
}

inline void 
RTP_LOGICAL_CHANNEL::ResetAssociationRef(
    )
{
    _ASSERTE(NULL != m_pAssocLogicalChannel);
    m_pAssocLogicalChannel = NULL;

    // we, now, own the RTP/RTCP ports that were being shared so far
}

inline DWORD 
RTP_LOGICAL_CHANNEL::GetSourceRTCPIPv4Address(
    )
{
    return m_SourceRTCPIPv4Address;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetSourceRTCPPort(
    )
{
    return m_SourceRTCPPort;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetOwnSourceSendRTCPPort(
    )
{
    return m_OwnSourceSendRTCPPort;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetOwnSourceRecvRTCPPort(
    )
{
    return m_OwnSourceRecvRTCPPort;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetOwnSourceRecvRTPPort(
    )
{
    return m_OwnSourceRecvRTPPort;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetOwnDestSendRTCPPort(
    )
{
    return m_OwnDestSendRTCPPort;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetOwnDestRecvRTCPPort(
    )
{
    return m_OwnDestRecvRTCPPort;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetOwnDestSendRTPPort(
    )
{
    return m_OwnDestSendRTPPort;
}


inline DWORD 
RTP_LOGICAL_CHANNEL::GetDestRTCPIPv4Address(
    )
{
    return m_DestRTCPIPv4Address;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetDestRTCPPort(
    )
{
    return m_DestRTCPPort;
}

inline DWORD 
RTP_LOGICAL_CHANNEL::GetDestRTPIPv4Address(
    )
{
    return m_DestRTPIPv4Address;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetDestRTPPort(
    )
{
    return m_DestRTPPort;
}




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// T.120 Logical Channel                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


class T120_LOGICAL_CHANNEL :
    public LOGICAL_CHANNEL
{
public:

    inline T120_LOGICAL_CHANNEL();

    // all of these are available in the OPEN LOGICAL CHANNEL message
    // it modifies the OLC PDU and passes it on to the other H245
    // instance for forwarding ???
    HRESULT HandleOpenLogicalChannelPDU(
        IN H245_INFO                            &H245Info,
        IN MEDIA_TYPE                           MediaType,
        IN WORD                                 LogicalChannelNumber,
        IN BYTE                                 SessionId,
        IN DWORD                                T120ConnectToIPAddr,
        IN WORD                                 T120ConnectToPort,
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    virtual HRESULT ProcessOpenLogicalChannelAckPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    // releases any pending associations
    virtual ~T120_LOGICAL_CHANNEL();


protected:

    // We store all the address and port information in host order.
    // We need to convert them to network order before we pass them
    // to the NAT functions.
    
    // These are the IP Address and port the T.120 end point is listening
    // on for the T.120 connection. We need to connect to this address.
    DWORD   m_T120ConnectToIPAddr;
    WORD    m_T120ConnectToPort;
    
    // These are the IP Address and port we will be listening on.
    // We send this information in the OLC or OLCAck PDU and the T.120
    // end point will connect to this address.
    DWORD   m_T120ListenOnIPAddr;
    WORD    m_T120ListenOnPort;

    // These are the IP Address and port we will be using in the NAT
    // redirect as the new source address of the TCP connection.
    // Once the remote T.120 end point receives a TCP conection,
    // it thinks that the connection is "from" this address.
    // CODEWORK: Any better names ??
    DWORD   m_T120ConnectFromIPAddr;
    

    // Note that we do not know the actual source address and port
    // from which the T.120 endpoint connects. This address is only
    // established when the T.120 endpoint actually calls connect.
    // We pass 0 (wild card) for these fields in the NAT redirect.

    HANDLE  m_DynamicRedirectHandle;
    


private:
    // Allocate m_T120ListenOnPort and m_T120ConnectFromPorts
    HRESULT SetPorts(
        DWORD T120ConnectToIPAddr,
        WORD  T120ConnectToPort,
        DWORD T120ListenOnIPAddr,
        DWORD T120ConnectFromIPAddr
        );

    BOOL IsT120RedirectNeeded( 
           DWORD T120ConnectToIPAddr, 
           DWORD T120ListenOnIPAddr,
           DWORD T120ListenFromIPAddr);

    // Free m_T120ListenOnPort and m_T120ConnectFromPorts
    // if they have been allocated.
    HRESULT FreePorts();
    
    // opens the bidirectional NAT redirect for the TCP stream
    HRESULT CreateNatRedirect();

    // closes any NAT redirect
    void CancelNatRedirect();

    HRESULT CheckOpenLogicalChannelAckPDU(
        IN  OpenLogicalChannelAck   &OlcPDU,
        OUT DWORD                   &T120ConnectToIPAddr,
        OUT WORD                    &T120ConnectToPort
        );
};


inline 
T120_LOGICAL_CHANNEL::T120_LOGICAL_CHANNEL(
    )
    : m_T120ConnectToIPAddr(INADDR_NONE),
      m_T120ConnectToPort(0),
      m_T120ListenOnIPAddr(INADDR_NONE),
      m_T120ListenOnPort(0),
      m_T120ConnectFromIPAddr(INADDR_NONE),
      m_DynamicRedirectHandle(INVALID_HANDLE_VALUE)
{
    InitLogicalChannel(NULL,MEDIA_TYPE_UNDEFINED,
                       0,0,LC_STATE_NOT_INIT);
}


// expandable array of pointer values
template <class T>
class DYNAMIC_POINTER_ARRAY
{
public:

    // number of blocks allocated for a new addition
    // when the array becomes full
#define DEFAULT_BLOCK_SIZE 4

	inline DYNAMIC_POINTER_ARRAY();

    // assumption: other member variables are all 0/NULL
    inline void Init(
        IN DWORD BlockSize = DEFAULT_BLOCK_SIZE
        );

    virtual ~DYNAMIC_POINTER_ARRAY();

    inline T **GetData()
    {
        return m_pData;
    }

    inline DWORD GetSize()
    {
        return m_NumElements;
    }

    DWORD Find(
        IN T& Val
        ) const;

    HRESULT Add(
        IN T &NewVal
        );

    inline T *Get(
        IN  DWORD   Index
        );
    
    inline HRESULT RemoveAt(
        IN DWORD Index
        );

    inline HRESULT Remove(
        IN  T   &Val
        );

protected:

    T       **m_pData;
    DWORD   m_NumElements;

    DWORD   m_AllocElements;

    DWORD   m_BlockSize;
};


template <class T>
inline 
DYNAMIC_POINTER_ARRAY<T>::DYNAMIC_POINTER_ARRAY(
	)
	: m_pData(NULL),
	  m_NumElements(0),
	  m_AllocElements(0),
	  m_BlockSize(0)
{
}

template <class T>
inline void 
DYNAMIC_POINTER_ARRAY<T>::Init(
    IN DWORD BlockSize /* = DEFAULT_BLOCK_SIZE */
    )
{
	_ASSERTE(NULL == m_pData);
    if (0 != BlockSize)
    {
        m_BlockSize = BlockSize;
    }
    else
    {
        m_BlockSize = DEFAULT_BLOCK_SIZE;
    }
}


// NOTE: uses realloc and free to grow/manage the array of pointers.
// This is better than new/delete as the additional memory is allocated
// in-place (i.e. the array ptr remains same) eliminating the need to copy
// memory from the old block to the new block and also reduces 
// heap fragmentation
template <class T>
HRESULT
DYNAMIC_POINTER_ARRAY<T>::Add(
    IN T &NewVal
    )
{
	if(m_NumElements == m_AllocElements)
    {
        typedef T *T_PTR;
        T** ppT = NULL;
        DWORD NewAllocElements = m_NumElements + m_BlockSize;
        ppT = (class LOGICAL_CHANNEL **) 
				realloc(m_pData, NewAllocElements * sizeof(T_PTR));
        if(NULL == ppT)
        {
            return E_OUTOFMEMORY;
        }

		// set the m_pData member to the newly allocated memory
        m_pData = ppT;
		m_AllocElements = NewAllocElements;
    }

    m_pData[m_NumElements] = &NewVal;
    m_NumElements++;
    return S_OK;
}

template <class T>
inline T *
DYNAMIC_POINTER_ARRAY<T>::Get(
    IN  DWORD   Index
    )
{
    _ASSERTE(Index < m_NumElements);
    if (Index < m_NumElements)
    {
        return m_pData[Index];
    }
    else
    {
        return NULL;
    }
}
    
template <class T>
inline HRESULT 
DYNAMIC_POINTER_ARRAY<T>::RemoveAt(
    IN DWORD Index
    )
{
    _ASSERTE(Index < m_NumElements);
    if (Index >= m_NumElements)
    {
        return E_FAIL;
    }

    // move all elements (to the right), left by one block
    memmove(
        (void*)&m_pData[Index], 
        (void*)&m_pData[Index + 1], 
        (m_NumElements - (Index + 1)) * sizeof(T *)
        );
    m_NumElements--;    
    return S_OK;
}

template <class T>
inline HRESULT 
DYNAMIC_POINTER_ARRAY<T>::Remove(
    IN  T   &Val
    )
{
    DWORD Index = Find(Val);
    if(Index >= m_NumElements)
    {
        return E_FAIL;
    }

    return RemoveAt(Index);
}

template <class T>
DWORD 
DYNAMIC_POINTER_ARRAY<T>::Find(
    IN T& Val
    ) const
{
    // search for an array element thats same as the passed
	// in value
    for(DWORD Index = 0; Index < m_NumElements; Index++)
    {
        if(m_pData[(DWORD)Index] == &Val)
        {
            return Index;
        }
    }

    return m_NumElements;      // not found
}

template <class T>
/* virtual */
DYNAMIC_POINTER_ARRAY<T>::~DYNAMIC_POINTER_ARRAY(
    )
{
    if (NULL != m_pData)
    {
        // delete each of the elements in the array
        for(DWORD Index = 0; Index < m_NumElements; Index++)
        {
            _ASSERTE(NULL != m_pData[Index]);
            delete m_pData[Index];
        }

        // free the array memory block
		free(m_pData);
    }
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Logical Channel Array                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


class LOGICAL_CHANNEL_ARRAY :
    public DYNAMIC_POINTER_ARRAY<LOGICAL_CHANNEL>
{
    typedef DYNAMIC_POINTER_ARRAY<LOGICAL_CHANNEL> BASE_CLASS;

public:

    inline LOGICAL_CHANNEL *FindByLogicalChannelNum(
        IN WORD LogicalChannelNumber
        );

    inline LOGICAL_CHANNEL *FindBySessionId(
        IN BYTE SessionId
        );

    inline void CancelAllTimers();
};


inline LOGICAL_CHANNEL *
LOGICAL_CHANNEL_ARRAY::FindByLogicalChannelNum(
    IN WORD LogicalChannelNumber
    )
{
    // check the logical channel number for each element in the array
    // search from back
    if (0 == m_NumElements) return NULL;
    for(DWORD Index = m_NumElements-1; Index < m_NumElements; Index--)
    {
        _ASSERTE(NULL != m_pData[Index]);
        if (m_pData[Index]->GetLogicalChannelNumber()
             == LogicalChannelNumber)
        {
            return m_pData[Index];
        }
    }

    // nothing found
    return NULL;
}

// SessionID is meaningful only for RTP logical channels.
// We look for only RTP logical channels.

inline LOGICAL_CHANNEL *
LOGICAL_CHANNEL_ARRAY::FindBySessionId(
    IN BYTE SessionId
    )
{
    // 0 is used by a slave terminal to request a session id from the master
    // hence, we shouldn't be searching for a match with 0
    _ASSERTE(0 != SessionId);

    // check the session for each element in the array
    // search from back
    if (0 == m_NumElements) return NULL;
    for(DWORD Index = m_NumElements-1; Index < m_NumElements; Index--)
    {
        _ASSERTE(NULL != m_pData[Index]);
        // SessionID is meaningful only for RTP logical channels.
        // We look for only RTP logical channels.
        if (IsMediaTypeRtp(m_pData[Index]->GetMediaType()) &&
            m_pData[Index]->GetSessionId() == SessionId)
        {
            return m_pData[Index];
        }
    }

    // nothing found
    return NULL;
}

inline void LOGICAL_CHANNEL_ARRAY::CancelAllTimers (void)
{
    for (DWORD Index = 0; Index < m_NumElements; Index++)
    {
        m_pData[(DWORD)Index]->TimprocCancelTimer();
    }
}

#endif // __h323ics_logchan_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\main.cpp ===
/*++

Copyright (c) 1998 - 2000  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    Contains:
        1. Module startup routines
        2. Component activation routines
        3. Component deactivation routines
        4. Module shutdown/cleanup routines
        5. Auxiliary routines

Revision History:
    
    1. 31-Jul-1998 -- File creation                     Ajay Chitturi (ajaych) 
    2. 15-Jul-1999 --                                   Arlie Davis   (arlied)    
    3. 14-Feb-2000 -- Added support for multiple        Ilya Kleyman  (ilyak)
                      private interfaces

--*/

#include "stdafx.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HANDLE NatHandle         = NULL;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Static declarations                                                       // 
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
static
void
QueryRegistry (
    void
    );

static
HRESULT
H323ProxyStartServiceInternal (
    void
    );

static
HRESULT
H323ProxyStart (
    void
    );

static
HRESULT
LdapProxyStart (
    void
    );

static
void
H323ProxyStop (
    void
    );

static
void
LdapProxyStop (
    void
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Module startup routines                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


EXTERN_C
BOOLEAN
H323ProxyInitializeModule (
    void
    )
/*++

Routine Description:
    Initializes module.
    
Arguments:
    None
    
Return Values:
    TRUE  - if initialization was successful
    FALSE - if initialization failed

Notes:
    Equivalent to DLL_PROCESS_ATTACH
--*/

{
    Debug (_T("H323: DLL_PROCESS_ATTACH.\n"));

    H323ASN1Initialize();

    return TRUE;
} // H323ProxyInitializeModule


EXTERN_C
ULONG
H323ProxyStartService (
    void
    )
/*++

Routine Description:
    Starts the service
    
Arguments:
    None
    
Return Values:
    Win32 error code

Notes:
    Module entry point
--*/

{
    HRESULT        Result;

    Debug (_T("H323: starting...\n"));

    Result = H323ProxyStartServiceInternal();

    if (Result == S_OK) {
        DebugF (_T("H323: H.323/LDAP proxy has initialized successfully.\n"));
        return ERROR_SUCCESS;
    }
    else {
        DebugError (Result, _T("H323: H.323/LDAP proxy has FAILED to initialize.\n"));
        return ERROR_CAN_NOT_COMPLETE;
    }
} // H323ProxyStartService

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Component activation routines                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


static
HRESULT
H323ProxyStartServiceInternal (
    void
    )
/*++

Routine Description:

    Initializes all components.

Arguments:
    
    None.

Return Values:

    Returns S_OK in case of success or an error in case of failure.

Notes:
    Internal version of DLL entry point

--*/

{
    WSADATA     WsaData;
    HRESULT     Result;

    QueryRegistry ();

    // Initialize WinSock
    Result = WSAStartup (MAKEWORD (2, 0), &WsaData);
    if (S_OK == Result) {

        // Initialize allocator of call reference values
        Result = InitCrvAllocator();
        if (S_OK == Result) {

            // initialize NAT
            Result = NatInitializeTranslator (&NatHandle);
            if (S_OK == Result) {

                // Initialize Port Pool
                Result = PortPoolStart ();
                if (S_OK == Result) {

                    // Initialize H.323 Proxy
                    Result = H323ProxyStart ();
                    if (S_OK == Result) {

                        // Initialize LDAP Proxy
                        Result = LdapProxyStart ();
                        if (S_OK == Result) {

                            return S_OK;
                        }
                        
                        H323ProxyStop ();
                    }

                    PortPoolStop ();
                }

                NatShutdownTranslator (NatHandle);
                NatHandle = NULL;
            }

            CleanupCrvAllocator ();
        }

        WSACleanup ();
    }

    return Result;
} // H323ProxyStartServiceInternal


HRESULT H323ProxyStart (
    void
    )
/*++

Routine Description:

    Initializes components of H.323 proxy

Arguments:

    None

Return Values:

    S_OK if successful, error code otherwise.

Notes:

--*/

{
	HRESULT		Result;

	Result = Q931SyncCounter.Start ();
	if (S_OK == Result) {

        CallBridgeList.Start ();
        Result = Q931CreateBindSocket ();
        if (S_OK == Result)  {

            Result = Q931StartLoopbackRedirect ();
            if (S_OK == Result) {

                return S_OK;

            }

            Q931CloseSocket ();
            CallBridgeList.Stop ();
        }

        Q931SyncCounter.Wait (INFINITE);
        Q931SyncCounter.Stop ();
    }

	return Result;
} // H323ProxyStart


HRESULT LdapProxyStart (
    void
    )
/*++

Routine Description:

    Initializes components of LDAP proxy

Arguments:

    None

Return Values:

    S_OK if successful, error code otherwise

Notes:

--*/

{
	HRESULT	Status;

	Status = LdapSyncCounter.Start ();
    if (S_OK == Status) {

        Status = LdapCoder.Start();
        if (S_OK == Status) {

            Status = LdapTranslationTable.Start ();
            if (S_OK == Status) {

                LdapConnectionArray.Start ();
                Status = LdapAccept.Start ();
                if (S_OK == Status) {

                    return S_OK;
                }

                LdapConnectionArray.Stop ();
                LdapTranslationTable.Stop ();
            }

            LdapCoder.Stop ();
        }
        
        LdapSyncCounter.Wait (INFINITE);

        LdapSyncCounter.Stop ();
    }

    return Status;
} // LdapProxyStart


EXTERN_C ULONG
H323ProxyActivateInterface(
    IN ULONG Index,
    IN H323_INTERFACE_TYPE InterfaceType,
    IN PIP_ADAPTER_BINDING_INFO BindingInfo
    )
/*++

Routine Description:

    Activates an interface for H.323/LDAP

Arguments:
    
    Index       - Interface index (for internal use)
    BindingInfo - Interface binding information

Return Values:

    Win32 error code

Notes:

    Module entry point

--*/

{
    ULONG   Error;

    DebugF (_T("H323: Request to activate interface with adapter index %d.\n"),
        Index);

    if (!BindingInfo->AddressCount ||
        !BindingInfo->Address[0].Address ||
         Index == INVALID_INTERFACE_INDEX) {

        return ERROR_INVALID_PARAMETER;
    }

    Error = InterfaceArray.AddStartInterface (Index, InterfaceType, BindingInfo);

    return Error;
} // H323ProxyActivateInterface

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Module shutdown routines                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


EXTERN_C void H323ProxyCleanupModule (
    void
    )
/*++

Routine Description:
    Shuts down module
    
Arguments:
    None
    
Return Values:
    None

Notes:
    Equivalent to DLL_PROCESS_DETACH
--*/

{
    Debug (_T("H323: DLL_PROCESS_DETACH\n"));

    H323ASN1Shutdown ();

} // H323ProxyCleanupModule


EXTERN_C
void H323ProxyStopService (
    void
    )
/*++

Routine Description:
    Stops the service
    
Arguments:
    None
    
Return Values:
    None

Notes:
    Module entry point
--*/

{
    LdapProxyStop ();

    H323ProxyStop ();

	InterfaceArray.AssertShutdownReady ();

    InterfaceArray.Stop ();

    PortPoolStop ();

    if (NatHandle) {
        NatShutdownTranslator (NatHandle);
        NatHandle = NULL;
    }

    CleanupCrvAllocator ();

    WSACleanup ();

    Debug (_T("H323: service has stopped\n"));
} // H323ProxyStopService


void
H323ProxyStop (
    void
    )
/*++

Routine Description:
    Stops H.323 proxy and waits until all call-bridges are deleted.
    
Arguments:
    None
    
Return Values:
    None

Notes:

--*/

{
    Q931StopLoopbackRedirect ();

    Q931CloseSocket ();

	CallBridgeList.Stop ();

	Q931SyncCounter.Wait (INFINITE);
    
    Q931SyncCounter.Stop ();
} // H323ProxyStop


void
LdapProxyStop (
    void)
/*++

Routine Description:
    LdapProxyStop is responsible for undoing all of the work that LdapProxyStart performed.
    It deletes the NAT redirect, deletes all LDAP connections (or, at least, it releases them
    -- they may not delete themselves yet if they have pending I/O or timer callbacks),
    and disables the creation of new LDAP connections.
    
Arguments:
    None
    
Return Values:
    None

Notes:

--*/

{
    LdapAccept.Stop ();

	LdapConnectionArray.Stop ();

	LdapTranslationTable.Stop ();

	LdapCoder.Stop();

	LdapSyncCounter.Wait (INFINITE);

    LdapSyncCounter.Stop ();
} // LdapProxyStop


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Component deactivation routines                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


EXTERN_C
VOID
H323ProxyDeactivateInterface (
    IN ULONG Index
    )
/*++

Routine Description:
    Deactivates interface for H.323/LDAP
    
Arguments:
    Index -- Interface index, previously passed to the 
             interface activation routine
    
Return Values:
    None

Notes:
    
    Module entry point
--*/

{
    DebugF (_T("H323: DeactivateInterface called, index %d\n"),
        Index);

    InterfaceArray.RemoveStopInterface (Index);
} // H323ProxyDeactivateInterface

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Auxiliary routines                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


static
void
QueryRegistry (
    void
    )
/*++

Routine Description:
    Queries Registry for the values needed in module operations
    
Arguments:
    None
    
Return Values:
    None

Notes:
    static
--*/

{
    HKEY    Key;
    HRESULT    Result;

    Result = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE, H323ICS_SERVICE_PARAMETERS_KEY_PATH,
        0, 
        KEY_READ, 
        &Key
        );

    if (ERROR_SUCCESS == Result) {

        Result = RegQueryValueDWORD (Key, H323ICS_REG_VAL_LOCAL_H323_ROUTING, &EnableLocalH323Routing);

        if (ERROR_SUCCESS != Result) {

            EnableLocalH323Routing = FALSE;

        }

        RegCloseKey (Key);

    } else {

        EnableLocalH323Routing = FALSE;

    }

    DebugF (_T("H323: Local H323 routing is %sabled.\n"),
            EnableLocalH323Routing ? _T("en") : _T("dis"));

} // QueryRegistry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\q931defs.h ===
#ifndef	__iptel_q931defs_h
#define	__iptel_q931defs_h

// This module contains constants and enumerated types for values used in the Q.931 protocol.
// It does not contain any structures, definitions, or APIs relevant to any implementation.



	// Q931_PROTOCOL_DISCRIMINATOR identifies Q.931 PDUs on links that may carry
	// PDUs from more than one protocol, such as LAPD D-channel links on PRI.
#define	Q931_PROTOCOL_DISCRIMINATOR					0x08

	// the well-known Q.931 TSAP for TCP on IP is TCP port 1720
#define	Q931_TSAP_IP_TCP							1720
#define	Q931_TSAP_IP_TCP_SECURE						1300


enum	Q931_MESSAGE_TYPE
{
	// Call Establishment Message (000-----)
	Q931_MESSAGE_TYPE_ALERTING				= 0x01,
	Q931_MESSAGE_TYPE_CALL_PROCEEDING		= 0x02,
	Q931_MESSAGE_TYPE_CONNECT				= 0x07,
	Q931_MESSAGE_TYPE_CONNECT_ACKNOWLEDGE	= 0x0F,
	Q931_MESSAGE_TYPE_PROGRESS				= 0x03,
	Q931_MESSAGE_TYPE_SETUP					= 0x05,
	Q931_MESSAGE_TYPE_SETUP_ACKNOWLEDGE		= 0x0E,
	Q931_MESSAGE_TYPE_FACILITY				= 0x1C,

	// Call Information Phase message (001-----)
	Q931_MESSAGE_TYPE_RESUME				= 0x26,
	Q931_MESSAGE_TYPE_RESUME_ACKNOWLEDGE	= 0x2E,
	Q931_MESSAGE_TYPE_RESUME_REJECT			= 0x22,
	Q931_MESSAGE_TYPE_SUSPEND				= 0x25,
	Q931_MESSAGE_TYPE_SUSPEND_ACKNOWLEDGE	= 0x2D,
	Q931_MESSAGE_TYPE_SUSPEND_REJECT		= 0x21,
	Q931_MESSAGE_TYPE_USER_INFORMATION		= 0x20,

	// Call Clearing Messages (010-----)
	Q931_MESSAGE_TYPE_DISCONNECT			= 0x45,
	Q931_MESSAGE_TYPE_RELEASE				= 0x4D,
	Q931_MESSAGE_TYPE_RELEASE_COMPLETE		= 0x5A,
	Q931_MESSAGE_TYPE_RESTART				= 0x46,
	Q931_MESSAGE_TYPE_RESTART_ACKNOWLEDGE	= 0x4E,
	
	// Miscellaneous Message (011-----)
	Q931_MESSAGE_TYPE_SEGMENT				= 0x60,
	Q931_MESSAGE_TYPE_CONGESTION_CONTROL	= 0x79,
	Q931_MESSAGE_TYPE_INFORMATION			= 0x7B,
	Q931_MESSAGE_TYPE_NOTIFY				= 0x6E,
	Q931_MESSAGE_TYPE_STATUS				= 0x7D,
	Q931_MESSAGE_TYPE_STATUS_ENQUIRY		= 0x75,
};


enum	Q931_IE_IDENTIFIER
{
	// Single-Octet Information Elements
	Q931_IE_SHIFT							= 0x90,		// 1001----
	Q931_IE_RESERVED						= 0x80,		// 1000----
	Q931_IE_MORE_DATA						= 0xA0,		// 11000000
	Q931_IE_SENDING_COMPLETE				= 0xA1,		// 11000001
	Q931_IE_CONGESTION_CONTROL				= 0xB0,		// 1011----
	Q931_IE_REPEAT_INDICATOR				= 0xD0,		// 1101----

	// Variable-Length Information Elements
	Q931_IE_SEGMENTED_MESSAGE				= 0x00,
	Q931_IE_BEARER_CAPABILITY				= 0x04,
	Q931_IE_CAUSE							= 0x08,
	Q931_IE_CALL_IDENTITIY					= 0x10,
	Q931_IE_CALL_STATE						= 0x14,
	Q931_IE_CHANNEL_IDENTIFICATION			= 0x18,
	Q931_IE_PROGRESS_INDICATOR				= 0x1E,
	Q931_IE_NETWORK_SPECIFIC_FACILITIES		= 0x20,
	Q931_IE_NOTIFICATION_INDICATOR			= 0x27,
	Q931_IE_DISPLAY							= 0x28,
	Q931_IE_DATE_TIME						= 0x29,
	Q931_IE_KEYPAD_FACILITY					= 0x2A,
	Q931_IE_SIGNAL							= 0x34,
	Q931_IE_INFORMATION_RATE				= 0x40,
	Q931_IE_END_TO_END_TRANSIT_DELAY		= 0x42,
	Q931_IE_TRANSIT_DELAY_SELECTION			= 0x43,
	Q931_IE_PACKET_LAYER_BINARY_PARAMETERS	= 0x44,
	Q931_IE_PACKET_LAYER_WINDOW_SIZE		= 0x45,
	Q931_IE_PACKET_SIZE						= 0x46,
	Q931_IE_CLOSED_USER_GROUP				= 0x47,
	Q931_IE_REVERSE_CHARGE_INDICATION		= 0x4A,
	Q931_IE_CALLING_PARTY_NUMBER			= 0x6A,
	Q931_IE_CALLING_PARTY_SUBADDRESS		= 0x6B,
	Q931_IE_CALLED_PARTY_NUMBER				= 0x70,
	Q931_IE_CALLED_PARTY_SUBADDRESS			= 0x71,
	Q931_IE_REDIRECTING_NUMBER				= 0x74,
	Q931_IE_TRANSIT_NETWORK_SELECTION		= 0x78,
	Q931_IE_RESTART_INDICATOR				= 0x79,
	Q931_IE_LOW_LAYER_COMPATIBILITY			= 0x7C,
	Q931_IE_HIGH_LAYER_COMPATIBILITY		= 0x7D,
	Q931_IE_USER_TO_USER					= 0x7E,
	Q931_IE_ESCAPE_FOR_EXTENSION			= 0x7F,
};

enum	Q931_UUIE_TYPE
{
	Q931_UUIE_USER_SPECIFIC					= 0x00,
	Q931_UUIE_OSI							= 0x01,
	Q931_UUIE_X244							= 0x02,
	Q931_UUIE_IA5_TEXT						= 0x04,
	Q931_UUIE_X208							= 0x05,
	Q931_UUIE_V120_RATE_ADAPTION			= 0x07,
	Q931_UUIE_UNI_CALL_CONTROL				= 0x08,
};

#endif // __iptel_q931defs_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\portmgmt.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    portmgmt.cpp

Abstract:

    Functions for allocating and freeing ports from the Port pool

        PortPoolAllocRTPPort()
	PortPoolFreeRTPPort()

Environment:

    User Mode - Win32

--*/


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Functions dealing with the TCP device to reserve/unreserve port ranges.   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"


#define NUM_DWORD_BITS (sizeof(DWORD)*8)


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define NUM_PORTS_PER_RANGE 100

struct	PORT_RANGE
{
	LIST_ENTRY		ListEntry;

    // This is the actual lower port. In case, the range allocated
    // by TCP starts with an odd port, we ignore the first port in
    // which case (low == AllocatedLow + 1). But when we free the
    // port range we should pass in AllocatedLow and not low.
    WORD  AllocatedLow;
    WORD  low;

    // high is the last port we can use and not the allocated high.
    // In some cases high will be one less than the actual allocated high.
    WORD  high;

    //Each bit in this bitmap indicates the status of 2 consecutive ports 

    DWORD *AllocList;
    DWORD dwAllocListSize;
};




class	PORT_POOL :
public	SIMPLE_CRITICAL_SECTION_BASE
{
private:
	HANDLE		TcpDevice;
	LIST_ENTRY	PortRangeList;		// contains PORT_RANGE.ListEntry

private:
	HRESULT		OpenTcpDevice	(void);
	HRESULT		StartLocked		(void);
	void		FreeAll			(void);

	HRESULT	CreatePortRange (
		OUT	PORT_RANGE **	ReturnPortRange);

	HRESULT	ReservePortRange (
		IN  ULONG	RangeLength,
		OUT WORD *	ReturnStartPort);

	HRESULT	UnReservePortRange (
		IN	WORD	StartPort);


public:

	PORT_POOL	(void);
	~PORT_POOL	(void);

	HRESULT		Start	(void);
	void		Stop	(void);

	HRESULT		AllocPort (
		OUT	WORD *	ReturnPort);

	void		FreePort (
		IN	WORD	Port);
};

// global data -------------------------------------------------------------------------

static	PORT_POOL	PortPool;

// extern code -----------------------------------------------------------------------

HRESULT PortPoolStart (void)
{
	return PortPool.Start();
}

void PortPoolStop (void)
{
	PortPool.Stop();
}

HRESULT PortPoolAllocRTPPort (
	OUT	WORD *	ReturnPort)
{
	return PortPool.AllocPort (ReturnPort);
}

HRESULT PortPoolFreeRTPPort (
	IN	WORD	Port)
{
	PortPool.FreePort (Port);

	return S_OK;
}





HRESULT PORT_POOL::ReservePortRange (
	IN  ULONG	RangeLength,
    OUT WORD *	ReturnStartPort)
{
    TCP_BLOCKPORTS_REQUEST	PortRequest;
    DWORD	BytesTransferred;
    ULONG	StartPort;

	AssertLocked();

    *ReturnStartPort = 0;

	if (!TcpDevice) {
		Debug (_T("H323: Cannot allocate port range, TCP device could not be opened.\n"));
		return E_UNEXPECTED;
	}

	assert (TcpDevice != INVALID_HANDLE_VALUE);

    PortRequest.ReservePorts = TRUE;
    PortRequest.NumberofPorts = RangeLength;
    
    if (!DeviceIoControl (TcpDevice, IOCTL_TCP_BLOCK_PORTS,
		&PortRequest, sizeof PortRequest,
		&StartPort, sizeof StartPort, 
		&BytesTransferred, NULL)) {

		DebugLastError (_T("H323: Failed to allocate TCP port range.\n"));
        return GetLastError();
    }

	DebugF (_T("H323: Reserved port range: [%04X - %04X)\n"),
		StartPort, StartPort + PortRequest.NumberofPorts);

    *ReturnStartPort = (WORD) StartPort;
    return S_OK;
}



HRESULT PORT_POOL::UnReservePortRange (
	IN	WORD	StartPort)
{
	TCP_BLOCKPORTS_REQUEST	PortRequest;
	DWORD	BytesTransferred;
	DWORD	Status;

	AssertLocked();

	if (!TcpDevice) {
		Debug (_T("H323: Cannot free TCP port range, TCP device is not open.\n"));
		return E_UNEXPECTED;
	}

	assert (TcpDevice != INVALID_HANDLE_VALUE);

	PortRequest.ReservePorts = FALSE;
	PortRequest.StartHandle = (ULONG) StartPort;
    
	if (!DeviceIoControl(TcpDevice, IOCTL_TCP_BLOCK_PORTS,
		&PortRequest, sizeof PortRequest,
		&Status, sizeof Status,
		&BytesTransferred, NULL)) {

		DebugLastError (_T("H323: Failed to free TCP port range.\n"));

		return GetLastError();
    }

    return S_OK;
}




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Port Pool Functions.                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



// PORT_POOL -----------------------------------------------------------------------

PORT_POOL::PORT_POOL (void)
{
	TcpDevice = NULL;
	InitializeListHead (&PortRangeList);
}

PORT_POOL::~PORT_POOL (void)
{
	assert (!TcpDevice);
	assert (IsListEmpty (&PortRangeList));
}

HRESULT PORT_POOL::Start (void)
{
	HRESULT		Result;

	Lock();

	Result = OpenTcpDevice();

	Unlock();

	return Result;
}

HRESULT PORT_POOL::OpenTcpDevice (void)
{
    UNICODE_STRING		DeviceName;
    IO_STATUS_BLOCK		IoStatusBlock;
    OBJECT_ATTRIBUTES	ObjectAttributes;
    NTSTATUS			Status;

	if (TcpDevice)
		return S_OK;

    RtlInitUnicodeString (&DeviceName, (PCWSTR) DD_TCP_DEVICE_NAME);

	InitializeObjectAttributes (&ObjectAttributes, &DeviceName,
		OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = NtCreateFile (
		&TcpDevice,
		SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA ,
		&ObjectAttributes,
		&IoStatusBlock,
		NULL,
		FILE_ATTRIBUTE_NORMAL,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		FILE_OPEN_IF, 0, NULL, 0);

    if (Status != STATUS_SUCCESS) {
		TcpDevice = NULL;

		DebugError (Status, _T("H323: Failed to open TCP device.\n"));

		return (HRESULT) Status;
    }

    return S_OK;
}

void PORT_POOL::Stop (void)
{
	Lock();

	FreeAll();

	if (TcpDevice) {
		assert (TcpDevice != INVALID_HANDLE_VALUE);

		CloseHandle (TcpDevice);
		TcpDevice = NULL;
	}
    
	Unlock();
}

void PORT_POOL::FreeAll (void)
{
	LIST_ENTRY *	ListEntry;
    PORT_RANGE *	PortRange;

	while (!IsListEmpty (&PortRangeList)) {
		ListEntry = RemoveHeadList (&PortRangeList);
		PortRange = CONTAINING_RECORD (ListEntry, PORT_RANGE, ListEntry);

        // Free the port range PortRange->AllocatedLow
        UnReservePortRange (PortRange -> AllocatedLow);
        EM_FREE (PortRange);
    }
}

/*++

Routine Description:

    This function allocates a pair of RTP/RTCP ports from the 
    port pool.

Arguments:
    
    rRTPport - This is an OUT parameter. If the function succeeds
        rRTPport will contain the RTP port (which is even).
        rRTPport+1 should be used as the RTCP port.
        
Return Values:

    This function returns S_OK on success and E_FAIL if it
    fails to allocate a port range.

--*/

HRESULT PORT_POOL::AllocPort (
	OUT	WORD *	ReturnPort)
{
    DWORD i, j;
    DWORD bitmap = 0x80000000;
	LIST_ENTRY *	ListEntry;
    PORT_RANGE *	PortRange;
	WORD			Port;
	HRESULT			Result;

    Lock();

	for (ListEntry = PortRangeList.Flink; ListEntry != &PortRangeList; ListEntry = ListEntry -> Flink) {
		PortRange = CONTAINING_RECORD (ListEntry, PORT_RANGE, ListEntry);

        for (i = 0; i < PortRange->dwAllocListSize; i++) {

            // traverse through AllocList of this portRange

            if ((PortRange->AllocList[i] & 0xffffffff) != 0xffffffff) {
				// at least one entry is free
				bitmap = 0x80000000;
            
				for (j = 0; j < NUM_DWORD_BITS; j++) {
					// traverse through each bit of the DWORD
					if ((PortRange->AllocList[i] & bitmap) == 0)
					{
						// found a free pair of ports
						Port = (WORD) (PortRange -> low + (i*NUM_DWORD_BITS*2) + (j*2));

						if (Port > PortRange -> high) {
							// This check is needed because the last DWORD
							// in the AllocList may contain bits which are
							// actually not included in the AllocList. 
							goto noports;
						}

						// set the bit to show the pair of ports is allocated
						PortRange -> AllocList[i] |= bitmap;
                    
						// Leave the global critical section for the Port pool 
						Unlock();

						DebugF (_T("H323: Allocated port pair (%04X, %04X).\n"), Port, Port + 1);

						*ReturnPort = Port;

						return S_OK;
					}

					bitmap = bitmap >> 1;
				}
            }
        }
    }
    
noports:
    // CODEWORK: Once we get the new ioctl() for dynamically reserving
    // port ranges, we need to allocate a new port range here. If the
    // ioctl() fails we need to return E_FAIL or another error which
    // says we have run out of ports.

    // Allocate a new port range
    Result = CreatePortRange (&PortRange);

	if (PortRange) {
		InsertHeadList (&PortRangeList, &PortRange -> ListEntry);

		// allocate the first port in the range and 
		Port = PortRange -> low;
		PortRange->AllocList[0] |= 0x80000000;

		DebugF (_T("H323: Allocated port pair (%04X, %04X).\n"),
			Port, Port + 1);

		*ReturnPort = Port;
		Result = S_OK;
	}
	else {
		Debug (_T("H323: Failed to allocate port range.\n"));

		*ReturnPort = 0;
		Result = E_FAIL;
    }

	Unlock();

	return Result;

}


/*++

Routine Description:

    This function frees a pair of RTP/RTCP ports.
    The data structure is changed to show that the pair of ports
    is now available.

    CODEWORK: If an entire port range becomes free, do we release
    the port range to the operating system ? We probably need a
    heuristic to do this because allocating a port range again
    could be an expensive operation.

Arguments:
    
    wRTPport - This gives the RTP port to be freed.
        (RTCP port is RTPport+1 which is implicitly freed because
	 we use one bit store the status of both these ports.)

Return Values:

    Returns S_OK on success or E_FAIL if the port is not found in
    the port pool list.

--*/

void PORT_POOL::FreePort (
	IN	WORD	Port)
{
	HRESULT		Result;

    // assert RTP port is even
    _ASSERTE ((Port & 1) == 0);

    DWORD	Index = 0;
    DWORD	Bitmap = 0x80000000;

	LIST_ENTRY *	ListEntry;
    PORT_RANGE *	PortRange;

	Lock();

	// find the port range that this port belongs to
	// simple linear scan -- suboptimal

	Result = E_FAIL;

	for (ListEntry = PortRangeList.Flink; ListEntry != &PortRangeList; ListEntry = ListEntry -> Flink) {
		PortRange = CONTAINING_RECORD (ListEntry, PORT_RANGE, ListEntry);

		if (PortRange -> low <= Port && PortRange -> high >= Port) {
			Result = S_OK;
			break;
		}
    }
    
	if (Result == S_OK) {
		Index = (Port - PortRange -> low) / (NUM_DWORD_BITS * 2);
    
		// assert index is less than the size of the array
		_ASSERTE (Index < PortRange -> dwAllocListSize);

		// CODEWORK: make sure that the bit is set i.e. the port has
		// been previously allocated. Otherwise return an error and print
		// a warning.
    
		// zero the bit to show the pair of ports is now free

		PortRange -> AllocList [Index] &=
			~(Bitmap >> (((Port - PortRange -> low) / 2) % NUM_DWORD_BITS));
			
		DebugF (_T("H323: Deallocated port pair (%04X, %04X).\n"), Port, Port + 1);
	}
	else {
		DebugF (_T("H323: warning, attempted to free port pair (%04X, %04X), but it did not belong to any port range.\n"),
		        Port, Port + 1);
	}

	Unlock();
}

HRESULT PORT_POOL::CreatePortRange (
	OUT	PORT_RANGE **	ReturnPortRange)
{
    // CODEWORK: Once we get the new ioctl() for dynamically reserving
    // port ranges, we need to allocate a new port range here. If the
    // ioctl() fails we need to return E_FAIL or another error which
    // says we have run out of ports.

    // assert low is even and high is odd
    // _ASSERTE((low % 2) == 0);
    // _ASSERTE((high % 2) == 1);

    HRESULT			Result;
    WORD			AllocatedLowerPort;
    WORD			LowerPort;
    DWORD			NumPortsInRange;
    PORT_RANGE *	PortRange;
	DWORD			dwAllocListSize;

	assert (ReturnPortRange);
	*ReturnPortRange = NULL;

    Result = ReservePortRange (NUM_PORTS_PER_RANGE, &AllocatedLowerPort);
    if (FAILED (Result))
		return Result;

    // If the allocated lower port is odd we do not use the lower port
    // and the range we use starts with the next higher port.
    if ((AllocatedLowerPort & 1) == 1) {
		// the allocated region is ODD
		// don't use the first entry

        NumPortsInRange = NUM_PORTS_PER_RANGE - 1 - ((NUM_PORTS_PER_RANGE) & 1);
        LowerPort       = AllocatedLowerPort + 1;
    }
    else {
		// the allocated region is EVEN
		// don't use the last entry

        NumPortsInRange = NUM_PORTS_PER_RANGE;
        LowerPort       = AllocatedLowerPort;
    }

    // If NumPortsInRange is odd, we can not use the last port
    if ((NumPortsInRange & 1) == 1)
    {
        NumPortsInRange--;
    }
    
    // Each bit gives the status (free/allocated) of two consecutive
    // ports. So, each DWORD can store the status of NUM_DWORD_BITS*2
    // ports. We add (NUM_DWORD_BITS*2 - 1) to round up the number of
    // DWORDS required.
    dwAllocListSize = (NumPortsInRange + NUM_DWORD_BITS*2 - 1)
		/ (NUM_DWORD_BITS * 2);

    // allocate space for the AllocList also
    // Since we do not anticipate too many port ranges being allocated,
    // we do not require a separate heap for these structures.
	PortRange = (PORT_RANGE *) EM_MALLOC (
		sizeof (PORT_RANGE) + dwAllocListSize * sizeof (DWORD));

    if (PortRange == NULL) {
		Debug (_T("H323: Allocation failure, cannot allocate PORT_RANGE and associated bit map\n"));

		UnReservePortRange (AllocatedLowerPort);
        return E_OUTOFMEMORY;
    }

    _ASSERTE((LowerPort + NumPortsInRange - 1) <= 0xFFFF);

    PortRange -> AllocatedLow = AllocatedLowerPort;
    PortRange -> low = LowerPort;
    PortRange -> high = (WORD) (LowerPort + NumPortsInRange - 1);
    PortRange -> dwAllocListSize = dwAllocListSize;
    PortRange -> AllocList = (DWORD *) (PortRange + 1);

	DebugF (_T("H323: Allocated port block: [%04X - %04X].\n"),
		PortRange -> low,
		PortRange -> high,
		PortRange -> dwAllocListSize);
 
   // Initialize the AllocList to show all the ports are free
    ZeroMemory (PortRange -> AllocList, (PortRange -> dwAllocListSize) * sizeof (DWORD));

	*ReturnPortRange = PortRange;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\main.h ===
/*++

Copyright (c) 1998 - 2000  Microsoft Corporation

Module Name:

    main.h

Abstract:

    Contains:
        1. Prototypes for routines used in asynchrounous I/O
        2. Definitions of constants and macros used by the above routines
        3. Definitions of macros and inline routines for memory management

Environment:

    User Mode - Win32

History:
    
    1. 31-Jul-1998 -- File creation                     Ajay Chitturi (ajaych) 
    2. 15-Jul-1999 --                                   Arlie Davis   (arlied)    
    3. 14-Feb-2000 -- Added support for multiple        Ilya Kleyman  (ilyak)
                      private interfaces

--*/
#ifndef    __h323ics_main_h
#define    __h323ics_main_h

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Constants and macros                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define    DEFAULT_TRACE_FLAGS          LOG_TRCE

#define    MAX_LISTEN_BACKLOG           5

#define    LOCAL_INTERFACE_INDEX     ((ULONG)-2)


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern HANDLE   NatHandle;
extern DWORD    EnableLocalH323Routing;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Prototypes for routines used in asynchrounous I/O                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
HRESULT
EventMgrIssueAccept (
    IN  DWORD                   BindIPAddress,          // in HOST order
    IN  OVERLAPPED_PROCESSOR &  OverlappedProcessor, 
    OUT WORD &                  BindPort,               // in HOST order
    OUT SOCKET &                ListenSocket
    );

HRESULT
EventMgrIssueSend(
    IN SOCKET                   Socket,
    IN OVERLAPPED_PROCESSOR &   OverlappedProcessor,
    IN BYTE                     *Buffer,
    IN DWORD                    BufferLength
    );
    
HRESULT
EventMgrIssueRecv(
    IN SOCKET                   Socket,
    IN OVERLAPPED_PROCESSOR &   OverlappedProcessor
    );

HRESULT
EventMgrBindIoHandle(
    IN SOCKET                   Socket
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Memory management support                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


__inline
void *EM_MALLOC (
    IN size_t Size
    )
/*++

Routine Description:

    Private memory allocator.

Arguments:

    Size - number of bytes to allocate

Return Values:
    - Pointer to allocated memory, if successful.
    - NULL otherwise.

Notes:

--*/

{
    return (HeapAlloc (GetProcessHeap (),
              0, /* no flags */
              (Size)));
} // EM_MALLOC


__inline
void
EM_FREE(
    IN void *Memory
    )
/*++

Routine Description:

    Private memory deallocator

Arguments:

    Memory -- pointer to allocated memory

Return Values:

    None

Notes:
    The memory should have previously been
    allocated via EM_MALLOC

--*/

{
    HeapFree (GetProcessHeap (),
         0, /* no flags */
         (Memory));
} // EM_FREE

#endif // __h323ics_main_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\ovioctx.h ===
/*
 * Copyright (c) 1998, Microsoft Corporation
 * File: timeout.cpp
 *
 * Purpose: 
 * 
 * Contains all the definitions
 * for the overlapped I/O context structures
 *
 * History:
 *
 *   1. created 
 *       Ajay Chitturi (ajaych)  26-Jun-1998
 *
 */

#ifndef _oviocontext_h_
#define _oviocontext_h_

/*
 * This file defines the structures used for overlapped I/O 
 */

#define ACCEPT_BUFFER_MAX       (sizeof (SOCKADDR_IN) * 2 + 0x20)
#define TPKT_HEADER_SIZE 4
#define TPKT_VERSION    3

// Types of overlapped I/O requests
enum EMGR_OV_IO_REQ_TYPE
{
     EMGR_OV_IO_REQ_ACCEPT = 0,
     EMGR_OV_IO_REQ_SEND,
     EMGR_OV_IO_REQ_RECV
};



// This structure stores the I/O context for each Overlapped I/O request
// OVERLAPPED should always be the first member of this struct. 
// A pointer to the overlapped member of this structure is passed 
// for all overlapped I/O calls.
// When we receive an I/O completion packet, the IOContext pointer is 
// obtained by casting the OVERLAPPED pointer. 

typedef struct _IOContext {
    OVERLAPPED ov;
    EMGR_OV_IO_REQ_TYPE reqType;        // ACCEPT/SEND/RECV
    OVERLAPPED_PROCESSOR *pOvProcessor;   // callback called on this member
                                          // this gives us the socket and 
                                          // the call type (Q931/H245) as well
} IOContext, *PIOContext;

// This structure stores the I/O context 
// for each Overlapped Send/Recv request
typedef struct _SendRecvContext {
    IOContext ioCtxt;
    SOCKET sock;
    BYTE pbTpktHdr[TPKT_HEADER_SIZE];
    DWORD dwTpktHdrBytesDone;
    PBYTE pbData;
    DWORD dwDataLen;
    DWORD dwDataBytesDone;
} SendRecvContext, *PSendRecvContext;

// This structure stores the I/O context 
// for each Overlapped accept request
typedef struct _AcceptContext {
    IOContext ioCtxt;
    SOCKET listenSock;
    SOCKET acceptSock;
    BYTE addrBuf[ACCEPT_BUFFER_MAX]; 
} AcceptContext, *PAcceptContext;

#include "sockinfo.h"

// the PDU decode logic depends upon whether its targeted for
// a Q931 or H245 channel. Since we want to keep that logic
// in the event manager, the overlapped processor needs to
// expose its type via this 
enum OVERLAPPED_PROCESSOR_TYPE
{
	OPT_Q931 = 0,
	OPT_H245
};

// Classes (Q931 src, dest and H245) inheriting
// from this make async overlapped operations
// this class provides the callback methods and
// some of the parameters needed by the event manager
// to make the overlapped calls
class OVERLAPPED_PROCESSOR
{
protected:

    OVERLAPPED_PROCESSOR_TYPE  m_OverlappedProcessorType;

	// it belongs to this call state
	H323_STATE *	m_pH323State;
    SOCKET_INFO		m_SocketInfo;			// socket handle and remote/local address/ports

public:

	OVERLAPPED_PROCESSOR::OVERLAPPED_PROCESSOR (void)
		: m_OverlappedProcessorType	(OPT_Q931),
		  m_pH323State	(NULL)
	{}


	void Init (
		IN OVERLAPPED_PROCESSOR_TYPE	OverlappedProcessorType,
		IN H323_STATE					&H323State)
	{
		// an assert is sufficient as this shouldn't happen
		_ASSERTE(NULL == m_pH323State);

		m_OverlappedProcessorType	= OverlappedProcessorType;

		m_pH323State				= &H323State;
	}

	BOOLEAN IsSocketValid (void) { return m_SocketInfo.IsSocketValid(); }

    inline OVERLAPPED_PROCESSOR_TYPE GetOverlappedProcessorType() { return m_OverlappedProcessorType; }

    inline SOCKET_INFO &GetSocketInfo() { return m_SocketInfo; }

    inline H323_STATE &GetH323State() { return *m_pH323State; }

    inline CALL_BRIDGE &GetCallBridge();

    virtual HRESULT AcceptCallback (
		IN	DWORD	Status,
		IN	SOCKET	Socket,
		IN	SOCKADDR_IN *	LocalAddress,
		IN	SOCKADDR_IN *	RemoteAddress) = 0;

    virtual HRESULT SendCallback(
        IN      HRESULT					  CallbackHResult
        ) = 0;

    virtual HRESULT ReceiveCallback(
        IN      HRESULT					 CallbackHResult,
        IN      BYTE                    *pBuffer,
        IN      DWORD                    BufLen
        ) = 0;
};

void
EventMgrFreeSendContext(
       IN PSendRecvContext			pSendCtxt
       );
void
EventMgrFreeRecvContext(
       IN PSendRecvContext			pRecvCtxt
       );
void
EventMgrFreeAcceptContext(
       IN PAcceptContext			pAcceptCtxt
       );

#endif //_oviocontext_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\portmgmt.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    portmgmt.h

Abstract:

    Port pool management functions

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _portmgmt_h_
#define _portmgmt_h_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT	PortPoolStart	(void);
void	PortPoolStop	(void);

HRESULT PortPoolAllocRTPPort (
	OUT	WORD *	ReturnPort);

HRESULT PortPoolFreeRTPPort (
	IN	WORD	RtpPort);

#endif //_portmgmt_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\q931info.h ===
#ifndef __pxsvc_q931_h
#define __pxsvc_q931_h

#include "q931msg.h"
#include "ovioctx.h"
#include "crv.h"

/*---------------------------------------------------
Copyright (c) 1998, Microsoft Corporation
File: q931.h

Purpose: 

    Contains declarations specific to q931 processing that need
    not be present in cbridge.h.

History:

    1. created 
        Byrisetty Rajeev (rajeevb)  26-Aug-1998

---------------------------------------------------*/

// The H.225 spec calls for a 2 byte call reference value
typedef WORD    CALL_REF_TYPE;

// Q931 source side states
enum Q931_SOURCE_STATE
{
    Q931_SOURCE_STATE_NOT_INIT = 0,
    Q931_SOURCE_STATE_INIT,
    Q931_SOURCE_STATE_CON_ESTD,
    Q931_SOURCE_STATE_SETUP_RCVD,
    Q931_SOURCE_STATE_REL_COMP_RCVD
};

// Q931 destination side states
enum Q931_DEST_STATE
{
    Q931_DEST_STATE_NOT_INIT = 0,
    Q931_DEST_STATE_INIT,
    Q931_DEST_STATE_CON_ESTD,
    Q931_DEST_STATE_CALL_PROC_RCVD,
    Q931_DEST_STATE_ALERTING_RCVD,
    Q931_DEST_STATE_CONNECT_RCVD,
    Q931_DEST_STATE_REL_COMP_RCVD
};

#ifdef DBG
// CODEWORK: Define a static array of strings to use in dbg printfs
// where the array can be indexed by the state.

#endif DBG

// Q931_INFO


class Q931_INFO :
    public OVERLAPPED_PROCESSOR,
    public TIMER_PROCESSOR
{
public:

    inline Q931_INFO();

    inline void Init(
        IN H323_STATE   &H323State
        );

    inline CALL_REF_TYPE GetCallRefVal();

    virtual HRESULT SendCallback(
        IN      HRESULT                 CallbackHResult
        );

    virtual HRESULT ReceiveCallback(
        IN      HRESULT                 CallbackHResult,
        IN      BYTE                   *pBuf,
        IN      DWORD                   BufLen
        );

    // Implementation is provided by SOURCE_Q931_INFO and DEST_Q931_INFO
    virtual HRESULT ReceiveCallback(
        IN      Q931_MESSAGE            *pQ931Message,
        IN      H323_UserInformation     *pH323UserInfo
        ) = 0;
    
    HRESULT CreateTimer(DWORD TimeoutValue);
    
    virtual void TimerCallback();

    HRESULT SendReleaseCompletePdu();

    HRESULT QueueSend(
        IN  Q931_MESSAGE         *pQ931Message,
        IN  H323_UserInformation  *pH323UserInfo
        );
    
    // queue an asynchronous receive call back
    HRESULT QueueReceive();

	void IncrementLifetimeCounter  (void);
	void DecrementLifetimeCounter (void);

protected:

    // call reference value for this call (Q931 portion)
    // A Call Reference Value is generated for each outbound call.
    // The CRV in PDUs corresponding to outbound calls needs to be
    // replaced because the external H.323 endpoint sees the call
    // as coming from the proxy. No CRV replacement is required for inbound
    // calls. But we need to store the CRV so that we can send the
    // CallProceeding/ReleaseComplete PDUs.
    // This variable is initialized when we process the Setup PDU.
    // Note that the Call Reference Value also includes the Call Reference Flag
    // which indicates whether the PDU is sent by the originator (0) or
    // destination (1) of the call.
    // m_CallRefVal always stores the Call Reference Value that we send in
    // the PDUs. So, SOURCE_Q931_INFO CRV will have the CRV flag set (since
    // it sends to the source) and the DEST_Q931_INFO CRV will have this flag
    // zeroed (since it is the source from the destination's point of view.
    CALL_REF_TYPE       m_CallRefVal;
};

inline 
Q931_INFO::Q931_INFO(
    )
    : m_CallRefVal(0)
{
}

inline void
Q931_INFO::Init(
    IN H323_STATE   &H323State
    )
{
    // initialize the overlaped processor
    OVERLAPPED_PROCESSOR::Init(OPT_Q931, H323State);
}


class SOURCE_Q931_INFO :
    public Q931_INFO
{
public:

    inline SOURCE_Q931_INFO();

    inline void Init(
        IN SOURCE_H323_STATE   &SourceH323State
        );

    inline HRESULT SetIncomingSocket(
        IN	SOCKET			IncomingSocket,
		IN	SOCKADDR_IN *	LocalAddress,
		IN	SOCKADDR_IN *	RemoteAddress);

    inline DEST_Q931_INFO &GetDestQ931Info();

    inline SOURCE_H245_INFO &GetSourceH245Info();

    // TimerValue contains the timer value in seconds, for a timer event
    // to be created when a queued send completes
    HRESULT ProcessDestPDU(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    virtual ~SOURCE_Q931_INFO();

protected:

    Q931_SOURCE_STATE  m_Q931SourceState;

	// this should never be called
    virtual HRESULT AcceptCallback(
        IN	DWORD			Status,
        IN	SOCKET			Socket,
		IN	SOCKADDR_IN *	LocalAddress,
		IN	SOCKADDR_IN *	RemoteAddress);

    virtual HRESULT ReceiveCallback(
        IN      Q931_MESSAGE            *pQ931Message,
        IN      H323_UserInformation    *pH323UserInfo
        );

private:
    
    // processes PDUs when in Q931_SRC_CON_EST state
    HRESULT HandleStateSrcConEstd(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    // handles the release complete PDU - sends it to the
    // destination q931 instance, performs state transition and
    // initiates cleanup
    HRESULT HandleReleaseCompletePDU(
        IN  Q931_MESSAGE             *pQ931Message,
        IN  H323_UserInformation     *pH323UserInfo
        );

    // processes CONNECT PDU forwarded by the dest instance
    HRESULT ProcessConnectPDU(
        IN  Q931_MESSAGE             *pQ931Message,
        IN  H323_UserInformation     *pH323UserInfo
        );
};


inline 
SOURCE_Q931_INFO::SOURCE_Q931_INFO(
    )
    : m_Q931SourceState(Q931_SOURCE_STATE_NOT_INIT)
{
}

inline void
SOURCE_Q931_INFO::Init(
    IN SOURCE_H323_STATE   &SourceH323State
    )
{
    m_Q931SourceState = Q931_SOURCE_STATE_INIT;
    Q931_INFO::Init((H323_STATE &)SourceH323State);
}


class DEST_Q931_INFO :
    public Q931_INFO
{
public:

    inline DEST_Q931_INFO();

    inline HRESULT Init(
        IN DEST_H323_STATE   &DestH323State
        );

    inline SOURCE_Q931_INFO &GetSourceQ931Info();

    inline DEST_H245_INFO &GetDestH245Info();

    // processes PDUs received from the source Q931 instance
    // and directs them to the method for processing the
    // specific PDU
    HRESULT ProcessSourcePDU(
        IN  Q931_MESSAGE             *pQ931Message,
        IN  H323_UserInformation     *pH323UserInfo
        );

    virtual ~DEST_Q931_INFO();

protected:

    // state for the dest instance
    Q931_DEST_STATE  m_Q931DestState;

	// this method should never be called
    virtual HRESULT AcceptCallback(
        IN	DWORD			Status,
        IN	SOCKET			Socket,
		IN	SOCKADDR_IN *	LocalAddress,
		IN	SOCKADDR_IN *	RemoteAddress);

    virtual HRESULT ReceiveCallback (
        IN      Q931_MESSAGE             *pQ931Message,
        IN      H323_UserInformation     *pH323UserInfo
        );

private:

    // the following methods handle PDUs when the instance
    // is in a certain Q931 state

    HRESULT HandleStateDestConEstd(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    HRESULT HandleStateDestCallProcRcvd(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    HRESULT HandleStateDestAlertingRcvd(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    HRESULT HandleStateDestConnectRcvd(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );
        
    // the following methods handle a specific PDU for
    // any state of the Q931 instance. These are typically
    // called after the PDU has gone through one of the
    // HandleState* methods

    HRESULT HandleCallProceedingPDU(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    HRESULT HandleAlertingPDU(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    HRESULT HandleConnectPDU(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    // handles the release complete PDU - sends it to the
    // source q931 instance, performs state transition and
    // initiates cleanup
    HRESULT HandleReleaseCompletePDU(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    // the following methods process PDUs received from
    // the source Q931 instance

    // processes source Q.931 instance setup PDU
    HRESULT ProcessSourceSetupPDU(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    // other helper methods
    
    HRESULT ConnectToH323Endpoint(
		IN	SOCKADDR_IN *	DestinationAddress);

	HRESULT LookupDefaultDestination (
		OUT	DWORD *	ReturnAddress); // host order

	// if necessary, bring up the demand-dial interface
	HRESULT	ConnectDemandDialInterface	(void);

};


inline 
DEST_Q931_INFO::DEST_Q931_INFO(
    )
    : m_Q931DestState(Q931_DEST_STATE_NOT_INIT)
{   
}

inline HRESULT
DEST_Q931_INFO::Init(
    IN DEST_H323_STATE   &DestH323State
    )
{
    m_Q931DestState = Q931_DEST_STATE_INIT;
    Q931_INFO::Init((H323_STATE &)DestH323State);

    return S_OK;
}

void
Q931AsyncAcceptFunction (
    IN	PVOID	Context,
    IN	SOCKET	Socket,
    IN	SOCKADDR_IN *	LocalAddress,
    IN	SOCKADDR_IN *	RemoteAddress); 

HRESULT
Q931CreateBindSocket (
    void);

void Q931CloseSocket (
    void);

HRESULT Q931StartLoopbackRedirect (
    void);

void Q931StopLoopbackRedirect (
    void); 
 
extern SYNC_COUNTER	         Q931SyncCounter;
extern ASYNC_ACCEPT	         Q931AsyncAccept;
extern SOCKADDR_IN           Q931ListenSocketAddress;
extern HANDLE			     Q931LoopbackRedirectHandle;

#endif // __pxsvc_q931_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\q931io.h ===
#ifndef	__h323ics_q931io_h
#define	__h323ics_q931io_h



// this module DOES make use of the global sync counter (PxSyncCounter)
// declared in main.h


HRESULT	H323ProxyStart		(void);
void	H323ProxyStop		(void);
HRESULT H323Activate        (void);
void    H323Deactivate      (void);

#endif // __h323ics_q931io_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\q931io.cpp ===
#include "stdafx.h"

SYNC_COUNTER          Q931SyncCounter;
ASYNC_ACCEPT          Q931AsyncAccept;
SOCKADDR_IN           Q931ListenSocketAddress;
HANDLE                Q931LoopbackRedirectHandle;

static
HRESULT
Q931AsyncAcceptFunctionInternal (
    IN  PVOID         Context,
    IN  SOCKET        Socket,
    IN  SOCKADDR_IN * LocalAddress,
    IN  SOCKADDR_IN * RemoteAddress
    );


void
Q931AsyncAcceptFunction (
    IN  PVOID         Context,
    IN  SOCKET        Socket,
    IN  SOCKADDR_IN * LocalAddress,
    IN  SOCKADDR_IN * RemoteAddress
    )
{
    HRESULT Result;

    Result = Q931AsyncAcceptFunctionInternal (
                 Context,
                 Socket,
                 LocalAddress,
                 RemoteAddress
                 );

    if (S_OK != Result) {

        if (INVALID_SOCKET != Socket) {

            closesocket (Socket);

            Socket = INVALID_SOCKET;

        }
    }
}
        

static
HRESULT
Q931AsyncAcceptFunctionInternal (
    IN  PVOID         Context,
    IN  SOCKET        Socket,
    IN  SOCKADDR_IN * LocalAddress,
    IN  SOCKADDR_IN * RemoteAddress
    )
{
    CALL_BRIDGE * CallBridge;
    HRESULT       Result;
    NAT_KEY_SESSION_MAPPING_EX_INFORMATION  RedirectInformation;
    ULONG         RedirectInformationLength;
    ULONG         Error;
    DWORD         BestInterfaceAddress;

    DebugF (_T("Q931: ----------------------------------------------------------------------\n"));

#if DBG
    ExposeTimingWindow ();
#endif

    // a new Q.931 connection has been accepted from the network.
    // first, we determine the original addresses of the transport connection.
    // if the connection was redirected to our socket (due to NAT),
    // then the query of the NAT redirect table will yield the original transport addresses.
    // if an errant client has connected to our service, well, we really didn't
    // intend for that to happen, so we just immediately close the socket.

    assert (NatHandle);

    RedirectInformationLength = sizeof (RedirectInformation);

    Result = NatLookupAndQueryInformationSessionMapping (
        NatHandle,
        IPPROTO_TCP,
        LocalAddress -> sin_addr.s_addr,
        LocalAddress -> sin_port,
        RemoteAddress -> sin_addr.s_addr,
        RemoteAddress -> sin_port,
        &RedirectInformation,
        &RedirectInformationLength,
        NatKeySessionMappingExInformation);

    if (STATUS_SUCCESS != STATUS_SUCCESS) {

        DebugError (Result, _T("Q931: New connection was accepted, but it is not in the NAT redirect table -- connection will be rejected.\n"));

        return Result;
    }

    Error = GetBestInterfaceAddress (ntohl (RedirectInformation.DestinationAddress), &BestInterfaceAddress);

    if (ERROR_SUCCESS != Error) {

        if (WSAEHOSTUNREACH == Error) {
    
            Error = RasAutoDialSharedConnection ();
    
            if (ERROR_SUCCESS != Error) {
                
                DebugF (_T("Q931: RasAutoDialSharedConnection failed. Error=%d\n"), Error);
    
            }
    
        } else {
    
            DebugError (Error, _T("LDAP: Failed to get interface address for the destination.\n"));
            
            return HRESULT_FROM_WIN32 (Error);
        }

    }
    
    // based on the source address of the socket, we decide whether the connection
    // came from an internal or external client.  this will govern later decisions
    // on how the call is routed.

#if DBG
    BOOL          IsPrivateOrLocalSource;
    BOOL          IsPublicDestination;

    Result = ::IsPrivateAddress (ntohl (RedirectInformation.SourceAddress), &IsPrivateOrLocalSource);

    if (S_OK != Result) {

        return Result;
    }

    IsPrivateOrLocalSource = IsPrivateOrLocalSource || ::NhIsLocalAddress (RedirectInformation.SourceAddress);

    Result = ::IsPublicAddress (ntohl (RedirectInformation.DestinationAddress), &IsPublicDestination);

    if (S_OK != Result) {

        return Result;

    }

    if (::NhIsLocalAddress (RedirectInformation.SourceAddress) &&
        ::NhIsLocalAddress (RedirectInformation.DestinationAddress)) {

        Debug (_T("Q931: New LOCAL connection.\n"));

    } else {

        if (IsPrivateOrLocalSource && IsPublicDestination) {

            Debug (_T("Q931: New OUTBOUND connection.\n"));

        } else {

            Debug (_T("Q931: New INBOUND connection.\n"));
        }
    }
#endif // DBG

    DebugF (_T("Q931: Connection redirected: (%08X:%04X -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"),
        ntohl (RedirectInformation.SourceAddress),
        ntohs (RedirectInformation.SourcePort),
        ntohl (RedirectInformation.DestinationAddress),
        ntohs (RedirectInformation.DestinationPort),
        ntohl (RedirectInformation.NewSourceAddress),
        ntohs (RedirectInformation.NewSourcePort),
        ntohl (RedirectInformation.NewDestinationAddress),
        ntohs (RedirectInformation.NewDestinationPort));

    CallBridge = new CALL_BRIDGE (&RedirectInformation);

    if (!CallBridge) {

        DebugF (_T("Q931: Failed to allocate CALL_BRIDGE.\n"));

        return E_OUTOFMEMORY;
    }

    CallBridge -> AddRef ();

    // Add the call-bridge to the list. Doing so makes an additional reference
    // to the object, which is retained until the object is destroyed by calling
    // RemoveCallBridge.

    if (CallBridgeList.InsertCallBridge (CallBridge) == S_OK) {

         // should we check the local address or the caller's address ?
         // The problem is that if someone tries to connect to the
         // external IP address from inside, they will still probably succeed

        Result = CallBridge -> Initialize (
                                    Socket,
                                    LocalAddress,
                                    RemoteAddress,
                                    &RedirectInformation
                                    );
        
        if (Result != S_OK) {

            CallBridge -> TerminateExternal ();

            DebugF (_T("Q931: 0x%x accepted new client, but failed to initialize.\n"), CallBridge);

            // Probably there was something wrong with just this
            // Init failure. Continue to accept more Q.931 connections.
        } 
    }

    CallBridge -> Release ();

    return Result;
}


HRESULT
Q931CreateBindSocket (
    void
    )
{
    HRESULT            Result;
    SOCKADDR_IN        SocketAddress;

    SocketAddress.sin_family      = AF_INET;
    SocketAddress.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
    SocketAddress.sin_port        = htons (0);  // request dynamic port

    Result = Q931AsyncAccept.StartIo (
        &SocketAddress,
        Q931AsyncAcceptFunction,
        NULL
        );

    if (Result != S_OK) {

        DebugError (Result, _T("Q931: Failed to create and bind socket.\n"));

        return Result;
    }

    DebugF (_T("Q931: Asynchronous Accept started.\n"));

    Result = Q931AsyncAccept.GetListenSocketAddress (&Q931ListenSocketAddress);

    if (Result != S_OK) {

        DebugError (Result, _T("Q931: Failed to get listen socket address.\n"));

        return Result;

    }

    return S_OK;
}

void 
Q931CloseSocket (
    void
    )
{
    ZeroMemory ((PVOID)&Q931ListenSocketAddress, sizeof (SOCKADDR_IN));

    Q931AsyncAccept.StopWait ();
    
}


HRESULT 
Q931StartLoopbackRedirect (
    void
    ) 
{
    NTSTATUS Status;

    Status = NatCreateDynamicAdapterRestrictedPortRedirect (
        NatRedirectFlagLoopback | NatRedirectFlagSendOnly,
        IPPROTO_TCP,
        htons (Q931_TSAP_IP_TCP),
        Q931ListenSocketAddress.sin_addr.s_addr,
        Q931ListenSocketAddress.sin_port,
        ::NhMapAddressToAdapter (htonl (INADDR_LOOPBACK)),
        MAX_LISTEN_BACKLOG,
        &Q931LoopbackRedirectHandle);

    if (Status != STATUS_SUCCESS) {

        Q931LoopbackRedirectHandle = NULL;

        DebugError (Status, _T("Q931: Failed to create local dynamic redirect.\n"));
        
        return (HRESULT)Status;
    }

    DebugF (_T("Q931: Connections traversing loopback interface to port %04X will be redirected to %08X:%04X.\n"),
                Q931_TSAP_IP_TCP,
                SOCKADDR_IN_PRINTF (&Q931ListenSocketAddress));

    return (HRESULT) Status;
}


void 
Q931StopLoopbackRedirect (
    void
    ) 
{
    if (Q931LoopbackRedirectHandle) {

        NatCancelDynamicRedirect (Q931LoopbackRedirectHandle);

        Q931LoopbackRedirectHandle = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\sockinfo.cpp ===
#include "stdafx.h"
#include "sockinfo.h"

SOCKET_INFO::SOCKET_INFO (void)
	: Socket (INVALID_SOCKET)
{
	ZeroMemory (&LocalAddress,  sizeof (SOCKADDR_IN));
	ZeroMemory (&RemoteAddress, sizeof (SOCKADDR_IN));
	ZeroMemory (&TrivialRedirectDestAddress, sizeof (SOCKADDR_IN));
   	ZeroMemory (&TrivialRedirectSourceAddress,  sizeof (SOCKADDR_IN));

    IsNatRedirectActive = FALSE;
}

void 
SOCKET_INFO::Init (
	IN	SOCKET			ArgSocket,
	IN	SOCKADDR_IN *	ArgLocalAddress,
	IN	SOCKADDR_IN *	ArgRemoteAddress)
{
    assert (Socket == INVALID_SOCKET);
	assert (ArgSocket != INVALID_SOCKET);
	assert (ArgLocalAddress);
	assert (ArgRemoteAddress);

	Socket = ArgSocket;
	LocalAddress = *ArgLocalAddress;
	RemoteAddress = *ArgRemoteAddress;
}


int SOCKET_INFO::Init (
	IN	SOCKET			ArgSocket,
	IN	SOCKADDR_IN *	ArgRemoteAddress)
{
	INT		AddressLength;

	assert (Socket == INVALID_SOCKET);
	assert (ArgSocket != INVALID_SOCKET);

	AddressLength = sizeof (SOCKADDR_IN);

	if (getsockname (ArgSocket, (SOCKADDR *) &LocalAddress, &AddressLength)) {
		return WSAGetLastError();
	}

	Socket = ArgSocket;
	RemoteAddress = *ArgRemoteAddress;

    return ERROR_SUCCESS;
}

BOOLEAN
SOCKET_INFO::IsSocketValid (void) {
	return Socket != INVALID_SOCKET;
}

void
SOCKET_INFO::SetListenInfo (
	IN	SOCKET			ListenSocket,
	IN	SOCKADDR_IN *	ListenAddress)
{
	assert (Socket == INVALID_SOCKET);
	assert (ListenSocket != INVALID_SOCKET);
	assert (ListenAddress);

	Socket = ListenSocket;
	LocalAddress = *ListenAddress;
}

int
SOCKET_INFO::Connect(
	IN	SOCKADDR_IN *	ArgRemoteAddress)
{
	int Status;
    DWORD LocalToRemoteInterfaceAddress;

	INT   AddressSize = sizeof (SOCKADDR_IN);
    BOOL  KeepaliveOption;

	assert (Socket == INVALID_SOCKET);
	assert (ArgRemoteAddress);

    Status = GetBestInterfaceAddress (
            ntohl (ArgRemoteAddress -> sin_addr.s_addr), 
            &LocalToRemoteInterfaceAddress);

    if (ERROR_SUCCESS != Status) {
        DebugF (_T("Q931: Failed to get best interface for the destination %08X:%04X.\n"), 
                SOCKADDR_IN_PRINTF (ArgRemoteAddress));

        return Status;
    }

    LocalAddress.sin_family      = AF_INET;
    LocalAddress.sin_addr.s_addr = htonl (LocalToRemoteInterfaceAddress);
    LocalAddress.sin_port        = htons (0); 

    Socket = WSASocket (AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);

    if (Socket == INVALID_SOCKET) {

        Status = WSAGetLastError ();

		DebugF( _T("Q931: Destination %08X:%04X, failed to create socket"),
            SOCKADDR_IN_PRINTF (ArgRemoteAddress));

		DumpError (Status);
		
		return Status;

    }

    //
    // Set RCV and SND buffers to zero
    // for details look up bug# WinSE 31054, 691666 (read both 35928 and 33546). 
    //
    ULONG Option = 0;
    setsockopt( Socket, SOL_SOCKET, SO_SNDBUF,
                (PCHAR)&Option, sizeof(Option) );
    Option = 0;
    setsockopt( Socket, SOL_SOCKET, SO_SNDBUF,
                (PCHAR)&Option, sizeof(Option) );


    if (SOCKET_ERROR == bind(Socket, (PSOCKADDR)&LocalAddress, AddressSize)) {

        Status = WSAGetLastError ();

        DebugLastError (_T("Q931: Failed to bind dest socket.\n"));

        goto cleanup;
    }

    // Set keepalive on the socket
    KeepaliveOption = TRUE;
    if (SOCKET_ERROR == setsockopt (Socket, SOL_SOCKET, SO_KEEPALIVE,
                                   (PCHAR) &KeepaliveOption, sizeof (KeepaliveOption)))
    {
        Status = WSAGetLastError ();

        DebugLastError (_T("Q931: Failed to set keepalive on the dest socket.\n"));

        goto cleanup;

    }

    if (getsockname (Socket, (struct sockaddr *)&LocalAddress, &AddressSize)) {

        Status = WSAGetLastError ();

        DebugLastError (_T("Q931: Failed to get name of TCP socket.\n"));

        goto cleanup;
    }

    // Create a trivial redirect. This is used to disallow interception of
    // Q.931 connect-attempts by more general Q.931 dynamic port redirect established
    // during initialization of the proxy. As a side effect it helps to puncture
    // the firewall for both H.245 and Q.931 if the firewall is enabled.

    Status = CreateTrivialNatRedirect(
        ArgRemoteAddress,
        &LocalAddress,
        0
        );

    if(Status != S_OK) {
    
        goto cleanup;
    }

    RemoteAddress = *ArgRemoteAddress;

    // connect to the target server
	// -XXX- make this asynchronous some day!!!
    Status =  connect (Socket, (SOCKADDR *) ArgRemoteAddress, sizeof (SOCKADDR_IN));

    if(Status) {
        Status = WSAGetLastError ();

		goto cleanup;
    }

	Status = EventMgrBindIoHandle (Socket);
	if (Status != S_OK) {
		goto cleanup;
	}

    return ERROR_SUCCESS;

cleanup:

	Clear(TRUE);

    return Status;
}

HRESULT SOCKET_INFO::CreateTrivialNatRedirect (
    IN SOCKADDR_IN * ArgTrivialRedirectDestAddress,
    IN SOCKADDR_IN * ArgTrivialRedirectSourceAddress,
    IN ULONG RestrictedAdapterIndex)
{
    HRESULT Status = S_OK;
    ULONG   ErrorCode;
    ULONG   RedirectFlags = NatRedirectFlagLoopback;    

    _ASSERTE(ArgTrivialRedirectDestAddress);
    _ASSERTE(ArgTrivialRedirectSourceAddress);

    // Save redirect information. It will be needed when time comes to cancel the redirect.
    TrivialRedirectDestAddress.sin_addr.s_addr = ArgTrivialRedirectDestAddress->sin_addr.s_addr;
    TrivialRedirectDestAddress.sin_port = ArgTrivialRedirectDestAddress->sin_port;
   
    TrivialRedirectSourceAddress.sin_addr.s_addr = ArgTrivialRedirectSourceAddress->sin_addr.s_addr;
    TrivialRedirectSourceAddress.sin_port = ArgTrivialRedirectSourceAddress->sin_port;

    if(RestrictedAdapterIndex) {
    
        RedirectFlags |= NatRedirectFlagRestrictAdapter;
    }

    ErrorCode = NatCreateRedirectEx ( 
            NatHandle, 
            RedirectFlags,
            IPPROTO_TCP,            
            TrivialRedirectDestAddress.sin_addr.s_addr,     // destination address
            TrivialRedirectDestAddress.sin_port,            // destination port
            TrivialRedirectSourceAddress.sin_addr.s_addr,   // source addresss
            TrivialRedirectSourceAddress.sin_port,          // source port
            TrivialRedirectDestAddress.sin_addr.s_addr,     // new destination address
            TrivialRedirectDestAddress.sin_port,            // new destination port
            TrivialRedirectSourceAddress.sin_addr.s_addr,   // new source address
            TrivialRedirectSourceAddress.sin_port,          // new source port
            RestrictedAdapterIndex,                         // restricted adapter index
            NULL,                                           // completion routine
            NULL,                                           // completion context
            NULL);                                          // notify event

    if( NO_ERROR != ErrorCode) { 
        
        Status = GetLastErrorAsResult();
        
        DebugF (_T("H323: Failed to set up trivial redirect (%08X:%04X -> %08X:%04X) => (%08X:%04X -> %08X:%04X). Error - %d.\n"), 
                   SOCKADDR_IN_PRINTF(&TrivialRedirectSourceAddress), SOCKADDR_IN_PRINTF(&TrivialRedirectDestAddress),
                   SOCKADDR_IN_PRINTF(&TrivialRedirectSourceAddress), SOCKADDR_IN_PRINTF(&TrivialRedirectDestAddress),
                   ErrorCode);

    }
    else {
    
        DebugF (_T("H323: Set up trivial redirect (%08X:%04X -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"), 
               SOCKADDR_IN_PRINTF(&TrivialRedirectSourceAddress), SOCKADDR_IN_PRINTF(&TrivialRedirectDestAddress),
               SOCKADDR_IN_PRINTF(&TrivialRedirectSourceAddress), SOCKADDR_IN_PRINTF(&TrivialRedirectDestAddress));

        IsNatRedirectActive = TRUE;
    }

    return Status;
}

void SOCKET_INFO::Clear (BOOL CancelTrivialRedirect)
{
	if (Socket != INVALID_SOCKET) {
		closesocket (Socket);
		Socket = INVALID_SOCKET;
	}

    if (CancelTrivialRedirect && IsNatRedirectActive) {
        
        DebugF (_T("H323: Cancelling trivial redirect (%08X:%04X -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"), 
                   SOCKADDR_IN_PRINTF(&TrivialRedirectSourceAddress), SOCKADDR_IN_PRINTF(&TrivialRedirectDestAddress),
                   SOCKADDR_IN_PRINTF(&TrivialRedirectSourceAddress), SOCKADDR_IN_PRINTF(&TrivialRedirectDestAddress));

        NatCancelRedirect ( 
            NatHandle, 
            IPPROTO_TCP, 
            TrivialRedirectDestAddress.sin_addr.s_addr,     // destination address
            TrivialRedirectDestAddress.sin_port,            // destination port
            TrivialRedirectSourceAddress.sin_addr.s_addr,   // source addresss
            TrivialRedirectSourceAddress.sin_port,          // source port
            TrivialRedirectDestAddress.sin_addr.s_addr,     // new destination address
            TrivialRedirectDestAddress.sin_port,            // new destination port
            TrivialRedirectSourceAddress.sin_addr.s_addr,   // new source address
            TrivialRedirectSourceAddress.sin_port           // new source port
            );
            
        IsNatRedirectActive = FALSE;
    }
}

SOCKET_INFO::~SOCKET_INFO (void)
{
    Clear(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\sockinfo.h ===
#ifndef __h323ics_sockinfo_h_
#define __h323ics_sockinfo_h_

// This class abstracts a winsock socket
// contains the socket descriptor, local and remote addresses and ports
// corresponding to a winsock socket
struct SOCKET_INFO
{
public:

    SOCKET			Socket;
    
    SOCKADDR_IN		LocalAddress;
    SOCKADDR_IN		RemoteAddress;
    SOCKADDR_IN		TrivialRedirectSourceAddress;
    SOCKADDR_IN		TrivialRedirectDestAddress;
    
    BOOL            IsNatRedirectActive;

    SOCKET_INFO();

    void Init (
        IN	SOCKET			ArgSocket,
        IN	SOCKADDR_IN *	ArgLocalAddress,
        IN	SOCKADDR_IN *	ArgRemoteAddress);

    int Init (
        IN	SOCKET			ArgSocket,
        IN	SOCKADDR_IN *	ArgRemoteAddress);

	BOOLEAN IsSocketValid (void);

    void SetListenInfo (
        IN	SOCKET			ListenSocket,
        IN	SOCKADDR_IN *	ListenAddress);

    int Connect (
        IN	SOCKADDR_IN *	RemoteAddress);
		
    HRESULT CreateTrivialNatRedirect (
        IN SOCKADDR_IN * ArgTrivialRedirectDestAddress,
        IN SOCKADDR_IN * ArgTrivialRedirectSourceAddress,
        IN ULONG RestrictedAdapterIndex);

    void Clear (BOOL CancelTrivialRedirect);

    ~SOCKET_INFO();
};


#endif __h323ics_sockinfo_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\srcq931.cpp ===
#include "stdafx.h"
#include "cbridge.h"

// SOURCE_Q931_INFO methods

/* virtual */
SOURCE_Q931_INFO::~SOURCE_Q931_INFO(
    )
{
}


// this should never get called, but needs to be supported
// as the base class implementation is pure virtual
// virtual
HRESULT SOURCE_Q931_INFO::AcceptCallback (
    IN	DWORD			Status,
    IN	SOCKET			Socket,
	IN	SOCKADDR_IN *	LocalAddress,
	IN	SOCKADDR_IN *	RemoteAddress)
{
    // we should never receive an accept call back for the 
    // Q931 source instance
    _ASSERTE(FALSE);

    return E_UNEXPECTED;
}


// This function is called by the event manager.
// The caller will free the PDU. This function may modify
// some of the fields of the PDU.

// this is called when an async receive operation completes
// virtual
HRESULT SOURCE_Q931_INFO::ReceiveCallback (
    IN      Q931_MESSAGE             *pQ931Message,
    IN      H323_UserInformation     *pH323UserInfo
    )
{
    HRESULT HResult;
    
    // we must have valid decoded PDUs 
    _ASSERTE(NULL != pQ931Message);

    // The ASN.1 part is not present in the case of some PDUs
    //_ASSERTE(NULL != pH323UserInfo);

    // if RELEASE COMPLETE PDU
    if (pH323UserInfo != NULL &&
        releaseComplete_chosen ==
            pH323UserInfo->h323_uu_pdu.h323_message_body.choice)
    {
        DebugF (_T("Q931: 0x%x caller sent 'Release Complete'.\n"), &GetCallBridge ());
        HResult = HandleReleaseCompletePDU(
                    pQ931Message,
                    pH323UserInfo
                    );

		return HResult;
    }

    // check current state and handle the incoming PDU
    switch(m_Q931SourceState)
    {
    case Q931_SOURCE_STATE_CON_ESTD:
        {
            // processes PDUs when in Q931_SOURCE_STATE_CON_ESTD state
            HResult = HandleStateSrcConEstd(
                        pQ931Message,
                        pH323UserInfo
                        );
        }
        break;

    case Q931_SOURCE_STATE_SETUP_RCVD:
        {
            // Pass on the PDU to the Q931 destination instance which
            // passes it on after due modifications
            HResult = GetDestQ931Info().ProcessSourcePDU(
                        pQ931Message,
                        pH323UserInfo
                        );
        }
        break;

    case Q931_SOURCE_STATE_INIT:
    case Q931_SOURCE_STATE_REL_COMP_RCVD:
    default:
        {
            // we can't be in Q931_SOURCE_STATE_INIT as we wouldn't have
            // queued an async receive by then

            // we can't be in Q931_SOURCE_STATE_REL_COMP_RCVD as we not have
            // queued this receive

          // I.K. 0819999  _ASSERTE(FALSE);
            HResult = E_UNEXPECTED;
        }
        break;
    };

    // if there is an error
    if (FAILED(HResult))
    {
        goto shutdown;
    }

    // we must queue an async receive irrespective of whether
    // the PDU was dropped (IPTEL_E_INVALID_PDU == HResult)
    // queue an async receive
    HResult = QueueReceive();
    if (FAILED(HResult))
    {
        goto shutdown;
    }

    return HResult;

shutdown:

    // initiate shutdown
    GetCallBridge().Terminate ();

    return HResult;
}


// handles RELEASE_COMPLETE PDUs
HRESULT 
SOURCE_Q931_INFO::HandleReleaseCompletePDU(
    IN      Q931_MESSAGE             *pQ931Message,
    IN      H323_UserInformation     *pH323UserInfo 
    )
{
    // it must be a release complete PDU
    _ASSERTE(releaseComplete_chosen == \
                pH323UserInfo->h323_uu_pdu.h323_message_body.choice);

    // we can handle a RELEASE COMPLETE PDU in any state except the following
    _ASSERTE(Q931_SOURCE_STATE_INIT             != m_Q931SourceState);
    _ASSERTE(Q931_SOURCE_STATE_REL_COMP_RCVD    != m_Q931SourceState);

    // pass on the pdu to the Q931 source instance
    // ignore return error code, if any
    GetDestQ931Info().ProcessSourcePDU(
        pQ931Message,
        pH323UserInfo
        );
    //
    // NetMeeting client doesn't like the fact that we send RST right after
    // a ReleaseComplete. 
    // Yes, it is ugly and bad practice but this is a QFE 
    // for details look up bug# WinSE 31054, 691666 (read both 35928 and 33546). 
    //
    Sleep( 500 );

    // state transition to Q931_SOURCE_STATE_REL_COMP_RCVD
    m_Q931SourceState = Q931_SOURCE_STATE_REL_COMP_RCVD;

    // initiate shutdown - this cancels the timers, but doesn't close
	// the sockets. the sockets are closed when the send callback is made
    GetCallBridge().TerminateCallOnReleaseComplete();

	GetSocketInfo ().Clear (TRUE);

    return S_OK;
}


// processes PDUs when in Q931_SOURCE_STATE_CON_EST state
HRESULT
SOURCE_Q931_INFO::HandleStateSrcConEstd(
    IN      Q931_MESSAGE            *pQ931Message,
    IN      H323_UserInformation    *pH323UserInfo 
    )
{
	if (!pH323UserInfo) {
		DebugF(_T("SOURCE_Q931_INFO::HandleStateSrcConEstd: no UUIE data!  ignoring message.\n"));
		return E_INVALIDARG;
	}

    // we can only handle a setup PDU in this state
    // all other PDUs are THROWN AWAY (as we don't know 
    // whom to pass it to)

    if (setup_chosen != pH323UserInfo->h323_uu_pdu.h323_message_body.choice)
    {
		DebugF(
			_T("SOURCE_Q931_INFO::HandleStateSrcConEstd: received a pdu other than Setup before receiving a Setup, pdu cannot be processed\n"));
        return E_INVALIDARG;
    }

	// save the caller's call reference value now as we may reuse the
	// PDU structure in ProcessSourcePDU
    // The Setup PDU is sent by the originator and so the call reference flag
    // should not be set.
	// -XXX- this should not be an assert!!!! FIX THIS! -- arlied
    _ASSERTE(!(pQ931Message->CallReferenceValue & CALL_REF_FLAG));
	m_CallRefVal = pQ931Message->CallReferenceValue | CALL_REF_FLAG;

    // pass on the setup pdu to the Q931 destination instance
    HRESULT HResult = GetDestQ931Info().ProcessSourcePDU(
                        pQ931Message,
                        pH323UserInfo
                        );

    if (FAILED (HResult))
    {
        return HResult;
    }
    
    // state transition to Q931_SOURCE_STATE_SETUP_RCVD
    m_Q931SourceState = Q931_SOURCE_STATE_SETUP_RCVD;


	// try to create a CALL PROCEEDING PDU
	// if we fail, don't try to recover
	// Q.931 requires that gateways in the call path must identify 
	// themselves to the callee
	Q931_MESSAGE CallProcQ931Message;
	H323_UserInformation CallProcH323UserInfo;
	HResult = Q931EncodeCallProceedingMessage(
					m_CallRefVal,
				    &CallProcQ931Message,
				    &CallProcH323UserInfo
					);

	// try to send a CALL PROCEEDING PDU to the caller
	// if we fail, don't try to recover

    HResult = QueueSend(
				&CallProcQ931Message, 
				&CallProcH323UserInfo);

    return HResult;
}


// TimerValue contains the timer value in seconds, for a timer event
// to be created when a queued send completes
HRESULT 
SOURCE_Q931_INFO::ProcessDestPDU(
    IN      Q931_MESSAGE            *pQ931Message,
    IN      H323_UserInformation    *pH323UserInfo
    )
{
    HRESULT HResult = E_FAIL;

    // handle PDU from the source Q931 instance
    switch(m_Q931SourceState)
    {
    case Q931_SOURCE_STATE_SETUP_RCVD:
        {
			if (connect_chosen == 
				pH323UserInfo->h323_uu_pdu.h323_message_body.choice)
			{
                DebugF (_T("Q931: 0x%x forwarding 'Connect' to caller.\n"), &GetCallBridge ());
				HResult = ProcessConnectPDU(
							pQ931Message, 
							pH323UserInfo
							);
                if (FAILED(HResult))
                {
	                DebugF(_T("SOURCE_Q931_INFO::ProcessDestPDU: ProcessConnectPDU failed, returning %x\n"),
                        HResult);
                    return HResult;
                }
			}
        }
        break;

    case Q931_SOURCE_STATE_INIT:
    case Q931_SOURCE_STATE_CON_ESTD:
    case Q931_SOURCE_STATE_REL_COMP_RCVD:
    default:
        {
			DebugF( _T("SOURCE_Q931_INFO::ProcessDestPDU: bogus state, returning E_UNEXPECTED\n"));
            return E_UNEXPECTED;
        }
        break;
    };

	// Q931 Header - CallReferenceValue
	// pQ931Message->CallReferenceValue = GetCallRefVal();

    // queue async send for the PDU
    HResult = QueueSend(pQ931Message, pH323UserInfo);
    if (HResult != S_OK) {
	    DebugF( _T("SOURCE_Q931_INFO::ProcessDestPDU: failed to queue sendreturning %x\n"), HResult);
		return HResult;
    }
   
    return HResult;
}


// NOTE: CRV modification is handled in ProcessDestPDU
HRESULT 
SOURCE_Q931_INFO::ProcessConnectPDU(
    IN      Q931_MESSAGE             *pQ931Message,
    IN      H323_UserInformation     *pH323UserInfo 
    )
{
	Connect_UUIE *	Connect;
	HRESULT			Result;
	SOCKADDR_IN		H245ListenAddress;

	// it must be a CONNECT PDU
	_ASSERTE(connect_chosen == pH323UserInfo->h323_uu_pdu.h323_message_body.choice);

	Connect = &pH323UserInfo -> h323_uu_pdu.h323_message_body.u.connect;

	// we must have already checked to see if an h245 transport
	// address was specified by the callee in the dest instance
	_ASSERTE(Connect_UUIE_h245Address_present & Connect -> bit_mask);
	_ASSERTE(ipAddress_chosen & Connect -> h245Address.choice);

	// queue an overlapped accept, get ready to accept an incoming
	// connection on the local address/port

    H245ListenAddress.sin_addr.s_addr = htonl (GetCallBridge (). GetSourceInterfaceAddress ());
    H245ListenAddress.sin_port = htons (0);

	Result = GetSourceH245Info().ListenForCaller (&H245ListenAddress);
	if (FAILED (Result))
	{
		DebugF (_T("H245: 0x%x failed to listen for caller.\n"), &GetCallBridge ());

		return Result;
	}
    //_ASSERTE(S_FALSE != HResult);

	// replace the h245 address/port in the connect PDU
	FillTransportAddress (H245ListenAddress, Connect -> h245Address);

    DebugF (_T("H245: 0x%x listens for H.245 connection from caller on %08X:%04X.\n"),
                &GetCallBridge (),
                SOCKADDR_IN_PRINTF (&H245ListenAddress));
            
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\rtplc.cpp ===
#include "stdafx.h"
#include "portmgmt.h"
#include "timerval.h"
#include "cbridge.h"
#include "main.h"


// destructor
// virtual
RTP_LOGICAL_CHANNEL::~RTP_LOGICAL_CHANNEL (void)
{
	// close NAT mappings
	CloseNATMappings();

    // release reference to any associated channel or allocated ports
	ReleaseAssociationAndPorts();
}


/*++
  Release ports only if there is no associated channel. If there is an
  associated channel the ports will be freed when it is deleted. Note that
  a logical channel could be closed and reopened again.
--*/

inline void 
RTP_LOGICAL_CHANNEL::ReleaseAssociationAndPorts()
{
    // if there is an associated logical channel
    if (NULL != m_pAssocLogicalChannel)
    {
        //  release reference to it
        m_pAssocLogicalChannel->ResetAssociationRef();
        m_pAssocLogicalChannel = NULL;
    }
    else
    {
        if (m_OwnSourceRecvRTPPort != 0)
            PortPoolFreeRTPPort(m_OwnSourceRecvRTPPort);
        if (m_OwnAssocLCRecvRTPPort != 0)
            PortPoolFreeRTPPort(m_OwnAssocLCRecvRTPPort);
        if (m_OwnDestSendRTPPort != 0)
            PortPoolFreeRTPPort(m_OwnDestSendRTPPort);
        if (m_OwnAssocLCSendRTPPort != 0)
            PortPoolFreeRTPPort(m_OwnAssocLCSendRTPPort);
        m_OwnSourceRecvRTPPort  = m_OwnSourceRecvRTCPPort   = 0;
        m_OwnAssocLCRecvRTPPort = m_OwnDestRecvRTCPPort     = 0;
        m_OwnDestSendRTPPort    = m_OwnDestSendRTCPPort     = 0;
        m_OwnAssocLCSendRTPPort = m_OwnSourceSendRTCPPort   = 0;
    }
}

/*++
 This function is called after the OLC is received.
 --*/

HRESULT
RTP_LOGICAL_CHANNEL::SetPorts (void)
{
	HRESULT HResult = E_FAIL;

	// if there is an associated LC, copy all the ports from that LC.
	// else, allocate them now
    if (NULL != m_pAssocLogicalChannel)
    {
        // tell the associated logical channel that we are associated
        // with it
        m_pAssocLogicalChannel->SetAssociationRef(*this);

        // save the associated channel's own source/dest ports
		// assoc channel's source ports become our dest ports and vice versa
        m_OwnDestRecvRTCPPort	= m_pAssocLogicalChannel->m_OwnSourceRecvRTCPPort;
        m_OwnSourceRecvRTCPPort	= m_pAssocLogicalChannel->m_OwnDestRecvRTCPPort;

        m_OwnDestSendRTCPPort	= m_pAssocLogicalChannel->m_OwnSourceSendRTCPPort;
        m_OwnSourceSendRTCPPort	= m_pAssocLogicalChannel->m_OwnDestSendRTCPPort;

        // Copy the RTP ports
        m_OwnSourceRecvRTPPort  = m_pAssocLogicalChannel->m_OwnAssocLCRecvRTPPort;
        m_OwnAssocLCRecvRTPPort = m_pAssocLogicalChannel->m_OwnSourceRecvRTPPort;

        m_OwnDestSendRTPPort    = m_pAssocLogicalChannel->m_OwnAssocLCSendRTPPort;
        m_OwnAssocLCSendRTPPort = m_pAssocLogicalChannel->m_OwnDestSendRTPPort;
    }
    else
    {
        // allocate own ports - the portmgt apis return an even port only (RTP)
        // and the assumption is that the RTCP port = RTP port + 1
		// however, we use the odd port for receiving RTCP and the even
		// port for sending RTP
        HResult = PortPoolAllocRTPPort (&m_OwnSourceRecvRTPPort);
        if (FAILED(HResult))
        {
            DebugF( _T("RTP_LOGICAL_CHANNEL::SetPorts")
				_T("failed to allocate m_OwnSourceRecvRTPPort, returning 0x%x\n"),
                HResult);
            goto cleanup;
        }
        m_OwnSourceRecvRTCPPort = m_OwnSourceRecvRTPPort + 1;

        HResult = PortPoolAllocRTPPort (&m_OwnAssocLCRecvRTPPort);
        if (FAILED(HResult))
        {
            DebugF( _T("RTP_LOGICAL_CHANNEL::SetPorts")
				_T("failed to allocate m_OwnAssocLCRecvRTPPort, returning 0x%x\n"),
                HResult);
            goto cleanup;
        }
        m_OwnDestRecvRTCPPort = m_OwnAssocLCRecvRTPPort + 1;

        HResult = PortPoolAllocRTPPort (&m_OwnDestSendRTPPort);
        if (FAILED(HResult))
        {
            DebugF( _T("RTP_LOGICAL_CHANNEL::SetPorts")
				_T("failed to allocate m_OwnDestSendRTPPort, returning 0x%x\n"),
                HResult);
            goto cleanup;
        }
        m_OwnDestSendRTCPPort = m_OwnDestSendRTPPort + 1;

        HResult = PortPoolAllocRTPPort (&m_OwnAssocLCSendRTPPort);
        if (FAILED(HResult))
        {
            DebugF( _T("RTP_LOGICAL_CHANNEL::SetPorts, ")
                _T("failed to allocate m_OwnAssocLCSendRTPPort, returning 0x%x\n"),
                HResult);
            goto cleanup;
        }
        m_OwnSourceSendRTCPPort = m_OwnAssocLCSendRTPPort + 1;
    }
    
	DebugF (_T("RTP : 0x%x using ports %04X, %04X, %04X, %04X.\n"),
            &GetCallBridge (),
            m_OwnSourceRecvRTPPort, m_OwnAssocLCRecvRTPPort,
            m_OwnDestSendRTPPort, m_OwnAssocLCSendRTPPort);

	DebugF (_T("RTCP: 0x%x using ports %04X, %04X, %04X, %04X.\n"),
            &GetCallBridge (),
            m_OwnSourceRecvRTCPPort, m_OwnDestRecvRTCPPort,
            m_OwnDestSendRTCPPort, m_OwnSourceSendRTCPPort);

	return S_OK;

 cleanup:
    if (m_OwnSourceRecvRTPPort != 0)
        PortPoolFreeRTPPort(m_OwnSourceRecvRTPPort);
    if (m_OwnAssocLCRecvRTPPort != 0)
        PortPoolFreeRTPPort(m_OwnAssocLCRecvRTPPort);
    if (m_OwnDestSendRTPPort != 0)
        PortPoolFreeRTPPort(m_OwnDestSendRTPPort);
    if (m_OwnAssocLCSendRTPPort != 0)
        PortPoolFreeRTPPort(m_OwnAssocLCSendRTPPort);
    m_OwnSourceRecvRTPPort  = m_OwnSourceRecvRTCPPort   = 0;
    m_OwnAssocLCRecvRTPPort = m_OwnDestRecvRTCPPort     = 0;
    m_OwnDestSendRTPPort    = m_OwnDestSendRTCPPort     = 0;
    m_OwnAssocLCSendRTPPort = m_OwnSourceSendRTCPPort   = 0;
    
    return HResult;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines for setting up and tearing down NAT Redirects                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


// opens the forward RTP, forward RTCP and reverse RTCP streams
// This function is called after the OLCAck is received.
HRESULT
RTP_LOGICAL_CHANNEL::OpenNATMappings(
	)
{
    // open NAT mapping for source -> dest RTP stream
	// this is the forward RTP stream and we must always open this

	NTSTATUS	Status;
	ULONG RedirectFlags = NatRedirectFlagNoTimeout;

	if (m_OwnDestIPv4Address == m_DestIPv4Address ||
		m_SourceIPv4Address  == m_OwnSourceIPv4Address)
	{
		RedirectFlags |= NatRedirectFlagLoopback;
	}

	Status = NatCreateRedirectEx (
            NatHandle,
			RedirectFlags,	                // flags
			IPPROTO_UDP,				    // UDP
			htonl(m_OwnSourceIPv4Address),	// source packet dest address (local)
			htons(m_OwnSourceRecvRTPPort),	// source packet dest port (local)
			htonl(0),			            // wildcard - source packet source address
			htons(0),			            // wildcard - source packet source port
			htonl(m_DestRTPIPv4Address),	// NewDestinationAddress
			htons(m_DestRTPPort),			// NewDestinationPort
			htonl(m_OwnDestIPv4Address),	// NewSourceAddress
			htons(m_OwnDestSendRTPPort),	// NewSourcePort
            NULL,                           // RestrictedAdapterIndex
			NULL,                   		// CompletionRoutine
			NULL,							// CompletionContext
            NULL);                          // NotifyEvent

	if (Status != NO_ERROR) {
	
        DebugF (_T("RTP : 0x%x failed to set up redirect for forward RTP stream: (*:* -> %08X:%04X) => (%08X:%04X -> %08X:%04X). Error - %d.\n"),
            &GetCallBridge (),
    		m_OwnSourceIPv4Address,		    
    		m_OwnSourceRecvRTPPort,		    
    		m_OwnDestIPv4Address,		    
    		m_OwnDestSendRTPPort,		    
    		m_DestRTPIPv4Address,		    
            m_DestRTPPort,			        
            Status);

		return E_FAIL;
	} 
	else {
	
    	DebugF (_T("RTP : 0x%x set up redirect for forward RTP stream: (*:* -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"),
            &GetCallBridge (),
    		m_OwnSourceIPv4Address,		
    		m_OwnSourceRecvRTPPort,		
    		m_OwnDestIPv4Address,		
    		m_OwnDestSendRTPPort,		
    		m_DestRTPIPv4Address,		
            m_DestRTPPort);			    
    }

	// check to see if we must open the RTCP streams in both directions
	// source <-> dest
	
	// if there is no associated logical channel or the assoc logical
	// channel is in neither LC_STATE_OPEN_ACK_RCVD nor 
	// LC_STATE_OPENED_CLOSE_RCVD, we must open the RTCP streams
	if ((!m_pAssocLogicalChannel) ||
		 ((LC_STATE_OPEN_ACK_RCVD != m_pAssocLogicalChannel -> m_LogicalChannelState) &&
		 (LC_STATE_OPENED_CLOSE_RCVD != m_pAssocLogicalChannel -> m_LogicalChannelState))) {

		// open NAT mapping for forward RTCP stream
		Status = NatCreateRedirectEx (
			NatHandle,
			RedirectFlags,	                // flags
			IPPROTO_UDP,				    // UDP
			htonl(m_OwnSourceIPv4Address),	// source packet dest address (local)
			htons(m_OwnSourceRecvRTCPPort),	// source packet dest port (local)
			htonl(0),				        // wildcard - source packet source address
			htons(0),				        // wildcard - source packet source port
			htonl(m_DestRTCPIPv4Address),	// NewDestinationAddress
			htons(m_DestRTCPPort),			// NewDestinationPort
			htonl(m_OwnDestIPv4Address),	// NewSourceAddress
			htons(m_OwnDestSendRTCPPort),	// NewSourcePort
            NULL,                           // RestrictedAdapterIndex
			NULL,                           // CompletionRoutine
			NULL,							// CompletionContext
			NULL);                          // NotifyEvent

		if (Status != NO_ERROR) {
			// close the forward RTP stream
			// ignore error code

		    DebugF (_T("RTCP: 0x%x failed to set up redirect for forward RCTP stream: (*:* -> %08X:%04X) => (%08X:%04X -> %08X:%04X). Error - %d.\n"),
                &GetCallBridge (),
                m_OwnSourceIPv4Address,		
                m_OwnSourceRecvRTCPPort,	
                m_OwnDestIPv4Address,		
                m_OwnDestSendRTCPPort,		
                m_DestRTCPIPv4Address,		
                m_DestRTCPPort,
                Status);

			NatCancelRedirect (
                NatHandle,
				IPPROTO_UDP,					// UDP
				htonl(m_OwnSourceIPv4Address),	// source packet dest address (local)
				htons(m_OwnSourceRecvRTPPort),	// source packet dest port (local)
				htonl(0),						// wildcard - source packet source address
				htons(0),						// wildcard - source packet source port
				htonl(m_DestRTPIPv4Address),	// NewDestinationAddress
				htons(m_DestRTPPort),			// NewDestinationPort
				htonl(m_OwnDestIPv4Address),	// NewSourceAddress
				htons(m_OwnDestSendRTPPort));	// NewSourcePort

			return E_FAIL;
		}
		else {
		
		    DebugF (_T("RTCP: 0x%x set up redirect for forward RCTP stream: (*:* -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"),
                &GetCallBridge (),
                m_OwnSourceIPv4Address,		// source packet dest address (local)
                m_OwnSourceRecvRTCPPort,	// source packet dest port (local)
                m_OwnDestIPv4Address,		// NewSourceAddress
                m_OwnDestSendRTCPPort,		// NewSourcePort
                m_DestRTCPIPv4Address,		// NewDestinationAddress
                m_DestRTCPPort);			// NewDestinationPort
        }

		// open NAT mapping for reverse RTCP stream
		Status = NatCreateRedirectEx (
            NatHandle,
			RedirectFlags,						// flags
			IPPROTO_UDP,		// UDP
			htonl(m_OwnDestIPv4Address),	// source packet dest address (local)
			htons(m_OwnDestRecvRTCPPort),	// source packet dest port (local)
			htonl(0),			// wildcard - source packet source address
			htons(0),			// wildcard - source packet source port
			htonl(m_SourceRTCPIPv4Address),	// NewDestinationAddress
			htons(m_SourceRTCPPort),		// NewDestinationPort
			htonl(m_OwnSourceIPv4Address),	// NewSourceAddress
			htons(m_OwnSourceSendRTCPPort),	// NewSourcePort
            NULL,                           // RestrictedAdapterIndex
			NULL,                           // CompletionRoutine
			NULL,							// CompletionContext
            NULL);                          // NotifyEvent

		if (Status != NO_ERROR) {
		
	        DebugF (_T("RTCP: 0x%x failed to set up redirect for reverse RTCP stream: (*:* -> %08X:%04X) => (%08X:%04X -> %08X:%04X). Error - %d.\n"),
                &GetCallBridge (),
                m_OwnDestIPv4Address,			
                m_OwnDestRecvRTCPPort,			
                m_OwnSourceIPv4Address,			
                m_OwnSourceSendRTCPPort,		
                m_SourceRTCPIPv4Address,		
                m_SourceRTCPPort,				
                Status);
                
			// close the forward RTP stream
			// ignore error code

			NatCancelRedirect(
                NatHandle,
				IPPROTO_UDP,					// UDP
				htonl(m_OwnSourceIPv4Address),	// source packet dest address (local)
				htons(m_OwnSourceRecvRTPPort),	// source packet dest port (local)
				htonl(0),						// wildcard - source packet source address
				htons(0),						// wildcard - source packet source port
				htonl(m_DestRTPIPv4Address),	// NewDestinationAddress
				htons(m_DestRTPPort),			// NewDestinationPort
				htonl(m_OwnDestIPv4Address),	// NewSourceAddress
				htons(m_OwnDestSendRTPPort)		// NewSourcePort
				);

			// close the forward RTCP stream
			// ignore error code
			NatCancelRedirect(
                NatHandle,
				IPPROTO_UDP,					// UDP
				htonl(m_OwnSourceIPv4Address),	// source packet dest address (local)
				htons(m_OwnSourceRecvRTCPPort),	// source packet dest port (local)
				htonl(0),						// wildcard - source packet source address
				htons(0),						// wildcard - source packet source port
				htonl(m_DestRTCPIPv4Address),	// NewDestinationAddress
				htons(m_DestRTCPPort),			// NewDestinationPort
				htonl(m_OwnDestIPv4Address),	// NewSourceAddress
				htons(m_OwnDestSendRTCPPort)	// NewSourcePort
				);

			return E_FAIL;
		}
		else {
		
	        DebugF (_T("RTCP: 0x%x set up redirect for reverse RTCP stream: (*:* -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"),
                &GetCallBridge (),
                m_OwnDestIPv4Address,			
                m_OwnDestRecvRTCPPort,			
                m_OwnSourceIPv4Address,			
                m_OwnSourceSendRTCPPort,		
                m_SourceRTCPIPv4Address,		
                m_SourceRTCPPort);				
       }

	}

	return S_OK;
}


void
RTP_LOGICAL_CHANNEL::CloseNATMappings(
	)
{
	// if our current state is LC_STATE_OPEN_ACK_RCVD or 
	// LC_STATE_OPENED_CLOSE_RCVD, we have a forward RTP NAT mapping
	// we may also have to close the RTCP mappings
	if ( (LC_STATE_OPEN_ACK_RCVD	 == m_LogicalChannelState) ||
		 (LC_STATE_OPENED_CLOSE_RCVD == m_LogicalChannelState)  )
	{

        DebugF (_T ("RTP : 0x%x cancels forward RTP  redirect (*:* -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"),
            &GetCallBridge (),
			m_OwnSourceIPv4Address,	// source packet dest address (local)
			m_OwnSourceRecvRTPPort,		// source packet dest port (local)
			m_OwnDestIPv4Address,	// NewSourceAddress
			m_OwnDestSendRTPPort,	// NewSourcePort
			m_DestRTPIPv4Address,	// NewDestinationAddress
			m_DestRTPPort			// NewDestinationPort
			);
		// cancel forward RTP NAT mapping
		// ignore error code
		ULONG Win32ErrorCode = NO_ERROR;
		Win32ErrorCode = NatCancelRedirect(
                NatHandle,
				IPPROTO_UDP,					// UDP
				htonl(m_OwnSourceIPv4Address),	// source packet dest address (local)
				htons(m_OwnSourceRecvRTPPort),	// source packet dest port (local)
				htonl(0),						// wildcard - source packet source address
				htons(0),						// wildcard - source packet source port
				htonl(m_DestRTPIPv4Address),	// NewDestinationAddress
				htons(m_DestRTPPort),			// NewDestinationPort
				htonl(m_OwnDestIPv4Address),	// NewSourceAddress
				htons(m_OwnDestSendRTPPort)		// NewSourcePort
            );

		// if we don't have an associated logical channel or its in neither
		// LC_STATE_OPEN_ACK_RCVD nor LC_STATE_OPENED_CLOSE_RCVD, we
		// must close the forward and reverse RTCP NAT mappings
		if ( (NULL == m_pAssocLogicalChannel) ||
			 ( (LC_STATE_OPEN_ACK_RCVD	 != 
					m_pAssocLogicalChannel->m_LogicalChannelState) &&
			   (LC_STATE_OPENED_CLOSE_RCVD != 
					m_pAssocLogicalChannel->m_LogicalChannelState)  ) )
		{
            DebugF (_T ("RTCP: 0x%x cancels forward RTCP redirect (*:* -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"),
                &GetCallBridge (),
				m_OwnSourceIPv4Address,		// source packet dest address (local)
				m_OwnSourceRecvRTCPPort,	// source packet dest port (local)
				m_OwnDestIPv4Address,		// NewSourceAddress
				m_OwnDestSendRTCPPort, 		// NewSourcePort
				m_DestRTCPIPv4Address,		// NewDestinationAddress
				m_DestRTCPPort				// NewDestinationPort
				);
			// cancel forward RTCP NAT mapping
			// ignore error code
 			Win32ErrorCode = NatCancelRedirect(
                    NatHandle,
					IPPROTO_UDP,						// UDP
					htonl(m_OwnSourceIPv4Address),		// source packet dest address (local)
					htons(m_OwnSourceRecvRTCPPort),		// source packet dest port (local)
					htonl(0),							// wildcard - source packet source address
					htons(0),							// wildcard - source packet source port
					htonl(m_DestRTCPIPv4Address),		// NewDestinationAddress
					htons(m_DestRTCPPort),				// NewDestinationPort
					htonl(m_OwnDestIPv4Address),		// NewSourceAddress
					htons(m_OwnDestSendRTCPPort) 		// NewSourcePort
                );

            DebugF (_T ("RTCP: 0x%x cancels reverse RTCP redirect (*:* -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"),
                &GetCallBridge (),
				m_OwnDestIPv4Address,		// source packet dest address (local)
				m_OwnDestRecvRTCPPort,		// source packet dest port (local)
				m_OwnSourceIPv4Address,		// NewSourceAddress
				m_OwnSourceSendRTCPPort,	// NewSourcePort
				m_SourceRTCPIPv4Address,	// NewDestinationAddress
				m_SourceRTCPPort			// NewDestinationPort
				);
			// close the reverse RTCP stream
			// ignore error code
			Win32ErrorCode = NatCancelRedirect(
                    NatHandle,
					IPPROTO_UDP,				// UDP
					htonl(m_OwnDestIPv4Address),	
						// source packet dest address (local)
					htons(m_OwnDestRecvRTCPPort),		
						// source packet dest port (local)
					htonl(0),		// wildcard - source packet source address
					htons(0),		// wildcard - source packet source port
					htonl(m_SourceRTCPIPv4Address),	// NewDestinationAddress
					htons(m_SourceRTCPPort),		// NewDestinationPort
					htonl(m_OwnSourceIPv4Address),	// NewSourceAddress
					htons(m_OwnSourceSendRTCPPort)	// NewSourcePort
                );
		}
	}
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines for processing H.245 PDUs                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT
RTP_LOGICAL_CHANNEL::HandleOpenLogicalChannelPDU(
	IN H245_INFO							&H245Info,
    IN MEDIA_TYPE                           MediaType,
	IN DWORD								LocalIPv4Address,
	IN DWORD								RemoteIPv4Address,
	IN DWORD								OtherLocalIPv4Address,
	IN DWORD								OtherRemoteIPv4Address,
	IN WORD									LogicalChannelNumber,
	IN BYTE									SessionId,
	IN RTP_LOGICAL_CHANNEL					*pAssocLogicalChannel,
	IN DWORD								SourceRTCPIPv4Address,
	IN WORD									SourceRTCPPort,
    IN      MultimediaSystemControlMessage   *pH245pdu
    )
/*++

Routine Description:

    
Arguments:
    
Return Values:

    S_OK on success.
    E_INVALIDARG if the PDU is invalid.

--*/
{
	// this should be the first call to this instance after its
	// created - hence, these fields must be as asserted
	_ASSERTE(LC_STATE_NOT_INIT == m_LogicalChannelState);
    _ASSERTE(NULL == m_pH245Info);
    _ASSERTE(NULL == m_pAssocLogicalChannel);

	HRESULT HResult = E_FAIL;

    m_pH245Info             = &H245Info;

    // the destructor will try to release associations, so assign the
    // associated logical channel now
    m_pAssocLogicalChannel = pAssocLogicalChannel;

	// set the local/remote addresses for our and the other h245 instance
	m_OwnSourceIPv4Address	= LocalIPv4Address;
	m_SourceIPv4Address		= RemoteIPv4Address;
	m_OwnDestIPv4Address	= OtherLocalIPv4Address;
	m_DestIPv4Address		= OtherRemoteIPv4Address;

    m_LogicalChannelNumber  = LogicalChannelNumber;
    m_SessionId             = SessionId;
    m_MediaType             = MediaType;  //  XXX

    m_SourceRTCPIPv4Address = SourceRTCPIPv4Address;
    m_SourceRTCPPort        = SourceRTCPPort;

	// set the rtp and rtcp ports on the source and dest side
	// if there is a logical channel, then, just the rtcp ports will be shared
	HResult = SetPorts();
	if (FAILED(HResult))
	{
        DebugF( _T("RTP_LOGICAL_CHANNEL::HandleOpenLogicalChannelPDU, ")
            _T("failed to set its ports, returning 0x%x\n"),
            HResult);
        return HResult;
    }
	//_ASSERTE(S_FALSE != HResult);


    OpenLogicalChannel &OlcPDU = 
        pH245pdu->u.request.u.openLogicalChannel;
    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters & MultiplexParams = 
        OlcPDU.forwardLogicalChannelParameters.multiplexParameters;
    H2250LogicalChannelParameters &H2250Params =
        MultiplexParams.u.h2250LogicalChannelParameters;

    // modify the OLC PDU by replacing the RTCP address/port
	// with the h245 address and RTCP port
	FillH245TransportAddress(
		m_OwnDestIPv4Address,
		m_OwnDestRecvRTCPPort,
		H2250Params.mediaControlChannel);

    // Should the part below be pushed into H245_INFO::HandleOpenLogicalChannelPDU ?????
    // let the other H245 instance process the PDU
    HResult = m_pH245Info->GetOtherH245Info().ProcessMessage(
                pH245pdu
                );
    if (FAILED(HResult))
    {
		DebugF(_T("RTP_LOGICAL_CHANNEL::HandleOpenLogicalChannelPDU: other H245 instance failed to process OLC PDU, returning 0x%x\n"), HResult);
        return HResult;
    }

	// start timer for a response
	// TO DO *** creating timers after queueing the send is sufficient.
	// change back earlier policy of creating these only after the send
	// callback (to be consistent). creating timers that way would be too
	// complex for logical channels
	HResult = CreateTimer(LC_POST_OPEN_TIMER_VALUE);
    if (FAILED(HResult))
    {
        DebugF (_T("RTP : 0x%x failed to create timer for duration %d milliseconds ('Open Logical Channel'). Error - %x.\n"),
             &GetCallBridge (), 
             LC_POST_OPEN_TIMER_VALUE,
             HResult);
        return HResult;
    }
    DebugF (_T("RTP : 0x%x created timer for duration %d milliseconds ('Open Logical Channel').\n"),
         &GetCallBridge (), 
         LC_POST_OPEN_TIMER_VALUE);

    // transition state to LC_STATE_OPEN_RCVD
    m_LogicalChannelState   = LC_STATE_OPEN_RCVD;

    return S_OK;
}


HRESULT
RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU(
    IN  MultimediaSystemControlMessage  &H245pdu,
    OUT BYTE                            &SessionId,
    OUT DWORD                           &DestRTPIPv4Address,
    OUT WORD                            &DestRTPPort,
    OUT DWORD                           &DestRTCPIPv4Address,
    OUT WORD                            &DestRTCPPort
    )
/*++

Routine Description:

    
Arguments:
    
    
Return Values:

    S_OK on success.
    E_INVALIDARG if the PDU is invalid.

--*/
{
    // get the open logical channel ack PDU
    OpenLogicalChannelAck &OlcAckPDU = H245pdu.u.response.u.openLogicalChannelAck;

    // there shouldn't be reverse logical channel parameters
    if (OpenLogicalChannelAck_reverseLogicalChannelParameters_present &
            OlcAckPDU.bit_mask)
    {
        DebugF( _T("RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, has ")
            _T("reverse logical channel params, returning E_INVALIDARG\n"));
        return E_INVALIDARG;
    }

    // there shouldn't be a separate stack
    if (OpenLogicalChannelAck_separateStack_present &
            OlcAckPDU.bit_mask)
    {
        DebugF( _T("RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, ")
            _T("has a separate stack, returning E_INVALIDARG\n"));
        return E_INVALIDARG;
    }

    // we should have forward multiplex ack params - these contain the
    // H245 params
    if ( !(forwardMultiplexAckParameters_present &
            OlcAckPDU.bit_mask) )
    {
        DebugF( _T("RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, ")
                _T("doesn't have forward multiplex ack params,")
                _T(" returning E_INVALIDARG\n"));
        return E_INVALIDARG;
    }

    // we should have the H245 params
    if (h2250LogicalChannelAckParameters_chosen !=
            OlcAckPDU.forwardMultiplexAckParameters.choice)
    {
        DebugF( _T("RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, ")
            _T("doesn't have H2250 ack params, returning E_INVALIDARG\n"));
        return E_INVALIDARG;
    }

    H2250LogicalChannelAckParameters &H2250Params =
        OlcAckPDU.forwardMultiplexAckParameters.\
        u.h2250LogicalChannelAckParameters;

    // it should have media channel info
    if ( !(H2250LogicalChannelAckParameters_mediaChannel_present &
            H2250Params.bit_mask) )
    {
        DebugF( _T("RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, ")
            _T("doesn't have media channel info, returning E_INVALIDARG\n"));
        return E_INVALIDARG;
    }

    // it should have control channel info
    if ( !(H2250LogicalChannelAckParameters_mediaControlChannel_present &
            H2250Params.bit_mask) )
    {
        DebugF(_T("RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, ")
                _T("doesn't have media control channel info,")
                _T(" returning E_INVALIDARG\n"));
        return E_INVALIDARG;
    }

    // save remote client RTP address/port
    HRESULT HResult = E_FAIL;
    HResult = GetH245TransportInfo(
                H2250Params.mediaChannel,
                DestRTPIPv4Address,
                DestRTPPort);

    if (FAILED(HResult))
    {
        DebugF( _T("RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, ")
            _T("can't get media channel (RTP) address/port, returning 0x%x\n"),
            HResult);
        return HResult;
    }
    _ASSERTE(S_OK == HResult);

    // save remote client RTP address/port
    HResult = GetH245TransportInfo(
                H2250Params.mediaControlChannel,
                DestRTCPIPv4Address,
                DestRTCPPort);

    if (FAILED(HResult))
    {
        DebugF( _T("RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, ")
            _T("can't get media control channel (RTCP) address/port, ")
            _T("returning 0x%x\n"),
            HResult);
        return HResult;
    }
    _ASSERTE(S_OK == HResult);

    // if there is a session id, save it
    if (sessionID_present & H2250Params.bit_mask)
    {
        // the PDU stores the session ID as an unsigned short
        // although the ITU spec requires it to be a BYTE value [0..255]
        // the cast to BYTE is intentional
        _ASSERTE(255 >= H2250Params.sessionID);
        SessionId = (BYTE)H2250Params.sessionID;

        // the session id must be non-zero
        if (0 == SessionId)
        {
            DebugF( _T("RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, ")
                _T("has a session id of 0, returning E_INVALIDARG\n"));
            return E_INVALIDARG;
        }
    }
    else
    {
        // if no session id is supplied, the source must have supplied
        // a non-zero session id in OpenLogicalChannel
        if (0 == SessionId)
        {
            DebugF( _T("RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, ")
                _T("the source supplied a session id of 0 and the dest hasn't")
                _T("supplied one, returning E_INVALIDARG\n"));
            return E_INVALIDARG;
        }
    }

    return HResult;
}


HRESULT
RTP_LOGICAL_CHANNEL::ProcessOpenLogicalChannelAckPDU(
    IN      MultimediaSystemControlMessage   *pH245pdu
    )
/*++

Routine Description:

    
Arguments:
    
    pH245pdu - 
    
Return Values:

    S_OK on success.
    E_INVALIDARG if the PDU is invalid.

--*/
{
    HRESULT HResult = E_FAIL;
	switch(m_LogicalChannelState)
	{
	case LC_STATE_OPEN_RCVD:
		{
			HResult = CheckOpenLogicalChannelAckPDU(
						*pH245pdu,
						m_SessionId, 
						m_DestRTPIPv4Address, 
						m_DestRTPPort, 
						m_DestRTCPIPv4Address, 
						m_DestRTCPPort
						);
			if (FAILED(HResult))
			{
				DebugF( _T("RTP_LOGICAL_CHANNEL::ProcessOpenLogicalChannelAckPDU")
                        _T("(&%x), can't process OpenLogicalChannelAck, returning 0x%x\n"),
                        pH245pdu, HResult);
				return HResult;
			}
			_ASSERTE(S_OK == HResult);

			HResult = OpenNATMappings();
			if (FAILED(HResult))
			{
				DebugF( _T("RTP_LOGICAL_CHANNEL::ProcessOpenLogicalChannelAckPDU")
                        _T("(&%x), can't process OpenLogicalChannelAck, returning 0x%x\n"),
                        pH245pdu, HResult);
				return HResult;
			}
			_ASSERTE(S_OK == HResult);

			OpenLogicalChannelAck &OlcAckPDU =
                pH245pdu->u.response.u.openLogicalChannelAck;
			H2250LogicalChannelAckParameters &H2250Params =
				OlcAckPDU.forwardMultiplexAckParameters.u.h2250LogicalChannelAckParameters;

			// replace the RTP address/port
			// with the H.245 address and RTP port
			FillH245TransportAddress(
				m_OwnSourceIPv4Address,
				m_OwnSourceRecvRTPPort,
				H2250Params.mediaChannel
				);

			// replace the RTCP address/port
			// with the h245 address and RTCP port
			FillH245TransportAddress(
				m_OwnSourceIPv4Address,
				m_OwnSourceRecvRTCPPort,
				H2250Params.mediaControlChannel);

			// reset timer, we must have one (ignore error code if any)
			_ASSERTE(NULL != m_TimerHandle);
			TimprocCancelTimer();
            DebugF (_T("RTP : 0x%x cancelled timer.\n"),
                 &GetCallBridge ());

			// trasition to LC_STATE_OPEN_ACK_RCVD
			m_LogicalChannelState = LC_STATE_OPEN_ACK_RCVD;
		}
		break;

	case LC_STATE_CLOSE_RCVD:
		{
			// if we have received a close logical channel PDU, we must throw
			// OLC ACKs away and continue to wait
			DebugF( _T("RTP_LOGICAL_CHANNEL::ProcessOpenLogicalChannelAckPDU")
                    _T("(&%x), in close state %d, returning E_INVALIDARG\n"),
                    pH245pdu, m_LogicalChannelState);
			return E_INVALIDARG;
		}
		break;

	case LC_STATE_NOT_INIT:
	case LC_STATE_OPEN_ACK_RCVD:
	case LC_STATE_OPENED_CLOSE_RCVD:
	default:
		{
			DebugF( _T("RTP_LOGICAL_CHANNEL::ProcessOpenLogicalChannelAckPDU")
                    _T("(&%x), in state %d, returning E_UNEXPECTED"),
                    pH245pdu, m_LogicalChannelState);
            _ASSERTE(FALSE);
			return E_UNEXPECTED;
		}
		break;
	};

    return HResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\q931msg.h ===
#ifndef	__iptel_q931msg_h
#define	__iptel_q931msg_h

// To use the Q931_MESSAGE class:
//
// To decode Q.931 PDUs:
//
//		Create an instance of the Q931_MESSAGE class.
//		Call the AssignDecodePdu method, supplying the buffer and length of the PDU data.
//			If the AssignDecodePdu succeeds, then the buffer is now "bound" to the
//			Q931_MESSAGE instance.  You may then examine the elements of Q931_MESSAGE:
//
//				MessageType - The type of Q.931 PDU received (Setup, etc.)
//				CallReferenceValue
//				InfoElementArray - An ordered array of IEs that were in the PDU
//				UserInformation - If an ASN.1 UUIE was present, this field will be non-NULL
//
//			You may also use the FindInfoElement method to locate a specific IE (cause code, etc.)
//
//		When you are done using the contents of the Q931_MESSAGE instance, you must call the
//		FreeAll method.  This destroys the association between the buffer and the Q931_MESSAGE class.
//		This step MUST be performed before destroying the instance of the Q931_MESSAGE class.
//
//
// To encode Q.931 PDUs:
//
//		Create an instance of the Q931_MESSAGE class.
//		Set the MessageType and CallReferenceValue fields.
//		For each IE that should be encoded, call AppendInfoElement.
//		(This includes the UUIE.)
//		Call EncodePdu.  The buffer on return contains the fully encoded PDU.
//
//		If the buffer supplied to EncodePdu is not long enough, then the ReturnLength
//		parameter will contain the required length, and the method will return
//		HRESULT_FROM_WIN32 (ERROR_MORE_DATA).
//
// When calling InsertInfoElement, you must insure that the buffer supplied in the
// Q931_IE structure is still valid when the EncodePdu call is made.  All IE buffers
// should remain valid until the Q931_MESSAGE::FreeAll method is called.



#include "q931defs.h"
#include "dynarray.h"

struct	H323_UserInformation;

struct	Q931_ENCODE_CONTEXT;

struct	Q931_BEARER_CAPABILITY
{
};

// Q931_IE_DATA contains the decoded contents of those information elements whose
// interpretation is known and implemented in this module.
// Not all IEs are supported.

union	Q931_IE_DATA
{
	// Q931_IE_USER_TO_USER
	struct	{
		Q931_UUIE_TYPE			Type;
		H323_UserInformation *	PduStructure;
		BOOL					IsOwner;		// if true, delete PduStructure on deletion
	}	UserToUser;

	// Q931_IE_CAUSE
	DWORD	CauseCode;

	// Q931_BEARER_CAPABILITY
	Q931_BEARER_CAPABILITY	BearerCapability;

	// Q931_DISPLAY
	struct	{
		LPSTR		String;
	}	Display;

	// IEs that are not implemented here, and are of variable length
	struct	{
		LPBYTE	Data;
		DWORD	Length;
	}	UnknownVariable;

	// IEs that are not implemented here, and are of fixed length
	struct	{
		BYTE	Value;
	}	UnknownFixed;
};

struct	Q931_IE
{
	Q931_IE_IDENTIFIER		Identifier;
	Q931_IE_DATA			Data;
};

// it is the responsibility of the user of this object to synchronize access
// and object lifetime.
//
// The Decode method builds the InfoElementArray.  Elements in this array
// may refer to the original buffer passed to Encode.  Therefore, users of
// Q931_MESSAGE::Decode must insure that the original buffer remains accessible
// and does not change, until the user no longer requires the use of this Q931_MESSAGE
// object, or calls Q931_MESSAGE::FreeAll.

struct	Q931_MESSAGE
{
public:

	Q931_MESSAGE_TYPE				MessageType;
	WORD							CallReferenceValue;
	DYNAMIC_ARRAY <Q931_IE>			InfoElementArray;

	LPBYTE							Buffer;
	DWORD							BufferLength;
	BOOL							BufferIsOwner;

private:

	HRESULT	DecodeInfoElement (
		IN OUT	LPBYTE *	Pos,
		IN		LPBYTE		End,
		OUT		Q931_IE *	ReturnInfoElement);

	void	FreeInfoElementArray	(void);

	// ParseInfoElement examines the contents of an IE that has already been decoded
	// (type and length determined), and for known IE types, decodes their contents
	// and assigns to data structures

	HRESULT	ParseIE (
		IN	Q931_IE *		InfoElement);

	HRESULT	ParseIE_UUIE (
		IN	Q931_IE *		InfoElement);

	HRESULT	EncodeIE_UUIE (
		IN	Q931_ENCODE_CONTEXT *	Context,
		IN	Q931_IE *		InfoElement);

	// for those IEs that have attached allocated data, free it

	void	FreeInfoElement (
		IN	Q931_IE *		InfoElement);

	HRESULT	EncodeHeader (
		IN	Q931_ENCODE_CONTEXT *	Context);

	HRESULT	EncodeInfoElement (
		IN	Q931_ENCODE_CONTEXT *	Context,
		IN	Q931_IE *				InfoElement);

	static INT __cdecl CompareInfoElement (const Q931_IE *, const Q931_IE *);

	static INT InfoElementSearchFunc (
		IN	const Q931_IE_IDENTIFIER *	SearchKey,
		IN	const Q931_IE *		Comparand);

public:

	// initializes array and UserInformation
	Q931_MESSAGE	(void);

	// will free the UserInformation field if present
	~Q931_MESSAGE	(void);


	HRESULT	EncodePdu	(
		IN	OUT	LPBYTE		Data,
		IN	OUT	LPDWORD		Length);

	HRESULT	AttachDecodePdu	(
		IN	LPBYTE		Data,
		IN	DWORD		Length,
		IN	BOOL		IsDataOwner);		// if TRUE, Q931_MESSAGE will free on dtor

	void	FreeAll	(void);

	// if Q931_MESSAGE currently has a Buffer, and it owns the Buffer,
	// then it will free it here, using GkHeapFree
	void	Detach	(void);

	// if Q931_MESSAGE currently has a Buffer, regardless of whether it owns the buffer,
	// then it will be returned here
	// returns S_OK if a buffer was returned
	// returns S_FALSE if no buffer was returned, and ReturnBuffer set to null
	HRESULT	Detach	(
		OUT	LPBYTE *	ReturnBuffer,
		OUT	DWORD *		ReturnBufferLength);

	void	SetUserInformation	(
		IN	H323_UserInformation *,
		IN	BOOL	FreeOnDelete);

	// information element manipulation

	HRESULT	AppendInfoElement (
		IN	Q931_IE *		InfoElement);

	HRESULT	DeleteInfoElement (
		IN	Q931_IE_IDENTIFIER	Identifier);

	HRESULT	FindInfoElement	(
		IN	Q931_IE_IDENTIFIER		Identifier,
		OUT	Q931_IE **				ReturnInfoElement);

	void	SortInfoElementArray	(void);

};

DECLARE_SEARCH_FUNC_CAST(Q931_IE_IDENTIFIER, Q931_IE);

#if	DBG

	// in debug builds, this function will take a Q.931 PDU buffer,
	// decode it, re-encode it, verify that the contents match,
	// and attempt to decode the re-encoded PDU.
	// this is good for verifying the integrity of the Q931_MESSAGE class.
void Q931TestDecoder (
	IN	LPBYTE		PduData,
	IN	DWORD		PduLength);

#else

#define	Q931TestDecoder(x,y)		0

#endif


#endif // __iptel_q931msg_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\t120lc.cpp ===
#include "stdafx.h"
#include "portmgmt.h"
#include "timerval.h"
#include "cbridge.h"
#include "main.h"

// destructor
// virtual
T120_LOGICAL_CHANNEL::~T120_LOGICAL_CHANNEL(
    )
{
    if ( INVALID_HANDLE_VALUE != m_DynamicRedirectHandle )
    {
        NatCancelDynamicRedirect( m_DynamicRedirectHandle );
        m_DynamicRedirectHandle = INVALID_HANDLE_VALUE;
    }

    // Free the ports if they have been allocated
    FreePorts();
}

// All params in host order
HRESULT
T120_LOGICAL_CHANNEL::SetPorts(
    DWORD T120ConnectToIPAddr,
    WORD  T120ConnectToPort,
    DWORD T120ListenOnIPAddr,
    DWORD T120ConnectFromIPAddr
    )
{
    HRESULT HResult;

    // CODEWORK: Decide on the maximum number of TCP/IP connections to
    // to allow to the same port. CurtSm suggests 8. MaxM thinks 4 for
    // NM3.0 and 5 in general - currently allow 5.
    
    // Allocate m_T120ListenOnPort and m_T120ConnectFromPorts
    // Note that I am using the same routine I use to reserve
    // ports for RTP/RTCP. This call reserves a pair of ports.

    // CODEWORK: The port pool should have functions which
    // reserve more than 2 ports (6 ports).
    HResult = PortPoolAllocRTPPort(&m_T120ListenOnPort);
    if (FAILED(HResult))
    {
        return HResult;
    }

    m_T120ConnectToIPAddr   = T120ConnectToIPAddr;
    m_T120ConnectToPort     = T120ConnectToPort;

    m_T120ListenOnIPAddr    = T120ListenOnIPAddr;
    m_T120ConnectFromIPAddr = T120ConnectFromIPAddr;

    HResult = CreateNatRedirect();
    
    if (FAILED(HResult))
    {
        return HResult;
    }
    _ASSERTE(S_OK == HResult);
    
    return S_OK;
}

HRESULT
T120_LOGICAL_CHANNEL::FreePorts()
{
    HRESULT Result;

    CancelNatRedirect();
    
    if (m_T120ListenOnPort != 0)
    {
        Result = PortPoolFreeRTPPort(m_T120ListenOnPort);
        if (FAILED(Result))
        {
            DebugF( _T("T120_LOGICAL_CHANNEL::FreePorts: PortPoolFreeRTPPort ")
                    _T("failed error: 0x%x\n"),
                    Result);
        }
        
        m_T120ListenOnPort = 0;
    }

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines for setting up and tearing down NAT Redirects                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


// This is defined in rtplc.cpp
// This should not be required. But currently there is a bug in the API impl.

// Create the NAT redirect 
HRESULT
T120_LOGICAL_CHANNEL::CreateNatRedirect(
    )
{
    // XXX Actually so many checks are not needed
    if (m_T120ConnectToIPAddr     == INADDR_NONE ||
        m_T120ConnectToPort       == 0 ||
        m_T120ListenOnPort        == 0 )
    {
        DebugF( _T("T120_LOGICAL_CHANNEL::CreateNatRedirect() Ports not set")
                _T("m_120ConnectToIPAddr: %d.%d.%d.%d\n"),
                BYTES0123(m_T120ConnectToIPAddr)
                );
        // INVALID state or some such
        return E_UNEXPECTED;
    }
    

    ULONG Status;
    Status = NatCreateDynamicRedirect(
                    NatRedirectFlagLoopback,
                    IPPROTO_TCP,
                    htonl(m_T120ListenOnIPAddr),
                    htons(m_T120ListenOnPort),
                    htonl(m_T120ConnectToIPAddr),
                    htons(m_T120ConnectToPort),
                    0, 
                    0, 
                    &m_DynamicRedirectHandle );

            if (Status != STATUS_SUCCESS) {
                DebugF (_T ("T120: failed to set up dynamic redirect (*.* -> %08X:%04X) => (*.* -> %08X:%04X).\n"),
                    m_T120ListenOnIPAddr,       // source packet dest address (local)
                    m_T120ListenOnPort,         // source packet dest port (local)
                    m_T120ConnectToIPAddr,      // NewDestinationAddress
                    m_T120ConnectToPort);       // NewDestinationPort
    
                return (HRESULT) Status;
            }
            else
            {
                DebugF (_T ("T120: 0x%x set up dynamic redirect (*.* -> %08X:%04X) => (*.* -> %08X:%04X).\n"),
                    &GetCallBridge (),
                    m_T120ListenOnIPAddr,       // source packet dest address (local)
                    m_T120ListenOnPort,         // source packet dest port (local)
                    m_T120ConnectToIPAddr,      // NewDestinationAddress
                    m_T120ConnectToPort);       // NewDestinationPort
            }
    
    return S_OK;
}


void
T120_LOGICAL_CHANNEL::CancelNatRedirect(
    )
{
    // CODEWORK: CODEWORK: 
    // Note that this routine gets called every time the destructor
    // gets called and this means that only half of the redirects could
    // have been established or whatever. So we need to check whether
    // each of the redirects has been established. For this purpose
    // it is probably advisable to have one more field storing whether
    // the redirect has been estd. so that we can appropriately clean
    // it up. This field should also be useful in the WSP filter scenario
    // where we don't actually store the ports.

    // if our current state is LC_STATE_OPEN_ACK_RCVD or 
    // LC_STATE_OPENED_CLOSE_RCVD, we have a NAT mapping
    ULONG Win32ErrorCode;
    DebugF (_T("T120: 0x%x cancels redirect (*:* -> %08X:%04X) => (*:* -> %08X:%04X).\n"),
        &GetCallBridge (),
        m_T120ListenOnIPAddr, // source packet dest address (local)
        m_T120ListenOnPort,   // source packet dest port (local)
//            m_T120ConnectFromIPAddr, // NewSourceAddress
//            m_T120ConnectFromPorts[i],
        m_T120ConnectToIPAddr,     // NewDestinationAddress
        m_T120ConnectToPort);    // NewDestinationPort


    if ( INVALID_HANDLE_VALUE != m_DynamicRedirectHandle )
    {
        Win32ErrorCode = NatCancelDynamicRedirect( m_DynamicRedirectHandle );
        m_DynamicRedirectHandle = INVALID_HANDLE_VALUE;
    }

    return;
}

#define INADDR_PRIVATE_HOSTORDER 0xC0A80001

BOOL 
T120_LOGICAL_CHANNEL::IsT120RedirectNeeded( DWORD T120ConnectToIPAddr,
                                            DWORD T120ListenOnIPAddr,
                                            DWORD T120ConnectFromIPAddr )
{
    HRESULT hr;
    BOOL IsPrivateDestination;
    BOOL IsPrivateSource = FALSE;
    BOOL IsPrivateListen    = FALSE;

    BOOL fIsRedirectNeeded = TRUE;

    hr = ::IsPrivateAddress( T120ConnectToIPAddr,  &IsPrivateDestination );
    ::IsPrivateAddress( T120ConnectToIPAddr,  &IsPrivateSource );
    ::IsPrivateAddress( T120ListenOnIPAddr,  &IsPrivateListen );

    DebugF( _T("Address %08X isPrivateDestionation %s\n"), 
                T120ConnectToIPAddr, IsPrivateDestination ? _T("TRUE"):_T("FALSE") );
    DebugF( _T("Address %08X isPrivateSource %s\n"), 
                T120ConnectFromIPAddr, IsPrivateSource ? _T("TRUE"):_T("FALSE") );
    DebugF( _T("Address %08X isPrivateSource %s\n"), 
                T120ListenOnIPAddr, IsPrivateListen ? _T("TRUE"):_T("FALSE") );

    if ( (INADDR_PRIVATE_HOSTORDER == T120ConnectToIPAddr) || 
         (INADDR_PRIVATE_HOSTORDER == T120ListenOnIPAddr) ) 
    {
        fIsRedirectNeeded = FALSE;
    } 
    else if ( SUCCEEDED(hr) && 
              ((FALSE == IsPrivateDestination) && (T120ListenOnIPAddr != T120ConnectToIPAddr)) )
    {
        fIsRedirectNeeded = FALSE;
    }


    if ( !fIsRedirectNeeded )
    {
        DebugF( _T(" T120 Redirect is NOT needed %08X\n"), T120ConnectToIPAddr );
        return FALSE;
    }
    
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines for processing H.245 PDUs                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


// all of these are available in the OPEN LOGICAL CHANNEL message
// it modifies the OLC PDU and passes it on to the other H245
// instance for forwarding ???
HRESULT
T120_LOGICAL_CHANNEL::HandleOpenLogicalChannelPDU(
    IN H245_INFO                            &H245Info,
    IN MEDIA_TYPE                            MediaType,
    IN WORD                                  LogicalChannelNumber,
    IN BYTE                                  SessionId,
    IN DWORD                                 T120ConnectToIPAddr,
    IN WORD                                  T120ConnectToPort,
    IN OUT  MultimediaSystemControlMessage  *pH245pdu
    )
/*++

Routine Description:

    This routine handles a T120 OLC PDU. The T120_LOGICAL_CHANNEL
    is create by H245_INFO::HandleOpenLogicalChannelPDU().
    If T120ConnectToIPAddr and Port are specified, then
    m_T120ListenOnPort and m_T120ConnectFromPorts are allocated and
    the listen address field in pH245pdu are replaced with an IP address
    and port on the other edge of the proxy.
    
Arguments:
    
    H245Info - 
    
    MediaType - 
    
    LogicalChannelNumber - 
    
    SessionId - 
    
    T120ConnectToIPAddr - 
    
    T120ConnectToPort - 
    
    pH245pdu - If the T120ConnectToIPAddr and Port are specified then
        the listen address field in the H245 pdu is replaced with an
        IP address and port on the other edge of the proxy.

Return Values:

    S_OK on success.
    E_INVALIDARG if the PDU is invalid.

--*/
{

    // CODEWORK: assert that we are dealing with a T120 PDU
    
    // this should be the first call to this instance after its
    // created - hence, these fields must be as asserted
    _ASSERTE(LC_STATE_NOT_INIT == m_LogicalChannelState);
    _ASSERTE(NULL == m_pH245Info);

    HRESULT HResult = E_FAIL;

    m_pH245Info = &H245Info;

    DWORD T120ListenOnIPAddr    = ntohl (m_pH245Info->GetOtherH245Info().GetSocketInfo().LocalAddress.sin_addr.s_addr);
    DWORD T120ConnectFromIPAddr = ntohl (m_pH245Info->m_SocketInfo.LocalAddress.sin_addr.s_addr);

    // If the IP address that we need to connect to is specified in the
    // OLC PDU, then we need to allocate the port for listening on the
    // other interface.
    if ( (T120ConnectToIPAddr != INADDR_NONE) && 
         IsT120RedirectNeeded(T120ConnectToIPAddr, T120ListenOnIPAddr, T120ConnectFromIPAddr) )
    {
        HResult = SetPorts(
                      T120ConnectToIPAddr,
                      T120ConnectToPort,
                      T120ListenOnIPAddr,
                      // listen on other h245 local address
                      T120ConnectFromIPAddr
                      // connect from our local address
                      );
        
        if (FAILED(HResult))
        {
            DebugF( _T("T120_LOGICAL_CHANNEL::HandleOpenLogicalChannelPDU, ")
                    _T("failed to set its ports, returning 0x%x\n"),
                    HResult);
            return HResult;
        }
        //_ASSERTE(S_FALSE != HResult);

        OpenLogicalChannel &OlcPDU = 
            pH245pdu->u.request.u.openLogicalChannel;
        // modify the OLC PDU by replacing the RTCP address/port
        // with the h245 address and RTCP port

        FillH245TransportAddress(
            m_T120ListenOnIPAddr,
            m_T120ListenOnPort,
            OlcPDU.separateStack.networkAddress.u.localAreaAddress
            );
    }
    else
    {
        m_T120ConnectToIPAddr   = T120ConnectToIPAddr;
        m_T120ConnectToPort     = T120ConnectToPort;
    
        m_T120ListenOnIPAddr    = T120ListenOnIPAddr;
        m_T120ConnectFromIPAddr = T120ConnectFromIPAddr;
    }
    

    // Should the part below be pushed into H245_INFO::HandleOpenLogicalChannelPDU ?????
    // let the other H245 instance process the PDU
    HResult = m_pH245Info->GetOtherH245Info().ProcessMessage(
                pH245pdu);

    if (FAILED(HResult))
    {
        DebugF( _T("T120_LOGICAL_CHANNEL::HandleOpenLogicalChannelPDU")
            _T("(&H245Info, %u, %u, %d.%d.%d.%d, %u, 0x%x, 0x%x)")
            _T("other H245 instance failed to process OLC PDU, returning 0x%x\n"),
            LogicalChannelNumber, SessionId, BYTES0123(T120ConnectToIPAddr),
            T120ConnectToPort, pH245pdu, HResult);
        return HResult;
    }

    // start timer for a response
    // TO DO *** creating timers after queueing the send is sufficient.
    // change back earlier policy of creating these only after the send
    // callback (to be consistent). creating timers that way would be too
    // complex for logical channels
    HResult = CreateTimer(LC_POST_OPEN_TIMER_VALUE);
    if (FAILED(HResult))
    {
        DebugF (_T("T120: 0x%x failed to create timer for duration %d milliseconds ('Open Logical Channel'). Error - %x.\n"),
             &GetCallBridge (), 
             LC_POST_OPEN_TIMER_VALUE,
             HResult);
        return HResult;
    }
    DebugF (_T("T120: 0x%x created timer for duration %d milliseconds ('Open Logical Channel').\n"),
         &GetCallBridge (), 
         LC_POST_OPEN_TIMER_VALUE);
    //_ASSERTE(S_FALSE != HResult);

    InitLogicalChannel(&H245Info, MediaType,
                       LogicalChannelNumber,
                       SessionId, LC_STATE_OPEN_RCVD);

    // transition state to LC_STATE_OPEN_RCVD
    m_LogicalChannelState   = LC_STATE_OPEN_RCVD;

    return S_OK;
}


// If there is no T.120 Listen address in the PDU
// T120ConnectToIPAddr will contain INADDR_NONE
HRESULT
T120_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU(
    IN  OpenLogicalChannelAck   &OlcAckPDU,
    OUT DWORD                   &T120ConnectToIPAddr,
    OUT WORD                    &T120ConnectToPort
    )
/*++

Routine Description:

    
Arguments:
    
    OlcAckPDU -
    T120ConnectToIPAddr - 
    T120ConnectToPort -
    
Return Values:

    S_OK on success.
    E_INVALIDARG if the PDU is invalid.

--*/
{
    HRESULT HResult = S_OK;

    // These are the return values in case of a failure
    // or if the address is not present in the PDU
    T120ConnectToIPAddr = INADDR_NONE;
    T120ConnectToPort = 0;
    
    // there should be reverse logical channel parameters
    if (!(OpenLogicalChannelAck_reverseLogicalChannelParameters_present &
            OlcAckPDU.bit_mask))
    {
        DebugF( _T("T120_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, NO")
            _T("reverse logical channel params, returning E_INVALIDARG\n"));
        return E_INVALIDARG;
    }

    // there should be a separate stack if we do not have
    // a T.120 end point address to connect to (from the OLC PDU).
    if (!(OpenLogicalChannelAck_separateStack_present &
          OlcAckPDU.bit_mask) &&
        m_T120ConnectToIPAddr == INADDR_NONE)
    {
        DebugF( _T("T120_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, ")
                _T("NO separate stack, returning E_INVALIDARG\n"));
        return E_INVALIDARG;
    }

    if (OpenLogicalChannelAck_separateStack_present &
        OlcAckPDU.bit_mask)
    {
        HResult = GetT120ConnectToAddress(
                      OlcAckPDU.separateStack,
                      T120ConnectToIPAddr,
                      T120ConnectToPort
                      );
    }
    
    return HResult;
}


HRESULT
T120_LOGICAL_CHANNEL::ProcessOpenLogicalChannelAckPDU(
    IN      MultimediaSystemControlMessage   *pH245pdu
    )
/*++

Routine Description:

    
Arguments:
    
    pH245pdu - 
    
Return Values:

    S_OK on success.
    E_INVALIDARG if the PDU is invalid.

--*/
{
    //The type of this pdu should be OLC Ack
    _ASSERTE(pH245pdu->u.response.choice == openLogicalChannelAck_chosen);
             
    HRESULT HResult = E_FAIL;
    OpenLogicalChannelAck &OlcAckPDU =
        pH245pdu->u.response.u.openLogicalChannelAck;

    

    switch(m_LogicalChannelState)
    {
        case LC_STATE_OPEN_RCVD:
            DWORD T120ConnectToIPAddr;
            WORD  T120ConnectToPort;
            DWORD T120ListenOnIPAddr;   
            DWORD T120ConnectFromIPAddr;

            T120ConnectFromIPAddr    = ntohl (m_pH245Info->GetOtherH245Info().GetSocketInfo().LocalAddress.sin_addr.s_addr);
            T120ListenOnIPAddr = ntohl (m_pH245Info->m_SocketInfo.LocalAddress.sin_addr.s_addr);    

            HResult = CheckOpenLogicalChannelAckPDU(
                        OlcAckPDU,
                        T120ConnectToIPAddr,
                        T120ConnectToPort
                        );
            
            if (FAILED(HResult))
            {
                return HResult;
            }
            _ASSERTE(S_OK == HResult);

            if ( (T120ConnectToIPAddr != INADDR_NONE) 
                 && IsT120RedirectNeeded(T120ConnectToIPAddr, T120ListenOnIPAddr, T120ConnectFromIPAddr) )
            {
                HResult = SetPorts(
                         T120ConnectToIPAddr,
                         T120ConnectToPort,
                         T120ListenOnIPAddr,
                         // listen on our local address
                         T120ConnectFromIPAddr
                         // connect from other h245 local address
                         );
        
                if (FAILED(HResult))
                {
                    return HResult;
                }

                // modify the OLC PDU by replacing the RTCP address/port
                // with the h245 address and RTCP port
                FillH245TransportAddress(
                    m_T120ListenOnIPAddr,
                    m_T120ListenOnPort,
                    OlcAckPDU.separateStack.networkAddress.u.localAreaAddress
                    );
            }
            else
            {
                m_T120ConnectToIPAddr   = T120ConnectToIPAddr;
                m_T120ConnectToPort     = T120ConnectToPort;

                m_T120ListenOnIPAddr    = T120ListenOnIPAddr;
                m_T120ConnectFromIPAddr = T120ConnectFromIPAddr;
            }

            // reset timer, we must have one (ignore error code if any)
            //_ASSERTE(NULL != m_TimerHandle);
            TimprocCancelTimer();
            DebugF (_T("T120: 0x%x cancelled timer.\n"),
                 &GetCallBridge ());

            // transition to LC_STATE_OPEN_ACK_RCVD
            m_LogicalChannelState = LC_STATE_OPEN_ACK_RCVD;
            break;

        case LC_STATE_CLOSE_RCVD:
            // if we have received a close logical channel PDU, we must throw
            // OLC ACKs away and continue to wait
            DebugF( _T("T120_LOGICAL_CHANNEL::ProcessOpenLogicalChannelAckPDU")
                    _T("(&%x), in close state %d, returning E_INVALIDARG\n"),
                    pH245pdu, m_LogicalChannelState);
            return E_INVALIDARG;
            break;
            
        case LC_STATE_NOT_INIT:
        case LC_STATE_OPEN_ACK_RCVD:
        case LC_STATE_OPENED_CLOSE_RCVD:
        default:
            DebugF( _T("T120_LOGICAL_CHANNEL::ProcessOpenLogicalChannelAckPDU")
                    _T("(&%x), in state %d, returning E_UNEXPECTED\n"),
                    pH245pdu, m_LogicalChannelState);
            _ASSERTE(FALSE);
            return E_UNEXPECTED;
            break;
    } // switch (m_LogicalChannelState)

    return HResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\q931msg.cpp ===
#include "stdafx.h"
#include "dynarray.h"
#include "q931msg.h"
#include "h323asn1.h"

struct	Q931_ENCODE_CONTEXT
{
	LPBYTE		Pos;			// next storage position, MAY EXCEED End!
	LPBYTE		End;			// end of storage buffer

	// if returns FALSE, then buffer is in overflow condition
	BOOL	StoreData	(
		IN	LPBYTE	Data,
		IN	DWORD	Length);

	BOOL	HasOverflowed (void) { return Pos > End; }

	// if returns FALSE, then buffer is in overflow condition, or would be
	BOOL	AllocData (
		IN	DWORD	Length,
		OUT	LPBYTE *	ReturnData);
};

BOOL Q931_ENCODE_CONTEXT::StoreData (
	IN	LPBYTE	Data,
	IN	DWORD	Length)
{
	if (Pos + Length > End) {
		Pos += Length;
		return FALSE;
	}

	memcpy (Pos, Data, Length);
	Pos += Length;

	return TRUE;
}

BOOL Q931_ENCODE_CONTEXT::AllocData (
	IN	DWORD		Length,
	OUT	LPBYTE *	ReturnData)
{
	if (Pos + Length > End) {
		Pos += Length;
		*ReturnData = NULL;
		return FALSE;
	}
	else {
		*ReturnData = Pos;
		Pos += Length;
		return TRUE;
	}
}

#if	DBG

void Q931TestDecoder (
	IN	LPBYTE		PduData,
	IN	DWORD		PduLength)
{
	Q931_MESSAGE	Message;
	HRESULT			Result;

	Q931_MESSAGE	NewMessage;
	BYTE			NewData	[0x400];
	DWORD			NewLength;

	Debug (_T("Q931TestDecoder --------------------------------------------------------------------\n"));
	DebugF (_T("- processing Q.931 PDU, length %d, contents:\n"), PduLength);
	DumpMemory (PduData, PduLength);


	Result = Message.AttachDecodePdu (PduData, PduLength, FALSE);

	if (Result != S_OK) {
		DebugError (Result, _T("- failed to decode Q.931 PDU\n"));
		return;
	}

	Debug (_T("- successfully decoded Q.931 PDU\n"));

	// now, try to re-encode the same PDU

	if (Message.MessageType == Q931_MESSAGE_TYPE_SETUP) {
		// there is an issue with decoding and re-encoding ASN.1 UUIE for Setup from TAPI
		// long, boring story

		Debug (_T("- it's a Setup PDU, will not attempt to re-encode (due to ASN.1 compatability issue)\n"));
	}
	else {
		Debug (_T("- will now attempt to re-encode\n"));

		NewLength = 0x400;
		Result = Message.EncodePdu (NewData, &NewLength);

		if (Result == S_OK) {
			DebugF (_T("- successfully re-encoded copy of Q.931 PDU, length %d, contents:\n"), NewLength);


			if (PduLength != NewLength) {
				DebugF (_T("- *** warning: original pdu length (%d) is different from re-encoded pdu length (%d), re-encoded contents:\n"),
					PduLength, NewLength);
					DumpMemory (NewData, NewLength);
			}
			else {
				if (memcmp (PduData, NewData, NewLength) != 0) {
					DebugF (_T("- *** warning: original pdu contents differ from re-encoded pdu contents, which follow:\n"));
					DumpMemory (NewData, NewLength);
				}
				else {
					DebugF (_T("- re-encoded pdu is identical to original pdu -- success!\n"));
				}
			}

			Debug (_T("- will now attempt to decode re-encoded PDU\n"));

			Result = NewMessage.AttachDecodePdu (NewData, NewLength, FALSE);

			if (Result == S_OK) {
				Debug (_T("- successfully decoded copy of Q.931 PDU\n"));
			}
			else {
				DebugError (Result, _T("- failed to decode copy of Q.931 PDU\n"));
			}
		}
		else {
			DebugError (Result, _T("- failed to re-encode Q.931 PDU\n"));
		}
	}

	Message.Detach();
	NewMessage.Detach();

	Debug (_T("\n"));
}

#endif

// Q931_MESSAGE -----------------------------------------------------------------------------

Q931_MESSAGE::Q931_MESSAGE (void)
{
	Buffer = NULL;
	BufferLength = 0;
}

Q931_MESSAGE::~Q931_MESSAGE (void)
{
	Detach();

	assert (!InfoElementArray.m_Length);
	assert (!Buffer);
}

void Q931_MESSAGE::Detach (void)
{
	FreeInfoElementArray();

	if (Buffer) {
		if (BufferIsOwner) {
			LocalFree (Buffer);
		}

		Buffer = NULL;
		BufferLength = 0;
		BufferIsOwner = FALSE;			
	}
}

HRESULT Q931_MESSAGE::Detach (
	OUT	LPBYTE *	ReturnBuffer,
	OUT	DWORD *		ReturnBufferLength)
{
	HRESULT		Result;

	assert (ReturnBuffer);
	assert (ReturnBufferLength);

	if (Buffer) {
		*ReturnBuffer = Buffer;
		*ReturnBufferLength = BufferLength;

		Result = S_OK;
	}
	else {
		Result = S_FALSE;
	}

	Detach();

	return Result;
}

void Q931_MESSAGE::FreeInfoElementArray (void)
{
	Q931_IE *	Pos;
	Q931_IE *	End;

	InfoElementArray.GetExtents (&Pos, &End);

	for (; Pos < End; Pos++) {
		FreeInfoElement (Pos);
	}

	InfoElementArray.Clear();
}

void Q931_MESSAGE::FreeInfoElement (Q931_IE * InfoElement)
{
    assert (InfoElement);

	switch (InfoElement -> Identifier) {
	case	Q931_IE_USER_TO_USER:

		assert (InfoElement -> Data.UserToUser.PduStructure);

		if (InfoElement -> Data.UserToUser.IsOwner) {

			H225FreePdu_H323_UserInformation (
				InfoElement -> Data.UserToUser.PduStructure);
		}
		break;
	}

			
}

HRESULT Q931_MESSAGE::DecodeInfoElement (
	IN	OUT	LPBYTE *	ArgPos,
	IN	LPBYTE			End,
	OUT	Q931_IE *		ReturnInfoElement)
{
	LPBYTE			Pos;
	BYTE			Identifier;
	DWORD			LengthLength;		// length of the IE length element, in bytes!
	LPBYTE			VariableData;		// payload of variable-length data
	DWORD			VariableDataLength;
	BYTE			FixedData;			// payload of fixed-length data
	HRESULT			Result;


	assert (ArgPos);
	assert (End);

	Pos = *ArgPos;

	if (Pos >= End) {
		Debug (_T("Q931_MESSAGE::DecodeInfoElement: should never have been called\n"));
		return E_INVALIDARG;
	}

	Identifier = *Pos;
	Pos++;

	// is it a single-byte IE?
	// if so, then bit 7 of the first byte = 1

	if (Identifier & 0x80) {

		// there are two types of single-byte IEs
		// Type 1 has a four-bit identifier and a four-bit value
		// Type 2 has only an identifier, and no value
		
		switch (Identifier & 0xF0) {
		case	Q931_IE_MORE_DATA:
		case	Q931_IE_SENDING_COMPLETE:
			// these IEs have an identifier, but no value

			ReturnInfoElement -> Identifier = (Q931_IE_IDENTIFIER) Identifier;

			DebugF (_T("Q931_MESSAGE::DecodeInfoElement: fixed-length IE, id %02XH, no value\n"),
				Identifier);

			break;

		default:
			// the other single-byte IEs have a value in the lower four bits
			ReturnInfoElement -> Identifier = (Q931_IE_IDENTIFIER) (Identifier & 0xF0);
			ReturnInfoElement -> Data.UnknownFixed.Value = Identifier & 0x0F;

			DebugF (_T("Q931_MESSAGE::DecodeInfoElement: fixed-length IE, id %02XH value %01XH\n"),
				ReturnInfoElement -> Identifier,
				ReturnInfoElement -> Data.UnknownFixed.Value);

			break;
		}

		// we don't currently parse any fixed-length IEs

		Result = S_OK;
	}
	else {
		// the next byte indicates the length of the info element

		// unfortunately, the number of octets that make up the length
		// depends on the identifier.
		// -XXX- is this because I don't understand the octet extension mechanism?

		ReturnInfoElement -> Identifier = (Q931_IE_IDENTIFIER) Identifier;

		switch (Identifier) {
		case	Q931_IE_USER_TO_USER:
			LengthLength = 2;
			break;

		default:
			LengthLength = 1;
			break;
		}

		if (Pos + LengthLength > End) {
			Debug (_T("Q931_MESSAGE::DecodeInfoElement: insufficient data for header of variable-length IE\n"));
			return E_INVALIDARG;
		}

		if (LengthLength == 1) {
			VariableDataLength = *Pos;
		}
		else {
			VariableDataLength = Pos [1] + (((WORD) Pos [0]) << 8);
		}
		Pos += LengthLength;

		if (Pos + VariableDataLength > End) {
			Debug (_T("Q931_MESSAGE::DecodeInfoElement: insufficient data for body of variable-length IE\n"));
			return E_INVALIDARG;
		}

		VariableData = (LPBYTE) Pos;
		Pos += VariableDataLength;

//		DebugF (_T("Q931_MESSAGE::DecodeInfoElement: variable-length IE, id %02XH length %d\n"),
//			Identifier, VariableDataLength);

		ReturnInfoElement -> Data.UnknownVariable.Data = VariableData;
		ReturnInfoElement -> Data.UnknownVariable.Length = VariableDataLength;

		Result = ParseIE (ReturnInfoElement);

		if (Result != S_OK) {
			DebugError (Result, _T("Q931_MESSAGE::DecodeInfoElement: IE was located, but failed to parse\n"));
		}
	}

	*ArgPos = Pos;

	return Result;
}

HRESULT Q931_MESSAGE::AppendInfoElement (
	IN	Q931_IE *	InfoElement)
{
	Q931_IE *	ArrayEntry;

	ArrayEntry = InfoElementArray.AllocAtEnd();

	if (ArrayEntry) {
		*ArrayEntry = *InfoElement;

		return S_OK;
	}
	else {
		Debug (_T("Q931_MESSAGE::AppendInfoElement: allocation failure\n"));

		return E_OUTOFMEMORY;
	}
}

HRESULT Q931_MESSAGE::ParseIE_UUIE (
	IN	Q931_IE *	InfoElement)
{
	LPBYTE	Data;
	DWORD	Length;
	DWORD	Status;

	// be careful to copy out all parameters from one branch of the union
	// before you start stomping on another branch
	Data = InfoElement -> Data.UnknownVariable.Data;
	Length = InfoElement -> Data.UnknownVariable.Length;

	if (Length < 1) {
		Debug (_T("Q931_MESSAGE::ParseIE_UUIE: IE payload is too short to contain UUIE\n"));
		return E_INVALIDARG;
	}

	InfoElement -> Data.UserToUser.Type = (Q931_UUIE_TYPE) *Data++;
	Length--;

	InfoElement -> Data.UserToUser.PduStructure = NULL;

	Status = H225DecodePdu_H323_UserInformation (Data, Length,
		&InfoElement -> Data.UserToUser.PduStructure);

	if (Status != ERROR_SUCCESS) {
		if (InfoElement -> Data.UserToUser.PduStructure) {
			// return value was a warning, not error

			H225FreePdu_H323_UserInformation (InfoElement -> Data.UserToUser.PduStructure);

			InfoElement -> Data.UserToUser.PduStructure = NULL;
		}


		InfoElement -> Data.UserToUser.PduStructure = NULL;
		DebugError (Status, _T("Q931_MESSAGE::ParseIE_UUIE: failed to decode UUIE / ASN.1\n"));
		return E_FAIL;
	}

	InfoElement -> Data.UserToUser.IsOwner = TRUE;

//	Debug (_T("Q931_MESSAGE::ParseIE_UUIE: successfully decoded UUIE\n"));

	return S_OK;
}

HRESULT Q931_MESSAGE::ParseIE (
	IN	Q931_IE *	InfoElement)
{
	assert (InfoElement);

	switch (InfoElement -> Identifier) {

	case	Q931_IE_USER_TO_USER:
		return ParseIE_UUIE (InfoElement);
		break;

	case	Q931_IE_CAUSE:
//		Debug (_T("Q931_MESSAGE::ParseInfoElement: Q931_IE_CAUSE\n"));
		break;

	case	Q931_IE_DISPLAY:
//		Debug (_T("Q931_MESSAGE::ParseInfoElement: Q931_IE_DISPAY\n"));
		break;

	case	Q931_IE_BEARER_CAPABILITY:
//		Debug (_T("Q931_MESSAGE::ParseInfoElement: Q931_IE_BEARER_CAPABILITY\n"));
		break;

	default:
		DebugF (_T("Q931_MESSAGE::ParseInfoElement: unknown IE identifier (%02XH), no interpretation will be imposed\n"),
			InfoElement -> Identifier);
		break;
	}

	return S_OK;
}

HRESULT Q931_MESSAGE::AttachDecodePdu (
	IN	LPBYTE		Data,
	IN	DWORD		Length,
	IN	BOOL		IsDataOwner)
{
	LPBYTE		Pos;
	LPBYTE		End;
	HRESULT		Result;

	Q931_IE *	ArrayEntry;

	assert (Data);

	Detach();

	if (Length < 5) {
		DebugF (_T("Q931_MESSAGE::Decode: header is too short (%d)\n"), Length);
		return E_INVALIDARG;
	}

	// octet 0 is the Protocol Discriminator

	if (Data [0] != Q931_PROTOCOL_DISCRIMINATOR) {
		DebugF (_T("Q931_MESSAGE::Decode: the pdu is not a Q.931 pdu, protocol discriminator = %02XH\n"),
			Data [0]);

		return E_INVALIDARG;
	}

	// octet 1: bits 0-3 contain the length, in octets of the Call Reference Value
	// octet 1: bits 4-7 should be zero

	if (Data [1] & 0xF0) {
		DebugF (_T("Q931_MESSAGE::Decode: the pdu has non-zero bits in octet 1: %02XH\n"),
			Data [1]);
	}

	// according to H.225, the Call Reference Value must be two octets in length

	if ((Data [1] & 0x0F) != 2) {
		DebugF (_T("Q931_MESSAGE::Decode: the call reference value size is invalid (%d), should be 2\n"),
			Data [1] & 0x0F);
		return E_INVALIDARG;
	}

	// since the Call Reference Value size is 2 octets, octets 2 and 3 are the CRV
	// octets are in network (big-endian) order.

	CallReferenceValue = (((WORD) Data [2]) << 8) | Data [3];

//	DebugF (_T("Q931_MESSAGE::Decode: crv %04XH\n"), CallReferenceValue);

	// Message Type is at octet offset 4

	if (Data [4] & 0x80) {
		DebugF (_T("Q931_MESSAGE::Decode: message type is invalid (%02XH)\n"), Data [4]);
		return E_INVALIDARG;
	}

	MessageType = (Q931_MESSAGE_TYPE) Data [4];

	// enumerate the Information Elements and extract the ones that we will use

	Pos = Data + 5;
	End = Data + Length;

	Result = S_OK;

	while (Pos < End) {
		ArrayEntry = InfoElementArray.AllocAtEnd();

		if (!ArrayEntry) {
			Result = E_OUTOFMEMORY;
			Debug (_T("Q931_MESSAGE::Decode: allocation failure\n"));
			break;
		}

		Result = DecodeInfoElement (&Pos, End, ArrayEntry);

		if (Result != S_OK) {
			DebugError (Result, _T("Q931_MESSAGE::Decode: failed to decode IE, packet may be corrupt, terminating (but not failing) decode\n"));
			Result = S_OK;

			InfoElementArray.DeleteEntry (ArrayEntry);
			break;
		}
	}

	if (Result == S_OK) {
		assert (!Buffer);

		Buffer = Data;
		BufferLength = Length;
		BufferIsOwner = IsDataOwner;
	}
	else {
		Detach();
	}

	return ERROR_SUCCESS;
}

HRESULT Q931_MESSAGE::EncodePdu (
	IN	OUT	LPBYTE			Data,
	IN	OUT	LPDWORD			Length)
{
	Q931_ENCODE_CONTEXT		Context;
	Q931_IE *		IePos;
	Q931_IE *		IeEnd;
	HRESULT			Result;
	DWORD			EncodeLength;

	assert (Data);
	assert (Length);

	Context.Pos = Data;
	Context.End = Data + *Length;

	SortInfoElementArray();

	Result = EncodeHeader (&Context);
	if (Result != S_OK)
		return Result;

	// walk IE array

	InfoElementArray.GetExtents (&IePos, &IeEnd);
	for (; IePos < IeEnd; IePos++) {
		Result = EncodeInfoElement (&Context, IePos);
		if (Result != S_OK) {
			return Result;
		}
	}

	EncodeLength = (DWORD)(Context.Pos - Data);

	if (Context.HasOverflowed()) {

		Result = HRESULT_FROM_WIN32 (ERROR_MORE_DATA);
	}
	else {

		Result = S_OK;

	}

	*Length = EncodeLength;

	return Result;
}

HRESULT Q931_MESSAGE::EncodeHeader (
	IN	Q931_ENCODE_CONTEXT *	Context)
{
	BYTE	Header	[5];

	Header [0] = Q931_PROTOCOL_DISCRIMINATOR;
	Header [1] = 2;
	Header [2] = (CallReferenceValue >> 8) & 0xFF;
	Header [3] = CallReferenceValue & 0xFF;
	Header [4] = MessageType;

	Context -> StoreData (Header, 5);

	return S_OK;
}

HRESULT Q931_MESSAGE::EncodeInfoElement (
	IN	Q931_ENCODE_CONTEXT *	Context,
	IN	Q931_IE *				InfoElement)
{
	BYTE		Header	[0x10];
	WORD		Length;
	DWORD		LengthLength;				// length of Length, in bytes
	LPBYTE		LengthInsertionPoint;
	LPBYTE		IeContents;
	DWORD		IeContentsLength;
	DWORD		ShiftCount;
	HRESULT		Result;

	if (InfoElement -> Identifier & 0x80) {
		// single-byte IE

		switch (InfoElement -> Identifier & 0xF0) {
		case	Q931_IE_MORE_DATA:
		case	Q931_IE_SENDING_COMPLETE:
			// these IEs have an identifier, but no value

			Header [0] = (BYTE) InfoElement -> Identifier;
			break;

		default:
			// these IEs have an identifier and a value, combined in a single byte
			Header [0] = (((BYTE) InfoElement -> Identifier) & 0xF0)
				| (InfoElement -> Data.UnknownFixed.Value & 0x0F);
			break;
		}

		Context -> StoreData (Header, 1);

		Result = S_OK;
	}
	else {
		// variable-length IE

		Header [0] = (BYTE) InfoElement -> Identifier;
		Context -> StoreData (Header, 1);

		// allocate data for the insertion point
		Context -> AllocData (2, &LengthInsertionPoint);

		// record the current buffer position, for use below in storing the content length
		IeContents = Context -> Pos;

		switch (InfoElement -> Identifier) {
		case	Q931_IE_USER_TO_USER:
			Result = EncodeIE_UUIE (Context, InfoElement);
			break;
			
		default:

			Context -> StoreData (
				InfoElement -> Data.UnknownVariable.Data,
				InfoElement -> Data.UnknownVariable.Length);

			if (InfoElement -> Data.UnknownVariable.Length >= 0x10000) {
				DebugF (_T("Q931_MESSAGE::EncodeInfoElement: payload is waaaaay too big (%d %08XH)\n"),
					InfoElement -> Data.UnknownVariable.Length,
					InfoElement -> Data.UnknownVariable.Length);

				Result = E_INVALIDARG;
			}
			else {
				Result = S_OK;
			}

			break;
		}

		if (Result == S_OK) {

			IeContentsLength = (DWORD)(Context -> Pos - IeContents);

			// this is such a hack
			// with little or no justification for when LengthLength = 1 and when LengthLength = 2
			// the octet group extension mechanism is poorly defined in Q.931

			if (InfoElement -> Identifier == Q931_IE_USER_TO_USER)
				LengthLength = 2;
			else
				LengthLength = 1;

			// if the storage context has not overflowed,
			// and if it is necessary to resize the Length parameter (we guessed pessimistically
			// that it would be 2), then move the buffer down one byte

			ShiftCount = 2 - LengthLength;

			if (ShiftCount > 0) {
				if (!Context -> HasOverflowed()) {
					memmove (
						LengthInsertionPoint + LengthLength,	// destination, where IE contents should be
						IeContents,				// source, where IE contents were actually stored
						IeContentsLength);		// length of the contents
				}

				// pull back the storage context's position pointer
				Context -> Pos -= ShiftCount;
			}

			// now store the actual count
                        if ( LengthInsertionPoint != NULL )
                        {

			     switch (LengthLength) {
			     case	1:
				     assert (IeContentsLength < 0x100);
				     LengthInsertionPoint [0] = (BYTE) IeContentsLength;
				     break;

			     case	2:
				     assert (IeContentsLength < 0x10000);
				     LengthInsertionPoint [0] = (BYTE) (IeContentsLength >> 8);
				     LengthInsertionPoint [1] = (BYTE) (IeContentsLength & 0xFF);
				     break;

			     default:
				     assert (FALSE);
			     }
                        }
		}

	}

	return Result;
}

HRESULT	Q931_MESSAGE::EncodeIE_UUIE (
	IN	Q931_ENCODE_CONTEXT *	Context,
	IN	Q931_IE *		InfoElement)
{
	DWORD	Status;
	LPBYTE	Buffer;
	DWORD	Length;
	BYTE	ProtocolDiscriminator;

	assert (Context);
	assert (InfoElement);
	assert (InfoElement -> Data.UserToUser.PduStructure);


	// store the UUIE protocol discriminator
	ProtocolDiscriminator = InfoElement -> Data.UserToUser.Type;
	Context -> StoreData (&ProtocolDiscriminator, 1);



	Buffer = NULL;
	Length = 0;

	Status = H225EncodePdu_H323_UserInformation (
		InfoElement -> Data.UserToUser.PduStructure,
		&Buffer, &Length);

	if (Status == ERROR_SUCCESS) {

		Context -> StoreData (Buffer, Length);
		H225FreeBuffer (Buffer);

		return S_OK;
	}
	else {
		// Status is not a real Win32 error code
		// it is an ASN.1 enum (
#if	DBG
		// we pull this in so source debuggers can show actual symbolic enum name
		tagASN1error_e	AsnError = (tagASN1error_e) Status;

		DebugF (_T("Q931_MESSAGE::EncodeIE_UUIE: failed to encode ASN.1 structure (%d)\n"),
			AsnError);

#endif

		// -XXX- one day, i'm going to convince Lon to use real Win32 error codes for ASN.1 return values
		// -XXX- on that day, the return value should reflect the actual ASN.1 error code

		return DIGSIG_E_ENCODE;
	}
}

void Q931_MESSAGE::SortInfoElementArray (void)
{
	InfoElementArray.QuickSort (CompareInfoElement);
}

// static
INT __cdecl Q931_MESSAGE::CompareInfoElement (
	const Q931_IE *		ComparandA,
	const Q931_IE *		ComparandB)
{
	if (ComparandA -> Identifier < ComparandB -> Identifier) return -1;
	if (ComparandA -> Identifier > ComparandB -> Identifier) return 1;

	return 0;
}

HRESULT Q931_MESSAGE::FindInfoElement (
	IN	Q931_IE_IDENTIFIER	Identifier,
	OUT	Q931_IE **			ReturnInfoElement)
{
	DWORD	Index;

	assert (ReturnInfoElement);

	if (InfoElementArray.BinarySearch ((SEARCH_FUNC_Q931_IE)InfoElementSearchFunc, &Identifier, &Index)) {
		*ReturnInfoElement = InfoElementArray.m_Array + Index;
		return S_OK;
	}
	else {
		*ReturnInfoElement = NULL;
		return E_FAIL;
	}
}


// static
INT Q931_MESSAGE::InfoElementSearchFunc (
	IN	const Q931_IE_IDENTIFIER *	SearchKey,
	IN	const Q931_IE *		Comparand)
{
	Q931_IE_IDENTIFIER	Identifier;

	assert (SearchKey);
	assert (Comparand);

	Identifier = * (Q931_IE_IDENTIFIER *) SearchKey;

	if (Identifier < Comparand -> Identifier) return -1;
	if (Identifier > Comparand -> Identifier) return 1;

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\stdafx.h ===
#define	STRICT
#define	UNICODE
#define	_UNICODE

#pragma	warning (disable : 4211)		// ASN.1 stubs have static/extern conflict
#pragma	warning (disable : 4201)		// nameless struct/union
#pragma warning (disable : 4514)		// unreferenced inline function has been removed
#pragma warning (disable : 4100)		// unreferenced formal parameter
#pragma warning (disable : 4127)		// conditional expression is constant
#pragma warning (disable : 4355)		// use of "this" in constructor initializer list



// NT private files
// Need to be before the windows include files
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// Win32 SDK (public)
#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <tchar.h>
#include <winsvc.h>
#include <mswsock.h>

// ANSI
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <limits.h>

// Microsoft private
#include <msasn1.h>
#include <msper.h>
#include <ipnatapi.h>
#include <ipnat.h>

extern "C" {
#include <sainfo.h>
#include <rasuip.h>
#include <raserror.h>
#include <ipexport.h>		// needed for interaction with TCP driver
#include <ipinfo.h>
#include <tcpinfo.h>
#include <ntddtcp.h>
#include <routprot.h>		// for struct IP_ADAPTER_BINDING_INFO
#include <mprerror.h>       // for RRAS error codes
#include <iphlpapi.h>
#include <ntddip.h>
#include <iphlpstk.h>
#include <mprapi.h>
};
#include <natio.h>


// Keep this prototype here until it gets included 
// in 'rasuip.h'
extern "C" {
extern
DWORD APIENTRY
RasGetEntryHrasconnW(
    IN  LPCWSTR             pszPhonebook,
    IN  LPCWSTR             pszEntry,
    OUT LPHRASCONN          lphrasconn);
};


// Interface to ipnathlp.dll
#include "h323icsp.h"

// Project
#include "ldap.h"			// ASN.1 structures for LDAP
#include "h225pp.h"
#include "h245pp.h"
#include "util.h"
#include "h323asn1.h"
#include "q931msg.h"
#include "portmgmt.h"
#include "h323ics.h"
#include "main.h"
#include "timer.h"
#include "gkwsock.h"
#include "cbridge.h"
#include "cblist.h"
#include "intfc.h"
#include "ldappx.h"
#include "timerval.h"
#include "iocompl.h"
#include "q931info.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\timer.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    timer.cpp

Abstract:

    Contains:
        Routines for timer operations

Environment:

    User Mode - Win32

History:
    
    1. 14-Feb-2000 -- File creation (based on             Ilya Kleyman  (ilyak)
                      previous work by AjayCh)

--*/

#include "stdafx.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// TIMER_PROCESSOR ------------------------------------------------------------------

/*
 * This function is passed as the callback in the 
 * CreateTimerQueueTimer() function
 */
// static
void WINAPI TimeoutCallback (
    IN    PVOID    Context,
    IN    BOOLEAN    TimerFired)
{
 
    TIMER_PROCESSOR *pTimerProcessor = (TIMER_PROCESSOR *) Context;

    pTimerProcessor->TimerCallback();

    // At this point the timer would have been canceled because
    // this is a one shot timer (no period)
}

/*++

Routine Description:

    Create a timer.
    
Arguments:
    
Return Values:
    if Success the caller should increase the ref count.
    
--*/

DWORD TIMER_PROCESSOR::TimprocCreateTimer (
    IN    DWORD    TimeoutValue)
{
    HRESULT Result;

    if (m_TimerHandle) {
        
        DebugF (_T("H323: timer is already pending, cannot create new timer.\n"));
        
        return E_FAIL;
    }

    IncrementLifetimeCounter ();

    if (CreateTimerQueueTimer(&m_TimerHandle,
                               NATH323_TIMER_QUEUE,
                               TimeoutCallback,
                               this,
                               TimeoutValue,
                               0,                    // One shot timer
                               WT_EXECUTEINIOTHREAD)) {

        assert (m_TimerHandle);

        Result = S_OK;
    }
    else {

        Result = GetLastResult();

        DecrementLifetimeCounter ();

    }

    return Result;
}

/*++

Routine Description:

    Cancel the timer if there is one. Otherwise simply return.
    
Arguments:
    
Return Values:
  
--*/

// If Canceling the timer fails this means that the
// timer callback could be pending. In this scenario,
// the timer callback could execute later and so we
// should not release the refcount on the TIMER_CALLBACK
// The refcount will be released in the TimerCallback().

// Release the ref count if callback is NOT pending.
DWORD TIMER_PROCESSOR::TimprocCancelTimer (void) {

   HRESULT HResult = S_OK;

   if (m_TimerHandle != NULL) {

       if (DeleteTimerQueueTimer(NATH323_TIMER_QUEUE, m_TimerHandle, NULL)) {

           DecrementLifetimeCounter ();
       }
       else {

           HResult = GetLastError ();
       }

       m_TimerHandle = NULL;  
   }

   return HResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\timer.h ===
/*++

Copyright (c) 1998 - 2000  Microsoft Corporation

Module Name:

    timer.h

Abstract:

    Contains:
        Declarations of classes, routines and constants needed for
        timer manipulations.

Environment:

    User Mode - Win32

History:
    
    1. 14-Feb-2000 -- File creation                     Ilya Kleyman  (ilyak)

--*/
#ifndef    __h323ics_timer_h
#define    __h323ics_timer_h


#define    NATH323_TIMER_QUEUE        NULL            // use default timer queue

// Classes (Q931 src, dest and H245) inheriting
// from this create timers
// this class provides the callback method for the event manager

class TIMER_PROCESSOR
{
protected:
    TIMER_HANDLE        m_TimerHandle;            // RTL timer queue timer

public:

    TIMER_PROCESSOR            (void)
    :    m_TimerHandle        (NULL)
    {}

    // This method is implemented by Q931_INFO and LOGICAL_CHANNEL
    virtual void TimerCallback    (void) = 0;

    virtual void IncrementLifetimeCounter (void) = 0;
    virtual void DecrementLifetimeCounter (void) = 0;
        
    DWORD TimprocCreateTimer    (
        IN    DWORD    Interval);            // in milliseconds

    DWORD TimprocCancelTimer    (void);
};

#endif // __h323ics_timer_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\timerval.h ===
/*---------------------------------------------------
Copyright (c) 1998, Microsoft Corporation
File: timerval.h

Purpose: 
    Contains H.323 related timer values. Timer values are only
	used to clean up state in case of client error and are not
	aggressive.

History:

    1. created as cb931pdu.h for q931 consts (rajeevb, 19-Jun-1998)
	2. now contains all timer values for q931 and h245 (rajeevb, 19-Jun-1998)

---------------------------------------------------*/
#ifndef __CB_TIMER_H__
#define __CB_TIMER_H__

// timers defined below are in seconds and indicate
// the number of seconds to wait before attempting to
// cleanup
// these are only loosely based on the H.323 specs in that
// they are only used to clean-up state and give a long leash
// to callee's in responding to messages (more than the spec)

#ifndef DBG
// we wait for the callee to respond
// to a SETUP PDU, we wait for a
// CALL PROCEEDING, ALERTING, CONNECT or RELEASE COMPLETE PDU
// the H.225 spec suggests that the caller wait for 4s 
const DWORD Q931_POST_SETUP_TIMER_VALUE = 60000;	// 1min

// we wait for the callee to respond
// to a CALL PROCEEDING PDU, we wait for an 
// ALERTING, CONNECT or RELEASE COMPLETE PDU
// the H.225 spec doesn't define the time to wait for this
const DWORD Q931_POST_CALL_PROC_TIMER_VALUE = 600000;	// 10mins

// we wait for the callee to respond
// to an ALERTING PDU, we wait for a 
// CONNECT or RELEASE COMPLETE PDU
// the H.225 spec suggests 180s (3mins) of wait for this
const DWORD Q931_POST_ALERTING_TIMER_VALUE = 600000;	// 10mins

// we wait for the callee to respond
// to an OPEN LOGICAL CHANNEL PDU, we wait for a 
// OPEN LOGICAL CHANNEL ACK/REJECT PDU from the callee
// the caller may send a CLOSE LOGICAL CHANNEL PDU in the meantime
// which would cause this to be reset
// I (rajeevb) couldn't find H.245 spec suggestion for this
const DWORD LC_POST_OPEN_TIMER_VALUE = 600000;	// 10mins

// we wait for the callee to respond
// to an CLOSE LOGICAL CHANNEL PDU, we wait for a 
// CLOSE LOGICAL CHANNEL ACK PDU from the callee
// I (rajeevb) couldn't find H.245 spec suggestion for this
const DWORD LC_POST_CLOSE_TIMER_VALUE = 600000;	// 10mins

#else // DBG

// Feel free to play around with the Timer values here

const DWORD Q931_POST_SETUP_TIMER_VALUE = 60000;	// 1min
const DWORD Q931_POST_CALL_PROC_TIMER_VALUE = 60000; //600000;	// 10mins
const DWORD Q931_POST_ALERTING_TIMER_VALUE = 60001; //600001;	// 10mins
const DWORD LC_POST_OPEN_TIMER_VALUE = 600000;	// 10mins
const DWORD LC_POST_CLOSE_TIMER_VALUE = 600001;	// 10mins

#endif // DBG

#endif // __CB_TIMER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\nath323\util.cpp ===
#include "stdafx.h"

#if	defined(DBG)

void Debug (LPCWSTR Text)
{
	UNICODE_STRING	UnicodeString;
	ANSI_STRING		AnsiString;
	NTSTATUS		Status;

	assert (Text);

    if (DebugLevel > 0) {

        RtlInitUnicodeString (&UnicodeString, Text);

        Status = RtlUnicodeStringToAnsiString (&AnsiString, &UnicodeString, TRUE);
        
        if (NT_SUCCESS (Status)) {

            OutputDebugStringA (AnsiString.Buffer);
            RtlFreeAnsiString (&AnsiString);
        }
    }
}

void DebugVa (LPCTSTR Format, va_list VaList)
{
	TCHAR	Text	[0x200];

	_vsntprintf (Text, 0x200, Format, VaList);
	Debug (Text);
}

void DebugF (LPCTSTR Format, ...)
{
	va_list	VaList;

	va_start (VaList, Format);
	DebugVa (Format, VaList);
	va_end (VaList);
}

void DumpError (DWORD ErrorCode)
{
	TCHAR	Text	[0x200];
	DWORD	TextLength;
	DWORD	MaxLength;
	LPTSTR	Pos;

	_tcscpy (Text, _T("\tError: "));
	Pos = Text + _tcslen (Text);

	MaxLength = 0x200 - (DWORD)(Pos - Text);

	TextLength = FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM, NULL, ErrorCode, LANG_NEUTRAL, Text, 0x200, NULL);
	if (!TextLength)
		_sntprintf (Pos, MaxLength, _T("Uknown error %08XH %u"), ErrorCode, ErrorCode);

	_tcsncat (Text, _T("\n"), MaxLength);
	Text [MaxLength - 1] = 0;

	Debug (Text);
}

void DebugError (DWORD ErrorCode, LPCTSTR Text)
{
	Debug (Text);
	DumpError (ErrorCode);
}

void DebugErrorF (DWORD ErrorCode, LPCTSTR Format, ...)
{
	va_list	VaList;

	va_start (VaList, Format);
	DebugVa (Format, VaList);
	va_end (VaList);

	DumpError (ErrorCode);
}

void DebugLastError (LPCTSTR Text)
{
	DebugError (GetLastError(), Text);
}

void DebugLastErrorF (LPCTSTR Format, ...)
{
	va_list	VaList;
	DWORD	ErrorCode;

	ErrorCode = GetLastError();

	va_start (VaList, Format);
	DebugVa (Format, VaList);
	va_end (VaList);

	DumpError (ErrorCode);
}

static __inline CHAR ToHexA (UCHAR x)
{
	x &= 0xF;
	if (x < 10) return x + '0';
	return (x - 10) + 'A';
}

void DumpMemory (const UCHAR * Data, ULONG Length)
{
	const UCHAR *	DataPos;		// position within data
	const UCHAR *	DataEnd;		// end of valid data
	const UCHAR *	RowPos;		// position within a row
	const UCHAR *	RowEnd;		// end of single row
	CHAR			Text	[0x100];
	LPSTR			TextPos;
	ULONG			RowWidth;

	assert (Data);

    if (DebugLevel > 1) {

        DataPos = Data;
        DataEnd = Data + Length;

        while (DataPos < DataEnd) {
            RowWidth = (DWORD)(DataEnd - DataPos);

            if (RowWidth > 16)
                RowWidth = 16;

            RowEnd = DataPos + RowWidth;

            TextPos = Text;
            *TextPos++ = '\t';

            for (RowPos = DataPos; RowPos < RowEnd; RowPos++) {
                *TextPos++ = ToHexA ((*RowPos >> 4) & 0xF);
                *TextPos++ = ToHexA (*RowPos & 0xF);
                *TextPos++ = ' ';
            }

            *TextPos++ = '\r';
            *TextPos++ = '\n';
            *TextPos = 0;

            OutputDebugStringA (Text);

            assert (RowEnd > DataPos);		// make sure we are walking forward

            DataPos = RowEnd;
        }
    }
}

#endif // defined(DBG)

// LIFETIME_CONTROLLER  -------------------------------------------------------------------------

LIFETIME_CONTROLLER::LIFETIME_CONTROLLER (SYNC_COUNTER * AssocSyncCounter) {

	ReferenceCount = 0L;

	AssociatedSyncCounter = AssocSyncCounter;

	if (AssociatedSyncCounter)
		AssociatedSyncCounter -> Increment ();

#if ENABLE_REFERENCE_HISTORY
	InitializeCriticalSection (&ReferenceHistoryLock);

	if (AssociatedSyncCounter) {
		
		AssociatedSyncCounter -> Lock ();
		
		InsertTailList (&AssociatedSyncCounter -> ActiveLifetimeControllers, &ListEntry);

		AssociatedSyncCounter -> Unlock ();
	
	}
#endif // ENABLE_REFERENCE_HISTORY
}

LIFETIME_CONTROLLER::~LIFETIME_CONTROLLER () {

#if ENABLE_REFERENCE_HISTORY

	if (AssociatedSyncCounter) {
		
		AssociatedSyncCounter -> Lock ();

		RemoveEntryList(&ListEntry);

		AssociatedSyncCounter -> Unlock ();
	}

	DeleteCriticalSection(&ReferenceHistoryLock);
#endif // ENABLE_REFERENCE_HISTORY

	_ASSERTE (ReferenceCount == 0L);
}

void LIFETIME_CONTROLLER::AddRef (void) {

	LONG Count;

	_ASSERTE (ReferenceCount >= 0L);

	Count = InterlockedIncrement (&ReferenceCount);

#if ENABLE_REFERENCE_HISTORY
	MAKE_REFERENCE_HISTORY_ENTRY ();
#endif //ENABLE_REFERENCE_HISTORY

}

void LIFETIME_CONTROLLER::Release (void) {

	LONG	Count;

	Count = InterlockedDecrement (&ReferenceCount);

#if ENABLE_REFERENCE_HISTORY
	MAKE_REFERENCE_HISTORY_ENTRY ();
#endif // ENABLE_REFERENCE_HISTORY
	
	_ASSERTE (Count >= 0);

	if (Count == 0) {

		SYNC_COUNTER * LocalAssociatedSyncCounter;

		LocalAssociatedSyncCounter = AssociatedSyncCounter;

		delete this;	

		if (LocalAssociatedSyncCounter)
			LocalAssociatedSyncCounter -> Decrement ();
	}
}


// SYNC_COUNTER ------------