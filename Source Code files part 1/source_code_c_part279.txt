_qyInput = null;
                    firstInput = null;
                    return new MergeFilterQuery(parent, input);
                }
                firstInput = null;
            }
            return new FilterQuery(qyInput, opnd, filterflag);
        }

        private IQuery ProcessOperand(Operand root) {
            return new OperandQuery(root.OperandValue, root.ReturnType);
        }

        private IQuery ProcessVariable(Variable root) {
            _hasPrefix = true;
            if (! allowVar) {
                throw new XPathException(Res.Xp_InvalidKeyPattern, _query);
            }
            return new VariableQuery(root.Localname, root.Prefix);
        }

        private IQuery ProcessFunction(
                                      System.Xml.XPath.Function root,
                                      IQuery qyInput,ref bool cache, ref bool position) {
            _specialAxis = false;
            IQuery qy = null;
            switch (root.TypeOfFunction) {
                case FT.FuncLast :
                     qy = new MethodOperand(
                                            null,
                                            root.TypeOfFunction);
                    cache = true;
                    return qy;
                case FT.FuncPosition :
                    qy =  new MethodOperand(
                                            null,
                                            root.TypeOfFunction);
                    position = true;
                    return qy;
                case FT.FuncCount :
                    return new MethodOperand(
                                            ProcessNode((AstNode)(root.ArgumentList[0]),null, 
                                                        Regular_D, 
                                                        Axis.AxisType.None, ref cache, ref position),
                                            FT.FuncCount);
                case FT.FuncID :
                    _specialAxis = true;
                    return new IDQuery(
                                       ProcessNode((AstNode)(root.ArgumentList[0]),null, 
                                                        Regular_D, 
                                                        Axis.AxisType.None, ref cache, ref position));
                case FT.FuncLocalName :
                case FT.FuncNameSpaceUri :
                case FT.FuncName :
                    if (root.ArgumentList != null && root.ArgumentList.Count > 0)
                        return new MethodOperand( ProcessNode(
                                                             (AstNode)(root.ArgumentList[0]),null, 
                                                             Regular_D, 
                                                             Axis.AxisType.None, ref cache, ref position),
                                                             root.TypeOfFunction);
                    else
                        return new MethodOperand(
                                                null,
                                                root.TypeOfFunction);
                case FT.FuncString:
                case FT.FuncConcat:
                case FT.FuncStartsWith:
                case FT.FuncContains:
                case FT.FuncSubstringBefore:
                case FT.FuncSubstringAfter:
                case FT.FuncSubstring:
                case FT.FuncStringLength:
                case FT.FuncNormalize:
                case FT.FuncTranslate:
                    ArrayList ArgList = null; 
                    if (root.ArgumentList != null) {
                        int count = 0;
                        ArgList = new ArrayList();
                        while (count < root.ArgumentList.Count)
                            ArgList.Add(ProcessNode(
                                                   (AstNode)root.ArgumentList[count++],
                                                   null, Regular_D, 
                                                   Axis.AxisType.None, ref cache, ref position));
                    }
                    return new StringFunctions(ArgList,root.TypeOfFunction);
                case FT.FuncNumber:
                case FT.FuncSum:
                case FT.FuncFloor:
                case FT.FuncCeiling:
                case FT.FuncRound:
                    if (root.ArgumentList != null && root.ArgumentList.Count > 0)
                        return new NumberFunctions(
                                                  ProcessNode((AstNode)root.ArgumentList[0], 
                                                              null, Regular_D, 
                                                              Axis.AxisType.None, ref cache, ref position),root.TypeOfFunction);
                    else
                        return new NumberFunctions(null);
                case FT.FuncTrue:
                case FT.FuncFalse:
                    return new BooleanFunctions(null,root.TypeOfFunction);
                case FT.FuncNot:
                case FT.FuncLang:
                case FT.FuncBoolean:
                    return new BooleanFunctions(
                                               ProcessNode((AstNode)root.ArgumentList[0], 
                                                           null, Regular_D, 
                                                           Axis.AxisType.None, ref cache, ref position),root.TypeOfFunction);
                case FT.FuncUserDefined:
                    _hasPrefix = true;
                    ArgList = null; 
                    if (! allowCurrent && root.Name == "current" && root.Prefix == "") {
                        throw new XPathException(Res.Xp_InvalidPatternString, _query);
                    }
                    if (! allowKey && root.Name == "key" && root.Prefix == "") {
                        throw new XPathException(Res.Xp_InvalidKeyPattern, _query);
                    }
                    if (root.ArgumentList != null) {
                        int count = 0;
                        ArgList = new ArrayList();
                        while (count < root.ArgumentList.Count)
                            ArgList.Add(ProcessNode(
                                                   (AstNode)root.ArgumentList[count++],
                                                   null, Regular_D, 
                                                   Axis.AxisType.None, ref cache, ref position));
                    }
                    return new XsltFunction(root.Prefix, root.Name, ArgList);
                default :
                    throw new XPathException(Res.Xp_NotSupported, _query);
            }

            //return null;
        }

        private void VerifyArgument(System.Xml.XPath.Function root) {
            if (root.ArgumentList != null ) {
                for(int i = 0; i < root.ArgumentList.Count; i++) {
                    Operand operand = root.ArgumentList[i]  as Operand;
                    if ( (operand == null) || (operand.ReturnType != XPathResultType.String) ) {
                        throw new XPathException(Res.Xp_InvalidPatternString, _query);
                    }       
                }
            }
        }
        
        private IQuery ProcessNode(AstNode root, IQuery qyInput,int parent, 
                                   Axis.AxisType parentaxis, ref bool cache, ref bool position) {
            IQuery result = null;
            if (root == null)
                return null;
            switch (root.TypeOfAst) {
                case AstNode.QueryType.Axis:
                    filterCount = 0;
                    firstInput = null;
                    Axis axis = (Axis)root;
                    if (axis.TypeOfAxis == Axis.AxisType.Descendant || axis.TypeOfAxis == 
                        Axis.AxisType.DescendantOrSelf)
                        if (_smart > 0) {
                            result = ProcessAxis(
                                                axis,
                                                ProcessNode(axis.Input, 
                                                            qyInput,Smart_D,
                                                            axis.TypeOfAxis, ref cache, ref position), 
                                                            parent, parentaxis);
                            break;
                        }
                    _smart++;
                    result = ProcessAxis(
                                        axis,
                                        ProcessNode(axis.Input, 
                                                    qyInput,Regular_D,
                                                    axis.TypeOfAxis, ref cache, ref position),
                                                    parent, parentaxis);
                    _smart--;
                    break;
                case AstNode.QueryType.Operator:
                    _smart = 2;
                    result = ProcessOperator((Operator)root, null, ref cache, ref position);
                    break;
                case AstNode.QueryType.Filter:
                    _smart = 2;
                    result = ProcessFilter((Filter)root, ref cache, ref position);
                    break;
                case AstNode.QueryType.ConstantOperand:
                    result = ProcessOperand((Operand)root);
                    break;
                case AstNode.QueryType.Variable:
                    result = ProcessVariable((Variable)root);
                    break;
                case AstNode.QueryType.Function:
                    result = ProcessFunction(
                                            (System.Xml.XPath.Function)root,
                                            qyInput, ref cache, ref position);
                    break;
                case AstNode.QueryType.Group:
                    _smart = 2;
                    result = new GroupQuery(ProcessNode(
                                                       ((System.Xml.XPath.Group)root).GroupNode,
                                                       qyInput,Regular_D, 
                                                       Axis.AxisType.None,
                                                       ref cache, ref position));
                    break;
                case AstNode.QueryType.Root:
                    result = new AbsoluteQuery();
                    break;
                default:
                    Debug.Assert(false, "Unknown QueryType encountered!!");
                    break;
            }
            return result;
        }

        internal IQuery Build(AstNode root, String query)
        {
            // before we go off and build the query tree for essentially
            // brute force walking of the tree, let's see if we recognize
            // the abstract syntax tree (AST) to be one of the 6 special
            // patterns that we already know about.
            reset();
            _query = query;
            bool flag1 = false, flag2 = false;
            return ProcessNode(root, null,Regular_D,  Axis.AxisType.None, ref flag1, ref flag2);
        } //Build

        internal IQuery Build(string query, bool allowVar, bool allowKey) {
            this.allowVar = allowVar;
            this.allowKey = allowKey;
            this.allowCurrent = true;
            return  Build(XPathParser.ParseXPathExpresion(query), query);
        }

        internal IQuery Build(string query, out bool hasPrefix) {
            IQuery result =  Build(query, true, true);
            hasPrefix = _hasPrefix;
            return result;
        }
        
        internal IQuery BuildPatternQuery(string query, bool allowVar, bool allowKey) {
            this.allowVar = allowVar;
            this.allowKey = allowKey;
            this.allowCurrent = false;
            return Build(XPathParser.ParseXPathPattern(query), query);
        }

        internal IQuery BuildPatternQuery(string query, out bool hasPrefix) {
            IQuery result =  BuildPatternQuery(query, true, true);
            hasPrefix = _hasPrefix;
            return result;
        }
    } // QueryBuilder
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\sortquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="SortQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System;
    using System.Xml.Xsl;
    using System.Globalization;
    using System.Diagnostics;
    using System.Collections;
    using FT = System.Xml.XPath.Function.FunctionType;
    using Debug = System.Diagnostics.Debug;

    
    internal sealed class SortQuery : IQuery {
        private ArrayList results = new ArrayList();
        private XPathSortComparer comparer = new XPathSortComparer();
        private int _advance = 0;
        private IQuery _qyInput;

        internal SortQuery(IQuery  qyParent) {
            Debug.Assert(qyParent != null, "Sort Query needs an input query tree to work on");
            _qyInput = qyParent;
            this.results = new ArrayList();
        }
        
        internal SortQuery(SortQuery originalQuery) {
            this._qyInput = originalQuery._qyInput.Clone();
            this.comparer = originalQuery.comparer.Clone();
        }

        internal override XPathResultType ReturnType() {
            return XPathResultType.NodeSet;
        }

        internal override void setContext(XPathNavigator e) {
            reset();
            _qyInput.setContext(e);
        }


        internal override XPathNavigator peekElement() {
            Debug.Assert(false, "Didn't expect this method to be called.");
            return null;
        }

        internal override Querytype getName() {
            return Querytype.Sort;
        }

        internal override void reset() {
            this.results.Clear();
            _advance = 0;
            _qyInput.reset();
        }

        internal override IQuery Clone() {
            return new SortQuery(this);
        }

        internal override void SetXsltContext(XsltContext context) {}

        internal override XPathNavigator advance() {
            if (this.results.Count == 0) {
                BuildResultsList(); // build up a sorted list of results

                if (this.results.Count == 0) {
                    return null;
                }
            }
            if (_advance < this.results.Count) {
                return((SortKey)(this.results[_advance++])).Node;
            }
            else return null;
        }

        internal override int Position {
            get {
		        Debug.Assert( _advance > 0, " Called Position before advance ");
                return ( _advance - 1 );
            }
        }
        
        private void BuildResultsList() {
            Int32 numSorts = this.comparer.NumSorts;

            Debug.Assert(numSorts > 0, "Why was the sort query created?");

            XPathNavigator eNext;
            while ((eNext = _qyInput.advance()) != null) {
                SortKey key = new SortKey(numSorts, /*originalPosition:*/this.results.Count, eNext.Clone());

                for (Int32 j = 0; j < numSorts; j ++) {
                    object keyval = this.comparer.Expression(j).getValue(_qyInput);
                    key[j] = keyval;
                }

                results.Add(key);
            }
            results.Sort(this.comparer);
        }

        internal void AddSort(IQuery evalQuery, IComparer comparer) {
            this.comparer.AddSort(evalQuery, comparer);
        }
    } // class SortQuery

    internal sealed class SortKey {
        private Int32          numKeys;
        private object[]       keys;
        private int            originalPosition;
        private XPathNavigator node;

        public SortKey(int numKeys, int originalPosition, XPathNavigator node) {
            this.numKeys          = numKeys;
            this.keys             = new object[numKeys];
            this.originalPosition = originalPosition;
            this.node             = node;
        }

        public object this[int index] { 
            get { return this.keys[index]; }
            set { this.keys[index] = value; }
        }

        public int NumKeys {
            get { return this.numKeys; }
        }
        
        public int OriginalPosition {
            get { return this.originalPosition; }
        }

        public XPathNavigator Node {
            get { return this.node; }
        }
    } // class SortKey

    internal sealed class XPathSortComparer : IComparer {
        private const int   minSize = 3;
        private IQuery[]    expressions;
        private IComparer[] comparers;
        private int         numSorts;
        
        public XPathSortComparer(int size) {
            if (size <= 0) size = minSize;
            this.expressions   = new IQuery[   size];
            this.comparers     = new IComparer[size];
        }
        public XPathSortComparer() : this (minSize) {}

        public void AddSort(IQuery evalQuery, IComparer comparer) {
            Debug.Assert(this.expressions.Length == this.comparers.Length);
            Debug.Assert(0 < this.expressions.Length);
            Debug.Assert(0 <= numSorts && numSorts <= this.expressions.Length);
            // Ajust array sizes if needed.
            if (numSorts == this.expressions.Length) {
                IQuery[]    newExpressions = new IQuery[   numSorts * 2];
                IComparer[] newComparers   = new IComparer[numSorts * 2];
                for (int i = 0; i < numSorts; i ++) {
                    newExpressions[i] = this.expressions[i];
                    newComparers  [i] = this.comparers[i];                
                }
                this.expressions = newExpressions;
                this.comparers   = newComparers;
            }
            Debug.Assert(numSorts < this.expressions.Length);

            // Fixup expression to handle node-set resurn type:
            XPathResultType queryType = evalQuery.ReturnType();
            if (queryType == XPathResultType.NodeSet || queryType == XPathResultType.Error || queryType == XPathResultType.Any) {
                ArrayList argList = new ArrayList();
                argList.Add(evalQuery);
                evalQuery = new StringFunctions(argList, FT.FuncString);
            }

            this.expressions[numSorts] = evalQuery;
            this.comparers[  numSorts] = comparer;
            numSorts ++;
        }

        public int NumSorts {
            get { return numSorts; }
        }

        public IQuery Expression(int i) {
            return this.expressions[i];
        }

        int IComparer.Compare(object x, object y) {
            Debug.Assert(x != null && y != null, "Oops!! what happened?");
            return Compare((SortKey)x, (SortKey)y);
        }

        public int Compare(SortKey x, SortKey y) {
            int result = 0;
            for (int i = 0; i < x.NumKeys; i ++) {
                result = this.comparers[i].Compare(x[i], y[i]);
                if (result != 0) {
                    return result;
                }
            }

            Debug.Assert(result == 0);

            // if after all comparisions, the two sort keys are still equal,
            // preserve the doc order
            return x.OriginalPosition - y.OriginalPosition;
        }

        internal XPathSortComparer Clone() {
            XPathSortComparer clone = new XPathSortComparer(this.numSorts);
            
            for (int i = 0; i < this.numSorts; i ++) {
                clone.comparers[i]   = this.comparers[i];
                clone.expressions[i] = this.expressions[i].Clone(); // Expressions should be cloned because IQuery should be cloned
            }
            clone.numSorts = this.numSorts;
            return clone;
        }
    } // class XPathSortComparer
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathancestorquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathAncestorQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Diagnostics;
    using System.Collections;

    internal sealed class XPathAncestorQuery : BaseAxisQuery {
        private XPathNavigator _eLast;
        private bool _fMatchSelf;
        private ArrayList _stack = new ArrayList();
        private ArrayList _pathstack = new ArrayList();
        private bool _fSelfCheckedBefore;
        private bool filledstack;
        private int _top;

        internal XPathAncestorQuery(
                                   IQuery  qyInput,
                                   bool matchSelf,
                                   String Name,
                                   String Prefix,
                                   String URN,
                                   XPathNodeType Type) : base(qyInput, Name, Prefix, URN, Type) {
            _fMatchSelf = matchSelf;
        }

        internal override void reset() {
            _eLast = null;
            _fSelfCheckedBefore = false;
            _stack.Clear();
            _pathstack.Clear();
            filledstack = false;
            base.reset();
        }

        internal override void setContext(XPathNavigator e) {
            reset();
            base.setContext(e);
        }
        
        override internal XPathNavigator advancefordescendant() {
            XPathNavigator result = null;
            ArrayList elementList = new ArrayList();
            int i = 0;
            _eLast = m_qyInput.advance();
            while (_eLast != null){
                for(i = 0; i < elementList.Count; i++ ) {
                    if (  ((XPathNavigator)elementList[i]).IsDescendant(_eLast)) {
                       break;
                    }
                }
                if ( i == _pathstack.Count )
                    break;
                _eLast = m_qyInput.advance();
            }
            
            if (_eLast == null )
                return null;
            result = _eLast.Clone();
            while (true) {
                if (_fMatchSelf)
                    if (matches( _eLast))
                        result.MoveTo(_eLast);
                if (!_eLast.MoveToParent())
                {
                    elementList.Add(result);
                    return result;
                }
                else{
                    if (matches(_eLast)){
                        result.MoveTo(_eLast);
                    }
                }
                
            }
        }

        internal XPathNavigator advanceforancestor() {
            _eLast = m_qyInput.advance();
            while (true) {
                if (_eLast == null)
                    return null;
                if (_fMatchSelf)
                    if (matches( _eLast))
                        return _eLast;
                if (_eLast.MoveToParent())
                    if (matches(_eLast))
                        return _eLast;
            }
        }
        
        internal override Querytype getName() {
            return Querytype.Ancestor;
        }

        internal override XPathNavigator advance() {

            if (! filledstack)
                populatestack();

            if (_top > 0) {
                _position--;
                m_eNext = (XPathNavigator)_stack[--_top];
                return m_eNext;
            }
            else
                return null;
        }

        private void populatestack() {
            filledstack = true;
            
            _eLast = m_qyInput.advance();
			if (_eLast != null )
				_eLast = _eLast.Clone();
            do {
                if (_eLast == null)
                    break;
                if (_fMatchSelf && !_fSelfCheckedBefore) {
                    _fSelfCheckedBefore = true;
                    if (matches(_eLast))
                        NotVisited(_eLast);
                }
                if (!_eLast.MoveToParent()) {
                    _eLast = m_qyInput.advance();
                    _fSelfCheckedBefore = false;
                    if (_eLast != null)
                    	_eLast = _eLast.Clone();

                }
                else
                {
                    if (matches(_eLast))
                        NotVisited(_eLast);
                }

            } while (true);
            _top = _stack.Count;
            _position = _top + 1;
        }


        void NotVisited(XPathNavigator current)
        {
            XmlNodeOrder compare;
            for (int i=0; i< _stack.Count ; i++)
            {
                XPathNavigator nav = _stack[i] as XPathNavigator;
                compare = nav.ComparePosition(current) ;      
                if (compare == XmlNodeOrder.Same ) return;
                if (compare == XmlNodeOrder.Before)
                {
                    _stack.Insert(i,current.Clone());
                    return;
                }
            }
            _stack.Add(current.Clone());
        }

        internal override IQuery Clone() {
            return new XPathAncestorQuery(CloneInput(),_fMatchSelf, m_Name,m_Prefix,m_URN,m_Type);
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\variable.cs ===
//------------------------------------------------------------------------------
// <copyright file="Variable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Diagnostics;

    internal class Variable : AstNode {
        private String _Localname;
	    private String _Prefix = String.Empty;

        internal Variable(String name, String prefix) {
            _Localname = name;
	        _Prefix = prefix;
        }

        internal override QueryType TypeOfAst {
            get {return QueryType.Variable;}
        }

        internal override XPathResultType ReturnType {
            get {return XPathResultType.Error;}
        }

        internal String Name {
            get {
			    if( Prefix != String.Empty ) {
                    return _Prefix + ":" + _Localname;
			    }
			    else {
				    return _Localname;
				    }
			    }
        }
        
        internal String Localname {
            get {return _Localname;}
        }

       	internal String Prefix {
            get {return _Prefix;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathancestoriterator.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathAncestorIterator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XPathAncestorIterator.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml.XPath {
    using System;

    internal class XPathAncestorIterator: XPathAxisIterator {
        public XPathAncestorIterator(XPathNavigator nav, XPathNodeType type, bool matchSelf) : base(nav, type, matchSelf) {}
        public XPathAncestorIterator(XPathNavigator nav, string name, string namespaceURI, bool matchSelf) : base(nav, name, namespaceURI, matchSelf) {}
        public XPathAncestorIterator(XPathAncestorIterator it) : base(it) {}

        public override XPathNodeIterator Clone() {
            return new XPathAncestorIterator(this);
        }

        public override bool MoveNext() {
            if(first) {
                first = false;
                if(matchSelf && Matches) {
                    position = 1;
                    return true;
                }
            }

            while(nav.MoveToParent()) {
                if(Matches) {
                    position ++;
                    return true;
                }
            }
            return false;
        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xmliteratorquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlIteratorQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlIteratorQuery.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml {
    using System;
    using System.Xml.XPath;

    internal class XmlIteratorQuery: IQuery {
        ResetableIterator it;

        public XmlIteratorQuery( ResetableIterator it ) {
            this.it = it;
        }

        internal override XPathNavigator peekElement() {
            return it.Current;
        }

        internal override XPathNavigator advance() {
            if( it.MoveNext() ) {
                return it.Current;
            }
            return null;
        }

        internal override XPathResultType ReturnType() {
            return XPathResultType.NodeSet;
        }

        internal override void reset() {
            it.Reset();
        }

        internal override IQuery Clone() {
            return new XmlIteratorQuery(it.MakeNewCopy());
        }
        
        internal override int Position {
            get {
                return it.CurrentPosition;
            }
        }

        internal override object getValue(IQuery qy) {
            return it;
        }
        internal override object getValue(XPathNavigator qy, XPathNodeIterator iterator) {
            return it;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\variablequery.cs ===
//------------------------------------------------------------------------------
// <copyright file="VariableQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Xml.Xsl;

    using System.Collections;

    internal  class VariableQuery : IQuery {
        private String Name;
        private String Prefix;
        private IQuery _VarQuery;
        private IXsltContextVariable xsltContextVariable;
        
        internal VariableQuery(string name, string prefix) {
            this.Name = name;
            this.Prefix = prefix;
        }

        private VariableQuery( string name, string prefix, IQuery varQuery) {
            this.Name = name;
            this.Prefix = prefix;
            this._VarQuery = varQuery;
        }
        
        internal override void SetXsltContext(XsltContext context) {
            if (context == null) {
                throw new XPathException(Res.Xp_UndefinedXsltContext, Prefix, Name);
            }

            if(xsltContextVariable == null) {
                xsltContextVariable = context.ResolveVariable(Prefix, Name);
                Debug.Assert(xsltContextVariable != null, "XSLT has to resolve it or throw exception");
            }
            else {
                Debug.Assert(xsltContextVariable == context.ResolveVariable(Prefix, Name), "ResolveVariable supposed to return the same VariableAction each time");
            }
            Object result = xsltContextVariable.Evaluate(context);
            if (result == null) {
                throw new XPathException(Res.Xslt_InvalidVariable, Name);
            }

            switch (Type.GetTypeCode(result.GetType())) {
            case TypeCode.String  : _VarQuery = new OperandQuery(result, XPathResultType.String); break;
            case TypeCode.Double  : _VarQuery = new OperandQuery(result, XPathResultType.Number); break;
            case TypeCode.Boolean : _VarQuery = new OperandQuery(result, XPathResultType.Boolean); break;
            case TypeCode.Int32   : _VarQuery = new OperandQuery(XmlConvert.ToXPathDouble(result), XPathResultType.Number); break;
            default :
                if (result is ResetableIterator) {
                    ResetableIterator it = result as ResetableIterator;
                    _VarQuery = new XmlIteratorQuery( (ResetableIterator) it.Clone() );
                }
                else if (result is XPathNavigator) {
                    _VarQuery = new NavigatorQuery((XPathNavigator)result);
                }            
                else if (result is XPathNodeIterator) {
                    Debug.Assert(false, "Unexpected type of XPathNodeIterator");
                    throw new NotSupportedException(Res.GetString(Res.XmlUnsupportedType, result.GetType().FullName));             
                }
                else {
                    Debug.Assert(false, "Unexpected variable type");
                    throw new NotSupportedException(Res.GetString(Res.XmlUnsupportedType, result.GetType().FullName));
                }
                break;
            }
            Debug.Assert(_VarQuery != null);           
        }
        
        internal override XPathNavigator advance() {
            if (_VarQuery != null )
                return _VarQuery.advance();
            throw new XPathException(Res.Xp_UndefinedXsltContext, Prefix, Name);
        } // Advance

        internal override Object getValue(IQuery qy) {
            if (_VarQuery != null )
                return _VarQuery.getValue(qy);
            throw new XPathException(Res.Xp_UndefinedXsltContext, Prefix, Name);
        } 

        internal override Object getValue(XPathNavigator qy, XPathNodeIterator iterator) {
            if (_VarQuery != null )
                return _VarQuery.getValue(qy, iterator);
            return null;
        } 
        
        internal override IQuery Clone() {            
            if (_VarQuery == null) {
                return new VariableQuery(Name, Prefix);
            }
            else {
                return new VariableQuery(Name, Prefix, _VarQuery.Clone());
            }
        }
        
        internal override XPathResultType  ReturnType() {
            if (_VarQuery != null)
                return _VarQuery.ReturnType();            
            throw new XPathException(Res.Xp_UndefinedXsltContext, Prefix, Name);
        }
        
        internal override Querytype getName() {
            if (_VarQuery != null)
                return _VarQuery.getName();
            return Querytype.None;
        }

        internal override void reset() {
            if (_VarQuery != null )
                _VarQuery.reset();
        } 

        internal override XPathNavigator peekElement() {
            if (_VarQuery != null )
                return _VarQuery.peekElement();
            throw new XPathException(Res.Xp_UndefinedXsltContext, Prefix, Name);
        }

        internal override int Position {
            get {
                Debug.Assert(_VarQuery != null , " Result Query is null in Position");
                return _VarQuery.Position; 
            } 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpatharrayiterator.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathArrayIterator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XPathArrayIterator.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml.XPath {
    using System;
    using System.Collections;
    using System.Diagnostics;

    /// <include file='doc\XPathArrayIterator.uex' path='docs/doc[@for="XPathArrayIterator"]/*' />
    internal class XPathArrayIterator: ResetableIterator {
        protected ArrayList array;
        protected int       index;

        /// <include file='doc\XPathArrayIterator.uex' path='docs/doc[@for="XPathArrayIterator.XPathArrayIterator"]/*' />
        public XPathArrayIterator(ArrayList array) {
            this.array = array;
        }

        /// <include file='doc\XPathArrayIterator.uex' path='docs/doc[@for="XPathArrayIterator.XPathArrayIterator2"]/*' />
        public XPathArrayIterator(XPathArrayIterator it) {
            this.array = it.array;
            this.index = it.index;
        }

        /// <include file='doc\XPathArrayIterator.uex' path='docs/doc[@for="XPathArrayIterator.XPathArrayIterator3"]/*' />
        public XPathArrayIterator(XPathNodeIterator iterator) {
            this.array = new ArrayList();
            while (iterator.MoveNext()) {
                this.array.Add(iterator.Current.Clone());
            }
        }

        public override ResetableIterator MakeNewCopy() {
            return new XPathArrayIterator(this.array);
        }

        /// <include file='doc\XPathArrayIterator.uex' path='docs/doc[@for="XPathArrayIterator.Clone"]/*' />
        public override XPathNodeIterator Clone() {
            return new XPathArrayIterator(this);
        }

        /// <include file='doc\XPathArrayIterator.uex' path='docs/doc[@for="XPathArrayIterator.Current"]/*' />
        public override XPathNavigator Current {
            get {
                Debug.Assert(index > 0, "MoveNext() wasn't called");
                return (XPathNavigator) array[index - 1];
            }
        }

        /// <include file='doc\XPathArrayIterator.uex' path='docs/doc[@for="XPathArrayIterator.CurrentPosition"]/*' />
        public override int CurrentPosition {
            get {
                Debug.Assert(index > 0, "MoveNext() wasn't called");
                return index ;
            }
        }

        /// <include file='doc\XPathArrayIterator.uex' path='docs/doc[@for="XPathArrayIterator.Count"]/*' />
        public override int Count {
            get {
                return array.Count;
            }
        }

        /// <include file='doc\XPathArrayIterator.uex' path='docs/doc[@for="XPathArrayIterator.MoveNext"]/*' />
        public override bool MoveNext() {
            Debug.Assert(index <= array.Count);
            if(index == array.Count) {
                return false;
            }
            index++;
            return true;
        }

        /// <include file='doc\XPathArrayIterator.uex' path='docs/doc[@for="XPathArrayIterator.Reset"]/*' />
        public override void Reset() {
            index = 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\stringfunctions.cs ===
//------------------------------------------------------------------------------
// <copyright file="StringFunctions.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Globalization;
    using System.Text;
    using System;
    using System.Xml.Xsl;
    using System.Collections;

    internal sealed class StringFunctions : IQuery {
        private ArrayList _ArgList;
        System.Xml.XPath.Function.FunctionType _FuncType;

        internal StringFunctions() {
        }
        internal StringFunctions(ArrayList qy, 
                                 System.Xml.XPath.Function.FunctionType ftype) {
            _ArgList = qy;
            _FuncType = ftype;
        }

        internal override void reset() {
            if (_ArgList != null)
                for (int i=0; i < _ArgList.Count; i++)
                    ((IQuery)_ArgList[i]).reset();
        }

        internal override void SetXsltContext(XsltContext context){
            if (_ArgList != null)
                for (int i=0; i < _ArgList.Count; i++)
                    ((IQuery)_ArgList[i]).SetXsltContext(context);
        }            
        
        internal override object getValue(IQuery qy) {
            switch (_FuncType) {
                case System.Xml.XPath.Function.FunctionType.FuncString :
                    return toString(qy);
                case System.Xml.XPath.Function.FunctionType.FuncConcat :
                    return Concat(qy);
                case System.Xml.XPath.Function.FunctionType.FuncStartsWith :
                    return Startswith(qy);
                case System.Xml.XPath.Function.FunctionType.FuncContains :
                    return Contains(qy);
                case System.Xml.XPath.Function.FunctionType.FuncSubstringBefore :
                    return Substringbefore(qy);
                case System.Xml.XPath.Function.FunctionType.FuncSubstringAfter :
                    return Substringafter(qy);
                case System.Xml.XPath.Function.FunctionType.FuncSubstring :
                    return Substring(qy);
                case System.Xml.XPath.Function.FunctionType.FuncStringLength :
                    return StringLength(qy);
                case System.Xml.XPath.Function.FunctionType.FuncNormalize :
                    return Normalize(qy);
                case System.Xml.XPath.Function.FunctionType.FuncTranslate :
                    return Translate(qy);
            }
            return String.Empty;
        }

        internal override object getValue(XPathNavigator qy, XPathNodeIterator iterator) {
            switch (_FuncType) {
                case System.Xml.XPath.Function.FunctionType.FuncString :
                    return toString(qy, iterator);
                case System.Xml.XPath.Function.FunctionType.FuncConcat :
                    return Concat(qy, iterator);
                case System.Xml.XPath.Function.FunctionType.FuncStartsWith :
                    return Startswith(qy, iterator);
                case System.Xml.XPath.Function.FunctionType.FuncContains :
                    return Contains(qy, iterator);
                case System.Xml.XPath.Function.FunctionType.FuncSubstringBefore :
                    return Substringbefore(qy, iterator);
                case System.Xml.XPath.Function.FunctionType.FuncSubstringAfter :
                    return Substringafter(qy, iterator);
                case System.Xml.XPath.Function.FunctionType.FuncSubstring :
                    return Substring(qy, iterator);
                case System.Xml.XPath.Function.FunctionType.FuncStringLength :
                    return StringLength(qy, iterator);
                case System.Xml.XPath.Function.FunctionType.FuncNormalize :
                    return Normalize(qy, iterator);
                case System.Xml.XPath.Function.FunctionType.FuncTranslate :
                    return Translate(qy, iterator);
            }
            return String.Empty;
        }
        
        internal static String toString(double num) {
            return num.ToString("R", NumberFormatInfo.InvariantInfo);
        }
        
        internal static String toString(Boolean b) {
            if (b)
                return "true";
            return "false";
        }

        private String toString(XPathNavigator qyContext, XPathNodeIterator iterator) {
            if (_ArgList != null && _ArgList.Count > 0) {
                IQuery _qy = (IQuery) _ArgList[0];

                if (_qy.ReturnType() == XPathResultType.NodeSet) {
                    _qy.setContext(qyContext.Clone());

                    XPathNavigator value = _qy.advance();

                    if (value  != null) {
                        return value.Value;
                    }
                    else {
                        return String.Empty;
                    }
                }
                else if (_qy.ReturnType() == XPathResultType.String) {
                    return  _qy.getValue(qyContext, iterator).ToString();
                }
                else if (_qy.ReturnType() == XPathResultType.Boolean) {
                    return( Convert.ToBoolean(_qy.getValue(qyContext, iterator)) ? "true" : "false");
                }
                else {
                    return toString(XmlConvert.ToXPathDouble(_qy.getValue(qyContext, iterator)));
                }
            }
            else if (qyContext != null) {
                return qyContext.Value;
            }
            else {
                return String.Empty;
            }
        }

        private String toString(IQuery qyContext) {
            XPathNavigator value = null;
            if (_ArgList != null && _ArgList.Count > 0) {
                IQuery _qy = (IQuery) _ArgList[0];

                if (_qy.ReturnType() == XPathResultType.NodeSet) {
  
                    _qy.setContext(qyContext.peekElement().Clone());
  
                    value = _qy.advance();
                    if (value  != null)
                        return value.Value;
                    else
                        return String.Empty;
                }
                else if (_qy.ReturnType() == XPathResultType.String) {
                    return  _qy.getValue(qyContext).ToString();
                }
                else if (_qy.ReturnType() == XPathResultType.Boolean) {
                    return toString(Convert.ToBoolean(_qy.getValue(qyContext)));
                }
                return toString(XmlConvert.ToXPathDouble(_qy.getValue(qyContext)));
            }
            else
                if ((value = qyContext.peekElement())!= null)
                return value.Value;
            else
                return String.Empty;
        }

        internal override XPathResultType ReturnType() {
            if (_FuncType == System.Xml.XPath.Function.FunctionType.FuncStringLength)
                return XPathResultType.Number;
            if (_FuncType == System.Xml.XPath.Function.FunctionType.FuncStartsWith  ||
                _FuncType == System.Xml.XPath.Function.FunctionType.FuncContains)
                return XPathResultType.Boolean;
            return XPathResultType.String;
        }

        private String Concat(IQuery qy) {
            int count = 0;
            StringBuilder s = new StringBuilder();
            while (count < _ArgList.Count)
                s.Append(((IQuery)_ArgList[count++]).getValue(qy).ToString());
            return s.ToString();
        }

        private String Concat(XPathNavigator qy, XPathNodeIterator iterator) {
            int count = 0;
            StringBuilder s = new StringBuilder();
            while (count < _ArgList.Count)
                s.Append(((IQuery)_ArgList[count++]).getValue(qy, iterator).ToString());
            return s.ToString();
        }

        private Boolean Startswith(IQuery qy) {
            String str1 = ((IQuery)_ArgList[0]).getValue(qy).ToString();
            String str2 = ((IQuery)_ArgList[1]).getValue(qy).ToString();

            return str1.StartsWith(str2);
        }

        private Boolean Startswith(XPathNavigator qy, XPathNodeIterator iterator) {
            String str1 = ((IQuery)_ArgList[0]).getValue(qy, iterator).ToString();
            String str2 = ((IQuery)_ArgList[1]).getValue(qy, iterator).ToString();

            return str1.StartsWith(str2);
        }

        private Boolean Contains(IQuery qy) {
            String str1 = ((IQuery)_ArgList[0]).getValue(qy).ToString();
            String str2 = ((IQuery)_ArgList[1]).getValue(qy).ToString();
            int index = str1.IndexOf(str2);
            if (index != -1)
                return true;
            return false;

        }

        private Boolean Contains(XPathNavigator qy, XPathNodeIterator iterator) {
            String str1 = ((IQuery)_ArgList[0]).getValue(qy, iterator).ToString();
            String str2 = ((IQuery)_ArgList[1]).getValue(qy, iterator).ToString();
            int index = str1.IndexOf(str2);
            if (index != -1)
                return true;
            return false;

        }

        private String Substringbefore(IQuery qy) {
            String str1 = ((IQuery)_ArgList[0]).getValue(qy).ToString();
            String str2 = ((IQuery)_ArgList[1]).getValue(qy).ToString();
            int index = str1.IndexOf(str2);
            if (index != -1)
                return str1.Substring(0,index);
            else
                return String.Empty;
        }

        private String Substringbefore(XPathNavigator qy, XPathNodeIterator iterator) {
            String str1 = ((IQuery)_ArgList[0]).getValue(qy, iterator).ToString();
            String str2 = ((IQuery)_ArgList[1]).getValue(qy, iterator).ToString();
            int index = str1.IndexOf(str2);
            if (index != -1)
                return str1.Substring(0,index);
            else
                return String.Empty;
        }

        private String Substringafter(IQuery qy) {
            String str1 = ((IQuery)_ArgList[0]).getValue(qy).ToString();
            String str2 = ((IQuery)_ArgList[1]).getValue(qy).ToString();
            int index = str1.IndexOf(str2);
            if (index != -1)
                return str1.Substring(index+str2.Length);
            else
                return String.Empty; 
        }

        private String Substringafter(XPathNavigator qy, XPathNodeIterator iterator) {
            String str1 = ((IQuery)_ArgList[0]).getValue(qy, iterator).ToString();
            String str2 = ((IQuery)_ArgList[1]).getValue(qy, iterator).ToString();
            int index = str1.IndexOf(str2);
            if (index != -1)
                return str1.Substring(index+str2.Length);
            else
                return String.Empty; 
        }

        private String Substring(IQuery qy) {
            String str1 = ((IQuery)_ArgList[0]).getValue(qy).ToString();
            double num = Math.Round(XmlConvert.ToXPathDouble(((IQuery)_ArgList[1]).getValue(qy))) - 1;
            if (double.IsNaN(num) || str1.Length <= num)
                return String.Empty;
            if (_ArgList.Count == 3) {
                double num1 = Math.Round(XmlConvert.ToXPathDouble(((IQuery)_ArgList[2]).getValue(qy))) ;
                if (double.IsNaN(num1))
                    return String.Empty;
                if (num < 0 || num1 < 0) {
                    num1 = num + num1;
                    if (num1 <= 0)
                        return String.Empty;
                    num = 0;
                }
                double maxlength = str1.Length - num;
                if (num1 > maxlength)
                    num1 = maxlength;
                return str1.Substring((int)num,(int)num1);
            }
            if (num < 0)
                num = 0;
            return str1.Substring((int)num);
        }

        private String Substring(XPathNavigator qy, XPathNodeIterator iterator) {
            String str1 = ((IQuery)_ArgList[0]).getValue(qy, iterator).ToString();
            double num = 
            Math.Round(XmlConvert.ToXPathDouble(((IQuery)_ArgList[1]).getValue(qy, iterator))) - 1 ;

            if (Double.IsNaN(num) || str1.Length <= num)
                return String.Empty;
            if (_ArgList.Count == 3) {
                double num1 = Math.Round(XmlConvert.ToXPathDouble(((IQuery)_ArgList[2]).getValue(qy, iterator))) ;
                if (Double.IsNaN(num1))
                    return String.Empty;
                if (num < 0 || num1 < 0 ) {
                    num1 = num + num1 ;
                    if (num1 <= 0)
                        return String.Empty;
                    num = 0;
                }
                double maxlength = str1.Length - num;
                if (num1 > maxlength)
                    num1 = maxlength;
                return str1.Substring((int)num ,(int)num1);
            }
            if (num < 0)
                num = 0;
            return str1.Substring((int)num );
        }

        private Double StringLength(IQuery qy) {
            if (_ArgList != null && _ArgList.Count > 0)
                return((IQuery)_ArgList[0]).getValue(qy).ToString().Length;
            else {
                XPathNavigator temp = qy.peekElement();
                if (temp != null)
                    return temp.Value.Length;
                else
                    return 0;
            }
        }

        private Double StringLength(XPathNavigator qy, XPathNodeIterator iterator) {
            if (_ArgList!= null && _ArgList.Count > 0)
                return((IQuery)_ArgList[0]).getValue(qy, iterator).ToString().Length;
            if (qy != null)
                return qy.Value.Length;
            return 0;
        }

        private String Normalize(IQuery qy) {
            String str1;
            if (_ArgList != null && _ArgList.Count > 0)
                str1 = ((IQuery)_ArgList[0]).getValue(qy).ToString().Trim();
            else
                str1 = qy.peekElement().Value.Trim();
            int count = 0;
            StringBuilder str2 = new StringBuilder();;
            bool FirstSpace = true;
            while (count < str1.Length) {
                if (!XmlCharType.IsWhiteSpace(str1[count])) {
                    FirstSpace = true;
                    str2.Append(str1[count]);
                }
                else
                    if (FirstSpace) {
                    FirstSpace = false;
                    str2.Append(str1[count]);
                }
                count++;
            }
            return str2.ToString();

        }
        private String Normalize(XPathNavigator qy, XPathNodeIterator iterator) {
            String str1;
            if (_ArgList != null && _ArgList.Count > 0)
                str1 = ((IQuery)_ArgList[0]).getValue(qy, iterator).ToString().Trim();
            else
                str1 = qy.Value.Trim();
            int count = 0;
            StringBuilder str2 = new StringBuilder();
            bool FirstSpace = true;
            while (count < str1.Length) {
                if (!XmlCharType.IsWhiteSpace(str1[count])) {
                    FirstSpace = true;
                    str2.Append(str1[count]);
                }
                else {
                    if (FirstSpace) {
                    FirstSpace = false;
                    str2.Append(' ');
                    }
                }
                count++;
            }
            return str2.ToString();

        }
        private String Translate(IQuery qy) {
            String str1 = ((IQuery)_ArgList[0]).getValue(qy).ToString();
            String str2 = ((IQuery)_ArgList[1]).getValue(qy).ToString();
            String str3 = ((IQuery)_ArgList[2]).getValue(qy).ToString();
            StringBuilder str = new StringBuilder();
            int count = 0, index;
            while (count < str1.Length) {
                index = str2.IndexOf(str1[count]);
                if (index != -1) {
                    if (index < str3.Length)
                        str.Append(str3[index]);
                }
                else
                    str.Append(str1[count]);
                count++;
            }
            return str.ToString();
        }
        private String Translate(XPathNavigator qy, XPathNodeIterator iterator) {
            String str1 = ((IQuery)_ArgList[0]).getValue(qy, iterator).ToString();
            String str2 = ((IQuery)_ArgList[1]).getValue(qy, iterator).ToString();
            String str3 = ((IQuery)_ArgList[2]).getValue(qy, iterator).ToString();
            int count = 0, index;
            StringBuilder str = new StringBuilder();
            while (count < str1.Length) {
                index = str2.IndexOf(str1[count]);
                if (index != -1) {
                    if (index < str3.Length)
                        str.Append(str3[index]);
                }
                else
                    str.Append(str1[count]);
                count++;
            }
            return str.ToString();
        }

        internal override IQuery Clone() {
            ArrayList newArgList = null;
            if (_ArgList != null) {
                newArgList = new ArrayList(_ArgList.Count);
                for (int i=0; i < _ArgList.Count; i++) {
                    newArgList.Add(((IQuery)_ArgList[i]).Clone());
                }
            }
            return new StringFunctions(newArgList, _FuncType); 
        }

    } // class Functions

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathemptyiterator.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathEmptyIterator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XPathEmptyIterator.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml.XPath {
    using System;
    using System.Diagnostics;
    
    /// <include file='doc\XPathEmptyIterator.uex' path='docs/doc[@for="XPathEmptyIterator"]/*' />
    internal class XPathEmptyIterator : ResetableIterator {
        /// <include file='doc\XPathEmptyIterator.uex' path='docs/doc[@for="XPathEmptyIterator.XPathEmptyIterator"]/*' />
        public XPathEmptyIterator() {}
        /// <include file='doc\XPathEmptyIterator.uex' path='docs/doc[@for="XPathEmptyIterator.Clone"]/*' />
        public override XPathNodeIterator Clone() {
            return new XPathEmptyIterator();
        }

        public override ResetableIterator MakeNewCopy() {
            return new XPathEmptyIterator();
        }
        
        /// <include file='doc\XPathEmptyIterator.uex' path='docs/doc[@for="XPathEmptyIterator.Current"]/*' />
        public override XPathNavigator Current {
            get { return null; }
        }

        /// <include file='doc\XPathEmptyIterator.uex' path='docs/doc[@for="XPathEmptyIterator.CurrentPosition"]/*' />
        public override int CurrentPosition {
            get { return 0; }
        }

        /// <include file='doc\XPathEmptyIterator.uex' path='docs/doc[@for="XPathEmptyIterator.Count"]/*' />
        public override int Count {
            get { return 0; }
        }

        /// <include file='doc\XPathEmptyIterator.uex' path='docs/doc[@for="XPathEmptyIterator.MoveNext"]/*' />
        public override bool MoveNext() {
            return false;
        }

        /// <include file='doc\XPathEmptyIterator.uex' path='docs/doc[@for="XPathEmptyIterator.Reset"]/*' />
        public override void Reset() {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathaxisiterator.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathAxisIterator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XPathAxisIterator.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml.XPath {
    using System;

    internal abstract class XPathAxisIterator: XPathNodeIterator {
        internal XPathNavigator nav;
        internal XPathNodeType type;
        internal string name;
        internal string uri;
        internal int    position;
        internal bool   matchSelf;
        internal bool   first = true;

        public XPathAxisIterator(XPathNavigator nav, bool matchSelf) {
            this.nav = nav;
            this.matchSelf = matchSelf;
        }

        public XPathAxisIterator(XPathNavigator nav, XPathNodeType type, bool matchSelf) : this(nav, matchSelf) {
            this.type = type;
        }

        public XPathAxisIterator(XPathNavigator nav, string name, string namespaceURI, bool matchSelf) : this(nav, matchSelf) {
            this.name      = nav.NameTable.Add(name);
            this.uri       = nav.NameTable.Add(namespaceURI);
        }

        public XPathAxisIterator(XPathAxisIterator it) {
            this.nav       = it.nav.Clone();
            this.type      = it.type;
            this.name      = it.name;
            this.uri       = it.uri;
            this.position  = it.position;
            this.matchSelf = it.matchSelf;
            this.first     = it.first;
        }

        public override XPathNavigator Current {
            get { return nav; }
        }

        public override int CurrentPosition {
            get { return position; }
        }

        // Nodetype Matching - Given nodetype matches the navigator's nodetype
        //Given nodetype is all . So it matches everything
        //Given nodetype is text - Matches text, WS, Significant WS
        protected virtual bool Matches {
            get { 
                if (name == null) {
                    return (nav.NodeType == type || type == XPathNodeType.All ||
                            ( type == XPathNodeType.Text && 
                            (nav.NodeType == XPathNodeType.Whitespace ||
                            nav.NodeType == XPathNodeType.SignificantWhitespace)));
                }
                else {
                    return(
                        nav.NodeType == XPathNodeType.Element && 
                        ((object) name == (object) nav.LocalName || name.Length == 0) && 
                        (object) uri == (object) nav.NamespaceURI
                    ); 
                }
            }
        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathchilditerator.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathChildIterator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XPathChildIterator.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml.XPath {
    using System;

    internal class XPathChildIterator: XPathAxisIterator {
        public XPathChildIterator(XPathNavigator nav, XPathNodeType type) : base(nav, type, /*matchSelf:*/false) {}
        public XPathChildIterator(XPathNavigator nav, string name, string namespaceURI) : base(nav, name, namespaceURI, /*matchSelf:*/false) {}
        public XPathChildIterator(XPathChildIterator it ): base( it ) {}

        public override XPathNodeIterator Clone() {
            return new XPathChildIterator( this );
        }

        public override bool MoveNext() {
            while (true) {
                bool flag = (first) ? nav.MoveToFirstChild() : nav.MoveToNext();
                first = false;
                if (flag) {
                    if (Matches) {
                        position++;
                        return true;
                    }
                }
                else {
                    return false;
                }
            }
        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathdescendantquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathDescendantQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 

    using System.Collections;

    internal class XPathDescendantQuery  : BaseAxisQuery {
        protected bool _fMatchSelf;
        protected bool _first = true;
        protected bool abbrAxis;
        XPathNodeIterator iterator;

        internal XPathDescendantQuery() {
        }

        internal override Querytype getName() {
            return Querytype.Descendant;
        }

        internal XPathDescendantQuery(
                                     IQuery  qyParent,
                                     bool matchSelf,
                                     String Name,
                                     String Prefix,
                                     String URN,
                                     XPathNodeType Type) : base(qyParent, Name, Prefix, URN, Type) {
            _fMatchSelf = matchSelf;
        }
        
        internal XPathDescendantQuery(
                                     IQuery  qyParent,
                                     bool matchSelf,
                                     String Name,
                                     String Prefix,
                                     String URN,
                                     XPathNodeType Type,
                                     bool abbrAxis) : this(qyParent, matchSelf, Name, Prefix, URN, Type)
        {
            this.abbrAxis = abbrAxis;
        }


        internal override XPathNavigator advance(){
            while (true) {
                if (_first) {
                    _position = 0;
                    XPathNavigator nav;
                    if ( m_qyInput is XPathAncestorQuery ) {
                        nav = m_qyInput.advancefordescendant();
                    }
                    else {
                        nav = m_qyInput.advance();
                    }
                    if( nav == null ) {
                        return null;
                    }
                    _first = false;
                    if( _fMatchName ) {
                        if( m_Type == XPathNodeType.ProcessingInstruction ) {
                            iterator = new IteratorFilter( nav.SelectDescendants( m_Type, _fMatchSelf ), m_Name );
                        }
                        else {
                            iterator = nav.SelectDescendants( m_Name, m_URN, _fMatchSelf );
                        }
                    }
                    else {
                        iterator = nav.SelectDescendants( m_Type, _fMatchSelf );
                    }
                }

                if( iterator.MoveNext() ) {
                    _position++;
                    m_eNext = iterator.Current;
                    return m_eNext;
                }
                else {
                    _first = true;
                }
            }
        }
                    
        internal override void reset() {
            _first = true;
            base.reset();
        }

        override internal XPathNavigator MatchNode(XPathNavigator context) {
            if (context != null) {
                if (!abbrAxis)
                    throw new XPathException(Res.Xp_InvalidPattern);
                XPathNavigator result = null;
                if (matches(context)) {
                    if (m_qyInput != null) {
                        if (_fMatchSelf) {
                            if ((result = m_qyInput.MatchNode(context) )!= null)
                                return result;
                        }

                        XPathNavigator anc = context.Clone();
                        while (anc.MoveToParent()) {
                            if ((result = m_qyInput.MatchNode(anc) ) != null)
                                return result;
                        }
                    }
                    else {
                        result = context.Clone();
                        result.MoveToParent();
                        return result;
                    }

                }
            }
            return null;

        }  

        internal override IQuery Clone() {
            return new XPathDescendantQuery(CloneInput(),_fMatchSelf, m_Name, m_Prefix, m_URN, m_Type, abbrAxis);
        }         
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathexpr.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathExpr.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------



namespace System.Xml.XPath {

    using System;
    using System.Xml;
    using System.Collections;

     /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XmlSortOrder"]/*' />
     /// <devdoc>
     ///    <para>[To be supplied.]</para>
     /// </devdoc>
    public enum XmlSortOrder {
         /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XmlSortOrder.Ascending"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        Ascending       = 1,
         /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XmlSortOrder.Descending"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        Descending      = 2,
    }

     /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XmlCaseOrder"]/*' />
     /// <devdoc>
     ///    <para>[To be supplied.]</para>
     /// </devdoc>
    public enum XmlCaseOrder {
         /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XmlCaseOrder.None"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        None            = 0,
         /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XmlCaseOrder.UpperFirst"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        UpperFirst      = 1,
         /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XmlCaseOrder.LowerFirst"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        LowerFirst      = 2,
    }

     /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XmlDataType"]/*' />
     /// <devdoc>
     ///    <para>[To be supplied.]</para>
     /// </devdoc>    
    public enum XmlDataType {
         /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XmlDataType.Text"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        Text            = 1,
         /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XmlDataType.Number"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        Number          = 2,
    }

     /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XPathNodeType"]/*' />
     /// <devdoc>
     ///    <para>[To be supplied.]</para>
     /// </devdoc>
    public enum XPathResultType {
         /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XPathNodeType.String"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        Number         = 0 ,
         /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XPathNodeType.Boolean"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        String          = 1,
         /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XPathNodeType.Number"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        Boolean         = 2,
         /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XPathNodeType.Navigator"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        NodeSet        = 3,
         /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XPathNodeType.NodeSet"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        Navigator       = XPathResultType.String,
         /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XPathNodeType.Any"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         Any            = 5,
         /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XPathNodeType.Error"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        Error
    };

     /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XPathExpression"]/*' />
     /// <devdoc>
     ///    <para>[To be supplied.]</para>
     /// </devdoc>
    public abstract class XPathExpression {
        //Added for UE
        internal XPathExpression(){}
         /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XPathExpression.Expressiom"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        public  abstract string Expression { get; }
         /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XPathExpression.AddSort"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        public abstract void AddSort(object expr, IComparer comparer);
         /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XPathExpression.AddSort1"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        public abstract void AddSort(object expr, XmlSortOrder order,
                    XmlCaseOrder caseOrder, string lang, XmlDataType dataType);
         /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XPathExpression.Clone"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        public abstract XPathExpression Clone();
         /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XPathExpression.SetContext"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        public abstract void SetContext(XmlNamespaceManager nsManager);
         /// <include file='doc\XPathExpr.uex' path='docs/doc[@for="XPathExpression.ReturnType"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        public abstract XPathResultType ReturnType { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System;
    using System.IO;
    using System.Resources;
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System.Security.Permissions;

    /// <include file='doc\XPathException.uex' path='docs/doc[@for="XPathException"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the exception that is thrown when there is error processing an
    ///       XPath expression.
    ///    </para>
    /// </devdoc>
    [Serializable]
    public class XPathException : SystemException {
        string   res;
        string[] args;
        string   message;
                                                                                                
        /// <include file='doc\XPathException.uex' path='docs/doc[@for="XPathException.XPathException3"]/*' />
        protected XPathException(SerializationInfo info, StreamingContext context) : base(info, context) {
            res  = (string  ) info.GetValue("res" , typeof(string  ));
            args = (string[]) info.GetValue("args", typeof(string[]));
        }

        /// <include file='doc\XPathException.uex' path='docs/doc[@for="XPathException.GetObjectData"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand,SerializationFormatter=true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            base.GetObjectData(info, context);
            info.AddValue("res" , res );
            info.AddValue("args", args);
        }

		/// <include file='doc\XPathException.uex' path='docs/doc[@for="XPathException.XPathException0"]/*' />
		public XPathException(String message, Exception innerException) : base(message, innerException) {
			HResult = HResults.XmlXPath;
			this.res = Res.Xml_UserException;
			this.args = new string[] { message };
		}

        internal XPathException(string res) :
            this(res, (string[])null ) {}

        internal XPathException(string res, string arg) :
            this(res, new string[] { arg } ) {}
            
        internal XPathException(string res, string arg1, string arg2) :
            this(res, new string[] { arg1, arg2 }) {}
            
        internal XPathException(string res, string[] args) {
            HResult = HResults.XmlXPath;
            this.res = res;
            this.args = args;
        }

        /// <include file='doc\XPathException.uex' path='docs/doc[@for="XPathException.Message"]/*' />
        public override string Message { 
            get {
                string message = this.message;
                if (message == null) {
                    message = Res.GetString(res, args);
                    if (message == null)
                        message = "UNKNOWN("+res+")";
                    this.message = message;
                }
                return message;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathdescendantiterator.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathDescendantIterator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XPathDescendantIterator.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml.XPath {
    using System;

    internal class XPathDescendantIterator: XPathAxisIterator {
        private int  level = 0;

        public XPathDescendantIterator(XPathNavigator nav, XPathNodeType type, bool matchSelf) : base(nav, type, matchSelf) {}
        public XPathDescendantIterator(XPathNavigator nav, string name, string namespaceURI, bool matchSelf) : base(nav, name, namespaceURI, matchSelf) {}
        public XPathDescendantIterator(XPathDescendantIterator it) : base(it)  {}

        public override XPathNodeIterator Clone() {
            return new XPathDescendantIterator(this);
        }

        public override bool MoveNext() {
            if (first) {
                first = false;
                if (matchSelf && Matches) {
                    position = 1;
                    return true;
                }
            }

            while(true) {
                bool flag = nav.MoveToFirstChild();
                if (! flag) {
                    if(level == 0) {
                        return false;
                    }
                    flag = nav.MoveToNext();
                }
                else {
                    level ++;
                }

                while (! flag) {
                    -- level;
                    if(level == 0 || ! nav.MoveToParent()) {
                        return false;
                    }
                    flag = nav.MoveToNext();
                }

                if (flag) {
                    if (Matches) {
                        position ++;
                        return true;
                    }
                }
            }
        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathdocument.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathDocument.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XPathDocument.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml.XPath {
    using System;
    using System.Collections;
    using System.Xml.Schema;
    using System.Text;
    using System.IO;
    using System.Diagnostics;

    /// <include file='doc\XPathDocument.uex' path='docs/doc[@for="XPathDocument"]/*' />
    public class XPathDocument: IXPathNavigable {
        internal XmlNameTable nt;
        internal XmlSpace space;
        internal string baseURI;
        internal XPathRoot root;
        internal string xmlnsUri;
        internal Hashtable htElementIdMap;
        internal Hashtable htElementIDAttrDecl; // key: id; object: the  element that has the same id (
        internal Hashtable elementBaseUriMap;   // element's who's baseUri != parent.baseUri are stored here
        internal int documentIndex;
        
        internal XPathDocument() {
            this.space = XmlSpace.Default;
            this.root = new XPathRoot();
            this.root.topNamespace = new XPathNamespace( "xml", "http://www.w3.org/XML/1998/namespace", ++ documentIndex );
            this.nt = new NameTable();
            this.baseURI = string.Empty;
        }

        /// <include file='doc\XPathDocument.uex' path='docs/doc[@for="XPathDocument.XPathDocument"]/*' />
        public XPathDocument( XmlReader reader, XmlSpace space ): this() {
            this.space = space;
            Load( reader );
        }

        /// <include file='doc\XPathDocument.uex' path='docs/doc[@for="XPathDocument.XPathDocument1"]/*' />
        public XPathDocument( XmlReader reader ): this() {
            Load( reader );
        }

        /// <include file='doc\XPathDocument.uex' path='docs/doc[@for="XPathDocument.XPathDocument2"]/*' />
        public XPathDocument( TextReader reader ): this() {
            Init( new XmlTextReader(reader) );
        }

        /// <include file='doc\XPathDocument.uex' path='docs/doc[@for="XPathDocument.XPathDocument3"]/*' />
        public XPathDocument( Stream stream ): this() {
            Init( new XmlTextReader(stream) );
        }

        /// <include file='doc\XPathDocument.uex' path='docs/doc[@for="XPathDocument.XPathDocument4"]/*' />
        public XPathDocument( string uri ): this() {
            Init( new XmlTextReader(uri) );
        }
        
        /// <include file='doc\XPathDocument.uex' path='docs/doc[@for="XPathDocument.XPathDocument5"]/*' />
        public XPathDocument( string uri, XmlSpace space ): this() {
            this.space = space;
            Init( new XmlTextReader(uri) );
        }
        
        // Caller is responcable to close this reader!
        internal static XmlValidatingReader CreateHelperValidatingReader( XmlReader reader ) {
            XmlValidatingReader vr = new XmlValidatingReader(reader); {
	            vr.ValidationType = ValidationType.None;
	            vr.EntityHandling = EntityHandling.ExpandEntities;
            }
            return vr;
        }
        
        private void Init( XmlReader reader ) {
            XmlValidatingReader vr = CreateHelperValidatingReader(reader);
            try {
                Load( vr );
            }
            finally {
                vr.Close();
                reader.Close();
            }
        }

        /// <include file='doc\XPathDocument.uex' path='docs/doc[@for="XPathDocument.CreateNavigator"]/*' />
        public XPathNavigator CreateNavigator() {
            return new XPathDocumentNavigator(this, root);
        }

	private void Load( XmlReader reader ) {
            if (reader == null) throw new ArgumentNullException( "reader" );
            nt = reader.NameTable;
            baseURI = reader.BaseURI;
            Debug.Assert(baseURI != null, "uri can't be null, isn't it?");
            xmlnsUri = (nt != null ? nt.Add(XmlReservedNs.NsXmlNs) : XmlReservedNs.NsXmlNs);
	        PositionInfo positionInfo = PositionInfo.GetPositionInfo(reader);
            if ( reader.ReadState == ReadState.Initial ) {
                if ( !reader.Read() )
                    return;
            }
		    ReadChildNodes( root, baseURI, reader, positionInfo );
	    }

	    private void ReadChildNodes( XPathContainer parent, string parentBaseUri, XmlReader reader, PositionInfo positionInfo ) {
		    do {
		        documentIndex++;
			    switch( reader.NodeType ) {
				case XmlNodeType.Element: {
                    string baseUri = reader.BaseURI;
                    XPathElement e = null;
                    if( reader.IsEmptyElement ) {
                        e = new XPathEmptyElement( reader.Prefix, reader.LocalName, reader.NamespaceURI, positionInfo.LineNumber, positionInfo.LinePosition, parent.topNamespace, documentIndex );
    					ReadAttributes( e, reader );
                    }
                    else {
                        e = new XPathElement( reader.Prefix, reader.LocalName, reader.NamespaceURI, positionInfo.LineNumber, positionInfo.LinePosition, parent.topNamespace, documentIndex );
    					ReadAttributes( e, reader );
    					reader.Read();
	    				ReadChildNodes( e, baseUri, reader, positionInfo );
                    }
                    if (parentBaseUri != baseUri) {
                        // We can't user Ref.Equial Because Reader fails to fully atomize base Uri.
                        if (elementBaseUriMap == null) {
                            elementBaseUriMap = new Hashtable();
                        }
                        elementBaseUriMap[e] = baseUri;
                    }
                    parent.AppendChild( e );
                    break;
				}	

				case XmlNodeType.Comment:
                    parent.AppendChild( new XPathComment( reader.Value, documentIndex ) );
                    break;

				case XmlNodeType.ProcessingInstruction:
                    parent.AppendChild( new XPathProcessingInstruction( reader.LocalName, reader.Value, documentIndex ) );
                    break;

				case XmlNodeType.SignificantWhitespace:
                    if( reader.XmlSpace == XmlSpace.Preserve ) {
                        parent.AppendSignificantWhitespace( reader.Value, positionInfo.LineNumber, positionInfo.LinePosition, documentIndex );
                    }
                    else {
                        // SWS without xml:space='preserve' is not really significant for XPath.
                        // so we treat it as just WS
                        goto case XmlNodeType.Whitespace;
                    }
                    break;

				case XmlNodeType.Whitespace:
                    if( space == XmlSpace.Preserve ) {
                        parent.AppendWhitespace( reader.Value, positionInfo.LineNumber, positionInfo.LinePosition, documentIndex );
                    }
                    break;

				case XmlNodeType.CDATA:
				case XmlNodeType.Text:
                    parent.AppendText( reader.Value, positionInfo.LineNumber, positionInfo.LinePosition, documentIndex );
                    break;

                case XmlNodeType.EntityReference:
                    reader.ResolveEntity();
                    reader.Read();
                    ReadChildNodes( parent, parentBaseUri, reader, positionInfo);
                    break;

                case XmlNodeType.EndEntity:
				case XmlNodeType.EndElement:
                case XmlNodeType.None:
					return;

                case XmlNodeType.DocumentType:
                    XmlValidatingReader vr = reader as XmlValidatingReader;
                    if ( vr != null ) {
                        SchemaInfo info = vr.GetSchemaInfo();
                        if ( info != null ) {
                            GetIDInfo( info);
                        }
                    }
                    break;
                case XmlNodeType.XmlDeclaration:
                default:
                    break;
			    }
		    }while( reader.Read() );
	    }

	    private void ReadAttributes( XPathElement parent, XmlReader reader ) {
            XPathNamespace last = null;
		    while(reader.MoveToNextAttribute()) {
		        documentIndex++;
                if ((object)reader.NamespaceURI == (object)xmlnsUri) {
                    XPathNamespace tmp = new XPathNamespace(reader.Prefix == string.Empty ? string.Empty : reader.LocalName, reader.Value, documentIndex);
                    tmp.next = last;
                    last = tmp;
                }
                else {
			        parent.AppendAttribute(new XPathAttribute(reader.Prefix, reader.LocalName, reader.NamespaceURI, reader.Value, documentIndex));
			        if (htElementIdMap != null) {
    			        Object attrname = htElementIdMap[new XmlQualifiedName(parent.Name, parent.Prefix)] ;
                        if (attrname != null && new XmlQualifiedName(reader.Name, reader.Prefix).Equals(attrname)) {
                            if (htElementIDAttrDecl[reader.Value] == null) {
                                htElementIDAttrDecl.Add(reader.Value, parent);
                            }
                        }
                    }
                }
		    }
            if (last != null) {
                parent.AppendNamespaces(last);
            }
	    }

	    internal XPathNode GetElementFromId( String id ) {
	        if ( htElementIDAttrDecl != null ) {
	            return (XPathNode) htElementIDAttrDecl[id];
            }
            return null;
        }
        
        private void GetIDInfo( SchemaInfo schInfo ) {
                //extract the elements which has attribute defined as ID from the element declarations
            IDictionaryEnumerator elementDecls = schInfo.ElementDecls.GetEnumerator();
            if (elementDecls != null) {
                elementDecls.Reset();
                while (elementDecls.MoveNext()) {
                    SchemaElementDecl elementDecl = (SchemaElementDecl)elementDecls.Value;
                    if (elementDecl.AttDefs != null) {
                        IDictionaryEnumerator attDefs =  elementDecl.AttDefs.GetEnumerator();
                        while (attDefs.MoveNext()) {
                            SchemaAttDef attdef = (SchemaAttDef)attDefs.Value;
                            if (attdef.Datatype.TokenizedType == XmlTokenizedType.ID) {
                                if ( htElementIdMap == null ) {
                                    htElementIdMap = new Hashtable();
                                    htElementIDAttrDecl = new Hashtable();
                                }
                                htElementIdMap.Add( elementDecl.Name, attdef.Name );   
                                break;
                            }
                        }
                    }
                }
            }
        }
    }

    internal abstract class XPathNode {
	    internal XPathContainer parent;
        internal XPathNode next;
        internal XPathNode previous;
        internal XPathNode firstChild;
        internal int documentIndex;

        public abstract XPathNodeType NodeType { get; }

        public virtual string Prefix { get { return string.Empty; } }

        public virtual string LocalName { get { return string.Empty; } }

        public virtual string NamespaceURI { get { return string.Empty; } }

        public virtual string Name { get { return string.Empty; } }

	    public virtual string InnerText { get { return string.Empty; } }

        public virtual string Value { get { return string.Empty; } }

        public virtual int LineNumber { get { return 0; } }

        public virtual int LinePosition { get { return 0; } }

        public virtual XPathNode ParentNode { get { return parent; } }

        public virtual XPathNode NextSiblingNode { get { return next; } }

        public virtual XPathNode PreviousSiblingNode { get { return previous; } }

        public virtual XPathNode FirstSiblingNode { get { return parent.firstChild; } }

        public virtual XPathNode LastSiblingNode { get { return parent.lastChild; } }

        public virtual XPathNode FirstChildNode { get { return null; } }

        public virtual XPathNode LastChildNode { get { return null; } }

        public virtual XPathNode FirstAttributeNode { get { return null; } }

        public virtual XPathNode NextAttributeNode { get { return null; } }

        public virtual bool HasAttributes { get { return false; } }

        public virtual XPathAttribute GetAttribute( string localName, string uri ) { return null; }

        public virtual XPathNamespace GetNamespace(string name) { return null; }

        public virtual XPathNode FirstNamespaceNode { get { return null; } }

        public virtual XPathNode NextNamespaceNode { get { return null; } }

        public int DocumentIndex { get { return documentIndex;}}
        
        public virtual bool IsElement( string nameAtom, string nsAtom ) { return false; }
    }

    internal abstract class XPathNamedNode: XPathNode {
        private  string prefix;
        internal string localName;
        internal string uri;
        private  string name;

        public XPathNamedNode( string prefix, string localName, string uri, int documentIndex ) {
            Debug.Assert(localName != null);
            this.prefix = prefix;
            this.localName = localName;
            this.uri = uri;
            this.documentIndex = documentIndex;
        }

        public override string Prefix { get { return prefix; } }

        public override string LocalName { get { return localName; } }

        public override string NamespaceURI { get { return uri; } }

        public override string Name {
            get {
			    if( name == null ) {
				    if( Prefix != null && Prefix != string.Empty ) {
					    name = Prefix + ":" + LocalName;
				    }
				    else {
					    name = LocalName;
				    }
			    }
			    return name;
            }
        }

    }

    internal abstract class XPathContainer: XPathNamedNode {
        internal XPathNode      lastChild;
        internal XPathNamespace topNamespace;

        public XPathContainer( string prefix, string localName, string uri, int documentIndex ):
            base( prefix, localName, uri, documentIndex ) {
        }

        public void AppendChild( XPathNode node ) {
            if( this.lastChild != null ) {
                node.previous = this.lastChild;
                this.lastChild.next = node;
                this.lastChild = node;
            }
            else {
                this.lastChild = node;
                this.firstChild = node;
            }
            node.parent = this;
        }

        public void RemoveChild( XPathNode node ) {
            Debug.Assert( node.ParentNode == this );
            XPathNode nodePrev = node.previous;
            XPathNode nodeNext = node.next;

            if( nodePrev != null ) {
                nodePrev.next = nodeNext;
            }
            if( nodeNext != null ) {
                nodeNext.previous = nodePrev;                
                Debug.Assert( this.lastChild != node, "Node has next. It can't be last child of it's parent." );
            }
            else {
                if( this.lastChild == node ) {
                    this.lastChild = nodePrev;
                }
            }
            if( this.firstChild == node ) {
                this.firstChild = nodeNext;
            }
        }

        public override XPathNode FirstChildNode { get { return firstChild; } }

        public override XPathNode LastChildNode { get { return lastChild; } }

        public override string Value { get { return InnerText; } }
        
	    public override string InnerText {
		    get { 
			    if( firstChild != null && firstChild.next == null ) {
				    return firstChild.InnerText;
			    }
			    else {
				    StringBuilder builder = new StringBuilder();
		            for( XPathNode node = firstChild; node != null ; node = node.next ) {
			            string it = node.InnerText;
			            if( it.Length > 0 ) {
				            builder.Append( it );
                        }
		            }
				    return builder.ToString();
			    }
		    }
	    }

        public virtual void AppendText( string value, int lineNumber, int linePosition, int documentIndex ) {
            XPathText last = this.lastChild as XPathText;
            if( last == null ) {
                this.AppendChild( new XPathText( value, lineNumber, linePosition, documentIndex ) );
            }
            else {
                // "last" can be Text | Whitespace | SignificantWhitespace
                last.text += value;
                if(last.NodeType != XPathNodeType.Text) {
                    // converting "last" node to Text
                    // 1. Add new text node to the end
                    this.AppendChild( new XPathText( last.Value, last.LineNumber, last.LinePosition, documentIndex ) );
                    // 2. Remove prev. "last" node
                    this.RemoveChild( last );
                }
            }       
        }

        public virtual void AppendWhitespace( string value, int lineNumber, int linePosition, int documentIndex ) {
            // after CDATA section we can have separate WS node, but because we converted CDATA to text we need to append WS to this text
            XPathText last = this.lastChild as XPathText;
            if( last == null ) {
                this.AppendChild( new XPathWhitespace( value, lineNumber, linePosition, documentIndex ) );
            }
            else {
                last.text += value;
            }       
        }

        public virtual void AppendSignificantWhitespace( string value, int lineNumber, int linePosition, int documentIndex ) {
            // after CDATA section we can have separate SWS node, but because we converted CDATA to text we need to append SWS to this text
            XPathText last = this.lastChild as XPathText;
            if( last == null ) {
                this.AppendChild( new XPathSignificantWhitespace( value, lineNumber, linePosition, documentIndex ) );
            }
            else {
                last.text += value;
            }       
        }
    }

    internal class XPathAttribute: XPathNamedNode {
        private string value;

        public XPathAttribute( string prefix, string localName, string uri, string value , int documentIndex) 
            : base( prefix, localName, uri, documentIndex ) {
            Debug.Assert(value != null);
            this.value = value;
        }

        public override XPathNodeType NodeType { 
            get { return XPathNodeType.Attribute; } 
        }

        public override string Value { 
            get { return value; }
        }

        public override XPathNode NextAttributeNode {
            get { return next; } 
        }

        public void AppendText( string text ) {
            value += text;
        }

        public override  int LineNumber { get { return parent.LineNumber; } }
        public override  int LinePosition { get { return parent.LinePosition; } }

        public override XPathNode NextSiblingNode { get { return null; } }

        public override XPathNode PreviousSiblingNode { get { return null; } }

    }

    internal class XPathNamespace: XPathNode {
        internal string localName;
        private string value;

        public XPathNamespace(string localName, string value, int documentIndex) {
            Debug.Assert(localName != null);
            Debug.Assert(value != null);
            this.localName = localName;
            this.value = value;
            this.documentIndex = documentIndex;
        }

        public override string LocalName { 
            get { return localName; } 
        }

        public override string Name { 
            get { return localName; } 
        }

        public override XPathNodeType NodeType { 
            get { return XPathNodeType.Namespace; } 
        }

        public override string Value { 
            get { return value; }
        }

        public override XPathNode NextNamespaceNode {
            get { return next; } 
        }

        public override XPathNode NextSiblingNode { get { return null; } }

        public override XPathNode PreviousSiblingNode { get { return null; } }

        public override XPathNode FirstSiblingNode { get { return null; } }

        public override XPathNode LastSiblingNode { get { return null; } }

    }

    internal class XPathElement: XPathContainer {
        private XPathAttribute firstAttribute;
        private XPathAttribute lastAttribute;
        private int lineNumber;
        private int linePosition;

        public XPathElement( string prefix, string localName, string uri, int lineNumber, int linePosition, XPathNamespace topNamespace , int documentIndex)
            : base( prefix, localName, uri, documentIndex ) {
            this.lineNumber = lineNumber;
            this.linePosition = linePosition;
            this.topNamespace = topNamespace;
        }

        public override XPathNodeType NodeType { 
            get { return XPathNodeType.Element; } 
        }

        public override int LineNumber { 
            get { return lineNumber; } 
        }
        
        public override int LinePosition { 
            get { return linePosition; } 
        }

        public override bool IsElement( string nameAtom, string nsAtom ) { 
            return ((object) localName == (object) nameAtom || nameAtom.Length == 0) && (object) uri == (object) nsAtom;
        }

        public override XPathNode FirstAttributeNode {
            get { return firstAttribute; } 
        }

        public override XPathNode NextAttributeNode { 
            get { return null; } 
        }

        public override bool HasAttributes { 
            get { return firstAttribute != null; } 
        }

        public virtual void AppendAttribute( XPathAttribute attr ) {
            if( lastAttribute != null ) {
                attr.previous = lastAttribute;
                lastAttribute.next = attr;
                lastAttribute = attr;
            }
            else {
                firstAttribute = attr;
                lastAttribute = attr;
            }
            attr.parent = this;
        }

        public override XPathAttribute GetAttribute( string localName, string uri ) {
            Debug.Assert(uri != null);
            for( XPathAttribute a = firstAttribute; a != null; a = (XPathAttribute) a.next ) {
                if( a.localName == localName && a.uri == uri ) {
                    return a;
                }
            }
            return null;
        }

        public override XPathNamespace GetNamespace(string name) { 
            for( XPathNamespace ns = topNamespace; ns != null; ns = (XPathNamespace) ns.next ) {
                if( ns.localName == name ) {
                    return ns;
                }
            }
            return null; 
        }

        private static XPathNamespace FindByName(XPathNamespace list, string name) {
            Debug.Assert(name != null);
            while(list != null && list.Name != name) {
                list = (XPathNamespace) list.next;
            }
            return list;
        }

        public static bool CheckDuplicates(XPathNamespace list) {
            while(list != null) {
                if (FindByName((XPathNamespace) list.next, list.Name) != null) {
                    return false;
                }
                list = (XPathNamespace) list.next;
            }
            return true;
        }

        public virtual void AppendNamespaces(XPathNamespace firstNew) {
            Debug.Assert(CheckDuplicates(firstNew), "List of namespases we are adding contains duplicates");
            Debug.Assert(CheckDuplicates(topNamespace), "List of namespases of parent node contains duplicates");
            Debug.Assert(firstNew != null, "Dont's call this unction if you don't have namespaces to add");
            XPathNamespace lastNew = null;
            // Find the topmost unconflicting node in old list
            // and remove duplicates from the new list 
            XPathNamespace unconflictOld = topNamespace;
            for (XPathNamespace tmpNew = firstNew; tmpNew != null; tmpNew = (XPathNamespace) tmpNew.next) {
                XPathNamespace confOld = FindByName(unconflictOld, tmpNew.Name);
                if (confOld != null) {
                    // Even if confOld.Value == tmpNew.Value we have to replace this nsNode because new has different docIndex and be sorted differentely
                    unconflictOld = (XPathNamespace) confOld.next;
                }
                // set parent to all of new ns and remember the last one as well;
                tmpNew.parent = this;
                lastNew = tmpNew;
            }
            XPathNamespace mirgedList = unconflictOld;           // now mirgedList has only unconfliced part of parent namespace list
            // from interval (unconflictOld, topNamespace] attached to mirgedList clones of all unconflicting nodes
            for (XPathNamespace tmpOld = topNamespace; tmpOld != unconflictOld; tmpOld = (XPathNamespace) tmpOld.next) {
                if (FindByName(firstNew, tmpOld.Name) == null) {
                    XPathNamespace clone = new XPathNamespace(tmpOld.Name, tmpOld.Value, tmpOld.DocumentIndex);
                    clone.parent = tmpOld.parent;
                    clone.next = mirgedList;
                    mirgedList = clone;
                }
                else {
                    // Just ignore it
                }
            }
            // now we can atach new nodes
            Debug.Assert(lastNew != null);
            lastNew.next = mirgedList;
            topNamespace = firstNew;
            Debug.Assert(CheckDuplicates(topNamespace), "List of namespases we just duilt contains duplicates");
        }

        public override XPathNode FirstNamespaceNode {
            get { return topNamespace; } 
        }

        public override XPathNode NextNamespaceNode { 
            get { return null; } 
        }
    }

    internal class XPathEmptyElement: XPathElement {
	    public XPathEmptyElement( string prefix, string localName, string uri, int lineNumber, int linePosition, XPathNamespace topNamespace, int documentIndex )
		    : base( prefix, localName, uri, lineNumber, linePosition, topNamespace, documentIndex ) {
	    }
    }

    internal class XPathText: XPathNode {
        internal string text;
        private int lineNumber;
        private int linePosition;

        public XPathText( string value, int lineNumber, int linePosition, int documentIndex ) {
            Debug.Assert(value != null);
            this.text = value;
            this.lineNumber = lineNumber;
            this.linePosition = linePosition;
            this.documentIndex = documentIndex;
        }

        public override XPathNodeType NodeType { get { return XPathNodeType.Text; } }

        public override string Value { get { return text; } }
        
        public override string InnerText { get { return text; } }
        
        public override int LineNumber { get { return lineNumber; } }
        
        public override int LinePosition { get { return linePosition; } }
    }

    internal class XPathWhitespace: XPathText {
        public XPathWhitespace( string value, int lineNumber, int linePosition, int documentIndex ) 
            : base( value, lineNumber, linePosition, documentIndex ) 
        {}

        public override XPathNodeType NodeType { get { return XPathNodeType.Whitespace; } }
    }


    internal class XPathSignificantWhitespace: XPathWhitespace {
        public XPathSignificantWhitespace( string value, int lineNumber, int linePosition, int documentIndex ) 
            : base( value, lineNumber, linePosition, documentIndex ) 
        {}
        public override XPathNodeType NodeType { get { return XPathNodeType.SignificantWhitespace; } }
    }

    internal class XPathComment: XPathNode {
        string comment;
        public XPathComment( string comment, int documentIndex ) {
            this.comment = comment;
            this.documentIndex = documentIndex;
        }
        
        public override XPathNodeType NodeType { get { return XPathNodeType.Comment; } }
        
        public override string Value { get { return comment; } }
    }

    internal class XPathProcessingInstruction: XPathNode {
        string target;
        string instruction;

        public XPathProcessingInstruction( string target, string instruction, int documentIndex ) {
            this.target = target;
            this.instruction = instruction;
            this.documentIndex = documentIndex;
        }

        public override XPathNodeType NodeType { get { return XPathNodeType.ProcessingInstruction; } }
        
        public override string Name { get { return target; } }
        
        public override string LocalName { get { return target; } }
        
        public override string Value { get { return instruction; } }
    }

    internal class XPathRoot: XPathContainer {
	    public XPathRoot(): base(string.Empty,string.Empty,string.Empty, 0) {
        }

        public override XPathNodeType NodeType { 
            get { return XPathNodeType.Root; } 
        }

        public override XPathNode FirstSiblingNode {
            get { return null; } 
        }

        public override XPathNode LastSiblingNode { 
            get { return null; }
        }
        public override void AppendWhitespace( string value, int lineNumber, int linePosition, int documentIndex ) {
            return;   
        }
    }

    internal class XPathDocumentNavigator: XPathNavigator, IXmlLineInfo {
        XPathDocument doc;
        internal XPathNode node;
        XPathNode parentOfNs;
        private const String lang = "lang";
        
	    internal XPathDocumentNavigator( XPathDocument doc, XPathNode node ) {
            this.doc = doc;
            this.node = node;
	    }
	    
	    private XPathDocumentNavigator( XPathDocumentNavigator nav ) {
            this.doc = nav.doc;
            this.node = nav.node;
            this.parentOfNs = nav.parentOfNs;
	    }

        public override XPathNavigator Clone() {
		    return new XPathDocumentNavigator(this);
	    }

        public override XPathNodeType NodeType {
		    get { return node.NodeType; }
	    }

        public override string LocalName {
		    get { return node.LocalName; }
	    }

        public override string NamespaceURI { 
		    get { return node.NamespaceURI; }
	    }

        public override string Name { 
		    get { return node.Name; }
	    }

        public override string Prefix { 
		    get { return node.Prefix; }
	    }

        public override string Value { 
		    get { return node.Value; }
	    }

        public override string BaseURI {
            get { 
                if (doc.elementBaseUriMap != null) {
                    for (XPathNode n = node; n.NodeType != XPathNodeType.Root; n = n.ParentNode) {
                        if (n.NodeType == XPathNodeType.Element) {
                            string baseUri = (string) doc.elementBaseUriMap[n];
                            if (baseUri != null) {
                                return baseUri;
                            }
                        }
                    }
                }
                return doc.baseURI; 
            }
        }

        int IXmlLineInfo.LineNumber { 
            get { return node.LineNumber; } 
        }

        int IXmlLineInfo.LinePosition { 
            get { return node.LinePosition; } 
        }

        bool IXmlLineInfo.HasLineInfo() { 
            return true; 
        }

        public override String XmlLang { 
            get { 
                XPathNode n = node;
                do {
                    XPathAttribute attr = n.GetAttribute( lang, XmlReservedNs.NsXml );    
                    if ( attr != null ){
                        return attr.Value; 
                    }
                    n = n.ParentNode;
                } while (n != null);
                return String.Empty;
            }
        }

        public override bool IsEmptyElement { 
		    get { return node is XPathEmptyElement; }
	    }

        public override XmlNameTable NameTable {
		    get { return doc.nt; }
	    }

        public override bool HasAttributes {
		    get { return node.HasAttributes; }
	    }

        public override string GetAttribute( string localName, string namespaceURI ) {
		    XPathAttribute attr = node.GetAttribute(localName, namespaceURI);
		    if( attr != null )
			    return attr.Value;
		    return string.Empty;			
	    }

        public override bool MoveToAttribute( string localName, string namespaceURI ) {
            XPathNode n = node.GetAttribute(localName, namespaceURI);
            if( n != null ) {
                node = n;
                return true;
            }
		    return false;
	    }

        public override bool MoveToFirstAttribute() {
            XPathNode n = node.FirstAttributeNode;
            if( n != null ) {
                node = n;
                return true;
            }
            return false;
	    }

        public override bool MoveToNextAttribute() {
            XPathNode n = node.NextAttributeNode;
            if( n != null ) {
                node = n;
                return true;
            }
            return false;
        }

        public override string GetNamespace(string name) {
            XPathNamespace ns = node.GetNamespace(name);
            if( ns != null )
                return ns.Value;
            if( name == "xml" )
                return XmlReservedNs.NsXml;
            if( name == "xmlns" )
                return XmlReservedNs.NsXmlNs;
            return string.Empty;			
        }

        public override bool MoveToNamespace(string name) {
		    XPathNamespace ns = node.GetNamespace(name);
            if( ns != null ) {
                parentOfNs = node;
                node = ns;
                return true;
            }
            return false;
        }

        public override bool MoveToFirstNamespace(XPathNamespaceScope namespaceScope) {
            XPathNode n = node.FirstNamespaceNode;
            if (n != null) {
                XPathNode parent = n.parent;
                if (parent == null && namespaceScope == XPathNamespaceScope.ExcludeXml) {
                    return false;
                }
                if (parent != node && namespaceScope == XPathNamespaceScope.Local) {
                    return false;
                }
                parentOfNs = node;
                node = n;
                return true;
            }
            return false;
        }

        public override bool MoveToNextNamespace(XPathNamespaceScope namespaceScope) { 
            XPathNode n = node.NextNamespaceNode;
            if (n != null) {
                XPathNode parent = n.parent;
                if (parent == null && namespaceScope == XPathNamespaceScope.ExcludeXml) {
                    return false;
                }
                if (parent != parentOfNs && namespaceScope == XPathNamespaceScope.Local) {
                    return false;
                }
                node = n;
                return true;
            }
            return false;
        }

        public override bool HasChildren { 
		    get { return node.FirstChildNode != null; }
	    }

        public override bool MoveToNext() {
            XPathNode n = node.NextSiblingNode;
            if( n != null ) {
			    node = n;
			    return true;
		    }
		    return false;
	    }

        public override bool MoveToPrevious() {
            XPathNode n = node.PreviousSiblingNode;
            if( n != null ) {
			    node = n;
			    return true;
		    }
		    return false;
	    }

        public override bool MoveToFirst() {
            XPathNode n = node.FirstSiblingNode;
            if( n != null ) {
		        node = n;
		        return true;
		    }
		    return false;
	    }
 
        public override bool MoveToFirstChild() {
            XPathNode n = node.FirstChildNode;
            if( n != null ) {
                //Debug.Assert(n.NodeType != XPathNodeType.Attribute, "Attribute is child");
			    node = n;
			    return true;
		    }
		    return false;
	    }

        public override bool MoveToParent() {
            if (parentOfNs != null) {
                node = parentOfNs; // namespace trick
                parentOfNs = null;
                return true;
            }
            else {
                XPathNode n = node.ParentNode;
                if( n != null ) {
			        node = n;
			        return true;
		        }
            }
		    return false;
	    }

        public override void MoveToRoot() {
            parentOfNs = null;
		    node = doc.root;
	    }

        public override bool MoveTo( XPathNavigator other ) {
		    XPathDocumentNavigator nav = other as XPathDocumentNavigator;
		    if( nav != null ) {
			    doc = nav.doc;
			    node = nav.node;
			    return true;				
		    }
		    return false;
	    }

        public override bool MoveToId( string id ) {
		    XPathNode n = doc.GetElementFromId( id );
		    if ( n != null ) {
		        node = n;
		        return true;
	        }
	        return false;
	    }   

        public override bool IsSamePosition( XPathNavigator other ) {
		    XPathDocumentNavigator nav = other as XPathDocumentNavigator;
		    if( nav != null ) {
			    return nav.node == this.node && nav.parentOfNs == this.parentOfNs;
		    }
		    return false;
	    }

        public override XPathNodeIterator SelectDescendants( string name, string namespaceURI, bool matchSelf ) {
            if( matchSelf ) {
                return new XPathDocumentDescendantOrSelfIterator( (XPathDocumentNavigator)this.Clone(), name, namespaceURI );
            }
            else {
                return new XPathDocumentDescendantIterator( (XPathDocumentNavigator)this.Clone(), name, namespaceURI );
            }
        }
        public override XPathNodeIterator SelectChildren( string name, string namespaceURI ) {
            return new XPathDocumentChildIterator( (XPathDocumentNavigator)this.Clone(), name, namespaceURI );
        }
        public override XPathNodeIterator SelectChildren(XPathNodeType nodeType ) {
            if (nodeType == XPathNodeType.All) {
                return new XPathDocumentEveryChildIterator( (XPathDocumentNavigator)this.Clone() );
            }
            else {
                return base.SelectChildren(nodeType);
            }
        }
        public override XmlNodeOrder ComparePosition( XPathNavigator navigator ) {
            XPathDocumentNavigator nav = navigator as XPathDocumentNavigator;
            if ( nav == null || this.doc != nav.doc ) {
                return XmlNodeOrder.Unknown;
            }
            XPathNode theNode = this.node;
            XPathNode navNode = nav .node;
            bool theNs = (theNode.NodeType == XPathNodeType.Namespace);
            bool navNs = (navNode.NodeType == XPathNodeType.Namespace);
            int nodeOrder = theNode.DocumentIndex - navNode.DocumentIndex;
            if (! theNs && ! navNs) {
                return (
                    nodeOrder < 0 ?  XmlNodeOrder.Before :
                    0 < nodeOrder ?  XmlNodeOrder.After  :
                    /*nodeOrder==0*/ XmlNodeOrder.Same
                );
            }
            else if (theNs && navNs) {
                XPathNode theParent = this.parentOfNs;
                XPathNode navParent = nav .parentOfNs;
                int parentOrder = theParent.DocumentIndex - navParent.DocumentIndex;
                return (
                    parentOrder < 0 ?  XmlNodeOrder.Before :
                    0 < parentOrder ?  XmlNodeOrder.After  :
                    /*parentOrder==0*/ (
                        nodeOrder < 0 ?  XmlNodeOrder.Before :
                        0 < nodeOrder ?  XmlNodeOrder.After  :
                        /*nodeOrder==0*/ XmlNodeOrder.Same
                    )
                );                
            }
            else if (theNs/* && ! navNs*/) {
                XPathNode theParent = this.parentOfNs;
                int parentOrder = theParent.DocumentIndex - navNode.DocumentIndex;
                return parentOrder < 0 ?  XmlNodeOrder.Before : XmlNodeOrder.After;                
//                parentOrder < 0 ?  XmlNodeOrder.Before :
//                0 < parentOrder ?  XmlNodeOrder.After  :
//                /*parentOrder==0*/ XmlNodeOrder.After
            }
            else /*! theNs && navNs*/ {
                XPathNode navParent = nav .parentOfNs;
                int parentOrder = theNode.DocumentIndex - navParent.DocumentIndex;
                return parentOrder <= 0 ?  XmlNodeOrder.Before : XmlNodeOrder.After;
//                parentOrder < 0 ?  XmlNodeOrder.Before :
//                0 < parentOrder ?  XmlNodeOrder.After  :
//                /*parentOrder==0*/ XmlNodeOrder.Before
            }
        }
    }

    internal class XPathDocumentDescendantIterator: XPathNodeIterator {
        protected XPathDocumentNavigator nav;
        protected string name;
        protected string uri;
        private   int    level;
        protected int    position;

        internal XPathDocumentDescendantIterator(XPathDocumentNavigator nav, string name, string namespaceURI) {
            this.nav   = nav;
            this.name  = nav.NameTable.Add(name);
            this.uri   = nav.NameTable.Add(namespaceURI);
        }

        public XPathDocumentDescendantIterator(XPathDocumentDescendantIterator it) {
            this.nav      = (XPathDocumentNavigator) it.nav.Clone();
            this.name     = it.name;
            this.uri      = it.uri;
            this.level    = it.level;
            this.position = it.position;
        }

        
        public override XPathNodeIterator Clone() {
            return new XPathDocumentDescendantIterator(this);
        }

        public override XPathNavigator Current {
            get { return nav; }
        }

        public override int CurrentPosition {
            get { return position; }
        }

        public override bool MoveNext() {
            XPathNode node = nav.node;

            while(true) {
                XPathNode next = node.firstChild;
                if (next == null){
                    if(level == 0) {
                        return false;
                    }
                    next = node.next;
                }
                else {
                    level ++;
                }

                while(next == null) {
                    -- level;
                    if(level == 0) {
                        return false;
                    }
                    node = node.parent;
                    next = node.next;
                }

                if(Match(next, name, uri)) {
                    nav.node = next;
                    position ++;
                    return true;
                }

                node = next;
            }
        }

        protected bool Match(XPathNode node, string name, string nsUri) {
            Debug.Assert(node != null);
            return node.IsElement(name, nsUri);
        }
    }    

    internal class XPathDocumentDescendantOrSelfIterator: XPathDocumentDescendantIterator {
        public XPathDocumentDescendantOrSelfIterator(XPathDocumentNavigator nav, string name, string namespaceURI) : base(nav, name, namespaceURI) {}
        public XPathDocumentDescendantOrSelfIterator(XPathDocumentDescendantIterator it) : base(it) {}

        public override XPathNodeIterator Clone() {
            return new XPathDocumentDescendantOrSelfIterator(this);
        }

        public override bool MoveNext() {
            if(position == 0) {
                if(Match(nav.node, name, uri)) {
                    position = 1;
                    return true;
                }
            }
            return base.MoveNext();
        }
    }

    internal class XPathDocumentChildIterator: XPathNodeIterator {
        protected XPathDocumentNavigator nav;
        protected string name;
        protected string uri;
        private   bool    first = true;
        protected int    position;

        internal XPathDocumentChildIterator(XPathDocumentNavigator nav, string name, string namespaceURI) {
            this.nav   = nav;
            this.name  = nav.NameTable.Add(name);
            this.uri   = nav.NameTable.Add(namespaceURI);
        }

        public XPathDocumentChildIterator(XPathDocumentChildIterator it) {
            this.nav      = (XPathDocumentNavigator) it.nav.Clone();
            this.name     = it.name;
            this.uri      = it.uri;
            this.first    = it.first;
            this.position = it.position;
        }
        

        public override XPathNodeIterator Clone() {
            return new XPathDocumentChildIterator( this );
        }

        public override XPathNavigator Current {
            get { return nav; }
        }

        public override int CurrentPosition {
            get { return position; }
        }
        
        public override bool MoveNext() {
            XPathNode node = nav.node;
            while ( true ) {
                if ( first ) {
                    node = node.firstChild; 
                    first = false;
                }
                else {
                    node = node.next;
                }
                if ( node != null ){
                    if (node.IsElement( name, uri ) ) {
                        position++;
                        nav.node = node;
                        return true;
                    }
                }
                else {
                    return false;
                }
            }
        }
    }

    internal class XPathDocumentEveryChildIterator: XPathNodeIterator {
        protected XPathDocumentNavigator nav;
        private   bool    first = true;
        protected int    position;

        internal XPathDocumentEveryChildIterator(XPathDocumentNavigator nav) {
            this.nav   = nav;            
        }

        public XPathDocumentEveryChildIterator(XPathDocumentEveryChildIterator it) {
            this.nav      = (XPathDocumentNavigator) it.nav.Clone();
            this.first    = it.first;
            this.position = it.position;
        }
        

        public override XPathNodeIterator Clone() {
            return new XPathDocumentEveryChildIterator( this );
        }

        public override XPathNavigator Current {
            get { return nav; }
        }

        public override int CurrentPosition {
            get { return position; }
        }
        
        public override bool MoveNext() {
            XPathNode node = nav.node;
            while ( true ) {
                if ( first ) {
                    node = node.firstChild; 
                    first = false;
                }
                else {
                    node = node.next;
                }
                if ( node != null ){
                    position++;
                    nav.node = node;
                    return true;
                }
                else {
                    return false;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathnavigator.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathNavigator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XPathNavigator.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml.XPath {
    using System;
    using System.Diagnostics;
    using System.Collections;

    /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator"]/*' />
    public abstract class XPathNavigator: ICloneable {

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.Clone"]/*' />
        public abstract XPathNavigator Clone();

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.ICloneable.Clone"]/*' />
        /// <internalonly/>
        object ICloneable.Clone() {
            return this.Clone();
        }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.NodeType"]/*' />
        public abstract XPathNodeType NodeType { get; }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.LocalName"]/*' />
        public abstract string LocalName { get; }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.NamespaceURI"]/*' />
        public abstract string NamespaceURI { get; }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.Name"]/*' />
        public abstract string Name { get; }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.Prefix"]/*' />
        public abstract string Prefix { get; }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.Value"]/*' />
        public abstract string Value { get; }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.BaseURI"]/*' />
        public abstract String BaseURI { get; }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.XmlLang"]/*' />
        public abstract String XmlLang { get; }
        
        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.IsEmptyElement"]/*' />
        public abstract bool IsEmptyElement { get; }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.NameTable"]/*' />
        public abstract XmlNameTable NameTable { get; }

        // Attributes
        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.HasAttributes"]/*' />
        public abstract bool HasAttributes { get; }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.GetAttribute"]/*' />
        public abstract string GetAttribute( string localName, string namespaceURI );

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.MoveToAttribute"]/*' />
        public abstract bool MoveToAttribute( string localName, string namespaceURI );

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.MoveToFirstAttribute"]/*' />
        public abstract bool MoveToFirstAttribute();

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.MoveToNextAttribute"]/*' />
        public abstract bool MoveToNextAttribute();

        // Namespaces
        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.GetNamespace"]/*' />
        public abstract string GetNamespace(string name);

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.MoveToNamespace"]/*' />
        public abstract bool MoveToNamespace(string name);

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.MoveToFirstNamespace"]/*' />
        public bool MoveToFirstNamespace() { return MoveToFirstNamespace(XPathNamespaceScope.All); }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.MoveToNextNamespace"]/*' />
        public bool MoveToNextNamespace() { return MoveToNextNamespace(XPathNamespaceScope.All); }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.MoveToFirstNamespace1"]/*' />
        public abstract bool MoveToFirstNamespace(XPathNamespaceScope namespaceScope);

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.MoveToNextNamespace1"]/*' />
        public abstract bool MoveToNextNamespace(XPathNamespaceScope namespaceScope);

        // Tree
        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.MoveToNext"]/*' />
        public abstract bool MoveToNext();

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.MoveToPrevious"]/*' />
        public abstract bool MoveToPrevious();

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.MoveToFirst"]/*' />
        public abstract bool MoveToFirst();

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.HasChildren"]/*' />
        public abstract bool HasChildren { get; }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.MoveToFirstChild"]/*' />
        public abstract bool MoveToFirstChild();

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.MoveToParent"]/*' />
        public abstract bool MoveToParent();

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.MoveToRoot"]/*' />
        public abstract void MoveToRoot();

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.MoveTo"]/*' />
        public abstract bool MoveTo( XPathNavigator other );

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.MoveToId"]/*' />
        public abstract bool MoveToId( string id );

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.IsSamePosition"]/*' />
        public abstract bool IsSamePosition( XPathNavigator other );

        // Selection
        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.Compile"]/*' />
        public virtual XPathExpression Compile( string xpath ) {
            bool hasPrefix;
            IQuery query = new QueryBuilder().Build(xpath, out hasPrefix);
            return new CompiledXpathExpr( query, xpath, hasPrefix );
        }

        internal XPathExpression CompileMatchPattern( string xpath ) {
            bool hasPrefix;
            IQuery query = new QueryBuilder().BuildPatternQuery(xpath, out hasPrefix);
            return new CompiledXpathExpr( query, xpath, hasPrefix );
        } 
        
        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.Evaluate"]/*' />
        public virtual object Evaluate( XPathExpression expr ) {
            return Evaluate( expr, null );
        }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.Evaluate1"]/*' />
        public virtual object Evaluate( XPathExpression expr, XPathNodeIterator context ) {
            CompiledXpathExpr cexpr = expr as CompiledXpathExpr;
            if( cexpr == null ) {
                throw new XPathException(Res.Xp_BadQueryObject);
            }
            IQuery query = cexpr.QueryTree;
            query.reset();

            XPathNavigator current = (context != null) ? context.Current : this;

            if (query.ReturnType() == XPathResultType.NodeSet) {
                return new XPathSelectionIterator(current, expr);
            }
            return query.getValue(current, context);
        }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.Evaluate2"]/*' />
        public virtual object Evaluate( string xpath ) {
            return Evaluate( Compile( xpath ) , null);
        }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.Matches"]/*' />
        public virtual bool Matches( XPathExpression expr ) {
            CompiledXpathExpr cexpr = expr as CompiledXpathExpr;
            if( cexpr == null ) 
                throw new XPathException(Res.Xp_BadQueryObject);

            IQuery query = cexpr.QueryTree;

            if (query.ReturnType() != XPathResultType.NodeSet)
                throw new XPathException(Res.Xp_NodeSetExpected);
            
            try {
                return query.MatchNode(this) != null;
            }
            catch(XPathException) {
                throw new XPathException(Res.Xp_InvalidPattern, cexpr.Expression);
            }
        }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.Matches1"]/*' />
        public virtual bool Matches( string xpath ) {
            return Matches( CompileMatchPattern( xpath ) );
        }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.Select"]/*' />
        public virtual XPathNodeIterator Select( XPathExpression expr ) {
            return new XPathSelectionIterator( this, expr );
        }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.Select1"]/*' />
        public virtual XPathNodeIterator Select( string xpath ) {
            return new XPathSelectionIterator( this, Compile( xpath ));
        }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.SelectChildren"]/*' />
        public virtual XPathNodeIterator SelectChildren( XPathNodeType type ) {
            return new XPathChildIterator( this.Clone(), type );
        }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.SelectChildren1"]/*' />
        public virtual XPathNodeIterator SelectChildren( string name, string namespaceURI ) {
            return new XPathChildIterator( this.Clone(), name, namespaceURI );
        }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.SelectDescendants"]/*' />
        public virtual XPathNodeIterator SelectDescendants( XPathNodeType type, bool matchSelf ) {
            return new XPathDescendantIterator( this.Clone(), type, matchSelf );
        }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.SelectDescendants1"]/*' />
        public virtual XPathNodeIterator SelectDescendants( string name, string namespaceURI, bool matchSelf ) {
            return new XPathDescendantIterator( this.Clone(), name, namespaceURI, matchSelf );
        }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.SelectAnscestors"]/*' />
        public virtual XPathNodeIterator SelectAncestors( XPathNodeType type, bool matchSelf ) {
            return new XPathAncestorIterator( this.Clone(), type, matchSelf );
        }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.SelectAnscestors1"]/*' />
        public virtual XPathNodeIterator SelectAncestors( string name, string namespaceURI, bool matchSelf ) {
            return new XPathAncestorIterator( this.Clone(), name, namespaceURI, matchSelf );
        }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.ComparePosition"]/*' />
        public virtual XmlNodeOrder ComparePosition( XPathNavigator nav ) {
            if( IsSamePosition( nav ) )
                return XmlNodeOrder.Same;

            XPathNavigator n1 = this.Clone();
            XPathNavigator n2 = nav.Clone();

            int depth1 = GetDepth( n1.Clone() );
            int depth2 = GetDepth( n2.Clone() );

            if( depth1 > depth2 ) {
                while( depth1 > depth2 ) {
                    n1.MoveToParent();
                    depth1--;
                }
                if( n1.IsSamePosition(n2) )
                    return XmlNodeOrder.After;
            }
        
            if( depth2 > depth1 ) {
                while( depth2 > depth1 ) {
                    n2.MoveToParent();
                    depth2 --;
                }
                if( n1.IsSamePosition(n2) )
                    return XmlNodeOrder.Before;
            }

            XPathNavigator parent1 = n1.Clone();
            XPathNavigator parent2 = n2.Clone();

            while( true ) {
                if( !parent1.MoveToParent() || !parent2.MoveToParent() )
                    return XmlNodeOrder.Unknown;

                if( parent1.IsSamePosition( parent2 ) ) {
                    return CompareSiblings(n1, n2);
                }

                n1.MoveToParent();
                n2.MoveToParent();
            }
        }

        private int GetDepth( XPathNavigator nav ) {            
            int depth = 0;
           /* if (nav.NodeType == XPathNodeType.Attribute)
                depth = -1;*/
            while( nav.MoveToParent() ) {
                depth++;
            }
            return depth;
        }

        internal int IndexInParent {
            get {
                XPathNavigator clone = this.Clone();
                int n = 0;
                while( clone.MoveToPrevious() ) {
                    n++;
                }
                return n;
            }
        }
        
        private XmlNodeOrder CompareSiblings(XPathNavigator n1, XPathNavigator n2){
            bool attr1 = n1.NodeType == XPathNodeType.Attribute;
            bool attr2 = n2.NodeType == XPathNodeType.Attribute;
            bool ns1 = n1.NodeType == XPathNodeType.Namespace;
            bool ns2 = n2.NodeType == XPathNodeType.Namespace;
            if (! ns1 && ! ns2 && ! attr1 && ! attr2) {
                while (n1.MoveToNext()) {
                    if (n1.IsSamePosition(n2))
                        return XmlNodeOrder.Before;
                }
                return XmlNodeOrder.After;
            }
            if (attr1 && attr2) {
                while (n1.MoveToNextAttribute()){
                    if (n1.IsSamePosition(n2))
                        return XmlNodeOrder.Before;
                }
                return XmlNodeOrder.After;
            }
            if (attr1){
                return XmlNodeOrder.After;
            }
            if (attr2){
                return XmlNodeOrder.Before;
            }
            if (ns1 && ns2) {
                while (n1.MoveToNextNamespace()) {
                    if (n1.IsSamePosition(n2))
                        return XmlNodeOrder.Before;
                }
                return XmlNodeOrder.After;
            }
            if (ns1){
                return XmlNodeOrder.After;
            }
            Debug.Assert(ns2);
            return XmlNodeOrder.Before;
        }
        
        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.IsDescendant"]/*' />
        public virtual bool IsDescendant(XPathNavigator nav){
            if (nav != null){
                XPathNavigator temp = nav.Clone();
                while (temp.MoveToParent())
                    if (temp.IsSamePosition(this))
                        return true;
            }
            return false;
        }

        /// <include file='doc\XPathNavigator.uex' path='docs/doc[@for="XPathNavigator.ToString"]/*' />
        public override String ToString(){
            return this.Value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathqueryiterator.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathQueryIterator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XPathQueryIterator.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml.XPath {
    using System;
    using System.Diagnostics;

    internal class XPathQueryIterator: ResetableIterator {
        XPathNavigator nav;
        IQuery         query;
        int            position;
        
        public XPathQueryIterator(IQuery query, XPathNavigator nav) {
            this.nav   = nav;
            this.query = query;
            this.query.setContext(nav);
        }

        public override ResetableIterator MakeNewCopy() {
            return new XPathQueryIterator(query.Clone(), nav.Clone());
        }

        public override XPathNavigator Current {
            get { return nav; }
        }

        public override int CurrentPosition {
            get { return position; }
        }

        public override bool MoveNext() {
            nav = query.advance();
            if(nav != null) {
                position ++;
                return true;
            }else {
                return false;
            }
        }
         
        public override void Reset() {
            query.reset();
        }

        public override XPathNodeIterator Clone() {
            XPathQueryIterator clone = new XPathQueryIterator(query.Clone(), nav.Clone());
            clone.MoveToPosition(this.CurrentPosition);
            Debug.Assert(this.CurrentPosition == clone.CurrentPosition);
            return clone;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathnodeiterator.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathNodeIterator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XPathNodeIterator.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml.XPath {
    using System;

    /// <include file='doc\XPathNodeIterator.uex' path='docs/doc[@for="XPathNodeIterator"]/*' />
    public abstract class XPathNodeIterator: ICloneable {
        private int count;
        object ICloneable.Clone() { return this.Clone(); }

        /// <include file='doc\XPathNodeIterator.uex' path='docs/doc[@for="XPathNodeIterator.Clone"]/*' />
        public abstract XPathNodeIterator Clone();
        /// <include file='doc\XPathNodeIterator.uex' path='docs/doc[@for="XPathNodeIterator.MoveNext"]/*' />
        public abstract bool MoveNext();
        /// <include file='doc\XPathNodeIterator.uex' path='docs/doc[@for="XPathNodeIterator.Current"]/*' />
        public abstract XPathNavigator Current { get; }
        /// <include file='doc\XPathNodeIterator.uex' path='docs/doc[@for="XPathNodeIterator.CurrentPosition"]/*' />
        public abstract int CurrentPosition { get; }
        /// <include file='doc\XPathNodeIterator.uex' path='docs/doc[@for="XPathNodeIterator.Count"]/*' />
        public virtual int Count {
            get { 
    	        if (count == 0) {
                    XPathNodeIterator clone = this.Clone();
                    while(clone.MoveNext()) ;
                    count = clone.CurrentPosition;
                }
                return count;
            } 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathnodetype.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathNodeType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XPathNodeType.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml.XPath {
    using System;
/*
    /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType"]/*' />
    public enum XPathNodeType {
        /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType.Root"]/*' />
        Root                    = (int)XmlNodeType.Document,
        /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType.Element"]/*' />
        Element                 = (int)XmlNodeType.Element,
        /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType.Attribute"]/*' />
        Attribute               = (int)XmlNodeType.Attribute,
        Namespace               = 1931,
       /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType.Text"]/*' />
        Text                    = (int)XmlNodeType.Text,
        /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType.SignificantWhitespace"]/*' />
        SignificantWhitespace   = (int)XmlNodeType.SignificantWhitespace,
        /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType.Whitespace"]/*' />
        Whitespace              = (int)XmlNodeType.Whitespace,
        /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType.ProcessingInstruction"]/*' />
        ProcessingInstruction   = (int)XmlNodeType.ProcessingInstruction,
        /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType.Comment"]/*' />
        Comment                 = (int)XmlNodeType.Comment,
        /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType.All"]/*' />
        All                     = (int)XmlNodeType.All
    }
*/
    /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType"]/*' />
    public enum XPathNodeType {
        /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType.Root"]/*' />
        Root,
        /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType.Element"]/*' />
        Element,
        /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType.Attribute"]/*' />
        Attribute,
        /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType.Namespace"]/*' />
        Namespace,
        /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType.Text"]/*' />
        Text,
        /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType.SignificantWhitespace"]/*' />
        SignificantWhitespace,
        /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType.Whitespace"]/*' />
        Whitespace,
        /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType.ProcessingInstruction"]/*' />
        ProcessingInstruction,
        /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType.Comment"]/*' />
        Comment,
        /// <include file='doc\XPathNodeType.uex' path='docs/doc[@for="XPathNodeType.All"]/*' />
        All,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathnodelist.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathNodeList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XPathNodeList.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml.XPath {

    using System;
    using System.Xml.XPath;
    using System.Collections;

    internal class XPathNodeList: XmlNodeList {
        ArrayList list;
        XPathNodeIterator iterator;
        bool done;

        public XPathNodeList( XPathNodeIterator iterator ) {
            this.iterator = iterator;
            this.list = new ArrayList();
            this.done = false;
        }

        public override int Count {
            get {
                if( !done ) {
                    ReadUntil( Int32.MaxValue );
                }
                return list.Count;
            }
        }

        private static readonly object[] nullparams = {};

        private XmlNode GetNode( XPathNavigator n ) {
            IHasXmlNode iHasNode = ( IHasXmlNode )n ;
            return iHasNode.GetNode();
        }

        internal int ReadUntil( int index ) {
            int count = list.Count;
            while( !done && index >= count ) {
                if( iterator.MoveNext() ) {
                    XmlNode n = GetNode(iterator.Current);
                    if( n != null ) {
                        list.Add(n);
                        count++;
                    }
                }
                else {
                    done = true;
                    break;
                }
            }
            return count;
        }

        public override XmlNode Item( int index ) {
            if( index >= list.Count ) {
                ReadUntil( index );
            }
            if( ( index >= list.Count ) || ( index < 0 ) )
                return null;
            return (XmlNode) list[index];
        }

        public override IEnumerator GetEnumerator() {
            return new XmlNodeListEnumerator(this);
        }
    }

    internal class XmlNodeListEnumerator: IEnumerator {
        XPathNodeList list;
        int index;
        bool valid;

        public XmlNodeListEnumerator( XPathNodeList list ) {
            this.list = list;
            this.index = -1;
            this.valid = false;
        }

        public void Reset() {
            index = -1;
        }

        public bool MoveNext() {
                index++;
                int count = list.ReadUntil( index+1 );   // read past for delete-node case
                if( index > ( count-1 ) )
                    return false;
                valid = (list[index] != null);
                return valid;
        }

       public object Current {
            get {
                if( valid ) {
                    return list[index];
                }
                return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathnamespacescope.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathNamespaceScope.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XPathNamespaceScope.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml.XPath {
    using System;

    /// <include file='doc\XPathNamespaceScope.uex' path='docs/doc[@for="XPathNamespaceScope"]/*' />
    public enum XPathNamespaceScope {
        /// <include file='doc\XPathNamespaceScope.uex' path='docs/doc[@for="XPathNamespaceScope.All"]/*' />
        All,
        /// <include file='doc\XPathNamespaceScope.uex' path='docs/doc[@for="XPathNamespaceScope.ExcludeXml"]/*' />
        ExcludeXml,
        /// <include file='doc\XPathNamespaceScope.uex' path='docs/doc[@for="XPathNamespaceScope.Local"]/*' />
        Local
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathreader.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

#if StreamFilter
namespace System.Xml
{
    using System;
    using System.IO;
    using System.Collections;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Text;
    using System.Runtime.Serialization.Formatters;
    using System.Xml.XPath;

    /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader"]/*' />
    public class XPathReader : XmlReader {

        XmlReader _Reader;
        IFQuery      _IfQuery;

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.XPathReader"]/*' />
        public XPathReader(XmlReader reader, String xpathexpr) {
            _Reader = reader;
            _IfQuery = QueryBuildRecord.ProcessNode( XPathParser.ParseXPathExpresion(xpathexpr)); // this will throw if xpathexpr is invalid
        }

        // XmlReader methods and properties
        //

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.NodeType"]/*' />
        public override XmlNodeType NodeType
        {
            get { return _Reader.NodeType; }
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.Name"]/*' />
        public override String Name
        {
            get { return _Reader.Name; }
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.LocalName"]/*' />
        public override String LocalName
        {
            get { return _Reader.LocalName; }
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.NamespaceURI"]/*' />
        public override String NamespaceURI
        {
            get { return _Reader.NamespaceURI; }
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.Prefix"]/*' />
        public override String Prefix
        {
            get { return _Reader.Prefix; }
        }


        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.HasValue"]/*' />
        public override bool HasValue
        {
            get { return _Reader.HasValue; }
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.Value"]/*' />
        public override string Value
        {
            get { return _Reader.Value; }
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.Depth"]/*' />
        public override int Depth
        {
            get { return _Reader.Depth; }
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.BaseURI"]/*' />
        public override string BaseURI
        {
            get { return _Reader.BaseURI; }
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.IsEmptyElement"]/*' />
        public override bool IsEmptyElement
        {
            get { return _Reader.IsEmptyElement; }
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.IsDefault"]/*' />
        public override bool IsDefault
        {
            get { return _Reader.IsDefault; }
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.QuoteChar"]/*' />
        public override char QuoteChar
        {
            get { return _Reader.QuoteChar; }
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.XmlSpace"]/*' />
        public override XmlSpace XmlSpace
        {
            get { return _Reader.XmlSpace; }
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.XmlLang"]/*' />
        public override string XmlLang
        {
            get { return _Reader.XmlLang; }
        }


        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.AttributeCount"]/*' />
        public override int AttributeCount
        {
            get { return _Reader.AttributeCount; }
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.GetAttribute"]/*' />
        public override string GetAttribute(string name)
        {
            return _Reader.GetAttribute( name );
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.GetAttribute1"]/*' />
        public override string GetAttribute(string name, string namespaceURI)
        {
            return _Reader.GetAttribute( name, namespaceURI );
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.GetAttribute2"]/*' />
        public override string GetAttribute(int i)
        {
            return _Reader.GetAttribute( i );
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.this"]/*' />
        public override string this [ int i ]
        {
            get { return _Reader[ i ]; }
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.this1"]/*' />
        public override string this [ string name ]
        {
            get { return _Reader[ name ]; }
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.this2"]/*' />
        public override string this [ string name,string namespaceURI ]
        {
            get { return _Reader[ name, namespaceURI ]; }
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.MoveToAttribute"]/*' />
        public override bool MoveToAttribute(string name)
        {
            return _Reader.MoveToAttribute( name );
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.MoveToAttribute1"]/*' />
        public override bool MoveToAttribute(string name, string ns)
        {
            return _Reader.MoveToAttribute( name, ns );
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.MoveToAttribute2"]/*' />
        public override void MoveToAttribute(int i)
        {
            _Reader.MoveToAttribute( i );
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.MoveToFirstAttribute"]/*' />
        public override bool MoveToFirstAttribute()
        {
            return _Reader.MoveToFirstAttribute();
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.MoveToNextAttribute"]/*' />
        public override bool MoveToNextAttribute()
        {
            return _Reader.MoveToNextAttribute();
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.MoveToElement"]/*' />
        public override bool MoveToElement()
        {
            return _Reader.MoveToElement();
        }

        //
        // the only place that needs to be changed
        //
        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.Read"]/*' />
        public override bool Read()
        {
            while ( _Reader.Read() ) {
                if ( _IfQuery.MatchNode( _Reader ) )
                    return true;
            }
            return false;
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.EOF"]/*' />
        public override bool EOF
        {
            get { return _Reader.EOF; }
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.Close"]/*' />
        public override void Close()
        {
            _Reader.Close();
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.ReadState"]/*' />
        public override ReadState ReadState
        {
            get { return _Reader.ReadState; }
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.ReadString"]/*' />
        public override string ReadString()
        {
            return _Reader.ReadString();
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.ReadInnerXml"]/*' />
        public override string ReadInnerXml()
        {
            return _Reader.ReadInnerXml();
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.ReadOuterXml"]/*' />
        public override string ReadOuterXml()
        {
            return _Reader.ReadOuterXml();
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.NameTable"]/*' />
        public override XmlNameTable NameTable
        {
            get { return _Reader.NameTable; }
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.LookupNamespace"]/*' />
        public override string LookupNamespace(string prefix)
        {
            return _Reader.LookupNamespace( prefix );
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.ResolveEntity"]/*' />
        public override void ResolveEntity()
        {
            _Reader.ResolveEntity();
        }

        /// <include file='doc\XPathReader.uex' path='docs/doc[@for="XPathReader.ReadAttributeValue"]/*' />
        public override bool ReadAttributeValue()
        {
            return _Reader.ReadAttributeValue();
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathscanner.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathScanner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Text;
    using System;
    using System.Collections;
    using System.Diagnostics;
	using System.Globalization;

    internal sealed class XPathScanner {
        private string  xpathExpr;
        private int     xpathExprIndex;
        private LexKind kind;
        private char    currentChar;
        private string  name;
        private string  prefix;
        private string  stringValue;
        private double  numberValue = double.NaN;
        private bool    canBeFunction;

        public XPathScanner(string xpathExpr) {
            if (xpathExpr == null) {
                throw new XPathException(Res.Xp_ExprExpected, String.Empty);
            }
            this.xpathExpr = xpathExpr;
			NextChar();
            NextLex();
        }

        public string SourceText { get { return this.xpathExpr; } }

        private char CurerntChar { get { return currentChar; } }

        private bool NextChar() {
            Debug.Assert(0 <= xpathExprIndex && xpathExprIndex <= xpathExpr.Length);
            if (xpathExprIndex < xpathExpr.Length) {
				currentChar = xpathExpr[xpathExprIndex ++]; 
				return true;
			}
			else  {
				currentChar = '\0';
                return false;
            }
        }

        public LexKind Kind { get { return this.kind; } }

        public string Name {
            get {
                Debug.Assert(this.kind == LexKind.Name || this.kind == LexKind.Axe);
                Debug.Assert(this.name != null);
                return this.name;
            }
        }

        public string Prefix {
            get {
                Debug.Assert(this.kind == LexKind.Name);
                Debug.Assert(this.prefix != null);
                return this.prefix;
            }
        }

        public string StringValue {
            get {
                Debug.Assert(this.kind == LexKind.String);
                Debug.Assert(this.stringValue != null);
                return this.stringValue;
            }
        }

        public double NumberValue {
            get {
                Debug.Assert(this.kind == LexKind.Number);
                Debug.Assert(this.numberValue != double.NaN);
                return this.numberValue;
            }
        }

        // To parse PathExpr we need a way to distinct name from function. 
        // THis distinction can't be done without context: "or (1 != 0)" this this a function or 'or' in OrExp 
        public bool CanBeFunction {
            get {
                Debug.Assert(this.kind == LexKind.Name);
                return this.canBeFunction;
            }
        }

        void SkipSpace() {
            while (XmlCharType.IsWhiteSpace(this.CurerntChar) && NextChar()) ;
        }

        public bool NextLex() {
            SkipSpace();
            switch (this.CurerntChar) {
            case '\0'  : 
                kind = LexKind.Eof;
                return false;
            case ',': case '@': case '(': case ')': 
            case '|': case '*': case '[': case ']': 
            case '+': case '-': case '=': case '#': 
            case '$':
                kind =  (LexKind) Convert.ToInt32(this.CurerntChar);
                NextChar();
                break;
            case '<': 
                kind = LexKind.Lt;
                NextChar();
                if (this.CurerntChar == '=') {
                    kind = LexKind.Le;
                    NextChar();
                }
                break;
            case '>': 
                kind = LexKind.Gt;
                NextChar();
                if (this.CurerntChar == '=') {
                    kind = LexKind.Ge;
                    NextChar();
                }
                break;
            case '!': 
                kind = LexKind.Bang;
                NextChar();
                if (this.CurerntChar == '=') {
                    kind = LexKind.Ne;
                    NextChar();
                }
                break;
            case '.': 
                kind = LexKind.Dot;
                NextChar();
                if (this.CurerntChar == '.') {
                    kind = LexKind.DotDot;
                    NextChar();
                }
                else if (XmlCharType.IsDigit(this.CurerntChar)) {
                    kind = LexKind.Number;
                    numberValue = ScanFraction();
                }
                break;
            case '/':
                kind = LexKind.Slash;
                NextChar();
                if (this.CurerntChar == '/') {
                    kind = LexKind.SlashSlash;
                    NextChar();
                }
                break;
            case '"': 
            case '\'': 
                this.kind = LexKind.String;
                this.stringValue = ScanString();
                break;
            default:
                if (XmlCharType.IsDigit(this.CurerntChar)) {
                    kind = LexKind.Number;
                    numberValue = ScanNumber();
                }
                else if (XmlCharType.IsStartNCNameChar(this.CurerntChar)) {
                    kind = LexKind.Name;
                    this.name   = ScanName();
                    this.prefix = string.Empty;
                    // "foo:bar" is one lexem not three because it doesn't allow spaces in between
                    // We should distinct it from "foo::" and need process "foo ::" as well
                    if (this.CurerntChar == ':') {
                        NextChar();
                        // can be "foo:bar" or "foo::"
                        if (this.CurerntChar == ':') {   // "foo::"
                            NextChar();
                            kind = LexKind.Axe;
                        }
                        else {                          // "foo:*", "foo:bar" or "foo: "
                            this.prefix = this.name;
                            if (this.CurerntChar == '*') {
	                            NextChar();
                                this.name = "*";
                            }
                            else if (XmlCharType.IsStartNCNameChar(this.CurerntChar)) {
                                this.name = ScanName(); 
                            }
                            else {
                                throw new XPathException(Res.Xp_InvalidName, SourceText);
                            }
                        }

                    }
                    else {
                        SkipSpace();
                        if (this.CurerntChar == ':') {
                            NextChar();
                            // it can be "foo ::" or just "foo :"
                            if (this.CurerntChar == ':') {
                                NextChar();
                                kind = LexKind.Axe;
                            }
                            else {
                                throw new XPathException(Res.Xp_InvalidName, SourceText);
                            }
                        }
                    }
                    SkipSpace();
                    this.canBeFunction = (this.CurerntChar == '(');
                }
                else {
                    throw new XPathException(Res.Xp_InvalidToken, SourceText);
                }
		        break;
            }
            return true;
        }

        private double ScanNumber() {
            Debug.Assert(this.CurerntChar == '.' || XmlCharType.IsDigit(this.CurerntChar));
            int start = xpathExprIndex - 1;
			int len = 0;
			while (XmlCharType.IsDigit(this.CurerntChar)) {
				NextChar(); len ++;
			}
            if (this.CurerntChar == '.') {
				NextChar(); len ++;
				while (XmlCharType.IsDigit(this.CurerntChar)) {
					NextChar(); len ++;
				}
            }
			return XmlConvert.ToXPathDouble(this.xpathExpr.Substring(start, len));
        }

        private double ScanFraction() {
            Debug.Assert(XmlCharType.IsDigit(this.CurerntChar));
            int start = xpathExprIndex - 2;
            Debug.Assert(0 <= start && this.xpathExpr[start] == '.');
			int len = 1; // '.'
			while (XmlCharType.IsDigit(this.CurerntChar)) {
				NextChar(); len ++;
			}
			return XmlConvert.ToXPathDouble(this.xpathExpr.Substring(start, len));
        }

        private string ScanString() {
            char endChar = this.CurerntChar;
            NextChar();
            int start = xpathExprIndex - 1;
			int len = 0;
            while(this.CurerntChar != endChar) {
				if (! NextChar()) {
	                throw new XPathException(Res.Xp_UnclosedString);
				}
				len ++;
			}
            Debug.Assert(this.CurerntChar == endChar);
            NextChar();
            return this.xpathExpr.Substring(start, len);
        }

        private string ScanName() {
            Debug.Assert(XmlCharType.IsStartNCNameChar(this.CurerntChar));
            int start = xpathExprIndex - 1;
			int len = 0;
            while (XmlCharType.IsNCNameChar(this.CurerntChar)) {
				NextChar(); len ++;
			}
            return this.xpathExpr.Substring(start, len);
        }

        public enum LexKind  {
            Comma                 = ',',
            Slash                 = '/',
            At                    = '@',
            Dot                   = '.',
            LParens               = '(',
            RParens               = ')',
            LBracket              = '[',
            RBracket              = ']',
            Star                  = '*',
            Plus                  = '+',
            Minus                 = '-',
            Eq                    = '=',
            Lt                    = '<',
            Gt                    = '>',
            Bang                  = '!',
            Dollar                = '$',
            Apos                  = '\'',
            Quote                 = '"',
            Union                 = '|',
            Ne                    = 'N',   // !=
            Le                    = 'L',   // <=
            Ge                    = 'G',   // >=
            And                   = 'A',   // &&
            Or                    = 'O',   // ||
            DotDot                = 'D',   // ..
            SlashSlash            = 'S',   // //
            Name                  = 'n',   // XML _Name
            String                = 's',   // Quoted string constant
            Number                = 'd',   // _Number constant
            Axe                   = 'a',   // Axe (like child::)
            Eof                   = 'E',
        };
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathselectioniterator.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathSelectionIterator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XPathSelectionIterator.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml.XPath {
    using System;
    using System.Diagnostics;

    internal class XPathSelectionIterator : ResetableIterator {
        private XPathNavigator nav;
        private IQuery         query;
        private int            position;
        
        public XPathSelectionIterator(XPathNavigator nav, XPathExpression expr) {
            this.nav = nav.Clone();
            query = ((CompiledXpathExpr) expr).QueryTree;
            if (query.ReturnType() != XPathResultType.NodeSet) {
                throw new XPathException(Res.Xp_NodeSetExpected);
            }
            query.setContext(nav.Clone());
        }

        public XPathSelectionIterator(XPathNavigator nav, string xpath) {
            this.nav = nav;
            query = new QueryBuilder().Build( xpath, /*allowVar:*/true, /*allowKey:*/true );
            if (query.ReturnType() != XPathResultType.NodeSet) {
                throw new XPathException(Res.Xp_NodeSetExpected);
            }
            query.setContext(nav.Clone());
        }

        private XPathSelectionIterator(XPathNavigator nav, IQuery query) {
            this.nav = nav;
            this.query = query;
        }

        public override ResetableIterator MakeNewCopy() {
           return new XPathSelectionIterator(nav.Clone(),query.Clone());
        }
        
        // sdub: Clone() inplementation of this class rely on fact that position is exectely the number of 
        //       calls to query.advance(). If you decide to overide this class be avare of that you don't breake this.
        private XPathSelectionIterator(XPathSelectionIterator it) {
            this.nav   = it.nav.Clone();
            this.query = it.query.Clone();
            for(position = 0; position < it.position; position ++) {
                this.query.advance();
            }
        }

        public override bool MoveNext() {
            XPathNavigator n = query.advance();
	        if( n != null ) {
                position++;
                if (!nav.MoveTo(n)) {                   
		            nav = n;
                }
                return true;
            }
            return false;
        }

        public override XPathNavigator Current {
            get { return nav; }
        }

        public override int CurrentPosition { 
       	    get { return position;  }
        }
	    
        public override void Reset() {
            this.query.reset();
        }

        public override XPathNodeIterator Clone() {
            return new XPathSelectionIterator(this);
        }

       
    }     
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathsingletoniterator.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathSingletonIterator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XPathSingletonIterator.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml.XPath {
    using System;
    using System.Diagnostics;
    
    /// <include file='doc\XPathSingletonIterator.uex' path='docs/doc[@for="XPathSingletonIterator"]/*' />
    internal class XPathSingletonIterator: ResetableIterator {
        private XPathNavigator nav;
        private int position;

        /// <include file='doc\XPathSingletonIterator.uex' path='docs/doc[@for="XPathSingletonIterator.XPathSingletonIterator"]/*' />
        public XPathSingletonIterator(XPathNavigator nav) {
            Debug.Assert(nav != null);
            this.nav = nav;
        }

        /// <include file='doc\XPathSingletonIterator.uex' path='docs/doc[@for="XPathSingletonIterator.XPathSingletonIterator1"]/*' />

        public override ResetableIterator MakeNewCopy(){
            return new XPathSingletonIterator(this.nav.Clone());
        }
        
        
        public XPathSingletonIterator(XPathSingletonIterator it) {
            this.nav      = it.nav.Clone();
            this.position = it.position;
        }

        /// <include file='doc\XPathSingletonIterator.uex' path='docs/doc[@for="XPathSingletonIterator.Clone"]/*' />
        public override XPathNodeIterator Clone() {
            return new XPathSingletonIterator(this);
        }

        /// <include file='doc\XPathSingletonIterator.uex' path='docs/doc[@for="XPathSingletonIterator.Current"]/*' />
        public override XPathNavigator Current {
            get { return nav; }
        }

        /// <include file='doc\XPathSingletonIterator.uex' path='docs/doc[@for="XPathSingletonIterator.CurrentPosition"]/*' />
        public override int CurrentPosition {
            get { return position; }
        }

        /// <include file='doc\XPathSingletonIterator.uex' path='docs/doc[@for="XPathSingletonIterator.Count"]/*' />
        public override int Count {
            get { return 1; }
        }

        /// <include file='doc\XPathSingletonIterator.uex' path='docs/doc[@for="XPathSingletonIterator.MoveNext"]/*' />
        public override bool MoveNext() {
            if(position == 0) {
                position = 1;
                return true;
            }
            return false;
        }

        /// <include file='doc\XPathSingletonIterator.uex' path='docs/doc[@for="XPathSingletonIterator.Reset"]/*' />
        public override void Reset() {
            position = 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Runtime.InteropServices;
    using System;
    using System.Collections;
    using System.Diagnostics;

    internal class XPathParser {
        XPathScanner scanner;

		private XPathParser(XPathScanner scanner) {
            this.scanner = scanner;
		}

		public static AstNode ParseXPathExpresion(string xpathExpresion) {
			XPathScanner scanner = new XPathScanner(xpathExpresion);
			XPathParser  parser  = new XPathParser(scanner);
            AstNode result = parser.ParseExpresion(null);
            if (scanner.Kind != XPathScanner.LexKind.Eof) {
                throw new XPathException(Res.Xp_InvalidToken, scanner.SourceText);
            }
			return result;
		}

		public static AstNode ParseXPathPattern(string xpathPattern) {
			XPathScanner scanner = new XPathScanner(xpathPattern);
			XPathParser  parser  = new XPathParser(scanner);
            AstNode result = parser.ParsePattern(null);
            if (scanner.Kind != XPathScanner.LexKind.Eof) {
                throw new XPathException(Res.Xp_InvalidToken, scanner.SourceText);
            }
			return result;
		}

        // --------------- Expresion Parsing ----------------------

        private AstNode ParseExpresion(AstNode qyInput) {
            return ParseOrExpr(qyInput);
        }

        //>> OrExpr ::= ( OrExpr 'or' )? AndExpr 
        private AstNode ParseOrExpr(AstNode qyInput) {
            AstNode opnd = ParseAndExpr(qyInput);

            do {
                if (! TestOp("or")) {
                    return opnd;
                }
                NextLex();
                opnd = new Operator(Operator.Op.OR, opnd, ParseAndExpr(qyInput));
            }while (true);
        }

        //>> AndExpr ::= ( AndExpr 'and' )? EqualityExpr 
        private AstNode ParseAndExpr(AstNode qyInput) {
            AstNode opnd = ParseEqualityExpr(qyInput);

            do {
                if (! TestOp("and")) {
                    return opnd;
                }
                NextLex();
                opnd = new Operator(Operator.Op.AND, opnd, ParseEqualityExpr(qyInput));
            }while (true);
        }

        //>> EqualityOp ::= '=' | '!='
        //>> EqualityExpr    ::= ( EqualityExpr EqualityOp )? RelationalExpr
        private AstNode ParseEqualityExpr(AstNode  qyInput) {
            AstNode opnd = ParseRelationalExpr(qyInput);

            do {
                Operator.Op op = (
                    this.scanner.Kind == XPathScanner.LexKind.Eq ? Operator.Op.EQ :
                    this.scanner.Kind == XPathScanner.LexKind.Ne ? Operator.Op.NE :
                    /*default :*/                                  Operator.Op.INVALID
                );
                if (op == Operator.Op.INVALID) {
                    return opnd;
                }
                NextLex();
                opnd = new Operator(op, opnd, ParseRelationalExpr(qyInput));
            }while (true);
        }

        //>> RelationalOp ::= '<' | '>' | '<=' | '>='
        //>> RelationalExpr    ::= ( RelationalExpr RelationalOp )? AdditiveExpr  
        private AstNode ParseRelationalExpr(AstNode  qyInput) {
            AstNode  opnd = ParseAdditiveExpr(qyInput);

            do {
                Operator.Op op = (
                    this.scanner.Kind == XPathScanner.LexKind.Lt ? Operator.Op.LT :
                    this.scanner.Kind == XPathScanner.LexKind.Le ? Operator.Op.LE :
                    this.scanner.Kind == XPathScanner.LexKind.Gt ? Operator.Op.GT :
                    this.scanner.Kind == XPathScanner.LexKind.Ge ? Operator.Op.GE :
                    /*default :*/                                  Operator.Op.INVALID
                );
                if (op == Operator.Op.INVALID) {
                    return opnd;
                }
                NextLex();
                opnd = new Operator(op, opnd, ParseAdditiveExpr(qyInput));
            }while (true);
        }

        //>> AdditiveOp   ::= '+' | '-'
        //>> AdditiveExpr ::= ( AdditiveExpr AdditiveOp )? MultiplicativeExpr
        private AstNode ParseAdditiveExpr(AstNode  qyInput) {
            AstNode  opnd = ParseMultiplicativeExpr(qyInput);

            do {
                Operator.Op op = (
                    this.scanner.Kind == XPathScanner.LexKind.Plus  ? Operator.Op.PLUS  :
                    this.scanner.Kind == XPathScanner.LexKind.Minus ? Operator.Op.MINUS :
                    /*default :*/                                     Operator.Op.INVALID
                );
                if (op == Operator.Op.INVALID) {
                    return opnd;
                }
                NextLex();
                opnd = new Operator(op, opnd, ParseMultiplicativeExpr(qyInput));
            }while (true);
        }

        //>> MultiplicativeOp   ::= '*' | 'div' | 'mod'
        //>> MultiplicativeExpr ::= ( MultiplicativeExpr MultiplicativeOp )? UnaryExpr
        private AstNode ParseMultiplicativeExpr(AstNode  qyInput) {
            AstNode  opnd = ParseUnaryExpr(qyInput);

            do {
                Operator.Op op = (
                    this.scanner.Kind == XPathScanner.LexKind.Star  ? Operator.Op.MUL :
                    TestOp("div")                                   ? Operator.Op.DIV :
                    TestOp("mod")                                   ? Operator.Op.MOD :
                    /*default :*/                                     Operator.Op.INVALID
                );
                if (op == Operator.Op.INVALID) {
                    return opnd;
                }
                NextLex();
                opnd = new Operator(op, opnd, ParseUnaryExpr(qyInput));
            }while (true);
        }

        //>> UnaryExpr    ::= UnionExpr | '-' UnaryExpr
        private AstNode ParseUnaryExpr(AstNode  qyInput) {
            if (this.scanner.Kind == XPathScanner.LexKind.Minus) {
                NextLex();
                return new Operator(Operator.Op.NEGATE, ParseUnaryExpr(qyInput), null);
            }
            else {
                return ParseUnionExpr(qyInput);
            }
        }

        //>> UnionExpr ::= ( UnionExpr '|' )? PathExpr  
        private AstNode ParseUnionExpr(AstNode  qyInput) {
            AstNode opnd = ParsePathExpr(qyInput);

            do {
                if (this.scanner.Kind != XPathScanner.LexKind.Union) {
                    return opnd;
                }
                NextLex();
                AstNode opnd2 = ParsePathExpr(qyInput);
                CheckNodeSet(opnd.ReturnType);
                CheckNodeSet(opnd2.ReturnType);
                opnd = new Operator(Operator.Op.UNION, opnd, opnd2);
            }while (true);
        }

        private static bool IsNodeType(XPathScanner scaner) {
            return (
                scaner.Prefix.Length == 0 && (
                    scaner.Name == "node"                   || 
                    scaner.Name == "text"                   || 
                    scaner.Name == "processing-instruction" || 
                    scaner.Name == "comment"
                )
            );
        }

        //>> PathOp   ::= '/' | '//'
        //>> PathExpr ::= LocationPath | 
        //>>              FilterExpr ( PathOp  RelativeLocationPath )?
        private AstNode ParsePathExpr(AstNode qyInput) {
			AstNode opnd;
			if (IsPrimaryExpr(this.scanner)) { // in this moment we shoud distinct LocationPas vs FilterExpr (which starts from is PrimaryExpr)
			    opnd = ParseFilterExpr(qyInput);
				if (this.scanner.Kind == XPathScanner.LexKind.Slash) {
					NextLex();
					opnd = ParseRelativeLocationPath(opnd);
				}
				else if (this.scanner.Kind == XPathScanner.LexKind.SlashSlash) {
					NextLex();
					opnd = ParseRelativeLocationPath(new Axis(Axis.AxisType.DescendantOrSelf, opnd));
				}
			}
			else {
                opnd = ParseLocationPath(null);
            }

            return opnd;
        }

        //>> FilterExpr ::= PrimaryExpr | FilterExpr Predicate 
        private AstNode ParseFilterExpr(AstNode  qyInput) {
            AstNode  opnd = ParsePrimaryExpr(qyInput);  
            while (this.scanner.Kind == XPathScanner.LexKind.LBracket) {
                // opnd must be a query
                opnd = new Filter(opnd, ParsePredicate(opnd));
            }
            return opnd;
        }

        //>> Predicate ::= '[' Expr ']'
        private AstNode ParsePredicate(AstNode  qyInput) {
            AstNode  opnd;

            // we have predicates. Check that input type is NodeSet
            CheckNodeSet(qyInput.ReturnType);

            PassToken(XPathScanner.LexKind.LBracket);
            opnd = ParseExpresion(qyInput);
            PassToken(XPathScanner.LexKind.RBracket);

            return opnd;
        }

        //>> LocationPath ::= RelativeLocationPath | AbsoluteLocationPath
        private AstNode ParseLocationPath(AstNode qyInput) {
            if (this.scanner.Kind == XPathScanner.LexKind.Slash) {
                NextLex();
                AstNode opnd = new Root();

                if (IsStep(this.scanner.Kind)) {
                    opnd = ParseRelativeLocationPath(opnd);
                }
                return opnd;
            }
            else if (this.scanner.Kind == XPathScanner.LexKind.SlashSlash) {
                NextLex();
                return ParseRelativeLocationPath(new Axis(Axis.AxisType.DescendantOrSelf, new Root()));
            }
            else {
                return  ParseRelativeLocationPath(qyInput);
            }
        } // ParseLocationPath

        //>> PathOp   ::= '/' | '//'
        //>> RelativeLocationPath ::= ( RelativeLocationPath PathOp )? Step 
        private AstNode ParseRelativeLocationPath(AstNode  qyInput) {
            AstNode  opnd = ParseStep(qyInput);
            if (XPathScanner.LexKind.SlashSlash == this.scanner.Kind) {
                NextLex();
                opnd = ParseRelativeLocationPath(new Axis(Axis.AxisType.DescendantOrSelf,opnd));
            }
			else if (XPathScanner.LexKind.Slash == this.scanner.Kind) {
                NextLex();
                opnd = ParseRelativeLocationPath(opnd);
            }
            return opnd;
        }

		private static bool IsStep(XPathScanner.LexKind lexKind) {
			return (
				lexKind == XPathScanner.LexKind.Dot    ||
				lexKind == XPathScanner.LexKind.DotDot ||
				lexKind == XPathScanner.LexKind.At     ||
				lexKind == XPathScanner.LexKind.Axe    ||
				lexKind == XPathScanner.LexKind.Star   ||
				lexKind == XPathScanner.LexKind.Name          // NodeTest is also Name
			);
		}

        //>> Step ::= '.' | '..' | ( AxisName '::' | '@' )? NodeTest Predicate*
        private AstNode ParseStep(AstNode  qyInput) {
            AstNode  opnd;
            if (XPathScanner.LexKind.Dot == this.scanner.Kind) {         //>> '.'
                NextLex();
                opnd = new Axis(Axis.AxisType.Self, qyInput);
            }
            else if (XPathScanner.LexKind.DotDot == this.scanner.Kind) { //>> '..'
                NextLex();
                opnd = new Axis(Axis.AxisType.Parent, qyInput);
            }
            else {                                                          //>> ( AxisName '::' | '@' )? NodeTest Predicate*
                Axis.AxisType axisType = Axis.AxisType.Child;
                switch (this.scanner.Kind) {
                case XPathScanner.LexKind.At:                               //>> '@'
                    axisType = Axis.AxisType.Attribute;
                    NextLex();
                    break;
                case XPathScanner.LexKind.Axe:                              //>> AxisName '::'
                    axisType = GetAxis(this.scanner);
                    NextLex();
                    break;
                }
                XPathNodeType nodeType = (
                    axisType == Axis.AxisType.Attribute ? XPathNodeType.Attribute :
//                    axisType == Axis.AxisType.Namespace ? XPathNodeType.Namespace : // No Idea why it's this way but othervise Axes doesn't work
                    /* default: */                        XPathNodeType.Element
                );

                opnd = ParseNodeTest(qyInput, axisType, nodeType);

                while (XPathScanner.LexKind.LBracket == this.scanner.Kind) {
                    opnd = new Filter(opnd, ParsePredicate(opnd));
                } 
            }
            return opnd;
        }

        //>> NodeTest ::= NameTest | 'comment ()' | 'text ()' | 'node ()' | 'processing-instruction ('  Literal ? ')'
        private AstNode ParseNodeTest(AstNode qyInput, Axis.AxisType axisType, XPathNodeType nodeType) {
            string        nodeName, nodePrefix;

            switch (this.scanner.Kind) {
            case XPathScanner.LexKind.Name :
                if (this.scanner.CanBeFunction && IsNodeType(this.scanner)) {
                    nodePrefix = string.Empty;
                    nodeName   = string.Empty;
                    nodeType = (
                        this.scanner.Name == "comment"                ? XPathNodeType.Comment :
                        this.scanner.Name == "text"                   ? XPathNodeType.Text :
                        this.scanner.Name == "node"                   ? XPathNodeType.All :
                        this.scanner.Name == "processing-instruction" ? XPathNodeType.ProcessingInstruction :
                        /* default: */ XPathNodeType.Root
                    );
                    Debug.Assert(nodeType != XPathNodeType.Root);
                    NextLex();

                    PassToken(XPathScanner.LexKind.LParens);

                    if (nodeType == XPathNodeType.ProcessingInstruction) {
                        if (this.scanner.Kind != XPathScanner.LexKind.RParens) { //>> 'processing-instruction (' Literal ')'
                            CheckToken(XPathScanner.LexKind.String);
                            nodeName = this.scanner.StringValue;
                            NextLex();
                        }
                    }

                    PassToken(XPathScanner.LexKind.RParens);
                }
                else {
                    nodePrefix = this.scanner.Prefix;
                    nodeName   = this.scanner.Name;
	                NextLex();
                    if (nodeName == "*") {
                        nodeName = string.Empty;
                    }
                }
                break;
            case XPathScanner.LexKind.Star :
                nodePrefix = string.Empty;
                nodeName   = string.Empty;
                NextLex();
                break;
            default :
	            throw new XPathException(Res.Xp_NodeSetExpected, this.scanner.SourceText);
            }
            return new Axis(axisType, qyInput, nodePrefix, nodeName, nodeType);
        }

		private static bool IsPrimaryExpr(XPathScanner scanner) {
			return (
				scanner.Kind == XPathScanner.LexKind.String  ||
				scanner.Kind == XPathScanner.LexKind.Number  ||
				scanner.Kind == XPathScanner.LexKind.Dollar  ||
				scanner.Kind == XPathScanner.LexKind.LParens ||
				scanner.Kind == XPathScanner.LexKind.Name && scanner.CanBeFunction && ! IsNodeType(scanner)
			);
		}

        //>> PrimaryExpr ::= Literal | Number | VariableReference | '(' Expr ')' | FunctionCall
        private AstNode ParsePrimaryExpr(AstNode  qyInput) {
            Debug.Assert(IsPrimaryExpr(this.scanner));
            AstNode  opnd = null;
            switch (this.scanner.Kind) {
            case XPathScanner.LexKind.String:
                opnd = new Operand(this.scanner.StringValue);
                NextLex();
                break;
            case XPathScanner.LexKind.Number:
                opnd = new Operand(this.scanner.NumberValue);
                NextLex();
                break;
            case XPathScanner.LexKind.Dollar:
                NextLex();
                CheckToken(XPathScanner.LexKind.Name);
                opnd = new Variable(this.scanner.Name, this.scanner.Prefix);
                NextLex();
                break;
            case XPathScanner.LexKind.LParens:
                NextLex();
                opnd = ParseExpresion(qyInput);
                if (opnd.TypeOfAst != AstNode.QueryType.ConstantOperand) {
                    opnd = new Group(opnd);
                }
                PassToken(XPathScanner.LexKind.RParens);
                break;
            case XPathScanner.LexKind.Name :
                if (this.scanner.CanBeFunction && ! IsNodeType(this.scanner)) {
                    opnd = ParseMethod(null); 
                }
                break;
            }
			Debug.Assert(opnd != null, "IsPrimaryExpr() was true. We should recognize this lex.");
            return opnd;
        }

        private AstNode ParseMethod(AstNode qyInput) {
            ArrayList argList = new ArrayList();
            string name   = this.scanner.Name;
            string prefix = this.scanner.Prefix;
            PassToken(XPathScanner.LexKind.Name);
            PassToken(XPathScanner.LexKind.LParens);
            if (this.scanner.Kind != XPathScanner.LexKind.RParens) {
                do {
                    argList.Add(ParseExpresion(qyInput));
                    if (this.scanner.Kind == XPathScanner.LexKind.RParens) {
                        break;
                    }
                    PassToken(XPathScanner.LexKind.Comma);
                }while (true);
            }
            PassToken(XPathScanner.LexKind.RParens);
            if (prefix == string.Empty) {
                ParamInfo pi = (ParamInfo) functionTable[name];
                if (pi != null) {
                    int argCount = argList.Count;
                    if (argCount < pi.Minargs) {
                        throw new XPathException(Res.Xp_InvalidNumArgs, name, this.scanner.SourceText);
                    }
                    if (pi.FType == Function.FunctionType.FuncConcat) {
                        for (int i = 0; i < argCount; i ++) {
                            AstNode arg = (AstNode)argList[i];
                            if (arg.ReturnType != XPathResultType.String) {
                                arg = new Function(Function.FunctionType.FuncString, arg);
                            }
                            argList[i] = arg;
                        }
                    }
                    else {
                        if (pi.Maxargs < argCount) {
                            throw new XPathException(Res.Xp_InvalidNumArgs, name, this.scanner.SourceText);
                        }
                        if (pi.ArgTypes.Length < argCount) {
                            argCount = pi.ArgTypes.Length;    // argument we have the type specified (can be < pi.Minargs)
                        }
                        for (int i = 0; i < argCount; i ++) {
                            AstNode arg = (AstNode)argList[i];
                            if (
                                pi.ArgTypes[i] != XPathResultType.Any && 
                                pi.ArgTypes[i] != arg.ReturnType
                            ) {
                                switch (pi.ArgTypes[i]) {
                                case  XPathResultType.NodeSet :
                                    if (!(arg is Variable) && !(arg is Function && arg.ReturnType == XPathResultType.Error) ) {
                                        throw new XPathException(Res.Xp_InvalidArgumentType, name, this.scanner.SourceText);
                                    }
                                    break;
                                case  XPathResultType.String :
                                    arg = new Function(Function.FunctionType.FuncString, arg);
                                    break;
                                case  XPathResultType.Number :
                                    arg = new Function(Function.FunctionType.FuncNumber, arg);
                                    break;
                                case  XPathResultType.Boolean :
                                    arg = new Function(Function.FunctionType.FuncBoolean, arg);
                                    break;
                                }
                                argList[i] = arg;
                            }
                        }
                    }
					return new Function(pi.FType, argList);
                }
            }
            return new Function(prefix, name, argList);
        }

        // --------------- Pattern Parsing ----------------------

        //>> Pattern ::= ( Pattern '|' )? LocationPathPattern
        private AstNode ParsePattern(AstNode  qyInput) {
            AstNode opnd = ParseLocationPathPattern(qyInput);

            do {
                if (this.scanner.Kind != XPathScanner.LexKind.Union) {
                    return opnd;
                }
                NextLex();
                opnd = new Operator(Operator.Op.UNION, opnd, ParseLocationPathPattern(qyInput));
            }while (true);
        }

        //>> LocationPathPattern ::= '/' | RelativePathPattern | '//' RelativePathPattern  |  '/' RelativePathPattern
        //>>                       | IdKeyPattern (('/' | '//') RelativePathPattern)?  
        private AstNode ParseLocationPathPattern(AstNode qyInput) {
            AstNode opnd = null;
            switch (this.scanner.Kind) {
            case XPathScanner.LexKind.Slash :
                NextLex();
                opnd = new Root();
                if (this.scanner.Kind == XPathScanner.LexKind.Eof || this.scanner.Kind == XPathScanner.LexKind.Union) {
                    return opnd;
                }
                break;
            case XPathScanner.LexKind.SlashSlash :
                NextLex();
                opnd = new Axis(Axis.AxisType.DescendantOrSelf, new Root());
                break;
            case XPathScanner.LexKind.Name :
                if (this.scanner.CanBeFunction) {
                    opnd = ParseIdKeyPattern(qyInput);
                    if (opnd != null) {
                        switch (this.scanner.Kind) {
                        case XPathScanner.LexKind.Slash :
                            NextLex();
                            break;
                        case XPathScanner.LexKind.SlashSlash :
                            NextLex();
                            opnd = new Axis(Axis.AxisType.DescendantOrSelf, opnd);
                            break;
                        default :
                            return opnd;
                        }
                    }
                }
                break;
            }
            return ParseRelativePathPattern(opnd);
        }

        //>> IdKeyPattern ::= 'id' '(' Literal ')' | 'key' '(' Literal ',' Literal ')'  
        private AstNode ParseIdKeyPattern(AstNode qyInput) {
            Debug.Assert(this.scanner.CanBeFunction);
            ArrayList argList = new ArrayList();
            if (this.scanner.Prefix.Length == 0) {
                if (this.scanner.Name == "id") {
                    ParamInfo pi = (ParamInfo) functionTable["id"];
                    NextLex();;
                    PassToken(XPathScanner.LexKind.LParens);
                    CheckToken(XPathScanner.LexKind.String);
                    argList.Add(new Operand(this.scanner.StringValue));
                    NextLex();
                    PassToken(XPathScanner.LexKind.RParens);
					return new Function(pi.FType, argList);
                }
                if (this.scanner.Name == "key") {
                    NextLex();
                    PassToken(XPathScanner.LexKind.LParens);
                    CheckToken(XPathScanner.LexKind.String);
                    argList.Add(new Operand(this.scanner.StringValue));
                    NextLex();
                    PassToken(XPathScanner.LexKind.Comma);
                    CheckToken(XPathScanner.LexKind.String);
                    argList.Add(new Operand(this.scanner.StringValue));
                    NextLex();
                    PassToken(XPathScanner.LexKind.RParens);
					return new Function("", "key", argList);
                }
            }
            return null;
        }

        //>> PathOp   ::= '/' | '//'
        //>> RelativePathPattern ::= ( RelativePathPattern PathOp )? StepPattern
        private AstNode ParseRelativePathPattern(AstNode qyInput) {
            AstNode  opnd = ParseStepPattern(qyInput);
            if (XPathScanner.LexKind.SlashSlash == this.scanner.Kind) {
                NextLex();
                opnd = ParseRelativePathPattern(new Axis(Axis.AxisType.DescendantOrSelf, opnd));
            }
			else if (XPathScanner.LexKind.Slash == this.scanner.Kind) {
                NextLex();
                opnd = ParseRelativePathPattern(opnd);
            }
            return opnd;
        }

        //>> StepPattern    ::=    ChildOrAttributeAxisSpecifier NodeTest Predicate*   
        //>> ChildOrAttributeAxisSpecifier    ::=    @ ? | ('child' | 'attribute') '::' 
        private AstNode ParseStepPattern(AstNode qyInput) {
            AstNode  opnd;
            Axis.AxisType axisType = Axis.AxisType.Child;
            switch (this.scanner.Kind) {
            case XPathScanner.LexKind.At:                               //>> '@'
                axisType = Axis.AxisType.Attribute;
                NextLex();
                break;
            case XPathScanner.LexKind.Axe:                              //>> AxisName '::'
                axisType = GetAxis(this.scanner);
                if (axisType != Axis.AxisType.Child && axisType != Axis.AxisType.Attribute) {
                    throw new XPathException(Res.Xp_InvalidToken, scanner.SourceText);
                }
                NextLex();
                break;
            }
            XPathNodeType nodeType = (
                axisType == Axis.AxisType.Attribute ? XPathNodeType.Attribute :
                /* default: */                        XPathNodeType.Element
            );

            opnd = ParseNodeTest(qyInput, axisType, nodeType);

            while (XPathScanner.LexKind.LBracket == this.scanner.Kind) {
                opnd = new Filter(opnd, ParsePredicate(opnd));
            } 
            return opnd;
        }

#if false
        // --------------- Identity-constraint ----------------------

        //>> Selector ::= ( Path  '|' )* Path
        private AstNode ParseSelector(AstNode  qyInput) {
            AstNode opnd = qyInput;

            do {
                opnd = new Operator(Operator.Op.UNION, opnd, ParsePathXsd(qyInput, /*allowAttribute:*/false));
                if (this.scanner.Kind != XPathScanner.LexKind.Union) {
                    return opnd;
                }
                NextLex();
            }while (true);
        }

        //>> Field ::= ( Path  '|' )* Path
        private AstNode ParseField(AstNode  qyInput) {
            AstNode opnd = qyInput;

            do {
                opnd = new Operator(Operator.Op.UNION, opnd, ParsePathXsd(qyInput, /*allowAttribute:*/true));
                if (this.scanner.Kind != XPathScanner.LexKind.Union) {
                    return opnd;
                }
                NextLex();
            }while (true);
        }

        //>> Path ::= ('.//')? ( Step '/' )* Step
        //>> Path ::= ('.//')? ( Step '/' )* ( Step | '@' NameTest ) 
        private AstNode ParsePathXsd(AstNode qyInput, bool allowAttribute) {
            AstNode opnd = qyInput;
            if (this.scanner.Kind == XPathScanner.LexKind.Dot) {
                NextLex();
                opnd = new Axis(Axis.AxisType.Self, opnd);
                // we don't know yet -- this '.' can be './/' './' or just '.'
                switch (this.scanner.Kind) {
                case XPathScanner.LexKind.SlashSlash:
                    NextLex();
                    opnd = new Axis(Axis.AxisType.DescendantOrSelf, opnd);
                    break;
                case XPathScanner.LexKind.Slash :
                    NextLex();
                    break;
                default :
                    return opnd;
                }
            }
            do {
                if (allowAttribute && this.scanner.Kind == XPathScanner.LexKind.At) {
                    NextLex();
                    return ParseNameTestXsd(qyInput, Axis.AxisType.Attribute, XPathNodeType.Attribute);
                }
                opnd = ParseStepXsd(opnd);
                if (this.scanner.Kind != XPathScanner.LexKind.Slash) {
                    return opnd;
                }
                NextLex();
            }while (true);
        }

        //>> Step ::=  '.' | NameTest  
        private AstNode ParseStepXsd(AstNode  qyInput) {
            if (this.scanner.Kind == XPathScanner.LexKind.Dot) {
                NextLex();
                return new Axis(Axis.AxisType.Self, qyInput);
            }
            else {
                return ParseNameTestXsd(qyInput, Axis.AxisType.Child, XPathNodeType.Element);
            }
        }
 
        //>> NameTest ::= QName | '*' | NCName ':' '*'
        private AstNode ParseNameTestXsd(AstNode qyInput, Axis.AxisType axisType, XPathNodeType nodeType) {
            string        nodeName, nodePrefix;

            switch (this.scanner.Kind) {
            case XPathScanner.LexKind.Name :
                nodePrefix = this.scanner.Prefix;
                nodeName   = this.scanner.Name;
	            NextLex();
                if (nodeName == "*") {
                    nodeName = string.Empty;
                }
                break;
            case XPathScanner.LexKind.Star :
                nodePrefix = string.Empty;
                nodeName   = string.Empty;
                NextLex();
                break;
            default :
	            throw new XPathException(Res.Xp_NodeSetExpected, this.scanner.SourceText);
            }
            return new Axis(axisType, qyInput, nodePrefix, nodeName, nodeType);
        }
#endif

        // --------------- Halper methods ----------------------

        void CheckToken(XPathScanner.LexKind t) {
            if (this.scanner.Kind != t) {
                throw new XPathException(Res.Xp_InvalidToken, this.scanner.SourceText);
            }
        }

        void PassToken(XPathScanner.LexKind t) {
            CheckToken(t);
            NextLex();
        }

        void NextLex(XPathScanner.LexKind t) {
            Debug.Assert(this.scanner.Kind == t);
            NextLex();
        }

        void NextLex() {
            this.scanner.NextLex();
        }

        private bool TestOp(string op) {
            return (
                this.scanner.Kind == XPathScanner.LexKind.Name && 
                this.scanner.Prefix.Length == 0 && 
                this.scanner.Name.Equals(op)
            );
        }

        void CheckNodeSet(XPathResultType t) {
            if (t != XPathResultType.NodeSet && t != XPathResultType.Error) {
                throw new XPathException(Res.Xp_NodeSetExpected, this.scanner.SourceText);
            }
        }

        // ----------------------------------------------------------------
        static readonly XPathResultType[] temparray1 = {XPathResultType.Error};
        static readonly XPathResultType[] temparray2 = {XPathResultType.NodeSet};                     
        static readonly XPathResultType[] temparray3 = {XPathResultType.Any};        
        static readonly XPathResultType[] temparray4 = {XPathResultType.String};                  
        static readonly XPathResultType[] temparray5 = {XPathResultType.String, XPathResultType.String};
        static readonly XPathResultType[] temparray6 = {XPathResultType.String, XPathResultType.Number, XPathResultType.Number};
        static readonly XPathResultType[] temparray7 = {XPathResultType.String, XPathResultType.String, XPathResultType.String};
        static readonly XPathResultType[] temparray8 = {XPathResultType.Boolean};
        static readonly XPathResultType[] temparray9 = {XPathResultType.Number};        
        
        private class ParamInfo {
            private Function.FunctionType ftype;
            private int                   minargs;
            private int                   maxargs;
            private XPathResultType[]     argTypes;

            public Function.FunctionType FType    { get { return this.ftype;    } }
            public int                   Minargs  { get { return this.minargs;  } }
            public int                   Maxargs  { get { return this.maxargs;  } }
            public XPathResultType[]     ArgTypes { get { return this.argTypes; } }

            internal ParamInfo(Function.FunctionType ftype, int minargs,  int maxargs, XPathResultType[] argTypes) {
                this.ftype   = ftype;
                this.minargs = minargs;
                this.maxargs = maxargs;
                this.argTypes = argTypes;
            }         
        } //ParamInfo

        private static Hashtable functionTable = CreateFunctionTable();
        private static Hashtable CreateFunctionTable(){
            Hashtable table = new Hashtable(36);
            table.Add("last"               , new ParamInfo(Function.FunctionType.FuncLast           , 0, 0, temparray1));  
            table.Add("position"           , new ParamInfo(Function.FunctionType.FuncPosition       , 0, 0, temparray1));  
            table.Add("name"               , new ParamInfo(Function.FunctionType.FuncName           , 0, 1, temparray2));  
            table.Add("namespace-uri"      , new ParamInfo(Function.FunctionType.FuncNameSpaceUri   , 0, 1, temparray2));  
            table.Add("local-name"         , new ParamInfo(Function.FunctionType.FuncLocalName      , 0, 1, temparray2));  
            table.Add("count"              , new ParamInfo(Function.FunctionType.FuncCount          , 1, 1, temparray2));  
            table.Add("id"                 , new ParamInfo(Function.FunctionType.FuncID             , 1, 1, temparray3));  
            table.Add("string"             , new ParamInfo(Function.FunctionType.FuncString         , 0, 1, temparray3));  
            table.Add("concat"             , new ParamInfo(Function.FunctionType.FuncConcat         , 2, 100, temparray4));
            table.Add("starts-with"        , new ParamInfo(Function.FunctionType.FuncStartsWith     , 2, 2, temparray5));  
            table.Add("contains"           , new ParamInfo(Function.FunctionType.FuncContains       , 2, 2, temparray5));  
            table.Add("substring-before"   , new ParamInfo(Function.FunctionType.FuncSubstringBefore, 2, 2, temparray5));  
            table.Add("substring-after"    , new ParamInfo(Function.FunctionType.FuncSubstringAfter , 2, 2, temparray5));  
            table.Add("substring"          , new ParamInfo(Function.FunctionType.FuncSubstring      , 2, 3, temparray6));  
            table.Add("string-length"      , new ParamInfo(Function.FunctionType.FuncStringLength   , 0, 1, temparray4));  
            table.Add("normalize-space"    , new ParamInfo(Function.FunctionType.FuncNormalize      , 0, 1, temparray4));  
            table.Add("translate"          , new ParamInfo(Function.FunctionType.FuncTranslate      , 3, 3, temparray7));  
            table.Add("boolean"            , new ParamInfo(Function.FunctionType.FuncBoolean        , 1, 1, temparray3));  
            table.Add("not"                , new ParamInfo(Function.FunctionType.FuncNot            , 1, 1, temparray8));  
            table.Add("true"               , new ParamInfo(Function.FunctionType.FuncTrue           , 0, 0 ,temparray8));  
            table.Add("false"              , new ParamInfo(Function.FunctionType.FuncFalse          , 0, 0, temparray8));  
            table.Add("lang"               , new ParamInfo(Function.FunctionType.FuncLang           , 1, 1, temparray4));  
            table.Add("number"             , new ParamInfo(Function.FunctionType.FuncNumber         , 0, 1, temparray3));  
            table.Add("sum"                , new ParamInfo(Function.FunctionType.FuncSum            , 1, 1, temparray2));  
            table.Add("floor"              , new ParamInfo(Function.FunctionType.FuncFloor          , 1, 1, temparray9));  
            table.Add("ceiling"            , new ParamInfo(Function.FunctionType.FuncCeiling        , 1, 1, temparray9));  
            table.Add("round"              , new ParamInfo(Function.FunctionType.FuncRound          , 1, 1, temparray9));  
            return table;
        }

        private static Hashtable AxesTable = CreateAxesTable();
        private static Hashtable CreateAxesTable() {
            Hashtable table = new Hashtable(13);
            table.Add("ancestor"          , Axis.AxisType.Ancestor         );
            table.Add("ancestor-or-self"  , Axis.AxisType.AncestorOrSelf   );
            table.Add("attribute"         , Axis.AxisType.Attribute        );
            table.Add("child"             , Axis.AxisType.Child            );
            table.Add("descendant"        , Axis.AxisType.Descendant       );
            table.Add("descendant-or-self", Axis.AxisType.DescendantOrSelf );
            table.Add("following"         , Axis.AxisType.Following        );
            table.Add("following-sibling" , Axis.AxisType.FollowingSibling );
            table.Add("namespace"         , Axis.AxisType.Namespace        );
            table.Add("parent"            , Axis.AxisType.Parent           );
            table.Add("preceding"         , Axis.AxisType.Preceding        );
            table.Add("preceding-sibling" , Axis.AxisType.PrecedingSibling );
            table.Add("self"              , Axis.AxisType.Self             );
            return table;
        }

        private Axis.AxisType GetAxis(XPathScanner scaner) {
            Debug.Assert(scaner.Kind == XPathScanner.LexKind.Axe);
            object axis = AxesTable[scaner.Name];
            if (axis == null) {
                throw new XPathException(Res.Xp_InvalidToken, scanner.SourceText);
            }
            return (Axis.AxisType) axis;
        }
       
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xpathselfquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathSelfQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 

    using System.Collections;

    internal class XPathSelfQuery : BaseAxisQuery {
        protected bool first = true;
        protected XPathNavigator _e = null;
        private bool _Context;
        
        internal XPathSelfQuery(XPathNavigator Input) {
            _e = Input;
            first=true;
            _Context = true;
        }

        internal XPathSelfQuery(XPathNavigator Input, bool simple) {
            _e = Input;
            first=true;
            m_Type = XPathNodeType.All;
            _Context = true;

        }
        
        internal XPathSelfQuery() {
            _Context = true;
        }
        
        internal XPathSelfQuery(
                               IQuery  qyInput,
                               String Name,
                               String Prefix,
                               String URN,
                               XPathNodeType Type) : base(qyInput, Name,  Prefix, URN,  Type) {
        }
                
        internal override void setContext(XPathNavigator e) {
            if (m_qyInput != null){
                m_qyInput.setContext(e);
            }
            else
            {
                _e = e;
                first = true;
            }
        }
        
        internal override XPathNavigator advance() {
            if (_e != null) {
                if (first) {
                    first = false;
                    if (_Context || matches(_e)) {
                        _position = 1;
                        return _e;
                    }
                    return null;
                }
                else
                    return null;
            }

            while (true) {
                m_eNext = m_qyInput.advance();
                if (m_eNext != null) {
                    if (matches(m_eNext)){
                        _position++;
                        return m_eNext;
                    }
                }
                else
                    return null;
            }
        }
                
        override internal void reset() {
            first = true;
        } 

        override internal XPathNavigator peekElement() {
            if (_e != null)
                return _e;
            if (m_eNext == null)
                m_eNext = advance();
            return m_eNext;

        } 
        internal override IQuery Clone() {
            if (_e != null)
                return new XPathSelfQuery(_e);
            else
                return new XPathSelfQuery(CloneInput(), m_Name, m_Prefix, m_URN, m_Type);
        }

        internal override XPathNavigator MatchNode(XPathNavigator navigator){
            if (_Context)
                return navigator;
            throw new XPathException(Res.Xp_InvalidPattern);
        }

        internal override Querytype getName() {
            if (m_qyInput == null) {
                return Querytype.Self;
            }
            else {
                return m_qyInput.getName();
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\action.cs ===
//------------------------------------------------------------------------------
// <copyright file="Action.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Xml;
    using System.Xml.XPath;
    using System.Xml.Xsl.Debugger;

    internal abstract class Action {
        internal const int Initialized  =  0;
        internal const int Finished     = -1;

        internal abstract void Execute(Processor processor, ActionFrame frame);

        internal virtual String Select {
            get { return null; }
        }

        internal virtual void ReplaceNamespaceAlias(Compiler compiler){}

        [System.Diagnostics.Conditional("DEBUG")]
        internal virtual void Trace(int tab) {}

        // -------------- Debugger related stuff ---------
        // BadBad: We have to pass ActionFrame to GetNavigator and GetVariables
        // bacause CopyCodeAction can't implement them without frame.count

        internal virtual DbgData GetDbgData(ActionFrame frame) { return DbgData.Empty; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\actionframe.cs ===
//------------------------------------------------------------------------------
// <copyright file="ActionFrame.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Xml;
    using System.Xml.XPath;
    using System.Collections;
    using System.Diagnostics;
    using System.Xml.Xsl.Debugger;

    internal class ActionFrame : IStackFrame {
        private int               state;         // Action execution state
        private int               counter;       // Counter, for the use of particular action
        private object []         variables;     // Store for template local variable values
        private Hashtable         withParams;
        private Action            action;        // Action currently being executed
        private ActionFrame       container;     // Frame of enclosing container action and index within it
        private int               currentAction;
        private XPathNodeIterator nodeSet;       // Current node set
        private XPathNodeIterator newNodeSet;    // Node set for processing children or other templates

        // Variables to store action data between states:
        private PrefixQName       calulatedName; // Used in ElementAction and AttributeAction
        private string            storedOutput;  // Used in NumberAction, CopyOfAction, ValueOfAction and ProcessingInstructionAction

        internal PrefixQName CalulatedName {
            get { return this.calulatedName; }
            set { this.calulatedName = value; }
        }

        internal string StoredOutput {
            get { return this.storedOutput; }
            set { this.storedOutput = value; }
        }

        internal int State {
            get { return this.state; }
            set { this.state = value; }
        }

        internal int Counter {
            get { return this.counter; }
            set { this.counter = value; }
        }

        internal object [] Variables {
            get { return this.variables; }
        }

        internal ActionFrame Container {
            get { return this.container; }
        }

        internal XPathNavigator Node {
            get {
                if (this.nodeSet != null)  {
                    return this.nodeSet.Current;
                }
                return null;
            }
        }

        internal XPathNodeIterator NodeSet {
            get { return this.nodeSet; }
        }

        internal XPathNodeIterator NewNodeSet {
            get { return this.newNodeSet; }
        }

        internal int IncrementCounter() {
            return ++ this.counter;
        }

        internal void AllocateVariables(int count) {
            Debug.WriteLine("Allocating variables: " + count);
            if (0 < count) {
                this.variables = new object [count];
            }
            else {
                this.variables = null;
            }
        }

        internal object GetVariable(int index) {
            Debug.Assert(this.variables != null && index < this.variables.Length);
            return this.variables[index];
        }

        internal void SetVariable(int index, object value) {
            Debug.Assert(this.variables != null && index < this.variables.Length);
            this.variables[index] = value;
        }

        internal void SetParameter(XmlQualifiedName name, object value) {
            if (this.withParams == null) {
                this.withParams = new Hashtable();
            }
            Debug.Assert(! this.withParams.Contains(name), "We should check duplicate params at compile time");
            this.withParams[name] = value;
        }

        internal void ResetParams() {
            if (this.withParams != null)
                this.withParams.Clear();
        }

        internal object GetParameter(XmlQualifiedName name) {
            if (this.withParams != null) {
                return this.withParams[name];
            }
            return null;
        }

        internal void InitNodeSet(XPathNodeIterator nodeSet) {
            Debug.Assert(nodeSet != null);
            this.nodeSet = nodeSet;
        }

        internal void InitNewNodeSet(XPathNodeIterator nodeSet) {
            Debug.Assert(nodeSet != null);
            this.newNodeSet = nodeSet;
        }

        internal void SortNewNodeSet(Processor proc, ArrayList sortarray) {
            Debug.Assert(0 < sortarray.Count);
            int numSorts = sortarray.Count;
            XPathSortComparer comparer = new XPathSortComparer(numSorts);
            IQuery[]  sortExpressions = new IQuery[numSorts];
            ArrayList comparers       = new ArrayList(numSorts);
            for (int i = 0; i < numSorts; i++) {
                Sort sort = (Sort) sortarray[i];
                XPathExpression expr = proc.GetCompiledQuery(sort.select);
                
                comparer.AddSort(
                    ((CompiledXpathExpr)expr).QueryTree, 
                    new XPathComparerHelper(sort.order, sort.caseOrder, sort.lang, sort.dataType)
                );
            }
            ArrayList results = new ArrayList();

            Debug.Assert(proc.ActionStack.Peek() == this, "the trick we are doing with proc.Current will work only if this is topmost frame");

            while (NewNextNode(proc)) {
                XPathNodeIterator savedNodeset = this.nodeSet;
                this.nodeSet = this.newNodeSet;              // trick proc.Current node

                SortKey key = new SortKey(numSorts, /*originalPosition:*/results.Count, this.newNodeSet.Current.Clone());

                for (int j = 0; j < numSorts; j ++) {
                    key[j] = comparer.Expression(j).getValue(this.newNodeSet.Current, this.newNodeSet);
                }
                results.Add(key);

                this.nodeSet = savedNodeset;                 // restore proc.Current node
            }
            results.Sort(comparer);
            this.newNodeSet = new XPathSortArrayIterator(results);
        }

        // Finished
        internal void Finished() {
            State = Action.Finished;
        }

        internal void Inherit(ActionFrame parent) {
            Debug.Assert(parent != null);
            this.variables = parent.variables;
        }

        private void Init(Action action, ActionFrame container, XPathNodeIterator nodeSet) {
            this.state         = Action.Initialized;
            this.action        = action;
            this.container     = container;
            this.currentAction = 0;
            this.nodeSet       = nodeSet;
            this.newNodeSet    = null;
        }

        internal void Init(Action action, XPathNodeIterator nodeSet) {
            Init(action, null, nodeSet);
        }

        internal void Init(ActionFrame containerFrame, XPathNodeIterator nodeSet) {
            Init(containerFrame.GetAction(0), containerFrame, nodeSet);
        }

        internal void SetAction(Action action) {
            SetAction(action, Action.Initialized);
        }

        internal void SetAction(Action action, int state) {
            this.action = action;
            this.state  = state;
        }

        private Action GetAction(int actionIndex) {
            Debug.Assert(this.action is ContainerAction);
            return((ContainerAction) this.action).GetAction(actionIndex);
        }

        internal void Exit() {
            Finished();
            this.container = null;
        }

        /*
         * Execute
         *  return values: true - pop, false - nothing
         */
        internal bool Execute(Processor processor) {
            if (this.action == null) {
                return true;
            }

            // Execute the action
            this.action.Execute(processor, this);

            // Process results
            if (State == Action.Finished) {
                // Advanced to next action
                if(this.container != null) {
                    this.currentAction ++;
                    this.action =  this.container.GetAction(this.currentAction);
                    State = Action.Initialized;
                }
                else {
                    this.action = null;
                }
                return this.action == null;
            }

            return false;                       // Do not pop, unless specified otherwise
        }

       internal bool NextNode(Processor proc) {
            bool next = this.nodeSet.MoveNext();
            if (proc.Stylesheet.Whitespace) {
                XPathNodeType type = this.nodeSet.Current.NodeType;
                if (type == XPathNodeType.Whitespace) {
                    XPathNavigator nav = this.nodeSet.Current.Clone();
                    bool flag;
                    do {
                        nav.MoveTo(this.nodeSet.Current);
                        nav.MoveToParent();
                        flag = ! proc.Stylesheet.PreserveWhiteSpace(proc, nav) && (next = this.nodeSet.MoveNext());
                        type = this.nodeSet.Current.NodeType;                    
                    }
                    while (flag && (type == XPathNodeType.Whitespace ));
                }
            }
            return next;
        }

        internal bool NewNextNode(Processor proc) {
            bool next = this.newNodeSet.MoveNext();
            if (proc.Stylesheet.Whitespace) {
                XPathNodeType type = this.newNodeSet.Current.NodeType;
                if (type == XPathNodeType.Whitespace) {
                    XPathNavigator nav = this.newNodeSet.Current.Clone();
                    bool flag;
                    do {
                        nav.MoveTo(this.newNodeSet.Current);
                        nav.MoveToParent();
                        flag = ! proc.Stylesheet.PreserveWhiteSpace(proc, nav) &&  (next = this.newNodeSet.MoveNext()) ;
                        type = this.newNodeSet.Current.NodeType;
                    }
                    while(flag && (type == XPathNodeType.Whitespace ));
                }                            
            }
            return next;
        }

        // ----------------------- IStackFrame : --------------------
        XPathNavigator    IStackFrame.Instruction { 
            get { 
                if (this.action == null) {
                    return null; // for builtIn action this shoud be null;
                }
                return this.action.GetDbgData(this).StyleSheet; 
            }
        }
        XPathNodeIterator IStackFrame.NodeSet { 
            get { return this.nodeSet.Clone(); }
        }
        // Variables:
        int               IStackFrame.GetVariablesCount() {
            if (this.action == null) {
                return 0;
            }
            return this.action.GetDbgData(this).Variables.Length;
        }
        XPathNavigator    IStackFrame.GetVariable(int varIndex) {
            return this.action.GetDbgData(this).Variables[varIndex].GetDbgData(null).StyleSheet;
        }
        object            IStackFrame.GetVariableValue(int varIndex) { 
            return GetVariable(this.action.GetDbgData(this).Variables[varIndex].VarKey); 
        }

        // special array iterator that iterates over ArrayList of SortKey
        private class XPathSortArrayIterator : XPathArrayIterator {
            public XPathSortArrayIterator(ArrayList array) : base(array) {}
            public XPathSortArrayIterator(XPathSortArrayIterator it) : base(it) {}

            public override XPathNodeIterator Clone() {
                return new XPathSortArrayIterator(this);
            }

            public override XPathNavigator Current {
                get {
                    Debug.Assert(index > 0, "MoveNext() wasn't called");
                    return ((SortKey) this.array[this.index - 1]).Node;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\applyimportsaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="ApplyImportsAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class ApplyImportsAction : CompiledAction {
        private XmlQualifiedName   mode;
        private Stylesheet         stylesheet;
        private const int    TemplateProcessed = 2;
        internal override void Compile(Compiler compiler) {
            CheckEmpty(compiler);
            if (! compiler.CanHaveApplyImports) {
                throw new XsltException(Res.Xslt_ApplyImports);                
            }
            this.mode = compiler.CurrentMode;
            this.stylesheet = compiler.CompiledStylesheet;
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);
            switch (frame.State) {
            case Initialized:
                processor.PushTemplateLookup(frame.NodeSet, this.mode, /*importsOf:*/this.stylesheet);
                frame.State = TemplateProcessed;
                break;
            case TemplateProcessed:
                frame.Finished();
                break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\xsltfunction.cs ===
//------------------------------------------------------------------------------
// <copyright file="XsltFunction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Xml.Xsl;
    using System.Collections;

    internal  class XsltFunction : IQuery {
        private String _Prefix;
        private String _Name;
        private ArrayList _ArgList;                // this is a list of subexpressions we have to recalulate before each invokation
        private object[]  _ArgArray;               // place for results for _ArgList execution
        private XsltContext _XsltContext;
        private IQuery _ResultQuery;
        private IXsltContextFunction functionToCall;
        
        internal XsltFunction(String prefix, String name, ArrayList ArgList) {
            _Prefix = prefix;
            _Name = name;
            _ArgList = ArgList;
            _ArgArray = new object[_ArgList.Count];
        }

        private IXsltContextFunction Function {
            get {
                if(functionToCall == null) {
                    if (_XsltContext == null ) {
                        throw new XPathException(Res.Xp_UndefinedXsltContext, _Prefix, _Name);
                    }
                    int length = _ArgList.Count;
                    XPathResultType[] argTypes ;
                   /* if (_Prefix == String.Empty) {
                        argTypes = null;
                    }
                    else {*/
                        argTypes = new XPathResultType[length];
                        for(int i = 0; i < length; i ++) {
                            argTypes[i] = ((IQuery)_ArgList[i]).ReturnType();
                        }
                    //}
                    functionToCall = _XsltContext.ResolveFunction(_Prefix, _Name, argTypes);
                }
                return functionToCall;
            }
        }
        
        internal override void SetXsltContext(XsltContext context) {
            _XsltContext = context;
            foreach(IQuery argument in _ArgList) 
                argument.SetXsltContext(context);
        }

        internal override void setContext(XPathNavigator context) {
            InvokeFunction(context, null);
        }

        internal override XPathNavigator advance() {
            return _ResultQuery.advance(); 
        }

        internal override Object getValue(IQuery qy) {
            InvokeFunction(qy.peekElement().Clone(), null);
            return _ResultQuery.getValue(qy);
        } 
        
        internal override Object getValue(XPathNavigator qy, XPathNodeIterator iterator) {
            InvokeFunction(qy, iterator);
            return _ResultQuery.getValue(qy, iterator);
        } 

        internal override XPathNavigator peekElement() {
            Debug.Assert(_ResultQuery != null && _ResultQuery.ReturnType() == XPathResultType.NodeSet);
            return _ResultQuery.peekElement();
        }

        internal override IQuery Clone() {
            ArrayList argsClone = (ArrayList) _ArgList.Clone(); {
                for (int i = 0; i < _ArgList.Count; i ++) {
                    argsClone[i] = ((IQuery) _ArgList[i]).Clone();
                }
            }
            XsltFunction clone = new XsltFunction(_Prefix, _Name, argsClone); {
                if (_ResultQuery != null) {
                    clone._ResultQuery = _ResultQuery.Clone();
                }
                clone._XsltContext   = _XsltContext;
                clone.functionToCall = functionToCall;
            }
            return clone;
        }
        
        internal override XPathResultType  ReturnType() {
            if (_ResultQuery == null) {
                return this.Function.ReturnType;
            } 
            else {
                return _ResultQuery.ReturnType();
            }
        }

        internal override int Position {
            get {
                if ( _ResultQuery == null) {
                    return 0;
                }
                return _ResultQuery.Position;
            }
        }
 
        private void InvokeFunction(XPathNavigator qy, XPathNodeIterator iterator) {
            IXsltContextFunction function = this.Function;

            // calculate arguments:
            Debug.Assert(_ArgArray != null && _ArgArray.Length == _ArgList.Count);
            for(int i = _ArgList.Count - 1; 0 <= i; i --) {
                IQuery arg = (IQuery) _ArgList[i];
                if (arg.ReturnType() == XPathResultType.NodeSet) {
                    _ArgArray[i] = new XPathQueryIterator(arg, qy.Clone());
                }
                else {
                    _ArgArray[i] = arg.getValue(qy, iterator);
                }
            }

            try {
                object result = function.Invoke(_XsltContext, _ArgArray, qy);

                if(result == null) {
                    _ResultQuery = new OperandQuery( String.Empty, XPathResultType.String );
                }
                else {
                    XPathResultType returnedType = function.ReturnType;
                    if(returnedType == XPathResultType.Any) {
                        // If function is untyped get returned type from real result
                        returnedType = XsltCompileContext.GetXPathType(result.GetType());
                    }
                    switch (returnedType) {
                    case XPathResultType.String :
                        // trick. As soon XPathResultType.Navigator will be distinct type rid of from it. 
                        //_ResultQuery = new OperandQuery( result, XPathResultType.String );
                        if(result is XPathNavigator) {
                            _ResultQuery = new NavigatorQuery((XPathNavigator)result);
                        }
                        else {
                            _ResultQuery = new OperandQuery( result, XPathResultType.String );
                        }
                        break;
                    case XPathResultType.Boolean :
                        _ResultQuery = new OperandQuery( result, XPathResultType.Boolean );
                        break;
                    case XPathResultType.Number :
                        _ResultQuery = new OperandQuery( XmlConvert.ToXPathDouble( result ), XPathResultType.Number );
                        break;
                    case XPathResultType.NodeSet :
                        if (result is ResetableIterator) {
                            _ResultQuery = new XmlIteratorQuery((ResetableIterator)result);
                        }
                        else {
                            Debug.Assert(false, "Unexpected type of XPathNodeIterator");
                            throw new NotSupportedException(Res.GetString(Res.XmlUnsupportedType, result.GetType().FullName)); 
                        }
                        break;
//                  case XPathResultType.Navigator :
//                      _ResultQuery = new NavigatorQuery((XPathNavigator)result);
//                      break;
                    default :
                        _ResultQuery = new OperandQuery( result.ToString(), XPathResultType.String );
                        break;
                    }
                }
            }
            catch(Exception ex) {
                string qname = _Prefix != string.Empty ? _Prefix + ":" + _Name : _Name;
                throw new XsltException(Res.Xslt_FunctionFailed, new string[] {qname}, ex);
            }
        }

        internal override void reset() {
            if (_ResultQuery != null)
                _ResultQuery.reset();
        }

        internal override XPathNavigator MatchNode(XPathNavigator navigator) {
            if (_Name != "key" && _Prefix != String.Empty) {
                throw new XPathException(Res.Xp_InvalidPattern);
            }
            InvokeFunction(navigator, null);
            XPathNavigator nav = null;
            while ( (nav = _ResultQuery.advance()) != null ) {
                if (nav.IsSamePosition(navigator)) {
                    return nav;
                }
            }
            return nav;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\attributeaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="AttributeAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class AttributeAction : ContainerAction {
        private const int NameDone          = 2;

        private Avt               nameAvt;
        private Avt               nsAvt;
        private InputScopeManager manager;
        // Compile time precalculated AVTs
        private string            name;
        private string            nsUri;
        private PrefixQName       qname; // When we not have AVTs at all we can do this. null otherwise.

        private static PrefixQName CreateAttributeQName(string name, string nsUri, InputScopeManager manager) {
            // if name == "xmlns" we don't need to generate this attribute.
            // to avoid i'ts generation we can return false and not add AtributeCation to it's parent container action
            // for now not creating this.qname will do the trick at execution time
            if (name  == Keywords.s_Xmlns) return null;
            if (nsUri == Keywords.s_XmlnsNamespace) {
                throw new XsltException(Res.Xslt_ReservedNS, nsUri);
            }

            PrefixQName qname = new PrefixQName();
            qname.SetQName(name);

            qname.Namespace = nsUri != null ? nsUri : manager.ResolveXPathNamespace(qname.Prefix);

            if(qname.Prefix.StartsWith("xml")) {
                if (qname.Prefix.Length == 3) { // prefix == "xml"
                    if (qname.Namespace == Keywords.s_XmlNamespace && (qname.Name == "lang" || qname.Name == "space")) {
                        // preserve prefix for xml:lang and xml:space
                    }
                    else {
                        qname.ClearPrefix();
                    }
                }
                else if (qname.Prefix == Keywords.s_Xmlns) {
                    if (qname.Namespace == Keywords.s_XmlnsNamespace) {
                        // if NS wasn't specified we have to use prefix to find it and this is imposible for 'xmlns' 
                        throw new XsltException(Res.Xslt_InvalidPrefix, qname.Prefix);
                    }
                    else {
                        qname.ClearPrefix();
                    }
                }
            }
            return qname;
        }

        internal override void Compile(Compiler compiler) {
            CompileAttributes(compiler);
            CheckRequiredAttribute(compiler, this.nameAvt, Keywords.s_Name);

            this.name  = PrecalculateAvt(ref this.nameAvt);
            this.nsUri = PrecalculateAvt(ref this.nsAvt  );

            // if both name and ns are not AVT we can calculate qname at compile time and will not need namespace manager anymore
            if (this.nameAvt == null && this.nsAvt == null) {
                if(this.name != Keywords.s_Xmlns) {
                    this.qname = CreateAttributeQName(this.name, this.nsUri, compiler.CloneScopeManager());                    
                }
            }
            else {
                this.manager = compiler.CloneScopeManager();
            }

            if (compiler.Recurse()) {
                CompileTemplate(compiler);
                compiler.ToParent();
            }
        }

        internal override bool CompileAttribute(Compiler compiler) {
            string name   = compiler.Input.LocalName;
            string value  = compiler.Input.Value;
            if (Keywords.Equals(name, compiler.Atoms.Name)) {
                this.nameAvt = Avt.CompileAvt(compiler, value);
                Debug.WriteLine("name = \"" + value + "\"");
            }
            else if (Keywords.Equals(name, compiler.Atoms.Namespace)) {
                this.nsAvt = Avt.CompileAvt(compiler, value);
                Debug.WriteLine("namespace = \"" + value + "\"");
            }
            else {
                return false;
            }

            return true;
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);

            switch (frame.State) {
            case Initialized:
                if(this.qname != null) {
                    frame.CalulatedName = this.qname;
                }
                else {
                    frame.CalulatedName = CreateAttributeQName(
                        this.nameAvt == null ? this.name  : this.nameAvt.Evaluate(processor, frame),
                        this.nsAvt   == null ? this.nsUri : this.nsAvt  .Evaluate(processor, frame),
                        this.manager
                    );
                    if(frame.CalulatedName == null) {
                        // name == "xmlns" case. Ignore xsl:attribute
                        frame.Finished();
                        break;
                    }
                }
                goto case NameDone;
            case NameDone :
                {
                    PrefixQName qname = frame.CalulatedName;
                    if (processor.BeginEvent(XPathNodeType.Attribute, qname.Prefix, qname.Name, qname.Namespace, false) == false) {
                        // Come back later
                        frame.State = NameDone;
                        break;
                    }

                    processor.PushActionFrame(frame);
                    frame.State = ProcessingChildren;
                    break;                              // Allow children to run
                }
            case ProcessingChildren:
                if (processor.EndEvent(XPathNodeType.Attribute) == false) {
                    Debug.WriteLine("Cannot end event, breaking, will restart");
                    frame.State = ProcessingChildren;
                    break;
                }
                frame.Finished();
                break;
            default:
                Debug.Fail("Invalid ElementAction execution state");
    		    break;
            }
        }

        internal override void Trace(int tab) {
            Debug.Indent(tab);
//            Debug.WriteLine("<xsl:attribute name=\"" + this.name + "\" namespace=\"" + this.nsUri + "\">");
            base.Trace(tab);
            Debug.Indent(tab);
            Debug.WriteLine("</xsl:attribute>");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\attributesetaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="AttributeSetAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;
    using System.Collections;

    internal class AttributeSetAction : ContainerAction {
        internal XmlQualifiedName            name;

        internal XmlQualifiedName Name {
            get { return this.name; }
        }

        internal override void Compile(Compiler compiler) {
            CompileAttributes(compiler);
            CheckRequiredAttribute(compiler, this.name, Keywords.s_Name);
            CompileContent(compiler);
        }

        internal override bool CompileAttribute(Compiler compiler) {
            string name   = compiler.Input.LocalName;
            string value  = compiler.Input.Value;
            if (Keywords.Equals(name, compiler.Atoms.Name)) {
                Debug.Assert(this.name == null);
                this.name = compiler.CreateXPathQName(value);
                Debug.WriteLine("name attribute found: " + this.name);
            }
            else if (Keywords.Equals(name, compiler.Atoms.UseAttributeSets)) {
                // create a UseAttributeSetsAction
                // sets come before xsl:attributes
                AddAction(compiler.CreateUseAttributeSetsAction());
            }
            else {
                return false;
            }

            return true;
        }

        private void CompileContent(Compiler compiler) {
            NavigatorInput input = compiler.Input;

            if (compiler.Recurse()) {
                do {
                    Debug.Trace(input);

                    switch(input.NodeType) {
                    case XPathNodeType.Element:
                        compiler.PushNamespaceScope();

                        string nspace = input.NamespaceURI;
                        string name   = input.LocalName;

                        if (Keywords.Equals(nspace, input.Atoms.XsltNamespace) && Keywords.Equals(name, input.Atoms.Attribute)) {
                            // found attribute so add it
                            AddAction(compiler.CreateAttributeAction());
                        }
                        else {
                            throw XsltException.UnexpectedKeyword(compiler);
                        }
                        compiler.PopScope();
                        break;

                    case XPathNodeType.Comment:
                    case XPathNodeType.ProcessingInstruction:
                    case XPathNodeType.Whitespace:
                    case XPathNodeType.SignificantWhitespace:
                        break;

                    default:
                        throw new XsltException(Res.Xslt_InvalidContents, Keywords.s_AttributeSet);
                    }
                }
                while(compiler.Advance());

                compiler.ToParent();
            }
        }

        internal void Merge(AttributeSetAction attributeAction) {
            // add the contents of "attributeAction" to this action
            // place them at the end
            Action  action;
            int     i = 0;

            while((action = attributeAction.GetAction(i)) != null) {
                AddAction(action);
                i++;
            }
        }

        internal override void Trace(int tab) {
            Debug.Indent(tab);
            Debug.WriteLine("<xsl:attribute-set name=\"" + this.name + "\">");
            base.Trace(tab + 1);
            Debug.Indent(tab);
            Debug.WriteLine("</xsl:attribute-set>");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\avtevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="AvtEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;
    using System.Text;

    internal sealed class AvtEvent : TextEvent {
        private int key;

        public AvtEvent(int key) {
            Debug.Assert(key != Compiler.InvalidQueryKey);
            this.key = key;
        }

        public override bool Output(Processor processor, ActionFrame frame) {
            Debug.Assert(key != Compiler.InvalidQueryKey);
            return processor.TextEvent(processor.EvaluateString(frame, this.key));
        }

        public override string Evaluate(Processor processor, ActionFrame frame) {
            return processor.EvaluateString(frame, this.key);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\avt.cs ===
//------------------------------------------------------------------------------
// <copyright file="Avt.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.Xml;
    using System.Xml.XPath;
    using System.Text;

    internal sealed class Avt {
        private string      constAvt;
        private TextEvent[] events;

        private Avt(string constAvt) {
            Debug.Assert(constAvt != null);
            this.constAvt = constAvt;
        }

        private Avt(ArrayList eventList) {
            Debug.Assert(eventList != null);
            this.events = new TextEvent[eventList.Count];
            for(int i = 0; i < eventList.Count; i ++) {
                this.events[i] = (TextEvent) eventList[i];
            }
        }

        public bool IsConstant {
            get {return this.events == null;}
        }

        internal string Evaluate(Processor processor, ActionFrame frame) {
            if (IsConstant) {
                Debug.Assert(constAvt != null);
                return constAvt;
            }
            else {
                Debug.Assert(processor != null && frame != null);

                StringBuilder builder = processor.GetSharedStringBuilder();

                for(int i = 0; i < events.Length; i ++) {
                    builder.Append(events[i].Evaluate(processor, frame));
                }
                processor.ReleaseSharedStringBuilder();
                return builder.ToString();
            }
        }

        internal static Avt CompileAvt(Compiler compiler, string avtText) {
            Debug.Assert(compiler != null);
            Debug.Assert(avtText != null);
            new ArrayList();

            bool constant;
            ArrayList list = compiler.CompileAvt(avtText, out constant);
            return constant ? new Avt(avtText) : new Avt(list);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\applytemplatesaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="ApplyTemplatesAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.Xml;
    using System.Xml.XPath;

    internal class ApplyTemplatesAction : ContainerAction {
        private const int    ProcessedChildren = 2;
        private const int    ProcessNextNode   = 3;
        private const int    PositionAdvanced  = 4;
        private const int    TemplateProcessed = 5;

        private string             select;
        private int                selectKey  = Compiler.InvalidQueryKey;
        private XmlQualifiedName   mode;

        //
        //  <xsl:template match="*|/" [mode="?"]>
        //    <xsl:apply-templates [mode="?"]/>
        //  </xsl:template>
        //

        private static ApplyTemplatesAction s_BuiltInRule = new ApplyTemplatesAction();

        internal static ApplyTemplatesAction BuiltInRule() {
            Debug.Assert(s_BuiltInRule != null);
            return s_BuiltInRule;
        }

        internal static ApplyTemplatesAction BuiltInRule(XmlQualifiedName mode) {
            return(mode == null || mode.IsEmpty) ? BuiltInRule() : new ApplyTemplatesAction(mode);
        }

        internal ApplyTemplatesAction() {}

        private ApplyTemplatesAction(XmlQualifiedName mode) {
            Debug.Assert(mode != null);
            this.mode = mode;
        }

        internal override String Select {
            get { return this.select; }
        }
        
        internal override void Compile(Compiler compiler) {
            Debug.Assert(!IsBuiltInAction);

            CompileAttributes(compiler);
            CompileContent(compiler);
        }

        internal override bool CompileAttribute(Compiler compiler) {
            string name   = compiler.Input.LocalName;
            string value  = compiler.Input.Value;
            if (Keywords.Equals(name, compiler.Atoms.Select )) {
                this.select    = value;
                this.selectKey = compiler.AddQuery(this.select);
                Debug.WriteLine("apply-templates select: \"" + this.select + "\" (#" + this.selectKey.ToString() + ")");
            }
            else if (Keywords.Equals(name, compiler.Atoms.Mode )) {
                Debug.Assert(this.mode == null);
                if (compiler.AllowBuiltInMode && value.Trim() == "*") {
                    this.mode = Compiler.BuiltInMode;
                }
                else {
                    this.mode = compiler.CreateXPathQName(value);
                }
                Debug.WriteLine("mode attribute found: \"" + this.mode + "\"");
            }
            else {
                return false;
            }

            return true;
        }

        private void CompileContent(Compiler compiler) {
            NavigatorInput input = compiler.Input;

            if (compiler.Recurse()) {
                do {
                    Debug.Trace(input);

                    switch (input.NodeType) {
                    case XPathNodeType.Element:
                        compiler.PushNamespaceScope();
                        string nspace = input.NamespaceURI;
                        string name   = input.LocalName;

                        if (Keywords.Equals(nspace, input.Atoms.XsltNamespace)) {
                            if (Keywords.Equals(name, input.Atoms.Sort)) {
                                AddAction(compiler.CreateSortAction());
                            }
                            else if (Keywords.Equals(name, input.Atoms.WithParam)) {
                                WithParamAction par = compiler.CreateWithParamAction();
                                CheckDuplicateParams(par.Name);
                                AddAction(par);
                            }
                            else {
                                throw XsltException.UnexpectedKeyword(compiler);
                            }
                        }
                        else {
                            throw XsltException.UnexpectedKeyword(compiler);
                        }
                        compiler.PopScope();
                        break;

                    case XPathNodeType.Comment:
                    case XPathNodeType.ProcessingInstruction:
                    case XPathNodeType.Whitespace:
                    case XPathNodeType.SignificantWhitespace:
                        break;

                    default:
                        throw new XsltException(Res.Xslt_InvalidContents, Keywords.s_ApplyTemplates);
                    }
                }
                while (compiler.Advance());

                compiler.ToParent();
            }
        }       
        
        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);

            switch (frame.State) {
            case Initialized:
		processor.ResetParams();
		processor.InitSortArray();
                if (this.containedActions != null && this.containedActions.Count > 0) {
                    processor.PushActionFrame(frame);
                    frame.State = ProcessedChildren;
                    break;
                }
                goto case ProcessedChildren;
	        case ProcessedChildren:
                if (this.selectKey == Compiler.InvalidQueryKey) {
                    Debug.Assert(this.select == null);

                    if (! frame.Node.HasChildren) {
                        frame.Finished();
                        break;
                    }
                    frame.InitNewNodeSet(frame.Node.SelectChildren(XPathNodeType.All));
                }
                else {
                    frame.InitNewNodeSet(processor.StartQuery(frame.Node, this.selectKey));
                }
                if (processor.SortArray.Count != 0) {
                    frame.SortNewNodeSet(processor, processor.SortArray);
                }
                frame.State = ProcessNextNode;
                goto case ProcessNextNode;

            case ProcessNextNode:
                Debug.Assert(frame.State == ProcessNextNode);
                Debug.Assert(frame.NewNodeSet != null);

                if (frame.NewNextNode(processor)) {
                    frame.State = PositionAdvanced;
                    goto case PositionAdvanced;
                }
                else {
                    frame.Finished();
                    break;
                }

            case PositionAdvanced:
                Debug.Assert(frame.State == PositionAdvanced);

                processor.PushTemplateLookup(frame.NewNodeSet, this.mode, /*importsOf:*/null);

                frame.State = TemplateProcessed;
                break;

            case TemplateProcessed:
                frame.State = ProcessNextNode;
                goto case ProcessNextNode;

            default:
                Debug.Fail("Invalid ApplyTemplatesAction execution state");
                break;
            }
        }

        private bool IsBuiltInAction {
            get {
                return this == s_BuiltInRule;
            }
        }

        internal override void Trace(int tab) {
            Debug.Indent(tab);
            Debug.WriteLine("<xsl:apply-templates select=\"" + this.select + "\" (#" + this.selectKey + ") mode=\"" + this.mode + "\">");
            Debug.WriteLine("</xsl:apply-templates/>");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\builderinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="BuilderInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {

    using System;
    using System.Text;
    using System.Xml;
    using System.Xml.XPath;

    internal class TextInfo {
        public TextInfo(string text, bool disableEscaping) {
            this.disableEscaping = disableEscaping;
            valueBuilder = new StringBuilder(text);
        }
        public TextInfo() {}

        internal bool          disableEscaping;
        internal StringBuilder valueBuilder;
        internal TextInfo      nextTextInfo;
    }

    internal class BuilderInfo : TextInfo {
        private string              name;
        private string              localName;
        private string              namespaceURI;
        private string              prefix;
        private XmlNodeType         nodeType;
        private int                 depth;
        private bool                isEmptyTag;
        internal bool               search;
        internal HtmlElementProps   htmlProps;
        internal HtmlAttributeProps htmlAttrProps;
        internal TextInfo           lastTextInfo; 


        internal BuilderInfo() {
            Initialize(string.Empty, string.Empty, string.Empty);
        }

        internal string Name {                        
            get {
                if (this.name == null) {
                    string prefix    = Prefix;
                    string localName = LocalName;

                    if (prefix != null && 0 < prefix.Length) {
                        if (localName.Length > 0) {
                            this.name = prefix + ":" + localName;
                        }
                        else {
                            this.name = prefix;
                        }
                    }
                    else {
                        this.name = localName;
                    }
                }
                return this.name;
            }
        }

        internal string LocalName {
            get { return this.localName; }
            set { this.localName = value; }
        }
        internal string NamespaceURI {
            get { return this.namespaceURI; }
            set { this.namespaceURI = value; }
        }
        internal string Prefix {
            get { return this.prefix; }
            set { this.prefix = value; }
        }

        internal void ClearValue() {
            this.valueBuilder.Length = 0;
            this.disableEscaping = false;
            this.nextTextInfo = null;
            this.lastTextInfo = this;
        }

        // Real value is a list of TextInfo nodes.
        // Value.get mirge them together discarding information about output escaping
        // Value.set replace all list with one TextInfo node.
        internal string Value {
            get {
                if(this.nextTextInfo == null) {
                    return this.valueBuilder.ToString();
                }
                else {
                    StringBuilder sb = new StringBuilder(this.valueBuilder.ToString());
                    for(TextInfo textInfo = this.nextTextInfo; textInfo != null; textInfo = textInfo.nextTextInfo) {
                        sb.Append(textInfo.valueBuilder.ToString());
                    }
                    return sb.ToString(); 
                }
            }
            set {
                this.ClearValue();
                this.valueBuilder.Append(value);
            }
        }

        internal void ValueAppend(string s, bool disableEscaping) {
            TextInfo last = this.lastTextInfo;
            if(last.disableEscaping == disableEscaping || last.valueBuilder.Length == 0) {
                last.valueBuilder.Append(s);
                last.disableEscaping = disableEscaping; // if the real value was empty we can override disableEscaping for this node
            }
            else {
                last.nextTextInfo = new TextInfo(s, disableEscaping);
                this.lastTextInfo = last.nextTextInfo;
            }
        }

        internal XmlNodeType NodeType {
            get { return this.nodeType; }
            set { this.nodeType = value; }
        }
        internal int Depth {
            get { return this.depth; }
            set { this.depth = value; }
        }
        internal bool IsEmptyTag {
            get { return this.isEmptyTag; }
            set { this.isEmptyTag = value; }
        }

        internal void Initialize(string prefix, string name, string nspace) {
            this.prefix        = prefix;
            this.localName     = name;
            this.namespaceURI  = nspace;
            this.name          = null;
            this.htmlProps     = null;
            this.htmlAttrProps = null;
            this.lastTextInfo  = this;
            // TextInfo:
            this.disableEscaping = false;
            this.valueBuilder    = new StringBuilder();
            this.nextTextInfo    = null;
        }

        internal void Initialize(BuilderInfo src) {
            this.prefix        = src.Prefix;
            this.localName     = src.LocalName;
            this.namespaceURI  = src.NamespaceURI;
            this.name          = null;
            this.depth         = src.Depth;
            this.nodeType      = src.NodeType;
            this.htmlProps     = src.htmlProps;
            this.htmlAttrProps = src.htmlAttrProps;
            this.lastTextInfo  = src.lastTextInfo;
            // TextInfo:
            this.disableEscaping = src.disableEscaping;
            this.valueBuilder    = src.valueBuilder;
            this.nextTextInfo    = src.nextTextInfo;
            // This not really correct to copy valueBuilder, but on next usage it will be reinitialized. The same for clone.
        }

        internal BuilderInfo Clone() {
            BuilderInfo info = (BuilderInfo) MemberwiseClone();
             // This is for cached nodes only and non whitespace text nodes will not be cached. So we cal loos disableOutputEscaping info.
            info.valueBuilder = new StringBuilder(this.Value);
            info.nextTextInfo = null; 
            info.lastTextInfo = this; 
            Debug.Assert(info.NodeType != XmlNodeType.Text || XmlCharType.IsOnlyWhitespace(info.Value));
            return info;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\beginevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="BeginEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {

    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class BeginEvent : Event {
        private XPathNodeType nodeType;
        private string        namespaceUri;
        private string        name;
        private string        prefix;
        private bool          empty;
        private object        htmlProps;
#if DEBUG
        private bool          replaceNSAliasesDone;
#endif
        
        public BeginEvent(Compiler compiler) {
            NavigatorInput input = compiler.Input;
            Debug.Assert(input != null);
            Debug.Assert(input.NodeType != XPathNodeType.Namespace);
            this.nodeType     = input.NodeType;
            this.namespaceUri = input.NamespaceURI;
            this.name         = input.LocalName;
            this.prefix       = input.Prefix;
            this.empty        = input.IsEmptyTag;
            if (nodeType ==  XPathNodeType.Element) {
                this.htmlProps = HtmlElementProps.GetProps(this.name);
            }
            else if (nodeType ==  XPathNodeType.Attribute) {
                this.htmlProps = HtmlAttributeProps.GetProps(this.name);
            }
        }

        public override void ReplaceNamespaceAlias(Compiler compiler){
#if DEBUG
            Debug.Assert(! replaceNSAliasesDone, "Second attempt to replace NS aliases!. This bad.");
            replaceNSAliasesDone = true;
#endif
            if (this.nodeType == XPathNodeType.Attribute && this.namespaceUri.Length == 0) {
                return ; // '#default' aren't apply to attributes.
            }
            NamespaceInfo ResultURIInfo = compiler.FindNamespaceAlias(this.namespaceUri);
            if (ResultURIInfo != null) {
                this.namespaceUri = ResultURIInfo.nameSpace;
                if (ResultURIInfo.prefix != null) {
                    this.prefix = ResultURIInfo.prefix; 
                }
            }
        }
        
        public override bool Output(Processor processor, ActionFrame frame) {
            return processor.BeginEvent(this.nodeType, this.prefix, this.name, this.namespaceUri, this.empty, this.htmlProps, false);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\chooseaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="ChooseAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class ChooseAction : ContainerAction {
        internal override void Compile(Compiler compiler) {
            CompileAttributes(compiler);

            if (compiler.Recurse()) {
                CompileConditions(compiler);
                compiler.ToParent();
            }
        }

        private void CompileConditions(Compiler compiler) {
            NavigatorInput input = compiler.Input;
            bool when       = false;
            bool otherwise  = false;

            do {
                Debug.Trace(input);

                switch (input.NodeType) {
                case XPathNodeType.Element:
                    compiler.PushNamespaceScope();
                    string nspace = input.NamespaceURI;
                    string name   = input.LocalName;

                    if (Keywords.Equals(nspace, input.Atoms.XsltNamespace)) {
                        IfAction action = null;
                        if (Keywords.Equals(name, input.Atoms.When) && ! otherwise) {
                            action = compiler.CreateIfAction(IfAction.ConditionType.ConditionWhen);
                            when = true;
                        }
                        else if (Keywords.Equals(name, input.Atoms.Otherwise) && ! otherwise) {
                            action = compiler.CreateIfAction(IfAction.ConditionType.ConditionOtherwise);
                            otherwise = true;
                        }
                        else {
                            throw XsltException.UnexpectedKeyword(compiler);
                        }
                        AddAction(action);
                    }
                    else {
                        throw XsltException.UnexpectedKeyword(compiler);
                    }
                    compiler.PopScope();
                    break;

                case XPathNodeType.Comment:
                case XPathNodeType.ProcessingInstruction:
                case XPathNodeType.Whitespace:
                case XPathNodeType.SignificantWhitespace:
                    break;

                default:
                    throw new XsltException(Res.Xslt_InvalidContents, Keywords.s_Choose);
                }
            }
            while (compiler.Advance());
            if (! when) {
                throw new XsltException(Res.Xslt_NoWhen);
            }
        }

        internal override void Trace(int tab) {
            Debug.Indent(tab);
            Debug.WriteLine("<xsl:choose>");
            base.Trace(tab + 1);
            Debug.Indent(tab);
            Debug.WriteLine("</xsl:choose>");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\commentaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="CommentAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class CommentAction : ContainerAction {
        internal override void Compile(Compiler compiler) {
            CompileAttributes(compiler);

            if (compiler.Recurse()) {
                CompileTemplate(compiler);
                compiler.ToParent();
            }
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);

            switch (frame.State) {
            case Initialized:
                if (processor.BeginEvent(XPathNodeType.Comment, string.Empty, string.Empty, string.Empty, false) == false) {
                    // Come back later
                    break;
                }

                processor.PushActionFrame(frame);
                frame.State = ProcessingChildren;
                break;                              // Allow children to run

            case ProcessingChildren:
                if (processor.EndEvent(XPathNodeType.Comment) == false) {
                    Debug.WriteLine("Cannot end event, breaking, will restart");
                    break;
                }

                frame.Finished();
                break;

            default:
                Debug.Fail("Invalid IfAction execution state");
    		    break;
            }
        }

        internal override void Trace(int tab) {
            Debug.Indent(tab);
            Debug.WriteLine("<xsl:comment>");
            base.Trace(tab + 1);
            Debug.Indent(tab);
            Debug.WriteLine("</xsl:comment>");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\compiledaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="CompiledAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Xml;
    using System.Xml.XPath;

    internal abstract class CompiledAction : Action {
        internal abstract void Compile(Compiler compiler);

        internal virtual bool CompileAttribute(Compiler compiler) {
            return false;
        }
        
        public void CompileAttributes(Compiler compiler) {
            NavigatorInput input   = compiler.Input;
            string         element = input.LocalName;

            if (input.MoveToFirstAttribute()) {
                do {
                    Debug.TraceAttribute(input);

                    if (! Keywords.Equals(input.NamespaceURI, input.Atoms.Empty)) continue;

                    try {
                        if (CompileAttribute(compiler) == false) {
                            throw XsltException.InvalidAttribute(element, input.LocalName);
                        }
                    }catch(Exception) {
                        if (! compiler.ForwardCompatibility) {
                            throw;
                        }
                        else {
                            // In ForwardCompatibility mode we ignoreing all unknown or incorrect attributes
                            // If it's mandatory attribute we'l notice it absents later.
                        }
                    }
                }
                while (input.MoveToNextAttribute());
                input.ToParent();
            }
        }

        // For perf reason we precalculating AVTs at compile time.
        // If we can do this we set original AVT to null
        internal static string PrecalculateAvt(ref Avt avt) {
            string result = null;
            if(avt != null && avt.IsConstant) {
                result = avt.Evaluate(null, null);
                avt = null;
            }
            return result;
        }

        public void CheckEmpty(Compiler compiler) {
            // Really EMPTY means no content atall but for compatibility with MSXML we allow whitespace
            if (compiler.Recurse()) {
                do {
                    if(
                        compiler.Input.NodeType != XPathNodeType.Whitespace            &&
                        compiler.Input.NodeType != XPathNodeType.Comment               &&
                        compiler.Input.NodeType != XPathNodeType.ProcessingInstruction
                    ) {
                        compiler.ToParent();
                        throw new XsltException(Res.Xslt_EmptyTagRequired, compiler.Input.LocalName);
                    }
                }
                while (compiler.Advance());
                compiler.ToParent();
            }
        }

        public void CheckRequiredAttribute(Compiler compiler, object attrValue, string attrName) {
            // sdub: what about attrValue == string.Empty ?
            CheckRequiredAttribute(compiler, attrValue != null, attrName);
        }

        public void CheckRequiredAttribute(Compiler compiler, bool attr, string attrName) {
            // sdub: what about attrValue == string.Empty ?
            if (! attr) {
                throw new XsltException(Res.Xslt_MissingAttribute, attrName);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\containeraction.cs ===
//------------------------------------------------------------------------------
// <copyright file="ContainerAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Text;
    using System.Globalization;
    using System.Xml;
    using System.Xml.XPath;
    using System.Collections;

    internal class NamespaceInfo {
        internal String prefix;
        internal String nameSpace;
        internal int stylesheetId;

        internal NamespaceInfo(String prefix, String nameSpace, int stylesheetId) {
            this.prefix = prefix;
            this.nameSpace = nameSpace;
            this.stylesheetId = stylesheetId;
        }
    }
        
    internal class ContainerAction : CompiledAction {
        internal ArrayList      containedActions;
        internal CopyCodeAction lastCopyCodeAction; // non null if last action is CopyCodeAction;

        private  int  maxid = 0;
        
        // Local execution states
        protected const int ProcessingChildren = 1;

        internal override void Compile(Compiler compiler) {
            Debug.NotImplemented();
        }

        internal void CompileStylesheetAttributes(Compiler compiler) {
            NavigatorInput input        = compiler.Input;
            string         element      = input.LocalName;
            string         badAttribute = null;
            string         version      = null;
            
            if (input.MoveToFirstAttribute()) {
                do {
                    Debug.TraceAttribute(input);

                    string nspace = input.NamespaceURI;
                    string name   = input.LocalName;

                    if (! Keywords.Equals(nspace, input.Atoms.Empty)) continue;

                    Debug.WriteLine("Attribute name: \"" + name + "\"");
                    if (Keywords.Equals(name, input.Atoms.Version)) {
                        version = input.Value;
                        if (1 <= XmlConvert.ToXPathDouble(version)) {
                            compiler.ForwardCompatibility = (version != Keywords.s_Version10);
                        }
                        else {
                            // XmlConvert.ToXPathDouble(version) an be NaN!
                            if (! compiler.ForwardCompatibility) {
                                throw XsltException.InvalidAttrValue(Keywords.s_Version, version);
                            }
                        }
                        Debug.WriteLine("Version found: \"" + version + "\"");
                    }
                    else if (Keywords.Equals(name, input.Atoms.ExtensionElementPrefixes)) {
                        compiler.InsertExtensionNamespace(input.Value);
                    }
                    else if (Keywords.Equals(name, input.Atoms.ExcludeResultPrefixes)) {
                        compiler.InsertExcludedNamespace(input.Value);
                    }
                    else if (Keywords.Equals(name, input.Atoms.Id)) {
                        // Do nothing here.
                    }
                    else {
                        // We can have version atribute later. For now remember this attribute and continue
                        badAttribute = name;
                    }
                }
                while( input.MoveToNextAttribute());
                input.ToParent();
            }

            if (version == null) {
                throw new XsltException(Res.Xslt_MissingAttribute, Keywords.s_Version);
            }

            if (badAttribute != null && ! compiler.ForwardCompatibility) {
                throw XsltException.InvalidAttribute(element, badAttribute);
            }
        }

        internal void CompileSingleTemplate(Compiler compiler) {
            NavigatorInput input = compiler.Input;

            //
            // find mandatory version attribute and launch compilation of single template
            //

            string version = null;
            bool wrongns = false;
            
            if (input.MoveToFirstAttribute()) {
                do {
                    Debug.TraceAttribute(input);

                    string nspace = input.NamespaceURI;
                    string name   = input.LocalName;

                    if (Keywords.Equals(name, input.Atoms.Version)) {
                        if (Keywords.Equals(nspace, input.Atoms.XsltNamespace))
                            version = input.Value;                    
                        else
                            wrongns = true;
                    }
                }
                while(input.MoveToNextAttribute());
                input.ToParent();
            }

            if (version == null) {
                if (wrongns) {
                    throw new XsltException(Res.Xslt_WrongNamespace);
                }
                throw new XsltException(Res.Xslt_MissingAttribute, Keywords.s_Version);
            }

            Debug.TraceElement(input);

            compiler.AddTemplate(compiler.CreateSingleTemplateAction());
        }

        /*
         * CompileTopLevelElements
         */
        protected void CompileDocument(Compiler compiler, bool inInclude) {
            NavigatorInput input = compiler.Input;

            // SkipToElement :
            while (input.NodeType != XPathNodeType.Element) {
                if (! compiler.Advance()) {
                    throw new XsltException(Res.Xslt_WrongStylesheetElement);
                }
            }

            Debug.Assert(compiler.Input.NodeType == XPathNodeType.Element);
            if (Keywords.Equals(input.NamespaceURI, input.Atoms.XsltNamespace)) {
                if (
                    ! Keywords.Equals(input.LocalName, input.Atoms.Stylesheet) &&
                    ! Keywords.Equals(input.LocalName, input.Atoms.Transform)
                ) {
                    throw new XsltException(Res.Xslt_WrongStylesheetElement);
                }
                compiler.PushNamespaceScope();
                CompileStylesheetAttributes(compiler);
                CompileTopLevelElements(compiler);
                if (! inInclude) {
                    CompileImports(compiler);
                }
            }
            else {
                // single template
                compiler.PushLiteralScope();
                CompileSingleTemplate(compiler);
            }

            compiler.PopScope();
        }

        internal Stylesheet CompileImport(Compiler compiler, Uri uri, int id) {
            NavigatorInput input = compiler.ResolveDocument(uri);
            compiler.PushInputDocument(input, input.Href);

            try {
                compiler.PushStylesheet(new Stylesheet());
                compiler.Stylesheetid = id;
                CompileDocument(compiler, /*inInclude*/ false);
            }
            catch(Exception e) {
                throw new XsltCompileException(e, input.BaseURI, input.LineNumber, input.LinePosition);
            }
            finally {
                compiler.PopInputDocument();
            }
            return compiler.PopStylesheet();
        }

        private void CompileImports(Compiler compiler) {
            ArrayList imports = compiler.CompiledStylesheet.Imports;
            // We can't reverce imports order. Template lookup relyes on it after compilation
            int saveStylesheetId = compiler.Stylesheetid;
            for (int i = imports.Count - 1; 0 <= i; i --) {   // Imports should be compiled in reverse order
                Uri uri = imports[i] as Uri;
                Debug.Assert(uri != null);
                imports[i] = CompileImport(compiler, uri, ++ this.maxid);
            }
            compiler.Stylesheetid = saveStylesheetId;
        }

        void CompileInclude(Compiler compiler) {
            string href  = compiler.GetSingleAttribute(compiler.Input.Atoms.Href);
            Debug.WriteLine("Including document: + \"" + href + "\"");

            NavigatorInput input = compiler.ResolveDocument(href);
            compiler.PushInputDocument(input, input.Href);
            Debug.TraceElement(compiler.Input);

            try {
                // Bug.Bug. We have to push stilesheet here. Otherwise document("") will not work properly.
                // Not shure now. Probebly I fixed this problem in different place. Reinvestigate.
                CompileDocument(compiler, /*inInclude*/ true);
            }
            catch(Exception e) {
                throw new XsltCompileException(e, input.BaseURI, input.LineNumber, input.LinePosition);
            }
            finally {
                compiler.PopInputDocument();
            }
        }

        internal void CompileNamespaceAlias(Compiler compiler) {
            NavigatorInput input   = compiler.Input;
            string         element = input.LocalName;
            string namespace1 = null, namespace2 = null;
            string prefix1 = null   , prefix2 = null;
            if (input.MoveToFirstAttribute()) {
                do {
                    string nspace = input.NamespaceURI;
                    string name   = input.LocalName;

                    if (! Keywords.Equals(nspace, input.Atoms.Empty)) continue;

                    if (Keywords.Equals(name,input.Atoms.StylesheetPrefix)) {
                        prefix1    = input.Value;
                        namespace1 = compiler.GetNsAlias(ref prefix1);
                    }
                    else if (Keywords.Equals(name,input.Atoms.ResultPrefix)){ 
                        prefix2    = input.Value;
                        namespace2 = compiler.GetNsAlias(ref prefix2);
                    }
                    else {
                        if (! compiler.ForwardCompatibility) {
                             throw XsltException.InvalidAttribute(element, name);
                        }
                    }
                }
                while(input.MoveToNextAttribute());
                input.ToParent();
            }

            CheckRequiredAttribute(compiler, namespace1, Keywords.s_StylesheetPrefix);
            CheckRequiredAttribute(compiler, namespace2, Keywords.s_ResultPrefix    );

            //String[] resultarray = { prefix2, namespace2 };
            compiler.AddNamespaceAlias( namespace1, new NamespaceInfo(prefix2, namespace2, compiler.Stylesheetid));
        }
        
        internal void CompileKey(Compiler compiler){
            NavigatorInput input    = compiler.Input;
            string         element  = input.LocalName;
            int            MatchKey = Compiler.InvalidQueryKey;
            int            UseKey   = Compiler.InvalidQueryKey;

            XmlQualifiedName Name = null;
            if (input.MoveToFirstAttribute()) {
                do {
                    Debug.TraceAttribute(input);

                    string nspace = input.NamespaceURI;
                    string name   = input.LocalName;
                    string value  = input.Value;

                    if (! Keywords.Equals(nspace, input.Atoms.Empty)) continue;

					if (Keywords.Equals(name, input.Atoms.Name)) {
                        Name = compiler.CreateXPathQName(value);
                    }
                    else if (Keywords.Equals(name, input.Atoms.Match)) {
                        MatchKey = compiler.AddPatternQuery(value, /*allowVars:*/false, /*allowKey*/false);
                    }
                    else if (Keywords.Equals(name, input.Atoms.Use)) {
                        UseKey = compiler.AddQuery(value, /*allowVars:*/false, /*allowKey*/false);
                    }
                    else {
                        if (! compiler.ForwardCompatibility) {
                             throw XsltException.InvalidAttribute(element, name);
                        }
                    }
                }
                while(input.MoveToNextAttribute());
                input.ToParent();
            }

            CheckRequiredAttribute(compiler, MatchKey != Compiler.InvalidQueryKey, Keywords.s_Match);
            CheckRequiredAttribute(compiler, UseKey   != Compiler.InvalidQueryKey, Keywords.s_Use  );
            CheckRequiredAttribute(compiler, Name     != null                    , Keywords.s_Name );

            compiler.InsertKey(Name, MatchKey, UseKey);
        }

        protected void CompileDecimalFormat(Compiler compiler){
            NumberFormatInfo info   = new NumberFormatInfo();
            DecimalFormat    format = new DecimalFormat(info, '#', '0', ';');
            XmlQualifiedName  Name  = null;
            NavigatorInput   input  = compiler.Input;
            if (input.MoveToFirstAttribute()) {
                do {
                    Debug.TraceAttribute(input);

                    if (! Keywords.Equals(input.Prefix, input.Atoms.Empty)) continue;

                    string name   = input.LocalName;
                    string value  = input.Value;

                    if (Keywords.Equals(name, input.Atoms.Name)) {
                        Name = compiler.CreateXPathQName(value);
                    }
                    else if (Keywords.Equals(name, input.Atoms.DecimalSeparator)) {
                        info.NumberDecimalSeparator = value;
                    }
                    else if (Keywords.Equals(name, input.Atoms.GroupingSeparator)) {
                        info.NumberGroupSeparator = value;
                    }
                    else if (Keywords.Equals(name, input.Atoms.Infinity)) {
                        info.PositiveInfinitySymbol = value;
                    }
                    else if (Keywords.Equals(name, input.Atoms.MinusSign)) {
                        info.NegativeSign = value;
                    }
                    else if (Keywords.Equals(name, input.Atoms.NaN)) {
                        info.NaNSymbol = value;
                    }
                    else if (Keywords.Equals(name, input.Atoms.Percent)) {
                        info.PercentSymbol = value;
                    }
                    else if (Keywords.Equals(name, input.Atoms.PerMille)) {
                        info.PerMilleSymbol = value;
                    }
                    else if (Keywords.Equals(name, input.Atoms.Digit)) {
                        if (CheckAttribute(value.Length == 1, compiler)) {
                            format.digit = value[0];
                        }   
                    }
                    else if (Keywords.Equals(name, input.Atoms.ZeroDigit)) {
                        if (CheckAttribute(value.Length == 1, compiler)) {
                            format.zeroDigit = value[0];
                        }   
                    }
                    else if (Keywords.Equals(name, input.Atoms.PatternSeparator)) {
                        if (CheckAttribute(value.Length == 1, compiler)) {
                            format.patternSeparator = value[0];
                        }   
                    }
                }
                while(input.MoveToNextAttribute());
                info.NegativeInfinitySymbol = String.Concat(info.NegativeSign, info.PositiveInfinitySymbol);
                if (Name == null) {
                    Name = new XmlQualifiedName(null, null);
                }
                compiler.AddDecimalFormat(Name, format);
                input.ToParent();
            }
        }

        internal bool CheckAttribute(bool valid, Compiler compiler) {
            if (! valid) {
                if (! compiler.ForwardCompatibility) {
                    throw XsltException.InvalidAttrValue(compiler.Input.LocalName, compiler.Input.Value);
                }
                return false;
            }
            return true;
        }

        protected void CompileSpace(Compiler compiler, bool preserve){
            String value = compiler.GetSingleAttribute(compiler.Input.Atoms.Elements);
            String[] elements = Compiler.SplitString(value);
            for(int i = 0; i < elements.Length ; i++ ){
                NameTest(elements[i], compiler);
                AstNode node = AstNode.NewAstNode(elements[i]);
                compiler.CompiledStylesheet.AddSpace(compiler, elements[i], node.DefaultPriority, preserve);
            }
        }

        void NameTest(String name, Compiler compiler){
            if (name == "*")
                return;
            if (name.EndsWith(":*")){
                if(! PrefixQName.ValidatePrefix(name.Substring(0, name.Length -3)))  {
                    throw XsltException.InvalidAttrValue(compiler.Input.LocalName, name);
                }
            }
            else {
                string prefix, localname;
                PrefixQName.ParseQualifiedName(name, out prefix, out localname);
            }
        }
        
        protected void CompileTopLevelElements(Compiler compiler) {
            // Navigator positioned at parent root, need to move to child and then back
            if (compiler.Recurse() == false) {
                Debug.WriteLine("Nothing to compile, exiting");
                return;
            }

            NavigatorInput input    = compiler.Input;
            bool notFirstElement    = false;
            do {
                Debug.Trace(input);
                switch (input.NodeType) {
                case XPathNodeType.Element:
                    string name   = input.LocalName;
                    string nspace = input.NamespaceURI;

                    if (Keywords.Equals(nspace, input.Atoms.XsltNamespace)) {
                        if (Keywords.Equals(name, input.Atoms.Import)) {
                            if (notFirstElement) {
                                throw new XsltException(Res.Xslt_NotFirstImport);
                            }
                            // We should compile imports in reverse order after all toplevel elements.
                            // remember it now and return to it in CompileImpoorts();
                            compiler.CompiledStylesheet.Imports.Add(compiler.ResolveUri(compiler.GetSingleAttribute(compiler.Input.Atoms.Href)));
                        }
                        else if (Keywords.Equals(name, input.Atoms.Include)) {
                            notFirstElement = true;                     
                            CompileInclude(compiler);
                        }
                        else {
                            notFirstElement = true;
                            compiler.PushNamespaceScope();
                            if (Keywords.Equals(name, input.Atoms.StripSpace)) {
                                CompileSpace(compiler, false);
                            }
                            else if (Keywords.Equals(name, input.Atoms.PreserveSpace)) {
                                CompileSpace(compiler, true);
                            }
                            else if (Keywords.Equals(name, input.Atoms.Output)) {
                                CompileOutput(compiler);
                            }
                            else if (Keywords.Equals(name, input.Atoms.Key)) {
                                CompileKey(compiler);
                            }
                            else if (Keywords.Equals(name, input.Atoms.DecimalFormat)) {
                                CompileDecimalFormat(compiler);
                            }
                            else if (Keywords.Equals(name, input.Atoms.NamespaceAlias)) {
                                CompileNamespaceAlias(compiler);
                            }
                            else if (Keywords.Equals(name, input.Atoms.AttributeSet)) {
                                compiler.AddAttributeSet(compiler.CreateAttributeSetAction());
                            }
                            else if (Keywords.Equals(name, input.Atoms.Variable)) {
                                VariableAction action = compiler.CreateVariableAction(VariableType.GlobalVariable);
                                if (action != null) {
                                    AddAction(action);
                                }
                            }
                            else if (Keywords.Equals(name, input.Atoms.Param)) {
                                VariableAction action = compiler.CreateVariableAction(VariableType.GlobalParameter);
                                if (action != null) {
                                    AddAction(action);
                                }
                            }
                            else if (Keywords.Equals(name, input.Atoms.Template)) {
                                compiler.AddTemplate(compiler.CreateTemplateAction());
                            }
                            else {
                                if (!compiler.ForwardCompatibility) {
                                    throw XsltException.UnexpectedKeyword(compiler);
                                }
                            }
                            compiler.PopScope();
                        }
                    }
                    else if (nspace == input.Atoms.MsXsltNamespace && name == input.Atoms.Script) {
                        AddScript(compiler);
                    }
                    else {
                        if (Keywords.Equals(nspace, input.Atoms.Empty)) {
                            throw new XsltException(Res.Xslt_NullNsAtTopLevel, input.Name);
                        }
                        // Ignoring non-recognized namespace per XSLT spec 2.2
                    }
                    break;

                case XPathNodeType.ProcessingInstruction:
                case XPathNodeType.Comment:
                case XPathNodeType.Whitespace:
                case XPathNodeType.SignificantWhitespace:
                    break;

                default:
                    throw new XsltException(Res.Xslt_InvalidContents, "xsl:stylesheet");
                }
            }
            while (compiler.Advance());

            compiler.ToParent();
        }
        
        protected void CompileTemplate(Compiler compiler) {
            do {
                CompileOnceTemplate(compiler);
            }
            while (compiler.Advance());
        }

        protected void CompileOnceTemplate(Compiler compiler) {
            NavigatorInput input = compiler.Input;

            Debug.Trace(input);
            if (input.NodeType == XPathNodeType.Element) {
                string nspace = input.NamespaceURI;

                if (Keywords.Equals(nspace, input.Atoms.XsltNamespace)) {
                    compiler.PushNamespaceScope();
                    CompileInstruction(compiler);
                    compiler.PopScope();
                }
                else {
                    compiler.PushLiteralScope();
                    compiler.InsertExtensionNamespace();
                    if (compiler.IsExtensionNamespace(nspace)) {
                        AddAction(compiler.CreateNewInstructionAction()); 
                    }
                    else {
                        CompileLiteral(compiler);
                    }
                    compiler.PopScope();
                    
                }
            }
            else {
                CompileLiteral(compiler);
            }
        }

        void CompileInstruction(Compiler compiler) {
            NavigatorInput input  = compiler.Input;
            CompiledAction action = null;

            Debug.Assert(Keywords.Equals(input.NamespaceURI, input.Atoms.XsltNamespace));

            string name = input.LocalName;

            if (Keywords.Equals(name, input.Atoms.ApplyImports)) {
                action = compiler.CreateApplyImportsAction();
            }
            else if (Keywords.Equals(name, input.Atoms.ApplyTemplates)) {
                action = compiler.CreateApplyTemplatesAction();
            }
            else if (Keywords.Equals(name, input.Atoms.Attribute)) {
                action = compiler.CreateAttributeAction();
            }
            else if (Keywords.Equals(name, input.Atoms.CallTemplate)) {
                action = compiler.CreateCallTemplateAction();
            }
            else if (Keywords.Equals(name, input.Atoms.Choose)) {
                action = compiler.CreateChooseAction();
            }
            else if (Keywords.Equals(name, input.Atoms.Comment)) {
                action = compiler.CreateCommentAction();
            }
            else if (Keywords.Equals(name, input.Atoms.Copy)) {
                action = compiler.CreateCopyAction();
            }
            else if (Keywords.Equals(name, input.Atoms.CopyOf)) {
                action = compiler.CreateCopyOfAction();
            }
            else if (Keywords.Equals(name, input.Atoms.Element)) {
                action = compiler.CreateElementAction();
            }
            else if (Keywords.Equals(name, input.Atoms.Fallback)) {
                return;
            }
            else if (Keywords.Equals(name, input.Atoms.ForEach)) {
                action = compiler.CreateForEachAction();
            }
            else if (Keywords.Equals(name, input.Atoms.If)) {
                action = compiler.CreateIfAction(IfAction.ConditionType.ConditionIf);
            }
            else if (Keywords.Equals(name, input.Atoms.Message)) {
                action = compiler.CreateMessageAction();
            }
            else if (Keywords.Equals(name, input.Atoms.Number)) {
                action = compiler.CreateNumberAction();
            }
            else if (Keywords.Equals(name, input.Atoms.ProcessingInstruction)) {
                action = compiler.CreateProcessingInstructionAction();
            }
            else if (Keywords.Equals(name, input.Atoms.Text)) {
                action = compiler.CreateTextAction();
            }
            else if (Keywords.Equals(name, input.Atoms.ValueOf)) {
                action = compiler.CreateValueOfAction();
            }
            else if (Keywords.Equals(name, input.Atoms.Variable)) {
                action = compiler.CreateVariableAction(VariableType.LocalVariable);
            }
            else {
                if (compiler.ForwardCompatibility)
                    action = compiler.CreateNewInstructionAction();
                else
                    throw XsltException.UnexpectedKeyword(compiler);
            }

            Debug.Assert(action != null);

            AddAction(action);
        }

        void CompileLiteral(Compiler compiler) {
            NavigatorInput input = compiler.Input;
            
            Debug.WriteLine("Node type: \"" + (int) input.NodeType + "\"");
            Debug.WriteLine("Node name: \"" + input.LocalName + "\"");

            switch (input.NodeType) {
            case XPathNodeType.Element:
                Debug.TraceElement(input);

                this.AddEvent(compiler.CreateBeginEvent());
                CompileLiteralAttributesAndNamespaces(compiler);

                if (compiler.Recurse()) {
                    CompileTemplate(compiler);
                    compiler.ToParent();
                }

                this.AddEvent(new EndEvent(XPathNodeType.Element));
                break;

            case XPathNodeType.Text:
            case XPathNodeType.SignificantWhitespace:
                this.AddEvent(compiler.CreateTextEvent());
                break;
            case XPathNodeType.Whitespace:
            case XPathNodeType.ProcessingInstruction:
            case XPathNodeType.Comment:
                break;

            default:
                Debug.Assert(false, "Unexpected node type.");
                break;
            }
        }
        
        void CompileLiteralAttributesAndNamespaces(Compiler compiler) {
            NavigatorInput input = compiler.Input;

            if (input.Navigator.MoveToAttribute(Keywords.s_UseAttributeSets, input.Atoms.XsltNamespace)) {
                AddAction(compiler.CreateUseAttributeSetsAction());
                input.Navigator.MoveToParent();
            }
            compiler.InsertExcludedNamespace();

            if (input.MoveToFirstNamespace()) {
                do {
                    string uri = input.Value;

                    if (Keywords.Compare(uri, input.Atoms.XsltNamespace)) {
                        continue;
                    }
                    if ( 
                        compiler.IsExcludedNamespace(uri) ||
                        compiler.IsExtensionNamespace(uri) ||
                        compiler.IsNamespaceAlias(uri)
                    ) {
                            continue;
                    }
                    this.AddEvent(new NamespaceEvent(input));
                }
                while (input.MoveToNextNamespace());
                input.ToParent();
            }

            if (input.MoveToFirstAttribute()) {
                do {

                    // Skip everything from Xslt namespace
                    if (Keywords.Equals(input.NamespaceURI, input.Atoms.XsltNamespace)) {
                        continue;
                    }

                    // Add attribute events
                    this.AddEvent (compiler.CreateBeginEvent());
                    this.AddEvents(compiler.CompileAvt(input.Value));
                    this.AddEvent (new EndEvent(XPathNodeType.Attribute));
                }
                while (input.MoveToNextAttribute());
                input.ToParent();
            }
        }

        void CompileOutput(Compiler compiler) {
            Debug.Assert((object) this == (object) compiler.RootAction);
            compiler.RootAction.Output.Compile(compiler);
        }

        internal void AddAction(Action action) {
            if (this.containedActions == null) {
                this.containedActions = new ArrayList();
            }
            this.containedActions.Add(action);
            lastCopyCodeAction = null;
        }

        private void EnsureCopyCodeAction() {
            if(lastCopyCodeAction == null) {
                CopyCodeAction copyCode = new CopyCodeAction();
                AddAction(copyCode);
                lastCopyCodeAction = copyCode;
            }
        }

        protected void AddEvent(Event copyEvent) {
            EnsureCopyCodeAction();
            lastCopyCodeAction.AddEvent(copyEvent);
        }

        protected void AddEvents(ArrayList copyEvents) {
            EnsureCopyCodeAction();
            lastCopyCodeAction.AddEvents(copyEvents);
        }

        private void AddScript(Compiler compiler) {
            NavigatorInput input = compiler.Input;

            ScriptingLanguage lang = ScriptingLanguage.JScript; 
            string implementsNamespace = null; 
            if (input.MoveToFirstAttribute()) {
                do {
                    if (input.LocalName == input.Atoms.Language) {
                        string langName = input.Value.ToLower(CultureInfo.InvariantCulture);   // Case insensetive !
                        if (langName == "jscript" || langName == "javascript") {
                            lang = ScriptingLanguage.JScript;
                        }
                        else if (langName == "vb" || langName == "visualbasic") {
                            lang = ScriptingLanguage.VisualBasic;
                        }
                        else if (langName == "c#" || langName == "csharp") {
                            lang = ScriptingLanguage.CSharp;
                        }
                        else {
                            throw new XsltException(Res.Xslt_ScriptInvalidLang, langName);
                        }
                    } 
                    else if (input.LocalName == input.Atoms.ImplementsPrefix) {
                        if(! PrefixQName.ValidatePrefix(input.Value))  {
                            throw XsltException.InvalidAttrValue(input.LocalName, input.Value);
                        }
                        implementsNamespace = compiler.ResolveXmlNamespace(input.Value);
                    }
                }
                while (input.MoveToNextAttribute());
                input.ToParent();
            }
            if (implementsNamespace == null) {
                throw new XsltException(Res.Xslt_MissingAttribute, input.Atoms.ImplementsPrefix);
            }
            if (!input.Recurse() || input.NodeType != XPathNodeType.Text) {
                throw new XsltException(Res.Xslt_ScriptEmpty);
            }
            compiler.AddScript(input.Value, lang, implementsNamespace, input.BaseURI, input.LineNumber);
            input.ToParent();
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);

            switch (frame.State) {
            case Initialized:
                if (this.containedActions != null && this.containedActions.Count > 0) {
                    processor.PushActionFrame(frame);
                    frame.State = ProcessingChildren;
                }        
                else {
                    frame.Finished();
                }
                break;                              // Allow children to run

            case ProcessingChildren:
                frame.Finished();
                break;

            default:
                Debug.Fail("Invalid Container action execution state");
                break;
            }
        }

        internal Action GetAction(int actionIndex) {
            Debug.Assert(actionIndex == 0 || this.containedActions != null);

            if (this.containedActions != null && actionIndex < this.containedActions.Count) {
                return (Action) this.containedActions[actionIndex];
            }
            else {
                return null;
            }
        }
        
        internal void CheckDuplicateParams(XmlQualifiedName name) {
            if (this.containedActions != null) {
                foreach(CompiledAction action in this.containedActions) {
                    WithParamAction param = action as WithParamAction;
                    if (param != null && param.Name == name) {
                        throw new XsltException(Res.Xslt_DuplicateParametr, name.ToString());                        
                    }
                }
            }
        }
        
        internal override void ReplaceNamespaceAlias(Compiler compiler){
            if (this.containedActions == null) {
                return;
            }
            int count = this.containedActions.Count;
            for(int i= 0; i < this.containedActions.Count; i++) {
                ((Action)this.containedActions[i]).ReplaceNamespaceAlias(compiler);
            }
        }

        internal override void Trace(int tab) {
            if (this.containedActions == null)
                return;

            for (int actionIndex = 0; actionIndex < this.containedActions.Count; actionIndex ++) {
                Action action = (Action) this.containedActions[actionIndex];
                action.Trace(tab + 1);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\calltemplateaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="CallTemplateAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {

    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class CallTemplateAction : ContainerAction {
        private const int        ProcessedChildren = 2;
        private const int        ProcessedTemplate = 3;
        private XmlQualifiedName name;
        
        internal XmlQualifiedName Name {
            get { return this.name; }
        }

        internal override void Compile(Compiler compiler) {
            CompileAttributes(compiler);
            CheckRequiredAttribute(compiler, this.name, Keywords.s_Name);
            CompileContent(compiler);
        }

        internal override bool CompileAttribute(Compiler compiler) {
            string name   = compiler.Input.LocalName;
            string value  = compiler.Input.Value;
            if (Keywords.Equals(name, compiler.Atoms.Name)) {
                Debug.Assert(this.name == null);
                this.name = compiler.CreateXPathQName(value);
                Debug.WriteLine("Name attribute found: " + this.name);
            }
            else {
                return false;
            }

            return true;
        }

        private void CompileContent(Compiler compiler) {
            NavigatorInput input = compiler.Input;
            
            if (compiler.Recurse()) {
                do {
                    Debug.Trace(input);
                    switch(input.NodeType) {
                    case XPathNodeType.Element:
                        compiler.PushNamespaceScope();
                        string nspace = input.NamespaceURI;
                        string name   = input.LocalName;

                        if (Keywords.Equals(nspace, input.Atoms.XsltNamespace) && Keywords.Equals(name, input.Atoms.WithParam)) {
                                WithParamAction par = compiler.CreateWithParamAction();
                                CheckDuplicateParams(par.Name);
                                AddAction(par);
                        }
                        else {
                            throw XsltException.UnexpectedKeyword(compiler);
                        }
                        compiler.PopScope();
                        break;
                    case XPathNodeType.Comment:
                    case XPathNodeType.ProcessingInstruction:
                    case XPathNodeType.Whitespace:
                    case XPathNodeType.SignificantWhitespace:
                        break;
                    default:
                        throw new XsltException(Res.Xslt_InvalidContents, Keywords.s_CallTemplate);
                    }
                } while(compiler.Advance());

                compiler.ToParent();
            }
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);
            switch(frame.State) {
            case Initialized : 
                processor.ResetParams();
                if (this.containedActions != null && this.containedActions.Count > 0) {
                    processor.PushActionFrame(frame);
                    frame.State = ProcessedChildren;
                    break;
                }
                goto case ProcessedChildren;
            case ProcessedChildren:
                TemplateAction action = processor.Stylesheet.FindTemplate(this.name);
                if (action != null) { 
                    frame.State = ProcessedTemplate;
                    processor.PushActionFrame(action, frame.NodeSet);
                    break;
                }
                else {
                    throw new XsltException(Res.Xslt_InvalidCallTemplate, this.name.ToString());
                }
            case ProcessedTemplate:
                frame.Finished();
                break;
            default:
                Debug.Fail("Invalid CallTemplateAction execution state");
                break;
            }
        }

        internal override void Trace(int tab) {
            Debug.Indent(tab);
            Debug.WriteLine("<xsl:call-template name=\"" + this.name + "\"/>");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\copycodeaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="CopyCodeAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;
    using System.Collections;

    internal class CopyCodeAction : Action {
        // Execution states:
        private const int Outputting = 2;
        
        private ArrayList copyEvents;   // Copy code action events

        internal ArrayList CopyEvents {
            get { return this.copyEvents; }
        }

        internal CopyCodeAction() {
            this.copyEvents = new ArrayList();
        }

        internal void AddEvent(Event copyEvent) {
            this.copyEvents.Add(copyEvent);
        }

        internal void AddEvents(ArrayList copyEvents) {
            Debug.Assert(copyEvents != null);
            this.copyEvents.AddRange(copyEvents);
        }

        internal override void ReplaceNamespaceAlias(Compiler compiler) {
            int count = this.copyEvents.Count;
            for(int i = 0; i< count; i++) {
                ((Event) this.copyEvents[i]).ReplaceNamespaceAlias(compiler);
            }
        }
        
        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);
            Debug.Assert(this.copyEvents != null && this.copyEvents.Count > 0);

            switch (frame.State) {
            case Initialized:
                frame.Counter = 0;
                frame.State   = Outputting;
                goto case Outputting;

            case Outputting:
                Debug.Assert(frame.State == Outputting);

                while (processor.CanContinue) {
                    Debug.Assert(frame.Counter < this.copyEvents.Count);
                    Event copyEvent = (Event) this.copyEvents[frame.Counter];

                    if (copyEvent.Output(processor, frame) == false) {
                        // This event wasn't processed
                        break;
                    }

                    if (frame.IncrementCounter() >= this.copyEvents.Count) {
                        frame.Finished();
                        break;
                    }
                }
                break;
            default:
                Debug.Fail("Invalid CopyCodeAction execution state");
                break;
            }
        }

        internal override void Trace(int tab) { }

        internal override DbgData GetDbgData(ActionFrame frame) {
            Debug.Assert(frame.Counter < this.copyEvents.Count);
            return ((Event)this.copyEvents[frame.Counter]).DbgData;        
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\copynamespacesaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="CopyNamespacesAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------



namespace System.Xml.Xsl {

    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal sealed class CopyNamespacesAction : Action {
        private const int BeginEvent    = 2;
        private const int TextEvent     = 3;
        private const int EndEvent      = 4;
        private const int Advance       = 5;

        private static CopyNamespacesAction s_Action = new CopyNamespacesAction();

        internal static CopyNamespacesAction GetAction() {
            Debug.Assert(s_Action != null);
            return s_Action;
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);

            while (processor.CanContinue) {
                switch (frame.State) {
                case Initialized:
                    if (frame.Node.MoveToFirstNamespace(XPathNamespaceScope.ExcludeXml) == false) {
                        frame.Finished();
                        break;
                    }

                    frame.State   = BeginEvent;
                    goto case BeginEvent;

                case BeginEvent:
                    Debug.Assert(frame.State == BeginEvent);
                    Debug.Assert(frame.Node.NodeType == XPathNodeType.Namespace);

                    if (processor.BeginEvent(XPathNodeType.Namespace, null, frame.Node.LocalName, frame.Node.Value, false) == false) {
                        // This one wasn't output
                        break;
                    }
                    frame.State = EndEvent;
                    continue;

                case EndEvent:
                    Debug.Assert(frame.State == EndEvent);
                    Debug.Assert(frame.Node.NodeType == XPathNodeType.Namespace);

                    if (processor.EndEvent(XPathNodeType.Namespace) == false) {
                        // This one wasn't output
                        break;
                    }
                    frame.State = Advance;
                    continue;

                case Advance:
                    Debug.Assert(frame.State == Advance);
                    Debug.Assert(frame.Node.NodeType == XPathNodeType.Namespace);

                    if (frame.Node.MoveToNextNamespace(XPathNamespaceScope.ExcludeXml)) {
                        frame.State = BeginEvent;
                        continue;
                    }
                    else {
                        frame.Node.MoveToParent();
                        frame.Finished();
                        break;
                    }
                }
                break;
            }// while
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\copynodesetaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="CopyNodeSetAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal sealed class CopyNodeSetAction : Action {
        private const int BeginEvent    = 2;
        private const int Contents      = 3;
        private const int Namespaces    = 4;
        private const int Attributes    = 5;
        private const int Subtree       = 6;
        private const int EndEvent      = 7;

        private static CopyNodeSetAction s_Action = new CopyNodeSetAction();

        internal static CopyNodeSetAction GetAction() {
            Debug.Assert(s_Action != null);
            return s_Action;
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);
            while (processor.CanContinue) {
                switch (frame.State) {
                case Initialized:
                    if (frame.NextNode(processor)) {
                        Debug.WriteLine("Next node to copy found");
                        Debug.WriteLine(frame.Node.Name);
                        frame.State = BeginEvent;
                        goto case BeginEvent;
                    }
                    else {
                        frame.Finished();
                        break;
                    }
                case BeginEvent:
                    Debug.Assert(frame.State == BeginEvent);

                    if (SendBeginEvent(processor, frame.Node) == false) {
                        // This one wasn't output
                        break;
                    }
                    frame.State = Contents;
                    continue;

                case Contents:
                    Debug.Assert(frame.State == Contents);
                    XPathNodeType nodeType = frame.Node.NodeType;

                    if (nodeType == XPathNodeType.Element || nodeType == XPathNodeType.Root) {
                        processor.PushActionFrame(CopyNamespacesAction.GetAction(), frame.NodeSet);
                        frame.State = Namespaces;
                        break;
                    }

                    if (SendTextEvent(processor, frame.Node) == false) {
                        // This one wasn't output
                        break;
                    }
                    frame.State = EndEvent;
                    continue;

                case Namespaces:
                    processor.PushActionFrame(CopyAttributesAction.GetAction(), frame.NodeSet);
                    frame.State = Attributes;
                    break;

                case Attributes:
                    if (frame.Node.HasChildren) {
                        processor.PushActionFrame(GetAction(), frame.Node.SelectChildren(XPathNodeType.All));
                        frame.State = Subtree;
                        break;
                    }
                    frame.State = EndEvent;
                    goto case EndEvent;

                case Subtree:
                    //frame.Node.MoveToParent();
                    frame.State = EndEvent;
                    continue;

                case EndEvent:
                    Debug.Assert(frame.State == EndEvent);

                    if (SendEndEvent(processor, frame.Node) == false) {
                        // This one wasn't output
                        break;
                    }

                    frame.State = Initialized;
                    continue;
                }

                break;
            }
        }

        private static bool SendBeginEvent(Processor processor, XPathNavigator node) {
            return processor.CopyBeginEvent(node, node.IsEmptyElement);
        }

        private static bool SendTextEvent(Processor processor, XPathNavigator node) {
            return processor.CopyTextEvent(node);
        }

        private static bool SendEndEvent(Processor processor, XPathNavigator node) {
            return processor.CopyEndEvent(node);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\copyofaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="CopyOfAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class CopyOfAction : CompiledAction {
        private const int ResultStored  = 2;
        private const int NodeSetCopied = 3;

        private string select;
        private int    selectKey   = Compiler.InvalidQueryKey;

        internal override void Compile(Compiler compiler) {
            CompileAttributes(compiler);
            CheckRequiredAttribute(compiler, this.select, Keywords.s_Select);
            CheckEmpty(compiler);
        }

        internal override String Select {
            get { return this.select; }
        }
        
        internal override bool CompileAttribute(Compiler compiler) {
            string name   = compiler.Input.LocalName;
            string value  = compiler.Input.Value;
            if (Keywords.Equals(name, compiler.Atoms.Select)) {
                this.select    = value;
                this.selectKey = compiler.AddQuery(this.select);
                Debug.WriteLine("Select expression == \"" + this.select + "\" + (#" + this.selectKey + ")");
            }
            else {
                return false;
            }

            return true;
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);

            switch (frame.State) {
            case Initialized:
                Debug.Assert(frame.NodeSet != null);
                Debug.Assert(this.selectKey != Compiler.InvalidQueryKey);
                XPathExpression expr = processor.GetValueQuery(this.selectKey);
                object result = frame.Node.Evaluate(expr);

                XPathNodeIterator nodeSet = result as XPathNodeIterator;
                if (nodeSet != null) {
                    processor.PushActionFrame(CopyNodeSetAction.GetAction(), nodeSet);
                    frame.State = NodeSetCopied;
                    break;
                }

                XPathNavigator nav = result as XPathNavigator;
                if (nav != null) {
                    processor.PushActionFrame(CopyNodeSetAction.GetAction(), new XPathSingletonIterator(nav));
                    frame.State = NodeSetCopied;
                    break; 
                }

                string value = XmlConvert.ToXPathString(result);
                if (processor.TextEvent(value)) {
                    frame.Finished();
                }
                else {
                    frame.StoredOutput = value;
                    frame.State        = ResultStored;
                }
                break;

            case ResultStored:
                Debug.Assert(frame.StoredOutput != null);
                processor.TextEvent(frame.StoredOutput);
                frame.Finished();
                break;

            case NodeSetCopied:
                Debug.Assert(frame.State == NodeSetCopied);
                frame.Finished();
                break;
            }
        }

        internal override void Trace(int tab) {
            Debug.Indent(tab);
            Debug.WriteLine("<xsl:copy-of select=\"" + this.select + "(#" + this.selectKey + ")/>");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\copyaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="CopyAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {

    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class CopyAction : ContainerAction {
        // Local execution states
        private const int CopyText          = 4;
        private const int NamespaceCopy     = 5;

        private const int ContentsCopy      = 6;
        private const int ProcessChildren   = 7;
        private const int ChildrenOnly      = 8;

        private string useAttributeSets;
        private bool   empty;

        internal override void Compile(Compiler compiler) {
            CompileAttributes(compiler);

            if (compiler.Recurse()) {
                CompileTemplate(compiler);
                compiler.ToParent();
            }
            if (this.containedActions == null)
                this.empty = true;
                
        }

        internal override bool CompileAttribute(Compiler compiler) {
            string name   = compiler.Input.LocalName;
            string value  = compiler.Input.Value;
            if (Keywords.Equals(name, compiler.Atoms.UseAttributeSets)) {
                this.useAttributeSets = value;
                AddAction(compiler.CreateUseAttributeSetsAction());
                Debug.WriteLine("UseAttributeSets = \"" + this.useAttributeSets + "\"");
            }
            else {
                return false;
            }
            return true;
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);

            while (processor.CanContinue) {
                switch (frame.State) {
                case Initialized:
                    if (Processor.IsRoot(frame.Node)) {
                        processor.PushActionFrame(frame);
                        frame.State = ChildrenOnly;
                        break;
                    }

                    if (processor.CopyBeginEvent(frame.Node, this.empty) == false) {
                        // This event wasn't processed
                        break;
                    }
                    frame.State = NamespaceCopy;
                 
                    continue;
                case NamespaceCopy:
                    frame.State = ContentsCopy;
                    if ( frame.Node.NodeType == XPathNodeType.Element ) {
                        processor.PushActionFrame(CopyNamespacesAction.GetAction(), frame.NodeSet);
                        break;
                    }
                    continue;
                case ContentsCopy:
                    if (frame.Node.NodeType == XPathNodeType.Element && !this.empty) {
                        //Debug.Assert(frame.Node.HasValue == false);
                        processor.PushActionFrame(frame);
                        frame.State = ProcessChildren;
                        break;
                    }
                    else {
                        if (processor.CopyTextEvent(frame.Node)) {
                            frame.State = ProcessChildren;
                            continue;
                        }
                        else {
                            // This event wasn't processed
                            break;
                        }
                    }

                case ProcessChildren:
                    if (processor.CopyEndEvent(frame.Node)) {
                        frame.Finished();
                    }
                    break;

                case ChildrenOnly:
                    frame.Finished();
                    break;

                default:
                    Debug.Fail("Invalid CopyAction execution state");
			        break;
                }

                break;
            }
        }

        internal override void Trace(int tab) {
            Debug.Indent(tab);
            Debug.WriteLine("<xsl:copy use-attribute-sets=\"" + this.useAttributeSets + "\">");
            base.Trace(tab);
            Debug.Indent(tab);
            Debug.WriteLine("</xsl:copy>");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\copyattributesaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="CopyAttributesAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal sealed class CopyAttributesAction : Action {
        private const int BeginEvent    = 2;
        private const int TextEvent     = 3;
        private const int EndEvent      = 4;
        private const int Advance       = 5;

        private static CopyAttributesAction s_Action = new CopyAttributesAction();

        internal static CopyAttributesAction GetAction() {
            Debug.Assert(s_Action != null);
            return s_Action;
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);

            while (processor.CanContinue) {
                switch (frame.State) {
                case Initialized:
                    if (!frame.Node.HasAttributes || frame.Node.MoveToFirstAttribute() == false) {
                        frame.Finished();
                        break;
                    }

                    frame.State   = BeginEvent;
                    goto case BeginEvent;

                case BeginEvent:
                    Debug.Assert(frame.State == BeginEvent);
                    Debug.Assert(frame.Node.NodeType == XPathNodeType.Attribute);

                    if (SendBeginEvent(processor, frame.Node) == false) {
                        // This one wasn't output
                        break;
                    }
                    frame.State = TextEvent;
                    continue;

                case TextEvent:
                    Debug.Assert(frame.State == TextEvent);
                    Debug.Assert(frame.Node.NodeType == XPathNodeType.Attribute);

                    if (SendTextEvent(processor, frame.Node) == false) {
                        // This one wasn't output
                        break;
                    }
                    frame.State = EndEvent;
                    continue;

                case EndEvent:
                    Debug.Assert(frame.State == EndEvent);
                    Debug.Assert(frame.Node.NodeType == XPathNodeType.Attribute);

                    if (SendEndEvent(processor, frame.Node) == false) {
                        // This one wasn't output
                        break;
                    }
                    frame.State = Advance;
                    continue;

                case Advance:
                    Debug.Assert(frame.State == Advance);
                    Debug.Assert(frame.Node.NodeType == XPathNodeType.Attribute);

                    if (frame.Node.MoveToNextAttribute()) {
                        frame.State = BeginEvent;
                        continue;
                    }
                    else {
                        frame.Node.MoveToParent();
                        frame.Finished();
                        break;
                    }
                }
                break;
            }// while (processor.CanContinue)
        }

        private static bool SendBeginEvent(Processor processor, XPathNavigator node) {
            Debug.Assert(node.NodeType == XPathNodeType.Attribute);
            return processor.BeginEvent(XPathNodeType.Attribute, node.Prefix, node.LocalName, node.NamespaceURI, false);
        }

        private static bool SendTextEvent(Processor processor, XPathNavigator node) {
            Debug.Assert(node.NodeType == XPathNodeType.Attribute);
            return processor.TextEvent(node.Value);
        }

        private static bool SendEndEvent(Processor processor, XPathNavigator node) {
            Debug.Assert(node.NodeType == XPathNodeType.Attribute);
            return processor.EndEvent(XPathNodeType.Attribute);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\dbgcompiler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DbgCompiler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Collections;
    using System.Xml;
    using System.Xml.XPath;
    using System.Xml.Xsl.Debugger;
    using System.Diagnostics;

    internal class DbgData {
        private XPathNavigator   styleSheet;
        private VariableAction[] variables;
        public XPathNavigator   StyleSheet { get { return this.styleSheet; } }
        public VariableAction[] Variables  { get { return this.variables;  } }
        public DbgData(Compiler compiler) {
            DbgCompiler dbgCompiler = (DbgCompiler) compiler;
            this.styleSheet = dbgCompiler.Input.Navigator.Clone();
            this.variables  = dbgCompiler.LocalVariables;
            dbgCompiler.Debugger.OnInstructionCompile(this.StyleSheet);
        }
        internal void ReplaceVariables(VariableAction[] vars) { this.variables = vars; }

        // static Empty:
        private static DbgData s_nullDbgData = new DbgData();
        private DbgData() {
            this.styleSheet = null;
            this.variables  = new VariableAction[0];
        }
        public static DbgData Empty { get { return s_nullDbgData; } }
    }

    internal class DbgCompiler : Compiler {
        private IXsltDebugger debugger;

        public DbgCompiler(IXsltDebugger debugger) {
            this.debugger = debugger;
        }
        public override IXsltDebugger Debugger { get { return this.debugger; } }

        // Variables
        //
        // In XsltDebugger we have to know variables that are visible from each action.
        // We keepping two different sets of wariables because global and local variables have different rules of visibility.
        // Globals: All global variables are visible avryware (uncalucaled will have null value), 
        //          Duplicated globals from different stilesheets are replaced (by import presidence)
        // Locals:  Visible only in scope and after it was defined.
        //          No duplicates posible.
        private ArrayList        globalVars = new ArrayList();
        private ArrayList        localVars  = new ArrayList();
        private VariableAction[] globalVarsCache, localVarsCache;

        public virtual VariableAction[] GlobalVariables {
            get { 
                Debug.Assert(this.Debugger != null);
                if (this.globalVarsCache == null) {
                    this.globalVarsCache = (VariableAction[]) this.globalVars.ToArray(typeof(VariableAction));
                }
                return this.globalVarsCache; 
            }
        }        
        public virtual VariableAction[] LocalVariables {
            get { 
                Debug.Assert(this.Debugger != null);
                if (this.localVarsCache == null) {
                    this.localVarsCache = (VariableAction[]) this.localVars.ToArray(typeof(VariableAction));
                }
                return this.localVarsCache; 
            }
        }

        private void DefineVariable(VariableAction variable) {
            Debug.Assert(this.Debugger != null);
            if (variable.IsGlobal) {
                for(int i = 0; i < globalVars.Count; i ++) {
                    VariableAction oldVar = (VariableAction)this.globalVars[i];
                    if(oldVar.Name == variable.Name) { // Duplicate var definition
                        if(variable.Stylesheetid < oldVar.Stylesheetid) {
                            Debug.Assert(variable.VarKey != -1, "Variable was already placed and it should replace prev var.");
                            this.globalVars[i] = variable;
                            this.globalVarsCache = null;
                        }
                        return;
                    }
                }
                this.globalVars.Add(variable);
                this.globalVarsCache = null;
            }
            else {
                // local variables never conflict
                localVars.Add(variable);
                this.localVarsCache = null;
            }
        }
        
        private void UnDefineVariables(int count) {
            Debug.Assert(0 <= count, "This scope can't have more variables than we have in total");
            Debug.Assert(count <= this.localVars.Count, "This scope can't have more variables than we have in total");
            if(count != 0) {
                this.localVars.RemoveRange(this.localVars.Count - count, count);
                this.localVarsCache = null;
            }
        }

        internal override void PopScope() {
            this.UnDefineVariables(this.ScopeManager.CurrentScope.GetVeriablesCount());
            base.PopScope();
        }

        // ---------------- Actions: ---------------

        public override ApplyImportsAction CreateApplyImportsAction() {
            ApplyImportsAction action = new ApplyImportsActionDbg();
            action.Compile(this);
            return action;
        }

        public override ApplyTemplatesAction CreateApplyTemplatesAction() {
            ApplyTemplatesAction action = new ApplyTemplatesActionDbg();
            action.Compile(this);
            return action;
        }

        public override AttributeAction CreateAttributeAction() {
            AttributeAction action = new AttributeActionDbg();
            action.Compile(this);
            return action;
        }

        public override AttributeSetAction CreateAttributeSetAction() {
            AttributeSetAction action = new AttributeSetActionDbg();
            action.Compile(this);
            return action;
        }

        public override CallTemplateAction CreateCallTemplateAction() {
            CallTemplateAction action = new CallTemplateActionDbg();
            action.Compile(this);
            return action;
        }

        public override ChooseAction CreateChooseAction() {//!!! don't need to be here
            ChooseAction action = new ChooseAction();
            action.Compile(this);
            return action;
        }

        public override CommentAction CreateCommentAction() {
            CommentAction action = new CommentActionDbg();
            action.Compile(this);
            return action;
        }

        public override CopyAction CreateCopyAction() {
            CopyAction action = new CopyActionDbg();
            action.Compile(this);
            return action;
        }

        public override CopyOfAction CreateCopyOfAction() {
            CopyOfAction action = new CopyOfActionDbg();
            action.Compile(this);
            return action;
        }

        public override ElementAction CreateElementAction() {
            ElementAction action = new ElementActionDbg();
            action.Compile(this);
            return action;
        }

        public override ForEachAction CreateForEachAction() {
            ForEachAction action = new ForEachActionDbg();
            action.Compile(this);
            return action;
        }

        public override IfAction CreateIfAction(IfAction.ConditionType type) {
            IfAction action = new IfActionDbg(type);
            action.Compile(this);
            return action;
        }

        public override MessageAction CreateMessageAction() {
            MessageAction action = new MessageActionDbg();
            action.Compile(this);
            return action;
        }

        public override NewInstructionAction CreateNewInstructionAction() {
            NewInstructionAction action = new NewInstructionActionDbg();
            action.Compile(this);
            return action;
        }

        public override NumberAction CreateNumberAction() {
            NumberAction action = new NumberActionDbg();
            action.Compile(this);
            return action;
        }

        public override ProcessingInstructionAction CreateProcessingInstructionAction() {
            ProcessingInstructionAction action = new ProcessingInstructionActionDbg();
            action.Compile(this);
            return action;
        }

        public override void CreateRootAction() {
            this.RootAction = new RootActionDbg();
            this.RootAction.Compile(this);
        }

        public override SortAction CreateSortAction() {
            SortAction action = new SortActionDbg();
            action.Compile(this);
            return action;
        }

        public override TemplateAction CreateTemplateAction() {
            TemplateAction action = new TemplateActionDbg();
            action.Compile(this);
            return action;
        }

        public override TemplateAction CreateSingleTemplateAction() {
            TemplateAction action = new TemplateActionDbg();
            action.CompileSingle(this);
            return action;
        }

        public override TextAction CreateTextAction() {
            TextAction action = new TextActionDbg();
            action.Compile(this);
            return action;
        }

        public override UseAttributeSetsAction CreateUseAttributeSetsAction() {
            UseAttributeSetsAction action = new UseAttributeSetsActionDbg();
            action.Compile(this);
            return action;
        }

        public override ValueOfAction CreateValueOfAction() {
            ValueOfAction action = new ValueOfActionDbg();
            action.Compile(this);
            return action;
        }

        public override VariableAction CreateVariableAction(VariableType type) {
            VariableAction action = new VariableActionDbg(type);
            action.Compile(this);
            return action;
        }

        public override WithParamAction CreateWithParamAction() {
            WithParamAction action = new WithParamActionDbg();
            action.Compile(this);
            return action;
        }

        // ---------------- Events: ---------------

        public override BeginEvent CreateBeginEvent() {
            return new BeginEventDbg(this);
        }

        public override TextEvent CreateTextEvent() {
            return new TextEventDbg(this);
        }

        // Debugger enabled implemetation of most compiled actions

        private class ApplyImportsActionDbg : ApplyImportsAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
            }
        }

        private class ApplyTemplatesActionDbg : ApplyTemplatesAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
            }
        }

        private class AttributeActionDbg : AttributeAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
            }
        }

        private class AttributeSetActionDbg : AttributeSetAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
            }
        }

        private class CallTemplateActionDbg : CallTemplateAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
            }
        }

        private class CommentActionDbg : CommentAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
            }
        }

        private class CopyActionDbg : CopyAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
            }
        }

        private class CopyOfActionDbg : CopyOfAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
            }
        }

        private class ElementActionDbg : ElementAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
            }
        }

        private class ForEachActionDbg : ForEachAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.PushDebuggerStack();
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
                if (frame.State == Finished) {
                    processor.PopDebuggerStack();
                }
            }
        }

        private class IfActionDbg : IfAction {
            internal IfActionDbg(ConditionType type) : base(type) {}

            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
            }
        }

        private class MessageActionDbg : MessageAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
            }
        }

        private class NewInstructionActionDbg : NewInstructionAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
            }
        }

        private class NumberActionDbg : NumberAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
            }
        }

        private class ProcessingInstructionActionDbg : ProcessingInstructionAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
            }
        }

        private class RootActionDbg : RootAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);

                Debug.Assert(compiler.Debugger != null);
                string builtIn = compiler.Debugger.GetBuiltInTemplatesUri();
                if (builtIn != null && builtIn != string.Empty) {
                    compiler.AllowBuiltInMode = true;
                    builtInSheet = compiler.RootAction.CompileImport(compiler, compiler.ResolveUri(builtIn), int.MaxValue);
                    compiler.AllowBuiltInMode = false;
                }

                dbgData.ReplaceVariables(((DbgCompiler) compiler).GlobalVariables) ;
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if (frame.State == Initialized) {
                    processor.PushDebuggerStack();
                    processor.OnInstructionExecute();
                    processor.PushDebuggerStack();
                }
                base.Execute(processor, frame);
                if (frame.State == Finished) {
                    processor.PopDebuggerStack();
                    processor.PopDebuggerStack();
                }
            }
        }

        private class SortActionDbg : SortAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
            }
        }

        private class TemplateActionDbg : TemplateAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.PushDebuggerStack();
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
                if (frame.State == Finished) {
                    processor.PopDebuggerStack();
                }
            }
        }

        private class TextActionDbg : TextAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
            }
        }

        private class UseAttributeSetsActionDbg : UseAttributeSetsAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
            }
        }

        private class ValueOfActionDbg : ValueOfAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
            }
        }

        private class VariableActionDbg : VariableAction {
            internal VariableActionDbg(VariableType type) : base(type) {}
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
                ((DbgCompiler) compiler).DefineVariable(this);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
            }
        }

        private class WithParamActionDbg : WithParamAction {
            private DbgData dbgData;
            internal override DbgData GetDbgData(ActionFrame frame) { return this.dbgData; }

            internal override void Compile(Compiler compiler) {
                dbgData = new DbgData(compiler);
                base.Compile(compiler);
            }

            internal override void Execute(Processor processor, ActionFrame frame) {
                if(frame.State == Initialized) {
                    processor.OnInstructionExecute();
                }
                base.Execute(processor, frame);
            }
        }

        // ---------------- Events: ---------------

        private class BeginEventDbg : BeginEvent {
            private DbgData dbgData;
            internal override DbgData DbgData { get { return this.dbgData; } }

            public BeginEventDbg(Compiler compiler) : base(compiler) {
                dbgData = new DbgData(compiler);
            }
            public override bool Output(Processor processor, ActionFrame frame) {
                this.OnInstructionExecute(processor);
                return base.Output(processor, frame);
            }
        }

        private class TextEventDbg : TextEvent {
            private DbgData dbgData;
            internal override DbgData DbgData { get { return this.dbgData; } }

            public TextEventDbg(Compiler compiler) : base(compiler) {
                dbgData = new DbgData(compiler);
            }
            public override bool Output(Processor processor, ActionFrame frame) {
                this.OnInstructionExecute(processor);
                return base.Output(processor, frame);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\documentscope.cs ===
//------------------------------------------------------------------------------
// <copyright file="DocumentScope.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class DocumentScope {
        protected NamespaceDecl scopes;

        internal NamespaceDecl Scopes {
            get { return this.scopes; }
        }

        internal NamespaceDecl AddNamespace(string prefix, string uri, string prevDefaultNsUri) {
            this.scopes = new NamespaceDecl(prefix, uri, prevDefaultNsUri, this.scopes);
            return this.scopes;
        }

        internal string ResolveAtom(string prefix) {
            Debug.Assert(prefix != null && prefix.Length > 0);

            for (NamespaceDecl scope = this.scopes; scope != null; scope = scope.Next) {
                if (Keywords.Equals(scope.Prefix, prefix)) {
                    Debug.Assert(scope.Uri != null);
                    return scope.Uri;
                }
            }

            return null;
        }

        internal string ResolveNonAtom(string prefix) {
            Debug.Assert(prefix != null && prefix.Length > 0);

            for (NamespaceDecl scope = this.scopes; scope != null; scope = scope.Next) {
                if (Keywords.Compare(scope.Prefix, prefix)) {
                    Debug.Assert(scope.Uri != null);
                    return scope.Uri;
                }
            }
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\endevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="EndEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class EndEvent : Event {
        private XPathNodeType nodeType;
        
        internal EndEvent(XPathNodeType nodeType) {
            Debug.Assert(nodeType != XPathNodeType.Namespace);
            this.nodeType = nodeType;
        }

        public override bool Output(Processor processor, ActionFrame frame) {
            return processor.EndEvent(this.nodeType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\elementaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="ElementAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class ElementAction : ContainerAction {
        private const int NameDone           = 2;

        private Avt                nameAvt;
        private Avt                nsAvt;
        private bool               empty;
        private InputScopeManager  manager;
        // Compile time precalculated AVTs
        private string              name;
        private string              nsUri;
        private PrefixQName         qname; // When we not have AVTs at all we can do this. null otherwise.

        internal ElementAction() {}

        private static PrefixQName CreateElementQName(string name, string nsUri, InputScopeManager manager) {
            if (nsUri == Keywords.s_XmlnsNamespace) {
                throw new XsltException(Res.Xslt_ReservedNS, nsUri);
            }

            PrefixQName qname = new PrefixQName();
            qname.SetQName(name);

            if (nsUri == null) {
                qname.Namespace = manager.ResolveXmlNamespace(qname.Prefix);
            }
            else {
                qname.Namespace = nsUri;
            }
            return qname;
        }

        internal override void Compile(Compiler compiler) {
            CompileAttributes(compiler);
            CheckRequiredAttribute(compiler, this.nameAvt, Keywords.s_Name);

            this.name  = PrecalculateAvt(ref this.nameAvt);
            this.nsUri = PrecalculateAvt(ref this.nsAvt  );

            // if both name and ns are not AVT we can calculate qname at compile time and will not need namespace manager anymore
            if (this.nameAvt == null && this.nsAvt == null) {
                if(this.name != Keywords.s_Xmlns) {
                    this.qname = CreateElementQName(this.name, this.nsUri, compiler.CloneScopeManager());                    
                }
            }
            else {
                this.manager = compiler.CloneScopeManager();
            }

            if (compiler.Recurse()) {
                Debug.Assert(this.empty == false);
                CompileTemplate(compiler);
                compiler.ToParent();
            }
            this.empty = (this.containedActions == null) ;
        }

        internal override bool CompileAttribute(Compiler compiler) {
            string name   = compiler.Input.LocalName;
            string value  = compiler.Input.Value;
            if (Keywords.Equals(name, compiler.Atoms.Name)) {
                this.nameAvt      = Avt.CompileAvt(compiler, value);
                Debug.WriteLine("name = \"" + value + "\"");
            }
            else if (Keywords.Equals(name, compiler.Atoms.Namespace)) {
                this.nsAvt = Avt.CompileAvt(compiler, value);
                Debug.WriteLine("namespace = \"" + value + "\"");
            }
            else if (Keywords.Equals(name, compiler.Atoms.UseAttributeSets)) {
                AddAction(compiler.CreateUseAttributeSetsAction());
            }
            else {
                return false;
            }

            return true;
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);

            switch (frame.State) {
            case Initialized:
                if(this.qname != null) {
                    frame.CalulatedName = this.qname;
                }
                else {
                    frame.CalulatedName = CreateElementQName(
                        this.nameAvt == null ? this.name  : this.nameAvt.Evaluate(processor, frame),
                        this.nsAvt   == null ? this.nsUri : this.nsAvt  .Evaluate(processor, frame),
                        this.manager
                    );
                }
                goto case NameDone;

            case NameDone:
                {
                    PrefixQName qname = frame.CalulatedName;
                    if (processor.BeginEvent(XPathNodeType.Element, qname.Prefix, qname.Name, qname.Namespace, this.empty) == false) {
                        // Come back later
                        frame.State = NameDone;
                        break;
                    }

                    if (! this.empty) {
                        processor.PushActionFrame(frame);
                        frame.State = ProcessingChildren;
                        break;                              // Allow children to run
                    }
                    else {
                        goto case ProcessingChildren;
                    }
                }
            case ProcessingChildren:
                if (processor.EndEvent(XPathNodeType.Element) == false) {
                    Debug.WriteLine("Cannot end event, breaking, will restart");
                    frame.State = ProcessingChildren;
                    break;
                }
                frame.Finished();
                break;
            default:
                Debug.Fail("Invalid ElementAction execution state");
    		    break;
            }
        }

        internal override void Trace(int tab) {
            Debug.Indent(tab);
//            Debug.WriteLine("<xsl:element name=\"" + this.name + "\" namespace=\"" + this.nsUri + "\" use-attribute-sets=\"" + this.useAttributeSets + "\"");
//            AvtAction.Trace(this.nameAvt, tab);
//            AvtAction.Trace(this.nsAvt, tab);
            base.Trace(tab);
            Debug.Indent(tab);
            Debug.WriteLine("</xsl:element>");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\compiler.cs ===
//------------------------------------------------------------------------------
// <copyright file="Compiler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Globalization;
    using System.Xml;
    using System.Xml.XPath;
    using System.Xml.Xsl.Debugger;
    using System.Text;
    using System.Collections;
    using System.IO;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using System.Reflection;
    using System.Security;
    using System.Security.Policy;
    using System.Security.Permissions;

    internal class Sort {
        internal int          select;
        internal string       lang;
        internal XmlDataType  dataType;
        internal XmlSortOrder order;
        internal XmlCaseOrder caseOrder;

        public Sort(int sortkey, String xmllang, XmlDataType datatype, XmlSortOrder xmlorder, XmlCaseOrder xmlcaseorder) {
            select    = sortkey;
            lang      = xmllang;
            dataType  = datatype;
            order     = xmlorder;
            caseOrder = xmlcaseorder;
        }
    }

    internal enum ScriptingLanguage {
        JScript,
        VisualBasic,
        CSharp
    }

    internal class DecimalFormat {
        internal NumberFormatInfo info;
        internal char digit;
        internal char zeroDigit;
        internal char patternSeparator;

        internal DecimalFormat(NumberFormatInfo Info, char Digit,char ZeroDigit, char PatternSeparator) {
            this.info = Info;
            this.digit = Digit;
            this.zeroDigit = ZeroDigit;
            this.patternSeparator = PatternSeparator;
        }
    }
    
    internal class Compiler {
        //
        // Predefined query keys
        //
        
        internal const int    InvalidQueryKey   = -1;
        internal const int    RootQueryKey      = 0;
        internal const int    SelfQueryKey      = 1;
        internal const int    PrecedingSiblingKey = 2;
        internal const int    DescendantKey     = 3;
        internal const int    DescendantTextKey = 4;

        internal const string RootQuery         = "/";
        internal const string SelfQuery         = ".";
        internal const string PrecedingSibling  = "preceding-sibling::node()";
        internal const string Descendant        = "descendant::node()";
        internal const string DescendantText    = "descendant::text()";

        internal const double RootPriority   = 0.5;

        // cached StringBuilder for AVT parseing
        internal StringBuilder AvtStringBuilder = new StringBuilder();

        private int                 stylesheetid; // Root stylesheet has id=0. We are using this in CompileImports to compile BuiltIns
        private InputScope          rootScope;

        //
        // Object members
        private XmlResolver         xmlResolver;

        //
        // Template being currently compiled
        private TemplateBaseAction  currentTemplate;
        private XmlQualifiedName    currentMode;
        private Hashtable           globalNamespaceAliasTable;
   
        //
        // Current import stack
        private Stack               stylesheets;

        private Hashtable           documentURIs;

        // import/include documents, who is here has its URI in this.documentURIs
        private NavigatorInput      input;

        // Atom table & InputScopeManager - cached top of the this.input stack
        private Keywords            atoms;
        private InputScopeManager   scopeManager;

        //
        // Compiled stylesheet state
        internal Stylesheet         stylesheet;
        internal Stylesheet         rootStylesheet;
        private RootAction          rootAction;
        private ArrayList           queryStore;
        private QueryBuilder        queryBuilder = new QueryBuilder();

        // Used to load Built In templates
        public  bool                AllowBuiltInMode;
        public  static XmlQualifiedName BuiltInMode = new XmlQualifiedName("*", string.Empty);

        internal Keywords Atoms {
            get {
                Debug.Assert(this.atoms != null);
                return this.atoms;
            }
        }

        internal int Stylesheetid {
            get{ return this.stylesheetid; }
            set { this.stylesheetid = value; }
        }
        
        internal NavigatorInput Document {
            get { return this.input; }
        }

        internal NavigatorInput Input {
            get { return this.input; }
        }

        internal bool Advance() {
            Debug.Assert(Document != null);
            return Document.Advance();
        }

        internal bool Recurse() {
            Debug.Assert(Document != null);
            return Document.Recurse();
        }

        internal bool ToParent() {
            Debug.Assert(Document != null);
            return Document.ToParent();
        }

        internal Stylesheet CompiledStylesheet {
            get { return this.stylesheet; }
        }

        internal RootAction RootAction {
            get { return this.rootAction; }
            set { 
                Debug.Assert(this.rootAction == null);
                this.rootAction = value; 
                Debug.Assert(this.currentTemplate == null);
                this.currentTemplate = this.rootAction;
            }
        }

        internal ArrayList QueryStore {
            get { return this.queryStore; }
        }

        public virtual IXsltDebugger Debugger { get { return null; } }

        //
        // The World of Compile
        //

        internal void Compile(NavigatorInput input, XmlResolver xmlResolver, Evidence evidence) {
            Debug.Assert(input != null);
            Debug.Assert(xmlResolver != null);
//            Debug.Assert(evidence    != null); -- default evidence is null now
            Debug.Assert(this.input == null && this.atoms == null);
            this.xmlResolver = xmlResolver;

            PushInputDocument(input, input.BaseURI);
            this.rootScope  = this.scopeManager.PushScope();
            this.queryStore = new ArrayList();
            AddSpecialQueries();

            try {
                this.rootStylesheet = new Stylesheet();
                PushStylesheet(this.rootStylesheet);

                Debug.Assert(this.input != null && this.atoms != null);

                try {
                    this.CreateRootAction();
                }
                catch(Exception e) {
                    throw new XsltCompileException(e, this.Input.BaseURI, this.Input.LineNumber, this.Input.LinePosition);
                }

                this.stylesheet.ProcessTemplates();
                this.rootAction.PorcessAttributeSets(this.rootStylesheet);
                this.stylesheet.SortWhiteSpace();
                CompileScript(evidence);
                this.rootAction.SortVariables();
                if (evidence != null) {
                    this.rootAction.permissions = SecurityManager.ResolvePolicy(evidence);
                }

                if (this.globalNamespaceAliasTable != null ) {
                    this.stylesheet.ReplaceNamespaceAlias(this);
                    this.rootAction.ReplaceNamespaceAlias(this);
                }  
            }
            finally {
                PopInputDocument();
            }

            Debug.Assert(this.rootAction != null);
            Debug.Assert(this.stylesheet != null);
            Debug.Assert(this.queryStore != null);
            Debug.Assert(this.input == null && this.atoms == null);
        }

        //
        // Input scope compiler's support
        //

        internal bool ForwardCompatibility {
            get { return this.scopeManager.CurrentScope.ForwardCompatibility;  }
            set { this.scopeManager.CurrentScope.ForwardCompatibility = value; }
        }
        
        internal bool CanHaveApplyImports {
            get { return this.scopeManager.CurrentScope.CanHaveApplyImports;  }
            set { this.scopeManager.CurrentScope.CanHaveApplyImports = value; }
        }
        
        internal void InsertExtensionNamespace(string value) {
            if (value == null) {
                return ;
            }
            String[] prefixes = SplitString(value);

            for (int i= 0; i < prefixes.Length; i++) {
                this.scopeManager.InsertExtensionNamespace(
                    prefixes[i] == Keywords.s_HashDefault ? DefaultNamespace : ResolveXmlNamespace(prefixes[i])
                );
            }       
        }

        internal void InsertExcludedNamespace(string value) {
            if (value == null) {
                return ;
            }
            String[] prefixes = SplitString(value);

            for (int i= 0; i < prefixes.Length; i++) {
                this.scopeManager.InsertExcludedNamespace(
                    prefixes[i] == Keywords.s_HashDefault ? DefaultNamespace : ResolveXmlNamespace(prefixes[i])
                );
            }
        }

        internal void InsertExtensionNamespace() {
            InsertExtensionNamespace(Input.Navigator.GetAttribute(Input.Atoms.ExtensionElementPrefixes, Input.Atoms.XsltNamespace));
        }

        internal void InsertExcludedNamespace() {
            InsertExcludedNamespace(Input.Navigator.GetAttribute(Input.Atoms.ExcludeResultPrefixes, Input.Atoms.XsltNamespace));
        }
        
        internal bool IsExtensionNamespace(String nspace) {
            return this.scopeManager.IsExtensionNamespace(nspace);
        }

        internal bool IsExcludedNamespace(String nspace) {
            return this.scopeManager.IsExcludedNamespace(nspace);
        }
        
        internal void PushLiteralScope() {
            PushNamespaceScope();
            string value = Input.Navigator.GetAttribute(Atoms.Version, Atoms.XsltNamespace);
            if (value != string.Empty) {
                ForwardCompatibility = (value != Keywords.s_Version10);
            }
        }

        internal void PushNamespaceScope() {
            this.scopeManager.PushScope();
            NavigatorInput input  = Input;

            if (input.MoveToFirstNamespace()) {
                do {
                    this.scopeManager.PushNamespace(input.LocalName, input.Value);
                }
                while(input.MoveToNextNamespace());
                input.ToParent();
            }
        }

        protected InputScopeManager  ScopeManager {
            get { return this.scopeManager; }
        }

        internal virtual void PopScope() {
            this.currentTemplate.ReleaseVariableSlots(this.scopeManager.CurrentScope.GetVeriablesCount());
            this.scopeManager.PopScope();
        }

        internal InputScopeManager CloneScopeManager() {
            return this.scopeManager.Clone();
        }

        //
        // Variable support
        //

        internal int InsertVariable(VariableAction variable) {
            InputScope varScope;
            if (variable.IsGlobal) {
                Debug.Assert(this.rootAction != null);
                varScope = this.rootScope;
            }
            else {
                Debug.Assert(this.currentTemplate != null);
                Debug.Assert(variable.VarType == VariableType.LocalVariable || variable.VarType == VariableType.LocalParameter || variable.VarType == VariableType.WithParameter);
                varScope = this.scopeManager.VariableScope;
            }

            VariableAction oldVar = varScope.ResolveVariable(variable.Name);
            if (oldVar != null) {
                // Other variable with this name is visible in this scope
                if (oldVar.IsGlobal) {
                    if (variable.IsGlobal) {
                        // Global Vars replace each other base on import presidens odred
                        if(variable.Stylesheetid == oldVar.Stylesheetid) {
                            // Both vars are in the same stylesheet
                            throw new XsltException(Res.Xslt_DupVarName, variable.NameStr);
                        }
                        else if(variable.Stylesheetid < oldVar.Stylesheetid) {
                            // newly defined var is more importent
                            varScope.InsertVariable(variable);
                            return oldVar.VarKey;
                        }
                        else {
                            // we egnore new variable
                            return InvalidQueryKey; // We didn't add this var, so doesn't matter what VarKey we return;
                        }
                    }
                    else {
                        // local variable can shadow global
                    }
                }
                else {
                    // Local variable never can be "shadowed"
                    throw new XsltException(Res.Xslt_DupVarName, variable.NameStr);
                }
            }

            varScope.InsertVariable(variable);
            return this.currentTemplate.AllocateVariableSlot();
        }
        
        internal void AddNamespaceAlias(String StylesheetURI, NamespaceInfo AliasInfo){
            if (this.globalNamespaceAliasTable == null) {
                this.globalNamespaceAliasTable = new Hashtable();            
            }
            NamespaceInfo duplicate = this.globalNamespaceAliasTable[StylesheetURI] as NamespaceInfo;
            if (duplicate == null || AliasInfo.stylesheetId <= duplicate.stylesheetId) {
                this.globalNamespaceAliasTable[StylesheetURI] = AliasInfo;
            }
        }
        
        internal bool IsNamespaceAlias(String StylesheetURI){
            if (this.globalNamespaceAliasTable == null) {
                return false;
            }
            return this.globalNamespaceAliasTable.Contains(StylesheetURI);
        }
        
        internal NamespaceInfo FindNamespaceAlias(String StylesheetURI) {
            if (this.globalNamespaceAliasTable != null) {
               return (NamespaceInfo)this.globalNamespaceAliasTable[StylesheetURI]; 
            }   
            return null;
        }

        internal String ResolveXmlNamespace(String prefix) {
            return this.scopeManager.ResolveXmlNamespace(prefix);
        }

        internal String ResolveXPathNamespace(String prefix) {
            return this.scopeManager.ResolveXPathNamespace(prefix);
        }

        internal String DefaultNamespace {
            get{ return this.scopeManager.DefaultNamespace; }
        }

        internal void InsertKey(XmlQualifiedName name, int MatchKey, int UseKey) {
            this.rootAction.InsertKey(name, MatchKey, UseKey);
        }

        internal void AddDecimalFormat(XmlQualifiedName name, DecimalFormat formatinfo) {
            this.rootAction.AddDecimalFormat(name, formatinfo);
        }
                
        //
        // Attribute parsing support
        //

        internal bool GetYesNo(string value) {
            Debug.Assert(value != null);
            Debug.Assert((object)value == (object)Input.Value); // this is always true. Why we passing value to this function.
//            if (value == null)
//                return false;  // in XSLT it happens that default value was always false;
            if (value.Equals(Atoms.Yes)) {
                return true;
            }
            if (value.Equals(Atoms.No)) {
                return false;
            }
            throw XsltException.InvalidAttrValue(Input.LocalName, value);
        }

        internal string GetSingleAttribute(string attributeAtom) {
            NavigatorInput input   = Input;
            string         element = input.LocalName;
            string         value   = null;

            if (input.MoveToFirstAttribute()) {
                do {
                    Debug.TraceAttribute(input);
                    string nspace = input.NamespaceURI;
                    string name   = input.LocalName;

                    if (! Keywords.Equals(nspace, Atoms.Empty)) continue;

                    if (Keywords.Equals(name, attributeAtom)) {
                        value = input.Value;
                    }
                    else {
                        if (! this.ForwardCompatibility) {
                             throw XsltException.InvalidAttribute(element, name);
                        }
                    }
                }
                while (input.MoveToNextAttribute());
                input.ToParent();
            }

            if (value == null) {
                throw new XsltException(Res.Xslt_MissingAttribute, attributeAtom);
            }
            return value;
        }

        internal XmlQualifiedName CreateXPathQName(string qname) {
            string prefix, local;
            PrefixQName.ParseQualifiedName(qname, out prefix, out local);

            return new XmlQualifiedName(local, this.scopeManager.ResolveXPathNamespace(prefix));
        }

        internal XmlQualifiedName CreateXmlQName(string qname) {
            string prefix, local;
            PrefixQName.ParseQualifiedName(qname, out prefix, out local);

            return new XmlQualifiedName(local, this.scopeManager.ResolveXmlNamespace(prefix));
        }

        //
        // Input documents management
        //

        internal static XPathDocument LoadDocument(XmlTextReader reader) {
            XmlValidatingReader vr = XPathDocument.CreateHelperValidatingReader(reader);
            try {
                return new XPathDocument(vr, XmlSpace.Preserve);
            }
            finally {
                vr.Close();
                reader.Close();
            }
        }

        private void AddDocumentURI(string href) {
            if (this.documentURIs == null) {
                this.documentURIs = new Hashtable();
            }

            if (this.documentURIs.Contains(href)) {
                throw new XsltException(Res.Xslt_CircularInclude, href);
            }

            this.documentURIs.Add(href, null);
        }

        private void RemoveDocumentURI(string href) {
            if (this.documentURIs != null) {
                Debug.Assert(this.documentURIs.Contains(href));
                this.documentURIs.Remove(href);
            }
        }

        internal NavigatorInput ResolveDocument(string relativeUri) {
            return this.ResolveDocument(this.ResolveUri(relativeUri));
        }

        internal Uri ResolveUri(string relativeUri) {
            Debug.Assert(this.xmlResolver != null);
            string baseUri = this.Input.BaseURI;
            Uri uri = this.xmlResolver.ResolveUri((baseUri != String.Empty) ? this.xmlResolver.ResolveUri(null, baseUri) : null, relativeUri);
            if (uri == null) {
                throw new XsltException(Res.Xslt_CantResolve, relativeUri);
            }
            return uri;
        }

        internal NavigatorInput ResolveDocument(Uri absoluteUri) {
            Debug.Assert(this.xmlResolver != null);
            object input = this.xmlResolver.GetEntity(absoluteUri, null, null);
            string resolved = absoluteUri.ToString();

            if (input is Stream) {
                XmlTextReader tr  = new XmlTextReader(resolved, (Stream) input); {
                                                                                     tr.XmlResolver = this.xmlResolver;
                                                                                 }
                // reader is closed by Compiler.LoadDocument()
                return new NavigatorInput(Compiler.LoadDocument(tr), resolved, rootScope);
            }
            else if (input is XPathNavigator) {
                return new NavigatorInput((XPathNavigator) input, resolved, rootScope);
            }
            else {
                throw new XsltException(Res.Xslt_CantResolve, resolved);
            }
        }

        internal void PushInputDocument(NavigatorInput newInput, string inputUri) {
            Debug.Assert(newInput != null);
            Debug.WriteLine("Pushing document \"" + inputUri + "\"");

            AddDocumentURI(inputUri);

            newInput.Next     = this.input;
            this.input        = newInput;
            this.atoms        = this.input.Atoms;
            this.scopeManager = this.input.InputScopeManager;
        }

        internal void PopInputDocument() {
            Debug.Assert(this.input != null);
            Debug.Assert(this.input.Atoms == this.atoms);

            NavigatorInput lastInput = this.input;

            this.input     = lastInput.Next;
            lastInput.Next = null;

            if (this.input != null) {
                this.atoms        = this.input.Atoms;
                this.scopeManager = this.input.InputScopeManager;
            }
            else {
                this.atoms        = null;
                this.scopeManager = null;
            }

            RemoveDocumentURI(lastInput.Href);
            lastInput.Close();
        }

        //
        // Stylesheet management
        //

        internal void PushStylesheet(Stylesheet stylesheet) {
            if (this.stylesheets == null) {
                this.stylesheets = new Stack();
            }
            Debug.Assert(this.stylesheets != null);

            this.stylesheets.Push(stylesheet);
            this.stylesheet = stylesheet;
        }

        internal Stylesheet PopStylesheet() {
            Debug.Assert(this.stylesheet == this.stylesheets.Peek());
            Stylesheet stylesheet = (Stylesheet) this.stylesheets.Pop();
            this.stylesheet = (Stylesheet) this.stylesheets.Peek();
            return stylesheet;
        }

        //
        // Attribute-Set management
        //

        internal void AddAttributeSet(AttributeSetAction attributeSet) {
            Debug.Assert(this.stylesheet == this.stylesheets.Peek());
            this.stylesheet.AddAttributeSet(attributeSet);
        }

        //
        // Template management
        //

        internal void AddTemplate(TemplateAction template) {
            Debug.Assert(this.stylesheet == this.stylesheets.Peek());
            this.stylesheet.AddTemplate(template);
        }

        internal void BeginTemplate(TemplateAction template) {
            Debug.Assert(this.currentTemplate != null);
            this.currentTemplate = template;
            this.currentMode     = template.Mode;
            this.CanHaveApplyImports = template.MatchKey != Compiler.InvalidQueryKey;
        }

        internal void EndTemplate() {
            Debug.Assert(this.currentTemplate != null);
            this.currentTemplate = this.rootAction;
        }

        internal XmlQualifiedName CurrentMode {
            get { return this.currentMode; }
        }

        //
        // Query management
        //

        private void AddSpecialQueries() {
            Debug.Assert(this.queryStore.Count == 0);

            if (
                AddQuery(RootQuery) != RootQueryKey ||
                AddQuery(SelfQuery) != SelfQueryKey ||
                AddQuery(PrecedingSibling) != PrecedingSiblingKey ||
                AddQuery(Descendant) != DescendantKey ||
                AddQuery(DescendantText) != DescendantTextKey
            ){
                Debug.Assert(false, "Internal Error: Predefined quiery mismatch.");
            }
        }

        internal int AddQuery(string xpathQuery) {
            return AddQuery(xpathQuery, /*allowVars:*/true, /*allowKey*/true);
        }

        internal int AddQuery(string xpathQuery, bool allowVar, bool allowKey) {
            Debug.Assert(this.queryStore != null);

            try {
                TheQuery theQuery = new TheQuery(new CompiledXpathExpr(this.queryBuilder.Build(xpathQuery, allowVar, allowKey), xpathQuery, false) , this.scopeManager);
                int      theKey   = this.queryStore.Add(theQuery);
                Debug.Assert(this.queryStore[theKey] == theQuery);
                Debug.Assert(theKey == this.queryStore.Count - 1);

                return theKey;
            }
            catch (XPathException e) {
                if (ForwardCompatibility) {
                    return InvalidQueryKey;
                }
                throw new XsltException(Res.Xslt_InvalidXPath,  new string[] { xpathQuery }, e);
                
            }
        }

        internal int AddPatternQuery(string xpathQuery, bool allowVar, bool allowKey) {
            Debug.Assert(this.queryStore != null);
            try {
                TheQuery theQuery = new TheQuery(new CompiledXpathExpr(this.queryBuilder.BuildPatternQuery(xpathQuery, allowVar, allowKey), xpathQuery, false) , this.scopeManager);
                int      theKey   = this.queryStore.Add(theQuery);
                Debug.Assert(this.queryStore[theKey] == theQuery);
                Debug.Assert(theKey == this.queryStore.Count - 1);
                return theKey;
            }
            catch (XPathException e) {
                if (ForwardCompatibility) {
                    return InvalidQueryKey;
                }
                throw new XsltException(Res.Xslt_InvalidXPath,  new string[] { xpathQuery }, e);
            }
        }

        internal int AddStringQuery(string xpathQuery) {
            string modifiedQuery = XmlCharType.IsOnlyWhitespace(xpathQuery) ? xpathQuery : "string(" + xpathQuery + ")";
            return AddQuery(modifiedQuery);
        }

        internal int AddBooleanQuery(string xpathQuery) {
            string modifiedQuery = XmlCharType.IsOnlyWhitespace(xpathQuery) ? xpathQuery : "boolean(" + xpathQuery + ")";
            return AddQuery(modifiedQuery);
        }

        //
        // Script support
        //
        Hashtable[] _typeDeclsByLang = new Hashtable[] { new Hashtable(), new Hashtable(), new Hashtable() };
        ArrayList   scriptFiles = new ArrayList();
        // Namespaces we always import when compiling
        private static string[] _defaultNamespaces = new string[] {
            "System",
            "System.Collections",
            "System.Text",
            "System.Text.RegularExpressions",
            "System.Xml",
            "System.Xml.Xsl",
            "System.Xml.XPath",
        };

        private static int scriptClassCounter = 0;
        private static string GenerateUniqueClassName() {
            return "ScriptClass_" + (++scriptClassCounter);
        }

        internal void AddScript(string source, ScriptingLanguage lang, string ns, string fileName, int lineNumber) {
            XsltArgumentList.ValidateExtensionNamespace(ns);
            for (ScriptingLanguage langTmp = ScriptingLanguage.JScript; langTmp <= ScriptingLanguage.CSharp; langTmp ++) {
                Hashtable typeDecls = _typeDeclsByLang[(int)langTmp];
                if (lang == langTmp) {
                    CodeTypeDeclaration scriptClass = (CodeTypeDeclaration)typeDecls[ns];
                    if (scriptClass == null) {
                        scriptClass = new CodeTypeDeclaration(GenerateUniqueClassName());
                        scriptClass.TypeAttributes = TypeAttributes.Public;
                        typeDecls.Add(ns, scriptClass);
                    }
                    CodeSnippetTypeMember scriptSnippet = new CodeSnippetTypeMember(source);
                    if (lineNumber > 0) {
                        scriptSnippet.LinePragma = new CodeLinePragma(fileName, lineNumber); 
                        scriptFiles.Add(fileName);
                    }
                    scriptClass.Members.Add(scriptSnippet);
                } 
                else if (typeDecls.Contains(ns)) {
                    throw new XsltException(Res.Xslt_ScriptMixLang);
                }
            }
        }

        private void FixCompilerError(CompilerError e) {
            foreach(string scriptFile in this.scriptFiles) {
                if (e.FileName == scriptFile) {
                    return; // Yes! this error is in our code sippet.
                }
            }
            e.FileName = string.Empty;
        }

        ICodeCompiler CreateCodeDomCompiler(ScriptingLanguage lang) {
            CodeDomProvider provider = (
                lang == ScriptingLanguage.JScript     ? (CodeDomProvider) Activator.CreateInstance(Type.GetType("Microsoft.JScript.JScriptCodeProvider, " + AssemblyRef.MicrosoftJScript), BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null, null) :
                lang == ScriptingLanguage.VisualBasic ? (CodeDomProvider) new Microsoft.VisualBasic.VBCodeProvider() :
                /*CSharp | default */                   (CodeDomProvider) new Microsoft.CSharp.CSharpCodeProvider()
            );
            return provider.CreateCompiler();  
        }

        private void CompileScript(Evidence evidence) {
            for (ScriptingLanguage lang = ScriptingLanguage.JScript; lang <= ScriptingLanguage.CSharp; lang ++) {
                int idx = (int)lang;
                if(_typeDeclsByLang[idx].Count > 0) {
                    CompileAssembly(lang, _typeDeclsByLang[idx], lang.ToString(), evidence);
                }
            }
        }

        private void CompileAssembly(ScriptingLanguage lang, Hashtable typeDecls, string nsName, Evidence evidence) {
            nsName = "Microsoft.Xslt.CompiledScripts." + nsName;
            CodeNamespace msXslt = new CodeNamespace(nsName);            

            // Add all the default namespaces
            foreach(string ns in _defaultNamespaces) {
                msXslt.Imports.Add(new CodeNamespaceImport(ns));
            }
            if (lang == ScriptingLanguage.VisualBasic) {
                msXslt.Imports.Add(new CodeNamespaceImport("Microsoft.VisualBasic"));
            }

            foreach(CodeTypeDeclaration scriptClass in typeDecls.Values) {
                msXslt.Types.Add(scriptClass);
            }

            CodeCompileUnit unit = new CodeCompileUnit(); {
                unit.Namespaces.Add(msXslt);
                // This settings have sense for Visual Basic only. 
                // We can consider in future to allow user set them in <xsl:script option="???"> attribute.
                unit.UserData["AllowLateBound"]             = true;  // Allow variables to be undeclared
                unit.UserData["RequireVariableDeclaration"] = false; // Allow variables to be declared untyped
            }
            CompilerParameters compilParams = new CompilerParameters(); {
                try {
                    new SecurityPermission(SecurityPermissionFlag.ControlEvidence).Assert();
                    try {
                        compilParams.GenerateInMemory = true;
                        compilParams.Evidence = evidence;
                        compilParams.ReferencedAssemblies.Add(typeof(XPathNavigator).Module.FullyQualifiedName);
                        compilParams.ReferencedAssemblies.Add("system.dll");
                        if (lang == ScriptingLanguage.VisualBasic) {
                            compilParams.ReferencedAssemblies.Add("microsoft.visualbasic.dll");
                        }
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                } catch { throw; }
            }

            CompilerResults results = CreateCodeDomCompiler(lang).CompileAssemblyFromDom(compilParams, unit);
            if (results.Errors.HasErrors) {
                StringWriter stringWriter = new StringWriter();
                foreach (CompilerError e in results.Errors) {
                    FixCompilerError(e);
                    stringWriter.WriteLine(e.ToString());
                }
                System.Diagnostics.Debug.WriteLine(stringWriter.ToString());
                throw new XsltException(Res.Xslt_ScriptCompileErrors, stringWriter.ToString());
            }
            Assembly assembly = results.CompiledAssembly;
            foreach(DictionaryEntry entry in typeDecls) {
                string ns = (string)entry.Key;
                CodeTypeDeclaration scriptClass = (CodeTypeDeclaration)entry.Value;
                this.stylesheet.ScriptObjectTypes.Add(ns, assembly.GetType(nsName + "." + scriptClass.Name));
            }
        }

        public string GetNsAlias(ref string prefix) {
            Debug.Assert(
                Keywords.Equals(this.input.LocalName, this.input.Atoms.StylesheetPrefix) || 
                Keywords.Equals(this.input.LocalName, this.input.Atoms.ResultPrefix)
            );
            if (Keywords.Compare(this.input.Atoms.HashDefault, prefix)) {
                prefix = string.Empty;
                return this.DefaultNamespace;
            }
            else {
                if(! PrefixQName.ValidatePrefix(prefix) || prefix.Length == 0) {
                    throw XsltException.InvalidAttrValue(this.input.LocalName, prefix);
                }
                return this.ResolveXPathNamespace(prefix);
            }
        }

        // AVT's compilation.
        // CompileAvt() returns ArrayList of TextEvent & AvtEvent

        private static void getTextLex(string avt, ref int start, StringBuilder lex) {
            Debug.Assert(avt.Length != start, "Empty string not supposed here");
            Debug.Assert(lex.Length == 0    , "Builder shoud to be reset here");
            int avtLength = avt.Length;
            int i;
            for (i = start; i < avtLength; i ++) {
                char ch = avt[i];
                if (ch == '{') {
                    if(i + 1 < avtLength && avt[i + 1] == '{') { // "{{"
                        i ++;                         
                    }
                    else {
                        break;
                    }
                }
                else if (ch == '}') {
                    if(i + 1 < avtLength && avt[i + 1] == '}') { // "}}"
                        i ++;                         
                    }
                    else {
                        throw new XsltException(Res.Xslt_SingleRightAvt, avt);
                    }
                }
                lex.Append(ch);
            }
            start = i;
        }

        private static void getXPathLex(string avt, ref int start, StringBuilder lex) {
            // AVT parser states
            const int InExp       = 0;      // Inside AVT expression
            const int InLiteralA  = 1;      // Inside literal in expression, apostrophe delimited
            const int InLiteralQ  = 2;      // Inside literal in expression, quote delimited
            Debug.Assert(avt.Length != start, "Empty string not supposed here");
            Debug.Assert(lex.Length == 0    , "Builder shoud to be reset here");
            Debug.Assert(avt[start] == '{'  , "We calling getXPathLex() only after we realy meet {");
            int avtLength = avt.Length;
            int state  = InExp;
            for (int i = start + 1; i < avtLength; i ++) {
                char ch = avt[i];
                switch(state) {
                case InExp :
                    switch (ch) {
                    case '{' :
                        throw new XsltException(Res.Xslt_NestedAvt, avt);
                    case '}' :
                        i ++; // include '}'
                        if(i == start + 2) { // empty XPathExpresion
                            throw new XsltException(Res.Xslt_EmptyAvtExpr, avt);
                        }
                        lex.Append(avt, start + 1, i - start - 2); // avt without {}
                        start = i;
                        return;
                    case '\'' :
                        state = InLiteralA;
                        break;
                    case '"' :
                        state = InLiteralQ;
                        break;
                    }
                    break;
                case InLiteralA :
                    if (ch == '\'') {
                        state = InExp;
                    }
                    break;
                case InLiteralQ :
                    if (ch == '"') {
                        state = InExp;
                    }
                    break;
                }
            }

            // if we meet end of string before } we have an error
            throw new XsltException(state == InExp ? Res.Xslt_OpenBracesAvt : Res.Xslt_OpenLiteralAvt, avt);
        }

        private static bool GetNextAvtLex(string avt, ref int start, StringBuilder lex, out bool isAvt) {
            Debug.Assert(start <= avt.Length);
#if DEBUG
            int saveStart = start;
#endif
            isAvt = false;
            if (start == avt.Length) {
                return false;
            }
            lex.Length = 0;
            getTextLex(avt, ref start, lex);
            if(lex.Length == 0) {
                isAvt = true;
                getXPathLex(avt, ref start, lex);
            }
#if DEBUG
            Debug.Assert(saveStart < start, "We have to read something. Otherwise it's dead loop.");
#endif
            return true;
        }

        internal ArrayList CompileAvt(string avtText, out bool constant) {
            Debug.Assert(avtText != null);
            ArrayList list = new ArrayList();

            constant = true;
            /* Parse input.Value as AVT */ {
                int  pos = 0;
                bool isAvt;
                while (GetNextAvtLex(avtText, ref pos, this.AvtStringBuilder, out isAvt)) {
                    string lex = this.AvtStringBuilder.ToString();
                    if (isAvt) {
                        list.Add(new AvtEvent(this.AddStringQuery(lex)));
                        constant = false;
                    }
                    else {
                        list.Add(new TextEvent(lex));
                    }
                }
            }
            if(constant) {
                Debug.Assert(list.Count <= 1, "We can't have more then 1 text event if now {avt} found");
            }
            return list;
        }

        internal ArrayList CompileAvt(string avtText) {
            bool constant;
            return CompileAvt(avtText, out constant);
        }

        internal static string[] SplitString(string source) {
            Debug.Assert(source != null);
            string[] array = source.Split(null);

            int realLength = 0; {
                for (int i = 0; i < array.Length; i++) {
                    if (array[i].Length != 0) {
                        realLength ++;
                    }
                }
            }
            if (realLength == array.Length) {
                return array;
            }

            string[] realArray = new string[realLength]; {
                int realPos = 0;
                for (int i = 0; i < array.Length; i++) {
                    if (array[i].Length != 0) {
                        realArray[realPos ++] = array[i];
                    }
                }
                Debug.Assert(realPos == realLength);
            }
            return realArray;
        }

        // Compiler is a class factory for some actions:
        // CompilerDbg override all this methods:

        public virtual ApplyImportsAction CreateApplyImportsAction() {
            ApplyImportsAction action = new ApplyImportsAction();
            action.Compile(this);
            return action;
        }

        public virtual ApplyTemplatesAction CreateApplyTemplatesAction() {
            ApplyTemplatesAction action = new ApplyTemplatesAction();
            action.Compile(this);
            return action;
        }

        public virtual AttributeAction CreateAttributeAction() {
            AttributeAction action = new AttributeAction();
            action.Compile(this);
            return action;
        }

        public virtual AttributeSetAction CreateAttributeSetAction() {
            AttributeSetAction action = new AttributeSetAction();
            action.Compile(this);
            return action;
        }

        public virtual CallTemplateAction CreateCallTemplateAction() {
            CallTemplateAction action = new CallTemplateAction();
            action.Compile(this);
            return action;
        }

        public virtual ChooseAction CreateChooseAction() {//!!! don't need to be here
            ChooseAction action = new ChooseAction();
            action.Compile(this);
            return action;
        }

        public virtual CommentAction CreateCommentAction() {
            CommentAction action = new CommentAction();
            action.Compile(this);
            return action;
        }

        public virtual CopyAction CreateCopyAction() {
            CopyAction action = new CopyAction();
            action.Compile(this);
            return action;
        }

        public virtual CopyOfAction CreateCopyOfAction() {
            CopyOfAction action = new CopyOfAction();
            action.Compile(this);
            return action;
        }

        public virtual ElementAction CreateElementAction() {
            ElementAction action = new ElementAction();
            action.Compile(this);
            return action;
        }

        public virtual ForEachAction CreateForEachAction() {
            ForEachAction action = new ForEachAction();
            action.Compile(this);
            return action;
        }

        public virtual IfAction CreateIfAction(IfAction.ConditionType type) {
            IfAction action = new IfAction(type);
            action.Compile(this);
            return action;
        }

        public virtual MessageAction CreateMessageAction() {
            MessageAction action = new MessageAction();
            action.Compile(this);
            return action;
        }

        public virtual NewInstructionAction CreateNewInstructionAction() {
            NewInstructionAction action = new NewInstructionAction();
            action.Compile(this);
            return action;
        }

        public virtual NumberAction CreateNumberAction() {
            NumberAction action = new NumberAction();
            action.Compile(this);
            return action;
        }

        public virtual ProcessingInstructionAction CreateProcessingInstructionAction() {
            ProcessingInstructionAction action = new ProcessingInstructionAction();
            action.Compile(this);
            return action;
        }

        public virtual void CreateRootAction() {
            this.RootAction = new RootAction();
            this.RootAction.Compile(this);
        }

        public virtual SortAction CreateSortAction() {
            SortAction action = new SortAction();
            action.Compile(this);
            return action;
        }

        public virtual TemplateAction CreateTemplateAction() {
            TemplateAction action = new TemplateAction();
            action.Compile(this);
            return action;
        }

        public virtual TemplateAction CreateSingleTemplateAction() {
            TemplateAction action = new TemplateAction();
            action.CompileSingle(this);
            return action;
        }

        public virtual TextAction CreateTextAction() {
            TextAction action = new TextAction();
            action.Compile(this);
            return action;
        }

        public virtual UseAttributeSetsAction CreateUseAttributeSetsAction() {
            UseAttributeSetsAction action = new UseAttributeSetsAction();
            action.Compile(this);
            return action;
        }

        public virtual ValueOfAction CreateValueOfAction() {
            ValueOfAction action = new ValueOfAction();
            action.Compile(this);
            return action;
        }

        public virtual VariableAction CreateVariableAction(VariableType type) {
            VariableAction action = new VariableAction(type);
            action.Compile(this);
            if ( action.VarKey != InvalidQueryKey ) {
                return action;
            }
            else {
                return null;
            }
        }

        public virtual WithParamAction CreateWithParamAction() {
            WithParamAction action = new WithParamAction();
            action.Compile(this);
            return action;
        }

        // Compiler is a class factory for some events:
        // CompilerDbg override all this methods:

        public virtual BeginEvent CreateBeginEvent() {
            return new BeginEvent(this);
        }

        public virtual TextEvent CreateTextEvent() {
            return new TextEvent(this);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\event.cs ===
//------------------------------------------------------------------------------
// <copyright file="Event.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;
    using System.Xml.Xsl.Debugger;

    internal abstract class Event {
        public virtual void ReplaceNamespaceAlias(Compiler compiler) {}        
        public abstract bool Output(Processor processor, ActionFrame frame);

        internal void OnInstructionExecute(Processor processor) {
            Debug.Assert(processor.Debugger != null, "We don't generate calls this function if ! debugger");
            Debug.Assert(DbgData.StyleSheet != null, "We call this function from *EventDbg only");
            processor.OnInstructionExecute();
        }

        internal virtual DbgData DbgData { get { return DbgData.Empty; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\htmlprops.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlProps.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Diagnostics;
    using System.Xml;
    using System.Globalization;

    internal class HtmlElementProps {
        private bool   empty;
        private bool   abrParent;
        private bool   uriParent;
        private bool   noEntities;
        private bool   blockWS;
        private bool   head;
        private bool   nameParent;

        static public HtmlElementProps Create(bool empty, bool abrParent, bool uriParent, bool noEntities, bool blockWS, bool head, bool nameParent) {
            HtmlElementProps props = new HtmlElementProps();
            props.empty      = empty     ;
            props.abrParent  = abrParent ;
            props.uriParent  = uriParent ;
            props.noEntities = noEntities;
            props.blockWS    = blockWS   ;
            props.head       = head      ;
            props.nameParent = nameParent;
            return props;
        }
        public bool   Empty      { get { return this.empty     ; } }
        public bool   AbrParent  { get { return this.abrParent ; } }
        public bool   UriParent  { get { return this.uriParent ; } }
        public bool   NoEntities { get { return this.noEntities; } }
        public bool   BlockWS    { get { return this.blockWS   ; } }
        public bool   Head       { get { return this.head      ; } }
        public bool   NameParent { get { return this.nameParent; } }


        static private Hashtable         s_table = CtreatePropsTable();
//        static private HtmlElementProps  s_otherElements = Create(false, false, false, false, false, false, false);

        static public  HtmlElementProps GetProps(string name) {
            HtmlElementProps result = (HtmlElementProps) s_table[name];
            return result;
            // We can do this but in case of Xml/Html mixed output this doesn't have big sence.
//            return result != null ?  result : s_otherElements;            
        }

        static Hashtable CtreatePropsTable() {
            bool o = false, X = true;
            Hashtable table = new Hashtable(71, new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture)); {
                //                                EMPTY    ABR     URI    NO_ENT  NO_WS   HEAD   NAME
                table.Add( "a"          , Create(   o   ,   o   ,   X   ,   o   ,   o  ,   o  ,   X   ) );
                table.Add( "address"    , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "applet"     , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "area"       , Create(   X   ,   X   ,   X   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "base"       , Create(   X   ,   o   ,   X   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "basefont"   , Create(   X   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "blockquote" , Create(   o   ,   o   ,   X   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "body"       , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "br"         , Create(   X   ,   o   ,   o   ,   o   ,   o  ,   o  ,   o   ) );
                table.Add( "button"     , Create(   o   ,   X   ,   o   ,   o   ,   o  ,   o  ,   o   ) );
                table.Add( "caption"    , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "center"     , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "col"        , Create(   X   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "colgroup"   , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "dd"         , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "del"        , Create(   o   ,   o   ,   X   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "dir"        , Create(   o   ,   X   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "div"        , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "dl"         , Create(   o   ,   X   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "dt"         , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "fieldset"   , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "font"       , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "form"       , Create(   o   ,   o   ,   X   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "frame"      , Create(   X   ,   X   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "frameset"   , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "h1"         , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "h2"         , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "h3"         , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "h4"         , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "h5"         , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "h6"         , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "head"       , Create(   o   ,   o   ,   X   ,   o   ,   X  ,   X  ,   o   ) );
                table.Add( "hr"         , Create(   X   ,   X   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "html"       , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "iframe"     , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "img"        , Create(   X   ,   X   ,   X   ,   o   ,   o  ,   o  ,   o   ) );
                table.Add( "input"      , Create(   X   ,   X   ,   X   ,   o   ,   o  ,   o  ,   o   ) );
                table.Add( "ins"        , Create(   o   ,   o   ,   X   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "isindex"    , Create(   X   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "legend"     , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "li"         , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "link"       , Create(   X   ,   o   ,   X   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "map"        , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "menu"       , Create(   o   ,   X   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "meta"       , Create(   X   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "noframes"   , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "noscript"   , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "object"     , Create(   o   ,   X   ,   X   ,   o   ,   o  ,   o  ,   o   ) );
                table.Add( "ol"         , Create(   o   ,   X   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "optgroup"   , Create(   o   ,   X   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "option"     , Create(   o   ,   X   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "p"          , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "param"      , Create(   X   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "pre"        , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "q"          , Create(   o   ,   o   ,   X   ,   o   ,   o  ,   o  ,   o   ) );
                table.Add( "s"          , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "script"     , Create(   o   ,   X   ,   X   ,   X   ,   o  ,   o  ,   o   ) );
                table.Add( "select"     , Create(   o   ,   X   ,   o   ,   o   ,   o  ,   o  ,   o   ) );
                table.Add( "strike"     , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "style"      , Create(   o   ,   o   ,   o   ,   X   ,   X  ,   o  ,   o   ) );
                table.Add( "table"      , Create(   o   ,   o   ,   X   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "tbody"      , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "td"         , Create(   o   ,   X   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "textarea"   , Create(   o   ,   X   ,   o   ,   o   ,   o  ,   o  ,   o   ) );
                table.Add( "tfoot"      , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "th"         , Create(   o   ,   X   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "thead"      , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "title"      , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "tr"         , Create(   o   ,   o   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "ul"         , Create(   o   ,   X   ,   o   ,   o   ,   X  ,   o  ,   o   ) );
                table.Add( "xmp"        , Create(   o   ,   o   ,   o   ,   o   ,   o  ,   o  ,   o   ) );
            }
            return table;
        }
    }

    internal class HtmlAttributeProps {
        private bool   abr;
        private bool   uri;
        private bool   name;

        static public HtmlAttributeProps Create(bool abr, bool uri, bool name) {
            HtmlAttributeProps props = new HtmlAttributeProps();
            props.abr  = abr;
            props.uri  = uri;
            props.name = name;
            return props;
        }
        public bool   Abr  { get { return this.abr ; } }
        public bool   Uri  { get { return this.uri ; } }
        public bool   Name { get { return this.name; } }

        static private Hashtable         s_table = CtreatePropsTable();
//      static private HtmlElementProps  s_otherAttributes = Create(false, false, false);

        static public  HtmlAttributeProps GetProps(string name) {
            HtmlAttributeProps result = (HtmlAttributeProps) s_table[name];
            return result;
            // We can do this but in case of Xml/Html mixed output this doesn't have big sence.
//          return result != null ?  result : s_otherElements;            
        }

        static Hashtable CtreatePropsTable() {
            bool o = false, X = true;
            Hashtable table = new Hashtable(26, new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture)); {
                //                               ABR     URI    NAME 
                table.Add( "action"   , Create(   o   ,   X  ,   o   ) );
                table.Add( "checked"  , Create(   X   ,   o  ,   o   ) );
                table.Add( "cite"     , Create(   o   ,   X  ,   o   ) );
                table.Add( "classid"  , Create(   o   ,   X  ,   o   ) );
                table.Add( "codebase" , Create(   o   ,   X  ,   o   ) );
                table.Add( "compact"  , Create(   X   ,   o  ,   o   ) );
                table.Add( "data"     , Create(   o   ,   X  ,   o   ) );
                table.Add( "datasrc"  , Create(   o   ,   X  ,   o   ) );
                table.Add( "declare"  , Create(   X   ,   o  ,   o   ) );
                table.Add( "defer"    , Create(   X   ,   o  ,   o   ) );
                table.Add( "disabled" , Create(   X   ,   o  ,   o   ) );
                table.Add( "for"      , Create(   o   ,   X  ,   o   ) );
                table.Add( "href"     , Create(   o   ,   X  ,   o   ) );
                table.Add( "ismap"    , Create(   X   ,   o  ,   o   ) );
                table.Add( "longdesc" , Create(   o   ,   X  ,   o   ) );
                table.Add( "multiple" , Create(   X   ,   o  ,   o   ) );
                table.Add( "name"     , Create(   o   ,   o  ,   X   ) );
                table.Add( "nohref"   , Create(   X   ,   o  ,   o   ) );
                table.Add( "noresize" , Create(   X   ,   o  ,   o   ) );
                table.Add( "noshade"  , Create(   X   ,   o  ,   o   ) );
                table.Add( "nowrap"   , Create(   X   ,   o  ,   o   ) );
                table.Add( "profile"  , Create(   o   ,   X  ,   o   ) );
                table.Add( "readonly" , Create(   X   ,   o  ,   o   ) );
                table.Add( "selected" , Create(   X   ,   o  ,   o   ) );
                table.Add( "src"      , Create(   o   ,   X  ,   o   ) );
                table.Add( "usemap"   , Create(   o   ,   X  ,   o   ) );
            }
            return table;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\foreachaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="ForEachAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.Xml;
    using System.Xml.XPath;

    internal class ForEachAction : ContainerAction {
        private const int    ProcessedSort     = 2;
        private const int    ProcessNextNode   = 3;
        private const int    PositionAdvanced  = 4;
        private const int    ContentsProcessed = 5;
        
        private string    select;
        private int       selectKey = Compiler.InvalidQueryKey;
        private ContainerAction sortContainer;

        internal override void Compile(Compiler compiler) {
            CompileAttributes(compiler);
            CheckRequiredAttribute(compiler, this.select, Keywords.s_Select);

            compiler.CanHaveApplyImports = false;
            if (compiler.Recurse()) {
                CompileSortElements(compiler);
                CompileTemplate(compiler);
                compiler.ToParent();
            }
        }

        internal override String Select {
            get { return this.select; }
        }
        
        internal override bool CompileAttribute(Compiler compiler) {
            string name   = compiler.Input.LocalName;
            string value  = compiler.Input.Value;
            if (Keywords.Equals(name, compiler.Atoms.Select)) {
                this.select    = value;
                this.selectKey = compiler.AddQuery(this.select);
                Debug.WriteLine("Select expression == \"" + this.select + "\" (#" + this.selectKey + ")");
            }
            else {
                return false;
            }

            return true;
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);

            switch (frame.State) {
            case Initialized:
                if (sortContainer != null) {
                    processor.InitSortArray();
                    processor.PushActionFrame(sortContainer, frame.NodeSet);
                    frame.State = ProcessedSort;
                    break;
                }
                goto case ProcessedSort; 
            case ProcessedSort:
                if (this.selectKey == Compiler.InvalidQueryKey) {
                    throw new XsltException(Res.Xslt_InvalidXPath,  new string[] { select });
                }
                frame.InitNewNodeSet(processor.StartQuery(frame.Node, this.selectKey));
                if (sortContainer != null) {
                    Debug.Assert(processor.SortArray.Count != 0);
                    frame.SortNewNodeSet(processor, processor.SortArray);
                }
                frame.State = ProcessNextNode;
                goto case ProcessNextNode;

            case ProcessNextNode:
                Debug.Assert(frame.State == ProcessNextNode);
                Debug.Assert(frame.NewNodeSet != null);

                Debug.WriteLine("Processing next Node");

                if (frame.NewNextNode(processor)) {
                    Debug.WriteLine("Node found");
                    frame.State = PositionAdvanced;
                    goto case PositionAdvanced;
                }
                else {
                    Debug.WriteLine("Node not found, finished ");

                    frame.Finished();
                    break;
                }

            case PositionAdvanced:
                processor.PushActionFrame(frame, frame.NewNodeSet);
                frame.State = ContentsProcessed;
                break;

            case ContentsProcessed:
                frame.State = ProcessNextNode;
                goto case ProcessNextNode;
            }
        }

        protected void CompileSortElements(Compiler compiler) {
            NavigatorInput input = compiler.Input;            
            do {
                switch(input.NodeType) {
                case XPathNodeType.Element:
                    if (Keywords.Equals(input.NamespaceURI, input.Atoms.XsltNamespace) &&
                        Keywords.Equals(input.LocalName, input.Atoms.Sort)) {
                        if (sortContainer == null) {
                            sortContainer = new ContainerAction();
                        }
                        sortContainer.AddAction(compiler.CreateSortAction());
                        continue;
                    }
                    return;
                case XPathNodeType.Text:
                    return;
                case XPathNodeType.SignificantWhitespace:
                    this.AddEvent(compiler.CreateTextEvent());
                    continue;
                default :
                    continue;
                }
            }
            while (input.Advance());
        }
        
        internal override void Trace(int tab) {
            Debug.Indent(tab);
            Debug.WriteLine("<xsl:for-each select=\"" + this.select + "(#" + this.selectKey + ")>");
            base.Trace(tab);
            Debug.Indent(tab);
            Debug.WriteLine("</xsl:for-each>");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\ifaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="IfAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class IfAction : ContainerAction {
        internal enum ConditionType {
            ConditionIf,
            ConditionWhen,
            ConditionOtherwise
        }

        private ConditionType   type;
        private int             testKey = Compiler.InvalidQueryKey;

        internal IfAction(ConditionType type) {
            this.type = type;
        }

        internal override void Compile(Compiler compiler) {
            CompileAttributes(compiler);
            if (this.type != ConditionType.ConditionOtherwise) {
                CheckRequiredAttribute(compiler, this.testKey != Compiler.InvalidQueryKey, Keywords.s_Test);
            }

            if (compiler.Recurse()) {
                CompileTemplate(compiler);
                compiler.ToParent();
            }
        }

        internal override bool CompileAttribute(Compiler compiler) {
            string name   = compiler.Input.LocalName;
            string value  = compiler.Input.Value;
            if (Keywords.Equals(name, compiler.Atoms.Test)) {
                if (this.type == ConditionType.ConditionOtherwise) {
                    return false;
                }
                this.testKey = compiler.AddBooleanQuery(value);

                Debug.WriteLine("Test condition == \"" + this.testKey + "\"");
            }
            else {
                return false;
            }

            return true;
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);

            switch (frame.State) {
            case Initialized:
                if (this.type == ConditionType.ConditionIf || this.type == ConditionType.ConditionWhen) {
                    Debug.Assert(this.testKey != Compiler.InvalidQueryKey);
                    bool value = processor.EvaluateBoolean(frame, this.testKey);
                    if (value == false) {
                        frame.Finished();
                        break;
                    }
                }

                processor.PushActionFrame(frame);
                frame.State = ProcessingChildren;
                break;                              // Allow children to run

            case ProcessingChildren:
                if (this.type == ConditionType.ConditionWhen ||this.type == ConditionType.ConditionOtherwise) {
                    Debug.Assert(frame.Container != null);
                    frame.Exit();
                }

                frame.Finished();
                break;

            default:
                Debug.Fail("Invalid IfAction execution state");
        		break;
            }
        }

        internal override void Trace(int tab) {
            Debug.Indent(tab);
            switch (this.type) {
            case ConditionType.ConditionIf:
                Debug.WriteLine("<xsl:if test=\"" + this.testKey + "\">");
                base.Trace(tab + 1);
                Debug.WriteLine("</xsl:if>");
                break;
            case ConditionType.ConditionWhen:
                Debug.WriteLine("<xsl:when test=\"" + this.testKey + "\">");
                base.Trace(tab + 1);
                Debug.WriteLine("</xsl:when>");
                break;
            case ConditionType.ConditionOtherwise:
                Debug.WriteLine("<xsl:otherwise>");
                base.Trace(tab + 1);
                Debug.WriteLine("</xsl:otherwise>");
                break;
            }
            Debug.Indent(tab);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\inputscope.cs ===
//------------------------------------------------------------------------------
// <copyright file="InputScope.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;
    using System.Collections;

    internal class InputScope : DocumentScope {
        private InputScope      parent;
        private bool            forwardCompatibility;
        private bool            canHaveApplyImports;
        private Hashtable       variables;
        private Hashtable       extensionNamespaces;
        private Hashtable       excludedNamespaces;
       
        internal InputScope Parent {
            get { return this.parent; }
        }

        internal Hashtable Variables {
            get { return this.variables; }
        }
        
        internal bool ForwardCompatibility {
            get { return this.forwardCompatibility; }
            set { this.forwardCompatibility = value; }
        }

        internal bool CanHaveApplyImports {
            get { return this.canHaveApplyImports; }
            set { this.canHaveApplyImports = value; }
        }

        internal InputScope(InputScope parent) {
            Init(parent);
        }

        internal void Init(InputScope parent) {
            this.scopes = null;
            this.parent = parent;

            if (this.parent != null) {
                this.forwardCompatibility = this.parent.forwardCompatibility;
                this.canHaveApplyImports  = this.parent.canHaveApplyImports;
            }
        }

        internal void InsertExtensionNamespace(String nspace) {
            if (this.extensionNamespaces == null ) {
                this.extensionNamespaces = new Hashtable();
            }
            this.extensionNamespaces[nspace] = null;
        }
        
        internal bool IsExtensionNamespace(String nspace) {
            if (extensionNamespaces == null ) {
                return false;
            }
            return extensionNamespaces.Contains(nspace);
        }
        
        internal void InsertExcludedNamespace(String nspace) {
            if (this.excludedNamespaces == null ) {
                this.excludedNamespaces = new Hashtable();
            }
            this.excludedNamespaces[nspace] = null;
        }

        internal bool IsExcludedNamespace(String nspace) {
            if (excludedNamespaces == null ) {
                return false;
            }
            return excludedNamespaces.Contains(nspace);
        }
        
        internal void InsertVariable(VariableAction variable) {
            Debug.Assert(variable != null);

            if (this.variables == null) {
                this.variables = new Hashtable();
            }
            this.variables[variable.Name] = variable;
        }
        
        internal int GetVeriablesCount() {
            if (this.variables == null) {
                return 0;
            }
            return this.variables.Count;
        }

        public VariableAction ResolveVariable(XmlQualifiedName qname) {
            for (InputScope inputScope = this; inputScope != null; inputScope = inputScope.Parent) {
                if (inputScope.Variables != null) {
                    VariableAction variable = (VariableAction) inputScope.Variables[qname];
                    if(variable != null) {
                        return variable;
                    }
                }
            }
            return null;
        }

        public VariableAction ResolveGlobalVariable(XmlQualifiedName qname) {
            InputScope prevScope = null;
            for (InputScope inputScope = this; inputScope != null; inputScope = inputScope.Parent) {
                prevScope = inputScope;
            }
            return prevScope.ResolveVariable(qname);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\messageaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.IO;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class MessageAction : ContainerAction {
        bool _Terminate;

        internal override void Compile(Compiler compiler) {
            CompileAttributes(compiler);

            if (compiler.Recurse()) {
                CompileTemplate(compiler);
                compiler.ToParent();
            }
        }

        internal override bool CompileAttribute(Compiler compiler) {
            string name   = compiler.Input.LocalName;
            string value  = compiler.Input.Value;
            if (Keywords.Equals(name, compiler.Atoms.Terminate)) {
                _Terminate = compiler.GetYesNo(value);
                Debug.WriteLine("Message terminate == \"" + _Terminate + "\"");
            }
            else {
                return false;
            }

            return true;
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);
            switch (frame.State) {
            case Initialized:
                TextOnlyOutput output = new TextOnlyOutput(processor, new StringWriter());
                processor.PushOutput(output);
                processor.PushActionFrame(frame);
                frame.State = ProcessingChildren;
                break;

            case ProcessingChildren:
                TextOnlyOutput recOutput = processor.PopOutput() as TextOnlyOutput;
                Debug.Assert(recOutput != null);
                Console.WriteLine(recOutput.Writer.ToString());

                if (_Terminate) {
                    throw new XsltException(Res.Xslt_Terminate, recOutput.Writer.ToString());
                }
                frame.Finished();
                break;
            
            default:
                Debug.Fail("Invalid MessageAction execution state");
                break;
            }
        }

        internal override void Trace(int tab) {
            Debug.Indent(tab);
            Debug.WriteLine("<xsl:message terminate=\"" + _Terminate + "\">");
            base.Trace(tab);
            Debug.Indent(tab);
            Debug.WriteLine("</xsl:message>");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\inputscopemanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="InputScopeManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {

    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    /// <include file='doc\InputScopeManager.uex' path='docs/doc[@for="InputScopeManager"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal class InputScopeManager  {
        private InputScope     scopeStack;
        private string         defaultNS = string.Empty;
        private XPathNavigator navigator;    // We need this nsvigator for document() function implementation

        public InputScopeManager(XPathNavigator navigator, InputScope rootScope) {
            this.navigator = navigator;
            this.scopeStack = rootScope;
        }

        internal InputScope CurrentScope {
            get {  return this.scopeStack;  }
        }

        internal InputScope VariableScope {
            get {
                Debug.Assert(this.scopeStack != null);
                Debug.Assert(this.scopeStack.Parent != null);
                return this.scopeStack.Parent;
            }
        }

        internal InputScopeManager Clone() {
            InputScopeManager manager = new InputScopeManager(this.navigator, null); 
            manager.scopeStack = this.scopeStack;
            manager.defaultNS  = this.defaultNS;
            return manager;
        }

        public XPathNavigator Navigator {
            get {return this.navigator;}
        }

        internal InputScope PushScope() {
            this.scopeStack = new InputScope(this.scopeStack);
            return this.scopeStack;
        }

        internal void PopScope() {
            Debug.Assert(this.scopeStack != null, "Push/Pop disbalance");
            if (this.scopeStack == null) {
                return;
            }

            for (NamespaceDecl scope = this.scopeStack.Scopes; scope != null; scope = scope.Next) {
                Debug.WriteLine("Popping namespace scope : " + scope.Prefix + " : " + scope.Uri);
                this.defaultNS = scope.PrevDefaultNsUri;
            }

            this.scopeStack = this.scopeStack.Parent;
        }

        internal void PushNamespace(string prefix, string nspace) {
            Debug.Assert(this.scopeStack != null, "PushScope wasn't called");
            Debug.Assert(prefix != null);
            Debug.Assert(nspace != null);
            this.scopeStack.AddNamespace(prefix, nspace, this.defaultNS);

            if (prefix == null || prefix.Length == 0) {
                this.defaultNS = nspace;
            }
        }

        // CompileContext

        public string DefaultNamespace {
            get {return this.defaultNS;}
        }

        private string ResolveNonEmptyPrefix(string prefix) {
            Debug.Assert(this.scopeStack != null, "PushScope wasn't called");
            Debug.Assert(prefix != null || prefix != string.Empty);
            if (prefix == Keywords.s_Xml) {
                return Keywords.s_XmlNamespace;
            }
            else if (prefix == Keywords.s_Xmlns) {
                return Keywords.s_XmlnsNamespace;
            }

            for (InputScope inputScope = this.scopeStack; inputScope != null; inputScope = inputScope.Parent) {
                string nspace = inputScope.ResolveNonAtom(prefix);
                if (nspace != null) {
                    return nspace;
                }
            }
            throw new XsltException(Res.Xslt_InvalidPrefix, prefix);
        }

        /// <include file='doc\InputScopeManager.uex' path='docs/doc[@for="InputScopeManager.ResolveNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ResolveXmlNamespace(string prefix) {
            Debug.Assert(prefix != null);
            if (prefix.Length == 0) {
                return this.defaultNS;
            }
            return ResolveNonEmptyPrefix(prefix);
        }
        
        public string ResolveXPathNamespace(string prefix) {
            Debug.Assert(prefix != null);
            if (prefix.Length == 0) {
                return string.Empty;
            }
            return ResolveNonEmptyPrefix(prefix);
        }
        
        internal void InsertExtensionNamespace(String nspace) {
            Debug.Assert(this.scopeStack != null, "PushScope wasn't called");
            this.scopeStack.InsertExtensionNamespace( nspace );
        }
        
        internal bool IsExtensionNamespace(String nspace) {
            Debug.Assert(this.scopeStack != null, "PushScope wasn't called");
            for (InputScope inputScope = this.scopeStack; inputScope != null; inputScope = inputScope.Parent) {
                if (inputScope.IsExtensionNamespace( nspace )) {
                    return true;
                }
            }
            return false;
        }
        
        internal void InsertExcludedNamespace(String nspace) {
            Debug.Assert(this.scopeStack != null, "PushScope wasn't called");
            this.scopeStack.InsertExcludedNamespace( nspace );
        }

        internal bool IsExcludedNamespace(String nspace) {
            Debug.Assert(this.scopeStack != null, "PushScope wasn't called");
            for (InputScope inputScope = this.scopeStack; inputScope != null; inputScope = inputScope.Parent) {
                if (inputScope.IsExcludedNamespace( nspace )) {
                    return true;
                }
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\namespacedecl.cs ===
//------------------------------------------------------------------------------
// <copyright file="NamespaceDecl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {

using System;
using System.Xml;

internal class NamespaceDecl {
    private string        prefix;
    private string        nsUri;
    private string        prevDefaultNsUri;
    private NamespaceDecl next;

    internal string Prefix {
        get { return this.prefix; }
    }

    internal string Uri {
        get { return this.nsUri; }
    }

    internal string PrevDefaultNsUri {
        get { return this.prevDefaultNsUri; }
    }

    internal NamespaceDecl Next {
        get { return this.next; }
    }

    internal NamespaceDecl(string prefix, string nsUri, string prevDefaultNsUri, NamespaceDecl next) {
        Init(prefix, nsUri, prevDefaultNsUri, next);
    }

    internal void Init(string prefix, string nsUri, string prevDefaultNsUri, NamespaceDecl next) {
        this.prefix           = prefix;
        this.nsUri            = nsUri;
        this.prevDefaultNsUri = prevDefaultNsUri;
        this.next             = next;
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\namespaceevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="NameSpaceEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class NamespaceEvent : Event {
        private string namespaceUri;
        private string name;
        
        public NamespaceEvent(NavigatorInput input) {
            Debug.Assert(input != null);
            Debug.Assert(input.NodeType == XPathNodeType.Namespace);
            this.namespaceUri = input.Value;
            this.name         = input.LocalName;
        }

        public override void ReplaceNamespaceAlias(Compiler compiler){
            if (this.namespaceUri != String.Empty) { // Do we need to check this for namespace?
                NamespaceInfo ResultURIInfo = compiler.FindNamespaceAlias(this.namespaceUri);
                if (ResultURIInfo != null) {
                    this.namespaceUri = ResultURIInfo.nameSpace;
                    if (ResultURIInfo.prefix != null) {
                        this.name = ResultURIInfo.prefix;
                    }
                }
            }
        }
        
        public override bool Output(Processor processor, ActionFrame frame) {
            bool res;
            res = processor.BeginEvent(XPathNodeType.Namespace, /*prefix:*/null, this.name, this.namespaceUri, /*empty:*/false);
            Debug.Assert(res); // Namespace node as any other attribute can't fail because it doesn't signal record change
            res = processor.TextEvent(this.namespaceUri);
            Debug.Assert(res);
            res = processor.EndEvent(XPathNodeType.Namespace);
            Debug.Assert(res);
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\navigatoroutput.cs ===
//------------------------------------------------------------------------------
// <copyright file="NavigatorOutput.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {

    using System;
    using System.Xml;
    using System.Xml.XPath;

    internal class NavigatorOutput : RecordOutput {
        protected XPathDocument doc;
        protected XPathContainer node;
        private int documentIndex;
        
        internal XPathNavigator Navigator {
            get { return ((IXPathNavigable)doc).CreateNavigator(); }
        }

        internal NavigatorOutput() {
            doc = new XPathDocument();
            node = doc.root;
        }

        public Processor.OutputResult RecordDone(RecordBuilder record) {
            Debug.Assert(record != null);

            BuilderInfo mainNode = record.MainNode;
            documentIndex++;
            mainNode.LocalName  = doc.nt.Add(mainNode.LocalName);
            mainNode.NamespaceURI   = doc.nt.Add(mainNode.NamespaceURI);
            switch(mainNode.NodeType) {
                case XmlNodeType.Element: {                    
                    XPathElement e = mainNode.IsEmptyTag ? 
                        new XPathEmptyElement(mainNode.Prefix, mainNode.LocalName, mainNode.NamespaceURI, 0, 0, node.topNamespace, documentIndex) :
                        new XPathElement(     mainNode.Prefix, mainNode.LocalName, mainNode.NamespaceURI, 0, 0, node.topNamespace, documentIndex)
                    ;
                    node.AppendChild( e );

                    XPathNamespace last = null;
                    for (int attrib = 0; attrib < record.AttributeCount; attrib ++) {
                        documentIndex++;
                        Debug.Assert(record.AttributeList[attrib] is BuilderInfo);
                        BuilderInfo attrInfo = (BuilderInfo) record.AttributeList[attrib];
                        if (attrInfo.NamespaceURI == Keywords.s_XmlnsNamespace) {
                            XPathNamespace tmp = new XPathNamespace(attrInfo.Prefix == string.Empty ? string.Empty : attrInfo.LocalName, attrInfo.Value, documentIndex);
                            tmp.next = last;
                            last = tmp;
                        }
                        else {
                            e.AppendAttribute( new XPathAttribute( attrInfo.Prefix, attrInfo.LocalName, attrInfo.NamespaceURI, attrInfo.Value, documentIndex ) );
                        }
                    }

                    if (last != null) {
                        e.AppendNamespaces(last);
                    }

                    if (!mainNode.IsEmptyTag) {
                        node = e;
                    }
                    break;
                }

                case XmlNodeType.Text:
                case XmlNodeType.Whitespace:
                case XmlNodeType.SignificantWhitespace:
                    node.AppendChild( new XPathText( mainNode.Value, 0, 0, documentIndex ) );
                    break;

                case XmlNodeType.ProcessingInstruction:
                    node.AppendChild( new XPathProcessingInstruction( mainNode.LocalName, mainNode.Value, documentIndex ) );
                    break;

                case XmlNodeType.Comment:
                    node.AppendChild( new XPathComment( mainNode.Value, documentIndex ) );
                    break;

                case XmlNodeType.Document:
                    break;

                case XmlNodeType.EndElement:
                    node = node.parent;
                    break;

                default:
                    Debug.Fail("Invalid NodeType on output: " + mainNode.NodeType.ToString());
                    break;
            }

            record.Reset();
            return Processor.OutputResult.Continue;
        }

        public void TheEnd() {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\numberaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="NumberAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Text;
    using System.Globalization;
    using System.Collections;
    using System.Xml;
    using System.Xml.XPath;

    internal class NumberAction : ContainerAction {
    // Numbering formats:
        enum MSONFC {
            msonfcNil = -1,

            msonfcFirstNum,
            msonfcArabic = msonfcFirstNum,      // 0x0031 -- 1, 2, 3, 4, ...
            msonfcDArabic,                      // 0xff11 -- Combines DbChar w/ Arabic
            msonfcHindi3,                       // 0x0967 -- Hindi numbers
            msonfcThai2,                        // 0x0e51 -- Thai numbers
            msonfcFEDecimal,                    // 0x4e00 -- FE numbering style (    decimal numbers)
            msonfcKorDbNum1,                    // 0xc77c -- Korea (decimal)
            msonfcLastNum = msonfcKorDbNum1,

            // Alphabetic numbering sequences (do not change order unless you also change _rgnfcToLab's order)
            msonfcFirstAlpha,
            msonfcUCLetter = msonfcFirstAlpha,  // 0x0041 -- A, B, C, D, ...
            msonfcLCLetter,                     // 0x0061 -- a, b, c, d, ...
            msonfcUCRus,                        // 0x0410 -- Upper case Russian     alphabet
            msonfcLCRus,                        // 0x0430 -- Lower case Russian    alphabet
            msonfcThai1,                        // 0x0e01 -- Thai letters
            msonfcHindi1,                       // 0x0915 -- Hindi vowels
            msonfcHindi2,                       // 0x0905 -- Hindi consonants
            msonfcAiueo,                        // 0xff71 -- Japan numbering style (    SbChar)
            msonfcDAiueo,                       // 0x30a2 -- Japan - Combines DbChar w    / Aiueo
            msonfcIroha,                        // 0xff72 -- Japan numbering style (   SbChar)
            msonfcDIroha,                       // 0x30a4 -- Japan - Combines DbChar w    / Iroha//  New defines for 97...
            msonfcDChosung,                     // 0x3131 -- Korea Chosung (DbChar)
            msonfcGanada,                       // 0xac00 -- Korea
            msonfcArabicScript,                 // 0x0623 -- BIDI AraAlpha for Arabic/    Farsi/Urdu
            msonfcLastAlpha = msonfcArabicScript,

            // Special numbering sequences (includes peculiar alphabetic and numeric    sequences)
            msonfcFirstSpecial,
            msonfcUCRoman = msonfcFirstSpecial, // 0x0049 -- I, II, III, IV, ...
            msonfcLCRoman,                      // 0x0069 -- i, ii, iii, iv, ...
            msonfcHebrew,                       // 0x05d0 -- BIDI Heb1 for Hebrew 
            msonfcDbNum3,                       // 0x58f1 -- FE numbering style (    similar to China2, some different characters)
            msonfcChnCmplx,                     // 0x58f9 -- China (complex,     traditional chinese, spell out numbers)
            msonfcKorDbNum3,                    // 0xd558 -- Korea (1-99)
            msonfcZodiac1,                      // 0x7532 -- China (10 numbers)
            msonfcZodiac2,                      // 0x5b50 -- China (12 numbers)
            msonfcZodiac3,                      // 0x7532 -- China (Zodiac1 +     Zodiac2)        
            msonfcLastSpecial = msonfcZodiac3
        } 

        bool isDecimalNFC(MSONFC msonfc) {
            Debug.Assert(MSONFC.msonfcFirstNum <= msonfc && msonfc <= MSONFC.msonfcLastSpecial);
            return msonfc <= MSONFC.msonfcLastNum;
        }

        const long msofnfcNil  =            0x00000000;     // no flags
        const long msofnfcTraditional =     0x00000001;     // use traditional numbering
        const long msofnfcAlwaysFormat =    0x00000002;     // if requested format is not supported, use Arabic (Western) style

    // Core, central use functions
        const int cchMaxFormat        = 63 ;     // max size of formatted result
        const int cchMaxFormatDecimal = 11  ;    // max size of formatted decimal result (doesn't handle the case of a very large pwszSeparator or minlen)

        class FormatInfo {
            internal bool   _fIsSeparator;    // False for alphanumeric strings of chars
            internal MSONFC _numberingType;   // Specify type of numbering
            internal int    _cMinLen;         // Minimum length of decimal numbers (if necessary, pad to left with zeros)
            internal String _wszSeparator;    // Pointer to separator token

            internal FormatInfo(bool IsSeparator, String wszSeparator) {
                _fIsSeparator = IsSeparator;
                _wszSeparator = wszSeparator;
            }

            internal FormatInfo(){}
        }

        static FormatInfo DefaultFormat    = new FormatInfo(false, "0");
        static FormatInfo DefaultSeparator = new FormatInfo(true , ".");
        
        class NumberingFormat {
            static readonly char[] upperCaseLetter = {'Z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y'};
            static readonly char[] lowerCaseLetter = {'z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y'};
   
            internal NumberingFormat(){}

            internal void setNumberingType(MSONFC nfc) {_nfc = nfc;}
            //void setLangID(LID langid) {_langid = langid;}
            //internal void setTraditional(bool fTraditional) {_grfnfc = fTraditional ? msofnfcTraditional : 0;}
            internal void setMinLen(double cMinLen) {_cMinLen = cMinLen;}
            internal void setGroupingSeparator(String  sSeparator) {_pwszSeparator = sSeparator;}
            internal void setGroupingSize(int sizeGroup) {_sizeGroup = sizeGroup;}

            static void AlphabeticNumber(StringBuilder builder, char[] letters, double number) {
                if (number <= 0) {
                    return;
                }
                int rem = (int) number % 26;
                AlphabeticNumber(builder, letters, (int) number / 27);
                builder.Append(letters[rem]); 
            }
        
            internal String format(double iVal){
                String result = null;

                switch (_nfc) {
                case MSONFC.msonfcUCLetter :
                    StringBuilder builder = new StringBuilder();
                    AlphabeticNumber(builder, upperCaseLetter, iVal);                   
                    return builder.ToString();
                case MSONFC.msonfcLCLetter :
                    builder = new StringBuilder();    
                    AlphabeticNumber(builder, lowerCaseLetter, iVal);                   
                    return builder.ToString();
                case MSONFC.msonfcArabic :
                    int[] array = {_sizeGroup};
                    StringBuilder format = new StringBuilder();
                    String str = null;
                    
                    if (array != null && _pwszSeparator != null ) {
                        NumberFormatInfo NumberFormat = new NumberFormatInfo();
                        NumberFormat.NumberGroupSizes = array;
                        NumberFormat.NumberGroupSeparator = _pwszSeparator;
                        if ((int) iVal == iVal) {
                            NumberFormat.NumberDecimalDigits = 0;
                        }
                        str = iVal.ToString("N",NumberFormat);
                    }
                    else {
                        str = Convert.ToString(iVal);
                    }
                    for(int i = 0; i < _cMinLen - str.Length; i++) {
                        format.Append('0');
                    }
                    format.Append(str);
                    result = format.ToString();
                    break;
                case MSONFC.msonfcFEDecimal :
                    int[] array1 = {_sizeGroup};
                    Decimal number = new Decimal(iVal);
                    StringBuilder format1 = new StringBuilder();
                    for(int i = 0; i < _cMinLen; i++) {
                        format1.Append('0');
                    }
                    if (array1 != null && _pwszSeparator != null ) {
                        NumberFormatInfo NumberFormat = new NumberFormatInfo();
                        NumberFormat.NumberGroupSizes = array1;
                        NumberFormat.NumberGroupSeparator = _pwszSeparator;
                        if ((int) iVal == iVal) {
                            NumberFormat.NumberDecimalDigits = 0;
                        }
                        format1.Append(number.ToString("N",NumberFormat));
                    }
                    else {
                        format1.Append(Convert.ToString(number));
                    }
                    result = format1.ToString();
                    break;
                case MSONFC.msonfcUCRoman :
                    return ConvertToRoman(iVal, true);
                case MSONFC.msonfcLCRoman:
                    return ConvertToRoman(iVal, false);
                default :
                    result = Convert.ToString(iVal);
                    break;
                }
                return result;
            }

            MSONFC _nfc;
            //LID _langid;
            //double _grfnfc;
            double _cMinLen;
            String _pwszSeparator;
            int _sizeGroup;
            //String _rgwchDest; // Must be last field

            // R O M A N  N U M E R A L S * * *

            static String[] rgwchUCRoman = new String[]{ "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX" , "X","C", "D", "M"};

            static String[] rgwchLCRoman = new String[]{ "i", "ii", "iii", "iv", "v", "vi", "vii", "viii","ix","x", "c", "d", "m"};
               
            const int RomanThousand    = 12;
            const int RomanFiveHundred = 11;
            const int RomanHundred     = 10;
            const int RomanTen         = 9;
            const int nMaxRoman        = 32767;    
            const int nMinRoman        = 1;

            static String ConvertToRoman(double iVal, bool UC) {
                if (iVal < nMinRoman || iVal > nMaxRoman) {
                    return String.Empty;
                }
                StringBuilder result = new StringBuilder();
                String chm, chd, chc, chx;
            
                int remainder = 0;
                if (UC) {
                   chm = rgwchUCRoman[RomanThousand];
                   chd = rgwchUCRoman[RomanFiveHundred]; 
                   chc = rgwchUCRoman[RomanHundred]; 
                   chx = rgwchUCRoman[RomanTen]; 
                }
                else {
                   chm = rgwchLCRoman[RomanThousand];
                   chd = rgwchLCRoman[RomanFiveHundred]; 
                   chc = rgwchLCRoman[RomanHundred];
                   chx = rgwchLCRoman[RomanTen]; 
                }
                Calculate(result, (int)iVal, 1000, ref remainder, chm);
                Calculate(result, remainder, 500, ref remainder, chd);
                Calculate(result, remainder, 100, ref remainder, chc);
                Calculate(result, remainder, 10, ref remainder, chx);
                if (remainder > 0) {
                    result.Append(UC? rgwchUCRoman[remainder - 1]: rgwchLCRoman[remainder -1]);
                }
                return result.ToString();
            
            }

            static void Calculate(StringBuilder result, int quot, int denom, ref int rem, String ch) {
                int number = quot / denom;
                rem = quot % denom;

                while (number-- > 0) {
                    result.Append(ch);
                }
            }
        }// class NumberingFormat
        
    // States:
        private const int OutputNumber = 2;

        private String    level;
        private String    countPattern;
        private int       countKey = Compiler.InvalidQueryKey;
        private String    from;
        private int       fromKey = Compiler.InvalidQueryKey;
        private String    value;
        private int       valueKey = Compiler.InvalidQueryKey;
        private Avt       formatAvt;
        private Avt       langAvt;
        private Avt       letterAvt;
        private Avt       groupingSepAvt;
        private Avt       groupingSizeAvt;
        // Compile time precalculated AVTs
        private ArrayList formatList;
        private String    lang;
        private String    letter;
        private String    groupingSep;
        private String    groupingSize;
        private bool      forwardCompatibility;

        private const String s_any      = "any";
        private const String s_multiple = "multiple";
        private const String s_single   = "single";
    
        internal override bool CompileAttribute(Compiler compiler) {
            string name   = compiler.Input.LocalName;
            string value  = compiler.Input.Value;
            if (Keywords.Equals(name, compiler.Atoms.Level)) {
                if (value != s_any && value != s_multiple && value != s_single) {
                    throw XsltException.InvalidAttrValue(Keywords.s_Level, value); 
                }
                this.level = value;
            }
            else if (Keywords.Equals(name, compiler.Atoms.Count)) {
                this.countPattern = value;
                this.countKey = compiler.AddPatternQuery(value, /*allowVars:*/true, /*allowKey:*/true);
            }
            else if (Keywords.Equals(name, compiler.Atoms.From)) { 
                this.from = value;
                this.fromKey = compiler.AddPatternQuery(value, /*allowVars:*/true, /*allowKey:*/true);
            }
            else if (Keywords.Equals(name, compiler.Atoms.Value)) {
                this.value = value;
                this.valueKey = compiler.AddQuery(value);
            }
            else if (Keywords.Equals(name, compiler.Atoms.Format)) {
                this.formatAvt = Avt.CompileAvt(compiler, value);
                Debug.WriteLine("name = \"" + value + "\"");
            }
            else if (Keywords.Equals(name, compiler.Atoms.Lang)) {
                this.langAvt = Avt.CompileAvt(compiler, value);
                Debug.WriteLine("name = \"" + value + "\"");
            }
            else if (Keywords.Equals(name, compiler.Atoms.LetterValue)) {
                this.letterAvt = Avt.CompileAvt(compiler, value);
                Debug.WriteLine("name = \"" + value + "\"");
            }
            else if (Keywords.Equals(name, compiler.Atoms.GroupingSeparator)) {
                this.groupingSepAvt = Avt.CompileAvt(compiler, value);
                Debug.WriteLine("name = \"" + value + "\"");
            }
            else if (Keywords.Equals(name, compiler.Atoms.GroupingSize)) {
                this.groupingSizeAvt = Avt.CompileAvt(compiler, value);
                Debug.WriteLine("name = \"" + value + "\"");
            }
            else {
               return false;
            }
            return true;
        }
            
        internal override void Compile(Compiler compiler) {
            CompileAttributes(compiler);
            CheckEmpty(compiler);

            this.forwardCompatibility = compiler.ForwardCompatibility;
            this.formatList    = ParseFormat(PrecalculateAvt(ref this.formatAvt));
            this.letter        = ParseLetter(PrecalculateAvt(ref this.letterAvt));
            this.lang          = PrecalculateAvt(ref this.langAvt);
            this.groupingSep   = PrecalculateAvt(ref this.groupingSepAvt);
            if (this.groupingSep != null && this.groupingSep.Length > 1) {
                throw XsltException.InvalidAttrValue(compiler.Atoms.GroupingSeparator, this.groupingSep);
            }
            this.groupingSize  = PrecalculateAvt(ref this.groupingSizeAvt);
        }

        private int numberAny(Processor processor, ActionFrame frame) {
            int result = 0;
            // Our current point will be our end point in this search
            XPathNavigator endNode = frame.Node;
            if(endNode.NodeType == XPathNodeType.Attribute) {
                endNode = endNode.Clone();
                endNode.MoveToParent();
            }
            XPathNavigator startNode = endNode.Clone(); 
        
            if(this.fromKey != Compiler.InvalidQueryKey) {
                bool hitFrom = false;
                // First try to find start by traversing up. This gives the best candidate or we hit root
                do{
                    if(processor.Matches(startNode, this.fromKey)) {
                        hitFrom = true;
                        break;
                    }
                }while(startNode.MoveToParent());

                Debug.Assert(
                    processor.Matches(startNode, this.fromKey) ||   // we hit 'from' or
                    startNode.NodeType == XPathNodeType.Root        // we are at root
                );
                
                // from this point (matched parent | root) create descendent quiery:
                // we have to reset 'result' on each 'from' node, because this point can' be not last from point;
                XPathNodeIterator  sel = processor.StartQuery(startNode, Compiler.DescendantKey);
                do {
                    if(processor.Matches(sel.Current, this.fromKey)) {
                        hitFrom = true;
                        result = 0;
                    }
                    else if(MatchCountKey(processor, frame.Node, sel.Current)) {
                        result ++;
                    }
                    if(sel.Current.IsSamePosition(endNode)) {
                        break;
                    }
                }while (sel.MoveNext());
                if(! hitFrom) {
                    result = 0;
                }
            }
            else {
                // without 'from' we startting from the root 
                startNode.MoveToRoot();      
                XPathNodeIterator  sel = processor.StartQuery(startNode, Compiler.DescendantKey);
                // and count root node by itself
                do {
                    if (MatchCountKey(processor, frame.Node, sel.Current)) {
                        result ++;
                    }
                    if (sel.Current.IsSamePosition(endNode)) {
                        break;
                    }
                }while (sel.MoveNext()); 
            }
            return result;
        }

        // check 'from' condition:
        // if 'from' exist it has to be ancestor-or-self for the nav
        private bool checkFrom(Processor processor, XPathNavigator nav) {
            if(this.fromKey == Compiler.InvalidQueryKey) {
                return true;
            }
            do {
                if (processor.Matches(nav, this.fromKey)) {
                    return true;
                }
            }while (nav.MoveToParent());
            return false;
        }

        private bool moveToCount(XPathNavigator nav, Processor processor, XPathNavigator contextNode) {
            do {
                if (this.fromKey != Compiler.InvalidQueryKey && processor.Matches(nav, this.fromKey)) {
                    return false;
                }
                if (MatchCountKey(processor, contextNode, nav)) {
                    return true;
                }
            }while (nav.MoveToParent());
            return false;
        }

        private int numberCount(XPathNavigator nav, Processor processor, XPathNavigator contextNode) {
            Debug.Assert(MatchCountKey(processor, contextNode, nav));
            int number = 1;
            // Perf: It can be faster to enumerate siblings by hand here.
            XPathNodeIterator sel = processor.StartQuery(nav, Compiler.PrecedingSiblingKey);
            while (sel.MoveNext()) {
                if (MatchCountKey(processor, contextNode, sel.Current)) {
                    number++;
                }
            }
            return number;
        }

        private static object SimplifyValue(object value) {
            // If result of xsl:number is not in correct range it should be returned as is.
            // so we need intermidiate string value.
            // If it's already a double we would like to keep it as double.
            // So this function converts to string only if if result is nodeset or RTF
            if (Type.GetTypeCode(value.GetType()) == TypeCode.Object) {
                XPathNodeIterator nodeset = value as XPathNodeIterator;
                if (nodeset != null) {
                    if(nodeset.MoveNext()) {
                        return nodeset.Current.Value;
                    }
                    return String.Empty;
                }
                XPathNavigator nav = value as XPathNavigator;
                if (nav != null) {
                    return nav.Value;
                }
            }
            return value;
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);
            ArrayList list = processor.NumberList;
            switch (frame.State) {
            case Initialized:
                Debug.Assert(frame != null);
                Debug.Assert(frame.NodeSet != null);
                list.Clear();
                if (this.value != null) {
                    object valueObject = SimplifyValue(processor.Evaluate(frame, this.valueKey));
                    double valueDouble = 0;
                    try {
                        valueDouble = XmlConvert.ToXPathDouble(valueObject);
                    }
                    catch (FormatException) {}
                    if (0.5 <= valueDouble && valueDouble < double.PositiveInfinity) {
                        Debug.Assert(! double.IsNaN(valueDouble), "I belive it should be filtered by if condition");
                        list.Add(Math.Floor(valueDouble + 0.5));   // See XPath round for detailes on the trick with Floor()
                    }
                    else {
                        // It is an error if the number is NaN, infinite or less than 0.5; an XSLT processor may signal the error; 
                        // if it does not signal the error, it must recover by converting the number to a string as if by a call 
                        // to the string function and inserting the resulting string into the result tree.
                        frame.StoredOutput = XmlConvert.ToXPathString(valueObject);
                        goto case OutputNumber;
                    }
                }
                else if (this.level == "any") {
                    int number = numberAny(processor, frame);
                    if (number != 0) {
                        list.Add((double)number);
                    }
                }
                else {
                    bool multiple = (this.level == "multiple");
                    XPathNavigator contextNode = frame.Node;         // context of xsl:number element. We using this node in MatchCountKey()
                    XPathNavigator countNode   = frame.Node.Clone(); // node we count for
                    if(countNode.NodeType == XPathNodeType.Attribute) {
                        countNode.MoveToParent();
                    }
                    while(moveToCount(countNode, processor, contextNode)) {
                        list.Insert(0, (double) numberCount(countNode, processor, contextNode));
                        if(! multiple || ! countNode.MoveToParent()) {
                            break;
                        }
                    }
                    if(! checkFrom(processor, countNode)) {
                        list.Clear();
                    }
                }

                /*CalculatingFormat:*/
                frame.StoredOutput = Format(list, 
                    this.formatAvt       == null ? this.formatList   : ParseFormat(this.formatAvt.Evaluate(processor, frame)), 
                    this.langAvt         == null ? this.lang         : this.langAvt        .Evaluate(processor, frame), 
                    this.letterAvt       == null ? this.letter       : ParseLetter(this.letterAvt.Evaluate(processor, frame)), 
                    this.groupingSepAvt  == null ? this.groupingSep  : this.groupingSepAvt .Evaluate(processor, frame), 
                    this.groupingSizeAvt == null ? this.groupingSize : this.groupingSizeAvt.Evaluate(processor, frame)
                );
                goto case OutputNumber;
            case OutputNumber :
                Debug.Assert(frame.StoredOutput != null);
                if (! processor.TextEvent(frame.StoredOutput)) {
                    frame.State        = OutputNumber;
                    break;
                }
                frame.Finished();
                break;
            default:
                Debug.Fail("Invalid Number Action execution state");
                break;
            }            
        }

        private bool MatchCountKey(Processor processor, XPathNavigator contextNode, XPathNavigator nav){
            if (this.countKey != Compiler.InvalidQueryKey) {
                return processor.Matches(nav, this.countKey);
            }
            if (contextNode.Name == nav.Name && BasicNodeType(contextNode.NodeType) == BasicNodeType(nav.NodeType)) {
                return true;
            }
            return false;
        }

        private XPathNodeType BasicNodeType(XPathNodeType type) {
            if(type == XPathNodeType.SignificantWhitespace || type == XPathNodeType.Whitespace) {
                return XPathNodeType.Text;
            } 
            else {
                return type;
            }
        }

        // SDUB: perf.
        // for each call to xsl:number Format() will build new NumberingFormat object.
        // in case of no AVTs we can build this object at compile time and reuse it on execution time.
        // even partial step in this derection will be usefull (when cFormats == 0)

        private static string Format(ArrayList numberlist, ArrayList formatlist, string lang, string letter, string groupingSep, string groupingSize) {
            StringBuilder result = new StringBuilder();
            int cFormats = 0;
            if (formatlist != null) {
                cFormats = formatlist.Count;
            }
                        
            NumberingFormat numberingFormat = new NumberingFormat();
            if (groupingSize != null) {
                try {
                    numberingFormat.setGroupingSize(Convert.ToInt32(groupingSize));
                }
                catch (System.OverflowException) {}
            }
            if (groupingSep != null) {
                numberingFormat.setGroupingSeparator(groupingSep);
            }
            if (0 < cFormats) {
                FormatInfo prefix = (FormatInfo) formatlist[0];
                Debug.Assert(prefix == null || prefix._fIsSeparator);
                FormatInfo sufix = null;
                if (cFormats % 2 == 1) {
                    sufix = (FormatInfo) formatlist[cFormats - 1];
                    cFormats --;
                }
                FormatInfo periodicSeparator = 2 < cFormats ? (FormatInfo) formatlist[cFormats - 2] : DefaultSeparator;
                FormatInfo periodicFormat    = 0 < cFormats ? (FormatInfo) formatlist[cFormats - 1] : DefaultFormat   ;
                if (prefix != null) {
                    result.Append(prefix._wszSeparator);
                }
                int numberlistCount = numberlist.Count;
                for(int i = 0; i < numberlistCount; i++ ) {
                    int formatIndex   = i * 2;
                    bool haveFormat = formatIndex < cFormats;
                    if (0 < i) {
                        FormatInfo thisSeparator = haveFormat ? (FormatInfo) formatlist[formatIndex + 0] : periodicSeparator;
                        Debug.Assert(thisSeparator._fIsSeparator);
                        result.Append(thisSeparator._wszSeparator);
                    }

                    FormatInfo thisFormat    = haveFormat ? (FormatInfo) formatlist[formatIndex + 1] : periodicFormat;
                    Debug.Assert(! thisFormat._fIsSeparator);

                    //numberingFormat.setletter(this.letter);
                    //numberingFormat.setLang(this.lang);
                    
                    numberingFormat.setNumberingType(thisFormat._numberingType);
                    numberingFormat.setMinLen(       thisFormat._cMinLen);
                    result.Append(numberingFormat.format((double)numberlist[i]));
                }

                if (sufix != null) {
                    result.Append(sufix._wszSeparator);
                }
            }
            else {
                numberingFormat.setNumberingType(MSONFC.msonfcArabic);
                for (int i = 0; i < numberlist.Count; i++) {
                    if (i != 0) {
                        result.Append(".");
                    }
                    result.Append(numberingFormat.format((double)numberlist[i]));
                }
            }
            return result.ToString();
        }

        /*      
        ----------------------------------------------------------------------------
            mapFormatToken()

            Maps a token of alphanumeric characters to a numbering format ID and a
            minimum length bound.  Tokens specify the character(s) that begins a 
            Unicode
            numbering sequence.  For example, "i" specifies lower case roman numeral
            numbering.  Leading "zeros" specify a minimum length to be maintained by
            padding, if necessary.
        ----------------------------------------------------------------------------
        */
        private static void mapFormatToken(String wsToken, int startLen, int tokLen, out MSONFC pnfc, out int  pminlen) {
            int wch = (int) wsToken[startLen];
            bool UseArabic = false;
            pminlen = 1;
            pnfc = MSONFC.msonfcNil;
            
            switch (wch) {
            case 0x0030:    // Digit zero
            case 0x0966:    // Hindi digit zero
            case 0x0e50:    // Thai digit zero
            case 0xc77b:    // Korean digit zero
            case 0xff10:    // Digit zero (double-byte)
                do {
                    // Leading zeros request padding.  Track how much.
                    pminlen++;
                }while ((--tokLen > 0) && (wch == (int) wsToken[++startLen]));
                
                if ((int) wsToken[startLen] != wch + 1) {
                    // If next character isn't "one", then use Arabic
                    UseArabic = true;
                }
                break;    
            }
            if (!UseArabic)
            // Map characters of token to number format ID
                switch (wch) {
                case 0x0031: pnfc = MSONFC.msonfcArabic; break;
                case 0x0041: pnfc = MSONFC.msonfcUCLetter; break;
                case 0x0049: pnfc = MSONFC.msonfcUCRoman; break;
                case 0x0061: pnfc = MSONFC.msonfcLCLetter; break;
                case 0x0069: pnfc = MSONFC.msonfcLCRoman; break;
                case 0x0410: pnfc = MSONFC.msonfcUCRus; break;
                case 0x0430: pnfc = MSONFC.msonfcLCRus; break;
                case 0x05d0: pnfc = MSONFC.msonfcHebrew; break;
                case 0x0623: pnfc = MSONFC.msonfcArabicScript; break;
                case 0x0905: pnfc = MSONFC.msonfcHindi2; break;
                case 0x0915: pnfc = MSONFC.msonfcHindi1; break;
                case 0x0967: pnfc = MSONFC.msonfcHindi3; break;
                case 0x0e01: pnfc = MSONFC.msonfcThai1; break;
                case 0x0e51: pnfc = MSONFC.msonfcThai2; break;
                case 0x30a2: pnfc = MSONFC.msonfcDAiueo; break;
                case 0x30a4: pnfc = MSONFC.msonfcDIroha; break;
                case 0x3131: pnfc = MSONFC.msonfcDChosung; break;
                case 0x4e00: pnfc = MSONFC.msonfcFEDecimal; break;
                case 0x58f1: pnfc = MSONFC.msonfcDbNum3; break;
                case 0x58f9: pnfc = MSONFC.msonfcChnCmplx; break;
                case 0x5b50: pnfc = MSONFC.msonfcZodiac2; break;
                case 0xac00: pnfc = MSONFC.msonfcGanada; break;
                case 0xc77c: pnfc = MSONFC.msonfcKorDbNum1; break;
                case 0xd558: pnfc = MSONFC.msonfcKorDbNum3; break;
                case 0xff11: pnfc = MSONFC.msonfcDArabic; break;
                case 0xff71: pnfc = MSONFC.msonfcAiueo; break;
                case 0xff72: pnfc = MSONFC.msonfcIroha; break;
                
                case 0x7532:
                    if (tokLen > 1 && wsToken[1] == 0x5b50) {
                        // 60-based Zodiak numbering begins with two characters
                        pnfc = MSONFC.msonfcZodiac3;
                        tokLen--;
                        startLen++;
                    }
                    else {
                        // 10-based Zodiak numbering begins with one character
                        pnfc = MSONFC.msonfcZodiac1;
                    }
                    break;
                default:
                    pnfc = MSONFC.msonfcArabic;
                    break;
                }

                //if (tokLen != 1 || UseArabic) {
                if (UseArabic) {
                    // If remaining token length is not 1, then don't recognize
                    // sequence and default to Arabic with no zero padding.
                    pnfc = MSONFC.msonfcArabic;
                    pminlen = 0;
                }   
        }


        /*  
        ----------------------------------------------------------------------------
            parseFormat()

            Parse format string into format tokens (alphanumeric) and separators
            (non-alphanumeric).

         
        */
        private static ArrayList ParseFormat(String  sFormat) {
            if (sFormat == null || sFormat.Length == 0) {
                return null;
            }
            String wszStart = sFormat;
            int length = 0;
            bool lastAlphaNumeric = IsCharAlphaNumeric(sFormat[length]);
            ArrayList arrFormatInfo = new ArrayList();
            int count = 0;
            int tokenlength = sFormat.Length;

            if (lastAlphaNumeric) {
                // If the first one is alpha num add empty separator as a prefix.
                arrFormatInfo.Add(null);
            }
            
            while (length <= sFormat.Length) {
                // Loop until a switch from format token to separator is detected (or vice-versa)
                bool currentchar = length < sFormat.Length ? IsCharAlphaNumeric(sFormat[length]) : ! lastAlphaNumeric;
                if (lastAlphaNumeric != currentchar) {
                    FormatInfo  pFormatInfo = new FormatInfo();
                    if (lastAlphaNumeric) {
                        // We just finished a format token.  Map it to a numbering format ID and a min-length bound.
                        mapFormatToken(sFormat, count, length - count ,out pFormatInfo._numberingType, out pFormatInfo._cMinLen);
                    } 
                    else {
                        pFormatInfo._fIsSeparator = true;
                        // We just finished a separator.  Save its length and a pointer to it.
                        pFormatInfo._wszSeparator = sFormat.Substring(count,length - count);
                    }
                    count = length;
                    length++;
                    // Begin parsing the next format token or separator
          
                    arrFormatInfo.Add(pFormatInfo);
                    // Flip flag from format token to separator (or vice-versa)
                    lastAlphaNumeric = currentchar;
                }
                else {
                    length++;
                }
            }

            return arrFormatInfo;
        }

        private string ParseLetter(string letter) {
            if (letter == null || letter == "traditional" || letter == "alphabetic") {
                return letter;
            }
            if (! this.forwardCompatibility) {
                throw XsltException.InvalidAttrValue(Keywords.s_LetterValue, letter);
            }
            return null;
        }

        private static bool IsCharAlphaNumeric(char ch){
            //return (XmlCharType.IsLetter(ch) || XmlCharType.IsDigit(ch));
            UnicodeCategory category = Char.GetUnicodeCategory(ch);
            switch (category) {
            case UnicodeCategory.DecimalDigitNumber:
            case UnicodeCategory.LetterNumber:
            case UnicodeCategory.OtherNumber:
            case UnicodeCategory.UppercaseLetter:
            case UnicodeCategory.LowercaseLetter:
            case UnicodeCategory.TitlecaseLetter:
            case UnicodeCategory.ModifierLetter:
            case UnicodeCategory.OtherLetter:
                return true;
            default:
                return false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\keywords.cs ===
//------------------------------------------------------------------------------
// <copyright file="Keywords.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;

    internal class Keywords {
        XmlNameTable _NameTable;
        internal Keywords(XmlNameTable nameTable) {
            Debug.Assert(nameTable != null);
            _NameTable = nameTable;
        }

        internal void LookupKeywords() {
            _AtomEmpty               = _NameTable.Add(String.Empty);
            _AtomXmlns               = _NameTable.Add(s_Xmlns);
            _AtomXsltNamespace       = _NameTable.Add(s_XsltNamespace);
            _AtomXmlNamespace        = _NameTable.Add(s_XmlNamespace);
            _AtomVersion10           = _NameTable.Add(s_Version10);
            _AtomApplyTemplates      = _NameTable.Add(s_ApplyTemplates);
            _AtomChoose              = _NameTable.Add(s_Choose);
            _AtomForEach             = _NameTable.Add(s_ForEach);
            _AtomIf                  = _NameTable.Add(s_If);
            _AtomOtherwise           = _NameTable.Add(s_Otherwise);
            _AtomStylesheet          = _NameTable.Add(s_Stylesheet);
            _AtomTemplate            = _NameTable.Add(s_Template);
            _AtomTransform           = _NameTable.Add(s_Transform);
            _AtomValueOf             = _NameTable.Add(s_ValueOf);
            _AtomWhen                = _NameTable.Add(s_When);
            _AtomMatch               = _NameTable.Add(s_Match);
            _AtomName                = _NameTable.Add(s_Name);
            _AtomSelect              = _NameTable.Add(s_Select);
            _AtomSpace               = _NameTable.Add(s_Space);
            _AtomTest                = _NameTable.Add(s_Test);

            _AtomMsXsltNamespace     = _NameTable.Add(s_MsXsltNamespace);
            _AtomScript              = _NameTable.Add(s_Script);

            CheckKeyword(_AtomEmpty);
            CheckKeyword(_AtomXmlns);
            CheckKeyword(_AtomXsltNamespace);
            CheckKeyword(_AtomXmlNamespace);
            CheckKeyword(_AtomVersion10);
            CheckKeyword(_AtomApplyTemplates);
            CheckKeyword(_AtomChoose);
            CheckKeyword(_AtomForEach);
            CheckKeyword(_AtomIf);
            CheckKeyword(_AtomOtherwise);
            CheckKeyword(_AtomStylesheet);
            CheckKeyword(_AtomTemplate);
            CheckKeyword(_AtomTransform);
            CheckKeyword(_AtomValueOf);
            CheckKeyword(_AtomWhen);
            CheckKeyword(_AtomMatch);
            CheckKeyword(_AtomName);
            CheckKeyword(_AtomSelect);
            CheckKeyword(_AtomSpace);
            CheckKeyword(_AtomTest);
            CheckKeyword(_AtomMsXsltNamespace);
            CheckKeyword(_AtomScript);
        }

        private string _AtomEmpty;
        private string _AtomXmlns;
        private string _AtomXsltNamespace;
        private string _AtomXmlNamespace;
        private string _AtomVersion10;
        private string _AtomApplyImports;
        private string _AtomApplyTemplates;
        private string _AtomAttribute;
        private string _AtomAttributeSet;
        private string _AtomCallTemplate;
        private string _AtomChoose;
        private string _AtomComment;
        private string _AtomCopy;
        private string _AtomCopyOf;
        private string _AtomDecimalFormat;
        private string _AtomElement;
        private string _AtomFallback;
        private string _AtomForEach;
        private string _AtomIf;
        private string _AtomImport;
        private string _AtomInclude;
        private string _AtomKey;
        private string _AtomMessage;
        private string _AtomNamespaceAlias;
        private string _AtomNumber;
        private string _AtomOtherwise;
        private string _AtomOutput;
        private string _AtomParam;
        private string _AtomPreserveSpace;
        private string _AtomProcessingInstruction;
        private string _AtomSort;
        private string _AtomStripSpace;
        private string _AtomStylesheet;
        private string _AtomTemplate;
        private string _AtomText;
        private string _AtomTransform;
        private string _AtomValueOf;
        private string _AtomVariable;
        private string _AtomWhen;
        private string _AtomWithParam;
        private string _AtomCaseOrder;
        private string _AtomCdataSectionElements;
        private string _AtomCount;
        private string _AtomDataType;
        private string _AtomDecimalSeparator;
        private string _AtomDigit;
        private string _AtomDisableOutputEscaping;
        private string _AtomDoctypePublic;
        private string _AtomDoctypeSystem;
        private string _AtomElements;
        private string _AtomEncoding;
        private string _AtomExcludeResultPrefixes;
        private string _AtomExtensionElementPrefixes;
        private string _AtomFormat;
        private string _AtomFrom;
        private string _AtomGroupingSeparator;
        private string _AtomGroupingSize;
        private string _AtomHref;
        private string _AtomId;
        private string _AtomIndent;
        private string _AtomInfinity;
        private string _AtomLang;
        private string _AtomLetterValue;
        private string _AtomLevel;
        private string _AtomMatch;
        private string _AtomMediaType;
        private string _AtomMethod;
        private string _AtomMinusSign;
        private string _AtomMode;
        private string _AtomName;
        private string _AtomNamespace;
        private string _AtomNaN;
        private string _AtomOmitXmlDeclaration;
        private string _AtomOrder;
        private string _AtomPatternSeparator;
        private string _AtomPercent;
        private string _AtomPerMille;
        private string _AtomPriority;
        private string _AtomResultPrefix;
        private string _AtomSelect;
        private string _AtomSpace;
        private string _AtomStandalone;
        private string _AtomStylesheetPrefix;
        private string _AtomTerminate;
        private string _AtomTest;
        private string _AtomUse;
        private string _AtomUseAttributeSets;
        private string _AtomValue;
        private string _AtomVersion;
        private string _AtomZeroDigit;
        private string _AtomAny;
        private string _AtomHashDefault;
        private string _AtomNo;
        private string _AtomYes;

        private string _AtomMsXsltNamespace;
        private string _AtomScript;
        private string _AtomLanguage;
        private string _AtomImplementsPrefix;

        internal const string s_Xmlns                         = "xmlns";
        internal const string s_XsltNamespace                 = "http://www.w3.org/1999/XSL/Transform";
        internal const string s_XmlNamespace                  = "http://www.w3.org/XML/1998/namespace";
        internal const string s_XmlnsNamespace                = "http://www.w3.org/2000/xmlns/";
        internal const string s_Version10                     = "1.0";
        internal const string s_ApplyImports                  = "apply-imports";
        internal const string s_ApplyTemplates                = "apply-templates";
        internal const string s_Attribute                     = "attribute";
        internal const string s_AttributeSet                  = "attribute-set";
        internal const string s_CallTemplate                  = "call-template";
        internal const string s_Choose                        = "choose";
        internal const string s_Comment                       = "comment";
        internal const string s_Copy                          = "copy";
        internal const string s_CopyOf                        = "copy-of";
        internal const string s_DecimalFormat                 = "decimal-format";
        internal const string s_Element                       = "element";
        internal const string s_Fallback                      = "fallback";
        internal const string s_ForEach                       = "for-each";
        internal const string s_If                            = "if";
        internal const string s_Import                        = "import";
        internal const string s_Include                       = "include";
        internal const string s_Key                           = "key";
        internal const string s_Message                       = "message";
        internal const string s_NamespaceAlias                = "namespace-alias";
        internal const string s_Number                        = "number";
        internal const string s_Otherwise                     = "otherwise";
        internal const string s_Output                        = "output";
        internal const string s_Param                         = "param";
        internal const string s_PreserveSpace                 = "preserve-space";
        internal const string s_ProcessingInstruction         = "processing-instruction";
        internal const string s_Sort                          = "sort";
        internal const string s_StripSpace                    = "strip-space";
        internal const string s_Stylesheet                    = "stylesheet";
        internal const string s_Template                      = "template";
        internal const string s_Text                          = "text";
        internal const string s_Transform                     = "transform";
        internal const string s_ValueOf                       = "value-of";
        internal const string s_Variable                      = "variable";
        internal const string s_When                          = "when";
        internal const string s_WithParam                     = "with-param";
        internal const string s_CaseOrder                     = "case-order";
        internal const string s_CdataSectionElements          = "cdata-section-elements";
        internal const string s_Count                         = "count";
        internal const string s_DataType                      = "data-type";
        internal const string s_DecimalSeparator              = "decimal-separator";
        internal const string s_Digit                         = "digit";
        internal const string s_DisableOutputEscaping         = "disable-output-escaping";
        internal const string s_DoctypePublic                 = "doctype-public";
        internal const string s_DoctypeSystem                 = "doctype-system";
        internal const string s_Elements                      = "elements";
        internal const string s_Encoding                      = "encoding";
        internal const string s_ExcludeResultPrefixes         = "exclude-result-prefixes";
        internal const string s_ExtensionElementPrefixes      = "extension-element-prefixes";
        internal const string s_Format                        = "format";
        internal const string s_From                          = "from";
        internal const string s_GroupingSeparator             = "grouping-separator";
        internal const string s_GroupingSize                  = "grouping-size";
        internal const string s_Href                          = "href";
        internal const string s_Id                            = "id";
        internal const string s_Indent                        = "indent";
        internal const string s_Infinity                      = "infinity";
        internal const string s_Lang                          = "lang";
        internal const string s_LetterValue                   = "letter-value";
        internal const string s_Level                         = "level";
        internal const string s_Match                         = "match";
        internal const string s_MediaType                     = "media-type";
        internal const string s_Method                        = "method";
        internal const string s_MinusSign                     = "minus-sign";
        internal const string s_Mode                          = "mode";
        internal const string s_Name                          = "name";
        internal const string s_Namespace                     = "namespace";
        internal const string s_NaN                           = "NaN";
        internal const string s_OmitXmlDeclaration            = "omit-xml-declaration";
        internal const string s_Order                         = "order";
        internal const string s_PatternSeparator              = "pattern-separator";
        internal const string s_Percent                       = "percent";
        internal const string s_PerMille                      = "per-mille";
        internal const string s_Priority                      = "priority";
        internal const string s_ResultPrefix                  = "result-prefix";
        internal const string s_Select                        = "select";
        internal const string s_Space                         = "space";
        internal const string s_Standalone                    = "standalone";
        internal const string s_StylesheetPrefix              = "stylesheet-prefix";
        internal const string s_Terminate                     = "terminate";
        internal const string s_Test                          = "test";
        internal const string s_Use                           = "use";
        internal const string s_UseAttributeSets              = "use-attribute-sets";
        internal const string s_Value                         = "value";
        internal const string s_Version                       = "version";
        internal const string s_ZeroDigit                     = "zero-digit";
        internal const string s_Alphabetic                    = "alphabetic";
        internal const string s_Any                           = "any";
        internal const string s_Ascending                     = "ascending";
        internal const string s_Descending                    = "descending";
        internal const string s_HashDefault                   = "#default";
        internal const string s_Html                          = "html";
        internal const string s_LowerFirst                    = "lower-first";
        internal const string s_Multiple                      = "multiple";
        internal const string s_No                            = "no";
        internal const string s_Single                        = "single";
        internal const string s_Traditional                   = "traditional";
        internal const string s_UpperFirst                    = "upper-first";
        internal const string s_Xml                           = "xml";
        internal const string s_Yes                           = "yes";
        internal const string s_Vendor                        = "vendor";
        internal const string s_VendorUrl                     = "vendor-url";

        // extension
        internal const string s_MsXsltNamespace               = "urn:schemas-microsoft-com:xslt";
        internal const string s_Script                        = "script";
        internal const string s_Language                      = "language";
        internal const string s_ImplementsPrefix              = "implements-prefix";
        

        // String.Empty
        internal string Empty {
            get {
                CheckKeyword(_AtomEmpty);
                return _AtomEmpty;
            }
        }

        // xmlns
        internal string Xmlns {
            get {
                CheckKeyword(_AtomXmlns);
                return _AtomXmlns;
            }
        }

        // http://www.w3.org/1999/XSL/Transform
        internal string XsltNamespace {
            get {
                CheckKeyword(_AtomXsltNamespace);
                return _AtomXsltNamespace;
            }
        }

        // http://www.w3.org/XML/1998/namespace
        internal string XmlNamespace {
            get {
                CheckKeyword(_AtomXmlNamespace);
                return _AtomXmlNamespace;
            }
        }

        // 1.0
        internal string Version10 {
            get {
                CheckKeyword(_AtomVersion10);
                return _AtomVersion10;
            }
        }

        // apply-imports
        internal string ApplyImports {
            get {
                if (_AtomApplyImports == null)
                    _AtomApplyImports = _NameTable.Add(s_ApplyImports);
                CheckKeyword(_AtomApplyImports);
                return _AtomApplyImports;
            }
        }

        // apply-templates
        internal string ApplyTemplates {
            get {
                CheckKeyword(_AtomApplyTemplates);
                return _AtomApplyTemplates;
            }
        }

        // attribute
        internal string Attribute {
            get {
                if (_AtomAttribute == null)
                    _AtomAttribute = _NameTable.Add(s_Attribute);
                CheckKeyword(_AtomAttribute);
                return _AtomAttribute;
            }
        }

        // attribute-set
        internal string AttributeSet {
            get {
                if (_AtomAttributeSet == null)
                    _AtomAttributeSet = _NameTable.Add(s_AttributeSet);
                CheckKeyword(_AtomAttributeSet);
                return _AtomAttributeSet;
            }
        }

        // call-template
        internal string CallTemplate {
            get {
                if (_AtomCallTemplate == null)
                    _AtomCallTemplate = _NameTable.Add(s_CallTemplate);
                CheckKeyword(_AtomCallTemplate);
                return _AtomCallTemplate;
            }
        }

        // choose
        internal string Choose {
            get {
                CheckKeyword(_AtomChoose);
                return _AtomChoose;
            }
        }

        // comment
        internal string Comment {
            get {
                if (_AtomComment == null)
                    _AtomComment = _NameTable.Add(s_Comment);
                CheckKeyword(_AtomComment);
                return _AtomComment;
            }
        }

        // copy
        internal string Copy {
            get {
                if (_AtomCopy == null)
                    _AtomCopy = _NameTable.Add(s_Copy);
                CheckKeyword(_AtomCopy);
                return _AtomCopy;
            }
        }

        // copy-of
        internal string CopyOf {
            get {
                if (_AtomCopyOf == null)
                    _AtomCopyOf = _NameTable.Add(s_CopyOf);
                CheckKeyword(_AtomCopyOf);
                return _AtomCopyOf;
            }
        }

        // decimal-format
        internal string DecimalFormat {
            get {
                if (_AtomDecimalFormat == null)
                    _AtomDecimalFormat = _NameTable.Add(s_DecimalFormat);
                CheckKeyword(_AtomDecimalFormat);
                return _AtomDecimalFormat;
            }
        }

        // element
        internal string Element {
            get {
                if (_AtomElement == null)
                    _AtomElement = _NameTable.Add(s_Element);
                CheckKeyword(_AtomElement);
                return _AtomElement;
            }
        }

        // fallback
        internal string Fallback {
            get {
                if (_AtomFallback == null)
                    _AtomFallback = _NameTable.Add(s_Fallback);
                CheckKeyword(_AtomFallback);
                return _AtomFallback;
            }
        }

        // for-each
        internal string ForEach {
            get {
                CheckKeyword(_AtomForEach);
                return _AtomForEach;
            }
        }

        // if
        internal string If {
            get {
                CheckKeyword(_AtomIf);
                return _AtomIf;
            }
        }

        // import
        internal string Import {
            get {
                if (_AtomImport == null)
                    _AtomImport = _NameTable.Add(s_Import);
                CheckKeyword(_AtomImport);
                return _AtomImport;
            }
        }

        // include
        internal string Include {
            get {
                if (_AtomInclude == null)
                    _AtomInclude = _NameTable.Add(s_Include);
                CheckKeyword(_AtomInclude);
                return _AtomInclude;
            }
        }

        // key
        internal string Key {
            get {
                if (_AtomKey == null)
                    _AtomKey = _NameTable.Add(s_Key);
                CheckKeyword(_AtomKey);
                return _AtomKey;
            }
        }

        // message
        internal string Message {
            get {
                if (_AtomMessage == null)
                    _AtomMessage = _NameTable.Add(s_Message);
                CheckKeyword(_AtomMessage);
                return _AtomMessage;
            }
        }

        // namespace-alias
        internal string NamespaceAlias {
            get {
                if (_AtomNamespaceAlias == null)
                    _AtomNamespaceAlias = _NameTable.Add(s_NamespaceAlias);
                CheckKeyword(_AtomNamespaceAlias);
                return _AtomNamespaceAlias;
            }
        }

        // number
        internal string Number {
            get {
                if (_AtomNumber == null)
                    _AtomNumber = _NameTable.Add(s_Number);
                CheckKeyword(_AtomNumber);
                return _AtomNumber;
            }
        }

        // otherwise
        internal string Otherwise {
            get {
                CheckKeyword(_AtomOtherwise);
                return _AtomOtherwise;
            }
        }

        // output
        internal string Output {
            get {
                if (_AtomOutput == null)
                    _AtomOutput = _NameTable.Add(s_Output);
                CheckKeyword(_AtomOutput);
                return _AtomOutput;
            }
        }

        // param
        internal string Param {
            get {
                if (_AtomParam == null)
                    _AtomParam = _NameTable.Add(s_Param);
                CheckKeyword(_AtomParam);
                return _AtomParam;
            }
        }

        // preserve-space
        internal string PreserveSpace {
            get {
                if (_AtomPreserveSpace == null)
                    _AtomPreserveSpace = _NameTable.Add(s_PreserveSpace);
                CheckKeyword(_AtomPreserveSpace);
                return _AtomPreserveSpace;
            }
        }

        // processing-instruction
        internal string ProcessingInstruction {
            get {
                if (_AtomProcessingInstruction == null)
                    _AtomProcessingInstruction = _NameTable.Add(s_ProcessingInstruction);
                CheckKeyword(_AtomProcessingInstruction);
                return _AtomProcessingInstruction;
            }
        }

        // sort
        internal string Sort {
            get {
                if (_AtomSort == null)
                    _AtomSort = _NameTable.Add(s_Sort);
                CheckKeyword(_AtomSort);
                return _AtomSort;
            }
        }

        // strip-space
        internal string StripSpace {
            get {
                if (_AtomStripSpace == null)
                    _AtomStripSpace = _NameTable.Add(s_StripSpace);
                CheckKeyword(_AtomStripSpace);
                return _AtomStripSpace;
            }
        }

        // stylesheet
        internal string Stylesheet {
            get {
                CheckKeyword(_AtomStylesheet);
                return _AtomStylesheet;
            }
        }

        // template
        internal string Template {
            get {
                CheckKeyword(_AtomTemplate);
                return _AtomTemplate;
            }
        }

        // text
        internal string Text {
            get {
                if (_AtomText == null)
                    _AtomText = _NameTable.Add(s_Text);
                CheckKeyword(_AtomText);
                return _AtomText;
            }
        }

        // transform
        internal string Transform {
            get {
                CheckKeyword(_AtomTransform);
                return _AtomTransform;
            }
        }

        // value-of
        internal string ValueOf {
            get {
                CheckKeyword(_AtomValueOf);
                return _AtomValueOf;
            }
        }

        // variable
        internal string Variable {
            get {
                if (_AtomVariable == null)
                    _AtomVariable = _NameTable.Add(s_Variable);
                CheckKeyword(_AtomVariable);
                return _AtomVariable;
            }
        }

        // when
        internal string When {
            get {
                CheckKeyword(_AtomWhen);
                return _AtomWhen;
            }
        }

        // with-param
        internal string WithParam {
            get {
                if (_AtomWithParam == null)
                    _AtomWithParam = _NameTable.Add(s_WithParam);
                CheckKeyword(_AtomWithParam);
                return _AtomWithParam;
            }
        }

        // case-order
        internal string CaseOrder {
            get {
                if (_AtomCaseOrder == null)
                    _AtomCaseOrder = _NameTable.Add(s_CaseOrder);
                CheckKeyword(_AtomCaseOrder);
                return _AtomCaseOrder;
            }
        }

        // cdata-section-elements
        internal string CdataSectionElements {
            get {
                if (_AtomCdataSectionElements == null)
                    _AtomCdataSectionElements = _NameTable.Add(s_CdataSectionElements);
                CheckKeyword(_AtomCdataSectionElements);
                return _AtomCdataSectionElements;
            }
        }

        // count
        internal string Count {
            get {
                if (_AtomCount == null)
                    _AtomCount = _NameTable.Add(s_Count);
                CheckKeyword(_AtomCount);
                return _AtomCount;
            }
        }

        // data-type
        internal string DataType {
            get {
                if (_AtomDataType == null)
                    _AtomDataType = _NameTable.Add(s_DataType);
                CheckKeyword(_AtomDataType);
                return _AtomDataType;
            }
        }

        // decimal-separator
        internal string DecimalSeparator {
            get {
                if (_AtomDecimalSeparator == null)
                    _AtomDecimalSeparator = _NameTable.Add(s_DecimalSeparator);
                CheckKeyword(_AtomDecimalSeparator);
                return _AtomDecimalSeparator;
            }
        }

        // digit
        internal string Digit {
            get {
                if (_AtomDigit == null)
                    _AtomDigit = _NameTable.Add(s_Digit);
                CheckKeyword(_AtomDigit);
                return _AtomDigit;
            }
        }

        // disable-output-escaping
        internal string DisableOutputEscaping {
            get {
                if (_AtomDisableOutputEscaping == null)
                    _AtomDisableOutputEscaping = _NameTable.Add(s_DisableOutputEscaping);
                CheckKeyword(_AtomDisableOutputEscaping);
                return _AtomDisableOutputEscaping;
            }
        }

        // doctype-public
        internal string DoctypePublic {
            get {
                if (_AtomDoctypePublic == null)
                    _AtomDoctypePublic = _NameTable.Add(s_DoctypePublic);
                CheckKeyword(_AtomDoctypePublic);
                return _AtomDoctypePublic;
            }
        }

        // doctype-system
        internal string DoctypeSystem {
            get {
                if (_AtomDoctypeSystem == null)
                    _AtomDoctypeSystem = _NameTable.Add(s_DoctypeSystem);
                CheckKeyword(_AtomDoctypeSystem);
                return _AtomDoctypeSystem;
            }
        }

        // elements
        internal string Elements {
            get {
                if (_AtomElements == null)
                    _AtomElements = _NameTable.Add(s_Elements);
                CheckKeyword(_AtomElements);
                return _AtomElements;
            }
        }

        // encoding
        internal string Encoding {
            get {
                if (_AtomEncoding == null)
                    _AtomEncoding = _NameTable.Add(s_Encoding);
                CheckKeyword(_AtomEncoding);
                return _AtomEncoding;
            }
        }

        // exclude-result-prefixes
        internal string ExcludeResultPrefixes {
            get {
                if (_AtomExcludeResultPrefixes == null)
                    _AtomExcludeResultPrefixes = _NameTable.Add(s_ExcludeResultPrefixes);
                CheckKeyword(_AtomExcludeResultPrefixes);
                return _AtomExcludeResultPrefixes;
            }
        }

        // extension-element-prefixes
        internal string ExtensionElementPrefixes {
            get {
                if (_AtomExtensionElementPrefixes == null)
                    _AtomExtensionElementPrefixes = _NameTable.Add(s_ExtensionElementPrefixes);
                CheckKeyword(_AtomExtensionElementPrefixes);
                return _AtomExtensionElementPrefixes;
            }
        }

        // format
        internal string Format {
            get {
                if (_AtomFormat == null)
                    _AtomFormat = _NameTable.Add(s_Format);
                CheckKeyword(_AtomFormat);
                return _AtomFormat;
            }
        }

        // from
        internal string From {
            get {
                if (_AtomFrom == null)
                    _AtomFrom = _NameTable.Add(s_From);
                CheckKeyword(_AtomFrom);
                return _AtomFrom;
            }
        }

        // grouping-separator
        internal string GroupingSeparator {
            get {
                if (_AtomGroupingSeparator == null)
                    _AtomGroupingSeparator = _NameTable.Add(s_GroupingSeparator);
                CheckKeyword(_AtomGroupingSeparator);
                return _AtomGroupingSeparator;
            }
        }

        // grouping-size
        internal string GroupingSize {
            get {
                if (_AtomGroupingSize == null)
                    _AtomGroupingSize = _NameTable.Add(s_GroupingSize);
                CheckKeyword(_AtomGroupingSize);
                return _AtomGroupingSize;
            }
        }

        // href
        internal string Href {
            get {
                if (_AtomHref == null)
                    _AtomHref = _NameTable.Add(s_Href);
                CheckKeyword(_AtomHref);
                return _AtomHref;
            }
        }

        // id
        internal string Id {
            get {
                if (_AtomId == null)
                    _AtomId = _NameTable.Add(s_Id);
                CheckKeyword(_AtomId);
                return _AtomId;
            }
        }

        // indent
        internal string Indent {
            get {
                if (_AtomIndent == null)
                    _AtomIndent = _NameTable.Add(s_Indent);
                CheckKeyword(_AtomIndent);
                return _AtomIndent;
            }
        }

        // infinity
        internal string Infinity {
            get {
                if (_AtomInfinity == null)
                    _AtomInfinity = _NameTable.Add(s_Infinity);
                CheckKeyword(_AtomInfinity);
                return _AtomInfinity;
            }
        }

        // lang
        internal string Lang {
            get {
                if (_AtomLang == null)
                    _AtomLang = _NameTable.Add(s_Lang);
                CheckKeyword(_AtomLang);
                return _AtomLang;
            }
        }

        // letter-value
        internal string LetterValue {
            get {
                if (_AtomLetterValue == null)
                    _AtomLetterValue = _NameTable.Add(s_LetterValue);
                CheckKeyword(_AtomLetterValue);
                return _AtomLetterValue;
            }
        }

        // level
        internal string Level {
            get {
                if (_AtomLevel == null)
                    _AtomLevel = _NameTable.Add(s_Level);
                CheckKeyword(_AtomLevel);
                return _AtomLevel;
            }
        }

        // match
        internal string Match {
            get {
                CheckKeyword(_AtomMatch);
                return _AtomMatch;
            }
        }

        // media-type
        internal string MediaType {
            get {
                if (_AtomMediaType == null)
                    _AtomMediaType = _NameTable.Add(s_MediaType);
                CheckKeyword(_AtomMediaType);
                return _AtomMediaType;
            }
        }

        // method
        internal string Method {
            get {
                if (_AtomMethod == null)
                    _AtomMethod = _NameTable.Add(s_Method);
                CheckKeyword(_AtomMethod);
                return _AtomMethod;
            }
        }

        // minus-sign
        internal string MinusSign {
            get {
                if (_AtomMinusSign == null)
                    _AtomMinusSign = _NameTable.Add(s_MinusSign);
                CheckKeyword(_AtomMinusSign);
                return _AtomMinusSign;
            }
        }

        // mode
        internal string Mode {
            get {
                if (_AtomMode == null)
                    _AtomMode = _NameTable.Add(s_Mode);
                CheckKeyword(_AtomMode);
                return _AtomMode;
            }
        }

        // name
        internal string Name {
            get {
                CheckKeyword(_AtomName);
                return _AtomName;
            }
        }

        // namespace
        internal string Namespace {
            get {
                if (_AtomNamespace == null)
                    _AtomNamespace = _NameTable.Add(s_Namespace);
                CheckKeyword(_AtomNamespace);
                return _AtomNamespace;
            }
        }

        // NaN
        internal string NaN {
            get {
                if (_AtomNaN == null)
                    _AtomNaN = _NameTable.Add(s_NaN);
                CheckKeyword(_AtomNaN);
                return _AtomNaN;
            }
        }

        // omit-xml-declaration
        internal string OmitXmlDeclaration {
            get {
                if (_AtomOmitXmlDeclaration == null)
                    _AtomOmitXmlDeclaration = _NameTable.Add(s_OmitXmlDeclaration);
                CheckKeyword(_AtomOmitXmlDeclaration);
                return _AtomOmitXmlDeclaration;
            }
        }

        // order
        internal string Order {
            get {
                if (_AtomOrder == null)
                    _AtomOrder = _NameTable.Add(s_Order);
                CheckKeyword(_AtomOrder);
                return _AtomOrder;
            }
        }

        // pattern-separator
        internal string PatternSeparator {
            get {
                if (_AtomPatternSeparator == null)
                    _AtomPatternSeparator = _NameTable.Add(s_PatternSeparator);
                CheckKeyword(_AtomPatternSeparator);
                return _AtomPatternSeparator;
            }
        }

        // percent
        internal string Percent {
            get {
                if (_AtomPercent == null)
                    _AtomPercent = _NameTable.Add(s_Percent);
                CheckKeyword(_AtomPercent);
                return _AtomPercent;
            }
        }

        // per-mille
        internal string PerMille {
            get {
                if (_AtomPerMille == null)
                    _AtomPerMille = _NameTable.Add(s_PerMille);
                CheckKeyword(_AtomPerMille);
                return _AtomPerMille;
            }
        }

        // priority
        internal string Priority {
            get {
                if (_AtomPriority == null)
                    _AtomPriority = _NameTable.Add(s_Priority);
                CheckKeyword(_AtomPriority);
                return _AtomPriority;
            }
        }

        // result-prefix
        internal string ResultPrefix {
            get {
                if (_AtomResultPrefix == null)
                    _AtomResultPrefix = _NameTable.Add(s_ResultPrefix);
                CheckKeyword(_AtomResultPrefix);
                return _AtomResultPrefix;
            }
        }

        // select
        internal string Select {
            get {
                CheckKeyword(_AtomSelect);
                return _AtomSelect;
            }
        }

        // space
        internal string Space {
            get {
                CheckKeyword(_AtomSpace);
                return _AtomSpace;
            }
        }

        // standalone
        internal string Standalone {
            get {
                if (_AtomStandalone == null)
                    _AtomStandalone = _NameTable.Add(s_Standalone);
                CheckKeyword(_AtomStandalone);
                return _AtomStandalone;
            }
        }

        // stylesheet-prefix
        internal string StylesheetPrefix {
            get {
                if (_AtomStylesheetPrefix == null)
                    _AtomStylesheetPrefix = _NameTable.Add(s_StylesheetPrefix);
                CheckKeyword(_AtomStylesheetPrefix);
                return _AtomStylesheetPrefix;
            }
        }

        // terminate
        internal string Terminate {
            get {
                if (_AtomTerminate == null)
                    _AtomTerminate = _NameTable.Add(s_Terminate);
                CheckKeyword(_AtomTerminate);
                return _AtomTerminate;
            }
        }

        // test
        internal string Test {
            get {
                CheckKeyword(_AtomTest);
                return _AtomTest;
            }
        }

        // use
        internal string Use {
            get {
                if (_AtomUse == null)
                    _AtomUse = _NameTable.Add(s_Use);
                CheckKeyword(_AtomUse);
                return _AtomUse;
            }
        }

        // use-attribute-sets
        internal string UseAttributeSets {
            get {
                if (_AtomUseAttributeSets == null)
                    _AtomUseAttributeSets = _NameTable.Add(s_UseAttributeSets);
                CheckKeyword(_AtomUseAttributeSets);
                return _AtomUseAttributeSets;
            }
        }

        // value
        internal string Value {
            get {
                if (_AtomValue == null)
                    _AtomValue = _NameTable.Add(s_Value);
                CheckKeyword(_AtomValue);
                return _AtomValue;
            }
        }

        // version
        internal string Version {
            get {
                if (_AtomVersion == null)
                    _AtomVersion = _NameTable.Add(s_Version);
                CheckKeyword(_AtomVersion);
                return _AtomVersion;
            }
        }

        // zero-digit
        internal string ZeroDigit {
            get {
                if (_AtomZeroDigit == null)
                    _AtomZeroDigit = _NameTable.Add(s_ZeroDigit);
                CheckKeyword(_AtomZeroDigit);
                return _AtomZeroDigit;
            }
        }

        // any
        internal string Any {
            get {
                if (_AtomAny == null)
                    _AtomAny = _NameTable.Add(s_Any);
                CheckKeyword(_AtomAny);
                return _AtomAny;
            }
        }

        // #default
        internal string HashDefault {
            get {
                if (_AtomHashDefault == null)
                    _AtomHashDefault = _NameTable.Add(s_HashDefault);
                CheckKeyword(_AtomHashDefault);
                return _AtomHashDefault;
            }
        }

        // no
        internal string No {
            get {
                if (_AtomNo == null)
                    _AtomNo = _NameTable.Add(s_No);
                CheckKeyword(_AtomNo);
                return _AtomNo;
            }
        }

        // yes
        internal string Yes {
            get {
                if (_AtomYes == null)
                    _AtomYes = _NameTable.Add(s_Yes);
                CheckKeyword(_AtomYes);
                return _AtomYes;
            }
        }

        //urn:schemas-microsoft-com:xslt
        internal string MsXsltNamespace {
            get {
                CheckKeyword(_AtomMsXsltNamespace);
                return _AtomMsXsltNamespace;
            }
        }

        // script
        internal string Script {
            get {
                CheckKeyword(_AtomScript);
                return _AtomScript;
            }
        }
        
        // language
        internal string Language {
            get {
                if (_AtomLanguage == null)
                    _AtomLanguage = _NameTable.Add(s_Language);
                CheckKeyword(_AtomLanguage);
                return _AtomLanguage;
            }
        }
        
        // implements-prefix
        internal string ImplementsPrefix {
            get {
                if (_AtomImplementsPrefix == null)
                    _AtomImplementsPrefix = _NameTable.Add(s_ImplementsPrefix);
                CheckKeyword(_AtomImplementsPrefix);
                return _AtomImplementsPrefix;
            }
        }

        // Keyword comparison methods
        internal static bool Equals(string strA, string strB) {
            Debug.Assert((object) strA == (object) strB || ! String.Equals(strA, strB), "String atomization failure");
            return (object) strA == (object) strB;
        }

        internal static bool Compare(string strA, string strB) {
            return String.Equals(strA, strB);
        }

        [System.Diagnostics.Conditional("DEBUG")]
        private void CheckKeyword(string keyword) {
            Debug.Assert(keyword != null);
            Debug.Assert((object) keyword == (object) _NameTable.Get(keyword));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\newinstructionaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="newinstructionaction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class NewInstructionAction : ContainerAction {
        string name;
        string parent;
        bool fallback;
        
        internal override void Compile(Compiler compiler) {
            XPathNavigator nav = compiler.Input.Navigator.Clone();
            string name = nav.Name;
            nav.MoveToParent();
            string parent = nav.Name;
            if (compiler.Recurse()) {
                CompileSelectiveTemplate(compiler);
                compiler.ToParent();
            }
        }

        internal void CompileSelectiveTemplate(Compiler compiler){
            NavigatorInput input = compiler.Input;
            do{
                if (Keywords.Equals(input.NamespaceURI, input.Atoms.XsltNamespace) &&
                    Keywords.Equals(input.LocalName, input.Atoms.Fallback)){
                    fallback = true;
                    if (compiler.Recurse()){
                        CompileTemplate(compiler);
                        compiler.ToParent();
                    }
                }
            }
            while (compiler.Advance());
        }
        
       internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);

            switch (frame.State) {
            case Initialized:
                if (!fallback) {
                    throw XsltException.UnexpectedKeyword(this.name, this.parent);
                }
                if (this.containedActions != null && this.containedActions.Count > 0) {
                    processor.PushActionFrame(frame);
                    frame.State = ProcessingChildren;
                    break;
                }
                else goto case ProcessingChildren;
            case ProcessingChildren:
                frame.Finished();
                break;

            default:
                Debug.Fail("Invalid Container action execution state");
                break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\navigatorinput.cs ===
//------------------------------------------------------------------------------
// <copyright file="NavigatorInput.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {

    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class NavigatorInput {
        private XPathNavigator     _Navigator;
        private PositionInfo       _PositionInfo;
        private InputScopeManager  _Manager;
        private NavigatorInput     _Next;
        private string             _Href;
        private Keywords           _Atoms;

        internal NavigatorInput Next {
            get {
                return _Next;
            }
            set {
                _Next = value;
            }
        }

        internal string Href {
            get {
                return _Href;
            }
        }

        internal Keywords Atoms {
            get {
                return _Atoms;
            }
        }        

        internal  XPathNavigator Navigator {
            get {
                AssertInput();
                return _Navigator;
            }
        }

        internal  InputScopeManager InputScopeManager {
            get {
                AssertInput();
                return _Manager;
            }
        }

        internal bool MoveToPrevious(){
            return _Navigator.MoveToPrevious();
        }
        
        internal  bool Advance() {
            AssertInput();
            return _Navigator.MoveToNext();
        }

        internal  bool Recurse() {
            AssertInput();
            return _Navigator.MoveToFirstChild();
        }

        internal  bool ToParent() {
            AssertInput();
            return _Navigator.MoveToParent();
        }

        internal  void Close() {
            _Navigator = null;
            _PositionInfo = null;
        }

        //
        // Input document properties
        //

        //
        // XPathNavigator does not support line and position numbers
        //

        internal  int LineNumber { 
            get { return _PositionInfo.LineNumber; }
        }

        internal  int LinePosition { 
            get { return _PositionInfo.LinePosition; }
        }

        internal  XPathNodeType NodeType {
            get {
                AssertInput();
                return _Navigator.NodeType;
            }
        }

        internal  string Name {
            get {
                AssertInput();
                return _Navigator.Name;
            }
        }

        internal  string LocalName {
            get {
                AssertInput();
                return _Navigator.LocalName;
            }
        }

        internal  string NamespaceURI {
            get {
                AssertInput();
                return _Navigator.NamespaceURI;
            }
        }

        internal  string Prefix {
            get {
                AssertInput();
                return _Navigator.Prefix;
            }
        }

        internal  string Value {
            get {
                AssertInput();
                return _Navigator.Value;
            }
        }

        internal  bool IsEmptyTag {
            get {
                AssertInput();
                return _Navigator.IsEmptyElement;
            }
        }

        internal  string BaseURI {
            get {
                Debug.WriteLine("Navigator doesn't support BaseURI");
                return  _Navigator.BaseURI;
            }
        }
        
        internal  bool MoveToFirstAttribute() {
            AssertInput();
            return _Navigator.MoveToFirstAttribute();
        }

        internal  bool MoveToNextAttribute() {
            AssertInput();
            return _Navigator.MoveToNextAttribute();
        }
        internal  bool MoveToFirstNamespace() {
            AssertInput();
            return _Navigator.MoveToFirstNamespace(XPathNamespaceScope.ExcludeXml);
        }

        internal  bool MoveToNextNamespace() {
            AssertInput();
            return _Navigator.MoveToNextNamespace(XPathNamespaceScope.ExcludeXml);
        }

        //
        // Constructor
        //
        internal NavigatorInput(XPathNavigator navigator, string baseUri, InputScope rootScope) {
            if (navigator == null) {
                throw new ArgumentNullException("navigator");
            }
            if (baseUri == null) {
                throw new ArgumentNullException("baseUri");
            }
            Debug.Assert(navigator.NameTable != null);
            _Next  = null;
            _Href  = baseUri;
            _Atoms = new Keywords(navigator.NameTable);
            _Atoms.LookupKeywords();
            _Navigator = navigator;
            _Manager   = new InputScopeManager(_Navigator, rootScope);
            _PositionInfo = PositionInfo.GetPositionInfo(_Navigator);

            /*BeginReading:*/
            AssertInput();
            if (NodeType == XPathNodeType.Root) {
                _Navigator.MoveToFirstChild();
            }
        }

        internal NavigatorInput(XPathNavigator navigator): this(navigator, navigator.BaseURI, null) {}

        internal NavigatorInput(IXPathNavigable doc, string baseUri, InputScope rootScope): this( doc.CreateNavigator(), baseUri, rootScope) {}

        //
        // Debugging support
        //
        [System.Diagnostics.Conditional("DEBUG")]
        internal void AssertInput() {
            Debug.Assert(_Navigator != null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\outkeywords.cs ===
//------------------------------------------------------------------------------
// <copyright file="OutKeywords.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;

    internal class OutKeywords {

#if DEBUG
        XmlNameTable _NameTable;
#endif
        internal OutKeywords(XmlNameTable nameTable) {
            Debug.Assert(nameTable != null);
#if DEBUG
            _NameTable = nameTable;
#endif

            _AtomEmpty               = nameTable.Add(String.Empty);
            _AtomLang                = nameTable.Add(Keywords.s_Lang);
            _AtomSpace               = nameTable.Add(Keywords.s_Space);
            _AtomXmlns               = nameTable.Add(Keywords.s_Xmlns);
            _AtomXml                 = nameTable.Add(Keywords.s_Xml);
            _AtomXmlNamespace        = nameTable.Add(Keywords.s_XmlNamespace);
            _AtomXmlnsNamespace      = nameTable.Add(Keywords.s_XmlnsNamespace);

            CheckKeyword(_AtomEmpty);
            CheckKeyword(_AtomLang);
            CheckKeyword(_AtomSpace);
            CheckKeyword(_AtomXmlns);
            CheckKeyword(_AtomXml);
            CheckKeyword(_AtomXmlNamespace);
            CheckKeyword(_AtomXmlnsNamespace);
        }

        private string _AtomEmpty;
        private string _AtomLang;
        private string _AtomSpace;
        private string _AtomXmlns;
        private string _AtomXml;
        private string _AtomXmlNamespace;
        private string _AtomXmlnsNamespace;

        internal string Empty {
            get {
                CheckKeyword(_AtomEmpty);
                return _AtomEmpty;
            }
        }

        internal string Lang {
            get {
                CheckKeyword(_AtomLang);
                return _AtomLang;
            }
        }

        internal string Space {
            get {
                CheckKeyword(_AtomSpace);
                return _AtomSpace;
            }
        }

        internal string Xmlns {
            get {
                CheckKeyword(_AtomXmlns);
                return _AtomXmlns;
            }
        }

        internal string Xml {
            get {
                CheckKeyword(_AtomXml);
                return _AtomXml;
            }
        }

        internal string XmlNamespace {
            get {
                CheckKeyword(_AtomXmlNamespace);
                return _AtomXmlNamespace;       // http://www.w3.org/XML/1998/namespace
            }
        }

        internal string XmlnsNamespace {
            get {
                CheckKeyword(_AtomXmlnsNamespace);
                return _AtomXmlnsNamespace;               // http://www.w3.org/XML/2000/xmlns
            }
        }

        [System.Diagnostics.Conditional("DEBUG")]
        private void CheckKeyword(string keyword) {
#if DEBUG
            Debug.Assert(keyword != null);
            Debug.Assert((object) keyword == (object) _NameTable.Get(keyword));
#endif
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\outputscope.cs ===
//------------------------------------------------------------------------------
// <copyright file="OutputScope.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;

    internal class OutputScope : DocumentScope {
        private string           name;
        private string           nsUri;
        private string           prefix;
        private XmlSpace         space;
        private string           lang;
        private bool             mixed;
        private bool             toCData;
        private HtmlElementProps htmlElementProps; // in HTML output -- atomized name of element

        internal string Name {
            get { return this.name; }
        }
        internal string Namespace {
            get { return this.nsUri; }
        }
        internal string Prefix {
            get { return this.prefix; }
            set { this.prefix = value; }
        }
        internal XmlSpace Space {
            get { return this.space; }
            set { this.space = value; }
        }
        internal string Lang {
            get { return this.lang; }
            set { this.lang = value; }
        }
        internal bool Mixed {
            get { return this.mixed; }
            set { this.mixed = value; }
        }
        internal bool ToCData {
            get { return this.toCData; }
            set { this.toCData = value; }
        }
        internal HtmlElementProps HtmlElementProps {
            get { return this.htmlElementProps; }
            set { this.htmlElementProps = value; }
        }

        internal OutputScope() {
            Init(String.Empty, String.Empty, String.Empty, XmlSpace.None, String.Empty, false);
        }

        internal void Init(string name, string nspace, string prefix, XmlSpace space, string lang, bool mixed) {
            this.scopes           = null;
            this.name             = name;
            this.nsUri            = nspace;
            this.prefix           = prefix;
            this.space            = space;
            this.lang             = lang;
            this.mixed            = mixed;
            this.toCData          = false;
            this.htmlElementProps = null;
        }

        internal bool FindPrefix(string urn, out string prefix) {
            Debug.Assert(urn != null);

            for (NamespaceDecl scope = this.scopes; scope != null; scope = scope.Next) {
                if (Keywords.Equals(scope.Uri, urn) &&
                    scope.Prefix != null            &&
                    scope.Prefix.Length > 0) {
                    prefix = scope.Prefix;
                    return true;
                }
            }

            prefix = String.Empty;
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\processinginstructionaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProcessingInstructionAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class ProcessingInstructionAction : ContainerAction {
        private const int NameEvaluated = 2;
        private const int NameReady     = 3;

        private Avt       nameAvt;
        // Compile time precalculated AVT
        private string    name; 

        private const char CharX = 'X';
        private const char Charx = 'x';
        private const char CharM = 'M';
        private const char Charm = 'm';
        private const char CharL = 'L';
        private const char Charl = 'l';

        internal ProcessingInstructionAction() {}

        internal override void Compile(Compiler compiler) {
            CompileAttributes(compiler);
            CheckRequiredAttribute(compiler, this.nameAvt, Keywords.s_Name);

            if(this.nameAvt.IsConstant) {
                this.name    = this.nameAvt.Evaluate(null, null);
                this.nameAvt = null;
                if (! IsProcessingInstructionName(this.name)) {
                    // For Now: set to null to ignore action late;
                   this.name = null;
               }
            }

            if (compiler.Recurse()) {
                CompileTemplate(compiler);
                compiler.ToParent();
            }
        }

        internal override bool CompileAttribute(Compiler compiler) {
            string name   = compiler.Input.LocalName;
            string value  = compiler.Input.Value;
            if (Keywords.Equals(name, compiler.Atoms.Name)) {
                this.nameAvt = Avt.CompileAvt(compiler, value);
                Debug.WriteLine("name = \"" + value + "\"");
            }
            else {
                return false;
            }

            return true;
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);

            switch (frame.State) {
            case Initialized:
                if(this.nameAvt == null) {
                    frame.StoredOutput = this.name;
                    if(this.name == null) {
                        // name was static but was bad;
                        frame.Finished();
                        break;
                    }
                }
                else {
                    frame.StoredOutput = this.nameAvt.Evaluate(processor, frame);
                    if (! IsProcessingInstructionName(frame.StoredOutput)) {
                        Debug.WriteLine("Invalid Processing instruction naame: \"" + name + "\"");
                        frame.Finished();
                        break;
                    }
                }
                goto case NameReady;

            case NameReady:
                Debug.Assert(frame.StoredOutput != null);
                if (processor.BeginEvent(XPathNodeType.ProcessingInstruction, string.Empty, frame.StoredOutput, string.Empty, false) == false) {
                    // Come back later
                    frame.State = NameReady;
                    break;
                }
                processor.PushActionFrame(frame);
                frame.State = ProcessingChildren;
                break;                              // Allow children to run

            case ProcessingChildren:
                if (processor.EndEvent(XPathNodeType.ProcessingInstruction) == false) {
                    Debug.WriteLine("Cannot end event, breaking, will restart");
                    frame.State = ProcessingChildren;
                    break;
                }
                frame.Finished();
                break;
            default:
                Debug.Fail("Invalid ElementAction execution state");
                frame.Finished();
                break;
            }
        }


        internal static bool IsProcessingInstructionName(string name) {
            if (name == null) {
                return false;
            }

            int nameLength = name.Length;
            int position   = 0;

            while (position < nameLength && XmlCharType.IsWhiteSpace(name[position])) {
                position ++;
            }

            if (position >= nameLength) {
                return false;
            }

            if (position < nameLength && ! XmlCharType.IsStartNCNameChar(name[position])) {
                return false;
            }

            while (position < nameLength && XmlCharType.IsNCNameChar(name[position])) {
                position ++;
            }

            while (position < nameLength && XmlCharType.IsWhiteSpace(name[position])) {
                position ++;
            }

            if (position < nameLength) {
                return false;
            }

            if (nameLength == 3 &&
                (name[0] == CharX || name[0] == Charx) &&
                (name[1] == CharM || name[1] == Charm) &&
                (name[2] == CharL || name[2] == Charl)
            ) {
                return false;
            }

            return true;
        }

        internal override void Trace(int tab) {
            Debug.Indent(tab);
            Debug.WriteLine("<xsl:processing-instruction name=\"" + this.name + "\"");
            base.Trace(tab);
            Debug.Indent(tab);
            Debug.WriteLine("</xsl:processing-instruction>");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\readeroutput.cs ===
//------------------------------------------------------------------------------
// <copyright file="ReaderOutput.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Xml;
    using System.Xml.XPath;
    using System.Collections;

    internal class ReaderOutput : XmlReader, RecordOutput {
        private Processor       processor;
        private XmlNameTable    nameTable;

        // Main node + Fields Collection
        private RecordBuilder   builder;
        private BuilderInfo     mainNode;
        private ArrayList       attributeList;
        private int             attributeCount;
        private BuilderInfo     attributeValue;

        // OutputScopeManager
        private OutputScopeManager  manager;

        // Current position in the list
        private int             currentIndex;
        private BuilderInfo     currentInfo;

        // Reader state
        private ReadState       state = ReadState.Initial;
        private bool            haveRecord;

        // Static default record
        static BuilderInfo      s_DefaultInfo = new BuilderInfo();

        XmlEncoder  encoder = new XmlEncoder();

        internal ReaderOutput(Processor processor) {
            Debug.Assert(processor != null);
            Debug.Assert(processor.NameTable != null);

            this.processor = processor;
            this.nameTable = processor.NameTable;

            Reset();
        }

        // XmlReader abstract methods implementation
        public override XmlNodeType NodeType {
            get {
                CheckCurrentInfo();
                return this.currentInfo.NodeType;
            }
        }

        public override string Name {
            get {
                CheckCurrentInfo();
                string prefix    = Prefix;
                string localName = LocalName;

                if (prefix != null && prefix.Length > 0) {
                    if (localName.Length > 0) {
                        return prefix + ":" + localName;
                    }
                    else {
                        return prefix;
                    }
                }
                else {
                    return localName;
                }
            }
        }

        public override string LocalName {
            get {
                CheckCurrentInfo();
                return this.currentInfo.LocalName;
            }
        }

        public override string NamespaceURI {
            get {
                CheckCurrentInfo();
                return this.currentInfo.NamespaceURI;
            }
        }

        public override string Prefix {
            get {
                CheckCurrentInfo();
                return this.currentInfo.Prefix;
            }
        }

        public override bool HasValue {
            get {
                switch (NodeType) {
                case XmlNodeType.Attribute:
                case XmlNodeType.Text:
                case XmlNodeType.CDATA:
                case XmlNodeType.ProcessingInstruction:
                case XmlNodeType.Comment:
                case XmlNodeType.Whitespace:
                case XmlNodeType.DocumentType:
                case XmlNodeType.SignificantWhitespace:
//              case XmlNodeType.CharacterEntity:
                case XmlNodeType.XmlDeclaration:
                    return true;
                case XmlNodeType.None:
                case XmlNodeType.Element:
                case XmlNodeType.EntityReference:
                case XmlNodeType.Entity:
                case XmlNodeType.Document:
                case XmlNodeType.DocumentFragment:
                case XmlNodeType.Notation:
                case XmlNodeType.EndElement:
                case XmlNodeType.EndEntity:
                    return false;
                default:
                    Debug.Fail("Invalid node type");
                    return false;
                }
            }
        }

        public override string Value {
            get {
                CheckCurrentInfo();
                return this.currentInfo.Value;
            }
        }

        public override int Depth {
            get {
                CheckCurrentInfo();
                return this.currentInfo.Depth;
            }
        }

        public override string BaseURI {
            get {
                return String.Empty;
            }
        }

        public override bool IsEmptyElement {
            get {
                CheckCurrentInfo();
                return this.currentInfo.IsEmptyTag;
            }
        }

        public override char QuoteChar {
            get { return encoder.QuoteChar; }
        }

        public override bool IsDefault {
            get { return false; }
        }

        public override XmlSpace XmlSpace {
            get { return this.manager != null ? this.manager.XmlSpace : XmlSpace.None; }
        }

        public override string XmlLang {
            get { return this.manager != null ? this.manager.XmlLang : String.Empty; }
        }

        // Attribute Accessors

        public override int AttributeCount {
            get { return this.attributeCount; }
        }

        public override string GetAttribute(string name) {
            int ordinal;
            if (FindAttribute(name, out ordinal)) {
                Debug.Assert(ordinal >= 0);
                return((BuilderInfo)this.attributeList[ordinal]).Value;
            }
            else {
                Debug.Assert(ordinal == -1);
                return null;
            }            
        }

        public override string GetAttribute(string localName, string namespaceURI) {
            int ordinal;
            if (FindAttribute(localName, namespaceURI, out ordinal)) {
                Debug.Assert(ordinal >= 0);
                return((BuilderInfo)this.attributeList[ordinal]).Value;
            }
            else {
                Debug.Assert(ordinal == -1);
                return null;
            }
        }

        public override string GetAttribute(int i) {
            BuilderInfo attribute = GetBuilderInfo(i);
            return attribute.Value;
        }

        public override string this [int i] {
            get { return GetAttribute(i); }
        }

        public override string this [string name] {
            get { return GetAttribute(name); }
        }

        public override string this [string name, string namespaceURI] {
            get { return GetAttribute(name, namespaceURI); }
        }

        public override bool MoveToAttribute(string name) {
            int ordinal;
            if (FindAttribute(name, out ordinal)) {
                Debug.Assert(ordinal >= 0);
                SetAttribute(ordinal);
                return true;
            }
            else {
                Debug.Assert(ordinal == -1);
                return false;
            }
        }

        public override bool MoveToAttribute(string localName, string namespaceURI) {
            int ordinal;
            if (FindAttribute(localName, namespaceURI, out ordinal)) {
                Debug.Assert(ordinal >= 0);
                SetAttribute(ordinal);
                return true;
            }
            else {
                Debug.Assert(ordinal == -1);
                return false;
            }
        }

        public override void MoveToAttribute(int i) {
            if (i < 0 || this.attributeCount <= i) {
                throw new ArgumentOutOfRangeException("i");
            }
            SetAttribute(i);
        }

        public override bool MoveToFirstAttribute() {
            if (this.attributeCount <= 0) {
                Debug.Assert(this.attributeCount == 0);
                return false;
            }
            else {
                SetAttribute(0);
                return true;
            }
        }

        public override bool MoveToNextAttribute() {
            if (this.currentIndex + 1 < this.attributeCount) {
                SetAttribute(this.currentIndex + 1);
                return true;
            }
            return false;
        }

        public override bool MoveToElement() {
            if (NodeType == XmlNodeType.Attribute || this.currentInfo == this.attributeValue) {
                SetMainNode();
                return true;
            }
            return false;
        }

        // Moving through the Stream

        public override bool Read() {
            Debug.Assert(this.processor != null || this.state == ReadState.Closed);

            if (this.state != ReadState.Interactive) {
                if (this.state == ReadState.Initial) {
                    state = ReadState.Interactive;
                }
                else {
                    return false;
                }
            }

            while (true) { // while -- to ignor empty whitespace nodes.
                if (this.haveRecord) {
                    this.processor.ResetOutput();
                    this.haveRecord = false;
                }

                this.processor.Execute();

                if (this.haveRecord) {
                    CheckCurrentInfo();
                    // check text nodes on whitespaces;
                    switch (this.NodeType) {
                    case XmlNodeType.Text :
                        if (XmlCharType.IsOnlyWhitespace(this.Value)) {
                            this.currentInfo.NodeType = XmlNodeType.Whitespace;
                            goto case XmlNodeType.Whitespace;
                        }
                        Debug.Assert(this.Value.Length != 0, "It whould be Whitespace in this case");
                        break;
                    case XmlNodeType.Whitespace :
                        if(this.Value.Length == 0) {
                            continue;                          // ignoring emty text nodes
                        }
                        if (this.XmlSpace == XmlSpace.Preserve) {
                            this.currentInfo.NodeType = XmlNodeType.SignificantWhitespace;
                        }
                        break;
                    }                
                }
                else {
                    Debug.Assert(this.processor.ExecutionDone);
                    this.state = ReadState.EndOfFile;
                    Reset();
                }

                return this.haveRecord;
            }
        }

        public override bool EOF {
            get { return this.state == ReadState.EndOfFile; }
        }

        public override void Close() {
            this.processor = null;
            this.state     = ReadState.Closed;
            Reset();
        }

        public override ReadState ReadState {
            get { return this.state; }
        }

        // Whole Content Read Methods
        public override string ReadString() {
            string result = string.Empty;

            if (NodeType == XmlNodeType.Element || NodeType == XmlNodeType.Attribute || this.currentInfo == this.attributeValue) {
                if(this.mainNode.IsEmptyTag) {
                    return result;
                }
                if (! Read()) {
                    throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation));
                }
            }

            while(true) {
                switch (NodeType) {
                case XmlNodeType.Text:
                case XmlNodeType.Whitespace:
                case XmlNodeType.SignificantWhitespace:
//              case XmlNodeType.CharacterEntity:
                    result += this.Value;
                    if (! Read())
                        throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation));
    		        break;
                default :
                    return result;
                }
            }
        }

        public override string ReadInnerXml() {
            if (ReadState == ReadState.Interactive) {
                if (NodeType == XmlNodeType.Element && ! IsEmptyElement) {
                    StringOutput output = new StringOutput(this.processor);
                    output.OmitXmlDecl();
                    int depth = Depth;

                    Read();                 // skeep  begin Element
                    while (depth < Depth) { // process content
                        Debug.Assert(this.builder != null);
                        output.RecordDone(this.builder);
                        Read();
                    }
                    Debug.Assert(NodeType == XmlNodeType.EndElement);
                    Read();                 // skeep end element

                    output.TheEnd();
                    return output.Result;
                }
                else if(NodeType == XmlNodeType.Attribute) {
                    return encoder.AtributeInnerXml(Value);
                }
                else {
                    Read();
                }
            }
            return String.Empty;
        }

        public override string ReadOuterXml() {
            if (ReadState == ReadState.Interactive) {
                if (NodeType == XmlNodeType.Element) {
                    StringOutput output = new StringOutput(this.processor);
                    output.OmitXmlDecl();
                    bool emptyElement = IsEmptyElement;
                    int  depth        = Depth;
                    // process current record
                    output.RecordDone(this.builder); 
                    Read();                          
                    // process internal elements & text nodes
                    while(depth < Depth) {                      
                        Debug.Assert(this.builder != null);
                        output.RecordDone(this.builder);
                        Read();
                    }
                    // process end element
                    if (! emptyElement) {
                        output.RecordDone(this.builder);            
                        Read();
                    }

                    output.TheEnd();
                    return output.Result; 
                }
                else if(NodeType == XmlNodeType.Attribute) {
                    return encoder.AtributeOuterXml(Name, Value);
                }
                else {
                    Read();
                }
            }
            return String.Empty;
        }

        //
        // Nametable and Namespace Helpers
        //

        public override XmlNameTable NameTable {
            get {
                Debug.Assert(this.nameTable != null);
                return this.nameTable;
            }
        }

        public override string LookupNamespace(string prefix) {
            prefix = this.nameTable.Get(prefix);

            if (this.manager != null && prefix != null) {
                return this.manager.ResolveNamespace(prefix);
            }
            return null;
        }

        public override void ResolveEntity() {
            Debug.Assert(NodeType != XmlNodeType.EntityReference);

            if (NodeType != XmlNodeType.EntityReference) {
                throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation));
            }
        }

        public override bool ReadAttributeValue() {
            if (ReadState != ReadState.Interactive || NodeType != XmlNodeType.Attribute) {
                return false;
            }

            if (this.attributeValue == null) {
                this.attributeValue = new BuilderInfo();
                this.attributeValue.NodeType = XmlNodeType.Text;
            }
            if (this.currentInfo == this.attributeValue) {
                return false;
            }

            this.attributeValue.Value = this.currentInfo.Value;
            this.attributeValue.Depth = this.currentInfo.Depth + 1;
            this.currentInfo          = this.attributeValue;

            return true;
        }

        //
        // RecordOutput interface method implementation
        //

        public Processor.OutputResult RecordDone(RecordBuilder record) {
            this.builder        = record;
            this.mainNode       = record.MainNode;
            this.attributeList  = record.AttributeList;
            this.attributeCount = record.AttributeCount;
            this.manager        = record.Manager;

            this.haveRecord     = true;
            SetMainNode();

            return Processor.OutputResult.Interrupt;
        }

        public void TheEnd() {
            // nothing here, was taken care of by RecordBuilder
        }

        //
        // Implementation internals
        //

        private void SetMainNode() {
            this.currentIndex   = -1;
            this.currentInfo    = this.mainNode;
        }

        private void SetAttribute(int attrib) {
            Debug.Assert(0 <= attrib && attrib < this.attributeCount);
            Debug.Assert(0 <= attrib && attrib < this.attributeList.Count);
            Debug.Assert(this.attributeList[attrib] is BuilderInfo);

            this.currentIndex = attrib;
            this.currentInfo  = (BuilderInfo) this.attributeList[attrib];
        }

        private BuilderInfo GetBuilderInfo(int attrib) {
            if (attrib < 0 || this.attributeCount <= attrib) {
                throw new ArgumentOutOfRangeException("attrib");
            }

            Debug.Assert(this.attributeList[attrib] is BuilderInfo);

            return(BuilderInfo) this.attributeList[attrib];
        }

        private bool FindAttribute(String localName, String namespaceURI, out int attrIndex) {
            if (namespaceURI == null) {
                namespaceURI = String.Empty;
            }
            if (localName == null) {
                localName    = String.Empty;
            }

            for (int index = 0; index < this.attributeCount; index ++) {
                Debug.Assert(this.attributeList[index] is BuilderInfo);

                BuilderInfo attribute = (BuilderInfo) this.attributeList[index];
                if (attribute.NamespaceURI == namespaceURI && attribute.LocalName == localName) {
                    attrIndex = index;
                    return true;
                }
            }

            attrIndex = -1;
            return false;
        }

        private bool FindAttribute(String name, out int attrIndex) {
            if (name == null) {
                name  = String.Empty;
            }

            for (int index = 0; index < this.attributeCount; index ++) {
                Debug.Assert(this.attributeList[index] is BuilderInfo);

                BuilderInfo attribute = (BuilderInfo) this.attributeList[index];
                if (attribute.Name == name) {
                    attrIndex = index;
                    return true;
                }
            }

            attrIndex = -1;
            return false;
        }

        private void Reset() {
            this.currentIndex = -1;
            this.currentInfo  = s_DefaultInfo;
            this.mainNode     = s_DefaultInfo;
            this.manager      = null;
        }

        [System.Diagnostics.Conditional("DEBUG")]
        private void CheckCurrentInfo() {
            Debug.Assert(this.currentInfo   != null);
            Debug.Assert(this.attributeCount == 0 || this.attributeList != null);
            Debug.Assert((this.currentIndex == -1) == (this.currentInfo == this.mainNode));
            Debug.Assert((this.currentIndex == -1) || (this.currentInfo == this.attributeValue || this.attributeList[this.currentIndex] is BuilderInfo && this.attributeList[this.currentIndex] == this.currentInfo));
        }

        private class XmlEncoder {
            private StringBuilder  buffer  = null;
            private XmlTextEncoder encoder = null;

            private void Init() {
                buffer  = new StringBuilder();
                encoder = new XmlTextEncoder(new StringWriter(buffer), Encoding.Unicode);
            }

            public string AtributeInnerXml(string value) {
                if(encoder == null) Init();
                buffer .Length = 0;       // clean buffer
                encoder.StartAttribute(/*save:*/false);
                encoder.Write(value);
                encoder.EndAttribute();
                return buffer.ToString();
            }

            public string AtributeOuterXml(string name, string value) {
                if(encoder == null) Init();
                buffer .Length = 0;       // clean buffer
                buffer .Append(name);
                buffer .Append('=');
                buffer .Append(QuoteChar);
                encoder.StartAttribute(/*save:*/false);
                encoder.Write(value);
                encoder.EndAttribute();
                buffer .Append(QuoteChar);
                return buffer.ToString();
            }

            public char QuoteChar {
                get { return '"'; }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\recordoutput.cs ===
//------------------------------------------------------------------------------
// <copyright file="RecordOutput.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {

    internal interface RecordOutput {
        Processor.OutputResult RecordDone(RecordBuilder record);
        void TheEnd();
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\outputscopemanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="OutputScopeManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;

    internal class OutputScopeManager {
        private const int STACK_INCREMENT = 10;

        private HWStack         elementScopesStack;
        private string          defaultNS;
        private OutKeywords     atoms;
        private XmlNameTable    nameTable;
        private int             prefixIndex;

        internal string DefaultNamespace {
            get { return this.defaultNS; }
        }

        internal OutputScope CurrentElementScope {
            get {
                Debug.Assert(this.elementScopesStack.Peek() != null); // We adding rootElementScope to garantee this
                return (OutputScope) this.elementScopesStack.Peek();
            }
        }

        internal XmlSpace XmlSpace {
            get { return CurrentElementScope.Space; }
        }

        internal string XmlLang {
            get { return CurrentElementScope.Lang; }
        }

        internal OutputScopeManager(XmlNameTable nameTable, OutKeywords atoms) {
            Debug.Assert(nameTable != null);
            Debug.Assert(atoms     != null);

            this.elementScopesStack = new HWStack(STACK_INCREMENT);
            this.nameTable          = nameTable;
            this.atoms              = atoms;
            this.defaultNS          = this.atoms.Empty;

            // We always adding rootElementScope to garantee that CurrentElementScope != null
            // This context is active between PI and first element for example
            OutputScope rootElementScope = (OutputScope) this.elementScopesStack.Push();
            if(rootElementScope == null) {
                rootElementScope = new OutputScope();
                this.elementScopesStack.AddToTop(rootElementScope);
            }
            rootElementScope.Init(string.Empty, string.Empty, string.Empty, /*space:*/XmlSpace.None, /*lang:*/String.Empty, /*mixed:*/false);
        }

        internal void PushNamespace(string prefix, string nspace) {
            Debug.Assert(prefix != null);
            Debug.Assert(nspace != null);
            CurrentElementScope.AddNamespace(prefix, nspace, this.defaultNS);

            if (prefix == null || prefix.Length == 0) {
                this.defaultNS = nspace;
            }
        }

        internal void PushScope(string name, string nspace, string prefix) {
            Debug.Assert(name != null);
            Debug.Assert(nspace != null);
            Debug.Assert(prefix != null);
            OutputScope parentScope  = CurrentElementScope;
            OutputScope elementScope = (OutputScope) this.elementScopesStack.Push();

            if (elementScope == null) {
                elementScope = new OutputScope();
                this.elementScopesStack.AddToTop(elementScope);
            }

            Debug.Assert(elementScope != null);
            elementScope.Init(name, nspace, prefix, parentScope.Space, parentScope.Lang, parentScope.Mixed);
        }

        internal void PopScope() {
            OutputScope elementScope = (OutputScope) this.elementScopesStack.Pop();

            Debug.Assert(elementScope != null); // We adding rootElementScope to garantee this

            for (NamespaceDecl scope = elementScope.Scopes; scope != null; scope = scope.Next) {
                Debug.WriteLine("Popping namespace scope : " + scope.Prefix + " : " + scope.Uri);
                this.defaultNS = scope.PrevDefaultNsUri;
            }
        }

        internal string ResolveNamespace(string prefix) {
            bool thisScope;
            return ResolveNamespace(prefix, out thisScope);
        }

        internal string ResolveNamespace(string prefix, out bool thisScope) {
            Debug.Assert(prefix != null);
            thisScope = true;

            if (prefix == null || prefix.Length == 0) {
                return this.defaultNS;
            }
            else {
                if (Keywords.Equals(prefix, this.atoms.Xml)) {
                    return this.atoms.XmlNamespace;
                }
                else if (Keywords.Equals(prefix, this.atoms.Xmlns)) {
                    return this.atoms.XmlnsNamespace;
                }

                for (int i = this.elementScopesStack.Length - 1; i >= 0; i --) {
                    Debug.Assert(this.elementScopesStack[i] is OutputScope);
                    OutputScope elementScope = (OutputScope) this.elementScopesStack[i];

                    string nspace = elementScope.ResolveAtom(prefix);
                    if (nspace != null) {
                        thisScope = (i == this.elementScopesStack.Length - 1);
                        return nspace;
                    }
                }
            }

            return null;
        }

        internal bool FindPrefix(string nspace, out string prefix) {
            Debug.Assert(nspace != null);
            for (int i = this.elementScopesStack.Length - 1; 0 <= i; i--) {
                Debug.Assert(this.elementScopesStack[i] is OutputScope);

                OutputScope elementScope = (OutputScope) this.elementScopesStack[i];
                string      pfx          = null;
                if (elementScope.FindPrefix(nspace, out pfx)) {
                    string testNspace = ResolveNamespace(pfx);
                    if(testNspace != null && Keywords.Equals(testNspace, nspace)) {
                        prefix = pfx;
                        return true;
                    }
                    else {
                        break;
                    }
                }
            }
            prefix = null;
            return false;
        }

        internal string GeneratePrefix(string format) {
            string prefix;

            do {
                prefix = String.Format(format, this.prefixIndex ++);
            }while(this.nameTable.Get(prefix) != null);

            return this.nameTable.Add(prefix);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\prefixqname.cs ===
//------------------------------------------------------------------------------
// <copyright file="PrefixQName.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Xml;

    internal sealed class PrefixQName {
        public string Prefix;
        public string Name;
        public string Namespace;

        internal void ClearPrefix() {
            Prefix = string.Empty;
        }

        internal void SetQName(string qname) {
            PrefixQName.ParseQualifiedName(qname, out Prefix, out Name);
        }

        //
        // Parsing qualified names
        //

        private static string ParseNCName(string qname, ref int position) {
            int qnameLength = qname.Length;
            int nameStart = position;

            if (
                qnameLength == position ||                           // Zero length ncname
                ! XmlCharType.IsStartNCNameChar(qname[position])     // Start from invalid char
            ) {
                throw new XsltException(Res.Xslt_InvalidQName, qname);
            }

            position ++;

            while (position < qnameLength && XmlCharType.IsNCNameChar(qname[position])) {
                position ++;
            }

            return qname.Substring(nameStart, position - nameStart);
        }

        public static void ParseQualifiedName(string qname, out string prefix, out string local) {
            Debug.Assert(qname != null);
            prefix = string.Empty;
            local  = string.Empty;
            int position    = 0;

            local = ParseNCName(qname, ref position);

            if (position < qname.Length) {
                if (qname[position] == ':') {
                    position ++;
                    prefix = local;
                    local  = ParseNCName(qname, ref position);
                }

                if (position < qname.Length) {
                    throw new XsltException(Res.Xslt_InvalidQName, qname);
                }
            }
        }

        public static bool ValidatePrefix(string prefix) {
            int position = 0;
            try {
                PrefixQName.ParseNCName(prefix, ref position);
            }
            catch (Exception) {}
            return position == prefix.Length;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\recordbuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="RecordBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {

    using System;
    using System.Diagnostics;
    using System.Text;
    using System.Xml;
    using System.Xml.XPath;
    using System.Collections;

    internal sealed class RecordBuilder {
        private int             outputState;
        private RecordBuilder   next;

        RecordOutput            output;

        // Atomization:
        private XmlNameTable    nameTable;
        private OutKeywords     atoms;

        // Namespace manager for output
        private OutputScopeManager  scopeManager;

        // Main node + Fields Collection
        private BuilderInfo     mainNode           = new BuilderInfo();
        private ArrayList       attributeList      = new ArrayList();
        private int             attributeCount;
        private ArrayList       namespaceList      = new ArrayList();
        private int             namespaceCount;
        private BuilderInfo     dummy = new BuilderInfo();

        // Current position in the list
        private BuilderInfo     currentInfo;
        // Builder state
        private bool            popScope;
        private int             recordState;
        private int             recordDepth;

        private const int       NoRecord    = 0;      // No part of a new record was generated (old record was cleared out)
        private const int       SomeRecord  = 1;      // Record was generated partially        (can be eventually record)
        private const int       HaveRecord  = 2;      // Record was fully generated

        private const char      s_Minus         = '-';
        private const string    s_Space         = " ";
        private const string    s_SpaceMinus    = " -";
        private const char      s_Question      = '?';
        private const char      s_Greater       = '>';
        private const string    s_SpaceGreater  = " >";

        private const string    PrefixFormat    = "xp_{0}";
        private const string    s_SpaceDefault  = "default";
        private const string    s_SpacePreserve = "preserve";

        internal RecordBuilder(RecordOutput output, XmlNameTable nameTable) {
            Debug.Assert(output != null);
            this.output    = output;
            this.nameTable = nameTable != null ? nameTable : new NameTable();
            this.atoms     = new OutKeywords(this.nameTable);
            this.scopeManager   = new OutputScopeManager(this.nameTable, this.atoms);
        }

        //
        // Internal properties
        //

        internal int OutputState {
            get { return this.outputState; }
            set { this.outputState = value; }
        }

        internal RecordBuilder Next {
            get { return this.next; }
            set { this.next = value; }
        }

        internal RecordOutput Output {
            get { return this.output; }
        }

        internal BuilderInfo MainNode {
            get { return this.mainNode; }
        }

        internal ArrayList AttributeList {
            get { return this.attributeList; }
        }

        internal int AttributeCount {
            get { return this.attributeCount; }
        }

        internal OutputScopeManager Manager {
            get { return this.scopeManager; }
        }

        // Private properties
        private string LocalName {
            get { return this.currentInfo.LocalName; }
            set { this.currentInfo.LocalName = value; }
        }
        private string NamespaceURI {
            get { return this.currentInfo.NamespaceURI; }
            set { this.currentInfo.NamespaceURI = value; }
        }
        private string Prefix {
            get { return this.currentInfo.Prefix; }
            set { this.currentInfo.Prefix = value; }
        }
        private HtmlElementProps htmlProps {
            get { return this.currentInfo.htmlProps; }
            set { this.currentInfo.htmlProps = value; }
        }
        private HtmlAttributeProps htmlAttrProps {
            get { return this.currentInfo.htmlAttrProps; }
            set { this.currentInfo.htmlAttrProps = value; }
        }
        private void ValueAppend(string s, bool disableOutputEscaping) {
            this.currentInfo.ValueAppend(s, disableOutputEscaping);
        }
        private XmlNodeType NodeType {
            get { return this.currentInfo.NodeType; }
            set { this.currentInfo.NodeType = value; }
        }
        private int Depth {
            get { return this.currentInfo.Depth; }
            set { this.currentInfo.Depth = value; }
        }
        private bool IsEmptyTag {
            get { return this.currentInfo.IsEmptyTag; }
            set { this.currentInfo.IsEmptyTag = value; }
        }

        private bool CanOutput(int state) {
            Debug.Assert(this.recordState != HaveRecord);

            // If we have no record cached or the next event doesn't start new record, we are OK

            if (this.recordState == NoRecord || (state & StateMachine.BeginRecord) == 0) {
                return true;
            }
            else {
                this.recordState = HaveRecord;
                FinalizeRecord();
                SetEmptyFlag(state);
                return this.output.RecordDone(this) == Processor.OutputResult.Continue;
            }
        }

        internal Processor.OutputResult BeginEvent(int state, XPathNodeType nodeType, string prefix, string name, string nspace, bool empty, Object htmlProps, bool search) {
            if (! CanOutput(state)) {
                return Processor.OutputResult.Overflow;
            }

            Debug.Assert(this.recordState == NoRecord || (state & StateMachine.BeginRecord) == 0);

            AdjustDepth(state);
            ResetRecord(state);
            PopElementScope();

            prefix = (prefix != null) ? this.nameTable.Add(prefix) : this.atoms.Empty;
            name   = (name   != null) ? this.nameTable.Add(name)   : this.atoms.Empty;
            nspace = (nspace != null) ? this.nameTable.Add(nspace) : this.atoms.Empty;

            switch (nodeType) {
            case XPathNodeType.Element:
                this.mainNode.htmlProps = htmlProps as HtmlElementProps;
                this.mainNode.search = search;
                BeginElement(prefix, name, nspace, empty);
                break;
            case XPathNodeType.Attribute:
                BeginAttribute(prefix, name, nspace, htmlProps, search);
                break;
            case XPathNodeType.Namespace:
                BeginNamespace(name, nspace);
                break;
            case XPathNodeType.Text:
                break;
            case XPathNodeType.ProcessingInstruction:
                if (BeginProcessingInstruction(prefix, name, nspace) == false) {
                    return Processor.OutputResult.Error;
                }
                break;
            case XPathNodeType.Comment:
                BeginComment();
                break;
            case XPathNodeType.Root:
                break;
            case XPathNodeType.Whitespace:
            case XPathNodeType.SignificantWhitespace:
            case XPathNodeType.All:
                break;
            }

            return CheckRecordBegin(state);
        }

        internal Processor.OutputResult TextEvent(int state, string text, bool disableOutputEscaping) {
            if (! CanOutput(state)) {
                return Processor.OutputResult.Overflow;
            }

            Debug.Assert(this.recordState == NoRecord || (state & StateMachine.BeginRecord) == 0);

            AdjustDepth(state);
            ResetRecord(state);
            PopElementScope();

            if ((state & StateMachine.BeginRecord) != 0) {
                Depth      = this.recordDepth;
                NodeType   = XmlNodeType.Text;
            }

            ValueAppend(text, disableOutputEscaping);

            return CheckRecordBegin(state);
        }

        internal Processor.OutputResult EndEvent(int state, XPathNodeType nodeType) {
            if (! CanOutput(state)) {
                return Processor.OutputResult.Overflow;
            }

            AdjustDepth(state);
            PopElementScope();
            this.popScope = (state & StateMachine.PopScope) != 0;

            if ((state & StateMachine.EmptyTag) != 0 && this.mainNode.IsEmptyTag == true) {
                return Processor.OutputResult.Continue;
            }

            ResetRecord(state);

            if ((state & StateMachine.BeginRecord) != 0) {
                if(nodeType == XPathNodeType.Element) {
                    EndElement();
                }
            }

            return CheckRecordEnd(state);
        }

        internal void Reset() {
            if (this.recordState == HaveRecord) {
                this.recordState = NoRecord;
            }
        }

        internal void TheEnd() {
            if (this.recordState == SomeRecord) {
                this.recordState = HaveRecord;
                FinalizeRecord();
                this.output.RecordDone(this);
            }
            this.output.TheEnd();
        }

        //
        // Utility implementation methods
        //

        private BuilderInfo GetBuilderInfo(int attrib) {
            if (attrib < 0 || attrib >= this.attributeCount) {
                throw new IndexOutOfRangeException("attrib");
            }

            Debug.Assert(this.attributeList[attrib] is BuilderInfo);

            return(BuilderInfo) this.attributeList[attrib];
        }

        private int FindAttribute(string name, string nspace, ref string prefix) {
            Debug.Assert(this.attributeCount <= this.attributeList.Count);

            for (int attrib = 0; attrib < this.attributeCount; attrib ++) {
                Debug.Assert(this.attributeList[attrib] != null && this.attributeList[attrib] is BuilderInfo);

                BuilderInfo attribute = (BuilderInfo) this.attributeList[attrib];

                if (Keywords.Equals(attribute.LocalName, name)) {
                    if (Keywords.Equals(attribute.NamespaceURI, nspace)) {
                        return attrib;
                    }
                    if (Keywords.Equals(attribute.Prefix, prefix)) {
                        // prefix conflict. Should be renamed.
                        prefix = string.Empty;
                    }
                }

            }

            return -1;
        }

        private void BeginElement(string prefix, string name, string nspace, bool empty) {
            Debug.Assert(this.attributeCount == 0);

            NodeType     = XmlNodeType.Element;
            Prefix       = prefix;
            LocalName    = name;
            NamespaceURI = nspace;
            Depth        = this.recordDepth;
            IsEmptyTag   = empty;

            this.scopeManager.PushScope(name, nspace, prefix);
        }

        private void EndElement() {
            Debug.Assert(this.attributeCount == 0);
            OutputScope elementScope = this.scopeManager.CurrentElementScope;

            NodeType     = XmlNodeType.EndElement;
            Prefix       = elementScope.Prefix;
            LocalName    = elementScope.Name;
            NamespaceURI = elementScope.Namespace;
            Depth        = this.recordDepth;
        }

        private int NewAttribute() {
            if (this.attributeCount >= this.attributeList.Count) {
                Debug.Assert(this.attributeCount == this.attributeList.Count);
                this.attributeList.Add(new BuilderInfo());
            }
            return this.attributeCount ++;
        }

        private void BeginAttribute(string prefix, string name, string nspace, Object htmlAttrProps, bool search) {
            int attrib = FindAttribute(name, nspace, ref prefix);

            if (attrib == -1) {
                attrib = NewAttribute();
            }

            Debug.Assert(this.attributeList[attrib] != null && this.attributeList[attrib] is BuilderInfo);

            BuilderInfo attribute = (BuilderInfo) this.attributeList[attrib];
            attribute.Initialize(prefix, name, nspace);
            attribute.Depth    = this.recordDepth;
            attribute.NodeType = XmlNodeType.Attribute;
            attribute.htmlAttrProps = htmlAttrProps as HtmlAttributeProps;
            attribute.search = search;
            this.currentInfo  = attribute;
        }

        private void BeginNamespace(string name, string nspace) {
            bool thisScope = false;
            if (Keywords.Equals(name, this.atoms.Empty)) {
                if (Keywords.Equals(nspace, this.scopeManager.DefaultNamespace)) {
                    // Main Node is OK
                }
                else if (Keywords.Equals(this.mainNode.NamespaceURI, this.atoms.Empty)) {
                    // http://www.w3.org/1999/11/REC-xslt-19991116-errata/ E25 
                    // Should throw an error but ingnoring it in Everett. 
                    // Would be a breaking change
                }
                else {
                    DeclareNamespace(nspace, name);
                }
            }
            else {
                string nspaceDeclared = this.scopeManager.ResolveNamespace(name, out thisScope);
                if (nspaceDeclared != null) {
                    if (! Keywords.Equals(nspace, nspaceDeclared)) {
                        if(!thisScope) {
                            DeclareNamespace(nspace, name);
                        }
                    }
                }
                else {
                     DeclareNamespace(nspace, name);
                }
            }
            this.currentInfo = dummy;
            currentInfo.NodeType = XmlNodeType.Attribute;
        }

        private bool BeginProcessingInstruction(string prefix, string name, string nspace) {
            NodeType     = XmlNodeType.ProcessingInstruction;
            Prefix       = prefix;
            LocalName    = name;
            NamespaceURI = nspace;
            Depth        = this.recordDepth;
            return true;
        }

        private void BeginComment() {
            NodeType   = XmlNodeType.Comment;
            Depth      = this.recordDepth;
        }

        private void AdjustDepth(int state) {
            switch (state & StateMachine.DepthMask) {
            case StateMachine.DepthUp:
                this.recordDepth ++;
                break;
            case StateMachine.DepthDown:
                this.recordDepth --;
                break;
            default:
                break;
            }
        }

        private void ResetRecord(int state) {
            Debug.Assert(this.recordState == NoRecord || this.recordState == SomeRecord);

            if ((state & StateMachine.BeginRecord) != 0) {
                this.attributeCount     = 0;
                this.namespaceCount     = 0;
                this.currentInfo        = this.mainNode;

                LocalName    = NamespaceURI = Prefix = this.atoms.Empty;
                this.currentInfo.ClearValue();
                NodeType      = XmlNodeType.None;
                IsEmptyTag    = false;
                htmlProps     = null;
                htmlAttrProps = null;
            }
        }

        private void PopElementScope() {
            if (this.popScope) {
                this.scopeManager.PopScope();
                this.popScope = false;
            }
        }

        private Processor.OutputResult CheckRecordBegin(int state) {
            Debug.Assert(this.recordState == NoRecord || this.recordState == SomeRecord);

            if ((state & StateMachine.EndRecord) != 0) {
                this.recordState = HaveRecord;
                FinalizeRecord();
                SetEmptyFlag(state);
                return this.output.RecordDone(this);
            }
            else {
                this.recordState = SomeRecord;
                return Processor.OutputResult.Continue;
            }
        }

        private Processor.OutputResult CheckRecordEnd(int state) {
            Debug.Assert(this.recordState == NoRecord || this.recordState == SomeRecord);

            if ((state & StateMachine.EndRecord) != 0) {
                this.recordState = HaveRecord;
                FinalizeRecord();
                SetEmptyFlag(state);
                return this.output.RecordDone(this);
            }
            else {
                // For end event, if there is no end token, don't force token
                return Processor.OutputResult.Continue;
            }
        }

        private void SetEmptyFlag(int state) {
            Debug.Assert(this.mainNode != null);

            if ((state & StateMachine.BeginChild) != 0) {
                this.mainNode.IsEmptyTag = false;
            }
        }


        private void AnalyzeSpaceLang() {
            Debug.Assert(this.mainNode.NodeType == XmlNodeType.Element);

            for (int attr = 0; attr < this.attributeCount; attr ++) {
                Debug.Assert(this.attributeList[attr] is BuilderInfo);
                BuilderInfo info = (BuilderInfo) this.attributeList[attr];

                if (Keywords.Equals(info.Prefix, this.atoms.Xml)) {
                    OutputScope scope = this.scopeManager.CurrentElementScope;

                    if (Keywords.Equals(info.LocalName, this.atoms.Lang)) {
                        scope.Lang  = info.Value;
                    }
                    else if (Keywords.Equals(info.LocalName, this.atoms.Space)) {
                        scope.Space = TranslateXmlSpace(info.Value);
                    }
                }
            }
        }

        private void FixupElement() {
            Debug.Assert(this.mainNode.NodeType == XmlNodeType.Element);

            if (Keywords.Equals(this.mainNode.NamespaceURI, this.atoms.Empty)) {
                this.mainNode.Prefix = this.atoms.Empty;
            }

            if (Keywords.Equals(this.mainNode.Prefix, this.atoms.Empty)) {
                if (Keywords.Equals(this.mainNode.NamespaceURI, this.scopeManager.DefaultNamespace)) {
                    // Main Node is OK
                }
                else {
                    DeclareNamespace(this.mainNode.NamespaceURI, this.mainNode.Prefix);
                }
            }
            else {
                bool   thisScope = false;
                string nspace = this.scopeManager.ResolveNamespace(this.mainNode.Prefix, out thisScope);
                if (nspace != null) {
                    if (! Keywords.Equals(this.mainNode.NamespaceURI, nspace)) {
                        if (thisScope) {    // Prefix conflict
                            this.mainNode.Prefix = GetPrefixForNamespace(this.mainNode.NamespaceURI);
                        }
                        else {
                            DeclareNamespace(this.mainNode.NamespaceURI, this.mainNode.Prefix);
                        }
                    }
                }
                else {
                    DeclareNamespace(this.mainNode.NamespaceURI, this.mainNode.Prefix);
                }
            }

            OutputScope elementScope = this.scopeManager.CurrentElementScope;
            elementScope.Prefix      = this.mainNode.Prefix;
        }

        private void FixupAttributes(int attributeCount) {
            for (int attr = 0; attr < attributeCount; attr ++) {
                Debug.Assert(this.attributeList[attr] is BuilderInfo);
                BuilderInfo info = (BuilderInfo) this.attributeList[attr];


                if (Keywords.Equals(info.NamespaceURI, this.atoms.Empty)) {
                    info.Prefix = this.atoms.Empty;
                }
                else {
                    if (Keywords.Equals(info.Prefix, this.atoms.Empty)) {
                        info.Prefix = GetPrefixForNamespace(info.NamespaceURI);
                    }
                    else {
                        bool thisScope = false;
                        string nspace = this.scopeManager.ResolveNamespace(info.Prefix, out thisScope);
                        if (nspace != null) {
                            if (! Keywords.Equals(info.NamespaceURI, nspace)) {
                                if(thisScope) { // prefix conflict
                                    info.Prefix = GetPrefixForNamespace(info.NamespaceURI);
                                }
                                else {
                                    DeclareNamespace(info.NamespaceURI, info.Prefix);
                                }
                            }
                        }
                        else {
                            DeclareNamespace(info.NamespaceURI, info.Prefix);
                        }
                    }
                }
            }
        }

        private void AppendNamespaces() {
            for (int i = this.namespaceCount - 1; i >= 0; i --) {
                BuilderInfo attribute = (BuilderInfo) this.attributeList[NewAttribute()];
                attribute.Initialize((BuilderInfo)this.namespaceList[i]);
            }
        }

        private void AnalyzeComment() {
            Debug.Assert(this.mainNode.NodeType == XmlNodeType.Comment);
            Debug.Assert((object) this.currentInfo == (object) this.mainNode);

            StringBuilder newComment = null;
            string        comment    = this.mainNode.Value;
            bool          minus      = false;
            int index = 0, begin = 0;

            for (; index < comment.Length; index ++) {
                switch (comment[index]) {
                    case s_Minus:
                        if (minus) {
                            if (newComment == null)
                                newComment = new StringBuilder(comment, begin, index, 2 * comment.Length);
                            else
                                newComment.Append(comment, begin, index - begin);

                            newComment.Append(s_SpaceMinus);
                            begin = index + 1;
                        }
                        minus = true;
                        break;
                    default:
                        minus = false;
                        break;
                }
            }

            if (newComment != null) {
                if (begin < comment.Length)
                    newComment.Append(comment, begin, comment.Length - begin);

                if (minus)
                    newComment.Append(s_Space);

                this.mainNode.Value = newComment.ToString();
            }
            else if (minus) {
                this.mainNode.ValueAppend(s_Space, false);
            }
        }

        private void AnalyzeProcessingInstruction() {
            Debug.Assert(this.mainNode.NodeType == XmlNodeType.ProcessingInstruction || this.mainNode.NodeType == XmlNodeType.XmlDeclaration);
            //Debug.Assert((object) this.currentInfo == (object) this.mainNode);

            StringBuilder newPI    = null;
            string        pi       = this.mainNode.Value;
            bool          question = false;
            int index = 0, begin = 0;

            for (; index < pi.Length; index ++) {
                switch (pi[index]) {
                case s_Question:
                    question = true;
                    break;
                case s_Greater:
                    if (question) {
                        if (newPI == null) {
                            newPI = new StringBuilder(pi, begin, index, 2 * pi.Length);
                        }
                        else {
                            newPI.Append(pi, begin, index - begin);
                        }
                        newPI.Append(s_SpaceGreater);
                        begin = index + 1;
                    }
                    question = false;
                    break;
                default:
                    question = false;
                    break;
                }
            }

            if (newPI != null) {
                if (begin < pi.Length) {
                    newPI.Append(pi, begin, pi.Length - begin);
                }
                this.mainNode.Value = newPI.ToString();
            }
        }

        private void FinalizeRecord() {
            switch (this.mainNode.NodeType) {
            case XmlNodeType.Element:
                // Save count since FixupElement can add attribute...
                int attributeCount = this.attributeCount;
                
                FixupElement();
                FixupAttributes(attributeCount);
                AnalyzeSpaceLang();
                AppendNamespaces();
                break;
            case XmlNodeType.Comment:
                AnalyzeComment();
                break;
            case XmlNodeType.ProcessingInstruction:
                AnalyzeProcessingInstruction();
                break;
            }
        }

        private int NewNamespace() {
            if (this.namespaceCount >= this.namespaceList.Count) {
                Debug.Assert(this.namespaceCount == this.namespaceList.Count);
                this.namespaceList.Add(new BuilderInfo());
            }
            return this.namespaceCount ++;
        }

        private void DeclareNamespace(string nspace, string prefix) {
            int index = NewNamespace();

            Debug.Assert(this.namespaceList[index] != null && this.namespaceList[index] is BuilderInfo);

            BuilderInfo ns = (BuilderInfo) this.namespaceList[index];
            if (prefix == this.atoms.Empty) {
                ns.Initialize(this.atoms.Empty, this.atoms.Xmlns, this.atoms.XmlnsNamespace);
            }
            else {
                ns.Initialize(this.atoms.Xmlns, prefix, this.atoms.XmlnsNamespace);
            }
            ns.Depth    = this.recordDepth;
            ns.NodeType = XmlNodeType.Attribute;
            ns.Value    = nspace;

            this.scopeManager.PushNamespace(prefix, nspace);
        }

        private string DeclareNewNamespace(string nspace) {
            string prefix = this.scopeManager.GeneratePrefix(PrefixFormat);
            DeclareNamespace(nspace, prefix);
            return prefix;
        }

        internal string GetPrefixForNamespace(string nspace) {
            string prefix = null;

            if (this.scopeManager.FindPrefix(nspace, out prefix)) {
                Debug.Assert(prefix != null && prefix.Length > 0);
                return prefix;
            }
            else {
                return DeclareNewNamespace(nspace);
            }
        }

        private static XmlSpace TranslateXmlSpace(string space) {
            if (Keywords.Compare(space, s_SpaceDefault)) {
                return XmlSpace.Default;
            }
            else if (Keywords.Compare(space, s_SpacePreserve)) {
                return XmlSpace.Preserve;
            }
            else {
                return XmlSpace.None;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\rootaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="RootAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.Globalization;
    using System.Xml;
    using System.Xml.XPath;
    using System.Security;

    internal class Key : ICloneable {
        XmlQualifiedName name;
        int              matchKey;
        int              useKey;
        ArrayList        keyNodes;

        public Key(XmlQualifiedName name, int matchkey, int usekey) {
            this.name     = name;
            this.matchKey = matchkey;
            this.useKey   = usekey;
            this.keyNodes = null;
        }

        public XmlQualifiedName Name { get { return this.name;     } }
        public int MatchKey          { get { return this.matchKey; } }
        public int UseKey            { get { return this.useKey;   } }

        public void AddKey(XPathNavigator root, Hashtable table) {
            if (this.keyNodes == null)
                this.keyNodes = new ArrayList();

            this.keyNodes.Add(new DocumentKeyList(root, table));
        }

        public Hashtable GetKeys(XPathNavigator root) {
            if (this.keyNodes != null) {
                for(int i=0; i < keyNodes.Count; i++) {
                    if (((DocumentKeyList)keyNodes[i]).RootNav.IsSamePosition(root)) {
                        return ((DocumentKeyList)keyNodes[i]).KeyTable;
                    }
                }
            }
            return null;
        }

        public object Clone() {
            return MemberwiseClone();
        }
    }

    internal struct DocumentKeyList {
        XPathNavigator rootNav;
        Hashtable   keyTable;

        public DocumentKeyList(XPathNavigator rootNav, Hashtable keyTable) {
            this.rootNav = rootNav;
            this.keyTable = keyTable;
        }

        public XPathNavigator RootNav {
            get {
                return this.rootNav;
            }
        }

        public Hashtable KeyTable {
            get {
                return this.keyTable;
            }
        }
    }
    
    internal class RootAction : TemplateBaseAction {
        private  const int    QueryInitialized = 2;
        private  const int    RootProcessed    = 3;
        
        private  Hashtable  attributeSetTable  = new Hashtable();
        private  Hashtable  decimalFormatTable = new Hashtable();
        private  ArrayList  keyList;
        private  XsltOutput output;
        public   Stylesheet builtInSheet;
        public   PermissionSet   permissions;

        internal XsltOutput Output {
            get { 
                if (this.output == null) {
                    this.output = new XsltOutput();
                }
                return this.output; 
            }
        }

        /*
         * Compile
         */
        internal override void Compile(Compiler compiler) {
            CompileDocument(compiler, /*inInclude*/ false);
        }

        internal void InsertKey(XmlQualifiedName name, int MatchKey, int UseKey){
            if (this.keyList == null) {
                this.keyList = new ArrayList();
            }
            this.keyList.Add(new Key(name, MatchKey, UseKey));
        }

        internal AttributeSetAction GetAttributeSet(XmlQualifiedName name) {
            AttributeSetAction action = (AttributeSetAction) this.attributeSetTable[name];
            if(action == null) {
                throw new XsltException(Res.Xslt_NoAttributeSet, name.ToString());
            }
            return action;
        }


        public void PorcessAttributeSets(Stylesheet rootStylesheet) {
            MirgeAttributeSets(rootStylesheet);

            // As we mentioned we need to invert all lists.
            foreach (AttributeSetAction attSet in this.attributeSetTable.Values) {
                if (attSet.containedActions != null) {
                    attSet.containedActions.Reverse();
                }
            }

            //  ensures there are no cycles in the attribute-sets use dfs marking method
            CheckAttributeSets_RecurceInList(new Hashtable(), this.attributeSetTable.Keys);
        }

        private void MirgeAttributeSets(Stylesheet stylesheet) {
            // mirge stylesheet.AttributeSetTable to this.AttributeSetTable

            if (stylesheet.AttributeSetTable != null) {
                foreach (AttributeSetAction srcAttSet in stylesheet.AttributeSetTable.Values) {
                    ArrayList srcAttList = srcAttSet.containedActions;
                    AttributeSetAction dstAttSet = (AttributeSetAction) this.attributeSetTable[srcAttSet.Name];
                    if (dstAttSet == null) {
                        dstAttSet = new AttributeSetAction(); {
                            dstAttSet.name             = srcAttSet.Name;
                            dstAttSet.containedActions = new ArrayList();
                        }
                        this.attributeSetTable[srcAttSet.Name] = dstAttSet;
                    }
                    ArrayList dstAttList = dstAttSet.containedActions;
                    // We adding attributes in reverse order for purpuse. In the mirged list most importent attset shoud go last one
                    // so we'll need to invert dstAttList finaly. 
                    if (srcAttList != null) {
                        for(int src = srcAttList.Count - 1; 0 <= src; src --) {
                            // We can ignore duplicate attibutes here.
                            dstAttList.Add(srcAttList[src]);
                        }
                    }
                }
            }

            foreach (Stylesheet importedStylesheet in stylesheet.Imports) {
                MirgeAttributeSets(importedStylesheet);
            }
        }

        private void CheckAttributeSets_RecurceInList(Hashtable markTable, ICollection setQNames) {
            const string PROCESSING = "P";
            const string DONE       = "D";

            foreach (XmlQualifiedName qname in setQNames) {
                object mark = markTable[qname];
                if(mark == (object) PROCESSING) {
                    throw new XsltException(Res.Xslt_CircularAttributeSet, qname.ToString());
                }
                else if(mark == (object) DONE) {
                    continue; // optimization: we already investigated this attribute-set.
                }
                else {
                    Debug.Assert(mark == null);

                    markTable[qname] = (object) PROCESSING;
                    CheckAttributeSets_RecurceInContainer(markTable, GetAttributeSet(qname));
                    markTable[qname] = (object) DONE;
                }
            }
        }

        private void CheckAttributeSets_RecurceInContainer(Hashtable markTable, ContainerAction container) {
            if (container.containedActions == null) {
                return;
            }
            foreach(Action action in container.containedActions) {
                if(action is UseAttributeSetsAction) {
                    CheckAttributeSets_RecurceInList(markTable, ((UseAttributeSetsAction)action).UsedSets);
                }
                else if(action is ContainerAction) {
                    CheckAttributeSets_RecurceInContainer(markTable, (ContainerAction)action);
                }
            }
        }
        
        internal void AddDecimalFormat(XmlQualifiedName name, DecimalFormat formatinfo) { 
            DecimalFormat exist = (DecimalFormat) this.decimalFormatTable[name];
            if (exist != null) {
                NumberFormatInfo info    = exist.info;
                NumberFormatInfo newinfo = formatinfo.info;
                if (info.NumberDecimalSeparator   != newinfo.NumberDecimalSeparator   ||
                    info.NumberGroupSeparator     != newinfo.NumberGroupSeparator     ||
                    info.PositiveInfinitySymbol   != newinfo.PositiveInfinitySymbol   ||
                    info.NegativeSign             != newinfo.NegativeSign             ||
                    info.NaNSymbol                != newinfo.NaNSymbol                ||
                    info.PercentSymbol            != newinfo.PercentSymbol            ||
                    info.PerMilleSymbol           != newinfo.PerMilleSymbol           ||
                    exist.zeroDigit               != formatinfo.zeroDigit             ||
                    exist.digit                   != formatinfo.digit                 ||
                    exist.patternSeparator        != formatinfo.patternSeparator 
                ) {
                    throw new XsltException(Res.Xslt_DupDecimalFormat, name.ToString());
                }
            }
            this.decimalFormatTable[name] = formatinfo;
        }

        internal DecimalFormat GetDecimalFormat(XmlQualifiedName name) {
            return this.decimalFormatTable[name] as DecimalFormat;
        }

        internal ArrayList KeyList{
            get { return this.keyList; }
        }

        internal void SortVariables(){
            if (this.containedActions == null) {
                return;
            }
            ArrayList InputList = new ArrayList();
            ArrayList OutputIndexList;
            bool flag = false;
            SortedList list;
            Hashtable hashtable = new Hashtable();
            Action action;
            int length = this.containedActions.Count;
            for (int i = 0; i < length; i++) {
                action = this.containedActions[i] as Action;
                if (action is VariableAction){                   
                    VariableAction var = action as VariableAction;
                    hashtable[var.NameStr] = i;
                }
            }
            for (int i = 0; i < length ; i++) {
                action = this.containedActions[i] as Action;
                if (action is VariableAction){                   
                    VariableAction var = action as VariableAction;
                    list = new SortedList();
                    if (var.Select != null) { 
                        AstNode node = AstNode.NewAstNode(var.Select);
                        ProcessNode(i, node, hashtable, ref list);
                    }
                    else {
                        if (var.containedActions != null ) {
                            foreach (Action containedaction in var.containedActions) {
                                if (containedaction.Select != null ) {
                                    AstNode node = AstNode.NewAstNode(containedaction.Select);
                                    ProcessNode(i, node, hashtable, ref list);
                                }
                            }
                        }
                    }
                    list.Add(i, i);
                    flag = list.Count > 1 || flag;
                    InputList.Add(list);
                
                }
                else {
                    list = new SortedList();
                    list.Add(i, i);
                    InputList.Add(list);
                }
            }
            if (flag) {
                ArrayList ActionList = new ArrayList();
                OutputIndexList = new ArrayList();
                for(int i = 0; i < InputList.Count; i++) {
                    RecursiveWalk(i, InputList, ref OutputIndexList);
                }
                for (int i = 0; i< OutputIndexList.Count; i++) {
                    ActionList.Add(this.containedActions[(int)OutputIndexList[i]]);
                }
                this.containedActions = ActionList;
            }
        }
        
        private void ProcessNode(int index, AstNode node, Hashtable hashtable, ref SortedList list) {
            if (node == null)
                return;
            switch (node.TypeOfAst) {
            case AstNode.QueryType.Axis:
                ProcessNode(index,((Axis)node).Input, hashtable, ref list);  
                break;
            case AstNode.QueryType.Operator:
                Operator op = node as Operator;
                ProcessNode(index, op.Operand1, hashtable, ref list);
                ProcessNode(index, op.Operand2, hashtable, ref list);
                break;
            case AstNode.QueryType.Filter:
                Filter filter = node as Filter;
                ProcessNode(index, filter.Input, hashtable, ref list);  
                ProcessNode(index, filter.Condition, hashtable, ref list);  
                break;
            case AstNode.QueryType.ConstantOperand:
                break;
            case AstNode.QueryType.Variable:
                String name = ((Variable)node).Name;
                if (hashtable.Contains(name)){
                    int i = (int)hashtable[name];
                    if (i == index)
                        throw new XsltException(Res.Xslt_CircularReference, name);
                    if (!list.ContainsKey(i))
                        list.Add(i, i);
                }
                break;
            case AstNode.QueryType.Function:
                int count = 0;
                Function function = node as Function;
                while (count < function.ArgumentList.Count) {
                    ProcessNode(index, (AstNode)function.ArgumentList[count++], hashtable, ref list);
                }
                break;
            case AstNode.QueryType.Group:
                ProcessNode(index, ((Group)node).GroupNode, hashtable, ref list);  
                break;
            case AstNode.QueryType.Root:
                break;
            }
        }
        
        private void RecursiveWalk(int index, ArrayList InputList,ref ArrayList OutputList){
            SortedList list = InputList[index] as SortedList;
            if (list.Count == 0) {
                return;
            }
            if (list.Count == 1) {
                OutputList.Add(index);
                list.Clear();
                return;
            }
            if (list.Contains(-1)) {
                VariableAction action = this.containedActions[index] as VariableAction;
                throw new XsltException(Res.Xslt_CircularReference, action.NameStr);
            }
            list.Add(-1, -1);

            for (int i = 0; i < list.Count; i++) {
                int actionindex = (int)list.GetByIndex(i) ;
                if (actionindex != -1 && actionindex != index) {
                    RecursiveWalk(actionindex, InputList, ref OutputList);
                }
            }
            OutputList.Add(index);
            list.Clear();
            return;
        }

       internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);

            switch (frame.State) {
            case Initialized:
                frame.AllocateVariables(variableCount);
                frame.InitNodeSet(processor.StartQuery(processor.Document, Compiler.RootQueryKey));
               
                if (this.containedActions != null && this.containedActions.Count > 0) {
                    processor.PushActionFrame(frame);
                }
                frame.State = QueryInitialized;
                break;
            case QueryInitialized:
                Debug.Assert(frame.State == QueryInitialized);
                frame.NextNode(processor);
                Debug.Assert(Processor.IsRoot(frame.Node));
                if (processor.Debugger != null) {
                    // this is like apply-templates, but we don't have it on stack. 
                    // Pop the stack, otherwise last instruction will be on it.
                    processor.PopDebuggerStack();
                }
                processor.PushTemplateLookup(frame.NodeSet, /*mode:*/null, /*importsOf:*/null);

                frame.State = RootProcessed;
                break;

            case RootProcessed:
                Debug.Assert(frame.State == RootProcessed);
                frame.Finished();
                break;
            default:
                Debug.Fail("Invalid RootAction execution state");
		        break;
            }
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal virtual void Trace() {
            Trace(0);
            Output.Trace(1);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\statemachine.cs ===
//------------------------------------------------------------------------------
// <copyright file="StateMachine.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class StateMachine {
        // Constants for the state table
        private  const int Init         = 0x000000;       // Initial state
        private  const int Elem         = 0x000001;       // Element was output
        private  const int AttrN        = 0x000002;       // Attribute name was output
        private  const int AttrV        = 0x000003;       // Attribute value was output (some more can follow)
        private  const int Attr         = 0x000004;       // Attribute was output
        private  const int InElm        = 0x000005;       // Filling in element, general state text
        private  const int EndEm        = 0x000006;       // After end element event - next end element doesn't generate token
        private  const int InCmt        = 0x000007;       // Adding text to a comment
        private  const int InPI         = 0x000008;       // Adding text to a processing instruction

        private  const int StateMask    = 0x00000F;       // State mask

        internal const int Error        = 0x000010;       // Invalid XML state

        private  const int Ignor        = 0x000020;       // Ignore this transition
        private  const int Assrt        = 0x000030;       // Assrt

        private  const int U            = 0x000100;       // Depth up
        private  const int D            = 0x000200;       // Depth down

        internal const int DepthMask    = 0x000300;       // Depth mask

        internal const int DepthUp      = U;
        internal const int DepthDown    = D;

        private  const int C            = 0x000400;       // BeginChild
        private  const int H            = 0x000800;       // HadChild
        private  const int M            = 0x001000;       // EmptyTag

        internal const int BeginChild   = C;
        internal const int HadChild     = H;
        internal const int EmptyTag     = M;

        private  const int B            = 0x002000;       // Begin Record
        private  const int E            = 0x004000;       // Record finished

        internal const int BeginRecord  = B;
        internal const int EndRecord    = E;

        private  const int S            = 0x008000;       // Push namespace scope
        private  const int P            = 0x010000;       // Pop current namepsace scope

        internal const int PushScope    = S;
        internal const int PopScope     = P;              // Next event must pop scope

        //
        // Runtime state
        //

        private int _State;

        internal StateMachine() {
            _State = Init;
        }

        internal int State {
            get {
                return _State;
            }

            set {
                // Hope you know what you are doing ...
                _State = value;
            }
        }

        internal void Reset() {
            _State = Init;
        }

        internal static int StateOnly(int state) {
            return state & StateMask;
        }

        internal int BeginOutlook(XPathNodeType nodeType) {
            int newState = s_BeginTransitions[(int)nodeType, _State];
            Debug.Assert(newState != Assrt);
            return newState;
        }

        internal int Begin(XPathNodeType nodeType) {
            int newState = s_BeginTransitions[(int)nodeType, _State];
            Debug.Assert(newState != Assrt);

            if (newState != Error && newState != Ignor) {
                _State = newState & StateMask;
            }
            return newState;
        }

        internal int EndOutlook(XPathNodeType nodeType) {
            int newState = s_EndTransitions[(int)nodeType, _State];
            Debug.Assert(newState != Assrt);
            return newState;
        }

        internal int End(XPathNodeType nodeType) {
            int newState = s_EndTransitions[(int)nodeType, _State];
            Debug.Assert(newState != Assrt);

            if (newState != Error && newState != Ignor) {
                _State = newState & StateMask;
            }
            return newState;
        }

        private static readonly int [,] s_BeginTransitions = {
            /*                             { Init,      Elem,          AttrN,   AttrV,   Attr,             InElm,            EndEm,            InCmt,   InPI  }, */
            /* Root                     */ { Error,     Error,         Error,   Error,   Error,            Error,            Error,            Error,   Error },
            /* Element                  */ { Elem |B|S, Elem |U|C|B|S, Error,   Error,   Elem |C|B|S,      Elem |B|S,        Elem |B|P|S,      Error,   Error },
            /* Attribute                */ { Error,     AttrN|U,       Error,   Error,   AttrN,            Error,            Error,            Error,   Error },
            /* Namespace                */ { Error,     AttrN|U,       Error,   Error,   AttrN,            Error,            Error,            Error,   Error },
            /* Text                     */ { InElm|B,   InElm|U|C|B,   AttrV|U, AttrV,   InElm|C|B,        InElm,            InElm|B|P,        InCmt,   InPI  },
            /* SignificantWhitespace    */ { InElm|B,   InElm|U|C|B,   AttrV|U, AttrV,   InElm|C|B,        InElm,            InElm|B|P,        InCmt,   InPI  },
            /* Whitespace               */ { InElm|B,   InElm|U|C|B,   AttrV|U, AttrV,   InElm|C|B,        InElm,            InElm|B|P,        InCmt,   InPI  },
            /* ProcessingInstruction    */ { InPI |B,   InPI |U|C|B,   Error,   Error,   InPI |C|B,        InPI |B,          InPI |B|P,        Error,   Error },
            /* Comment                  */ { InCmt|B,   InCmt|U|C|B,   Error,   Error,   InCmt|C|B,        InCmt|B,          InCmt|B|P,        Error,   Error },
            /* All                      */ { Error,     Error,         Error,   Error,   Error,            Error,            Error,            Error,   Error },
        };                                                             
                                                                       
        private static readonly int [,] s_EndTransitions = {           
            /*                             { Init,      Elem,          AttrN,   AttrV,   Attr,             InElm,            EndEm,            InCmt,   InPI   }, */
            /* Root                     */ { Assrt,     Assrt,         Assrt,   Assrt,   Assrt,            Assrt,            Assrt,            Assrt,   Assrt  },
            /* Element                  */ { Assrt,     EndEm|B|E|P|M, Assrt,   Assrt,   EndEm|D|B|E|P|M,  EndEm|D|H|B|E|P,  EndEm|D|H|B|E|P,  Assrt,   Assrt  },
            /* Attribute                */ { Assrt,     Assrt,         Attr,    Attr |D, Assrt,            Assrt,            Assrt,            Assrt,   Assrt  },
            /* Namespace                */ { Assrt,     Assrt,         Attr,    Attr |D, Assrt,            Assrt,            Assrt,            Assrt,   Assrt  },
            /* Text                     */ { Assrt,     Assrt,         Assrt,   Assrt,   Assrt,            Assrt,            Assrt,            Assrt,   Assrt  },
            /* SignificantWhitespace    */ { Assrt,     Assrt,         Assrt,   Assrt,   Assrt,            Assrt,            Assrt,            Assrt,   Assrt  },
            /* Whitespace               */ { Assrt,     Assrt,         Assrt,   Assrt,   Assrt,            Assrt,            Assrt,            Assrt,   Assrt  },
            /* ProcessingInstruction    */ { Assrt,     Assrt,         Assrt,   Assrt,   Assrt,            Assrt,            Assrt,            Assrt,   EndEm|E},
            /* Comment                  */ { Assrt,     Assrt,         Assrt,   Assrt,   Assrt,            Assrt,            Assrt,            EndEm|E, Assrt  },
            /* All                      */ { Assrt,     Assrt,         Assrt,   Assrt,   Assrt,            Assrt,            Assrt,            Assrt,   Assrt  },
	};
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\stylesheet.cs ===
//------------------------------------------------------------------------------
// <copyright file="Stylesheet.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;
    using System.Collections;

    internal class Stylesheet {
        private ArrayList       imports           = new ArrayList();
        private Hashtable       modeManagers;
        private Hashtable       templateNameTable = new Hashtable();
        private Hashtable       attributeSetTable;
        private int             templateCount;
        //private ArrayList     preserveSpace;
        private Hashtable       queryKeyTable;
        private ArrayList       whitespaceList;
        private bool            whitespace;
        private Hashtable       scriptObjectTypes = new Hashtable();
        private TemplateManager templates;

        
        private class WhitespaceElement {
            private int    key;
            private double priority;
            private bool   preserveSpace;

            internal double Priority {
                get { return this.priority; }
            }

            internal int Key {
                get { return this.key; }
            }
            
            internal bool PreserveSpace {
                get { return this.preserveSpace; }
            }
            
            internal WhitespaceElement(int Key, double priority, bool PreserveSpace) {
                this.key = Key;
                this.priority = priority;
                this.preserveSpace = PreserveSpace;
            }

            internal void ReplaceValue(bool PreserveSpace) {
                this.preserveSpace = PreserveSpace;
            }
        }

        internal bool      Whitespace        { get { return this.whitespace       ; } }
        internal ArrayList Imports           { get { return this.imports          ; } }
        internal Hashtable AttributeSetTable { get { return this.attributeSetTable; } }
                    
        internal void AddSpace(Compiler compiler, String query, double Priority, bool PreserveSpace) {
            WhitespaceElement elem;
            if (this.queryKeyTable != null) {
                if (this.queryKeyTable.Contains(query)) {
                    elem = (WhitespaceElement) this.queryKeyTable[query];
                    elem.ReplaceValue(PreserveSpace);
                    return;
                }
            }
            else{
                this.queryKeyTable = new Hashtable();
                this.whitespaceList = new ArrayList();
            }
            int key = compiler.AddQuery(query);
            elem = new WhitespaceElement(key, Priority, PreserveSpace);
            this.queryKeyTable[query] = elem;
            this.whitespaceList.Add(elem);
        }

        internal void SortWhiteSpace(){
            if (this.queryKeyTable != null){
                for (int i= 0; i < this.whitespaceList.Count  ; i++ ) {
                    for(int j = this.whitespaceList.Count - 1; j > i; j--) {
                        WhitespaceElement elem1, elem2;
                        elem1 = (WhitespaceElement) this.whitespaceList[j - 1];
                        elem2 = (WhitespaceElement) this.whitespaceList[j];
                        if (elem2.Priority < elem1.Priority) {
                            this.whitespaceList[j - 1] = elem2;
                            this.whitespaceList[j] = elem1;
                        }
                    }
                }
                this.whitespace = true;
            }
            if (this.imports != null) {
                for (int importIndex = this.imports.Count - 1; importIndex >= 0; importIndex --) {
                    Stylesheet stylesheet = (Stylesheet) this.imports[importIndex];
                    if (stylesheet.Whitespace) {
                        stylesheet.SortWhiteSpace();
                        this.whitespace = true;
                    }
                }
            }
        }

        internal bool PreserveWhiteSpace(Processor proc, XPathNavigator node){
            // last one should win. I.E. We starting from the end. I.E. Lowest priority should go first
            if (this.whitespaceList != null) {
                for (int i = this.whitespaceList.Count - 1; 0 <= i; i --) {
                    WhitespaceElement elem = (WhitespaceElement) this.whitespaceList[i];
                    if (proc.Matches(node, elem.Key)) {
                        return elem.PreserveSpace;
                    }
                }
            }
            if (this.imports != null) {
                for (int importIndex = this.imports.Count - 1; importIndex >= 0; importIndex --) {
                    Stylesheet stylesheet = (Stylesheet) this.imports[importIndex];
                    if (! stylesheet.PreserveWhiteSpace(proc, node))
                        return false;
                }
            }
            return true;
        }

        internal void AddAttributeSet(AttributeSetAction attributeSet) {
            Debug.Assert(attributeSet.Name != null);
            if (this.attributeSetTable == null) {
                this.attributeSetTable = new Hashtable();
            }
            Debug.Assert(this.attributeSetTable != null);

            if (this.attributeSetTable.ContainsKey(attributeSet.Name) == false) {
                this.attributeSetTable[attributeSet.Name] = attributeSet;
            }
            else {
                // merge the attribute-sets
                ((AttributeSetAction)this.attributeSetTable[attributeSet.Name]).Merge(attributeSet);
            }
        }

        internal void AddTemplate(TemplateAction template) {
            XmlQualifiedName mode = template.Mode;

            //
            // Ensure template has a unique name
            //

            Debug.Assert(this.templateNameTable != null);

            if (template.Name != null) {
                if (this.templateNameTable.ContainsKey(template.Name) == false) {
                    this.templateNameTable[template.Name] = template;
                }
                else {
                    throw new XsltException(Res.Xslt_DupTemplateName, template.Name.ToString());
                }
            }


            if (template.Match != null) {
                if (this.modeManagers == null) {
                    this.modeManagers = new Hashtable();
                }
                Debug.Assert(this.modeManagers != null);

                if (mode == null) {
                    mode = XmlQualifiedName.Empty;
                }

                TemplateManager manager = (TemplateManager) this.modeManagers[mode];

                if (manager == null) {
                    manager = new TemplateManager(this, mode);

                    this.modeManagers[mode] = manager;

                    if (mode.IsEmpty) {
                        Debug.Assert(this.templates == null);
                        this.templates = manager;
                    }
                }
                Debug.Assert(manager != null);

                template.TemplateId = ++ this.templateCount;
                manager.AddTemplate(template);
            }
        }

        internal void ProcessTemplates() {
            if (this.modeManagers != null) {
                IDictionaryEnumerator enumerator = this.modeManagers.GetEnumerator();
                while (enumerator.MoveNext()) {
                    Debug.Assert(enumerator.Value is TemplateManager);
                    TemplateManager manager = (TemplateManager) enumerator.Value;
                    manager.ProcessTemplates();
                }
            }

            if (this.imports != null) {
                for (int importIndex = this.imports.Count - 1; importIndex >= 0; importIndex --) {
                    Debug.Assert(this.imports[importIndex] is Stylesheet);
                    Stylesheet stylesheet = (Stylesheet) this.imports[importIndex];
                    Debug.Assert(stylesheet != null);

                    //
                    // Process templates in imported stylesheet
                    //

                    stylesheet.ProcessTemplates();
                }
            }
        }


        internal void ReplaceNamespaceAlias(Compiler compiler){
            if (this.modeManagers != null) {
                IDictionaryEnumerator enumerator = this.modeManagers.GetEnumerator();
                while (enumerator.MoveNext()) {
                    TemplateManager manager = (TemplateManager) enumerator.Value;
                    if (manager.templates != null) {
                        for(int i=0 ; i< manager.templates.Count; i++) {
                            TemplateAction template = (TemplateAction) manager.templates[i];
                            template.ReplaceNamespaceAlias(compiler);
                        }
                    }
                }
            }
            if (this.templateNameTable != null) {
                IDictionaryEnumerator enumerator = this.templateNameTable.GetEnumerator();
                while (enumerator.MoveNext()) {
                    TemplateAction template = (TemplateAction) enumerator.Value;
                    template.ReplaceNamespaceAlias(compiler);
                }
            }
            if (this.imports != null) {
                for (int importIndex = this.imports.Count - 1; importIndex >= 0; importIndex --) {
                    Stylesheet stylesheet = (Stylesheet) this.imports[importIndex];
                    stylesheet.ReplaceNamespaceAlias(compiler);
                }
            }
        }

        internal TemplateAction FindTemplate(Processor processor, XPathNavigator navigator, XmlQualifiedName mode) {
            Debug.Assert(processor != null && navigator != null);
            Debug.Assert(mode != null);
            TemplateAction  action  = null;

            //
            // Try to find template within this stylesheet first
            //
            if (this.modeManagers != null) {
                TemplateManager manager = (TemplateManager) this.modeManagers[mode];

                if (manager != null) {
                    Debug.Assert(manager.Mode.Equals(mode));
                    action = manager.FindTemplate(processor, navigator);
                }
            }

            //
            // If unsuccessful, search in imported documents from backwards
            //

            if (action == null) {
                action = FindTemplateImports(processor, navigator, mode);
            }

            return action;
        }

        internal TemplateAction FindTemplateImports(Processor processor, XPathNavigator navigator, XmlQualifiedName mode) {
            TemplateAction action = null;

            //
            // Do we have imported stylesheets?
            //

            if (this.imports != null) {
                for (int importIndex = this.imports.Count - 1; importIndex >= 0; importIndex --) {
                    Debug.Assert(this.imports[importIndex] is Stylesheet);
                    Stylesheet stylesheet = (Stylesheet) this.imports[importIndex];
                    Debug.Assert(stylesheet != null);

                    //
                    // Search in imported stylesheet
                    //

                    action = stylesheet.FindTemplate(processor, navigator, mode);

                    if (action != null) {
                        return action;
                    }
                }
            }

            return action;
        }

        internal TemplateAction FindTemplate(Processor processor, XPathNavigator navigator) {
            Debug.Assert(processor != null && navigator != null);
            Debug.Assert(this.templates == null && this.modeManagers == null || this.templates == this.modeManagers[XmlQualifiedName.Empty]);

            TemplateAction action = null;

            //
            // Try to find template within this stylesheet first
            //

            if (this.templates != null) {
                action = this.templates.FindTemplate(processor, navigator);
            }

            //
            // If unsuccessful, search in imported documents from backwards
            //

            if (action == null) {
                action = FindTemplateImports(processor, navigator);
            }

            return action;
        }

        internal TemplateAction FindTemplate(XmlQualifiedName name) {
            //Debug.Assert(this.templateNameTable == null);

            TemplateAction action = null;

            //
            // Try to find template within this stylesheet first
            //

            if (this.templateNameTable != null) {
                action = (TemplateAction)this.templateNameTable[name];
            }

            //
            // If unsuccessful, search in imported documents from backwards
            //

            if (action == null && this.imports != null) {
                for (int importIndex = this.imports.Count - 1; importIndex >= 0; importIndex --) {
                    Debug.Assert(this.imports[importIndex] is Stylesheet);
                    Stylesheet stylesheet = (Stylesheet) this.imports[importIndex];
                    Debug.Assert(stylesheet != null);

                    //
                    // Search in imported stylesheet
                    //

                    action = stylesheet.FindTemplate(name);

                    if (action != null) {
                        return action;
                    }
                }
            }

            return action;
        }

        internal TemplateAction FindTemplateImports(Processor processor, XPathNavigator navigator) {
            TemplateAction action = null;

            //
            // Do we have imported stylesheets?
            //

            if (this.imports != null) {
                for (int importIndex = this.imports.Count - 1; importIndex >= 0; importIndex --) {
                    Debug.Assert(this.imports[importIndex] is Stylesheet);
                    Stylesheet stylesheet = (Stylesheet) this.imports[importIndex];
                    Debug.Assert(stylesheet != null);

                    //
                    // Search in imported stylesheet
                    //

                    action = stylesheet.FindTemplate(processor, navigator);

                    if (action != null) {
                        return action;
                    }
                }
            }

            return action;
        }

        internal Hashtable ScriptObjectTypes {
            get { return this.scriptObjectTypes; }
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal void Trace(int tab) {
            Debug.Indent(tab);
            Debug.WriteLine("Stylesheet");
            Debug.Indent(tab + 1);
            Debug.WriteLine("mode managers :");

            if (this.modeManagers != null) {
                IDictionaryEnumerator enumerator = this.modeManagers.GetEnumerator();
                while (enumerator.MoveNext()) {
                    TemplateManager manager = (TemplateManager) enumerator.Value;
                    manager.Trace(tab + 2);
                }
            }

            Debug.Indent(tab + 1);
            Debug.WriteLine("Imports:");

            if (this.imports != null) {
                for (int import = 0; import < this.imports.Count; import ++) {
                    Stylesheet imported = (Stylesheet) this.imports[import];
                    imported.Trace(tab + 2);
                }
            }
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal void Trace() {
            Trace(0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\processor.cs ===
//------------------------------------------------------------------------------
// <copyright file="Processor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.IO;
    using System.Xml;
    using System.Xml.XPath;
    using System.Text;
    using System.Collections;
    using System.Xml.Xsl.Debugger;
    using System.Reflection;
    using System.Security;

    internal sealed class Processor : IXsltProcessor {
        //
        // Static constants
        //

        const int StackIncrement = 10;

        //
        // Execution result
        //

        internal enum ExecResult {
            Continue,           // Continues next iteration immediately
            Interrupt,          // Returns to caller, was processed enough
            Done                // Execution finished
        }

        internal enum OutputResult {
            Continue,
            Interrupt,
            Overflow,
            Error,
            Ignore
        }

        private ExecResult     execResult;

        //
        // Compiled stylesheet
        //

        private Stylesheet      stylesheet;     // Root of import tree of template managers
        private RootAction      rootAction;
        private ArrayList       keyList;
        private ArrayList       queryStore;
        public  PermissionSet   permissions;   // used by XsltCompiledContext in document and extension functions

        //
        // Document Being transformed
        //

        private XPathNavigator    document;

        //
        // Execution action stack
        //

        private HWStack         actionStack;
        private HWStack         debuggerStack;

        //
        // Register for returning value from calling nested action
        //

        private StringBuilder   sharedStringBuilder;

        //
        // Output related member variables
        //
        int                     ignoreLevel;
        StateMachine            xsm;
        RecordBuilder           builder;

        XsltOutput              output;

        XmlNameTable            nameTable      = new NameTable();
        
        XmlResolver             resolver;
        
        XsltArgumentList        args;
        Hashtable               scriptExtensions;

        ArrayList               numberList;
        //
        // Template lookup action
        //

        TemplateLookupAction    templateLookup = new TemplateLookupAction();

        bool                    isReaderOutput;
        private IXsltDebugger   debugger;
        XPathExpression[]  queryList;

        private ArrayList sortArray;

        private Hashtable documentCache;


        internal XPathNavigator Current {
            get {
                ActionFrame frame = (ActionFrame) this.actionStack.Peek();
                return frame != null ? frame.Node : null;
            }
        }
        
        internal ExecResult ExecutionResult {
            get { return this.execResult; }

            set {
                Debug.Assert(this.execResult == ExecResult.Continue);
                this.execResult = value;
            }
        }

        internal Stylesheet Stylesheet {
            get { return this.stylesheet; }
        }

        internal XmlResolver Resolver {
            get { 
                Debug.Assert(this.resolver != null, "Constructor should create it if null passed");
                return this.resolver; 
            }
        }

        internal ArrayList SortArray {
            get { 
                Debug.Assert(this.sortArray != null, "InitSortArray() wasn't called");
                return this.sortArray; 
            }
        }

        internal ArrayList KeyList{
            get { return this.keyList; }
        }

        internal XPathNavigator GetNavigator(Uri ruri) {
            XPathNavigator result = null;
            if (documentCache != null) {
                result = documentCache[ruri] as XPathNavigator;
                if (result != null) {
                    return result.Clone();
                }
            }
            else {
                documentCache = new Hashtable();
            }

            Object input = resolver.GetEntity(ruri, null, null);
            if (input is Stream) {
                XmlTextReader tr  = new XmlTextReader(ruri.ToString(), (Stream) input); {
                    tr.XmlResolver = this.resolver;
                }
                // reader is closed by Compiler.LoadDocument()
                result = ((IXPathNavigable)Compiler.LoadDocument(tr)).CreateNavigator();
            }
            else if (input is XPathNavigator){
                result = (XPathNavigator) input;
            }
            else {
                throw new XsltException(Res.Xslt_CantResolve, ruri.ToString());
            }
            documentCache[ruri] = result.Clone();
            return result;
        }        

        internal void AddSort(Sort sortinfo) {
            Debug.Assert(this.sortArray != null, "InitSortArray() wasn't called");
            this.sortArray.Add(sortinfo);
        }

        internal void InitSortArray() {
            if (this.sortArray == null) {
                this.sortArray = new ArrayList();
            }
            else {
                this.sortArray.Clear();
            }
        }
        
        internal object GetGlobalParameter(XmlQualifiedName qname) {
            return args.GetParam(qname);
        }

        internal object GetExtensionObject(string nsUri) {
            return args.GetExtensionObject(nsUri);
        }

        internal object GetScriptObject(string nsUri) {
            return scriptExtensions[nsUri];
        }

        internal bool ReaderOutput {
            get { return this.isReaderOutput; }
        }
        
        internal RootAction RootAction {
            get { return this.rootAction; }
        }

        internal XPathNavigator Document {
            get { return this.document; }
        }

#if DEBUG
        private bool stringBuilderLocked = false;
#endif

        internal StringBuilder GetSharedStringBuilder() {
#if DEBUG
            Debug.Assert(! stringBuilderLocked);
#endif
            if (sharedStringBuilder == null) {
                sharedStringBuilder = new StringBuilder();
            }
            else {
                sharedStringBuilder.Length = 0;
            }
#if DEBUG
            stringBuilderLocked = true;
#endif
            return sharedStringBuilder;
        }

        internal void ReleaseSharedStringBuilder() {
            // don't clean stringBuilderLocked here. ToString() will happen after this call 
#if DEBUG
            stringBuilderLocked = false;
#endif
        }

        internal ArrayList NumberList {
            get {
                if (this.numberList == null) {
                    this.numberList = new ArrayList();
                }
                return this.numberList;
            }
        }

        internal IXsltDebugger Debugger {
            get { return this.debugger; }
        }

        internal HWStack ActionStack {
            get { return this.actionStack; }
        }

        internal RecordBuilder Builder {
            get { return this.builder; }
        }

        internal XsltOutput Output {
            get { return this.output; }
        }

        internal ReaderOutput Reader {
            get {
                Debug.Assert(Builder != null);
                RecordOutput output = Builder.Output;
                Debug.Assert(output is ReaderOutput);
                return (ReaderOutput) output;
            }
        }

        //
        // Construction
        //

        private Processor(XPathNavigator doc, XsltArgumentList args, XmlResolver resolver, XslTransform transform) {
            transform.LoadCompiledStylesheet(out this.stylesheet, out this.queryList, out this.queryStore, out this.rootAction, doc);

            this.xsm                 = new StateMachine();
            this.document            = doc;
            this.builder             = null;
            this.actionStack         = new HWStack(StackIncrement);
            this.output              = this.rootAction.Output;
            this.permissions         = this.rootAction.permissions;
            this.resolver            = resolver != null ? resolver : new XmlNullResolver();
            this.args                = args     != null ? args     : new XsltArgumentList();
            this.debugger            = transform.Debugger;
            if (this.debugger != null) {
                this.debuggerStack = new HWStack(StackIncrement, /*limit:*/1000);
                templateLookup     = new TemplateLookupActionDbg();
            }

            // Clone the compile-time KeyList
            if (this.rootAction.KeyList != null) {
                this.keyList = new ArrayList();
                foreach (Key key in this.rootAction.KeyList) {
                    this.keyList.Add(key.Clone());
                }
            }
            
            this.scriptExtensions = new Hashtable(this.stylesheet.ScriptObjectTypes.Count); {
                foreach(DictionaryEntry entry in this.stylesheet.ScriptObjectTypes) {
                    string namespaceUri = (string)entry.Key;
                    if (GetExtensionObject(namespaceUri) != null) {
	                    throw new XsltException(Res.Xslt_ScriptDub, namespaceUri);
                    }
                    scriptExtensions.Add(namespaceUri, Activator.CreateInstance((Type)entry.Value,
                        BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null, null));
                }
            }
            
            this.PushActionFrame(this.rootAction, /*nodeSet:*/null);
        }

        internal Processor(XslTransform transform, XPathNavigator doc, XsltArgumentList args, XmlResolver resolver)
            : this(doc, args, resolver, transform)
        {
            InitializeOutput();
            this.isReaderOutput = true;
        }

        internal Processor(XslTransform transform, XPathNavigator doc, XsltArgumentList args, XmlResolver resolver, Stream stream)
            : this(doc, args, resolver, transform)
        {
            InitializeOutput(stream);
        }

        internal Processor(XslTransform transform, XPathNavigator doc, XsltArgumentList args, XmlResolver resolver, TextWriter writer)
            : this(doc, args, resolver, transform)
        {
            InitializeOutput(writer);
        }

        internal Processor(XslTransform transform, XPathNavigator doc, XsltArgumentList args, XmlResolver resolver, XmlWriter xmlWriter)
            : this(doc, args, resolver, transform)
        {
            InitializeOutput(xmlWriter);
        }

        //
        // Output Initialization
        //

        private void InitializeOutput() {
            this.builder = new RecordBuilder(new ReaderOutput(this), this.nameTable);
        }

        private void InitializeOutput(Stream stream) {
            RecordOutput recOutput = null;

            switch (this.output.Method) {
            case XsltOutput.OutputMethod.Text:
                recOutput = new TextOnlyOutput(this, stream);
                break;
            case XsltOutput.OutputMethod.Xml:
            case XsltOutput.OutputMethod.Html:
            case XsltOutput.OutputMethod.Other:
            case XsltOutput.OutputMethod.Unknown:
                recOutput = new TextOutput(this, stream);
                break;
            }
            this.builder = new RecordBuilder(recOutput, this.nameTable);
        }

        private void InitializeOutput(TextWriter writer) {
            RecordOutput recOutput = null;

            switch (this.output.Method) {
            case XsltOutput.OutputMethod.Text:
                recOutput = new TextOnlyOutput(this, writer);
                break;
            case XsltOutput.OutputMethod.Xml:
            case XsltOutput.OutputMethod.Html:
            case XsltOutput.OutputMethod.Other:
            case XsltOutput.OutputMethod.Unknown:
                recOutput = new TextOutput(this, writer);
                break;
            }
            this.builder = new RecordBuilder(recOutput, this.nameTable);
        }

        private void InitializeOutput(XmlWriter writer) {
            this.builder = new RecordBuilder(new WriterOutput(this, writer), this.nameTable);
        }

        //
        //  Execution part of processor
        //
        internal void Execute() {
            Debug.Assert(this.actionStack != null);

            while (this.execResult == ExecResult.Continue) {
                ActionFrame frame = (ActionFrame) this.actionStack.Peek();

                if (frame == null) {
                    Debug.Assert(this.builder != null);
                    this.builder.TheEnd();
                    ExecutionResult = ExecResult.Done;
                    break;
                }

                // Execute the action which was on the top of the stack
                if (frame.Execute(this)) {
                    Debug.WriteLine("Popping action frame");
                    this.actionStack.Pop();
                }
            }

            if (this.execResult == ExecResult.Interrupt) {
                this.execResult = ExecResult.Continue;
            }
        }

        //
        // Action frame support
        //

        internal ActionFrame PushNewFrame() {
            ActionFrame prent = (ActionFrame) this.actionStack.Peek();
            ActionFrame frame = (ActionFrame) this.actionStack.Push();
            if (frame == null) {
                frame = new ActionFrame();
                this.actionStack.AddToTop(frame);
            }
            Debug.Assert(frame != null);

            if (prent != null) {
                frame.Inherit(prent);
            }

            return frame;
        }

        internal void PushActionFrame(Action action, XPathNodeIterator nodeSet) {
            ActionFrame frame = PushNewFrame();
            frame.Init(action, nodeSet);
        }

        internal void PushActionFrame(ActionFrame container) {
            this.PushActionFrame(container, container.NodeSet);
        }

        internal void PushActionFrame(ActionFrame container, XPathNodeIterator nodeSet) {
            ActionFrame frame = PushNewFrame();
            frame.Init(container, nodeSet);
        }

        internal void PushTemplateLookup(XPathNodeIterator nodeSet, XmlQualifiedName mode, Stylesheet importsOf) {
            Debug.Assert(this.templateLookup != null);
            this.templateLookup.Initialize(mode, importsOf);
            PushActionFrame(this.templateLookup, nodeSet);
        }

        internal XPathExpression GetCompiledQuery(int key) {
            Debug.Assert(key != Compiler.InvalidQueryKey);
            Debug.Assert(this.queryStore[key] is TheQuery);
            TheQuery theQuery = (TheQuery)this.queryStore[key];
            XPathExpression expr =  this.queryList[key].Clone();
            XsltCompileContext context = new XsltCompileContext(theQuery._ScopeManager, this);
            expr.SetContext(context);
            return expr;
        }

        internal XPathExpression GetValueQuery(int key) {
            Debug.Assert(key != Compiler.InvalidQueryKey);
            Debug.Assert(this.queryStore[key] is TheQuery);
            TheQuery theQuery = (TheQuery)this.queryStore[key];
            XPathExpression expr =  this.queryList[key];
            XsltCompileContext context = new XsltCompileContext(theQuery._ScopeManager, this);
            expr.SetContext(context);
            return expr;
        }
        
        private InputScopeManager GetManager(int key) {
            return ((TheQuery)this.queryStore[key])._ScopeManager;
        }

        internal String ValueOf(ActionFrame context, int key) {
            XPathExpression expr = this.GetValueQuery(key);
            object result        = context.Node.Evaluate(expr, context.NodeSet);

            XPathNodeIterator nodeSet = result as XPathNodeIterator;
            if (nodeSet != null) {
                if (nodeSet.MoveNext()) {
                    if (this.stylesheet.Whitespace && nodeSet.Current.NodeType == XPathNodeType.Element) {
                        return ElementValueWithoutWS(nodeSet.Current);
                    }
                    return nodeSet.Current.Value;
                }
                else {
                    return String.Empty;
                }
            }

            return XmlConvert.ToXPathString(result);
        }

        private String ElementValueWithoutWS(XPathNavigator nav) {
            StringBuilder builder = this.GetSharedStringBuilder();
            // SDUB: Will be faster not use XPath here but run recursion here. 
            // We can avoid multiple calls to PreserveWhiteSpace() for the same parent node.
            XPathNodeIterator selection = this.StartQuery(nav, Compiler.DescendantTextKey);
            XPathNavigator parent = selection.Current.Clone();
            while (selection.MoveNext()) {
                if (selection.Current.NodeType == XPathNodeType.Whitespace) {
                    parent.MoveTo(selection.Current);
                    parent.MoveToParent();
                    if (! this.Stylesheet.PreserveWhiteSpace(this, parent)) {
                        continue;
                    }
                }
                builder.Append(selection.Current.Value);
            }
            this.ReleaseSharedStringBuilder();
            return builder.ToString();
        }
            
        internal XPathNodeIterator StartQuery(XPathNavigator context, int key) { 
            XPathNodeIterator it = context.Select(GetCompiledQuery(key));
            return it;
        }

      
        internal XPathNodeIterator StartQuery(XPathNavigator context, int key, ArrayList sortarray) {
            XPathExpression expr, expr1;
            expr = GetCompiledQuery(key);

            for (int i = 0; i< sortarray.Count; i++){
                Sort sort = (Sort) sortarray[i];
                expr1 = GetCompiledQuery(sort.select);
                expr.AddSort(expr1, sort.order, sort.caseOrder, sort.lang, sort.dataType);
            }

            XPathNodeIterator it = context.Select(expr);

            return it;
        }
        
        internal object Evaluate(ActionFrame context, int key) {
            object    value = null;
            XPathExpression expr;

            expr = GetValueQuery(key);
            value = context.Node.Evaluate(expr, context.NodeSet);

            return value;
        }

        internal object RunQuery(ActionFrame context, int key) {
            object    value = null;
            XPathExpression expr;

            expr = GetCompiledQuery(key);
            if (expr.ReturnType == XPathResultType.NodeSet){
                return new XPathArrayIterator(context.Node.Select(expr));
            }
            
            value = context.Node.Evaluate(expr, context.NodeSet);

            return value;
        }
        
        internal string EvaluateString(ActionFrame context, int key) {
            object objValue = Evaluate(context, key);
            string value = null;
            if (objValue != null)
                value = XmlConvert.ToXPathString(objValue);
            if (value == null)
                value = String.Empty;
            return value;
        }

        internal bool EvaluateBoolean(ActionFrame context, int key) {
            object objValue = Evaluate(context, key);

            if (objValue != null) {
                XPathNavigator nav = objValue as XPathNavigator;
                return nav != null ? Convert.ToBoolean(nav.Value) : Convert.ToBoolean(objValue);
            }
            else {
                return false;
            }
        }

        internal bool Matches(XPathNavigator context, int key) {
            return context.Matches(GetValueQuery(key));
        }

        //
        // Outputting part of processor
        //

        internal XmlNameTable NameTable {
            get { return this.nameTable; }
        }

        internal bool CanContinue {
            get { return this.execResult == ExecResult.Continue; }
        }

        internal bool ExecutionDone {
            get { return this.execResult == ExecResult.Done; }
        }

        internal void ResetOutput() {
            Debug.Assert(this.builder != null);
            this.builder.Reset();
        }
        internal bool BeginEvent(XPathNodeType nodeType, string prefix, string name, string nspace, bool empty) {
            return BeginEvent(nodeType, prefix, name,  nspace,  empty, null, true);
        }

        internal bool BeginEvent(XPathNodeType nodeType, string prefix, string name, string nspace, bool empty, Object htmlProps, bool search) {
            Debug.Assert(this.xsm != null);

            int stateOutlook = this.xsm.BeginOutlook(nodeType);

            if (this.ignoreLevel > 0 || stateOutlook == StateMachine.Error) {
                this.ignoreLevel ++;
                return true;                        // We consumed the event, so pretend it was output.
            }

            switch (this.builder.BeginEvent(stateOutlook, nodeType, prefix, name, nspace, empty, htmlProps, search)) {
            case OutputResult.Continue:
                this.xsm.Begin(nodeType);
                Debug.Assert(StateMachine.StateOnly(stateOutlook) == this.xsm.State);
                Debug.Assert(ExecutionResult == ExecResult.Continue);
                return true;
            case OutputResult.Interrupt:
                this.xsm.Begin(nodeType);
                Debug.Assert(StateMachine.StateOnly(stateOutlook) == this.xsm.State);
                ExecutionResult = ExecResult.Interrupt;
                return true;
            case OutputResult.Overflow:
                ExecutionResult = ExecResult.Interrupt;
                return false;
            case OutputResult.Error:
                this.ignoreLevel ++;
                return true;
            case OutputResult.Ignore:
                return true;
            default:
                Debug.Fail("Unexpected result of RecordBuilder.BeginEvent()");
                return true;
            }
        }

        internal bool TextEvent(string text) {
            return this.TextEvent(text, false);
        }

        internal bool TextEvent(string text, bool disableOutputEscaping) {
            Debug.Assert(this.xsm != null);

            if (this.ignoreLevel > 0) {
                return true;
            }

            int stateOutlook = this.xsm.BeginOutlook(XPathNodeType.Text);

            switch (this.builder.TextEvent(stateOutlook, text, disableOutputEscaping)) {
                case OutputResult.Continue:
                this.xsm.Begin(XPathNodeType.Text);
                Debug.Assert(StateMachine.StateOnly(stateOutlook) == this.xsm.State);
                Debug.Assert(ExecutionResult == ExecResult.Continue);
                return true;
            case OutputResult.Interrupt:
                this.xsm.Begin(XPathNodeType.Text);
                Debug.Assert(StateMachine.StateOnly(stateOutlook) == this.xsm.State);
                ExecutionResult = ExecResult.Interrupt;
                return true;
            case OutputResult.Overflow:
                ExecutionResult = ExecResult.Interrupt;
                return false;
            case OutputResult.Error:
            case OutputResult.Ignore:
                return true;
            default:
                Debug.Fail("Unexpected result of RecordBuilder.TextEvent()");
                return true;
            }
        }

        internal bool EndEvent(XPathNodeType nodeType) {
            Debug.Assert(this.xsm != null);

            if (this.ignoreLevel > 0) {
                this.ignoreLevel --;
                return true;
            }

            int stateOutlook = this.xsm.EndOutlook(nodeType);

            switch (this.builder.EndEvent(stateOutlook, nodeType)) {
                case OutputResult.Continue:
                this.xsm.End(nodeType);
                Debug.Assert(StateMachine.StateOnly(stateOutlook) == this.xsm.State);
                return true;
            case OutputResult.Interrupt:
                this.xsm.End(nodeType);
                Debug.Assert(StateMachine.StateOnly(stateOutlook) == this.xsm.State,
                             "StateMachine.StateOnly(stateOutlook) == this.xsm.State");
                ExecutionResult = ExecResult.Interrupt;
                return true;
            case OutputResult.Overflow:
                ExecutionResult = ExecResult.Interrupt;
                return false;
            case OutputResult.Error:
            case OutputResult.Ignore:
            default:
                Debug.Fail("Unexpected result of RecordBuilder.TextEvent()");
                return true;
            }
        }

        internal bool CopyBeginEvent(XPathNavigator node, bool emptyflag) {
            switch (node.NodeType) {
            case XPathNodeType.Element:
            case XPathNodeType.Attribute:
            case XPathNodeType.ProcessingInstruction:
            case XPathNodeType.Comment:
                return BeginEvent(node.NodeType, node.Prefix, node.LocalName, node.NamespaceURI, emptyflag);
            case XPathNodeType.Namespace:
                // value instead of namespace here!
                return BeginEvent(XPathNodeType.Namespace, null, node.LocalName, node.Value, false);
            case XPathNodeType.Text:
                // Text will be copied in CopyContents();
                break;

            case XPathNodeType.Root:
            case XPathNodeType.Whitespace:
            case XPathNodeType.SignificantWhitespace:
            case XPathNodeType.All:
                break;

            default:
                Debug.Fail("Invalid XPathNodeType in CopyBeginEvent");
                break;
            }

            return true;
        }

        internal bool CopyTextEvent(XPathNavigator node) {
            switch (node.NodeType) {
            case XPathNodeType.Element:
            case XPathNodeType.Namespace:
                break;

            case XPathNodeType.Attribute:
            case XPathNodeType.ProcessingInstruction:
            case XPathNodeType.Comment:
            case XPathNodeType.Text:
            case XPathNodeType.Whitespace:
            case XPathNodeType.SignificantWhitespace:
                string text = node.Value;
                return TextEvent(text);

                
            case XPathNodeType.Root:
            case XPathNodeType.All:
                break;

            default:
                Debug.Fail("Invalid XPathNodeType in CopyTextEvent");
                break;
            }

            return true;
        }

        internal bool CopyEndEvent(XPathNavigator node) {
            switch (node.NodeType) {
            case XPathNodeType.Element:
            case XPathNodeType.Attribute:
            case XPathNodeType.ProcessingInstruction:
            case XPathNodeType.Comment:
            case XPathNodeType.Namespace:
                return EndEvent(node.NodeType);

            case XPathNodeType.Text:
                // Text was copied in CopyContents();
                break;


            case XPathNodeType.Root:
            case XPathNodeType.Whitespace:
            case XPathNodeType.SignificantWhitespace:
            case XPathNodeType.All:
                break;

            default:
                Debug.Fail("Invalid XPathNodeType in CopyEndEvent");
                break;
            }

            return true;
        }

        internal static bool IsRoot(XPathNavigator navigator) {
            Debug.Assert(navigator != null);

            if (navigator.NodeType == XPathNodeType.Root) {
                return true;
            }
            else if (navigator.NodeType == XPathNodeType.Element) {
                XPathNavigator clone = navigator.Clone();
                clone.MoveToRoot();
                return clone.IsSamePosition(navigator);
            }
            else {
                return false;
            }
        }

        //
        // Builder stack
        //
        internal void PushOutput(RecordOutput output) {
            Debug.Assert(output != null);
            this.builder.OutputState = this.xsm.State;
            RecordBuilder lastBuilder = this.builder;
            this.builder      = new RecordBuilder(output, this.nameTable);
            this.builder.Next = lastBuilder;

            this.xsm.Reset();
        }

        internal RecordOutput PopOutput() {
            Debug.Assert(this.builder != null);

            RecordBuilder topBuilder = this.builder;
            this.builder              = topBuilder.Next;
            this.xsm.State            = this.builder.OutputState;

            topBuilder.TheEnd();

            return topBuilder.Output;
        }

        internal bool SetDefaultOutput(XsltOutput.OutputMethod method) {
            if(Output.Method != method) {
                this.output = this.output.CreateDerivedOutput(method);
                return true;
            }
            return false;
        }

        internal Object GetVariableValue(VariableAction variable) {
            int variablekey = variable.VarKey;
            ActionFrame frame = (ActionFrame) (variable.IsGlobal ? this.actionStack[0] : this.actionStack.Peek());
            return frame.GetVariable(variablekey);
        }

        internal void SetParameter(XmlQualifiedName name, object value) {
            Debug.Assert(1 < actionStack.Length);
            ActionFrame parentFrame = (ActionFrame) this.actionStack[actionStack.Length - 2];
            parentFrame.SetParameter(name, value);
        }

        internal void ResetParams() {
            ActionFrame frame = (ActionFrame) this.actionStack[actionStack.Length - 1];
            frame.ResetParams();
        }

        internal object GetParameter(XmlQualifiedName name) {
            Debug.Assert(2 < actionStack.Length);
            ActionFrame parentFrame = (ActionFrame) this.actionStack[actionStack.Length - 3];
            return parentFrame.GetParameter(name);
        }

        // ---------------------- Debugger stack -----------------------

        internal class DebuggerFrame {
            internal ActionFrame        actionFrame;
            internal XmlQualifiedName   currentMode;
        }

        internal void PushDebuggerStack() {
            Debug.Assert(this.Debugger != null, "We don't generate calls this function if ! debugger");
            DebuggerFrame dbgFrame = (DebuggerFrame) this.debuggerStack.Push();
            if (dbgFrame == null) {
                dbgFrame = new DebuggerFrame();
                this.debuggerStack.AddToTop(dbgFrame);
            }
            dbgFrame.actionFrame = (ActionFrame) this.actionStack.Peek(); // In a case of next builtIn action.
        }

        internal void PopDebuggerStack() {
            Debug.Assert(this.Debugger != null, "We don't generate calls this function if ! debugger");
            this.debuggerStack.Pop();
        }

        internal void OnInstructionExecute() {
            Debug.Assert(this.Debugger != null, "We don't generate calls this function if ! debugger");
            DebuggerFrame dbgFrame = (DebuggerFrame) this.debuggerStack.Peek();
            Debug.Assert(dbgFrame != null, "PushDebuggerStack() wasn't ever called");
            dbgFrame.actionFrame = (ActionFrame) this.actionStack.Peek();
            this.Debugger.OnInstructionExecute((IXsltProcessor) this);
        }

        internal XmlQualifiedName GetPrevioseMode() {
            Debug.Assert(this.Debugger != null, "We don't generate calls this function if ! debugger");
            Debug.Assert(2 <= this.debuggerStack.Length); 
            return ((DebuggerFrame) this.debuggerStack[this.debuggerStack.Length - 2]).currentMode;
        }

        internal void SetCurrentMode(XmlQualifiedName mode) {
            Debug.Assert(this.Debugger != null, "We don't generate calls this function if ! debugger");
            ((DebuggerFrame) this.debuggerStack[this.debuggerStack.Length - 1]).currentMode = mode;
        }

        // ----------------------- IXsltProcessor : --------------------
        int IXsltProcessor.StackDepth { 
            get {return this.debuggerStack.Length;}
        }

        IStackFrame IXsltProcessor.GetStackFrame(int depth) {
            return ((DebuggerFrame) this.debuggerStack[depth]).actionFrame;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\stringoutput.cs ===
//------------------------------------------------------------------------------
// <copyright file="StringOutput.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {

    using System;
    using System.Xml;
    using System.Text;

    internal class StringOutput : SequentialOutput {
        private StringBuilder builder;
        private string        result;

        internal string Result {
            get {
                return this.result;
            }
        }

        internal StringOutput(Processor processor)
        : base(processor) {
            this.builder  = new StringBuilder();
        }

        internal override void Write(char outputChar) {
            this.builder.Append(outputChar);

#if DEBUG
            this.result = this.builder.ToString();
#endif
        }

        internal override void Write(string outputText) {
            this.builder.Append(outputText);

#if DEBUG
            this.result = this.builder.ToString();
#endif
        }

        internal override void Close() {
            this.result = this.builder.ToString();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\templateaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="TemplateAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.Xml;
    using System.Xml.XPath;
    using System.Globalization;

    internal class TemplateAction : TemplateBaseAction {
        private string            match;
        private int               matchKey = Compiler.InvalidQueryKey;
        private XmlQualifiedName  name;
        private double            priority = double.NaN;
        private XmlQualifiedName  mode;
        private int               templateId;
        private bool              replaceNSAliasesDone;

        internal string Match {
            get { return this.match; }
        }

        internal int MatchKey {
            get { return this.matchKey; }
        }

        internal XmlQualifiedName Name {
            get { return this.name; }
        }

        internal double Priority {
            get { return this.priority; }
        }

        internal XmlQualifiedName Mode {
            get { return this.mode; }
        }

        internal int TemplateId {
            get { return this.templateId; }
            set {
                Debug.Assert(this.templateId == 0);
                this.templateId = value;
            }
        }

        internal override void Compile(Compiler compiler) {
            CompileAttributes(compiler);
            if (this.match == null && this.name == null) {
                Debug.Assert(this.matchKey == Compiler.InvalidQueryKey);
                throw new XsltException(Res.Xslt_TemplateNoAttrib);
            }
            if ( this.matchKey == Compiler.InvalidQueryKey  && this.mode != null ) {
                throw new XsltException(Res.Xslt_InvalidModeAttribute);
            }
            compiler.BeginTemplate(this);

            if (compiler.Recurse()) {
                CompileParameters(compiler);
                CompileTemplate(compiler);

                compiler.ToParent();
            }

            compiler.EndTemplate();
            AnalyzePriority(compiler);
        }

        internal virtual void CompileSingle(Compiler compiler) {
            this.match      = Compiler.RootQuery;
            this.matchKey   = Compiler.RootQueryKey;
            this.priority   = Compiler.RootPriority;

            CompileOnceTemplate(compiler);
        }

        internal override bool CompileAttribute(Compiler compiler) {
            string name   = compiler.Input.LocalName;
            string value  = compiler.Input.Value;

            if (Keywords.Equals(name, compiler.Atoms.Match)) {
                Debug.Assert(this.match == null);
                this.match    = value;
                this.matchKey = compiler.AddPatternQuery(value, /*allowVars:*/false, /*allowKey:*/true);
                Debug.WriteLine("match attribute found: \"" + this.match + "\"  (#" + this.matchKey + ")");
            }
            else if (Keywords.Equals(name, compiler.Atoms.Name)) {
                Debug.Assert(this.name == null);
                this.name = compiler.CreateXPathQName(value);
                Debug.WriteLine("name attribute found: " + this.name);
            }
            else if (Keywords.Equals(name, compiler.Atoms.Priority)) {
                Debug.Assert(Double.IsNaN(this.priority));
                this.priority = XmlConvert.ToXPathDouble(value);
                if (double.IsNaN(this.priority) && ! compiler.ForwardCompatibility) {
                    throw XsltException.InvalidAttrValue(Keywords.s_Priority, value);
                }
            }
            else if (Keywords.Equals(name, compiler.Atoms.Mode)) {
                Debug.Assert(this.mode == null);
                if (compiler.AllowBuiltInMode && value.Trim() == "*") {
                    this.mode = Compiler.BuiltInMode;
                }
                else {
                    this.mode = compiler.CreateXPathQName(value);
                }
                Debug.WriteLine("mode attribute found: " + this.mode);
            }
            else {
                return false;
            }

            return true;
        }

        private void AnalyzePriority(Compiler compiler) {
            NavigatorInput input = compiler.Input;

            if (! Double.IsNaN(this.priority) || this.match == null) {
                return;
            }
            SplitUnions(compiler);
        }

        protected void CompileParameters(Compiler compiler) {
            NavigatorInput input = compiler.Input;
            do {
                switch(input.NodeType) {
                case XPathNodeType.Element:
                    if (Keywords.Equals(input.NamespaceURI, input.Atoms.XsltNamespace) &&
                        Keywords.Equals(input.LocalName, input.Atoms.Param)) {
                        compiler.PushNamespaceScope();
                        AddAction(compiler.CreateVariableAction(VariableType.LocalParameter));
                        compiler.PopScope();
                        continue;
                    }
                    else {
                        return;
                    }
                case XPathNodeType.Text:
                    return;
                case XPathNodeType.SignificantWhitespace:
                    this.AddEvent(compiler.CreateTextEvent());
                    continue;
                default :
                    continue;
                }
            }
            while (input.Advance());
        }

        //
        // Priority calculation plus template splitting
        //

        private TemplateAction CloneWithoutName() {
            TemplateAction clone    = new TemplateAction(); {
                clone.containedActions = this.containedActions;
                clone.mode             = this.mode;
                clone.variableCount    = this.variableCount;
            }
            return clone;
        }

        private void FixupMatch(Compiler compiler, AstNode node) {
            Debug.Assert(node.TypeOfAst != AstNode.QueryType.Operator, "Right operand should be path or filter");
            this.match    = XPathComposer.ComposeXPath(node);
            this.matchKey = compiler.AddQuery(this.match);
            this.priority = node.DefaultPriority;
        }

        private void SplitUnions(Compiler compiler) {
            AstNode node = AstNode.NewAstNode(this.match);
            if (node == null) {
                throw new XsltException(Res.Xslt_InvalidXPath, this.match);
            }

            if (node.TypeOfAst != AstNode.QueryType.Operator) {
                this.priority = node.DefaultPriority;
                return;
            }
            while (node.TypeOfAst == AstNode.QueryType.Operator) {
                Operator op = (Operator) node;
                if (op.OperatorType != Operator.Op.UNION) {
                    Debug.Assert(false, "Match pattern cant contain other top level operators");
                    break;
                }
                // We have here: UNION := UNION '|' path
                TemplateAction right = this.CloneWithoutName();
                right.FixupMatch(compiler, op.Operand2);
                compiler.AddTemplate(right);
                node = op.Operand1;
            }
            this.FixupMatch(compiler, node);
        }

        internal override void ReplaceNamespaceAlias(Compiler compiler) {
            // if template has both name and match it will be twice caled by stylesheet to replace NS aliases.
            if (! replaceNSAliasesDone) {
                base.ReplaceNamespaceAlias(compiler);
                replaceNSAliasesDone = true;
            }
        }

        //
        // Execution
        //

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);

            switch (frame.State) {
            case Initialized:
                if (this.variableCount > 0) {
                    frame.AllocateVariables(this.variableCount);
                }
                if (this.containedActions != null &&  this.containedActions.Count > 0) {
                    processor.PushActionFrame(frame);
                    frame.State = ProcessingChildren;
                }
                else {
                    frame.Finished();
                }
                break;                              // Allow children to run
            case ProcessingChildren:
                frame.Finished();
                break;
            default:
                Debug.Fail("Invalid Container action execution state");
    		    break;
            }
        }

        internal override void Trace(int tab) {
            Debug.Indent(tab);
            Debug.WriteLine("<xsl:template match=\"" + this.match + "\"  (#" + this.matchKey + ")  name=\"" + this.name +
                            "\" mode=\"" + this.mode + "\" priority=\"" + this.priority + "\">");
            base.Trace(tab + 1);
            Debug.Indent(tab);
            Debug.WriteLine("</xsl:template>");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\sortaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="SortAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class SortAction : CompiledAction {
        private int selectKey  = Compiler.InvalidQueryKey;
        private Avt langAvt;
        private Avt dataTypeAvt;
        private Avt orderAvt;
        private Avt caseOrderAvt;
        // Compile time precalculated AVTs
        private string        lang;
        private XmlDataType   dataType  = XmlDataType.Text;
        private XmlSortOrder  order     = XmlSortOrder.Ascending;
        private XmlCaseOrder  caseOrder = XmlCaseOrder.None;
        private Sort          sort; //When we not have AVTs at all we can do this. null otherwise.
        private bool      forwardCompatibility;
        private InputScopeManager  manager;

        private string ParseLang(string value) {
            if(value == null) { // Avt is not constant, or attribute wasn't defined
                return null; 
            }
            if (! XmlComplianceUtil.IsValidLanguageID(value.ToCharArray(), 0, value.Length)) {
                if (this.forwardCompatibility) {
                    return null;
                }
                throw XsltException.InvalidAttrValue(Keywords.s_Lang, value);
            }
            return value;
        }

        private XmlDataType ParseDataType(string value, InputScopeManager manager) {
            if(value == null) { // Avt is not constant, or attribute wasn't defined
                return XmlDataType.Text; 
            }
            if (value == Keywords.s_Text) {
                return XmlDataType.Text;
            }
            if (value == Keywords.s_Number) {
                return XmlDataType.Number; 
            }
            String prefix, localname;
            PrefixQName.ParseQualifiedName(value, out prefix, out localname);
			manager.ResolveXmlNamespace(prefix);
            if (prefix == String.Empty && ! this.forwardCompatibility) {
                throw XsltException.InvalidAttrValue(Keywords.s_DataType, value); 
            }
            return XmlDataType.Text;
        }

        private XmlSortOrder ParseOrder(string value) {
            if(value == null) { // Avt is not constant, or attribute wasn't defined
                return XmlSortOrder.Ascending; 
            }
            if (value == Keywords.s_Ascending) {
                return XmlSortOrder.Ascending;
            }
            if (value == Keywords.s_Descending) {
                return XmlSortOrder.Descending;
            }
            if (this.forwardCompatibility) {
                return XmlSortOrder.Ascending;
            }
            throw XsltException.InvalidAttrValue(Keywords.s_Order, value);        
        }

        private XmlCaseOrder ParseCaseOrder(string value) {
            if(value == null) { // Avt is not constant, or attribute wasn't defined
                return XmlCaseOrder.None; 
            }
            if (value == Keywords.s_UpperFirst) {
                return XmlCaseOrder.UpperFirst;
            }
            if (value == Keywords.s_LowerFirst) {
                return XmlCaseOrder.LowerFirst;
            }
            if (this.forwardCompatibility) {
                return XmlCaseOrder.None; 
            }
            throw XsltException.InvalidAttrValue(Keywords.s_CaseOrder, value);        
        }
        
        internal override void Compile(Compiler compiler) {
            CompileAttributes(compiler);
            CheckEmpty(compiler);
            if (selectKey == Compiler.InvalidQueryKey) {
                selectKey = compiler.AddQuery(Compiler.SelfQuery);
            }

            this.forwardCompatibility = compiler.ForwardCompatibility;
            this.manager = compiler.CloneScopeManager();

            this.lang      = ParseLang(     PrecalculateAvt(ref this.langAvt     ));
            this.dataType  = ParseDataType( PrecalculateAvt(ref this.dataTypeAvt ), manager);
            this.order     = ParseOrder(    PrecalculateAvt(ref this.orderAvt    ));
            this.caseOrder = ParseCaseOrder(PrecalculateAvt(ref this.caseOrderAvt));

            if(this.langAvt == null && this.dataTypeAvt == null && this.orderAvt == null && this.caseOrderAvt == null) {
                this.sort = new Sort(this.selectKey, this.lang, this.dataType, this.order, this.caseOrder);
            }
        }

        internal override bool CompileAttribute(Compiler compiler) {
            string name   = compiler.Input.LocalName;
            string value  = compiler.Input.Value;

            if (Keywords.Equals(name, compiler.Atoms.Select)) {
                this.selectKey = compiler.AddQuery(value);
            }
            else if (Keywords.Equals(name, compiler.Atoms.Lang)) {
                this.langAvt = Avt.CompileAvt(compiler, value);
            }
            else if (Keywords.Equals(name, compiler.Atoms.DataType)) {
                this.dataTypeAvt = Avt.CompileAvt(compiler, value);
            }
            else if (Keywords.Equals(name, compiler.Atoms.Order)) {
                this.orderAvt = Avt.CompileAvt(compiler, value);
            }    
            else if (Keywords.Equals(name, compiler.Atoms.CaseOrder)) {
                this.caseOrderAvt = Avt.CompileAvt(compiler, value);
            }    
            else {
                return false;
            }
            return true;
        }
        
        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);
            Debug.Assert(frame.State == Initialized);
            
            processor.AddSort(this.sort != null ? 
                this.sort : 
                new Sort(
                    this.selectKey,
                    this.langAvt      == null ? this.lang      : ParseLang(     this.langAvt     .Evaluate(processor, frame)),
                    this.dataTypeAvt  == null ? this.dataType  : ParseDataType( this.dataTypeAvt .Evaluate(processor, frame), manager),
                    this.orderAvt     == null ? this.order     : ParseOrder(    this.orderAvt    .Evaluate(processor, frame)),
                    this.caseOrderAvt == null ? this.caseOrder : ParseCaseOrder(this.caseOrderAvt.Evaluate(processor, frame))
                )
            );
            frame.Finished();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\sequentialoutput.cs ===
//------------------------------------------------------------------------------
// <copyright file="SequentialOutput.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Text;
    using System.Collections;
    using System.Globalization;
    
    internal abstract class SequentialOutput : RecordOutput {
        private const char   s_Colon                = ':';
        private const char   s_GreaterThan          = '>';
        private const char   s_LessThan             = '<';
        private const char   s_Space                = ' ';
        private const char   s_Quote                = '\"';
        private const char   s_Semicolon            = ';';
        private const char   s_NewLine              = '\n';
        private const char   s_Return               = '\r';
        private const char   s_Ampersand            = '&';
        private const string s_LessThanQuestion     = "<?";
        private const string s_QuestionGreaterThan  = "?>";
        private const string s_LessThanSlash        = "</";
        private const string s_SlashGreaterThan     = " />";
        private const string s_EqualQuote           = "=\"";
        private const string s_DocType              = "<!DOCTYPE ";
        private const string s_CommentBegin         = "<!--";
        private const string s_CommentEnd           = "-->";
        private const string s_CDataBegin           = "<![CDATA[";
        private const string s_CDataEnd             = "]]>";
        private const string s_VersionAll           = " version=\"1.0\"";
        private const string s_Standalone           = " standalone=\"";
        private const string s_EncodingStart        = " encoding=\"";
        private const string s_Public               = "PUBLIC ";
        private const string s_System               = "SYSTEM ";
        private const string s_Html                 = "html";
        private const string s_QuoteSpace           = "\" ";
        private const string s_CDataSplit           = "]]]]><![CDATA[>";

        private const string s_EnLessThan           = "&lt;";
        private const string s_EnGreaterThan        = "&gt;";
        private const string s_EnAmpersand          = "&amp;";
        private const string s_EnQuote              = "&quot;";
        private const string s_EnNewLine            = "&#xA;";
        private const string s_EnReturn             = "&#xD;";

        private const string s_EndOfLine            = "\r\n";

        static char[]   s_TextValueFind    = new char[]   {s_Ampersand, s_GreaterThan, s_LessThan};
        static string[] s_TextValueReplace = new string[] {s_EnAmpersand , s_EnGreaterThan , s_EnLessThan };

        static char[]   s_XmlAttributeValueFind    = new char[]   {s_Ampersand, s_GreaterThan, s_LessThan, s_Quote, s_NewLine, s_Return};
        static string[] s_XmlAttributeValueReplace = new string[] {s_EnAmpersand , s_EnGreaterThan , s_EnLessThan , s_EnQuote , s_EnNewLine , s_EnReturn };

        // Instance members
        private     Processor processor;
        protected   Encoding  encoding;
        private     ArrayList outputCache;
        private     bool      firstLine          = true;
        private     bool      secondRoot;

        // Cached Output propertes:
        private XsltOutput output;
        private bool       isHtmlOutput;
        private bool       isXmlOutput;
        private Hashtable  cdataElements;
        private bool       indentOutput;
        private bool       outputDoctype;
        private bool       outputXmlDecl;
        private bool       omitXmlDeclCalled;

        // Uri Escaping:
        private byte[]     byteBuffer;
        private Encoding   utf8Encoding;

        private void CacheOuptutProps(XsltOutput output) {
            this.output        = output;
            this.isXmlOutput   = this.output.Method == XsltOutput.OutputMethod.Xml;
            this.isHtmlOutput  = this.output.Method == XsltOutput.OutputMethod.Html;
            this.cdataElements = this.output.CDataElements;
            this.indentOutput  = this.output.Indent;
            this.outputDoctype = this.output.DoctypeSystem != null || (this.isHtmlOutput && this.output.DoctypePublic != null);
            this.outputXmlDecl = this.isXmlOutput && ! this.output.OmitXmlDeclaration && ! this.omitXmlDeclCalled;
        }

        //
        // Constructor
        //
        internal SequentialOutput(Processor processor) {
            this.processor = processor;
            CacheOuptutProps(processor.Output);
        }

        public void OmitXmlDecl() {
            this.omitXmlDeclCalled = true;
            this.outputXmlDecl = false;
        }

        //
        // Particular outputs
        //
        void WriteStartElement(RecordBuilder record) {
            Debug.Assert(record.MainNode.NodeType == XmlNodeType.Element);
            BuilderInfo mainNode = record.MainNode;
            HtmlElementProps htmlProps = null;
            if (this.isHtmlOutput) {
                if (mainNode.Prefix.Length == 0) {
                    htmlProps = mainNode.htmlProps;
                    if (htmlProps == null && mainNode.search) {
                        htmlProps = HtmlElementProps.GetProps(mainNode.LocalName);
                    }
                    record.Manager.CurrentElementScope.HtmlElementProps = htmlProps;
                    mainNode.IsEmptyTag = false;
                }
            }
            else if (this.isXmlOutput) {
                if (mainNode.Depth == 0) {
                    if(
                        secondRoot && (
                            output.DoctypeSystem != null ||
                            output.Standalone
                        )
                    ) {
                        throw new XsltException(Res.Xslt_MultipleRoots);
                    }
                    secondRoot = true;
                }                
            }

            if (this.outputDoctype) {
                WriteDoctype(mainNode);
                this.outputDoctype = false;
            }

            if (this.cdataElements != null && this.cdataElements.Contains(new XmlQualifiedName(mainNode.LocalName, mainNode.NamespaceURI)) && this.isXmlOutput) {
                record.Manager.CurrentElementScope.ToCData = true;
            }

            Indent(record);
            Write(s_LessThan);
            WriteName(mainNode.Prefix, mainNode.LocalName);

            WriteAttributes(record.AttributeList, record.AttributeCount, htmlProps);


            if (mainNode.IsEmptyTag) {
                Debug.Assert(! this.isHtmlOutput || mainNode.Prefix != null, "Html can't have abreviated elements");
                Write(s_SlashGreaterThan);
            }
            else {
                Write(s_GreaterThan);
            }

            if(htmlProps != null && htmlProps.Head) {
                mainNode.Depth ++;
                Indent(record);
                mainNode.Depth --;
                Write("<META http-equiv=\"Content-Type\" content=\"");
                Write(this.output.MediaType);
                Write("; charset=");
                Write(this.encoding.WebName);
                Write("\">");
            }
        }

        void WriteTextNode(RecordBuilder record) {
            BuilderInfo mainNode = record.MainNode;
            OutputScope scope = record.Manager.CurrentElementScope;

            scope.Mixed = true;

            if(scope.HtmlElementProps != null && scope.HtmlElementProps.NoEntities) {
                // script or stile
                Write(mainNode.Value);
            }
            else if (scope.ToCData) {
                WriteCDataSection(mainNode.Value);
            }
            else {
                WriteTextNode(mainNode);
            }
        }

        void WriteTextNode(BuilderInfo node) {
            for(TextInfo textInfo = node; textInfo != null; textInfo = textInfo.nextTextInfo) {
                if(textInfo.disableEscaping) {
                    Write(textInfo.valueBuilder.ToString());
                }
                else {
                    WriteWithReplace(textInfo.valueBuilder.ToString(), s_TextValueFind, s_TextValueReplace);
                }
            }
        }

        void WriteCDataSection(string value) {
            Write(s_CDataBegin);
            WriteCData(value);
            Write(s_CDataEnd);
        }

        void WriteDoctype(BuilderInfo mainNode) {
            Debug.Assert(this.outputDoctype == true, "It supposed to check this condition before actual call");
            Debug.Assert(this.output.DoctypeSystem != null || (this.isHtmlOutput && this.output.DoctypePublic != null), "We set outputDoctype == true only if");
            Indent(0);
            Write(s_DocType);
            if (this.isXmlOutput) {
                WriteName(mainNode.Prefix, mainNode.LocalName);
            }
            else {
                WriteName(string.Empty, s_Html);
            }
            Write(s_Space);
            if (output.DoctypePublic != null) {
                Write(s_Public);
                Write(s_Quote);
                Write(output.DoctypePublic);
                Write(s_QuoteSpace);
            }
            else {
                Write(s_System);
            }
            if (output.DoctypeSystem != null) {
                Write(s_Quote);
                Write(output.DoctypeSystem);
                Write(s_Quote);
            }
            Write(s_GreaterThan);
        }

        void WriteXmlDeclaration() {
            Debug.Assert(this.outputXmlDecl == true, "It supposed to check this condition before actual call");
            Debug.Assert(this.isXmlOutput && ! this.output.OmitXmlDeclaration, "We set outputXmlDecl == true only if");
            this.outputXmlDecl = false;

            Indent(0);
            Write(s_LessThanQuestion);
            WriteName(String.Empty, "xml");
            Write(s_VersionAll);
            if (this.encoding != null) {
                Write(s_EncodingStart);
                Write(this.encoding.WebName);
                Write(s_Quote);
            }
            if (output.HasStandalone) {
                Write(s_Standalone);
                Write(output.Standalone ? Keywords.s_Yes : Keywords.s_No);
                Write(s_Quote);
            }
            Write(s_QuestionGreaterThan);
        }

        void WriteProcessingInstruction(RecordBuilder record) {
            Indent(record);
            WriteProcessingInstruction(record.MainNode);
        }

        void WriteProcessingInstruction(BuilderInfo node) {
            Write(s_LessThanQuestion);
            WriteName(node.Prefix, node.LocalName);
            Write(s_Space);
            Write(node.Value);

            if(this.isHtmlOutput) {
                Write(s_GreaterThan);
            }
            else {
                Write(s_QuestionGreaterThan);
            }
        }

        void WriteEndElement(RecordBuilder record) {
            BuilderInfo node = record.MainNode;
            HtmlElementProps htmlProps = record.Manager.CurrentElementScope.HtmlElementProps;

            if(htmlProps != null && htmlProps.Empty) {
                return;
            }

            Indent(record);
            Write(s_LessThanSlash);
            WriteName(record.MainNode.Prefix, record.MainNode.LocalName);
            Write(s_GreaterThan);
        }

        //
        // RecordOutput interface method implementation
        //

        public Processor.OutputResult RecordDone(RecordBuilder record) {
            if (output.Method == XsltOutput.OutputMethod.Unknown) {
                if (! DecideDefaultOutput(record.MainNode)) {
                    CacheRecord(record);
                }
                else {
                    OutputCachedRecords();
                    OutputRecord(record);    
                }
            }
            else {
                OutputRecord(record);
            }

            record.Reset();
            return Processor.OutputResult.Continue;
        }

        public void TheEnd() {
            OutputCachedRecords();
            Close();
        }

        private bool DecideDefaultOutput(BuilderInfo node) {
            XsltOutput.OutputMethod method = XsltOutput.OutputMethod.Xml;
            switch (node.NodeType) {
            case XmlNodeType.Element:
                if (node.NamespaceURI.Length == 0 && String.Compare(Keywords.s_Html, node.LocalName, /*ignoreCase:*/true, CultureInfo.InvariantCulture) == 0) {
                    method = XsltOutput.OutputMethod.Html;
                }
                break;
            case XmlNodeType.Text:
            case XmlNodeType.Whitespace:
            case XmlNodeType.SignificantWhitespace:
                if (XmlCharType.IsOnlyWhitespace(node.Value)) {
                    return false;
                }
                method = XsltOutput.OutputMethod.Xml;
                break;
            default :
                return false;
            }
            if(this.processor.SetDefaultOutput(method)) {
                CacheOuptutProps(processor.Output);                
            }
            return true;
        }

        private void CacheRecord(RecordBuilder record) {
            if (this.outputCache == null) {
                this.outputCache = new ArrayList();
            }

            this.outputCache.Add(record.MainNode.Clone());
        }

        private void OutputCachedRecords() {
            if (this.outputCache == null) {
                return;
            }

            for(int record = 0; record < this.outputCache.Count; record ++) {
                Debug.Assert(this.outputCache[record] is BuilderInfo);
                BuilderInfo info = (BuilderInfo) this.outputCache[record];

                OutputRecord(info);
            }

            this.outputCache = null;
        }

        private void OutputRecord(RecordBuilder record) {
            BuilderInfo mainNode = record.MainNode;

            if(this.outputXmlDecl) {
                WriteXmlDeclaration();
            }

            switch (mainNode.NodeType) {
            case XmlNodeType.Element:
                WriteStartElement(record);
                break;
            case XmlNodeType.Text:
            case XmlNodeType.Whitespace:
            case XmlNodeType.SignificantWhitespace:
                WriteTextNode(record);
                break;
            case XmlNodeType.CDATA:
                Debug.Fail("Should never get here");
                break;
            case XmlNodeType.EntityReference:
                Write(s_Ampersand);
                WriteName(mainNode.Prefix, mainNode.LocalName);
                Write(s_Semicolon);
                break;
            case XmlNodeType.ProcessingInstruction:
                WriteProcessingInstruction(record);
                break;
            case XmlNodeType.Comment:
                Indent(record);
                Write(s_CommentBegin);
                Write(mainNode.Value);
                Write(s_CommentEnd);
                break;
            case XmlNodeType.Document:
                break;
            case XmlNodeType.DocumentType:
                Write(mainNode.Value);
                break;
            case XmlNodeType.EndElement:
                WriteEndElement(record);
                break;
            default:
                break;
            }
        }

        private void OutputRecord(BuilderInfo node) {
            if(this.outputXmlDecl) {
                WriteXmlDeclaration();
            }

            Indent(0); // we can have only top level stuff here

            switch (node.NodeType) {
            case XmlNodeType.Element:
                Debug.Fail("Should never get here");
                break;
            case XmlNodeType.Text:
            case XmlNodeType.Whitespace:
            case XmlNodeType.SignificantWhitespace:
                WriteTextNode(node);
                break;
            case XmlNodeType.CDATA:
                Debug.Fail("Should never get here");
                break;
            case XmlNodeType.EntityReference:
                Write(s_Ampersand);
                WriteName(node.Prefix, node.LocalName);
                Write(s_Semicolon);
                break;
            case XmlNodeType.ProcessingInstruction:
                WriteProcessingInstruction(node);
                break;
            case XmlNodeType.Comment:
                Write(s_CommentBegin);
                Write(node.Value);
                Write(s_CommentEnd);
                break;
            case XmlNodeType.Document:
                break;
            case XmlNodeType.DocumentType:
                Write(node.Value);
                break;
            case XmlNodeType.EndElement:
                Debug.Fail("Should never get here");
                break;
            default:
                break;
            }
        }

        //
        // Internal helpers
        //

        private void WriteName(string prefix, string name) {
            if (prefix != null && prefix.Length > 0) {
                Write(prefix);
                if (name != null && name.Length > 0) {
                    Write(s_Colon);
                }
                else {
                    return;
                }
            }
            Write(name);
        }

        private void WriteXmlAttributeValue(string value) {
            Debug.Assert(value != null);
            WriteWithReplace(value, s_XmlAttributeValueFind, s_XmlAttributeValueReplace);
        }

        private void WriteHtmlAttributeValue(string value) {
            Debug.Assert(value != null);

            int length = value.Length;
            int i = 0;
            while(i < length) {
                char ch = value[i];
                i ++;
                switch (ch) {
                case '&':
                    if(i != length && value[i] == '{') { // &{ hasn't to be encoded in HTML output.
                        Write(ch);
                    }
                    else {
                        Write(s_EnAmpersand);
                    }
                    break;
                case '"':
                    Write(s_EnQuote);
                    break;
                default:
                    Write(ch);
                    break;
                }
            }
        }

        private void WriteHtmlUri(string value) {
            Debug.Assert(value != null);
            Debug.Assert(this.isHtmlOutput);

            int length = value.Length;
            int i = 0;
            while(i < length) {
                char ch = value[i];
                i ++;
                switch (ch) {
                case '&':
                    if(i != length && value[i] == '{') { // &{ hasn't to be encoded in HTML output.
                        Write(ch);
                    }
                    else {
                        Write(s_EnAmpersand);
                    }
                    break;
                case '"':
                    Write(s_EnQuote);
                    break;
                case '\n':
                    Write(s_EnNewLine);
                    break;
                case '\r':
                    Write(s_EnReturn);
                    break;
                default:
                    if(127 < ch) {
                        if (this.utf8Encoding == null) {
                            this.utf8Encoding = Encoding.UTF8;
                            this.byteBuffer   = new byte[utf8Encoding.GetMaxByteCount(1)];
                        }
                        int bytes = this.utf8Encoding.GetBytes(value, i - 1, 1, this.byteBuffer, 0);
                        for(int j = 0; j < bytes; j ++) {
                            Write("%");
                            Write(((uint)this.byteBuffer[j]).ToString("X2"));
                        }
                    }
                    else {
                        Write(ch);
                    }
                    break;
                }
            }
        }

        private void WriteWithReplace(string value, char[] find, string[] replace) {
            Debug.Assert(value != null);
            Debug.Assert(find.Length == replace.Length);

            int length = value.Length;
            int pos = 0;
            while(pos < length) {
                int newPos = value.IndexOfAny(find, pos);
                if (newPos == -1) {
                    break; // not found;
                }
                // output clean leading part of the string
                while (pos < newPos) {
                    Write(value[pos]);
                    pos ++;
                }
                // output replacement
                char badChar = value[pos];
                int i;
                for(i = find.Length - 1; 0 <= i; i --) {
                    if(find[i] == badChar) {
                        Write(replace[i]);
                        break;
                    }
                }
                Debug.Assert(0 <= i, "find char wasn't realy find");
                pos ++;
            }

            // output rest of the string
            if(pos == 0) {
                Write(value);
            }
            else {
                while(pos < length) {
                    Write(value[pos]);
                    pos ++;
                }
            }
        }

        private void WriteCData(string value) {
            Debug.Assert(value != null);
            Write(value.Replace(s_CDataEnd, s_CDataSplit));
        }

        private void WriteAttributes(ArrayList list, int count, HtmlElementProps htmlElementsProps) {
            Debug.Assert(count <= list.Count);
            for (int attrib = 0; attrib < count; attrib ++) {
                Debug.Assert(list[attrib] is BuilderInfo);
                BuilderInfo attribute = (BuilderInfo) list[attrib];
                string attrValue = attribute.Value;
                bool abr = false, uri = false; {
                    if(htmlElementsProps != null && attribute.Prefix.Length == 0) {
                        HtmlAttributeProps htmlAttrProps = attribute.htmlAttrProps;
                        if (htmlAttrProps == null && attribute.search) {
                            htmlAttrProps = HtmlAttributeProps.GetProps(attribute.LocalName);
                        }
                        if(htmlAttrProps != null) {
                            abr = htmlElementsProps.AbrParent  && htmlAttrProps.Abr;
                            uri = htmlElementsProps.UriParent  && ( htmlAttrProps.Uri ||
								  htmlElementsProps.NameParent && htmlAttrProps.Name
							);
                        }
                    }
                }
                Write(s_Space);
                WriteName(attribute.Prefix, attribute.LocalName);
                if(abr && 0 == string.Compare(attribute.LocalName, attrValue, /*ignoreCase:*/true, CultureInfo.InvariantCulture) ) {
                    // Since the name of the attribute = the value of the attribute, 
                    // this is a boolean attribute whose value should be suppressed
                    continue; 
                }
                Write(s_EqualQuote);
                if(uri) {
                    WriteHtmlUri(attrValue);
                }
                else if(this.isHtmlOutput) {
                    WriteHtmlAttributeValue(attrValue);
                }
                else {
                    WriteXmlAttributeValue(attrValue);
                }
                Write(s_Quote);
            }
        }

        void Indent(RecordBuilder record) {
            if (! record.Manager.CurrentElementScope.Mixed) {
                Indent(record.MainNode.Depth);
            }
        }

        void Indent(int depth) {
            if(this.firstLine) {
                if (this.indentOutput) {
                    this.firstLine = false;
                }
                return;    // preven leading CRLF
            }
            Write(s_EndOfLine);
            for (int i = 2 * depth; 0 < i; i--) {
                Write(" ");
            }
        }

        //
        // Abstract methods
        internal abstract void Write(char outputChar);
        internal abstract void Write(string outputText);
        internal abstract void Close();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\templatemanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="TemplateManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;
    using System.Collections;

    internal class TemplateManager {
        private XmlQualifiedName mode;
        internal ArrayList       templates;
        private Stylesheet       stylesheet;    // Owning stylesheet

        private class TemplateComparer : IComparer {
            public int Compare(object x, object y) {
                Debug.Assert(x != null && x is TemplateAction);
                Debug.Assert(y != null && y is TemplateAction);

                TemplateAction tx = (TemplateAction) x;
                TemplateAction ty = (TemplateAction) y;

                Debug.Assert(! Double.IsNaN(tx.Priority));
                Debug.Assert(! Double.IsNaN(ty.Priority));

                if (tx.Priority == ty.Priority) {
                    Debug.Assert(tx.TemplateId != ty.TemplateId || tx == ty);
                    return tx.TemplateId - ty.TemplateId;
                }
                else {
                    return tx.Priority > ty.Priority ? 1 : -1;
                }
            }
        }

        private static TemplateComparer s_TemplateComparer = new TemplateComparer();

        internal XmlQualifiedName Mode {
            get { return this.mode; }
        }

        internal TemplateManager(Stylesheet stylesheet, XmlQualifiedName mode) {
            this.mode       = mode;
            this.stylesheet = stylesheet;
        }

        internal void AddTemplate(TemplateAction template) {
            Debug.Assert(template != null);
            Debug.Assert(
                ((object) this.mode == (object) template.Mode) ||
                (template.Mode == null && this.mode.Equals(XmlQualifiedName.Empty)) ||
                this.mode.Equals(template.Mode)
            );

            if (this.templates == null) {
                this.templates = new ArrayList();
            }

            Debug.Assert(this.templates != null);
            Debug.WriteLine("Adding Template #" + this.templates.Count + ", mode==\"" + template.Mode + "\" match=\"" + template.Match + "\"");

            this.templates.Add(template);
        }

        internal void ProcessTemplates() {
            if (this.templates != null) {
                this.templates.Sort(s_TemplateComparer);
            }
        }

        internal TemplateAction FindTemplate(Processor processor, XPathNavigator navigator) {
            if (this.templates == null) {
                return null;
            }

            Debug.Assert(this.templates != null);
            for (int templateIndex = this.templates.Count - 1; templateIndex >= 0 ; templateIndex --) {
                TemplateAction action = (TemplateAction) this.templates[templateIndex];
                int matchKey = action.MatchKey;

                if (matchKey != Compiler.InvalidQueryKey) {
                    if (processor.Matches(navigator, matchKey)) {
                        return action;
                    }
                }
            }

            Debug.WriteLine("Template not found");

            return null;
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal void Trace(int tab) {
            Debug.Indent(tab);
            Debug.WriteLine("Template manager for mode \"" + this.mode + "\"");
            Debug.WriteLine("templates :");

            if (this.templates != null) {
                for (int template = 0; template < this.templates.Count; template ++) {
                    TemplateAction action = (TemplateAction) this.templates[template];
                    action.Trace(tab + 1);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\templatebaseaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="TemplateBaseAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.Xml;
    using System.Xml.XPath;
    using System.Globalization;

    // RootAction and TemplateActions have a litle in common -- they are responsible for variable allocation
    // TemplateBaseAction -- implenemts this shared behavior

    internal abstract class TemplateBaseAction : ContainerAction {
        protected int variableCount;      // space to allocate on frame for variables
        private   int variableFreeSlot;   // compile time counter responsiable for variable placement logic

        public int AllocateVariableSlot() {
            // Variable placement logic. Optimized
            int thisSlot = this.variableFreeSlot;
            this.variableFreeSlot ++;
            if(this.variableCount < this.variableFreeSlot) {
                this.variableCount = this.variableFreeSlot;
            }
            return thisSlot;
        }

        public void ReleaseVariableSlots(int n) {
        // This code does optimisation of variable placement. Comented out for this version
        //      Reuse of the variable disable the check that variable was assigned before the actual use
        //      this check has to be done in compile time n future.
//            this.variableFreeSlot -= n;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\textevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class TextEvent : Event {
        private string text;
        
        protected TextEvent() {}

        public TextEvent(string text) {
            Debug.Assert(text != null);
            this.text = text;
        }

        public TextEvent(Compiler compiler) {
            NavigatorInput input = compiler.Input;
            Debug.Assert(input.NodeType == XPathNodeType.Text || input.NodeType == XPathNodeType.SignificantWhitespace);
            this.text = input.Value;
        }

        public override bool Output(Processor processor, ActionFrame frame) {
            return processor.TextEvent(this.text);
        }

        public virtual string Evaluate(Processor processor, ActionFrame frame) {
            return this.text;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\textaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class TextAction : CompiledAction {
        private bool   disableOutputEscaping;
        private string text;

        internal override void Compile(Compiler compiler) {
            CompileAttributes(compiler);
            CompileContent(compiler);

        }

        internal override bool CompileAttribute(Compiler compiler) {
            string name   = compiler.Input.LocalName;
            string value  = compiler.Input.Value;

            if (Keywords.Equals(name, compiler.Atoms.DisableOutputEscaping)) {
                this.disableOutputEscaping = compiler.GetYesNo(value);
            }
            else {
                return false;
            }

            return true;
        }

        private void CompileContent(Compiler compiler) {
            if (compiler.Recurse()) {
                NavigatorInput input = compiler.Input;

                this.text = String.Empty;

                do {
                    switch (input.NodeType) {
                    case XPathNodeType.Text:
                    case XPathNodeType.Whitespace:
                    case XPathNodeType.SignificantWhitespace:
                        this.text += input.Value;
                        break;
                    case XPathNodeType.Comment:
                    case XPathNodeType.ProcessingInstruction:
                        break;
                    default:
                        throw XsltException.UnexpectedKeyword(compiler);
                    }
                } while(compiler.Advance());
                compiler.ToParent();
            }
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);

            switch (frame.State) {
            case Initialized:
                if (processor.TextEvent(this.text, disableOutputEscaping)) {
                    frame.Finished();
                }
                break;

            default:
                Debug.Fail("Invalid execution state in TextAction");
                break;
            }
        }

        internal override void Trace(int tab) {
            Debug.Indent(tab);
            Debug.WriteLine("<xsl:text disable-output-escaping=\"" + this.disableOutputEscaping + "\">");
            Debug.WriteLine(this.text);
            Debug.WriteLine("</xsl:text>");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\templatelookupaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="TemplateLookupAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class TemplateLookupAction : Action {
        protected XmlQualifiedName mode;
        protected Stylesheet       importsOf;

        internal void Initialize(XmlQualifiedName mode, Stylesheet importsOf) {
            this.mode      = mode;
            this.importsOf = importsOf;
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);
            Debug.Assert(frame.State == Initialized);

            Action action = null;

            if (this.mode != null) {
                action = importsOf == null 
                    ? processor.Stylesheet.FindTemplate(processor, frame.Node, this.mode)
                    : importsOf.FindTemplateImports(processor, frame.Node, this.mode);
            }
            else {
                action = importsOf == null 
                    ? processor.Stylesheet.FindTemplate(processor, frame.Node)
                    : importsOf.FindTemplateImports(processor, frame.Node);
            }

            // Built-int template rules
            if (action == null) {
                action = BuiltInTemplate(frame.Node);
            }

            // Jump
            if (action != null) {
                frame.SetAction(action);
            }
            else {
                frame.Finished();
            }
        }

        internal Action BuiltInTemplate(XPathNavigator node) {
            Debug.Assert(node != null);
            Action action = null;

            switch (node.NodeType) {
            //  <xsl:template match="*|/" [mode="?"]>
            //    <xsl:apply-templates [mode="?"]/>
            //  </xsl:template>
            case XPathNodeType.Element:
            case XPathNodeType.Root:
                Debug.WriteLine("->->->->-> Picking built-in rule for element (mode == \"" + this.mode + "\") <-<-<-<-<-");
                action = ApplyTemplatesAction.BuiltInRule(this.mode);
                break;
            //  <xsl:template match="text()|@*">
            //    <xsl:value-of select="."/>
            //  </xsl:template>
            case XPathNodeType.Attribute:
            case XPathNodeType.Whitespace:
            case XPathNodeType.SignificantWhitespace:
            case XPathNodeType.Text:
                Debug.WriteLine("->->->->-> Picking built-in rule for text or attribute <-<-<-<-<-");
                action = ValueOfAction.BuiltInRule();
                break;
            // <xsl:template match="processing-instruction()|comment()"/>
            case XPathNodeType.ProcessingInstruction:
            case XPathNodeType.Comment:
                // Empty action;
                break;
            case XPathNodeType.All:
                // Ignore the rest
                break;
            }

            return action;
        }
    }

    internal class TemplateLookupActionDbg : TemplateLookupAction {
        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);
            Debug.Assert(frame.State == Initialized);
            Debug.Assert(processor.Debugger != null);

            Action action = null;

            if (this.mode == Compiler.BuiltInMode) {
                // mode="*" -- use one from debuggerStack
                this.mode = processor.GetPrevioseMode();
                Debug.Assert(this.mode != Compiler.BuiltInMode);
            }
            processor.SetCurrentMode(this.mode);

            if (this.mode != null) {
                action = importsOf == null 
                    ? processor.Stylesheet.FindTemplate(processor, frame.Node, this.mode)
                    : importsOf.FindTemplateImports(processor, frame.Node, this.mode);
            }
            else {
                action = importsOf == null 
                    ? processor.Stylesheet.FindTemplate(processor, frame.Node)
                    : importsOf.FindTemplateImports(processor, frame.Node);
            }

            // Built-int template rules
            if (action == null && processor.RootAction.builtInSheet != null) {
                action = processor.RootAction.builtInSheet.FindTemplate(processor, frame.Node, Compiler.BuiltInMode);
            }
            if (action == null) {
                action = BuiltInTemplate(frame.Node);
            }

            // Jump
            if (action != null) {
                frame.SetAction(action);
            }
            else {
                frame.Finished();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\thequery.cs ===
//------------------------------------------------------------------------------
// <copyright file="TheQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {

    using System;
    using System.Xml;
    using System.Xml.XPath;

    internal sealed class TheQuery {
        internal InputScopeManager   _ScopeManager;
        private  XPathExpression   _CompiledQuery;

        internal XPathExpression CompiledQuery {
            get {
                return _CompiledQuery;
            }
            set {
                _CompiledQuery = value;
            }
        }
        

        internal InputScopeManager ScopeManager {
            get {
                return _ScopeManager;
            }
        }

        internal TheQuery( CompiledXpathExpr compiledQuery, InputScopeManager manager) {
            _CompiledQuery = compiledQuery;
            _ScopeManager = manager.Clone();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\textonlyoutput.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextOnlyOutput.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {

    using System;
    using System.IO;
    using System.Xml;
    using System.Xml.XPath;
    using System.Text;
    using System.Collections;

    internal class TextOnlyOutput : RecordOutput {
        private     Processor  processor;
        private     TextWriter writer;

        internal XsltOutput Output {
            get { return this.processor.Output; }
        }

		public TextWriter Writer {
			get { return this.writer; }
		}

        //
        // Constructor
        //

        internal TextOnlyOutput(Processor processor, Stream stream) {
            if (stream == null) {
                throw new ArgumentNullException("stream");
            }

            this.processor  = processor;
            this.writer     = new StreamWriter(stream, Output.Encoding);
        }

        internal TextOnlyOutput(Processor processor, TextWriter writer) {
            if (writer == null) {
                throw new ArgumentNullException("writer");
            }

            this.processor  = processor;
            this.writer     = writer;
        }

        //
        // RecordOutput interface method implementation
        //

        public Processor.OutputResult RecordDone(RecordBuilder record) {
            BuilderInfo mainNode       = record.MainNode;

            switch (mainNode.NodeType) {
            case XmlNodeType.Text:
            case XmlNodeType.Whitespace:
            case XmlNodeType.SignificantWhitespace:
                this.writer.Write(mainNode.Value);
                break;
            default:
                break;
            }

            record.Reset();
            return Processor.OutputResult.Continue;
        }

        public void TheEnd() {
            this.writer.Flush();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\textoutput.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextOutput.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {

    using System;
    using System.IO;
    using System.Xml;
    using System.Xml.XPath;
    using System.Text;

    internal class TextOutput : SequentialOutput {
        private TextWriter writer;

        internal TextWriter Writer {
            get {
                return this.writer;
            }
        }

        internal TextOutput(Processor processor, Stream stream)
            : base(processor) 
        {
            if (stream == null) {
                throw new ArgumentNullException("stream");
            }

            this.encoding = processor.Output.Encoding;
            this.writer   = new StreamWriter(stream, this.encoding);
        }

        internal TextOutput(Processor processor, TextWriter writer)
            : base(processor) 
        {
            if (writer == null) {
                throw new ArgumentNullException("writer");
            }

            this.encoding = writer.Encoding;
            this.writer   = writer;
        }

        internal override void Write(char outputChar) {
            this.writer.Write(outputChar);
        }

        internal override void Write(string outputText) {
            this.writer.Write(outputText);
        }

        internal override void Close() {
            this.writer.Flush();
            this.writer = null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\useattributesetsaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="UseAttributeSetsAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;
    using System.Collections;

    internal class UseAttributeSetsAction : CompiledAction {
        private XmlQualifiedName[]  useAttributeSets;
        private string              useString;

        private const int  ProcessingSets = 2;

        internal XmlQualifiedName[] UsedSets {
            get { return this.useAttributeSets; }
        }

        internal override void Compile(Compiler compiler) {
            Debug.Assert(Keywords.Equals(compiler.Input.LocalName, compiler.Atoms.UseAttributeSets));
            this.useString = compiler.Input.Value;

            Debug.Assert(this.useAttributeSets == null);

            if (this.useString.Length == 0) {
                // Split creates empty node is spliting empty string
                this.useAttributeSets = new XmlQualifiedName[0];
                return ;
            }

            string[] qnames = Compiler.SplitString(this.useString);

            this.useAttributeSets = new XmlQualifiedName[qnames.Length]; {
                for (int i = 0; i < qnames.Length; i++) {
                    this.useAttributeSets[i] = compiler.CreateXPathQName(qnames[i]);
                }
            }
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            switch(frame.State) {
            case Initialized:
                frame.Counter = 0;
                frame.State = ProcessingSets;
                goto case ProcessingSets;

            case ProcessingSets:
                if (frame.Counter < this.useAttributeSets.Length) {
                    AttributeSetAction action = processor.RootAction.GetAttributeSet(this.useAttributeSets[frame.Counter]);
                    frame.IncrementCounter();
                    processor.PushActionFrame(action, frame.NodeSet);
                }
                else {
                    frame.Finished();
                }
                break;

            default:
                Debug.Fail("Invalid Container action execution state");
		        break;
            }
        }

        internal override void Trace(int tab) {
            Debug.Indent(tab);
            Debug.WriteLine("use-attribute-set name=\"" + this.useString + "\">");
            Debug.Indent(tab);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\valueofaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="ValueOfAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;

    internal class ValueOfAction : CompiledAction {
        private const int ResultStored = 2;

        private string select;
        private int    selectKey = Compiler.InvalidQueryKey;
        private bool   disableOutputEscaping;

        static private ValueOfAction s_BuiltInRule;

        static ValueOfAction() {
            s_BuiltInRule = new ValueOfAction(); {
                s_BuiltInRule.select    = Compiler.SelfQuery;
                s_BuiltInRule.selectKey = Compiler.SelfQueryKey;
            }
        }

        internal static ValueOfAction BuiltInRule() {
            Debug.Assert(s_BuiltInRule != null);
            return s_BuiltInRule;
        }

        internal override String Select {
            get { return this.select; }
        }
        
        internal override void Compile(Compiler compiler) {
            Debug.Assert(!IsBuiltInAction);
            CompileAttributes(compiler);
            CheckRequiredAttribute(compiler, this.select, Keywords.s_Select);
            CheckEmpty(compiler);
        }

        internal override bool CompileAttribute(Compiler compiler) {
            string name   = compiler.Input.LocalName;
            string value  = compiler.Input.Value;

            if (Keywords.Equals(name, compiler.Atoms.Select)) {
                this.select    = value;
                //this.selectKey = compiler.AddStringQuery(this.select);
                this.selectKey = compiler.AddQuery(this.select);
                Debug.WriteLine("value-of select = \"" + this.select + "\"  (#" + this.selectKey + ")");
            }
            else if (Keywords.Equals(name, compiler.Atoms.DisableOutputEscaping)) {
                this.disableOutputEscaping = compiler.GetYesNo(value);
            }
            else {
                return false;
            }

            return true;
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);

            switch (frame.State) {
            case Initialized:
                Debug.Assert(frame != null);
                Debug.Assert(frame.NodeSet != null);

                if (this.selectKey == Compiler.InvalidQueryKey) {
                    throw new XsltException(Res.Xslt_InvalidXPath,  new string[] { select });
                }

                string value = processor.ValueOf(frame, this.selectKey);

                if (processor.TextEvent(value, disableOutputEscaping)) {
                    frame.Finished();
                }
                else {
                    frame.StoredOutput = value;
                    frame.State        = ResultStored;
                }
                break;

            case ResultStored:
                Debug.Assert(frame.StoredOutput != null);
                processor.TextEvent(frame.StoredOutput);
                frame.Finished();
                break;

            default:
                Debug.Fail("Invalid ValueOfAction execution state");
                break;
            }
        }

        private bool IsBuiltInAction {
            get { return this == s_BuiltInRule; }
        }

        internal override void Trace(int tab) {
            Debug.Indent(tab);
            Debug.WriteLine("<xsl:value-of select=\"" + this.select + "\"  (#" + this.selectKey + ")/>");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\variableaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="VariableAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.Xml;
    using System.Xml.XPath;
    using System.Xml.Xsl.Debugger;

    internal enum VariableType {
        GlobalVariable,
        GlobalParameter,
        LocalVariable,
        LocalParameter,
        WithParameter,
    }

    internal class VariableAction : ContainerAction, IXsltContextVariable {
        protected XmlQualifiedName  name;
        protected string            nameStr;
        protected string            select;
        protected int               selectKey = Compiler.InvalidQueryKey;
        protected int               stylesheetid;
        protected VariableType      varType;
        private   int               varKey;

        internal int Stylesheetid {
            get { return this.stylesheetid; }
        }
        internal override String Select {
            get { return this.select; }
        }        
        internal XmlQualifiedName Name {
            get { return this.name; }
        }
        internal string NameStr {
            get { return this.nameStr; }
        }
        internal VariableType VarType {
            get { return this.varType; }
        }
        internal int VarKey {
            get { return this.varKey; }
        }
        internal bool IsGlobal {
            get { return this.varType == VariableType.GlobalVariable || this.varType == VariableType.GlobalParameter; }
        }

        internal VariableAction(VariableType type) {
            this.varType = type;
        }

        internal override void Compile(Compiler compiler) {
            this.stylesheetid = compiler.Stylesheetid;
            CompileAttributes(compiler);
            CheckRequiredAttribute(compiler, this.name, Keywords.s_Name);

            Debug.WriteLine("Variable inserted under the key: #" + this.varKey);

            if (compiler.Recurse()) {
                CompileTemplate(compiler);
                compiler.ToParent();

                if (this.select != null && this.containedActions != null) {
                    throw new XsltException(Res.Xslt_VariableCntSel, this.nameStr, this.select);
                }
            }

            this.varKey = compiler.InsertVariable(this);
        }

        internal override bool CompileAttribute(Compiler compiler) {
            string name   = compiler.Input.LocalName;
            string value  = compiler.Input.Value;

            if (Keywords.Equals(name, compiler.Atoms.Name)) {
                Debug.Assert(this.name == null && this.nameStr == null);
                this.nameStr = value;
                this.name    = compiler.CreateXPathQName(this.nameStr);
                Debug.WriteLine("name attribute found: " + this.name);
            }
            else if (Keywords.Equals(name, compiler.Atoms.Select)) {
                Debug.Assert(this.select == null);
                this.select    = value;
                this.selectKey = compiler.AddQuery(this.select);
                Debug.WriteLine("select attribute = \"" + this.select + "\"  (#" + this.selectKey + ")");
            }
            else {
                return false;
            }

            return true;
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);
            switch(frame.State) {
            case Initialized:
                object value = processor.GetGlobalParameter(this.name);
                if (value != null) {
                    frame.SetVariable(this.varKey, value);
                    frame.Finished();
                    break;
                } 
                if (this.varType == VariableType.LocalParameter)
                    if ((value = processor.GetParameter(this.name)) != null) {
                        frame.SetVariable(this.varKey, value);
                        frame.Finished();
                        break;
                    }
                if (this.selectKey != Compiler.InvalidQueryKey) {
                    value = processor.RunQuery(frame, this.selectKey);
                    frame.SetVariable(this.varKey, value);
                    frame.Finished();
                }
                else {
                    if (this.containedActions == null){
                        frame.SetVariable(this.varKey, "");
                        frame.Finished();
                        break;
                    }
                    NavigatorOutput output = new NavigatorOutput();
                    processor.PushOutput(output);
                    processor.PushActionFrame(frame);
                    frame.State = ProcessingChildren;
                }
                break;

            case ProcessingChildren:
                RecordOutput recOutput = processor.PopOutput();
                Debug.Assert(recOutput is NavigatorOutput);
                frame.SetVariable(this.varKey, ((NavigatorOutput)recOutput).Navigator);
                frame.Finished();
                break;

            default:
                Debug.Fail("Invalid execution state inside VariableAction.Execute");
		    break;
            }
        }

        internal override void Trace(int tab) {
            Debug.Indent(tab);
            Debug.WriteLine("<xsl:variable select=\"" + this.select + "\" name=\"" + this.name + "\">");
            base.Trace(tab);
            Debug.Indent(tab);
            Debug.WriteLine("</xsl:variable>");
        }

        // ---------------------- IXsltContextVariable --------------------

        XPathResultType IXsltContextVariable.VariableType { 
            get { return XPathResultType.Any; }
        }
        object IXsltContextVariable.Evaluate(XsltContext xsltContext) {
            return ((XsltCompileContext)xsltContext).EvaluateVariable(this);
        }
        bool   IXsltContextVariable.IsLocal { 
            get { return this.varType == VariableType.LocalVariable  || this.varType == VariableType.LocalParameter;  }
        }
        bool   IXsltContextVariable.IsParam { 
            get { return this.varType == VariableType.LocalParameter || this.varType == VariableType.GlobalParameter; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\withparamaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="WithParamAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.Xml;
    using System.Xml.XPath;

    internal class WithParamAction : VariableAction {
        internal WithParamAction() : base(VariableType.WithParameter) {}

        internal override void Compile(Compiler compiler) {
            CompileAttributes(compiler);
            CheckRequiredAttribute(compiler, this.name, Keywords.s_Name);
            if (compiler.Recurse()) {
                CompileTemplate(compiler);
                compiler.ToParent();

                if (this.select != null && this.containedActions != null) {
                    throw new XsltException(Res.Xslt_VariableCntSel, this.nameStr, this.select);
                }
            }
        }
        
        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(processor != null && frame != null);
            object ParamValue;
            switch(frame.State) {
            case Initialized:           
                if (this.selectKey != Compiler.InvalidQueryKey) {
                    ParamValue = processor.RunQuery(frame, this.selectKey);
                    processor.SetParameter(this.name, ParamValue);
                    frame.Finished();
                }
                else {
                    if (this.containedActions == null) {
                        processor.SetParameter(this.name, String.Empty);
                        frame.Finished();
                        break;
                    }
                    NavigatorOutput output = new NavigatorOutput();
                    processor.PushOutput(output);
                    processor.PushActionFrame(frame);
                    frame.State = ProcessingChildren;
                }
                break;
            case ProcessingChildren:
                RecordOutput recOutput = processor.PopOutput();
                Debug.Assert(recOutput is NavigatorOutput);
                processor.SetParameter(this.name,((NavigatorOutput)recOutput).Navigator);
                frame.Finished();
                break;
            default:
                Debug.Fail("Invalid execution state inside VariableAction.Execute");
		    break;
            }
        }

        internal override void Trace(int tab) {
            Debug.Indent(tab);
            Debug.WriteLine("<xsl:variable select=\"" + this.select + "\" name=\"" + this.name + "\">");
            base.Trace(tab);
            Debug.Indent(tab);
            Debug.WriteLine("</xsl:variable>");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\writeroutput.cs ===
//------------------------------------------------------------------------------
// <copyright file="WriterOutput.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.XPath;
    using System.Collections;

    internal class WriterOutput : RecordOutput {
        private XmlWriter writer;
        private Processor processor;

        internal WriterOutput(Processor processor, XmlWriter writer) {
            if (writer == null) {
                throw new ArgumentNullException("writer");
            }

            this.writer    = writer;
            this.processor = processor;
        }

        // RecordOutput interface method implementation
        //
        public Processor.OutputResult RecordDone(RecordBuilder record) {
            BuilderInfo mainNode       = record.MainNode;

            switch (mainNode.NodeType) {
            case XmlNodeType.Element:
                this.writer.WriteStartElement(mainNode.Prefix, mainNode.LocalName, mainNode.NamespaceURI);

                WriteAttributes(record.AttributeList, record.AttributeCount);

                if (mainNode.IsEmptyTag) {
                    this.writer.WriteEndElement();
                }
                break;
            case XmlNodeType.Text:
            case XmlNodeType.Whitespace:
            case XmlNodeType.SignificantWhitespace:
                this.writer.WriteString(mainNode.Value);
                break;
            case XmlNodeType.CDATA:
                Debug.Assert(false, "XSLT never gives us CDATA");
                this.writer.WriteCData(mainNode.Value);
                break;
            case XmlNodeType.EntityReference:
                this.writer.WriteEntityRef(mainNode.LocalName);
                break;
            case XmlNodeType.ProcessingInstruction:
                this.writer.WriteProcessingInstruction(mainNode.LocalName, mainNode.Value);
                break;
            case XmlNodeType.Comment:
                this.writer.WriteComment(mainNode.Value);
                break;
            case XmlNodeType.Document:
                break;
            case XmlNodeType.DocumentType:
                this.writer.WriteRaw(mainNode.Value);
                break;
            case XmlNodeType.EndElement:
                this.writer.WriteFullEndElement();
                break;

            case XmlNodeType.None:
            case XmlNodeType.Attribute:
            case XmlNodeType.Entity:
            case XmlNodeType.Notation:
            case XmlNodeType.DocumentFragment:
            case XmlNodeType.EndEntity:
                break;
            default:
                Debug.Fail("Invalid NodeType on output: " + ((int)mainNode.NodeType).ToString());
                break;
            }

            record.Reset();
            return Processor.OutputResult.Continue;
        }

        public void TheEnd() {
            this.writer.Flush();
            this.writer = null;
        }

        private void WriteAttributes(ArrayList list, int count) {
            Debug.Assert(list.Count >= count);
            for (int attrib = 0; attrib < count; attrib ++) {
                Debug.Assert(list[attrib] is BuilderInfo);
                BuilderInfo attribute = (BuilderInfo) list[attrib];
                this.writer.WriteAttributeString(attribute.Prefix, attribute.LocalName, attribute.NamespaceURI, attribute.Value);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\xmltotextwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlToTextWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
* 
* Copyright (c) 2000 Microsoft Corporation. All rights reserved.
* 
*/

#if DIRECT_WRITER

namespace System.Xml.Xslt {
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Text;
    using System.Diagnostics;

/*
    Text Writer differ from Xml Writer:
    1.  Outputs only content of text() nodes
    2.  No encoding 
*/
    internal class XmlToTextWriter : XmlTextWriter {
        private bool inAttibute;

        public override void WriteStartAttribute(string prefix, string name, string ns) {
            inAttibute = true;
        }

        public override void WriteEndAttribute() {
            inAttibute = false;
        }
        public override void WriteString(string text) {
            if(! inAttibute) {
                base.WriteRaw(text);
            }
        }

        public override void WriteStartElement(string prefix, string name, string ns) {}
        public override void WriteEndElement() {}
        public override void WriteFullEndElement() {}
        public override void WriteCData(string text) {}
        public override void WriteComment(string text) {}
        public override void WriteProcessingInstruction(string name, string text) {}
        public override void WriteEntityRef(string name) {}
        public override void WriteCharEntity(char ch) {}
        public override void WriteStartDocument() {}
        public override void WriteStartDocument(bool standalone) {}
        public override void WriteEndDocument() {}
        public override void WriteDocType(string name, string pubid, string sysid, string subset) {}
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\xmltonavigatorwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlToNavigatorWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
* 
* Copyright (c) 2000 Microsoft Corporation. All rights reserved.
* 
*/

#if DIRECT_WRITER
namespace System.Xml.Xslt {
    using System;
    using System.Xml.XPath;

    internal class XmlToNavigatorWriter : XmlWriter {
        protected XPathDocument doc;
        protected XPathContainer node;
        protected XPathAttribute attr;

        public XPathNavigator Navigator {
            get { return ((IXPathNavigable)doc).CreateNavigator(); }
        }

        internal XmlToNavigatorWriter() {
            doc = new XPathDocument();
            node = doc.root;
        }

        public override void WriteStartElement(string prefix, string name, string ns) {
            XPathElement e = new XPathElement(prefix, name, ns);
            node.AppendChild(e);
            node = e;
        }

        public override void WriteEndElement() {
            node = node.parent;
        }

        public override void WriteString(string text) {
            if(attr != null) {
                attr.AppendText(text);
            }
            else {
                node.AppendText(text);
            }
        }
        public override void WriteWhitespace(string text) {WriteString(text);}
        public override void WriteRaw(string text) {WriteString(text);}

        public override void WriteFullEndElement() {
            WriteEndElement();
        }

        public override void WriteStartAttribute(string prefix, string name, string ns) {
            attr = new XPathAttribute(prefix, name, ns, string.Empty);
            node.AppendChild(attr);
        }

        public override void WriteEndAttribute() {
            attr = null;
        }

        public override void WriteProcessingInstruction(string name, string text) {
            node.AppendChild(new XPathProcessingInstruction(name, text));
        }

        public override void WriteComment(string text) {
            node.AppendChild(new XPathComment(text));
        }

        public override void WriteStartDocument() {}
        public override void WriteStartDocument(bool standalone) {}
        public override void WriteEndDocument() {}
        public override void WriteDocType(string name, string pubid, string sysid, string subset) {}
        public override void WriteCData(string text) {}
        public override void WriteEntityRef(string name) {}
        public override void WriteCharEntity(char ch) {}
        public override void WriteChars(char[] buffer, int index, int count) {}
        public override void WriteRaw(char[] buffer, int index, int count) {}
        public override void WriteBase64(byte[] buffer, int index, int count) {}
        public override void WriteBinHex(byte[] buffer, int index, int count) {}
        public override void Close() {}
        public override void Flush() {}
        public override string LookupPrefix(string ns) {return String.Empty;}
        public override void WriteNmToken(string name) {}
        public override void WriteName(string name) {}
        public override void WriteQualifiedName(string localName, string ns) {}
        public override XmlSpace XmlSpace { get { return XmlSpace.None; } }
        public override String   XmlLang { get { return String.Empty; } }
        public override WriteState WriteState {
            get {
                return (attr != null ? WriteState.Attribute : WriteState.Element);
            }
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\xsltargumentlist.cs ===
//------------------------------------------------------------------------------
// <copyright file="XsltArgumentList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Collections;
    using System.Xml.XPath;
    using System.Security;
    using System.Security.Permissions;

     /// <include file='doc\XsltArgumentList.uex' path='docs/doc[@for="XsltArgumentList"]/*' />
     /// <devdoc>
     ///    <para>[To be supplied.]</para>
     /// </devdoc>
    public sealed class XsltArgumentList {
        Hashtable parameters = new Hashtable();
        Hashtable extensions = new Hashtable();
     	/// <include file='doc\XsltArgumentList.uex' path='docs/doc[@for="XsltArgumentList.XsltArgumentList"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public XsltArgumentList() {}
     	/// <include file='doc\XsltArgumentList.uex' path='docs/doc[@for="XsltArgumentList.GetParam"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public object GetParam(string name, string namespaceUri) {
            return GetParam(new XmlQualifiedName(name, namespaceUri));
        }

        internal object GetParam(XmlQualifiedName qname) {
            return this.parameters[qname];
        }
     	/// <include file='doc\XsltArgumentList.uex' path='docs/doc[@for="XsltArgumentList.GetExtensionObject"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public object GetExtensionObject(string namespaceUri) {
            return this.extensions[namespaceUri];
        }

     	/// <include file='doc\XsltArgumentList.uex' path='docs/doc[@for="XsltArgumentList.AddParam"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public void AddParam(string name, string namespaceUri, object parameter) {
            CheckArgumentNull(name        , "name"        );
            CheckArgumentNull(namespaceUri, "namespaceUri");
            CheckArgumentNull(parameter   , "parameter"   );
            ValidateParamNamespace(namespaceUri);

            if (
                parameter is XPathNodeIterator ||
                parameter is XPathNavigator    ||
                parameter is Boolean           ||
                parameter is Double            ||
                parameter is String
            ) {
                // doing nothing
            }
            else if (
                parameter is Int16  || parameter is UInt16 ||
                parameter is Int32  || parameter is UInt32 ||
                parameter is Int64  || parameter is UInt64 ||
                parameter is Single || parameter is Decimal
            ) {
                parameter = XmlConvert.ToXPathDouble(parameter);
            }
            else {
                parameter = parameter.ToString();
            }
            XmlQualifiedName qname = new XmlQualifiedName(name, namespaceUri);
            qname.Verify();
            this.parameters.Add(qname, parameter);
        }

     	/// <include file='doc\XsltArgumentList.uex' path='docs/doc[@for="XsltArgumentList.AddExtensionObject"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        public void AddExtensionObject(string namespaceUri, object extension) {
            CheckArgumentNull(namespaceUri, "namespaceUri");
            CheckArgumentNull(extension   , "extension"   );
            ValidateExtensionNamespace(namespaceUri);
            this.extensions.Add(namespaceUri, extension);
        }

     	/// <include file='doc\XsltArgumentList.uex' path='docs/doc[@for="XsltArgumentList.RemoveParam"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public object RemoveParam(string name, string namespaceUri) {
            XmlQualifiedName qname = new XmlQualifiedName(name, namespaceUri);
            object parameter = this.parameters[qname];
            this.parameters.Remove(qname);
            return parameter;
        }
     	///<include file='doc\XsltArgumentList.uex' path='docs/doc[@for="XsltArgumentList.RemoveExtensionObject"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public object RemoveExtensionObject(string namespaceUri) {
            object extension = this.extensions[namespaceUri];
            this.extensions.Remove(namespaceUri);
            return extension;
        }

        /// <include file='doc\XsltArgumentList.uex' path='docs/doc[@for="XsltArgumentList.Clear"]/*' />
        public void Clear() {
            this.parameters.Clear();
            this.extensions.Clear();
        }
        
        internal static void  ValidateExtensionNamespace(string nsUri) {
            if (nsUri == string.Empty || nsUri == Keywords.s_XsltNamespace) {
                throw new XsltException(Res.Xslt_InvalidExtensionNamespace);
            }
            XmlConvert.ToUri(nsUri);
        }

        internal static void  ValidateParamNamespace(string nsUri) {
            if (nsUri != string.Empty) {
                if (nsUri == Keywords.s_XsltNamespace) {
                    throw new XsltException(Res.Xslt_InvalidParamNamespace);
                }
                XmlConvert.ToUri(nsUri);
            }
        }

        private static void CheckArgumentNull(object param, string paramName) {
            if (param == null) {
                throw new ArgumentNullException(paramName);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\xsltdebugger.cs ===
//------------------------------------------------------------------------------
// <copyright file="XsltDebugger.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl.Debugger {
    using System;
    using System.Xml;
    using System.Xml.XPath;
    
    internal interface IStackFrame {
        XPathNavigator    Instruction     { get; }
        XPathNodeIterator NodeSet         { get; }
        // Variables:
        int               GetVariablesCount();
        XPathNavigator    GetVariable(int varIndex);
        object            GetVariableValue(int varIndex);
    }

    internal interface IXsltProcessor {
        int         StackDepth { get; }
        IStackFrame GetStackFrame(int depth);
    }

    internal interface IXsltDebugger {
        string GetBuiltInTemplatesUri();
        void   OnInstructionCompile(XPathNavigator styleSheetNavigator);
        void   OnInstructionExecute(IXsltProcessor xsltProcessor);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\xsltdebug.cs ===
//------------------------------------------------------------------------------
// <copyright file="XsltDebug.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {

    using System;
    using System.Xml;
    using System.Xml.XPath;

    internal sealed class Debug {
#if DEBUG
        const string s_XsltCategory = "Xslt";
#endif
        private Debug() {
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal static void Indent(int indent) {
            System.Diagnostics.Debug.IndentLevel = indent;
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal static void Fail(string message) {
            System.Diagnostics.Debug.Fail(message);
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal static void Assert(bool condition) {
            System.Diagnostics.Debug.Assert(condition);
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal static void Assert(bool condition, string message) {
            System.Diagnostics.Debug.Assert(condition, message);
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal static void NotImplemented() {
            System.Diagnostics.Debug.Fail("Not Implemented");
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal static void Write(string message) {
#if DEBUGTRACETRACE
            System.Diagnostics.Debug.Write(message, s_XsltCategory);
#endif
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal static void WriteLine(string message) {
#if DEBUGTRACE
            System.Diagnostics.Debug.WriteLine(message, s_XsltCategory);
#endif
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal static void Trace(NavigatorInput record) {
#if DEBUGTRACE
            string s;
            s = String.Format("Element: {0} ({1}) : {2}", record.Prefix, record.NamespaceURI, record.LocalName);
            System.Diagnostics.Debug.WriteLine(s, s_XsltCategory);
#endif
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal static void TraceAttribute(NavigatorInput input) {
#if DEBUGTRACE
            string s;
            s = String.Format("Attribute: {0}({1}):{2}={3}", new Object[] {input.Prefix, input.NamespaceURI, input.LocalName, input.Value});
            System.Diagnostics.Debug.WriteLine(s, s_XsltCategory);
#endif
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal static void TraceElement(NavigatorInput input) {
#if DEBUGTRACE
            System.Diagnostics.Debug.WriteLine("=============== Element trace ==================", s_XsltCategory);
            Trace(input);
            if (input.MoveToFirstAttribute()) {
                do {
                    TraceAttribute(input);
                }
                while (input.MoveToNextAttribute());
                input.ToParent();
            }
#endif
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal static void TraceContext(XPathNavigator context) {
#if DEBUGTRACE
            string output = "(null)";

            if (context != null) {
                XPathNavigator node = context.Clone();
                switch (node.NodeType) {
                    case XPathNodeType.Element:
                        output = string.Format("<{0}:{1}", node.Prefix, node.LocalName);
                        for (bool attr = node.MoveToFirstAttribute(); attr; attr = node.MoveToNextAttribute()) {
                            output += string.Format(" {0}:{1}={2}", node.Prefix, node.LocalName, node.Value);
                        }
                        output += ">";
                        break;
		    default:
		        break;
                }
            }

            System.Diagnostics.Debug.WriteLine(output, s_XsltCategory);
#endif
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal static void CompilingMessage() {
#if DEBUGTRACE
            System.Diagnostics.Debug.WriteLine("******************************************************", s_XsltCategory);
            System.Diagnostics.Debug.WriteLine("*              Compiling Stylesheet                  *", s_XsltCategory);
            System.Diagnostics.Debug.WriteLine("******************************************************", s_XsltCategory);
#endif
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal static void TracingMessage() {
#if DEBUGTRACE
            System.Diagnostics.Debug.WriteLine("******************************************************", s_XsltCategory);
            System.Diagnostics.Debug.WriteLine("*             Compiling Done - TRACE                 *", s_XsltCategory);
            System.Diagnostics.Debug.WriteLine("******************************************************", s_XsltCategory);
#endif
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\xsltexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="XsltException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.IO;
    using System.Resources;
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System.Xml.XPath;
    using System.Security.Permissions;
    
    /// <include file='doc\XsltException.uex' path='docs/doc[@for="XsltException"]/*' />
    /// <devdoc>
    ///    <para>Represents the exception that is thrown when there is error processing
    ///       an XSLT transform.</para>
    /// </devdoc>
    [Serializable]
    public class XsltException : SystemException {
        string      res;
        string[]    args;
        string      sourceUri;
        int         lineNumber;
        int         linePosition; 
        string      message;

        /// <include file='doc\XsltException.uex' path='docs/doc[@for="XsltException.XsltException6"]/*' />
        protected XsltException(SerializationInfo info, StreamingContext context) : base(info, context) {
            res          = (string)   info.GetValue("res"         , typeof(string           ));
            args         = (string[]) info.GetValue("args"        , typeof(string[]         ));
            sourceUri    = (string)   info.GetValue("sourceUri"   , typeof(string           ));
            lineNumber   = (int)      info.GetValue("lineNumber"  , typeof(int              ));
            linePosition = (int)      info.GetValue("linePosition", typeof(int              ));
        }

        /// <include file='doc\XsltException.uex' path='docs/doc[@for="XsltException.GetObjectData"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand,SerializationFormatter=true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            base.GetObjectData(info, context);
            info.AddValue("res"         , res         );
            info.AddValue("args"        , args        );
            info.AddValue("sourceUri"   , sourceUri   );
            info.AddValue("lineNumber"  , lineNumber  );
            info.AddValue("linePosition", linePosition);
        }

		/// <include file='doc\XsltException.uex' path='docs/doc[@for="XsltException.XsltException0"]/*' />
		public XsltException(String message, Exception innerException) : base(message, innerException) {
            HResult = HResults.XmlXslt;
			this.res = Res.Xml_UserException;
			this.args = new string[] { message };
		}

        /// <include file='doc\XsltException.uex' path='docs/doc[@for="XsltException.XsltException"]/*' />
        internal XsltException(string res) :
            this(res, (string[])null, null, 0, 0, null) {}

        /// <include file='doc\XsltException.uex' path='docs/doc[@for="XsltException.XsltException1"]/*' />
        internal XsltException(string res, string sourceUri, int lineNumber, int linePosition) :
            this(res, (string[])null, sourceUri, lineNumber, linePosition, null) {}

        /// <include file='doc\XsltException.uex' path='docs/doc[@for="XsltException.XsltException2"]/*' />
        internal XsltException(string res, string[] args) :
            this(res, args, null, 0, 0, null) {}

        /// <include file='doc\XsltException.uex' path='docs/doc[@for="XsltException.XsltException5"]/*' />
        internal XsltException(string res, string[] args, Exception inner) :
            this(res, args, null, 0, 0, inner) {}

        /// <include file='doc\XsltException.uex' path='docs/doc[@for="XsltException.XsltException3"]/*' />
        internal XsltException(string res, string arg) :
            this(res, new string[] { arg }, null, 0, 0, null) {}

        internal XsltException(string res, string arg1, string arg2) :
            this(res, new string[] { arg1, arg2 }, null, 0, 0, null) {}

        /// <include file='doc\XsltException.uex' path='docs/doc[@for="XsltException.XsltException4"]/*' />
        internal XsltException(string res, string[] args, string sourceUri, int lineNumber, int linePosition, Exception inner)
            :base(string.Empty, inner)
        {
            HResult           = HResults.XmlXslt;
            this.res          = res;
            this.args         = args;
            this.sourceUri    = sourceUri;
            this.lineNumber   = lineNumber;
            this.linePosition = linePosition;
        }

        /// <include file='doc\XsltException.uex' path='docs/doc[@for="XsltException.SourceUri"]/*' />
        public string SourceUri {
            get { return this.sourceUri; }
        }

        /// <include file='doc\XsltException.uex' path='docs/doc[@for="XsltException.LineNumber"]/*' />
        public int LineNumber {
            get { return this.lineNumber; }
        }

        /// <include file='doc\XsltException.uex' path='docs/doc[@for="XsltException.LinePosition"]/*' />
        public int LinePosition {
            get { return this.linePosition; }
        }
      
        /// <include file='doc\XsltException.uex' path='docs/doc[@for="XsltException.Message"]/*' />
        public override string Message {
            get {
                string message = this.message;
                if (message == null) {
                    try {
                        message = FormatMessage(res, this.args);
                    }
                    catch {
                        message = "UNKNOWN("+res+")";
                    }

                    if (this.sourceUri != null) {
                        string[] msg = new string[] {this.sourceUri , this.lineNumber.ToString(), this.linePosition.ToString() };
                        message += " " + FormatMessage(Res.Sch_ErrorPosition, msg);
                    }

                    this.message = message;
                }
                return message;
            }

        }        

        private string FormatMessage(string key, string[] args) {
            string message = Res.GetString(key);
            if (message != null && args != null) {
                message = string.Format(message, args);
            }
            return message;
        }

        // --------- "Strong Typed" helper functions: ----------------- 
        static internal XsltException InvalidAttribute(string element, string attr) {
            return new XsltException(Res.Xslt_InvalidAttribute, attr, element);
        }

        static internal XsltException InvalidAttrValue(string attr, string value) {
            return new XsltException(Res.Xslt_InvalidAttrValue, attr, value);
        }
        static internal XsltException UnexpectedKeyword(string elem, string parent) {
            return new XsltException(Res.Xslt_UnexpectedKeyword, elem, parent);
        }
        static internal XsltException UnexpectedKeyword(Compiler compiler) {
            XPathNavigator nav = compiler.Input.Navigator.Clone();
            string thisName = nav.Name;
            nav.MoveToParent();
            string parentName = nav.Name;
            return UnexpectedKeyword(thisName, parentName);
        }
    }

    /// <include file='doc\XsltException.uex' path='docs/doc[@for="XsltCompileException"]/*' />
    [Serializable]
    public class XsltCompileException : XsltException {
        string      message;

        /// <include file='doc\XsltException.uex' path='docs/doc[@for="XsltCompileException.XsltCompileException5"]/*' />
        protected XsltCompileException(SerializationInfo info, StreamingContext context) : base(info, context) {}

        /// <include file='doc\XsltException.uex' path='docs/doc[@for="XsltCompileException.GetObjectData"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand,SerializationFormatter=true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            base.GetObjectData(info, context);
        }

        /// <include file='doc\XsltException.uex' path='docs/doc[@for="XsltCompileException.XsltException1"]/*' />
        public XsltCompileException(Exception inner, string sourceUri, int lineNumber, int linePosition) :
            base(Res.Xslt_CompileError, (string[])null, sourceUri, lineNumber, linePosition, inner) {}

        /// <include file='doc\XsltException.uex' path='docs/doc[@for="XsltCompileException.Message"]/*' />
        public override string Message { 
            get {
                if (this.message == null) {
                    this.message = Res.GetString(Res.Xslt_CompileError,
                        new string[] {this.SourceUri , this.LineNumber.ToString(), this.LinePosition.ToString() }
                    );
                }
                return this.message;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\xsltcontext.cs ===
//------------------------------------------------------------------------------
// <copyright file="XsltContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Xml;
    using System.Collections;
    using System.Xml.XPath;

    /// <include file='doc\XsltContext.uex' path='docs/doc[@for="IXsltContextFunction"]/*' />
    public interface IXsltContextFunction {
        /// <include file='doc\XsltContext.uex' path='docs/doc[@for="IXsltContextFunction.Minargs"]/*' />
        int               Minargs    { get; }
        /// <include file='doc\XsltContext.uex' path='docs/doc[@for="IXsltContextFunction.Maxargs"]/*' />
        int               Maxargs    { get; }
        /// <include file='doc\XsltContext.uex' path='docs/doc[@for="IXsltContextFunction.ReturnType"]/*' />
        XPathResultType   ReturnType { get; }
        /// <include file='doc\XsltContext.uex' path='docs/doc[@for="IXsltContextFunction.ArgTypes"]/*' />
        XPathResultType[] ArgTypes   { get; }
        /// <include file='doc\XsltContext.uex' path='docs/doc[@for="IXsltContextFunction.Invoke"]/*' />
        object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext);
    }

    /// <include file='doc\XsltContext.uex' path='docs/doc[@for="IXsltContextVariable"]/*' />
    public interface IXsltContextVariable {
        /// <include file='doc\XsltContext.uex' path='docs/doc[@for="IXsltContextVariable.IsLocal"]/*' />
        bool            IsLocal { get; }
        /// <include file='doc\XsltContext.uex' path='docs/doc[@for="IXsltContextVariable.IsParam"]/*' />
        bool            IsParam { get; }
        /// <include file='doc\XsltContext.uex' path='docs/doc[@for="IXsltContextVariable.VariableType"]/*' />
        XPathResultType VariableType { get; }
        /// <include file='doc\XsltContext.uex' path='docs/doc[@for="IXsltContextVariable.Evaluate"]/*' />
        object          Evaluate(XsltContext xsltContext);
    }

     /// <include file='doc\XsltContext.uex' path='docs/doc[@for="XsltContext"]/*' />
     /// <devdoc>
     ///    <para>[To be supplied.]</para>
     /// </devdoc>
    public abstract class XsltContext : XmlNamespaceManager {
         /// <include file='doc\XsltContext.uex' path='docs/doc[@for="XsltContext.XsltContext1"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        public  XsltContext(NameTable table):base(table){}
         /// <include file='doc\XsltContext.uex' path='docs/doc[@for="XsltContext.XsltContext2"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        public  XsltContext(){}
         /// <include file='doc\XsltContext.uex' path='docs/doc[@for="XsltContext.ResolveVariable"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        public abstract IXsltContextVariable ResolveVariable(string prefix, string name);
         /// <include file='doc\XsltContext.uex' path='docs/doc[@for="XsltContext.ResolveFunction"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        public abstract IXsltContextFunction ResolveFunction(string prefix, string name, XPathResultType[] ArgTypes);
         /// <include file='doc\XsltContext.uex' path='docs/doc[@for="XsltContext.Whitespace"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        public abstract bool Whitespace { get; }
         /// <include file='doc\XsltContext.uex' path='docs/doc[@for="XsltContext.PreserveWhitespace"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        public abstract bool PreserveWhitespace(XPathNavigator node);
         /// <include file='doc\XsltContext.uex' path='docs/doc[@for="XsltContext.CompareDocument"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
        public abstract int CompareDocument (string baseUri, string nextbaseUri);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\xsltoutput.cs ===
//------------------------------------------------------------------------------
// <copyright file="XsltOutput.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Diagnostics;
    using System.IO;
    using System.Xml;
    using System.Text;
    using System.Collections;

    internal class XsltOutput : CompiledAction {

        internal enum OutputMethod {
            Xml,
            Html,
            Text,
            Other,
            Unknown,
        }

        private OutputMethod    method             = OutputMethod.Unknown;
        private int                 methodSId          = int.MaxValue;
        private Encoding            encoding           = System.Text.Encoding.UTF8;
        private int                 encodingSId        = int.MaxValue;
        private string              version;
        private int                 versionSId         = int.MaxValue;
        private bool                omitXmlDecl;
        private int                 omitXmlDeclSId     = int.MaxValue;
        private bool                standalone;
        private int                 standaloneSId      = int.MaxValue;
        private string              doctypePublic;
        private int                 doctypePublicSId   = int.MaxValue;
        private string              doctypeSystem;
        private int                 doctypeSystemSId   = int.MaxValue;
        private bool                indent;
        private int                 indentSId          = int.MaxValue;
        private string              mediaType          = "text/html";
        private int                 mediaTypeSId       = int.MaxValue;
        private Hashtable           cdataElements;

        internal OutputMethod Method {
            get { return this.method; }
        }

        internal string Version {
            get { return this.version; }
        }

        internal bool OmitXmlDeclaration {
            get { return this.omitXmlDecl; }
        }

        internal bool HasStandalone {
            get { return this.standaloneSId != int.MaxValue; }
        }

        internal bool Standalone {
            get { return this.standalone; }
        }

        internal string DoctypePublic {
            get { return this.doctypePublic; }
        }

        internal string DoctypeSystem {
            get { return this.doctypeSystem; }
        }

        internal Hashtable CDataElements {
            get { return this.cdataElements; }
        }

        internal bool Indent {
            get { return this.indent; }
        }

        internal Encoding Encoding {
            get { return this.encoding; }
        }

        internal string MediaType {
            get { return this.mediaType; }
        }

        internal XsltOutput CreateDerivedOutput(OutputMethod method) {
            XsltOutput output = (XsltOutput) MemberwiseClone();
            output.method = method;
            if (method == OutputMethod.Html && this.indentSId == int.MaxValue) { // HTML output and Ident wasn't specified
                output.indent = true;
            }
            return output;
        }

        internal override void Compile(Compiler compiler) {
            CompileAttributes(compiler);
            CheckEmpty(compiler);
        }

        internal override bool CompileAttribute(Compiler compiler) {
            string name   = compiler.Input.LocalName;
            string value  = compiler.Input.Value;

            if (Keywords.Equals(name, compiler.Atoms.Method)) {
                if (compiler.Stylesheetid <= this.methodSId) {
                    this.method    = ParseOutputMethod(value, compiler);
                    this.methodSId = compiler.Stylesheetid;
                    if (this.indentSId == int.MaxValue) {
                        this.indent = (this.method == OutputMethod.Html);
                    }
                }
            }
            else if (Keywords.Equals(name, compiler.Atoms.Version)) {
                if (compiler.Stylesheetid <= this.versionSId) {
                    this.version    = value;
                    this.versionSId = compiler.Stylesheetid;
                }
            }
            else if (Keywords.Equals(name, compiler.Atoms.Encoding)) {
                if (compiler.Stylesheetid <= this.encodingSId) {
                    try { 
                        this.encoding    = System.Text.Encoding.GetEncoding(value);
                        this.encodingSId = compiler.Stylesheetid;
                    }catch {}
                    Debug.Assert(this.encoding != null);
                }
            }
            else if (Keywords.Equals(name, compiler.Atoms.OmitXmlDeclaration)) {
                if (compiler.Stylesheetid <= this.omitXmlDeclSId) {
                    this.omitXmlDecl    = compiler.GetYesNo(value);
                    this.omitXmlDeclSId = compiler.Stylesheetid;
                }
            }
            else if (Keywords.Equals(name, compiler.Atoms.Standalone)) {
                if (compiler.Stylesheetid <= this.standaloneSId) {
                    this.standalone    = compiler.GetYesNo(value);
                    this.standaloneSId = compiler.Stylesheetid;
                }
            }
            else if (Keywords.Equals(name, compiler.Atoms.DoctypePublic)) {
                if (compiler.Stylesheetid <= this.doctypePublicSId) {
                    this.doctypePublic    = value;
                    this.doctypePublicSId = compiler.Stylesheetid;
                }
            }
            else if (Keywords.Equals(name, compiler.Atoms.DoctypeSystem)) {
                if (compiler.Stylesheetid <= this.doctypeSystemSId) {
                    this.doctypeSystem    = value;
                    this.doctypeSystemSId = compiler.Stylesheetid;
                }
            }
            else if (Keywords.Equals(name, compiler.Atoms.Indent)) {
                if (compiler.Stylesheetid <= this.indentSId) {
                    this.indent    = compiler.GetYesNo(value);
                    this.indentSId = compiler.Stylesheetid;
                }
            }
            else if (Keywords.Equals(name, compiler.Atoms.MediaType)) {
                if (compiler.Stylesheetid <= this.mediaTypeSId) {
                    this.mediaType    = value;
                    this.mediaTypeSId = compiler.Stylesheetid;
                }
            }
            else if (Keywords.Equals(name, compiler.Atoms.CdataSectionElements)) {
                string[] qnames = Compiler.SplitString(value);

                if (this.cdataElements == null) {
                    this.cdataElements = new Hashtable(qnames.Length);
                }

                for (int i = 0; i < qnames.Length; i++) {
                    XmlQualifiedName qname = compiler.CreateXmlQName(qnames[i]);
                    this.cdataElements[qname] = qname;
                }
            }
            else {
                return false;
            }
            return true;
        }

        internal override void Execute(Processor processor, ActionFrame frame) {
            Debug.Assert(false);
        }

        private static OutputMethod ParseOutputMethod(string value, Compiler compiler) {
            XmlQualifiedName method = compiler.CreateXPathQName(value);
            if(method.Namespace != string.Empty) {
                return OutputMethod.Other;
            }
            switch(method.Name) {
            case Keywords.s_Xml  : 
                return OutputMethod.Xml ;
            case Keywords.s_Html : 
                return OutputMethod.Html;
            case Keywords.s_Text : 
                return OutputMethod.Text;
            default :
                if (compiler.ForwardCompatibility) {
                    return OutputMethod.Unknown;
                }
                throw XsltException.InvalidAttrValue(Keywords.s_Method, value);
            }
        }

        internal override void Trace(int tab) {
            Debug.Indent(tab);
            StringBuilder bld = new StringBuilder();
            bld.Append("<xsl:output" +
                "   method=\"" + this.method.ToString() +
                "\" version=\"" + this.version +
                "\" encoding=\"" + this.encoding + "\" omit-xml-declaration=\"" + this.omitXmlDecl +
                "\" standalone=\"" + this.standalone + "\" doctype-public=\"" + this.doctypePublic +
                "\" doctype-system=\"" + this.doctypeSystem + "\" cdata-elements=\""
            );

            if (this.cdataElements != null) {
                IEnumerator e = this.cdataElements.GetEnumerator();
                
                while (e.MoveNext()) {
                    Debug.Assert(((DictionaryEntry)e.Current).Value is XmlQualifiedName);
                    bld.Append((((DictionaryEntry)e.Current).Value).ToString());
                    bld.Append(" ");
                }
            }

            bld.Append("\" indent=\"" + this.indent + "\" media-type=\"" + this.mediaType + "\"/>");
            Debug.WriteLine(bld.ToString());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\xsltcompilecontext.cs ===
//------------------------------------------------------------------------------
// <copyright file="XsltCompileContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {

    using System;
    using System.Text;
    using System.IO;
    using System.Globalization;
    using System.Collections;
    using System.Xml;
    using System.Xml.XPath;
    using System.Reflection;
    using System.Security;

    /// <include file='doc\XsltCompileContext.uex' path='docs/doc[@for="XsltCompileContext"]/*' />
    internal class XsltCompileContext : XsltContext {
        private InputScopeManager manager;
        private Processor         processor;

        // storage for the functions
        private static Hashtable            s_FunctionTable = CreateFunctionTable();
        private static IXsltContextFunction s_FuncNodeSet   = new FuncNodeSet();
        const          string               f_NodeSet       = "node-set";

        internal XsltCompileContext(InputScopeManager manager, Processor processor) {
            this.manager   = manager;
            this.processor = processor;
            //InitFunctions();
        }

        public override int CompareDocument (string baseUri, string nextbaseUri) {
            return String.Compare(baseUri, nextbaseUri, false, CultureInfo.InvariantCulture);
        }
        // Namespace support
        /// <include file='doc\XsltCompileContext.uex' path='docs/doc[@for="XsltCompileContext.DefaultNamespace"]/*' />
        public override string DefaultNamespace {
            get { return string.Empty; }
        }

        /// <include file='doc\XsltCompileContext.uex' path='docs/doc[@for="XsltCompileContext.LookupNamespace"]/*' />
        public override string LookupNamespace(string prefix) { 
            return this.manager.ResolveXPathNamespace(prefix);
        }

        // --------------------------- XsltContext -------------------
        //                Resolving variables and functions

        /// <include file='doc\XsltCompileContext.uex' path='docs/doc[@for="XsltCompileContext.ResolveVariable"]/*' />
        public override IXsltContextVariable ResolveVariable(string prefix, string name) {
            string namespaceURI = this.LookupNamespace(prefix);
            XmlQualifiedName qname = new XmlQualifiedName(name, namespaceURI);
            IXsltContextVariable variable = this.manager.VariableScope.ResolveVariable(qname);
            if (variable == null) {
                throw new XPathException(Res.Xslt_InvalidVariable, qname.ToString());
            }
            return variable;
        }
        
        /// <include file='doc\XsltCompileContext.uex' path='docs/doc[@for="XsltCompileContext.EvaluateVariable1"]/*' />
        internal object EvaluateVariable(VariableAction variable) { 
            Object result = this.processor.GetVariableValue(variable);
            if (result != null || variable.IsGlobal) {
                return result;
            }
            VariableAction global =  this.manager.VariableScope.ResolveGlobalVariable(variable.Name);
            if (global != null) {
                result = this.processor.GetVariableValue(global);
            }
            return result;
        }

        // Whitespace stripping support
        /// <include file='doc\XsltCompileContext.uex' path='docs/doc[@for="XsltCompileContext.Whitespace"]/*' />
        public override bool Whitespace { 
            get { return this.processor.Stylesheet.Whitespace; } 
        }
        
        /// <include file='doc\XsltCompileContext.uex' path='docs/doc[@for="XsltCompileContext.PreserveWhitespace"]/*' />
        public override bool PreserveWhitespace(XPathNavigator node) {
            node = node.Clone();
            node.MoveToParent();
            return this.processor.Stylesheet.PreserveWhiteSpace(this.processor, node);
        }

        private MethodInfo FindBestMethod(MethodInfo[] methods, bool ignoreCase, bool publicOnly, string name, XPathResultType[] argTypes) {
            int length = methods.Length;
            int free   = 0;
            // restrict search to methods with the same name and requiested protection attribute
            for(int i = 0; i < length; i ++) {
                if(string.Compare(name, methods[i].Name, ignoreCase, CultureInfo.InvariantCulture) == 0) {
                    if(! publicOnly || methods[i].GetBaseDefinition().IsPublic) {
                        methods[free ++] = methods[i];
                    }
                }
            }
            length = free;
            if(length == 0) {
                // this is the only place we returning null in this function
                return null;
            }
            if(argTypes == null) {
                // without arg types we can't do more detailed search
                return methods[0];
            }
            // restrict search by number of parameters
            free = 0;
            for(int i = 0; i < length; i ++) {
                if(methods[i].GetParameters().Length == argTypes.Length) {
                    methods[free ++] = methods[i];
                }
            }
            length = free;
            if(length <= 1) {
                // 0 -- not method found. We have to return non-null and let it fail with corect exception on call. 
                // 1 -- no reason to continue search anyway. 
                return methods[0];
            }
            // restrict search by parameters type
            free = 0;
            for(int i = 0; i < length; i ++) {
                bool match = true;
                ParameterInfo[] parameters = methods[i].GetParameters();
                for(int par = 0; par < parameters.Length; par ++) {
                    XPathResultType required = argTypes[par];
                    if(required == XPathResultType.Any) {
                        continue;                        // Any means we don't know type and can't discriminate by it
                    }
                    XPathResultType actual = GetXPathType(parameters[par].ParameterType);
                    if(
                        actual != required && 
                        actual != XPathResultType.Any   // actual arg is object and we can pass everithing here.
                    ) {
                        match = false;
                        break;
                    }
                }
                if(match) {
                    methods[free ++] = methods[i];
                }
            }
            length = free;
            return methods[0];
        }

        private const BindingFlags bindingFlags = BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static;
        private IXsltContextFunction GetExtentionMethod(string ns, string name, XPathResultType[] argTypes, out object extension) {
            FuncExtension result = null;
            extension = this.processor.GetScriptObject(ns);
            if (extension != null) {
                MethodInfo method = FindBestMethod(extension.GetType().GetMethods(bindingFlags), /*ignoreCase:*/true, /*publicOnly:*/false, name, argTypes);
                if (method != null) {
                    result = new FuncExtension(extension, method, /*permissions*/null);
                }
                return result;
            }

            extension = this.processor.GetExtensionObject(ns);
            if(extension != null) {
                MethodInfo method = FindBestMethod(extension.GetType().GetMethods(bindingFlags), /*ignoreCase:*/false, /*publicOnly:*/true, name, argTypes);
                if (method != null) {
                    result = new FuncExtension(extension, method, this.processor.permissions);
                }
                return result;
            }

            return null;
        }

        public override IXsltContextFunction ResolveFunction(string prefix, string name, XPathResultType[] argTypes) {
            IXsltContextFunction func = null;
            if(prefix == String.Empty) {
                func = s_FunctionTable[name] as IXsltContextFunction;
            }
            else {
                string ns = this.LookupNamespace(prefix);
                if (ns == Keywords.s_MsXsltNamespace && name == f_NodeSet) {
                    func = s_FuncNodeSet;
                }
                else {
                    object     extension;
                    func = GetExtentionMethod(ns, name, argTypes, out extension);
                    if(extension == null) {
                        throw new XsltException(Res.Xslt_ScriptInvalidPrefix, prefix);
                    }
                }
            }
            if (func == null) {
                throw new XsltException(Res.Xslt_UnknownXsltFunction, name);
            }
            if (argTypes.Length < func.Minargs || func.Maxargs < argTypes.Length) {
               throw new XsltException(Res.Xslt_WrongNumberArgs, name, Convert.ToString(argTypes.Length));
            }
            return func;
        }

        ///
        /// Xslt Function Extensions to XPath
        ///
        private Uri ComposeUri(string thisUri, string baseUri) {
            XmlResolver resolver = processor.Resolver;
            Uri uriBase = null; {
                if (baseUri != string.Empty) {
                    uriBase = resolver.ResolveUri(null, baseUri);
                }
            }
            return resolver.ResolveUri(uriBase, thisUri);
        }

        private XPathNavigator GetNavigator(Uri uri) {
            if (uri.ToString() == string.Empty) {
                XPathNavigator nav = this.manager.Navigator.Clone();
                nav.MoveToRoot();
                return nav;
            }
            return processor.GetNavigator(uri);
        }
	
        private XPathNodeIterator Document(object arg0, string baseUri) {
            if (this.processor.permissions != null) {
                this.processor.permissions.PermitOnly();
            }
            XPathNodeIterator it = arg0 as XPathNodeIterator;
            if (it != null) {
                ArrayList list = new ArrayList();
                Hashtable documents = new Hashtable();
                while (it.MoveNext()) {
                    Uri uri = ComposeUri(it.Current.Value, baseUri!=null? baseUri : it.Current.BaseURI);
                    if (! documents.ContainsKey(uri)) {
                        documents.Add(uri, null);
                        list.Add(this.GetNavigator(uri));
                    }
                }
                return new XPathArrayIterator(list);
            }
            else{
                return new XPathSingletonIterator(
                    this.GetNavigator(
                        ComposeUri(arg0.ToString(), baseUri!=null? baseUri : this.manager.Navigator.BaseURI)
                    )
                );
            }
        }
        
        internal void FindKeyMatch(XmlQualifiedName name, String value, ArrayList ResultList, XPathNavigator context) {
            ArrayList      KeyList = this.processor.KeyList;

            XPathNavigator nav     = context.Clone();
            nav.MoveToRoot();
            XPathExpression descendantExpr = this.processor.GetCompiledQuery(Compiler.DescendantKey);
            for (int i=0; i< KeyList.Count; i++) {

                Key key = (Key) KeyList[i];
                if (key.Name != name ) {
                    continue;
                }
                Hashtable keyTable = key.GetKeys(nav);
                XPathExpression useExpr = this.processor.GetCompiledQuery(key.UseKey);
                if (keyTable != null) {
                    if (keyTable.Contains(value)) {
                        ArrayList nodeList = keyTable[value] as ArrayList;
                        for(int j=0; j< nodeList.Count; j++) {                      
                            AddResult(ResultList, nodeList[j] as XPathNavigator);
                        }
                    }
                    else {
                        continue;
                    }
                }
                else {

                    keyTable = new Hashtable();

                    XPathExpression matchExpr = this.processor.GetCompiledQuery(key.MatchKey);

                    XPathNodeIterator sel = nav.Select(descendantExpr);

                    while( sel.MoveNext() ) {
                        EvaluateKey( sel, matchExpr, useExpr, ResultList, value, keyTable);
                        XPathNodeIterator attrsel = sel.Current.Select("attribute::*"); 
                        while ( attrsel.MoveNext() ) {
                            EvaluateKey( attrsel, matchExpr, useExpr, ResultList , value, keyTable);
                        }
                    }
                    key.AddKey(nav,keyTable);
                    KeyList[i] = key;
                }
            }
                
        }

        internal bool KeyMatches(String value, XPathExpression query, XPathNavigator nav, Hashtable keyTable) {
            XPathNodeIterator it = nav.Select(query);
            bool returnValue = false;
            while( it.MoveNext() ) {
                if (keyTable.Contains(it.Current.Value)) {
                    ((ArrayList)keyTable[it.Current.Value]).Add(nav.Clone());
                }
                else {
                    ArrayList list = new ArrayList();
                    list.Add(nav.Clone());
                    keyTable.Add(it.Current.Value, list);
                }                
                if (it.Current.Value == value)
                    returnValue = true;
            }
            return returnValue;
        }

        private void EvaluateKey(XPathNodeIterator sel, XPathExpression matchExpr,
                                 XPathExpression useExpr, ArrayList ResultList, String value, Hashtable keyTable) {
            XPathNavigator nav = sel.Current;
            if ( nav.Matches( matchExpr ) ) {
                if (useExpr.ReturnType != XPathResultType.NodeSet) {
                    String keyvalue = Convert.ToString(nav.Evaluate(useExpr, null));
                    if (keyTable.Contains(keyvalue)) {
                        ((ArrayList)keyTable[keyvalue]).Add(nav.Clone());
                    }
                    else {
                        ArrayList list = new ArrayList();
                        list.Add(nav.Clone());
                        keyTable.Add(keyvalue, list);
                    }
                    if (value == keyvalue) {
                        AddResult( ResultList, nav );
                    }
                }
                else {
                    if (KeyMatches(value, useExpr, nav, keyTable) ) {
                        AddResult( ResultList, nav );
                    }
                }
            }
        }

        private void AddResult(ArrayList ResultList, XPathNavigator nav) {
            int count = ResultList.Count;
            for(int i = 0; i< count; i++ ) {
                XmlNodeOrder docOrder = nav.ComparePosition(((XPathNavigator)ResultList[i] ));
                if (docOrder == XmlNodeOrder.Same){
                    return;
                }
                if (docOrder == XmlNodeOrder.Before) {
                    ResultList.Insert(i, nav.Clone());
                    return;
                }
            }
            ResultList.Add(nav.Clone());
        }
        
        private  void RemoveTrailingComma(StringBuilder builder, int commaindex, int decimalindex, ref int groupingSize) {
            if ( commaindex > 0 && commaindex == (decimalindex - 1) ) {
                builder.Remove(decimalindex - 1, 1);
                groupingSize = 0;
            }
            else {
                if (decimalindex > commaindex)
                    groupingSize =  decimalindex - commaindex - 1;
            }
        }
        
        private int ValidateFormat(ref String format, DecimalFormat formatinfo, bool negative) {
            String pospattern = null;
            char currencySymbol = (char)0x00A4;
            int commaindex = 0;
            bool integer = true, posDecimalSeparator = false;
            bool sawpattern = false, sawzerodigit= false, sawdigit = false, 
            sawdecimalseparator = false, sawunderscore = false, sawstar = false;
            char patternseparator, decimalseparator, groupseparator, percentsymbol;
            if ( formatinfo != null ) {
                patternseparator = formatinfo.patternSeparator;
                percentsymbol = formatinfo.info.PercentSymbol[0];
                decimalseparator = formatinfo.info.NumberDecimalSeparator[0] ;
                groupseparator = formatinfo.info.NumberGroupSeparator[0];
            }
            else {
                percentsymbol = '%';
                patternseparator = ';';
                decimalseparator = '.';
                groupseparator = ',';
            }
            if ( format.Length == 0 ) {
                throw new XsltException(Res.Xslt_InvalidFormat);
            }
            StringBuilder temp = new StringBuilder();
            int groupingSize = 0;
            int length = format.Length;
            int decimalindex = length;
            for (int i= 0; i < length; i++ ) {
                char ch = format[i];
                
                if ( ch ==  formatinfo.digit )  {
                    if (sawzerodigit && integer) {
                        throw new XsltException(Res.Xslt_InvalidFormat1, format);
                    }
                    sawdigit = true;
                    temp.Append('#');
                    continue;
                }
                if (ch ==  formatinfo.zeroDigit ) {
                    if (sawdigit && !integer) {
                        throw new XsltException(Res.Xslt_InvalidFormat2, format);
                    }
                    sawzerodigit = true;
                    temp.Append('0');
                    continue;
                }
                if (ch == patternseparator ) {
                    CheckInteger(sawzerodigit, sawdigit);
                    if (sawpattern) {
                        throw new XsltException(Res.Xslt_InvalidFormat3, format);
                    }
                    sawpattern = true;
                    if (i == 0 || i == length - 1) {
                        throw new XsltException(Res.Xslt_InvalidFormat4, format);
                    }
                    RemoveTrailingComma(temp, commaindex, decimalindex, ref groupingSize);

                    pospattern = temp.ToString();
                    posDecimalSeparator = sawdecimalseparator;
                    temp.Length = 0;
                    decimalindex = length - i - 1;
                    commaindex = 0;
                    sawdigit = sawzerodigit = sawdecimalseparator = 
                    sawstar = sawunderscore = false;
                    integer = true;
                    continue;
                }
                if (ch == decimalseparator ) {
                    if ( sawdecimalseparator ) {
                        throw new XsltException(Res.Xslt_InvalidFormat5, format);
                    }
                    decimalindex = temp.Length;
                    sawdecimalseparator = true;
                    sawdigit = sawzerodigit = integer = false;
                    temp.Append('.');
                    continue;
                }
                if (ch ==  groupseparator ) {
                    commaindex = temp.Length;
                    temp.Append(',');
                    continue;
                }
                if (ch == formatinfo.info.PercentSymbol[0] ) {
                    temp.Append('%');
                    continue;
                }
                if (ch == formatinfo.info.PerMilleSymbol[0] ) {
                    temp.Append((char)0x2030);
                    continue;
                }
                if (ch == '*' ) {
                    if (sawunderscore) {
                        throw new XsltException(Res.Xslt_InvalidFormat6, format);
                    }
                    sawstar = true;
                    continue;
                }
                if (ch == '_' ) {
                    if (sawstar) {
                        throw new XsltException(Res.Xslt_InvalidFormat6, format);
                    }
                    sawunderscore = true;
                    temp.Append(ch);
                    continue;
                }
                
                if ((int) ch < 0x0000 && (int) ch > 0xfffd || ch == currencySymbol) {
                    throw new XsltException(Res.Xslt_InvalidFormat7, format, ch.ToString());
                }
                temp.Append(ch);
            }
            //CheckInteger(sawzerodigit, sawdigit);
            if ( sawpattern ) {
                if (negative) {
                    if (!sawdecimalseparator) {
                        formatinfo.info.NumberDecimalDigits = 0;
                    }
                    RemoveTrailingComma(temp, commaindex, decimalindex, ref groupingSize);
                    if (temp.Length > 0 && temp[0] == '-') {
                        temp.Remove(0,1);
                    }
                    else {
                        formatinfo.info.NegativeSign = String.Empty; 
                    }
                    format = temp.ToString();
                }                
                else {
                    if (!posDecimalSeparator) {
                        formatinfo.info.NumberDecimalDigits = 0;
                    }
                    format = pospattern;
                }
            }
            else {
                RemoveTrailingComma(temp, commaindex, decimalindex, ref groupingSize);
                format = temp.ToString();
                if (!sawdecimalseparator) {
                    formatinfo.info.NumberDecimalDigits = 0;
                }
            }

            return groupingSize;
        }

        private void CheckInteger(bool sawzerodigit, bool sawdigit) {
            if (!sawzerodigit && !sawdigit) {
                throw new XsltException(Res.Xslt_InvalidFormat8);
            }
        }
        
        private String FormatNumber(double value, string formatPattern, String formatName) {
            string ns = string.Empty, local = string.Empty;
            if (formatName != null) {
                string prefix;
                PrefixQName.ParseQualifiedName(formatName, out prefix, out local);
                ns = LookupNamespace(prefix);
            }
            DecimalFormat formatInfo = this.processor.RootAction.GetDecimalFormat(new XmlQualifiedName(local, ns));
            if (formatInfo == null) {
                if (formatName != null) {
                    throw new XsltException(Res.Xslt_NoDecimalFormat, formatName);
                }
                formatInfo = new DecimalFormat(new NumberFormatInfo(), '#', '0', ';'); 
            }

            int[] groupsize = {ValidateFormat(ref formatPattern, formatInfo, value < 0)};
            NumberFormatInfo numberInfo = formatInfo.info;
            numberInfo.NumberGroupSizes = groupsize;
            String result = value.ToString(formatPattern, numberInfo);
            if (formatInfo.zeroDigit != '0') {
                StringBuilder builder = new StringBuilder(result.Length);
                int startingLetter = Convert.ToInt32(formatInfo.zeroDigit) - Convert.ToInt32('0');;
                for(int i = 0; i < result.Length; i++) {
                    if (result[i] >= '0' && result[i] <= '9') {
                        builder.Append((char)(Convert.ToInt32(result[i]) + startingLetter));
                    }
                    else {
                        builder.Append(result[i]);
                    }
                }
                result = builder.ToString();
            }
            return result;
        }
        
        // see http://www.w3.org/TR/xslt#function-element-available
        private bool ElementAvailable(string qname) {
            string name, prefix;
            PrefixQName.ParseQualifiedName(qname, out prefix, out name);
            string ns = this.manager.ResolveXmlNamespace(prefix);
            // msxsl:script - is not an "instruction" so we return false for it.
            if(ns == Keywords.s_XsltNamespace) {
                return (
                    name == Keywords.s_ApplyImports ||
                    name == Keywords.s_ApplyTemplates ||
                    name == Keywords.s_Attribute ||
                    name == Keywords.s_CallTemplate ||
                    name == Keywords.s_Choose ||
                    name == Keywords.s_Comment ||
                    name == Keywords.s_Copy ||
                    name == Keywords.s_CopyOf ||
                    name == Keywords.s_Element ||
                    name == Keywords.s_Fallback ||
                    name == Keywords.s_ForEach ||
                    name == Keywords.s_If ||
                    name == Keywords.s_Message ||
                    name == Keywords.s_Number ||
                    name == Keywords.s_ProcessingInstruction ||
                    name == Keywords.s_Text ||
                    name == Keywords.s_ValueOf ||
                    name == Keywords.s_Variable
                );
            }
            return false;
        }

        // see: http://www.w3.org/TR/xslt#function-function-available
        private bool FunctionAvailable(string qname) {
            string name, prefix;
            PrefixQName.ParseQualifiedName(qname, out prefix, out name);
            string ns = LookupNamespace(prefix);

            if(ns == Keywords.s_MsXsltNamespace) {
                return name == f_NodeSet;
            }
            else if(ns == string.Empty) {
                return (
                    // It'll be better to get this information from XPath
                    name == "last"              ||
                    name == "position"          ||
                    name == "name"              ||
                    name == "namespace-uri"     ||
                    name == "local-name"        ||
                    name == "count"             ||
                    name == "id"                ||
                    name == "string"            ||
                    name == "concat"            ||
                    name == "starts-with"       ||
                    name == "contains"          ||
                    name == "substring-before"  ||
                    name == "substring-after"   ||
                    name == "substring"         ||
                    name == "string-length"     ||
                    name == "normalize-space"   ||
                    name == "translate"         ||
                    name == "boolean"           ||
                    name == "not"               ||
                    name == "true"              ||
                    name == "false"             ||
                    name == "lang"              ||
                    name == "number"            ||
                    name == "sum"               ||
                    name == "floor"             ||
                    name == "ceiling"           ||
                    name == "round"             ||
                    // XSLT functions:
                    (s_FunctionTable[name] != null && name != "unparsed-entity-uri")
                );
            }
            else {
                // Is this script or extention function?
                object extension;
                return GetExtentionMethod(ns, name, /*argTypes*/null, out extension) != null;
            }
        }

        private XPathNodeIterator Current() {
            XPathNavigator nav = this.processor.Current;
            if (nav != null) {
                return new XPathSingletonIterator(nav.Clone());
            }
            return new XPathEmptyIterator();
        }

        private object GenerateId(XPathNavigator node) {
            // requirements for id:
            //  1. must consist of alphanumeric characters only
            //  2. must begin with an alphabetic character
            //  3. same id is generated for the same node
            //  4. ids are unique
            //
            //  id = "XSLT" + name + reverse path to root in terms of the IndexInParent integers from node to root seperated by x's
            if (node.NodeType == XPathNodeType.Namespace) {
                XPathNavigator n = node.Clone();
                String id = "XSLT" + n.Name;
                n.MoveToParent();
                do {
                    id += n.IndexInParent + 'x';
                }
                while(n.MoveToParent());

                return id;   
            }
            else {
                XPathNavigator n = node.Clone();
                String id = "XSLT" + n.Name;
                do {
                    id += n.IndexInParent + 'x';
                }
                while(n.MoveToParent());

                return id;
            }
        }

        private String SystemProperty(string qname) {
            String result = String.Empty;

            string prefix;
            string local;
            PrefixQName.ParseQualifiedName(qname, out prefix, out local);

            // verify the prefix corresponds to the Xslt namespace
            string urn = LookupNamespace(prefix);
            
            if(urn == Keywords.s_XsltNamespace) {
                if(local == "version") {
                    result = "1";
                }
                else if(local == "vendor") {
                    result = "Microsoft";
                }
                else if(local == "vendor-url") {
                    result = "http://www.microsoft.com";
                }
            }
            else {
                if(urn == null && prefix != null ) {
                // if prefix exist it has to be mapped to namespace.
                // Can it be "" here ?
                    throw new XsltException(Res.Xslt_InvalidPrefix, prefix);
                }
                return String.Empty;
            }

            return result;
        }

        public static XPathResultType GetXPathType(Type type) {
            switch(Type.GetTypeCode(type)) {
            case TypeCode.String :
                return XPathResultType.String;
            case TypeCode.Boolean :
                return XPathResultType.Boolean;
            case TypeCode.Object :
                if ( 
                    typeof(XPathNavigator ).IsAssignableFrom(type) ||
                    typeof(IXPathNavigable).IsAssignableFrom(type)
                ) {
                    return XPathResultType.Navigator;
                }
                if (typeof(XPathNodeIterator).IsAssignableFrom(type)) {
                    return XPathResultType.NodeSet;
                }
                // sdub: It be better to check that type is realy object and otherwise return XPathResultType.Error
                return XPathResultType.Any;
            case TypeCode.DateTime :
                return XPathResultType.Error;
            default: /* all numeric types */
                return XPathResultType.Number;
            } 
        }

        // ---------------- Xslt Function Implementations -------------------
        //
        static Hashtable CreateFunctionTable() {
            Hashtable ft = new Hashtable(10); {
                ft["current"            ] = new FuncCurrent          ();
                ft["unparsed-entity-uri"] = new FuncUnEntityUri      ();
                ft["generate-id"        ] = new FuncGenerateId       ();
                ft["system-property"    ] = new FuncSystemProp       ();
                ft["element-available"  ] = new FuncElementAvailable ();
                ft["function-available" ] = new FuncFunctionAvailable();
                ft["document"           ] = new FuncDocument         ();
                ft["key"                ] = new FuncKey              ();
                ft["format-number"      ] = new FuncFormatNumber     ();
            }
            return ft;
        }

        // + IXsltContextFunction
        //   + XsltFunctionImpl             func. name,       min/max args,      return type                args types                                                            
        //       FuncCurrent            "current"              0   0         XPathResultType.NodeSet   { XPathResultType.Error   }                                                
        //       FuncUnEntityUri        "unparsed-entity-uri"  1   1         XPathResultType.String    { XPathResultType.String  }                                                
        //       FuncGenerateId         "generate-id"          0   1         XPathResultType.String    { XPathResultType.NodeSet }                                                
        //       FuncSystemProp         "system-property"      1   1         XPathResultType.String    { XPathResultType.String  }                                                
        //       FuncElementAvailable   "element-available"    1   1         XPathResultType.Boolean   { XPathResultType.String  }                                                
        //       FuncFunctionAvailable  "function-available"   1   1         XPathResultType.Boolean   { XPathResultType.String  }                                                
        //       FuncDocument           "document"             1   2         XPathResultType.NodeSet   { XPathResultType.Any    , XPathResultType.NodeSet }                       
        //       FuncKey                "key"                  2   2         XPathResultType.NodeSet   { XPathResultType.String , XPathResultType.Any     }                       
        //       FuncFormatNumber       "format-number"        2   3         XPathResultType.String    { XPathResultType.Number , XPathResultType.String, XPathResultType.String }
        //       FuncNodeSet            "msxsl:node-set"       1   1         XPathResultType.NodeSet   { XPathResultType.Navigator }                                              
        //       FuncExtension
        //                 
        private abstract class XsltFunctionImpl : IXsltContextFunction {
            private int               minargs;
            private int               maxargs;
            private XPathResultType   returnType;
            private XPathResultType[] argTypes;

            public XsltFunctionImpl () {}
            public XsltFunctionImpl (int minArgs, int maxArgs, XPathResultType returnType, XPathResultType[] argTypes) {
                this.Init(minArgs, maxArgs, returnType, argTypes);
            }
            protected void Init(int minArgs, int maxArgs, XPathResultType returnType, XPathResultType[] argTypes) {
                this.minargs    = minArgs;
                this.maxargs    = maxArgs;
                this.returnType = returnType;
                this.argTypes   = argTypes;
            }

            public int               Minargs       { get { return this.minargs;    } }
            public int               Maxargs       { get { return this.maxargs;    } }
            public XPathResultType   ReturnType    { get { return this.returnType; } }
            public XPathResultType[] ArgTypes      { get { return this.argTypes;   } }
            public abstract object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext);

        // static helper methods:
            public static XPathNodeIterator ToIterator(object argument) {
                XPathNodeIterator it = argument as XPathNodeIterator;
                if(it == null) {
                    throw new XsltException(Res.Xslt_NoNodeSetConversion);
                }
                return it;
            }

            public static XPathNavigator ToNavigator(object argument) {
                XPathNavigator nav = argument as XPathNavigator;
                if(nav == null) {
                    throw new XsltException(Res.Xslt_NoNavigatorConversion);
                }
                return nav;
            }

            private static string IteratorToString(XPathNodeIterator it) {
                Debug.Assert(it != null);
                if(it.MoveNext()) {
                    return it.Current.Value;
                }
                return String.Empty;
            }

            public static string ToString(object argument) {
                XPathNodeIterator it = argument as XPathNodeIterator;
                if(it != null) {
                    return IteratorToString(it);
                }
                else {
                    return argument.ToString();
                }
            }

            public static bool ToBoolean(object argument) {
                XPathNodeIterator it = argument as XPathNodeIterator;
                if(it != null) {
                    return Convert.ToBoolean(IteratorToString(it));
                }
                XPathNavigator nav = argument as XPathNavigator;
                if (nav != null) {
                    return Convert.ToBoolean(nav.ToString());
                }
                return Convert.ToBoolean(argument);
            }

            public static double ToNumber(object argument) {
                XPathNodeIterator it = argument as XPathNodeIterator;
                if (it != null) {
                    return XmlConvert.ToXPathDouble(IteratorToString(it));
                }
                XPathNavigator nav = argument as XPathNavigator;
                if (nav != null) {
                    return XmlConvert.ToXPathDouble(nav.ToString());
                }
                return XmlConvert.ToXPathDouble(argument);
            }

            private static object ToNumeric(object argument, TypeCode typeCode) {
                try {
                    return Convert.ChangeType(ToNumber(argument), typeCode);
                }
                catch {
                    return double.NaN;
                }        
            }

            public static object ConvertToXPathType(object val, XPathResultType xt, TypeCode typeCode) {
                switch(xt) {
                case XPathResultType.String    :
                    // Unfortunetely XPathResultType.String == XPathResultType.Navigator (This is wrong but cant be changed in Everett)
                    // Fortunetely we have typeCode hare so let's discriminate by typeCode
                    if (typeCode == TypeCode.String) {
                        return ToString(val);
                    }
                    else {
                        return ToNavigator(val);
                    }
                case XPathResultType.Number    : return ToNumeric(val, typeCode);
                case XPathResultType.Boolean   : return ToBoolean(val);
                case XPathResultType.NodeSet   : return ToIterator(val);
//                case XPathResultType.Navigator : return ToNavigator(val);
                case XPathResultType.Any       : 
                case XPathResultType.Error     : 
                    return val;
                default :
                    Debug.Assert(false, "unexpected XPath type");
                    return val;
                }
            }
        }

        private class FuncCurrent : XsltFunctionImpl {
            public FuncCurrent() : base(0, 0, XPathResultType.NodeSet, new XPathResultType[] { XPathResultType.Error   }) {}
            public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext) {
                return ((XsltCompileContext)xsltContext).Current();
            }
        }

        private class FuncUnEntityUri : XsltFunctionImpl {
            public FuncUnEntityUri() : base(1, 1, XPathResultType.String , new XPathResultType[] { XPathResultType.String  }) {}
            public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext) {
                throw new XsltException(Res.Xslt_UnsuppFunction, "unparsed-entity-uri");
            }
        } 

        private class FuncGenerateId : XsltFunctionImpl {
            public FuncGenerateId() : base(0, 1, XPathResultType.String , new XPathResultType[] { XPathResultType.NodeSet }) {}
            public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext) {
                if(args.Length > 0) {
                    XPathNodeIterator it = ToIterator(args[0]);
                    if(it.MoveNext()) {
                        return ((XsltCompileContext)xsltContext).GenerateId(it.Current);
                    }
                    else {
                        // if empty nodeset, return empty string, otherwise return generated id
                        return string.Empty;
                    }
                }
                else {
                    return ((XsltCompileContext)xsltContext).GenerateId(docContext);
                }
            }
        } 

        private class FuncSystemProp : XsltFunctionImpl {
            public FuncSystemProp() : base(1, 1, XPathResultType.String , new XPathResultType[] { XPathResultType.String  }) {}
            public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext) {
                return ((XsltCompileContext)xsltContext).SystemProperty(ToString(args[0]));
            }
        } 

        // see http://www.w3.org/TR/xslt#function-element-available
        private class FuncElementAvailable : XsltFunctionImpl {
            public FuncElementAvailable() : base(1, 1, XPathResultType.Boolean, new XPathResultType[] { XPathResultType.String  }) {}
            public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext) {
                return ((XsltCompileContext)xsltContext).ElementAvailable(ToString(args[0]));
            }
        } 

        // see: http://www.w3.org/TR/xslt#function-function-available
        private class FuncFunctionAvailable : XsltFunctionImpl {
            public FuncFunctionAvailable() : base(1, 1, XPathResultType.Boolean, new XPathResultType[] { XPathResultType.String  }) {}
            public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext) {
                return ((XsltCompileContext)xsltContext).FunctionAvailable(ToString(args[0]));
            }
        } 

        private class FuncDocument : XsltFunctionImpl {
            public FuncDocument() : base(1, 2, XPathResultType.NodeSet, new XPathResultType[] { XPathResultType.Any    , XPathResultType.NodeSet}) {}
            public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext) {
                string baseUri = null;
                if (args.Length == 2) {
                    XPathNodeIterator it = ToIterator(args[1]);
                    if (it.MoveNext()){
                        baseUri = it.Current.BaseURI;
                    }
                    else {
                        // http://www.w3.org/1999/11/REC-xslt-19991116-errata (E14):
                        // It is an error if the second argument node-set is empty and the URI reference is relative; the XSLT processor may signal the error; 
                        // if it does not signal an error, it must recover by returning an empty node-set.
                        baseUri = string.Empty; // call to Document will fail if args[0] is reletive.
                    }
                }
                try {
                    return ((XsltCompileContext)xsltContext).Document(args[0], baseUri);
                }
                catch {
                    return new XPathEmptyIterator();
                }
            }
        } 

        private class FuncKey : XsltFunctionImpl {
            public FuncKey() : base(2, 2, XPathResultType.NodeSet, new XPathResultType[] { XPathResultType.String , XPathResultType.Any     }) {}
            public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext) {
                XsltCompileContext xsltCompileContext = (XsltCompileContext) xsltContext;
                ArrayList ResultList = new ArrayList();
                string local, prefix;
                PrefixQName.ParseQualifiedName(ToString(args[0]), out prefix, out local);
                string ns = xsltContext.LookupNamespace(prefix);
                XmlQualifiedName qname = new XmlQualifiedName(local, ns);
                XPathNodeIterator it = args[1] as XPathNodeIterator;
                if (it != null) {
                    while (it.MoveNext()) {
                        xsltCompileContext.FindKeyMatch(qname, it.Current.Value, ResultList, docContext);
                    }
                }
                else {
                    xsltCompileContext.FindKeyMatch(qname, ToString(args[1]), ResultList, docContext);
                }

                return new XPathArrayIterator(ResultList);
            }
        } 

        private class FuncFormatNumber : XsltFunctionImpl {
            public FuncFormatNumber() : base(2, 3, XPathResultType.String , new XPathResultType[] { XPathResultType.Number , XPathResultType.String, XPathResultType.String }) {}
            public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext) {
                return ((XsltCompileContext)xsltContext).FormatNumber(ToNumber(args[0]), ToString(args[1]), args.Length == 3 ?ToString(args[2]):null);
            }
        } 

        private class FuncNodeSet : XsltFunctionImpl {
            public FuncNodeSet() : base(1, 1, XPathResultType.NodeSet, new XPathResultType[] { XPathResultType.Navigator }) {}
            public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext) {
                return new XPathSingletonIterator(ToNavigator(args[0]));
            }
        } 

        private class FuncExtension : XsltFunctionImpl {
            private object            extension;
            private MethodInfo        method;
            private TypeCode[]        typeCodes;
            private PermissionSet     permissions;

            public FuncExtension(object extension, MethodInfo method, PermissionSet permissions) {
                Debug.Assert(extension != null);
                Debug.Assert(method    != null);
                this.extension   = extension;
                this.method      = method;
                this.permissions = permissions;
                XPathResultType returnType = GetXPathType(method.ReturnType);

                ParameterInfo[] parameters = method.GetParameters();
                int minArgs = parameters.Length;
                int maxArgs = parameters.Length;
                this.typeCodes = new TypeCode[parameters.Length];
                XPathResultType[] argTypes = new XPathResultType[parameters.Length];
                bool optionalParams = true; // we allow only last params be optional. Set false on the first non optional.
                for (int i = parameters.Length - 1; 0 <= i; i --) {            // Revers order is essential: counting optional parameters
                    typeCodes[i] = Type.GetTypeCode(parameters[i].ParameterType);
                    argTypes[i] = GetXPathType(parameters[i].ParameterType);
                    if(optionalParams) {
                        if(parameters[i].IsOptional) {
                            minArgs --;
                        }
                        else {
                            optionalParams = false;
                        }
                    }
                }
                base.Init(minArgs, maxArgs, returnType, argTypes);
            }

            public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext) {
                Debug.Assert(args.Length <= this.Minargs, "We cheking this on resolve time");
                for(int i = args.Length -1; 0 <= i; i --) {
                    args[i] = ConvertToXPathType(args[i], this.ArgTypes[i], this.typeCodes[i]);
                }
                if (this.permissions != null) {
                    this.permissions.PermitOnly();
                }
                object result = method.Invoke(extension, args);
                IXPathNavigable navigable = result as IXPathNavigable;
                if(navigable != null) {
                    return navigable.CreateNavigator();
                }
                return result;
            }
        } 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\xpathcomposer.cs ===
//------------------------------------------------------------------------------
// <copyright file="XPathComposer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {

    using System;
    using System.Diagnostics;
    using System.Text;
    using System.Xml;
    using System.Xml.XPath;
    using System.Globalization;
    
    internal class XPathComposer {
        private const string s_Comma                 = ",";
        private const string s_Slash                 = "/";
        private const string s_Caret                 = "^";
        private const string s_At                    = "@";
        private const string s_Dot                   = ".";
        private const string s_LParens               = "(";
        private const string s_RParens               = ")";
        private const string s_LBracket              = "[";
        private const string s_RBracket              = "]";
        private const string s_Colon                 = ":";
        private const string s_Semicolon             = ";";
        private const string s_Star                  = "*";
        private const string s_Plus                  = "+";
        private const string s_Minus                 = "-";
        private const string s_Eq                    = "=";
        private const string s_Neq                   = "!=";
        private const string s_Lt                    = "<";
        private const string s_Le                    = "<=";
        private const string s_Gt                    = ">";
        private const string s_Ge                    = ">=";
        private const string s_Bang                  = "!";
        private const string s_Dollar                = "$";
        private const string s_Apos                  = "'";
        private const string s_Quote                 = "\"";
        private const string s_Union                 = "|";

        private const string s_True                  = "true";
        private const string s_False                 = "false";
        private const string s_Mod                   = " mod ";
        private const string s_Div                   = " div ";
        private const string s_Or                    = " or ";
        private const string s_And                   = " and ";
        private const string s_Negate                = " -";

        private const string s_Ancestor              = "ancestor::";
        private const string s_AncestorOrSelf        = "ancestor-or-self::";
        private const string s_Attribute             = "attribute::";
        private const string s_Child                 = "child::";
        private const string s_Descendant            = "descendant::";
        private const string s_DescendantOrSelf      = "descendant-or-self::";
        private const string s_Following             = "following::";
        private const string s_FollowingSibling      = "following-sibling::";
        private const string s_Namespace             = "namespace::";
        private const string s_Parent                = "parent::";
        private const string s_Preceding             = "preceding::";
        private const string s_PrecedingSibling      = "preceding-sibling::";
        private const string s_Self                  = "self::";

        private const string s_Node                  = "node()";
        private const string s_ProcessingInstruction = "processing-instruction";
        private const string s_Text                  = "text()";
        private const string s_Comment               = "comment()";

        private static readonly string [] s_Functions =
        {
            "last",
            "position",
            "count",
            "localname",
            "namespaceuri",
            "name",
            "string",
            "boolean",
            "number",
            "true",
            "false",
            "not",
            "id",
            "concat",
            "starts-with",
            "contains",
            "substring-before",
            "substring-after",
            "substring",
            "string-length",
            "normalize-space",
            "translate",
            "lang",
            "sum",
            "floor",
            "celing",
            "round",
        };

        private XPathComposer() {
        }

        internal static string ComposeXPath(AstNode node) {
            StringBuilder expr = new StringBuilder();
            ComposeExpression(node, expr);
            return expr.ToString();
        }

        private static void DecodeName(Axis node, StringBuilder expr) {
            string name = node.Name;
            if (name == null || name.Length == 0) {
                expr.Append(s_Star);
            }
            else {
                string prefix = node.Prefix;
                if (prefix != null && prefix.Length > 0) {
                    expr.Append(prefix);
                    expr.Append(s_Colon);
                }
                expr.Append(name);
            }
        }

        private static void DecodeNodeTest(Axis node, StringBuilder expr) {
            switch (node.Type) {
                case XPathNodeType.Element:
                case XPathNodeType.Attribute:
                    DecodeName(node, expr);
                    break;
                case XPathNodeType.Text:
                    expr.Append(s_Text);
                    break;
                case XPathNodeType.ProcessingInstruction:
                    expr.Append(s_ProcessingInstruction);
                    expr.Append(s_LParens);
                    string name = node.Name;
                    if (name != null && name.Length > 0)
                        expr.Append(name);
                    expr.Append(s_RParens);
                    break;
                case XPathNodeType.Comment:
                    expr.Append(s_Comment);
                    break;
                case XPathNodeType.All:
                    expr.Append(s_Node);
                    break;
                default:
                    Debug.Fail("Unexpected node type in axis");
		    break;
            }
        }

        private static void DecodeAxis(Axis node, StringBuilder expr) {
            string axis = String.Empty;

            switch (node.TypeOfAxis) {
                case Axis.AxisType.Ancestor:            axis = s_Ancestor;          break;
                case Axis.AxisType.AncestorOrSelf:      axis = s_AncestorOrSelf;    break;
                case Axis.AxisType.Attribute:           axis = s_Attribute;         break;
                case Axis.AxisType.Child:                                           break;
                case Axis.AxisType.Descendant:          axis = s_Descendant;        break;
                case Axis.AxisType.DescendantOrSelf:    if (node.abbrAxis) {

                                                            return;
                                                        }
                                                        axis = s_DescendantOrSelf;  break;
                case Axis.AxisType.Following:           axis = s_Following;         break;
                case Axis.AxisType.FollowingSibling:    axis = s_FollowingSibling;  break;
                case Axis.AxisType.Namespace:           axis = s_Namespace;         break;
                case Axis.AxisType.Parent:              axis = s_Parent;            break;
                case Axis.AxisType.Preceding:           axis = s_Preceding;         break;
                case Axis.AxisType.PrecedingSibling:    axis = s_PrecedingSibling;  break;
                case Axis.AxisType.Self:                axis = s_Self;              break;
                case Axis.AxisType.None:                                            break;
                default:
                    Debug.Fail("Unexpected Type Of Axis");
		    break;
            }

            expr.Append(axis);
            DecodeNodeTest(node, expr);
        }

        private static void ComposeAxis(Axis node, StringBuilder expr) {
            if (node.Input != null) {
                ComposeExpression(node.Input, expr);
                if (node.Input.TypeOfAst == AstNode.QueryType.Axis) {
                    expr.Append(s_Slash);
                }
            }

            DecodeAxis(node, expr);
        }

        private static void ComposeOperator(Operator node, StringBuilder expr) {
            AstNode op1 = node.Operand1;
            AstNode op2 = node.Operand2;
            string  op  = null;

            switch (node.OperatorType) {
                case Operator.Op.PLUS:      op = s_Plus;        break;
                case Operator.Op.MINUS:     op = s_Minus;       break;
                case Operator.Op.MUL:       op = s_Star;        break;
                case Operator.Op.MOD:       op = s_Mod;         break;
                case Operator.Op.DIV:       op = s_Div;         break;
                case Operator.Op.NEGATE:    op = s_Negate;      op2 = op1;      op1 = null;     break;
                case Operator.Op.LT:        op = s_Lt;          break;
                case Operator.Op.GT:        op = s_Gt;          break;
                case Operator.Op.LE:        op = s_Le;          break;
                case Operator.Op.GE:        op = s_Ge;          break;
                case Operator.Op.EQ:        op = s_Eq;          break;
                case Operator.Op.NE:        op = s_Neq;         break;
                case Operator.Op.OR:        op = s_Or;          break;
                case Operator.Op.AND:       op = s_And;         break;
                case Operator.Op.UNION:     op = s_Union;       break;
                case Operator.Op.INVALID:
                default:
                    Debug.Fail("Unexpected Operator Type value");
		    break;
            }
            ComposeExpression(op1, expr);
            expr.Append(op);
            ComposeExpression(op2, expr);
        }

        private static void ComposeFilter(Filter node, StringBuilder expr) {
            ComposeExpression(node.Input, expr);
            expr.Append(s_LBracket);
            ComposeExpression(node.Condition, expr);
            expr.Append(s_RBracket);
        }

        private static void ComposeOperand(Operand node, StringBuilder expr) {
            switch (node.ReturnType) {
                case XPathResultType.Number:
                    expr.Append(node.OperandValue.ToString());
                    break;
                case XPathResultType.String:
                    expr.Append(s_Apos);
                    expr.Append(node.OperandValue.ToString());
                    expr.Append(s_Apos);
                    break;
                case XPathResultType.Boolean:
                    bool value = (bool) node.OperandValue;
                    expr.Append(s_Apos);
                    expr.Append(value ? s_True : s_False);
                    expr.Append(s_Apos);
                    break;
                default:
                    Debug.Fail("Unexpected operand type");
		    break;
            }
        }

        private static void ComposeVariable(Variable node, StringBuilder expr) {
            expr.Append(s_Dollar);
            expr.Append(node.Prefix);
            expr.Append(":");
            expr.Append(node.Localname);
        }
        
        private static void ComposeFunction(Function function, StringBuilder expr) {
            Debug.Assert((int) function.TypeOfFunction < s_Functions.Length,
                         "(int) function.TypeOfFunction < s_Functions.Length");
            Debug.Assert(function.Name.Length == s_Functions[(int) function.TypeOfFunction].Length + 2,
                         "function.Name.Length == s_Functions[(int) function.TypeOfFunction].Length + 2");
            Debug.Assert(String.Compare(function.Name, 0, s_Functions[(int) function.TypeOfFunction], 0, s_Functions[(int) function.TypeOfFunction].Length, false, CultureInfo.InvariantCulture) == 0,
                         "String.Compare(function.Name, 0, s_Functions[(int) function.TypeOfFunction], 0, s_Functions[(int) function.TypeOfFunction].Length, false, CultureInfo.InvariantCulture) == 0");

            bool firstArg = true;

            expr.Append(s_Functions[(int) function.TypeOfFunction]);
            expr.Append(s_LParens);
            foreach(AstNode arg in function.ArgumentList) {
                if (! firstArg) {
                    expr.Append(s_Comma);
                }
                ComposeExpression(arg, expr);
                firstArg = false;
            }
            expr.Append(s_RParens);
        }

        private static void ComposeGroup(Group node, StringBuilder expr) {
            expr.Append(s_LParens);
            ComposeExpression(node.GroupNode, expr);
            expr.Append(s_RParens);
        }

        private static void ComposeRoot(Root node, StringBuilder expr) {
            expr.Append(s_Slash);
        }

        private static void ComposeExpression(AstNode node, StringBuilder expr) {
            if (node == null)
                return;

            switch (node.TypeOfAst) {
                case AstNode.QueryType.Axis:
                    ComposeAxis((Axis)node, expr);
                    break;
                case AstNode.QueryType.Operator:
                    ComposeOperator((Operator)node, expr);
                    break;
                case AstNode.QueryType.Filter:
                    ComposeFilter((Filter)node, expr);
                    break;
                case AstNode.QueryType.ConstantOperand:
                    ComposeOperand((Operand)node, expr);
                    break;
                case AstNode.QueryType.Variable:
                    ComposeVariable((Variable)node, expr);
                    break;
                case AstNode.QueryType.Function:
                    ComposeFunction((Function)node, expr);
                    break;
                case AstNode.QueryType.Group:
                    ComposeGroup((Group)node, expr);
                    break;
                case AstNode.QueryType.Root:
                    ComposeRoot((Root)node, expr);
                    break;
                case AstNode.QueryType.Error:
                    Debug.Fail("Error node inside AST");
                    break;
                default:
                    Debug.Fail("Unknown type of AST node");
                    break;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\xmltohtmlwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlToHtmlWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
* 
* Copyright (c) 2000 Microsoft Corporation. All rights reserved.
* 
*/

#if DIRECT_WRITER

namespace System.Xml.Xslt {
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Text;
    using System.Diagnostics;
    using System.Globalization;
    
/*
    Html Writer differ from Xml Writer:
    1.  Empty elements
    2.  Doesn't encode content of <script> tag
Not implemented :
    3.  PI are terminated with ">" rather then "?>"
    4.  Diferent encoding of href in <a> and src in <img>
    5.  <textarea READONLY>
    6.  <td width="&{width};">    
*/
    internal class XmlToHtmlWriter : XmlTextWriter {
        // Empty Elements:
        private static string[] emptyTagsArray = new string[] {"area","base","basefont","br","col","frame","hr","img","input","isindex","link","meta","param"};
        private const string s_Script = "script";
        private static Hashtable emptyTags;
        private bool inEmptyTag;
        private bool inScriptTag;
        private bool inAttibute;
        internal XmlToHtmlWriter() {
            if(emptyTags == null) {
                Hashtable table = new Hashtable(emptyTagsArray.Length, new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture)); {
                    foreach(string tagName in emptyTagsArray) {
                        table.Add(tagName, tagName);
                    }
                }
                emptyTags = table;
            }            
        }
        bool OmitEndTag(string ns, string name) {
            return (ns == null || ns.Length == 0) && emptyTags.Contains(name);
        }
        bool ScritpTag(string ns, string name) {
            return (ns == null || ns.Length == 0) && 0 == string.Compare(name, s_Script, /*ignoreCase:*/true, CultureInfo.InvariantCulture);
        }
        public override void WriteStartElement(string prefix, string name, string ns) {
            inScriptTag = ScritpTag(ns, name);
            inEmptyTag  = OmitEndTag(ns, name);
            base.WriteStartElement(prefix, name, ns);
        }
        public override void WriteEndElement() {
            if(! inEmptyTag) {
                base.WriteEndElement();
            }
            else {
                base.WriteNoEndElement();
            }
            inEmptyTag  = false;
            inScriptTag = false;
        }
        public override void WriteString(string text) {
            if(inScriptTag && ! inAttibute) {
                base.WriteRaw(text);
            }
            else {
                base.WriteString(text);
            }
        }

        public override void WriteFullEndElement() {
            WriteEndElement();
        }

        public override void WriteStartAttribute(string prefix, string name, string ns) {
            base.WriteStartAttribute(prefix, name, ns);
            inAttibute = true;
        }

        public override void WriteEndAttribute() {
            inAttibute = false;
            base.WriteEndAttribute();
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\mkinc.inc ===
# no longer needed, definitions merged into makefile.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\place.inc ===
!include $(DNAROOT)\sources.inc

#
# Establish the root of our project tree.
#

XSPBASEDIR=$(DNAROOT)\src\xsp

#
# Old XSP defines
#

_XSPTARGETRETAIL=$(URTTARGET)
_XSPBASERETAIL=$(URTTARGET)

#
# Establish the product - overrides defaults in makefile.def
#

MODMAKEDIR=$(MAKEDIR)QQQZZZ
!if "$(MODMAKEDIR:\redistQQQZZZ=)" != "$(MODMAKEDIR)"
ASPNET_PRODUCT_ID=$(ASPNET_PRODUCT_REDIST)
!undef ALT_PROJECT_TARGET
!else if "$(MODMAKEDIR:\expQQQZZZ=)" != "$(MODMAKEDIR)"
ASPNET_PRODUCT_ID=$(ASPNET_PRODUCT_EXPRESS)
ALT_PROJECT_TARGET=$(ASPNET_PRODUCT)
!else if "$(MODMAKEDIR:\stdQQQZZZ=)" != "$(MODMAKEDIR)"
ASPNET_PRODUCT_ID=$(ASPNET_PRODUCT_STANDARD)
ALT_PROJECT_TARGET=$(ASPNET_PRODUCT)
!else if "$(MODMAKEDIR:\entQQQZZZ=)" != "$(MODMAKEDIR)"
ASPNET_PRODUCT_ID=$(ASPNET_PRODUCT_ENTERPRISE)
ALT_PROJECT_TARGET=$(ASPNET_PRODUCT)
!else
ASPNET_PRODUCT=none
!ERROR ASP.NET not built from a product-specific directory
!endif

!include "aspnet.inc"

#
# Establish the default "includes" path.
#

XSPINCLUDES=$(O);..;$(XSPBASEDIR)\rc\$(ASPNET_PRODUCT)\$(O);$(XSPBASEDIR)\inc;$(XSPBASEDIR)\inc\$(ASPNET_PRODUCT)\$(O);
INCLUDES=$(XSPINCLUDES);$(INCLUDES)

#
# Use Unicode
#

C_DEFINES=$(C_DEFINES) /DUNICODE /D_UNICODE

#
# We run on Windows 2000 and higher only
#
WIN32_WINNT_VERSION=0x0500
WIN32_WIN95_VERSION=0x0500
WIN32_IE_VERSION=0x0500
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\cultures\culturegenerator.cs ===
//------------------------------------------------------------------------------
// <copyright file="CultureGenerator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   CultureGenerator.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System {

    using System;
    using System.IO;
    using System.Globalization;

    public struct CultureNames
    {
        public string CultureName;
        public string NeutralName;
    }

    public class CultureGenerator {
        public static int Main(string[] args) {

            if (args.Length != 1) {
                Console.WriteLine("Usage: CultureGenerater <output_filename>");
                return 0;
            }

            string filename = args[0];
           
            CultureInfo[] cultures = CultureInfo.GetCultures(CultureTypes.AllCultures);
            int length = cultures.Length;
            
            int[] cultureLCIDs = new int[length];
            CultureNames[] cultureNames = new CultureNames[length];
            
            for (int i=0; i<length; i++) {
                CultureInfo c = cultures[i];
                cultureLCIDs[i] = c.LCID;
                cultureNames[i].CultureName = c.Name;

                if (! c.IsNeutralCulture)
                    c = c.Parent;
                
                cultureNames[i].NeutralName = c.Name;
            }

            Array.Sort(cultureLCIDs, cultureNames);
            FileInfo file = new FileInfo(filename);
            FileStream fs = file.Create();
            StreamWriter sw = new StreamWriter(fs);

            // write languange ids
            sw.Write("int knownLangIds[] = {");
            sw.Write(cultureLCIDs[0]);
            for (int i=1; i<length; i++) {
                sw.Write(",\r\n");
                sw.Write(cultureLCIDs[i]);
            }
            sw.Write("};\r\n");
            sw.WriteLine();            

            // write culture names
            sw.Write("WCHAR * cultureNames[] = {L\"");
            sw.Write(cultureNames[0].CultureName);
            for (int i=1; i<length; i++) {
                sw.Write("\",\r\nL\"");
                sw.Write(cultureNames[i].CultureName);
            }
            sw.Write("\"};\r\n");
            sw.WriteLine();

            // write culture neutral names
            sw.Write("WCHAR * cultureNeutralNames[] = {L\"");
            sw.Write(cultureNames[0].NeutralName);
            for (int i=1; i<length; i++) {
                sw.Write("\",\r\nL\"");
                sw.Write(cultureNames[i].NeutralName);
            }
            sw.Write("\"};");

            
            sw.Flush();
            fs.Close();
            return 0;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\cultures\ent\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\cultures\exp\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\cultures\redist\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\cultures\sources.inc ===
!IF 0

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

!include $(DNAROOT)\src\xsp\place.inc

TARGETNAME=CultureGenerator
TARGETTYPE=NOTARGET
TARGETPATH=$(O)
COMPLUSTYPE=EXE

BUILD_COMPLUSTARGET_PASS0=1
NO_BINPLACE=1

!if "$(ASPNET_PRODUCT)" == "redist"
SYNCHRONIZE_BLOCK=1
!endif

COMPONENT_NO_DOC=1

COMPLUSIMPORTS = 

NTTARGETFILE0=$(O)\cultures.h

SOURCES=

CSHARP_SOURCES = ..\*.cs \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\cultures\makefile.inc ===
$(O)\cultures.h : $(O)\$(TARGETNAME).exe
        $(O)\$(TARGETNAME) $(DNAROOT)\src\xsp\inc\$(ASPNET_PRODUCT)\$(O)\cultures.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\cultures\std\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xslt\xsltransform.cs ===
//------------------------------------------------------------------------------
// <copyright file="XslTransform.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Xsl {
    using System;
    using System.Reflection;
    using System.Diagnostics;
    using System.IO;
    using System.Xml;
    using System.Xml.XPath;
    using System.Collections;
    using System.Xml.Xsl.Debugger;
    using System.Security;
    using System.Security.Policy;
    using System.Security.Permissions;

    /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform"]/*' />
    public sealed class XslTransform {
        //
        // XmlResolver
        //
        private XmlResolver _XmlResolver = new XmlUrlResolver();

        //
        // Compiled stylesheet state
        //
        private Stylesheet  _CompiledStylesheet;
        private ArrayList   _QueryStore;
        private RootAction  _RootAction;


        private IXsltDebugger debugger;
    
        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.XslTransform"]/*' />
        public XslTransform() {}

        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.XmlResolver"]/*' />
        [Obsolete("You should pass XmlResolver to Transform() method")]
        public XmlResolver XmlResolver {
            set { _XmlResolver = value; }
        }

        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Load1"]/*' />
        [Obsolete("You should pass evidence to Load() method")]
        public void Load(XmlReader stylesheet) {
            Load(stylesheet, new XmlUrlResolver());
        }
        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Load2"]/*' />
        [Obsolete("You should pass evidence to Load() method")]
        public void Load(XmlReader stylesheet, XmlResolver resolver) {
            Load(new XPathDocument(stylesheet, XmlSpace.Preserve), resolver);
        }

        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Load3"]/*' />
        [Obsolete("You should pass evidence to Load() method")]
        public void Load(IXPathNavigable stylesheet) {
            Load(stylesheet, new XmlUrlResolver());
        }
        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Load10"]/*' />
        [Obsolete("You should pass evidence to Load() method")]
        public void Load(IXPathNavigable stylesheet, XmlResolver resolver) {
            Load(stylesheet.CreateNavigator(), resolver);
        }

        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Load5"]/*' />
        [Obsolete("You should pass evidence to Load() method")]
        public void Load(XPathNavigator stylesheet) {
            Load(stylesheet, new XmlUrlResolver());
        }
        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Load6"]/*' />
        [Obsolete("You should pass evidence to Load() method")]
        public void Load(XPathNavigator stylesheet, XmlResolver resolver) {
            if (resolver == null) {
                resolver = new XmlNullResolver();
            }
            Compile(stylesheet, resolver, /*evidence:*/null);
        }

        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Load"]/*' />
        public void Load(string url) {
            Load(url, new XmlUrlResolver());
        }
        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Load4"]/*' />
        public void Load(string url, XmlResolver resolver) {
            XmlTextReader tr  = new XmlTextReader(url); {
                tr.XmlResolver = resolver;
            }
            Evidence evidence = XmlSecureResolver.CreateEvidenceForUrl(tr.BaseURI); // We should ask BaseURI before we start reading because it's changing with each node
            if (resolver == null) {
                resolver = new XmlNullResolver();
            }
            Compile(Compiler.LoadDocument(tr).CreateNavigator(), resolver, evidence);
        }

        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Load7"]/*' />
        public void Load(IXPathNavigable stylesheet, XmlResolver resolver, Evidence evidence) {
            Load(stylesheet.CreateNavigator(), resolver, evidence);
        }
        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Load8"]/*' />
        public void Load(XmlReader stylesheet, XmlResolver resolver, Evidence evidence) {
            Load(new XPathDocument(stylesheet, XmlSpace.Preserve), resolver, evidence);
        }
        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Load9"]/*' />
        public void Load(XPathNavigator stylesheet, XmlResolver resolver, Evidence evidence) {
            if (resolver == null) {
                resolver = new XmlNullResolver();
            }
            if (evidence == null) {
                evidence = new Evidence();
            }
            else {
                new SecurityPermission(SecurityPermissionFlag.ControlEvidence).Demand();
            }
            Compile(stylesheet, resolver, evidence);
        }
        
        // ------------------------------------ Transform() ------------------------------------ //

		/// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Transform1"]/*' />
        public XmlReader Transform(XPathNavigator input, XsltArgumentList args, XmlResolver resolver) {
            Processor    processor = new Processor(this, input, args, resolver);
            return processor.Reader;
        }

        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Transform2"]/*' />
        [Obsolete("You should pass XmlResolver to Transform() method")]
        public XmlReader Transform(XPathNavigator input, XsltArgumentList args) {
            return Transform(input, args, _XmlResolver);
        }

        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Transform3"]/*' />
        public void Transform(XPathNavigator input, XsltArgumentList args, XmlWriter output, XmlResolver resolver) {
            Processor    processor = new Processor(this, input, args, resolver, output);
            processor.Execute();        
        }

        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Transform4"]/*' />
        [Obsolete("You should pass XmlResolver to Transform() method")]
        public void Transform(XPathNavigator input, XsltArgumentList args, XmlWriter output) {
            Transform(input, args, output, _XmlResolver);
        }
        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Transform5"]/*' />
        public void Transform(XPathNavigator input, XsltArgumentList args, Stream output, XmlResolver resolver) {
            Processor    processor = new Processor(this, input, args, resolver, output);
            processor.Execute();        
        }

        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Transform6"]/*' />
        [Obsolete("You should pass XmlResolver to Transform() method")]
        public void Transform(XPathNavigator input, XsltArgumentList args, Stream output) {
            Transform(input, args, output, _XmlResolver);
        }

        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Transform7"]/*' />
        public void Transform(XPathNavigator input, XsltArgumentList args, TextWriter output, XmlResolver resolver) {
            Processor    processor = new Processor(this, input, args, resolver, output);
            processor.Execute();        
        }

        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Transform8"]/*' />
        [Obsolete("You should pass XmlResolver to Transform() method")]
        public void Transform(XPathNavigator input, XsltArgumentList args, TextWriter output) {
            Processor    processor = new Processor(this, input, args, _XmlResolver, output);
            processor.Execute();        
        }

        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Transform9"]/*' />
        public XmlReader Transform(IXPathNavigable input, XsltArgumentList args, XmlResolver resolver) {
            return Transform( input.CreateNavigator(), args, resolver);
        }

        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Transform10"]/*' />
        [Obsolete("You should pass XmlResolver to Transform() method")]
        public XmlReader Transform(IXPathNavigable input, XsltArgumentList args) {
            return Transform( input.CreateNavigator(), args, _XmlResolver);
        }
        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Transform11"]/*' />
        public void Transform(IXPathNavigable input, XsltArgumentList args, TextWriter output, XmlResolver resolver) {
            Transform( input.CreateNavigator(), args, output, resolver);
        }

        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Transform12"]/*' />
        [Obsolete("You should pass XmlResolver to Transform() method")]
        public void Transform(IXPathNavigable input, XsltArgumentList args, TextWriter output) {
            Transform( input.CreateNavigator(), args, output, _XmlResolver);
        }

        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Transform13"]/*' />
        public void Transform(IXPathNavigable input, XsltArgumentList args, Stream output, XmlResolver resolver) {
            Transform( input.CreateNavigator(), args, output, resolver);
        }
 
        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Transform14"]/*' />
        [Obsolete("You should pass XmlResolver to Transform() method")]
        public void Transform(IXPathNavigable input, XsltArgumentList args, Stream output) {
            Transform( input.CreateNavigator(), args, output, _XmlResolver);
        }
 
        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Transform15"]/*' />
        public void Transform(IXPathNavigable input, XsltArgumentList args, XmlWriter output, XmlResolver resolver) {
            Transform( input.CreateNavigator(), args, output, resolver);
        }

        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Transform16"]/*' />
        [Obsolete("You should pass XmlResolver to Transform() method")]
        public void Transform(IXPathNavigable input, XsltArgumentList args, XmlWriter output) {
            Transform( input.CreateNavigator(), args, output, _XmlResolver);
        }

        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Transform18"]/*' />
        public void Transform(String inputfile, String outputfile, XmlResolver resolver) { 
            FileStream fs = null;
            try {
                // We should read doc before creating output file in case they are the same
                XPathDocument doc = new XPathDocument(inputfile); 
                fs = new FileStream(outputfile, FileMode.Create, FileAccess.ReadWrite);
                Transform(doc, /*args:*/null, fs, resolver);
            }
            finally {
                if (fs != null) {
                    fs.Close();
                }
            }
	}

        /// <include file='doc\XslTransform.uex' path='docs/doc[@for="XslTransform.Transform17"]/*' />
        [Obsolete("You should pass XmlResolver to Transform() method")]
        public void Transform(String inputfile, String outputfile) { 
            Transform(inputfile, outputfile, _XmlResolver);
        }                

        // Implementation

        private void StoreCompiledStylesheet(Stylesheet compiledStylesheet, ArrayList queryStore, RootAction rootAction) {
            Debug.Assert(queryStore != null);
            Debug.Assert(compiledStylesheet != null);
            Debug.Assert(rootAction != null);

            //
            // Set the new state atomically
            //

           // lock(this) {
                _CompiledStylesheet = compiledStylesheet;
                _QueryStore         = queryStore;
                _RootAction         = rootAction;
            //    }
        }

        internal void LoadCompiledStylesheet(out Stylesheet compiledStylesheet, out XPathExpression[] querylist, out ArrayList queryStore, out RootAction rootAction, XPathNavigator input) {
            //
            // Extract the state atomically
            //
            if (_CompiledStylesheet == null || _QueryStore == null || _RootAction == null) {
                throw new XsltException(Res.Xslt_NoStylesheetLoaded);
            }

            compiledStylesheet  = _CompiledStylesheet;
            queryStore          = _QueryStore;
            rootAction          = _RootAction;
            int queryCount      = _QueryStore.Count;
            querylist           = new XPathExpression[queryCount]; {
                bool canClone = input is DocumentXPathNavigator || input is XPathDocumentNavigator;
                for(int i = 0; i < queryCount; i ++) {
                    XPathExpression query = ((TheQuery)_QueryStore[i]).CompiledQuery;
                    if (canClone) {
                        querylist[i] = query.Clone();
                    }
                    else {
                        bool hasPrefix;
                        IQuery ast = new QueryBuilder().Build(query.Expression, out hasPrefix);
                        querylist[i] = new CompiledXpathExpr(ast, query.Expression, hasPrefix);
                    }
                }
            }
        }

        private void Compile(XPathNavigator stylesheet, XmlResolver resolver, Evidence evidence) {
            Debug.Assert(stylesheet != null);
            Debug.Assert(resolver   != null);
//            Debug.Assert(evidence   != null); - default evidence is null now

            Compiler  compiler = (Debugger == null) ? new Compiler() : new DbgCompiler(this.Debugger);
            NavigatorInput input    = new NavigatorInput(stylesheet);
            compiler.Compile(input, resolver, evidence);
            StoreCompiledStylesheet(compiler.CompiledStylesheet, compiler.QueryStore, compiler.RootAction);
        }

        internal IXsltDebugger Debugger {
            get {return this.debugger;}
        }

#if false
        internal XslTransform(IXsltDebugger debugger) {
            this.debugger = debugger;
        }
#endif

        internal XslTransform(object debugger) {
            if (debugger != null) {
                this.debugger = new DebuggerAddapter(debugger);
            }
        }

        private class DebuggerAddapter : IXsltDebugger {
            private object unknownDebugger;
            private MethodInfo getBltIn;
            private MethodInfo onCompile;
            private MethodInfo onExecute;
            public DebuggerAddapter(object unknownDebugger) {
                this.unknownDebugger = unknownDebugger;
                BindingFlags flags = BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static;
                Type unknownType = unknownDebugger.GetType();
                getBltIn  = unknownType.GetMethod("GetBuiltInTemplatesUri", flags);
                onCompile = unknownType.GetMethod("OnInstructionCompile"  , flags);
                onExecute = unknownType.GetMethod("OnInstructionExecute"  , flags);
            }
            // ------------------ IXsltDebugger ---------------
            public string GetBuiltInTemplatesUri() {
                if (getBltIn == null) {
                    return null;
                }
                return (string) getBltIn.Invoke(unknownDebugger, new object[] {});
            }
            public void OnInstructionCompile(XPathNavigator styleSheetNavigator) {
                if (onCompile != null) {
                    onCompile.Invoke(unknownDebugger, new object[] { styleSheetNavigator });
                }
            }
            public void OnInstructionExecute(IXsltProcessor xsltProcessor) {
                if (onExecute != null) {
                    onExecute.Invoke(unknownDebugger, new object[] { xsltProcessor });
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\filtercache.cxx ===
/**
 * AuthFilter Main module:
 * DllMain, 
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

#include "precomp.h"
#include "dbg.h"
#include "util.h"
#include "nisapi.h"
#include "filter.h"
#include "dirmoncompletion.h"
#include "iadmw.h"
#include "iiscnfg.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#define MAX_FIXED_DIR_LENGTH        40
#define CACHE_SIZE                  64   // Power of 2
#define CACHE_MASK                  0x3F // CACHE_SIZE - 1
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Cached node
class CCacheNode : public DirMonCompletionFromFilter
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    char *                      szDir;
    char                        szDirFixed[MAX_FIXED_DIR_LENGTH + 4];

    char *                      szMetaPath;
    char                        szMetaPathFixed[MAX_FIXED_DIR_LENGTH + 4];

    DWORD                       eValue;
    CCacheNode *                pNext;

protected:
    virtual void OnFileChanged  ();
};

/////////////////////////////////////////////////////////////////////////////
struct CCacheHashNode
{
    CCacheHashNode() : lAppendLock("CCacheHashNode") {
    }
    NO_COPY(CCacheHashNode); // see util.h
    
    CCacheNode *       pHead;
    CReadWriteSpinLock lAppendLock;
};

/////////////////////////////////////////////////////////////////////////////

class CMetabaseChangeSink : public IMSAdminBaseSink
{
public:
    CMetabaseChangeSink              () : m_lRefCount(0) {}

    STDMETHOD    (QueryInterface   ) (REFIID, void ** );
    STDMETHOD_   (ULONG, AddRef    ) ();
    STDMETHOD_   (ULONG, Release   ) ();
    STDMETHOD    (SinkNotify       ) (DWORD , MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[]);
    STDMETHOD    (ShutdownNotify   ) (void  );

private:
    long  m_lRefCount;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Globals
CCacheHashNode      g_hashTable[CACHE_SIZE];
LONG                g_lCreatingCache = 0;
LONG                g_lCacheInitialized = 0;
IConnectionPoint *  g_pConnPt           = NULL;
IMSAdminBase     *  g_pcAdmCom          = NULL;
DWORD               g_dwCookie          = 0;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
void 
__stdcall
OnAppConfigFileChange(int iAction, WCHAR * pFilename);

void
InitializeMetabaseChangeNotifications();

void
CleanupMetabaseChangeNotifications();

/////////////////////////////////////////////////////////////////////////////
int
ComputeHash(LPCSTR szString)
{
    DWORD iLen   = strlen(szString);
    DWORD iTotal = 0;
    for(DWORD iter=0; iter<iLen; iter++)
    {
        DWORD iVal = szString[iter];
        if (iVal > 'a')
            iVal -= 'a';
        iTotal += iVal;
    }

    return int(iTotal & CACHE_MASK);
}

/////////////////////////////////////////////////////////////////////////////

void
InitializeFilterCache()
{    
    if (InterlockedIncrement(&g_lCreatingCache) == 1)
    {
        ZeroMemory(g_hashTable, sizeof(g_hashTable));
        InitializeMetabaseChangeNotifications();

        g_lCacheInitialized = 1;
    }
    else
    {
        while(g_lCacheInitialized == 0)
            SwitchToThread();
    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOL
CheckCacheForFilterSettings
    (LPCSTR                szDir, 
     EBasicAuthSetting *   pSetting)
{
    CCacheNode * pNode;
    BOOL         fRet  = FALSE;

    ////////////////////////////////////////////////////////////
    // Step 1: Compute the hash
    int    iHash = ComputeHash(szDir);

    ////////////////////////////////////////////////////////////
    // Step 2: Make sure that the cache is initialized
    if (g_lCacheInitialized == 0)
        InitializeFilterCache();

    ////////////////////////////////////////////////////////////
    // Step 3: See if this entry is present
    for(pNode = g_hashTable[iHash].pHead; pNode != NULL; pNode = pNode->pNext)
    {
        if (strcmp(pNode->szDir, szDir) == 0)
        { 
            // Copy the data
            (*pSetting) = (EBasicAuthSetting) pNode->eValue;
            fRet = TRUE;
            break;
        }
    }
    return fRet;
}

/////////////////////////////////////////////////////////////////////////////

void
AddFilterSettingsToCache
    ( LPCSTR              szDir, 
      LPCSTR              szMetaPath,
      EBasicAuthSetting   eSetting)
{
    if (szDir == NULL)
        return;

    CCacheNode *    pNewNode = NULL;
    int             iLen  = strlen(szDir);
    HRESULT         hr    = S_OK;
    int             iHash;

    ////////////////////////////////////////////////////////////
    // Step 1: Alloc space for the node
    pNewNode = new CCacheNode;
    ON_OOM_EXIT(pNewNode);

    ////////////////////////////////////////////////////////////
    // Step 2: Alloc extra space for the szDir if it's too long
    if (iLen > MAX_FIXED_DIR_LENGTH)
    {
        pNewNode->szDir = (char *) MemAllocClear(iLen + 1);
        ON_OOM_EXIT(pNewNode->szDir);
    }
    else
    {   // szDir is not too long 
        pNewNode->szDir = pNewNode->szDirFixed;
    }

    ////////////////////////////////////////////////////////////
    // Step 2b: Alloc extra space for the szMetaPath
    if (iLen > MAX_FIXED_DIR_LENGTH)
    {
        pNewNode->szMetaPath = (char *) MemAllocClear(iLen + 1);
        ON_OOM_EXIT(pNewNode->szMetaPath);
    }
    else
    {   // szMetaPath is not too long 
        pNewNode->szMetaPath = pNewNode->szMetaPathFixed;
    }

    ////////////////////////////////////////////////////////////
    // Step 3: Set the values in this node
    pNewNode->eValue = eSetting;
    strcpy(pNewNode->szDir, szDir);
    strcpy(pNewNode->szMetaPath, szMetaPath);

    ////////////////////////////////////////////////////////////
    // Step 4: Add the new node to the end of the hash bucket
    iHash = ComputeHash(szDir);
    g_hashTable[iHash].lAppendLock.AcquireWriterLock();

    if (g_hashTable[iHash].pHead == NULL)
    {
        g_hashTable[iHash].pHead = pNewNode;
    }
    else
    {
        CCacheNode * pPrev = g_hashTable[iHash].pHead;        
        CCacheNode * pNode = NULL;
        for(pNode = g_hashTable[iHash].pHead; pNode != NULL; pNode = pNode->pNext)
        {
            pPrev = pNode;
            if (strcmp(pNode->szDir, szDir) == 0)
            {   // Already exists
                pNode->eValue = eSetting;
                delete pNewNode;
                pNewNode = NULL;
                break;
            }
        }
        
        if (pNode==NULL)            
        { // Not Found
            pPrev->pNext = pNewNode;
        }
    }

    g_hashTable[iHash].lAppendLock.ReleaseWriterLock();

    if (pNewNode != NULL)
        pNewNode->InitFromFilter(pNewNode->szDir, SZ_WEB_CONFIG_FILE);

 Cleanup:
    if (hr != S_OK && pNewNode != NULL)
    {
        if (pNewNode->szDir != NULL && pNewNode->szDir != pNewNode->szDirFixed)
            MemFree(pNewNode->szDir);
        if (pNewNode->szMetaPath != NULL && pNewNode->szMetaPath != pNewNode->szMetaPathFixed)
            MemFree(pNewNode->szMetaPath);
        delete pNewNode;
    }
}

/////////////////////////////////////////////////////////////////////////////
void
DestroyFilterCache ()
{
    for(int iHash=0; iHash<CACHE_SIZE; iHash++)
    {
        while(g_hashTable[iHash].pHead != NULL)
        {
            CCacheNode * pNextNode = g_hashTable[iHash].pHead->pNext;
            g_hashTable[iHash].pHead->Close();
            g_hashTable[iHash].pHead = pNextNode;
        }
    }

    CleanupMetabaseChangeNotifications();
}

/////////////////////////////////////////////////////////////////////////////

void
CCacheNode::OnFileChanged()
{
    BOOL fExists;
    BOOL fValue;
    char szFile[512];
    char szNotParsed[100];

    szNotParsed[0] = NULL;
    strncpy(szFile, szDir, 500);
    szFile[500] = NULL;
    strcat(szFile, SZ_WEB_CONFIG_FILE);

    fExists = GetConfigurationFromNativeCode(szFile, 
                                             SZ_MY_CONFIG_TAG, 
                                             g_szProperties, 
                                             (DWORD *) &fValue, 
                                             1,
                                             NULL, NULL, 0,
                                             szNotParsed,
                                             100);

    if (fExists)
        eValue |= EBasicAuthSetting_Exists;
    else
        eValue &= (EBasicAuthSetting_Exists ^ 0xffffffff);

    if (fValue)
        eValue |= EBasicAuthSetting_Enabled;
    else
        eValue &= (EBasicAuthSetting_Enabled ^ 0xffffffff);

    if (szNotParsed[0] != NULL)
        eValue |= EBasicAuthSetting_ParseError;
    else
        eValue &= (EBasicAuthSetting_ParseError ^ 0xffffffff);

}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void
InitializeMetabaseChangeNotifications()
{
    HRESULT                      hr;
    IUnknown                   * pSink      = NULL;
    IConnectionPointContainer  * pContainer = NULL;

    g_pConnPt    = NULL;
    g_dwCookie   = 0;
    g_pcAdmCom   = NULL;

    hr = CoCreateInstance(GETAdminBaseCLSID(TRUE), 
                          NULL, 
                          CLSCTX_ALL, 
                          IID_IMSAdminBase, 
                          (void **) &g_pcAdmCom);


    ON_ERROR_EXIT();
	hr = g_pcAdmCom->QueryInterface(
            IID_IConnectionPointContainer,
            (PVOID *)&pContainer);

    ON_ERROR_EXIT();

    hr = pContainer->FindConnectionPoint(IID_IMSAdminBaseSink, &g_pConnPt);
    ON_ERROR_EXIT();

    pSink = new CMetabaseChangeSink();
    ON_OOM_EXIT(pSink);

    hr = g_pConnPt->Advise(pSink, &g_dwCookie);
    ON_ERROR_EXIT();

 Cleanup:
    if (pContainer != NULL)
        pContainer->Release();
    if (FAILED(hr) && pSink != NULL)
        delete pSink;
}

/////////////////////////////////////////////////////////////////////////////

void
CleanupMetabaseChangeNotifications()
{
    if (g_dwCookie == 0 || g_pConnPt == NULL)
        return;

    DWORD dwCookie = g_dwCookie;
    g_dwCookie = 0;

    g_pConnPt->Unadvise(dwCookie);
    g_pConnPt->Release();
    g_pConnPt = NULL;
    if (g_pcAdmCom != NULL)
        g_pcAdmCom->Release();
    g_pcAdmCom = NULL;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CMetabaseChangeSink::QueryInterface(REFIID iid, void **ppvObj)
{
    if (iid == IID_IUnknown || iid == __uuidof(IMSAdminBaseSink))
    {
        *ppvObj = this;
        AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////

ULONG
CMetabaseChangeSink::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

/////////////////////////////////////////////////////////////////////////////

ULONG
CMetabaseChangeSink::Release()
{
    long lRet = InterlockedDecrement(&m_lRefCount);
    if (lRet == 0)
        delete this;
    return lRet;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT 
CMetabaseChangeSink::SinkNotify(
        DWORD                       dwMDNumElements,
        MD_CHANGE_OBJECT __RPC_FAR  pcoChangeList[])
{
    if (dwMDNumElements > 0 && pcoChangeList == NULL)
        return S_OK;

    for (DWORD iter = 0; iter < dwMDNumElements; iter++)
    {
        BOOL   fAnonChange    = FALSE;
        BOOL   fScriptChange  = FALSE;

        for(DWORD inner=0; inner<pcoChangeList[iter].dwMDNumDataIDs; inner++)
        {
            if (pcoChangeList[iter].pdwMDDataIDs[inner] == MD_AUTHORIZATION)
                fAnonChange = TRUE;

            if (pcoChangeList[iter].pdwMDDataIDs[inner] == MD_SCRIPT_MAPS)
                fScriptChange = TRUE;
        }

        if (fAnonChange || fScriptChange)
        {
            char szMetaPath[512];
            szMetaPath[0] = NULL;

            WideCharToMultiByte(CP_ACP, 0, pcoChangeList[iter].pszMDPath, -1,
                                szMetaPath, sizeof(szMetaPath) - 2, NULL, NULL);

            DWORD iLen = strlen(szMetaPath);

            if (iLen < 2)
                return S_OK;

            for(DWORD iHash=0; iHash<CACHE_SIZE; iHash++)
            {
                for(CCacheNode * pNode=g_hashTable[iHash].pHead; pNode!=NULL; pNode = pNode->pNext)
                {
                    DWORD  iLenThis = strlen(pNode->szMetaPath);
                    BOOL   fMatch   = FALSE;

                    if (pNode->szMetaPath[iLenThis-1] != '/' && szMetaPath[iLen-1] == '/')
                    {
                        szMetaPath[iLen-1] = NULL;
                        iLen--;
                    }
                    else
                    {
                        if (pNode->szMetaPath[iLenThis-1] == '/' && szMetaPath[iLen-1] != '/')
                        {
                            szMetaPath[iLen] = '/';
                            szMetaPath[iLen+1] = NULL;
                            iLen++;
                        }
                    }

                    if (iLenThis < iLen)
                        continue;

                    if (iLenThis == iLen && _strcmpi(pNode->szMetaPath, szMetaPath) == 0)
                        fMatch = TRUE;

                    if (fMatch == FALSE)
                    {
                        char szMDPathNode[512];
                        strncpy(szMDPathNode, pNode->szMetaPath, iLen);
                        szMDPathNode[iLen] = NULL;

                        if (_strcmpi(szMDPathNode, szMetaPath) == 0)
                            fMatch = TRUE;
                    }

                    if (fMatch == TRUE)
                    {
                        DWORD eVal = GetMetabaseSettings(NULL, pNode->szMetaPath, iLenThis + 1);

                        if (eVal & EBasicAuthSetting_StarMapped)
                            pNode->eValue |= EBasicAuthSetting_StarMapped;
                        else
                            pNode->eValue &= (EBasicAuthSetting_StarMapped ^ 0xffffffff);

                        if (eVal & EBasicAuthSetting_AnonSetting)
                            pNode->eValue |= EBasicAuthSetting_AnonSetting;
                        else
                            pNode->eValue &= (EBasicAuthSetting_AnonSetting ^ 0xffffffff);                        
                    }
                }
            }
        }
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE
CMetabaseChangeSink::ShutdownNotify(void)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\authfilt.cxx ===
/**
 * AuthFilter Main module:
 * DllMain, 
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

#include "precomp.h"
#include "httpfilt.h"
#include "filter.h"
#include "dbg.h"
#include "util.h"
#include "nisapi.h"
#include "iiscnfg.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Globals
LPCSTR              g_szProperties[1]   =  {"applicationEnableAuthentication"};

/////////////////////////////////////////////////////////////////////////////
// Forward decl for functions

BOOL
IsMapped(LPCWSTR szPath);

BOOL
IsAnonymousOn(LPCWSTR szPath);

BOOL
GetApplicationDir 
    (PHTTP_FILTER_CONTEXT   pfc, 
     char *                 szBuffer, 
     int                    iBufSize);

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Exported function: HttpFilterProc: Called by IIS

DWORD 
AuthenticationFilterProc(
        PHTTP_FILTER_CONTEXT   pfc,  
        LPVOID                 pvNotification,
        BOOL                   fEnableAuth,
        BOOL                   fParseError)
{
    char       szFile[512];
    char       szAppDir[300];
    DWORD      eValue  = 0;

    ////////////////////////////////////////////////////////////
    // Step 1: Get the application physical path for this request 
    if ( GetApplicationDir(pfc, szAppDir, sizeof(szAppDir)) == TRUE)
    {
        ////////////////////////////////////////////////////////
        // Step 2: Check the cache to see if settings for this 
        //         application are present
        if ( CheckCacheForFilterSettings(szAppDir, (EBasicAuthSetting *) &eValue) == FALSE)
        {   // Not Present in Cache

            BOOL    fBasicAuth           = FALSE;
            BOOL    fExists              = FALSE;                        
            char    szNotParsed [100]    = "";
            char    szMetaPath  [1024]   = "";


            ////////////////////////////////////////////////////
            // Step 3: Parse the config file for the config settings
            strcpy(szFile, szAppDir);
            strcat(szFile, SZ_WEB_CONFIG_FILE);
            fExists = GetConfigurationFromNativeCode(szFile, 
                                                     SZ_MY_CONFIG_TAG, 
                                                     g_szProperties, 
                                                     (DWORD *) &fBasicAuth, 
                                                     1,
                                                     NULL, NULL, 0,
                                                     szNotParsed,
                                                     sizeof(szNotParsed));
            if (fExists)
                eValue = EBasicAuthSetting_Exists;

            if (fExists && fBasicAuth)
                eValue |= EBasicAuthSetting_Enabled;            

            eValue |= GetMetabaseSettings(pfc, szMetaPath, sizeof(szMetaPath));

            if (szNotParsed[0] != NULL)
                eValue |= EBasicAuthSetting_ParseError;

            ////////////////////////////////////////////////////
            // Step 5: Add the config settings to our cache            
            AddFilterSettingsToCache(szAppDir, szMetaPath, (EBasicAuthSetting) eValue);
        }
    }

    ////////////////////////////////////////////////////////////
    // Step 6: Munge request if needed
    if (eValue & EBasicAuthSetting_Exists)
        fEnableAuth = (eValue & EBasicAuthSetting_Enabled);
    
    if (fParseError)
        eValue |= EBasicAuthSetting_ParseError;

    if (fEnableAuth)
    {
        if ((eValue & EBasicAuthSetting_StarMapped) && !(eValue & EBasicAuthSetting_ParseError) && 
            (eValue & EBasicAuthSetting_AnonSetting) )
        {
            PHTTP_FILTER_AUTHENT   pFilt   = (PHTTP_FILTER_AUTHENT) pvNotification;
            if (pFilt->pszUser != NULL && pFilt->cbUserBuff > 0)
                pFilt->pszUser[0] = NULL;        
        }
        else
        {
            (*pfc->ServerSupportFunction)(
                    pfc,
                    SF_REQ_SEND_RESPONSE_HEADER,
                    "500 Internal Server Error",
                    0,
                    0);

            static char szError1 [] = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\"> <HTML><HEAD> <META content=\"text/html; charset=windows-1252\" http-equiv=Content-Type> <STYLE>H1 { 	COLOR: red; FONT-FAMILY: Arial, Helvetica, Geneva, SunSans-Regular, sans-serif; FONT-SIZE: 26pt; FONT-WEIGHT: bold } H2 { 	COLOR: black; FONT-FAMILY: Arial, Helvetica, Geneva, SunSans-Regular, sans-serif; FONT-SIZE: 18pt; FONT-WEIGHT: bold } </STYLE> <META content=\"MSHTML 5.00.2919.3800\" name=GENERATOR></HEAD> <BODY bgColor=white> <TABLE width=\"100%\"> <H1>" PRODUCT_NAME " Error <HR width=\"100%\"> </H1> <H2><I>Server Configuration Error</I></H2><FONT face=\"Arial, Helvetica, Geneva, SunSans-Regular, sans-serif \"><B>Description: </B>This " PRODUCT_NAME " application is configured to use the IIS Filter authentication mechanism. A prerequisite for using this mechanism is to script map \"*\"  of this application root to " ISAPI_MODULE_FULL_NAME " , so that all requests are handled by " PRODUCT_NAME ". Since this web application's root has not been script mapped to " ISAPI_MODULE_FULL_NAME ", this may lead to security breaches. To avoid security breaches, all requests for this application will be denied till this situation is corrected.<BR><BR></FONT></TABLE></BODY></HTML>";

            static char szError2 [] = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\"> <HTML><HEAD> <META content=\"text/html; charset=windows-1252\" http-equiv=Content-Type> <STYLE>H1 { 	COLOR: red; FONT-FAMILY: Arial, Helvetica, Geneva, SunSans-Regular, sans-serif; FONT-SIZE: 26pt; FONT-WEIGHT: bold } H2 { 	COLOR: black; FONT-FAMILY: Arial, Helvetica, Geneva, SunSans-Regular, sans-serif; FONT-SIZE: 18pt; FONT-WEIGHT: bold } </STYLE> <META content=\"MSHTML 5.00.2919.3800\" name=GENERATOR></HEAD> <BODY bgColor=white> <TABLE width=\"100%\"> <H1>" PRODUCT_NAME " Error <HR width=\"100%\"> </H1> <H2><I>Server Configuration Error</I></H2><FONT face=\"Arial, Helvetica, Geneva, SunSans-Regular, sans-serif \"><B>Description: </B> The \"iisFilter\" section in the configuration file was not parsed correctly. All requests for this application will be denied till this situation is corrected.<BR><BR></FONT></TABLE></BODY></HTML>";

            static char szError3 [] = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\"> <HTML><HEAD> <META content=\"text/html; charset=windows-1252\" http-equiv=Content-Type> <STYLE>H1 { 	COLOR: red; FONT-FAMILY: Arial, Helvetica, Geneva, SunSans-Regular, sans-serif; FONT-SIZE: 26pt; FONT-WEIGHT: bold } H2 { 	COLOR: black; FONT-FAMILY: Arial, Helvetica, Geneva, SunSans-Regular, sans-serif; FONT-SIZE: 18pt; FONT-WEIGHT: bold } </STYLE> <META content=\"MSHTML 5.00.2919.3800\" name=GENERATOR></HEAD> <BODY bgColor=white> <TABLE width=\"100%\"> <H1>" PRODUCT_NAME " Error <HR width=\"100%\"> </H1> <H2><I>Server Configuration Error</I></H2><FONT face=\"Arial, Helvetica, Geneva, SunSans-Regular, sans-serif \"><B>Description: </B>This " PRODUCT_NAME " application is configured to use the IIS Filter authentication mechanism. This requires that you configure IIS to allow anonymous access to this application. All requests for this application will be denied till this situation is corrected.<BR><BR></FONT></TABLE></BODY></HTML>";
            
            LPCSTR szErr;
            if (eValue & EBasicAuthSetting_ParseError)
                szErr = szError2;
            else
                if (!(eValue & EBasicAuthSetting_StarMapped))
                    szErr = szError1;
                else
                    szErr = szError3;                    

            DWORD errorTextLen = strlen(szErr);
            (*pfc->WriteClient)(
                    pfc,
                    (void *) szErr,
                    &errorTextLen,
                    0
                    );
            return SF_STATUS_REQ_FINISHED_KEEP_CONN;
        }
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Get the application phisical path for this request
BOOL
GetApplicationDir 
    (PHTTP_FILTER_CONTEXT   pfc, 
     char *                 szBuffer, 
     int                    iBufSize)
{
    if (pfc == NULL || szBuffer == NULL || iBufSize < 1)
        return FALSE;

    DWORD dwSize = iBufSize;
    szBuffer[0] = NULL;
    if (pfc->GetServerVariable(pfc, "APPL_PHYSICAL_PATH", szBuffer, &dwSize) == FALSE)
        return FALSE;

    _strlwr(szBuffer);
    int iLen = strlen(szBuffer);
    if (iLen > 1 && iLen < iBufSize - 2 && szBuffer[iLen-1] != '\\')
    {
        szBuffer[iLen] = '\\';
        szBuffer[iLen+1] = NULL; 
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

EBasicAuthSetting
GetMetabaseSettings
    (PHTTP_FILTER_CONTEXT  pfc, 
     LPSTR                 szMetaPath, 
     DWORD                 dwMetaPathSize)
{
    if (dwMetaPathSize < 4 || szMetaPath == NULL)
        return EBasicAuthSetting_DoesNotExist;

    EBasicAuthSetting  eReturn = EBasicAuthSetting_DoesNotExist;
    WCHAR              szPath  [512];

    if (szMetaPath[0] == NULL && pfc != NULL)
    {    
        char          szPathA [256];
        DWORD         dwSize  = sizeof(szPathA);
        
        if (pfc->GetServerVariable(pfc, "APPL_MD_PATH", szPathA, &dwSize) == FALSE)
            return eReturn;

        if (szMetaPath != NULL && dwMetaPathSize > 1)
            szMetaPath[0] = NULL;
        
        if (szMetaPath != NULL && dwSize < dwMetaPathSize)
            strcpy(szMetaPath, szPathA);
    }

    wcscpy(szPath, L"IIS://localhost");
    if ( MultiByteToWideChar(CP_ACP, 0, &szMetaPath[3], -1, &szPath[15], 480) == FALSE)
        return eReturn;

    if (IsMapped(szPath))
        eReturn = EBasicAuthSetting(eReturn | EBasicAuthSetting_StarMapped);

    if (IsAnonymousOn(szPath))
        eReturn = EBasicAuthSetting(eReturn | EBasicAuthSetting_AnonSetting);

    return eReturn;
}

////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOL
IsMapped(LPCWSTR szPath)
{
    HRESULT       hr;
    BIND_OPTS     opts;
    VARIANT       scriptMap;
    VARIANT       mapElement;
    IADs *        pADs = NULL;
    long          lbound;
    long          ubound;
    WCHAR         szDll[14];
    long          lElem;
    int           iRet = -1;

    ////////////////////////////////////////////////////////////
    // Step 3: Get it from the metabase
    VariantInit(&scriptMap);
    VariantInit(&mapElement);

    ZeroMemory(&opts, sizeof(opts));
    opts.cbStruct = sizeof(opts);

    hr = CoGetObject(szPath, &opts, __uuidof(IADs), (void **)&pADs);
    if (hr != S_OK)
        goto Cleanup;

    hr = pADs->GetEx(L"ScriptMaps", &scriptMap);
    if (hr != S_OK)
        goto Cleanup;

    if (scriptMap.vt != (VT_ARRAY|VT_VARIANT))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = SafeArrayGetLBound(V_ARRAY(&scriptMap), 1, &lbound);
    if (hr != S_OK)
        goto Cleanup;

    hr = SafeArrayGetUBound(V_ARRAY(&scriptMap), 1, &ubound);
    if (hr != S_OK)
        goto Cleanup;

    for (lElem = lbound; lElem <= ubound; lElem++)
    {
        VariantClear(&mapElement);

        hr = SafeArrayGetElement(V_ARRAY(&scriptMap), &lElem, &mapElement);
        if (hr != S_OK || mapElement.vt != VT_BSTR)
            continue;

        LPCWSTR   szStr         = V_BSTR(&mapElement);

        if (szStr[0] != L'*')
            continue;

        int       iLastSlash    = 0;
        int       iLen          = wcslen(szStr);
                
        for(int iter=2; iter<iLen; iter++)
        {
            if (szStr[iter] == L'\\')
                iLastSlash = iter;
            else
                if (szStr[iter] == L',')
                    break;
        }

        if (iLastSlash == 0 || iter-iLastSlash != ARRAY_SIZE(ISAPI_MODULE_FULL_NAME))
            continue;
        
        memcpy( szDll, &szStr[iLastSlash+1], 12 * sizeof(WCHAR));
        szDll[12] = NULL;
        if (_wcsicmp(szDll, ISAPI_MODULE_FULL_NAME_L) != 0)
            continue;
      
        iRet = 1;
        goto Cleanup;
    }

    iRet = 0;

Cleanup:
    VariantClear(&scriptMap);
    VariantClear(&mapElement);
    if (pADs != NULL)
        pADs->Release();
    return iRet;
}


////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOL
IsAnonymousOn(LPCWSTR szPath)
{
    HRESULT       hr;
    BIND_OPTS     opts;
    IADs *        pADs = NULL;
    VARIANT       anonSetting;
    BOOL          fRet = FALSE;

    VariantInit(&anonSetting);

    ZeroMemory(&opts, sizeof(opts));
    opts.cbStruct = sizeof(opts);

    hr = CoGetObject(szPath, &opts, __uuidof(IADs), (void **)&pADs);
    ON_ERROR_EXIT();

    hr = pADs->Get(L"AuthFlags", &anonSetting);
    ON_ERROR_EXIT();

    if (anonSetting.vt == VT_I4)
        fRet = (anonSetting.lVal & MD_AUTH_ANONYMOUS);

Cleanup:
    VariantClear(&anonSetting);
    if (pADs != NULL)
        pADs->Release();
    return fRet;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\codegen\codegen.h ===
/**
 * Code generation header file
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

// REVIEW (DavidEbb): we should not need a critical section
extern CRITICAL_SECTION g_CodeGenCritSec;

/**
 * Launch a command line compiler and redirected the output to a file.
 */
HRESULT LaunchCommandLineCompiler(LPWSTR wzCmdLine, LPCWSTR wzCompilerOutput);

/**
 * Return the path to the COM+ installation directory.
 * REVIEW: should probably be moved a xspisapi's global utilities
 */
HRESULT GetCorInstallPath(WCHAR **ppwz);


#define MAX_COMMANDLINE_LENGTH 16384

// Note: this doesn't need to be thread safe, since compilations are
// serialized (from inside managed code).
extern WCHAR s_wzCmdLine[MAX_COMMANDLINE_LENGTH];

/**
 * Base abstract compiler class, from which other compilers are derived
 */
class Compiler
{
private:
    LPCWSTR _pwzCompilerOutput;
    LPCWSTR *_rgwzImportedDlls;
    int _importedDllCount;
    boolean _fDebug;

protected:
    StaticStringBuilder *_sb;

    // The following method are implemented by the derived classes

    virtual LPCWSTR GetCompilerDirectoryName() = 0;

    virtual LPCWSTR GetCompilerExeName() = 0;

    virtual void AppendImportedDll(LPCWSTR /*pwzImportedDll*/) {}

    virtual void AppendCompilerOptions() {}

public:
    Compiler(
        LPCWSTR pwzCompilerOutput,
        LPCWSTR *rgwzImportedDlls,
        int importedDllCount)
    {
        // Create the string builder
        _sb = new StaticStringBuilder(s_wzCmdLine, ARRAY_SIZE(s_wzCmdLine));

        _pwzCompilerOutput = pwzCompilerOutput;
        _rgwzImportedDlls = rgwzImportedDlls;
        _importedDllCount = importedDllCount;
        _fDebug = false;
    }

    ~Compiler()
    {
        delete _sb;
    }

    void SetDebugMode() { _fDebug = true; }
    boolean FDebugMode() { return _fDebug; }

    HRESULT Compile();

    /**
     * Launch the command line compiler and redirected the output to a file.
     */
    HRESULT LaunchCommandLineCompiler(LPWSTR pwzCmdLine);
};


/**
 * Class used to launch the Cool compiler
 */
class CoolCompiler: public Compiler
{
private:
    LPCWSTR _pwzClass;
    LPCWSTR *_rgwzSourceFiles;
    int _sourceFileCount;
    LPCWSTR _pwzOutputDll;

public:
    CoolCompiler(
        LPCWSTR pwzClass,
        LPCWSTR pwzOutputDll,
        LPCWSTR pwzCompilerOutput,
        LPCWSTR *rgwzImportedDlls,
        int importedDllCount)
        : Compiler(pwzCompilerOutput, rgwzImportedDlls, importedDllCount)
    {
        _pwzClass = pwzClass;
        _rgwzSourceFiles = NULL;
        _sourceFileCount = 0;
        _pwzOutputDll = pwzOutputDll;
    }

    CoolCompiler(
        LPCWSTR pwzOutputDll,
        LPCWSTR pwzCompilerOutput,
        LPCWSTR *rgwzSourceFiles,
        int sourceFileCount,
        LPCWSTR *rgwzImportedDlls,
        int importedDllCount)
        : Compiler(pwzCompilerOutput, rgwzImportedDlls, importedDllCount)
    {
        _pwzClass = NULL;
        _rgwzSourceFiles = rgwzSourceFiles;
        _sourceFileCount = sourceFileCount;
        _pwzOutputDll = pwzOutputDll;
    }
    
protected:
    virtual LPCWSTR GetCompilerDirectoryName() { return L"CS"; }

    virtual LPCWSTR GetCompilerExeName() { return L"csc"; }

    virtual void AppendImportedDll(LPCWSTR pwzImportedDll);

    virtual void AppendCompilerOptions();
};


/**
 * Class used to launch the VB compiler
 */
class VBCompiler: public Compiler
{
private:
    LPCWSTR _pwzProject;
    LPCWSTR _pwzOutputDll;

public:
    VBCompiler(LPCWSTR pwzProject, LPCWSTR pwzOutputDll, LPCWSTR pwzCompilerOutput)
        : Compiler(pwzCompilerOutput, NULL, 0)
    {
        _pwzProject = pwzProject;
        _pwzOutputDll = pwzOutputDll;
    }

protected:
    virtual LPCWSTR GetCompilerDirectoryName() { return L"VB"; }

    virtual LPCWSTR GetCompilerExeName() { return L"bc"; }

    virtual void AppendCompilerOptions();
};

/**
 * Class used to launch the JS compiler
 */
class JSCompiler: public Compiler
{
private:
    LPCWSTR _pwzClass;
    LPCWSTR *_rgwzSourceFiles;
    int _sourceFileCount;
    LPCWSTR _pwzOutputDll;

public:
    JSCompiler(
        LPCWSTR pwzClass,
        LPCWSTR pwzOutputDll,
        LPCWSTR pwzCompilerOutput,
        LPCWSTR *rgwzImportedDlls,
        int importedDllCount)
        : Compiler(pwzCompilerOutput, rgwzImportedDlls, importedDllCount)
    {
        _pwzClass = pwzClass;
        _pwzOutputDll = pwzOutputDll;
    }

    JSCompiler(
        LPCWSTR pwzOutputDll,
        LPCWSTR pwzCompilerOutput,
        LPCWSTR *rgwzSourceFiles,
        int sourceFileCount,
        LPCWSTR *rgwzImportedDlls,
        int importedDllCount)
        : Compiler(pwzCompilerOutput, rgwzImportedDlls, importedDllCount)
    {
        _pwzClass = NULL;
        _rgwzSourceFiles = rgwzSourceFiles;
        _sourceFileCount = sourceFileCount;
        _pwzOutputDll = pwzOutputDll;
    }

protected:
    virtual LPCWSTR GetCompilerDirectoryName() { return L"JSCRIPT"; }

    virtual LPCWSTR GetCompilerExeName() { return L"jsc"; }

    virtual void AppendImportedDll(LPCWSTR pwzImportedDll);
    
    virtual void AppendCompilerOptions();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\codegen\coolcomp.cxx ===
/**
 * Code to invoke the COOL compiler and build managed DLL's.
 *
 * Copyright (c) 1999 Microsoft Corporation
 */


#include "precomp.h"
#include "codegen.h"

//////////////////////////////////////////////////////////////////////////////
// Prototypes for functions defined here
extern "C"
{
    // This function is called by managed code through NDirect
    HRESULT __stdcall BuildCoolClass(LPCWSTR pwzClass, LPCWSTR pwzOutputDll,
        LPCWSTR pwzCompilerOutput, LPCWSTR *rgwzImportedDlls,
        int importedDllCount, boolean fDebug);
}

/**
 * Build a COOL file into a managed DLL
 */
HRESULT BuildCoolClass(LPCWSTR pwzClass, LPCWSTR pwzOutputDll,
    LPCWSTR pwzCompilerOutput, LPCWSTR *rgwzImportedDlls,
    int importedDllCount, boolean fDebug)
{
    HRESULT hr;

    CoolCompiler *pCompiler = new CoolCompiler(
        pwzClass, pwzOutputDll, pwzCompilerOutput,
        rgwzImportedDlls, importedDllCount);

    if (pCompiler == NULL)
        return E_OUTOFMEMORY;

    if (fDebug)
        pCompiler->SetDebugMode();

    hr = pCompiler->Compile();

    delete pCompiler;

    return hr;
}

/**
 * Build a COOL file into a managed DLL
 */
HRESULT BatchBuildCoolClass(
    LPCWSTR *rgwzSourceFiles, int sourceFileCount,
    LPCWSTR pwzOutputDll,
    LPCWSTR pwzCompilerOutput,
    LPCWSTR *rgwzImportedDlls, int importedDllCount,
    boolean fDebug)
{
    HRESULT hr;

    CoolCompiler *pCompiler = new CoolCompiler(
        pwzOutputDll, pwzCompilerOutput,
        rgwzSourceFiles, sourceFileCount,
        rgwzImportedDlls, importedDllCount);

    if (pCompiler == NULL)
        return E_OUTOFMEMORY;

    if (fDebug)
        pCompiler->SetDebugMode();

    hr = pCompiler->Compile();

    delete pCompiler;

    return hr;
}


void CoolCompiler::AppendImportedDll(LPCWSTR pwzImportedDll)
{
    _sb->Append(L"/I:");
    _sb->Append(pwzImportedDll);
}

void CoolCompiler::AppendCompilerOptions()
{
    int i;
    
    if (FDebugMode())
        _sb->Append(L"/debug+ ");

    _sb->Append(L"/dll /W:4 /out:");
    _sb->Append(_pwzOutputDll);
    
    if (_pwzClass)
    {
        _sb->Append(L" ");
        _sb->Append(_pwzClass);
    }
    
    if (_rgwzSourceFiles != NULL)
    {
        for (i=0; i<_sourceFileCount; i++)
        {
            if (_rgwzSourceFiles[i] != NULL)
            {
                _sb->Append(L" ");
                _sb->Append(_rgwzSourceFiles[i]);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\lkrhashtable.cs ===
//------------------------------------------------------------------------------
// <copyright file="LkrHashtable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#define IMPLEMENT_SYSTEM_COLLECTIONS

namespace System.Web.Util.Lkr {

using System.Collections;
using System.Threading;
   

internal enum TableSize {
    Default = 0,
    Small = 1,  // < 200 elements
    Medium = 2, // 200 to 10,000 elements
    Large = 3   // 10,000+ elements
}
 
/// <include file='doc\LkrHashtable.uex' path='docs/doc[@for="LkrHashtable"]/*' />
/// <internalonly/>

// 
// Notes
// 
//  This work is a port of George Reilly's LKRHash scalable hashtable.
//  http://georgere/work/lkrhash/
//  His site has resources explaining the theory behind linear hashing
//  and covers the reasons for lock cascading.  Because Reilly explains
//  his design so well, there is little reason to duplicate that here.
//
#if IMPLEMENT_SYSTEM_COLLECTIONS
internal sealed class LkrHashtable : IDictionary {
#else
internal sealed class LkrHashtable {
#endif

    public const int MIN_INITIAL_CAPACITY = 4;
    public const int MAX_SUBTABLES = 64;
    const TableSize DEFAULT_META_TABLE_SIZE = TableSize.Medium;

    readonly IHashCodeProvider  _hcp;
    readonly LinearHashtable [] _subTables; // sizes: 1, 2, 4, 8, 16, 32, or 64
    readonly int                _subTableMask;


    public LkrHashtable(string name) : this(name, TableSize.Default) {
    }

    public LkrHashtable(string name, IHashCodeProvider hcp, IComparer comparer) : this(name, TableSize.Default, hcp, comparer) {
    }

    public LkrHashtable(string name, TableSize size) : this(name, size, 0, 0, null, null) {
    }

    public LkrHashtable(string name, TableSize size, IHashCodeProvider hcp, IComparer comparer) : this(name, size, 0, 0, hcp, comparer) {
    }

    public LkrHashtable(
            string name,
            TableSize size,
            double maxLoad,
            int subTableCount) : this(name, size, maxLoad, subTableCount, null, null) {
    }

    public LkrHashtable(
            string name,
            TableSize size,
            double maxLoad,
            int subTableCount,
            IHashCodeProvider hcp, 
            IComparer comparer) {

        _hcp = hcp;

        if (size == TableSize.Default) {
            size = DEFAULT_META_TABLE_SIZE;
        }

        _CtorCheckParameters(maxLoad, subTableCount);

        if (subTableCount == 0) {
            subTableCount = _SubTableCountFromTableSize(size);
        }

        Debug.Trace("LkrHashtable", "LkrHashtable.ctor  name=" + name + " size=" + 
            size + " subtables=" + subTableCount);

        _CtorMakeSubTables(subTableCount, out _subTables, out _subTableMask);

        for(int i = 0; i < subTableCount; ++i) {
            string subTableName = name + " sub " + i.ToString();
            _subTables[i] = new LinearHashtable(
                                    subTableName, 
                                    size,
                                    maxLoad,
                                    hcp,
                                    comparer);
        }
    }


    // use similiar to Hashtable(int initialCapacity), or ArrayList(int initialCapacity)
    public LkrHashtable(string name, int initialCapacity) : this(name, initialCapacity, 0, 0, null, null) {
    }

    public LkrHashtable(string name, int initialCapacity, IHashCodeProvider hcp, IComparer comparer) : this(name, initialCapacity, 0, 0, hcp, comparer) {
    }

    public LkrHashtable(
        string name,                
        int initialCapacity,
        double maxLoad,     
        int subTableCount) : this(name, initialCapacity, maxLoad, subTableCount, null, null) {
    }

    public LkrHashtable(
        string name,           // an identifier for debugging
        int initialCapacity,   // initial size of hash table (entries, not buckets like C++ LkrHash) 
        double maxLoad,        // bound on the average chain length
        int subTableCount,     // number of subordinate hash tables
        IHashCodeProvider hcp, 
        IComparer comparer) {

        _hcp = hcp;

        if (initialCapacity < MIN_INITIAL_CAPACITY) { 
            // initialCapacity must be greater than MIN_INITIAL_CAPACITY
            throw new ArgumentOutOfRangeException("initialCapacity", initialCapacity, null);
        }

        _CtorCheckParameters(maxLoad, subTableCount);

        if (subTableCount == 0) { // get default from initialCapacity
            subTableCount = _GetSubTableCount(initialCapacity, maxLoad);
        }

        Debug.Trace("LkrHashtable", "LkrHashtable: name=" + name + 
            " subtables=" + subTableCount + ", capacity=" + initialCapacity);

        _CtorMakeSubTables(subTableCount, out _subTables, out _subTableMask);

        for(int i = 0; i < subTableCount; ++i) {
            string subTableName = name + " sub " + i.ToString();
            _subTables[i] = new LinearHashtable(
                                    subTableName, 
                                    initialCapacity / subTableCount,
                                    maxLoad,
                                    hcp,
                                    comparer);

        }
    }


    // used to share code between the two constructors
    private void _CtorCheckParameters(double maxLoad, int subTableCount) {
        if (maxLoad == 0) {
            maxLoad = LinearHashtable.DEFAULT_MAXLOAD; // TODO: Fix
        }

        if (!(0 <= subTableCount && subTableCount <= MAX_SUBTABLES)) {
            // Must be 1-64 inclusive.  Use 0 for default based on initialCapacity
            throw new ArgumentOutOfRangeException("subTableCount", subTableCount, null);
        }
    }

    // used to share code between the two constructors
    // out parameters are necessary for readonly variables (can only be set in ctor)
    private void _CtorMakeSubTables(int subTableCount, out LinearHashtable[] subTables, out int subTableMask) {

        subTables = new LinearHashtable[subTableCount];

        subTableMask = subTableCount - 1;
        // power of 2?
        if ((subTableMask & subTableCount) != 0)
            subTableMask = -1;

    }


    static int _SubTableCountFromTableSize(TableSize size) {
        // size is Small, Medium, or Large.  NOT Default.
        Debug.Assert(TableSize.Small <= size && size <= TableSize.Large);

        int nCPUs = GetProcessorCount();
        int subTableCount;

        switch(size) {
            case TableSize.Small:
                subTableCount = nCPUs;
                break;

            case TableSize.Medium:
                subTableCount = 2 * nCPUs;
                break;

            case TableSize.Large:
                subTableCount = 4 * nCPUs;
                break;

            default:
                throw new InvalidOperationException();
        };

        subTableCount = Math.Min(subTableCount, MAX_SUBTABLES);

        return subTableCount;
    }


    // Note: initialCapacity is #entries, not #buckets
    int _GetSubTableCount(int initialCapacity, double maxLoad) {

        // convert from #entries to #buckets
        int initialTotalBucketCount = (int)(initialCapacity / maxLoad);

        TableSize size;

        // use heuristic to guess best TableSize fit
        if (initialTotalBucketCount <= LinearHashtable.Segment.SmallSegSize)      // small
            size = TableSize.Small;
        else if (initialTotalBucketCount >= LinearHashtable.Segment.LargeSegSize * 4) // large
            size = TableSize.Large;
        else                                           // default to medium
            size = TableSize.Medium;

        return _SubTableCountFromTableSize(size);
    }


    int _GetHash(Object key) {

    	if (_hcp != null)
    		return _hcp.GetHashCode(key);

    	return key.GetHashCode();
    }


    public void DeleteKey(object key) {
        int hashValue = _GetHash(key);
        LinearHashtable subTable = _GetSubTable(hashValue);
        subTable._DeleteKey(key, hashValue);
    }


    // return - returns the previous value at key
    //      Notes: return can be null key is new
    public object Insert(object key, object value) { 
        return Insert(key, value, false); 
    }


    // paramaters -
    //      bool onlyAdd
    //          false - allows overwriting at key
    //          true  - throws exception if key exists
    //          
    // return - returns the previous value at key
    //      Notes: return can be null key is new or if value at key is null
    public object Insert(object key, object value, bool onlyAdd) {
        if (key == null)
            throw new ArgumentNullException("key");

        int hashValue = _GetHash(key);
        LinearHashtable subTable = _GetSubTable(hashValue);
        return subTable._Insert(key, value, hashValue, onlyAdd);
    }


    public object FindKey(object key) { 
        int hashValue = _GetHash(key);
        LinearHashtable subTable = _GetSubTable(hashValue);
        return subTable._FindKey(key, hashValue);
    }


    // Lock all subtables for writing
    public void AcquireWriterLock() {
        foreach(LinearHashtable table in _subTables) {
            table.AcquireWriterLock();
            Debug.Assert(table.IsWriterLockHeld);
        }
    }


    // Lock all subtables for reading 
    public void AcquireReaderLock() {
        foreach(LinearHashtable table in _subTables) {
            table.AcquireReaderLock();
            Debug.Assert(table.IsReaderLockHeld);
        }
    }


    // Unlock all subtables
    public void ReleaseWriterLock() {
        foreach(LinearHashtable table in _subTables) {
            Debug.Assert(table.IsWriterLockHeld);
            table.ReleaseWriterLock();
            Debug.Assert(false == table.IsWriterLockHeld);
        }
    }


    // Unlock all subtables
    public void ReleaseReaderLock() {
        foreach(LinearHashtable table in _subTables) {
            Debug.Assert(table.IsReaderLockHeld);
            table.ReleaseReaderLock();
            Debug.Assert(false == table.IsReaderLockHeld);
        }
    }


    public bool IsWriterLockHeld {
        get {
            bool isLocked = true;
            foreach(LinearHashtable table in _subTables)
                isLocked = isLocked && table.IsWriterLockHeld;
            return isLocked;
        }
    }


    public bool IsReaderLockHeld {
        get {
            bool isLocked = true;
            foreach(LinearHashtable table in _subTables)
                isLocked = isLocked && table.IsReaderLockHeld;
            return isLocked;
        }
    }


    public bool IsWriteNotHeld {
        get {
            bool isUnlocked = true;
            foreach(LinearHashtable table in _subTables)
                isUnlocked = isUnlocked && (false == table.IsWriterLockHeld);
            return isUnlocked;
        }
    }


    public bool IsReadNotHeld {
        get {
            bool isUnlocked = true;
            foreach(LinearHashtable table in _subTables)
                isUnlocked = isUnlocked && (false == table.IsReaderLockHeld);
            return isUnlocked;
        }
    }


    public int Size {
        get {
            int size = 0;

            foreach(LinearHashtable table in _subTables)
                size += table.Size;

            return size;
        }
    }


    public bool IsValid() {
        bool isValid = _subTables != null;

        foreach(LinearHashtable table in _subTables) {
            table.AssertValid();
        }

        return isValid;
    }


    LinearHashtable _GetSubTable(int hashCode) {
        Debug.Assert(_subTables != null
            && _subTables.Length != 0);

        int index = hashCode;
        const int PRIME = 1048583;  // used to scramble the hash sig
    
        index = (int)((uint)(index * PRIME + 12345) >> 16)
             | (int)((uint)(index * 69069 + 1) & 0xffff0000);
    
        if (_subTableMask >= 0)
            index &= _subTableMask;
        else
            index %= _subTables.Length;

        return _subTables[index];
    }


    //
    // Static Utility Functions / Debug functions
    //

    static int _numberOfProcessors = 0;

    public static int GetProcessorCount() {

        if (_numberOfProcessors == 0) {
            NativeMethods.SYSTEM_INFO si;
            NativeMethods.GetSystemInfo(out si);
            _numberOfProcessors = (int) si.dwNumberOfProcessors;
            Debug.Assert(_numberOfProcessors != 0);
        }

        return _numberOfProcessors;
    }


    public static Type LinearHashtableLockType
    { get { return LinearHashtable.LockType; } }


    public static Type BucketLockType
    { get { return LinearHashtable.Bucket.LockType; } }


    public void CopyEntriesTo(DictionaryEntry [] entries, int destination) {
        Debug.Assert(destination + Size < entries.Length);
        foreach(LinearHashtable table in _subTables) {
            table.CopyEntriesTo(entries, destination);
            destination += table.Size;
        }
    }

#if IMPLEMENT_SYSTEM_COLLECTIONS
    // <IEnumerable interface>
    IEnumerator IEnumerable.GetEnumerator() {
        throw new InvalidOperationException();
    }
    // </IEnumerable interface>


    // <ICollection interface>
    void ICollection.CopyTo(Array destination, int destinationIndex) {
        throw new InvalidOperationException();
    }


    int ICollection.Count {
        get {
            return Size;
        }
    }


    bool IDictionary.IsReadOnly {
        get { return false; }
    }

    bool IDictionary.IsFixedSize {
        get { return false; }
    }


    bool ICollection.IsSynchronized {
        get { return false; }
    }


    object ICollection.SyncRoot {
        get {
            throw new InvalidOperationException();
        }
    }
    // </ICollection interface>


    // <IDictionary interface>
    public void Add(object key, object value) {
        Insert(key, value, true);
    }


    public void Clear() {
        foreach(LinearHashtable table in _subTables) {
            table.Clear();
        }
    }


    public bool Contains(object key) {
        object value = FindKey(key);
        return value != null;
    }


    IDictionaryEnumerator IDictionary.GetEnumerator() {
        throw new InvalidOperationException();
    }


    public void Remove(object key) { 
        DeleteKey(key); 
    }


    public object this[object key] {
        get {
            return FindKey(key);
        }
        set {
            Insert(key, value, false);
        }
    }


    public ICollection Keys {
        get {
            throw new InvalidOperationException();
        }
    }


    public ICollection Values {
        get {
            throw new InvalidOperationException();
        }
    }
    // </IDictionary interface>
#endif // IMPLEMENT_SYSTEM_COLLECTIONS

} // LkrHashtable


} // ns
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\codegen\jscomp.cxx ===
/**
 * Code to invoke the JS compiler and build managed DLL's.
 *
 * Copyright (c) 1999 Microsoft Corporation
 */


#include "precomp.h"
#include "codegen.h"

//////////////////////////////////////////////////////////////////////////////
// Prototypes for functions defined here
extern "C"
{
    // This function is called by managed code through NDirect
    HRESULT __stdcall BuildJSClass(LPCWSTR wzClass, LPCWSTR wzOutputDll,
        LPCWSTR wzCompilerOutput, LPCWSTR *rgwzImportedDlls,
        int importedDllCount, boolean fDebug);
}


/**
 * Build an JS file into a managed DLL
 */
HRESULT BuildJSClass(LPCWSTR pwzClass, LPCWSTR pwzOutputDll,
    LPCWSTR pwzCompilerOutput, LPCWSTR *rgwzImportedDlls,
    int importedDllCount, boolean fDebug)
{
    HRESULT hr;

    JSCompiler *pCompiler = new JSCompiler(
        pwzClass, pwzOutputDll, pwzCompilerOutput,
        rgwzImportedDlls, importedDllCount);

    if (pCompiler == NULL)
        return E_OUTOFMEMORY;

    if (fDebug)
        pCompiler->SetDebugMode();

    hr = pCompiler->Compile();

    delete pCompiler;

    return hr;
}

/**
 * Build a JS file into a managed DLL
 */
HRESULT BatchBuildJSClass(
    LPCWSTR *rgwzSourceFiles, int sourceFileCount,
    LPCWSTR pwzOutputDll,
    LPCWSTR pwzCompilerOutput,
    LPCWSTR *rgwzImportedDlls, int importedDllCount,
    boolean fDebug)
{
    HRESULT hr;

    JSCompiler *pCompiler = new JSCompiler(
        pwzOutputDll, pwzCompilerOutput,
        rgwzSourceFiles, sourceFileCount,
        rgwzImportedDlls, importedDllCount);

    if (pCompiler == NULL)
        return E_OUTOFMEMORY;

    if (fDebug)
        pCompiler->SetDebugMode();

    hr = pCompiler->Compile();

    delete pCompiler;

    return hr;
}


void JSCompiler::AppendImportedDll(LPCWSTR pwzImportedDll)
{
    _sb->Append(L"/i:");
    _sb->Append(pwzImportedDll);
}

void JSCompiler::AppendCompilerOptions()
{
    int i;
    
    if (FDebugMode())
        _sb->Append(L"/debug+ ");

    _sb->Append(L"/out:");
    _sb->Append(_pwzOutputDll);

    if (_pwzClass)
    {
        _sb->Append(L" ");
        _sb->Append(_pwzClass);
    }
    
    if (_rgwzSourceFiles != NULL)
    {
        for (i=0; i<_sourceFileCount; i++)
        {
            if (_rgwzSourceFiles[i] != NULL)
            {
                _sb->Append(L" ");
                _sb->Append(_rgwzSourceFiles[i]);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\codegen\codegen.cxx ===
/**
 * Code to invoke COM+ compilers and build managed DLL's.
 *
 * Copyright (c) 1999 Microsoft Corporation
 */


#include "precomp.h"
#include "codegen.h"

// How long (in milliseconds) do we wait for the compiler to terminate
#define PROCESS_TIMEOUT 30000


// REVIEW (DavidEbb): we should not need a critical section
CRITICAL_SECTION g_CodeGenCritSec;


/**
 * Initialization of the code generator
 */
HRESULT InitCodeGenerator()
{
    InitializeCriticalSection(&g_CodeGenCritSec);

    return NOERROR;
}

/**
 * Cleanup of the code generator
 */
HRESULT UninitCodeGenerator()
{
    DeleteCriticalSection(&g_CodeGenCritSec);

    return NOERROR;
}


/**
 * Create a writable with an inheritable handle
 */
HANDLE CreateInheritedFile(LPCWSTR pwzFile)
{
    SECURITY_ATTRIBUTES sec_attribs;
    ZeroMemory(&sec_attribs, sizeof(sec_attribs));
    sec_attribs.nLength = sizeof(sec_attribs);
    sec_attribs.bInheritHandle = TRUE;

    return CreateFile(
        pwzFile,
        GENERIC_WRITE,
        0,
        &sec_attribs,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
}

/**
 * Return the path to the COM+ installation directory.
 * REVIEW: should probably be moved a xspisapi's global utilities
 */
HRESULT GetCorInstallPath(WCHAR **ppwz)
{
    // path to the COM+ installation directory
    static WCHAR g_wzCorInstallPath[MAX_PATH];

    HRESULT hr = NOERROR;

    // Only get it if we don't already have it
    if (g_wzCorInstallPath[0] == '\0')
    {
        HKEY hKey = NULL;
        DWORD cbData, dwType, dwRet;

        // Open the COM+ reg key
        dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            L"Software\\Microsoft\\COMPlus",
            0, KEY_QUERY_VALUE, &hKey);
        ON_WIN32_ERROR_EXIT(dwRet);

        // Read the install directory from it
        cbData = sizeof(g_wzCorInstallPath);
        dwRet = RegQueryValueEx(hKey, L"sdkInstallRoot", NULL,
            &dwType, (BYTE *)g_wzCorInstallPath, &cbData);
        RegCloseKey(hKey);
        ON_WIN32_ERROR_EXIT(dwRet);
    }

    *ppwz = g_wzCorInstallPath;

Cleanup:
    return hr;
}


WCHAR s_wzCmdLine[MAX_COMMANDLINE_LENGTH];

HRESULT Compiler::Compile()
{
    WCHAR *pwzNoPath;   // The command line without the full path
    int i;

    HRESULT hr;

    // the path to the COM+ installation directory
    WCHAR *pwzCorInstallPath = NULL;
    GetCorInstallPath(&pwzCorInstallPath);
    // Ignore failures since the reg key may not be there

    // Start the command line with the path to the compiler
    if (pwzCorInstallPath != NULL)
    {
        _sb->Append(pwzCorInstallPath);
        _sb->Append(L"Compiler\\");
        _sb->Append(GetCompilerDirectoryName());
        _sb->Append(L"\\");
    }

    // Remember where we are in the command line
    pwzNoPath = _sb->GetCurrentPos();

    _sb->Append(GetCompilerExeName());
    _sb->Append(L" ");

    // Append the list of imported DLL's
    for (i=0; i<_importedDllCount; i++)
    {
        if (_rgwzImportedDlls[i] != NULL)
        {
            AppendImportedDll(_rgwzImportedDlls[i]);
            _sb->Append(L" ");
        }
    }

    AppendCompilerOptions();
    _sb->Append(L" ");

    // Check if we have overflowed the string builder
    if (_sb->FOverFlow())
        return E_OUTOFMEMORY;

    // Launch the command line with the full path to the compiler, assuming
    // that we successfully got the full path
    if (pwzCorInstallPath != NULL)
    {
        hr = LaunchCommandLineCompiler(s_wzCmdLine);
    }
    else
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    // If we can't find the compiler with the full path, try with no path
    // in case it's on the path.
    // REVIEW: this is probably temporary.  See bug 6059.
    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ||
        hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
    {
        hr = LaunchCommandLineCompiler(pwzNoPath);
    }

    return hr;
}

/**
 * Launch a command line compiler and redirect the output to a file
 */
HRESULT Compiler::LaunchCommandLineCompiler(LPWSTR pwzCmdLine)
{
    HRESULT hr = NOERROR;
    DWORD dwRet, dwExitCode;
    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFOW StartupInfo;

    // Create a file for the output of the compiler
    HANDLE hFile = CreateInheritedFile(_pwzCompilerOutput);
    if (hFile == INVALID_HANDLE_VALUE)
        EXIT_WITH_LAST_ERROR();

    // Output the command line to the file
    static char szCmdLine[MAX_COMMANDLINE_LENGTH + 10];
    WideCharToMultiByte(CP_ACP, 0, pwzCmdLine, -1, szCmdLine,
        sizeof (szCmdLine), NULL, NULL);
    lstrcatA(szCmdLine, "\r\n\r\n");
    DWORD dwWritten;
    WriteFile(hFile, szCmdLine, lstrlenA(szCmdLine), &dwWritten, NULL);

    ZeroMemory(&StartupInfo, sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);

    StartupInfo.hStdOutput = hFile;
    StartupInfo.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
    StartupInfo.wShowWindow = SW_HIDE;

    // Launch the process
    if (!CreateProcessW(
        NULL,                   // lpApplicationName
        pwzCmdLine,
        NULL,                   // lpProcessAttributes
        NULL,                   // lpThreadAttributes
        TRUE,                   // bInheritHandles
        0,                      // dwCreationFlags
        NULL,                   // lpEnvironment
        NULL,                   // lpCurrentDirectory
        &StartupInfo,
        &ProcessInfo))
    {
        CloseHandle(hFile);
        EXIT_WITH_LAST_ERROR();
    }

    CloseHandle(hFile);

    // Wait for it to terminate
    dwRet = WaitForSingleObject(ProcessInfo.hProcess, PROCESS_TIMEOUT);

    // Check for timeout
    if (dwRet == WAIT_TIMEOUT)
        return HRESULT_FROM_WIN32(WAIT_TIMEOUT);

    if (dwRet != WAIT_OBJECT_0)
        EXIT_WITH_LAST_ERROR();

    // Check the process's exit code
    if (!GetExitCodeProcess(ProcessInfo.hProcess, &dwExitCode))
        EXIT_WITH_LAST_ERROR();

    CloseHandle(ProcessInfo.hProcess);
    CloseHandle(ProcessInfo.hThread);

    // If it's not 0, something must have failed
    if (dwExitCode != 0)
        return E_FAIL;

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\linearhashtable.cs ===
//------------------------------------------------------------------------------
/// <copyright file="LinearHashtable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#define IMPLEMENT_SYSTEM_COLLECTIONS
//#define MLKR_ENUMERATORS

namespace System.Web.Util.Lkr {

using System.Collections;
using System.Threading;
   
// 
// Notes
// 
//  This work is a port of George Reilly's LKRHash scalable hashtable.
//  http://georgere/work/lkrhash/
//  His site has resources explaining the theory behind linear hashing
//  and covers the reasons for lock cascading.  Because Reilly explains
//  his design so well, there is little reason to duplicate that here.
//  The rest of these notes explain the differences in the managed version.
//  
//  
// Notes on Bucket Layout:
//
//  In LKRHash the Segment object is one very large set of nested arrays:
//
//  64 buckets (down) x 6 ints across (with a lock and a next pointer tacked on)
//
//      B: begining of bucket   N: "next" chain pointer   
//      i: used node   o: empty (unused) node
//      -> indirection (potential cache miss)   
//
// B iiioooN
// B iiiiioN->iiiiiiN
// B iiiiooN
// B iiiiioN->iiiiioN->iiioooN
//
// This layout is VERY cache friendly.  This layout is NOT possible in CSharp, 
// because there is no way to embed an array (even as small as six integers) inside
// a struct.  So, after a few tries and a couple wasted hours, I came up with:
//
// B->iiiiiiiiiooo
// B->iiiiiiiiiiii
// B->iiiiio
// B->iiiooo
// B->iiiiiiiioooo
//
// I did NOT chose to use arraylists:
//      B: begining of bucket   AL: Collection.ArrayList object  
// B->AL->iiiiii
// B->AL->iiiiiii
// ...
// notice the extra level of indirection (extra potential cache miss)
// 
// neither my CSharp version nor the LKRHash version include
// data pointers in the array:
//
// k - reference (pointer) to key object
// v - reference (pointer) to value object
//
// YES: B->iiiiiii
//      +->kvkvkvkvkvkvkv
// 
// NO:  B->ikvikvikvikvikvikvikvikv
// 
// Notice that more hash codes fit into an L1 cache line the "YES" way.
// This is good - we want to optimize the scanning-down of the hashcodes 
// looking for the correct object(s).  This does mean when we verify the key
// we have another potential cache miss, but it's a good trade-off.
//
#if IMPLEMENT_SYSTEM_COLLECTIONS
internal sealed class LinearHashtable : IDictionary {
#else
internal sealed class LinearHashtable {
#endif

    internal const double DEFAULT_MAXLOAD = 6.0;
    internal const double MAX_MAXLOAD = 100.0;
    internal const TableSize DEFAULT_TABLE_SIZE = TableSize.Small;
    internal const int MIN_DIRSIZE = 8;       // min capacity of _segments
    internal const int MAX_DIRSIZE = (1<<19); // max capacity of _segments
    const int minSegments = 1;


    ReadWriteSpinLock _lock;
    int _tableIndexMask0;
    int _tableIndexMask1;
    int _expansionIndex;

    Segment [] _segments;
    int _level;
    string _name;
    int _entryCount;           // number of records in the table
    int _bucketCount;          // number of buckets allocated

    readonly int _segBits;      // 3,6,9        (small, medium, large)
    readonly int _segSize;      // 1<<_segBits  (2^_segBits)
    readonly int _segMask;      // _segSize-1   (all ones)
    readonly double _maxLoad;

    readonly IHashCodeProvider _hcp;
    readonly IComparer _comparer;


    int _GetHash(Object key) {

    	if (_hcp != null)
    		return _hcp.GetHashCode(key);

    	return key.GetHashCode();
    }


    bool _KeyEquals(Object item, Object key) {

        //if (item == key) return true;

        if (_comparer != null)
            return _comparer.Compare(item, key) == 0;

        return item.Equals(key);
    }

    int _TableIndexMask0 { 
        get { 
            return _tableIndexMask0; 
        } 
        set {
            Debug.Assert((value + 1 & value) == 0);
            _tableIndexMask0 = value;
            _tableIndexMask1 = (value << 1) | 1;
        }
    }

    int _TableIndexMask1 { 
        get { 
            return _tableIndexMask1; 
        } 
    }


    // See the Linear Hashing paper.
    static int _H0(int hashCode, int tableIndexMask) { 
        return hashCode & tableIndexMask; 
    }


    int _H0(int hashCode) { 
        return _H0(hashCode, _TableIndexMask0); 
    }


    // See the Linear Hashing paper.  Preserves one bit more than _H0.
    static int _H1(int hashCode, int tableIndexMask) { 
        return hashCode & ((tableIndexMask << 1) | 1); 
    }


    int _H1(int hashCode) { 
        return _H0(hashCode, _TableIndexMask1); 
    }


    //
    // _TableIndex
    //
    // 'table index' = 'segment index' concatenated with a 'bucket index'
    //  Values are 32 bit values layed out as follows:
    //
    //                Width                   Offset
    //                ---------------------   --------
    //  hashcode      32                      0
    //  H1            level + SegBits + 1     0          Note: H1 == hashCode & TableIndexMask1
    //  H0            level + SegBits         0          Note: H0 == hashCode & TableIndexMask0
    //  tableIndex    level + SegBits + 1*    0          
    //  tableIndex1   level + SegBits + 1     0
    //  tableIndex0   level + SegBits         0
    //  segindex      level + 1*              SegBits
    //  bucketIndex   SegBits                 0
    //
    // * - see linear hashing paper for when the extra (+1) bit is used
    //
    //
    // So this is what the bit field layout would be when 
    //  SegBits  6  (medium TableSize)
    //  level    4  (the directory has grown to use up to 2^4 segments)
    //
    //   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
    //   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    //  +-----------------------------------------+-+-------+-----------+
    //  |                                         |*| SegIdx| BucketIdx |
    //  +-----------------------------------------+-+-------+-----------+
    //  |                                         |*|    Table Index    |
    //  +-----------------------------------------+-+-------------------+
    //
    // * - see linear hashing paper for when the extra (+1) bit is used
    //  
    int _TableIndex(int hashCode) {
        int tableIndex = _H0(hashCode);
        // Has this bucket been split already?
        if (tableIndex < _expansionIndex)
            tableIndex = _H1(hashCode);
        Debug.Assert(tableIndex < _bucketCount);
        Debug.Assert(tableIndex < (_segments.Length << _segBits));
        return tableIndex;
    }


    Segment _Segment(int tableIndex) {
        int segmentIndex = tableIndex >> _segBits;
        return _segments[segmentIndex]; 
    }


    void _Segment(int tableIndex, Segment value) {
        int segmentIndex = tableIndex >> _segBits;
        _segments[segmentIndex] = value; 
    }


    // Offset within the segment of the bucketaddress
    int _BucketIndex(int tableIndex) { 
        return (tableIndex & _segMask); 
    }

    // Convert a tableIndex to a Bucket reference
    Bucket _Bucket(int tableIndex) {
        Debug.Assert(tableIndex < _bucketCount);
        Segment segment = _Segment(tableIndex);
        Debug.Assert(segment != null);
        return segment[_BucketIndex(tableIndex)];
    }


    public LinearHashtable(string name) : this(name, TableSize.Default) {
    }

    public LinearHashtable(string name, IHashCodeProvider hcp, IComparer comparer) 
        : this(name, TableSize.Default, 0, 0, hcp, comparer) {
    }

    public LinearHashtable(string name, TableSize size) 
        : this(name, size, 0) {
    }

    public LinearHashtable(string name, TableSize size, double maxLoad)
        : this(name, size, 0, maxLoad, null, null) {
    }

    // string               name            -- An identifier for debugging
    // TableSize            size            -- TableSize.Small, TableSize.Medium, TableSize.Large
    // double               maxLoad         -- Upperbound on the average chain length  
    // IHashCodeProvider    hcp             -- User-supplied hashcode provider
    // IComparer            comparer        -- User-supplied key comparer
    public LinearHashtable(string name, TableSize size, double maxLoad, IHashCodeProvider hcp, IComparer comparer) 
        : this(name, size, 0, maxLoad, hcp, comparer) {
    }

    public LinearHashtable(string name, int initialCapacity) 
        : this(name, initialCapacity, 0) {
    }
    
    public LinearHashtable(string name, int initialCapacity, double maxLoad) 
        : this(name, TableSize.Default, initialCapacity, maxLoad, null, null) {
    }

    // string               name            -- An identifier for debugging
    // int                  initialCapacity -- allocate enough buckets to hold initialCapacity entries
    // double               maxLoad         -- Upperbound on the average chain length  
    // IHashCodeProvider    hcp             -- User-supplied hashcode provider
    // IComparer            comparer        -- User-supplied key comparer
    public LinearHashtable(string name, int initialCapacity, double maxLoad, IHashCodeProvider hcp, IComparer comparer) 
        : this(name, TableSize.Default, initialCapacity, maxLoad, hcp, comparer) {
    }


    private LinearHashtable(string name, TableSize size, int initialCapacity, double maxLoad, IHashCodeProvider hcp, IComparer comparer) {

        _lock     = new ReadWriteSpinLock();
        _name     = name;
        _hcp      = hcp;
        _comparer = comparer;

        //
        // Check maxLoad
        //

        // sanity-check default values
        Debug.Assert(1 <= DEFAULT_MAXLOAD && DEFAULT_MAXLOAD <= Bucket.INITIAL_CAPACITY);
        if (maxLoad == 0) {
            maxLoad = DEFAULT_MAXLOAD;
        }
        if (!(1 <= maxLoad && maxLoad <= MAX_MAXLOAD)) {
            throw new ArgumentOutOfRangeException("maxLoad");
        }
        _maxLoad = maxLoad;


        //
        // Check size and initialCapacity
        //

        // at least one must be zero
        Debug.Assert(size == TableSize.Default || initialCapacity == 0);

        if (!(TableSize.Default <= size && size <= TableSize.Large)) {
            throw new ArgumentOutOfRangeException("size");
        }
        if (!(0 <= initialCapacity && initialCapacity < (maxLoad * MAX_DIRSIZE))) {
            throw new ArgumentOutOfRangeException("initialCapacity");
        }

        // if both are zero use DEFAULT_TABLE_SIZE
        if (size == TableSize.Default && initialCapacity == 0) {
            size = DEFAULT_TABLE_SIZE;
        }


        //
        // Determine TableSize (if necessary) and set size variables
        //
        {
            int initBucketCount = 0;
            int initBucketsPerSegment = 0;

            // If given a specific capacity, use a heuristic to guess a table size
            if (initialCapacity > 0) {

                // initialCapacity ctor was called
                Debug.Assert(size == TableSize.Default);

                // force Small.INITSIZE <= initialCapacity <= MAX_DIRSIZE * Large::INITSIZE
                initBucketCount = 1 + (int)(initialCapacity / maxLoad);
                initBucketCount = Math.Max(initBucketCount, Segment.SmallInitSize);
                initBucketCount = Math.Min(initBucketCount, MAX_DIRSIZE * Segment.LargeInitSize);

                // Guess a table size
                if (initBucketCount <= 8 * Segment.SmallInitSize)
                    size = TableSize.Small;
                else if (initBucketCount >= Segment.LargeInitSize)
                    size = TableSize.Large;
                else
                    size = TableSize.Medium;
            }

            //
            // Set Size Related Variables
            //
            Debug.Assert(TableSize.Small <= size && size <= TableSize.Large);

            switch (size) {
            case TableSize.Small:
                _segBits     = Segment.SmallBits;
                _segSize     = Segment.SmallSegSize;
                _segMask     = Segment.SmallSegMask;
                initBucketsPerSegment  = Segment.SmallInitSize;
                break;

            case TableSize.Medium:
                _segBits    = Segment.MediumBits;
                _segSize    = Segment.MediumSegSize;
                _segMask    = Segment.MediumSegMask;
                initBucketsPerSegment = Segment.MediumInitSize;
                break;

            case TableSize.Large:
                _segBits    = Segment.LargeBits;
                _segSize    = Segment.LargeSegSize;
                _segMask    = Segment.LargeSegMask;
                initBucketsPerSegment = Segment.LargeInitSize;
                break;
            }
            _TableIndexMask0 = _segMask;
            _level = _segBits;

            // If not given a specific capacity, use the number of buckets 
            // in a single segment as the initial number of buckets.
            if (initialCapacity > 0) {
                _bucketCount = initBucketCount;
            }
            // Otherwise use enough buckets to ensure initialCapacity can be handled.
            else {
                _bucketCount = initBucketsPerSegment;
            }
        }


        // adjust _TableIndexMask0 (== _segMask) to make it large
        // enough to distribute the buckets across the address space
        for (int temp = _bucketCount >> _segBits; temp > 1; temp >>= 1) {
            ++_level;
            _TableIndexMask0 = ((_TableIndexMask0 << 1) | 1);
        }

        Debug.Assert(_H1(_bucketCount) == _bucketCount);

        _expansionIndex = _bucketCount & _TableIndexMask0;


        //
        // Create array of segment references
        //
        int dirCapacity = MIN_DIRSIZE; 
        while (dirCapacity < (_bucketCount >> _segBits))
            dirCapacity <<= 1;

        Debug.Assert(dirCapacity * _segSize >= _bucketCount);

        // verify that dirCapacity is a power of two
        Debug.Assert(dirCapacity >= MIN_DIRSIZE 
                    && (dirCapacity & (dirCapacity-1)) == 0);

        _segments = new Segment[dirCapacity];

        // create and initialize only the required segments
        // divide by 2^SEGBITS, .. rounding up
        int maxSegs = (_bucketCount + _segSize - 1) >> _segBits;

        // create the initial segments
        for (int i = 0; i < maxSegs; ++i) 
            _segments[i] = new Segment(_segSize); 


        Debug.Trace("LkrHashtable", "LinearHashtable.ctor  " + 
                    "_bucketCount = " + _bucketCount.ToString() + ", " +
                    "_segSize = " + _segSize + ", " +
                    "_segBits = " + _segBits + ", " +
                    "_segments.Length = " + _segments.Length + ", " + 
                    "maxSegs = " + maxSegs + ", " + 
                    "_maxLoad = " + _maxLoad);

        // REVIEW: TODO: PORT: catch out-of-memory errors and reset state?
        // REVIEW: What happens when an exception is thrown from a ctor in C#?
    }

#if IMPLEMENT_SYSTEM_COLLECTIONS
    // <IEnumerable interface>
    IEnumerator IEnumerable.GetEnumerator() {
        throw new InvalidOperationException();
    }
    // </IEnumerable interface>


    // <ICollection interface>
    void ICollection.CopyTo(Array destination, int destinationIndex) {
        // 00.08.22 ctracy: TODO: FIXME
        throw new InvalidOperationException();
    }


    int ICollection.Count {
        get {
            return Size;
        }
    }

    bool ICollection.IsSynchronized {
        get { return false; }
    }


    object ICollection.SyncRoot {
        get {
            // 00.08.22 ctracy: TODO: FIXME
            throw new InvalidOperationException();
        }
    }
    // </ICollection interface>


    // <IDictionary interface>
    public void Add(object key, object value) {
        Insert(key, value, true);
    }


    public void Clear() {
        _Clear();
    }


    public bool Contains(object key) {
        object value = FindKey(key);
        return value != null;
    }


    bool IDictionary.IsReadOnly {
        get { return false; }
    }

    bool IDictionary.IsFixedSize {
        get { return false; }
    }

    IDictionaryEnumerator IDictionary.GetEnumerator() {
        throw new InvalidOperationException();
    }


    public void Remove(object key) { 
        DeleteKey(key); 
    }


    public object this[object key] {
        get {
            return FindKey(key);
        }
        set {
            Insert(key, value, false);
        }
    }


    public ICollection Keys {
        get {
            throw new InvalidOperationException();
        }
    }


    public ICollection Values {
        get {
            throw new InvalidOperationException();
        }
    }
    // </IDictionary interface>
#endif // IMPLEMENT_SYSTEM_COLLECTIONS



    // <LKRHash interface>
    public object Insert(object key, object value) { 
        return Insert(key, value, false); 
    }


    // paramaters -
    //      bool onlyAdd
    //          false - allows overwriting at key
    //          true  - throws exception if key exists
    //          
    // return - returns the previous value at key
    //      Notes: return can be null key is new or if value at key is null
    public object Insert(object key, object value, bool onlyAdd) { 
        return _Insert(key, value, _GetHash(key), onlyAdd); 
    }


    public void DeleteKey(object key) {
        _DeleteKey(key, _GetHash(key));
    }


    public int Size{
        get{
            return _entryCount;
        }
    }


    public int MaxSize { 
        get {
            return (int)(_maxLoad * MAX_DIRSIZE * _segSize); 
        }
    }


    // return:
    //  null if key is not found
    //  otherwise, the value at that key
    public object FindKey(object key) { 
        return _FindKey(key, _GetHash(key)); 
    }
    // </LKRHash interface>


    public void CopyEntriesTo(DictionaryEntry [] entries, int destination) {

        Debug.Assert(_lock.IsReaderLockHeld  ||  _lock.IsWriterLockHeld);

        if (destination >= entries.Length || entries.Length - destination < Size) {
            throw new ArgumentOutOfRangeException("destination", destination, null);
        }

        for (int iBkt = 0;  iBkt < _bucketCount;  ++iBkt) {
            
            Bucket bucket = _Bucket(iBkt);
            Debug.Assert(bucket != null);
            bucket.AcquireReaderLock();
            try {
                if (bucket.Size != 0) {
                    Debug.Assert(destination + bucket.Size < entries.Length);
                    Array.Copy(bucket._entries, 0, entries, destination, bucket.Size);
                    destination += bucket.Size;
                }
            }
            finally {
                bucket.ReleaseReaderLock();
            }
        }
    }


    Bucket _FindBucket(int hashCode, bool lockForWrite) {

        AssertValid();
        Debug.Assert(_TableIndexMask0 > 0);
        Debug.Assert((_TableIndexMask0 & (_TableIndexMask0+1)) == 0); // 00011..111
        Debug.Assert(_TableIndexMask0 == (1U << _level) - 1);
        Debug.Assert(_TableIndexMask1 == ((_TableIndexMask0 << 1) | 1));
        Debug.Assert((_TableIndexMask1 & (_TableIndexMask1+1)) == 0);
        Debug.Assert(0 <= _expansionIndex && _expansionIndex <= _TableIndexMask0);
        Debug.Assert(2 < _segBits  &&  _segBits < 19
                   &&  _segSize == (1U << _segBits)
                   &&  _segMask == (_segSize - 1));
        Debug.Assert(_lock.IsReaderLockHeld  ||  _lock.IsWriterLockHeld);


        int tableIndex = _TableIndex(hashCode);
        Debug.Assert(tableIndex < _bucketCount);

        Bucket bucket = _Bucket(tableIndex);
        Debug.Assert(bucket != null);

        if (lockForWrite)
            bucket.AcquireWriterLock();
        else
            bucket.AcquireReaderLock();

        return bucket;
    }


    // Note: Needs to be internal so LkrHashtable can 
    //      call through without recalculating the hash code.
    internal object _Insert(object key, object value, int hashCode, bool onlyAdd) {

        if (key == null) {
            throw new ArgumentNullException("key");
        }

        object oldValue = null; // return value
        Bucket bucket = null;
        bool useLock = (IsWriterLockHeld == false);

        //
        // Find the begining of the correct bucket chain
        //
        // protect bucket lock
        try {

            if (useLock)
                AcquireWriterLock();

            // protect _lock
            try {
                // Must call AssertValid inside a lock to ensure that none of the state 
                // variables change while it's being evaluated
                AssertValid();

                bucket = _FindBucket(hashCode, true);
                Debug.Assert(bucket != null);
                Debug.Assert(bucket.IsWriterLockHeld);
        
                // Note: This Ensures that if a user aquires a writer lock on the 
                // LinearHashtable _entryCount can be used reliably as the upper-bound 
                // of the number of entries in the table.
                Interlocked.Increment(ref _entryCount);
            }
            finally {
                if (useLock)
                    ReleaseWriterLock();
            }

            int insertIndex = _ScanBucket(bucket, key, hashCode);

            if (insertIndex  == -1) {
                // entry not found, insert at tail
                bucket.Add(hashCode, key, value);
            }
            else {
                if (onlyAdd == true) {
                    // Insert() failed: key already exists.  
                    // To onlyAdd keys set onlyAdd=true.  Duplicate keys not supported.
                    throw new InvalidOperationException("key exists"); 
                }

                // key was not unique, so undo the Interlocked.Increment above
                Interlocked.Decrement(ref _entryCount);

                // found.. insert at found index
                Debug.Assert(0 <= insertIndex && insertIndex < bucket.Size);

                oldValue = bucket._entries[insertIndex].Value;

                // 00.08.22 ctracy:
                // Key is the same, so DON'T reassign the hashcode.
                // But, key is a reference object that could use value comparison
                // semantics, so DO assign the new key object (could be a 
                // different object with the same value).
                //bucket._codes[insertIndex] = hashCode;
                bucket._entries[insertIndex].Key = key;
                bucket._entries[insertIndex].Value = value;
            }
        }
        finally {
            if (bucket != null) {
                bucket.ReleaseWriterLock();
            }
        }

        while(_entryCount > _maxLoad * _bucketCount)
            _Expand();

        return oldValue;
    } // _Insert


    // returns:
    //  true  - key found and removed
    //  false - key not found
    //
    // Note: Needs to be internal so LkrHashtable can 
    //      call through without recalculating the hash code.
    internal bool _DeleteKey(object key, int hashCode) {

        bool retCode = false;
        Bucket bucket = null;
        bool useLock = (IsWriterLockHeld == false);

        //
        // Locate the beginning of the correct bucket chain
        // 

        // protect bucket lock from exceptions
        try { 

            if (useLock)
                AcquireWriterLock();
            // protect table lock from exceptions
            try { 
                // Must call AssertValid inside a lock to ensure that none of the state
                // variables change while it's being evaluated
                AssertValid();

                bucket = _FindBucket(hashCode, true);
                Debug.Assert(bucket != null);
                Debug.Assert(bucket.IsWriterLockHeld);
            }
            finally {
                if (useLock)
                    ReleaseWriterLock();
            }

            // scan down the bucket chain, looking for the victim
            int i = _ScanBucket(bucket, key, hashCode);
            if (i != -1) {
                bucket.RemoveAt(i);
                retCode = true;
            }

        }
        finally {
            if (bucket != null)
                bucket.ReleaseWriterLock();
        }

        if (retCode == true) {

            Interlocked.Decrement(ref _entryCount);

            // contract the table if necessary
            Debug.Assert(_maxLoad >= 1.0);
            if (_entryCount < _maxLoad * _bucketCount && _bucketCount > _segSize * MIN_DIRSIZE) {
                _Contract();
            }
        }

        return retCode;
    } // _DeleteKey


    // return:
    //  -1 if not found
    //  otherwise, index of found key
    int _ScanBucket(Bucket bucket, object key, int hashCode) {

        if (_comparer == null) {
            for (int i = 0;i < bucket.Size; ++i)
                if (hashCode == bucket._codes[i] && bucket._entries[i].Key.Equals(key))
                    return i;
        }
        else {
            for (int i = 0;i < bucket.Size; ++i) {
                if (hashCode == bucket._codes[i] && 0 == _comparer.Compare(bucket._entries[i].Key, key)) {
                    return i;
                }
            }
        }
        return -1;
    }


    // return:
    //  null if key is not found
    //  otherwise, the value at that key
    //
    // Note: Needs to be internal so LkrHashtable can 
    //      call through without recalculating the hash code.
    internal object _FindKey(object key, int hashCode) {

        if (key == null) {
            throw new ArgumentNullException("key");
        }

        object retVal = null;
        Bucket bucket = null;
        
        try {
            // locate the beginning of the correct bucket chain

            bool isWriteLockHeld = _lock.IsWriterLockHeld;

            // If this thread already holds the WriteLock, then
            // don't deadlock by trying to acquire a ReadLock
            if (isWriteLockHeld == false) {
                AcquireReaderLock();
            }

            try {
                // Must call AssertValid inside a lock to ensure that none of the state
                // variables change while it's being evaluated
                AssertValid();

                bucket = _FindBucket(hashCode, false);
                Debug.Assert(bucket != null);
                Debug.Assert(bucket.IsReaderLockHeld);
            } 
            finally {
                if (isWriteLockHeld == false) {
                    ReleaseReaderLock();
                }
            }

            int i = _ScanBucket(bucket, key, hashCode);
            if (i != -1) {
                retVal = bucket._entries[i].Value;
            }
        }
        finally {
            if (bucket != null)
                bucket.ReleaseReaderLock();
        }

        return retVal;
    }

    // PORT: TODO: implement stats conditionals and GetStatistics()

    void _Expand() {

        if (_bucketCount >= MaxSize)
            throw new InvalidOperationException("bucket count maximum exceeded");


        Bucket oldBucket = null;
        Bucket newBucket = null;
        bool useLock = (IsWriterLockHeld == false);

        // protect bucket locks
        try {
            int expansionIndexCopy;  // used to avoid race conditions
            int tableIndexMask0Copy; // ditto
            int oldBucketIndex;
            int newBucketIndex;



            if (useLock)
                AcquireWriterLock();
            // protect LinearHashtable lock
            try  {

                // double segment directory size if necessary
                if (_bucketCount >= _segments.Length * _segSize) {
                    Segment [] newSegments = new Segment[_segments.Length << 1];
                    _segments.CopyTo(newSegments, 0);
                    _segments = newSegments;
                }
        
                // locate a new bucket, creating a new segment if necessary
                oldBucketIndex = _expansionIndex;
                newBucketIndex = (1 << _level) | oldBucketIndex;

                Debug.Assert(oldBucketIndex <= _bucketCount);
                Debug.Assert(newBucketIndex <= _bucketCount);

                Debug.Assert(_Segment(oldBucketIndex) != null);
                Segment newSegment = _Segment(newBucketIndex);

                //
                // Normally, the new bucket is the next unused bucket in the segment.
                // If the new bucket crosses a segment boundary we need to allocate the new segment
                //
                if (newSegment == null) {
                    newSegment = new Segment(_segSize);
                    _Segment(newBucketIndex, newSegment);
                    //_segments.Add(newSegment);
                }

                ++_bucketCount;

                // prepare to shuffle records from oldBucket to newBucket
                oldBucket = _Bucket(oldBucketIndex);
                oldBucket.AcquireWriterLock();
                newBucket = _Bucket(newBucketIndex);
                newBucket.AcquireWriterLock();

                // adjust expansion index, level, and mask
               ++_expansionIndex;
               if (_expansionIndex == (1 << _level)) { // have we doubled again?
                   ++_level;
                   _expansionIndex = 0;
                   _TableIndexMask0 = ((_TableIndexMask0 << 1) | 1); // shift and fill bit field
                   // _TableIndexMask0 = 00011..111
                   Debug.Assert((_TableIndexMask0 & (_TableIndexMask0 + 1)) == 0);
                   Debug.Assert((_TableIndexMask1 & (_TableIndexMask1 + 1)) == 0);
               }

               expansionIndexCopy = _expansionIndex;  // save to avoid race conditions
               tableIndexMask0Copy= _TableIndexMask0; // ditto
            }
            finally {
                if (useLock)
                    ReleaseWriterLock();
            }

            _SplitBucket(oldBucket, newBucket, 
                            expansionIndexCopy,
                            tableIndexMask0Copy,
                            newBucketIndex);
        }
        finally {
            if (oldBucket != null)
                oldBucket.ReleaseWriterLock();
            if (newBucket != null)
                newBucket.ReleaseWriterLock();
        }
    } // _Expand()


    // caller is responsible for locking/unlocking oldBucket and newBucket
    static internal void _SplitBucket(Bucket oldBucket, 
                                Bucket newBucket, 
                                int expansionIndex, 
                                int tableIndexMask0, 
                                int newBucketIndex) {
        int iDest = 0;
        for(int i = 0; i < oldBucket.Size; ++i) {
            // index - bucket index of this node
            int code = oldBucket._codes[i];
            int index = _H0(code, tableIndexMask0);
            if (index < expansionIndex)
                index = _H1(code, tableIndexMask0);

            if (index == newBucketIndex) {
                newBucket.Add(code, oldBucket._entries[i].Key, oldBucket._entries[i].Value);
            } else {
                // compact nodes kept in oldBucket
                if (i != iDest) { // avoid assignment until first node is moved into newBucket
                    oldBucket._codes[iDest] = oldBucket._codes[i];
                    oldBucket._entries[iDest] = oldBucket._entries[i];
                }

                // this destination has been used, set to next one
                ++iDest;
            }
        }

        // the next (unused) destination node is the new size of the bucket
        if (iDest < oldBucket.Size) {
            // Bucket.set_Size calls Bucket._SetSize which is responsible 
            // for shrinking the capacity or setting old references to null.
            oldBucket.Size = iDest;
        }
    } // _SplitBucket


    //
    // 00.08.16 ctracy: Notes:
    // _Contract is used in conjunction with Bucket.PrepareMerge and Bucket.Merge
    // In order to make state consistant in cases of memory allocation failures.
    // We use PrepareMerge to allocate any memory (returned as a pseudo-bucket) before 
    // we update the LinearHashtable's state variables.  After the LinearHashtable lock is 
    // released we merge the old bucket, new bucket, and if necessary the bucket holding the
    // newly allocated memory.
    //
    void _Contract() {
        Bucket newBucket = null;
        Bucket lastBucket = null;
        Bucket placeHolder = null; // placeHolder for allocated memory, nothing else
        bool useLock = (IsWriterLockHeld == false);

        // protect newBucket and oldBucket locks
        try { 
            if (useLock)
                AcquireWriterLock();

            // protect table lock
            try  {
                //
                // Calculate new state variables.
                // (But don't set them until after memeory allocation.)
                //
                bool changeLevel;
                int newExpansionIndex;

                if (_expansionIndex == 0) {
                    changeLevel = true;
                    newExpansionIndex = (1 << (_level - 1)) - 1;
                }
                else {
                    changeLevel = false;
                    newExpansionIndex = _expansionIndex - 1;
                }

                //lastBucket = _Bucket(_bucketCount - 1);
                int lastBucketIndex = _bucketCount - 1;
                lastBucket = _Bucket(lastBucketIndex);
                lastBucket.AcquireWriterLock();

                // Where the nodes from pbktLast will end up
                newBucket = _Bucket(newExpansionIndex);
                newBucket.AcquireWriterLock();

                // 
                // If we need to allocate memory, do it before updating 
                // member variables, in case memory allocation fails.
                //
                placeHolder = newBucket.PrepareMerge(lastBucket);


                //
                // Update the state variables (expansion index, level, and mask)
                // 
                --_bucketCount;
                _expansionIndex = newExpansionIndex;
                if (changeLevel) {
                    --_level;
                    Debug.Assert(_level > 0 && _expansionIndex > 0);
                    _TableIndexMask0 >>= 1;
                   // _TableIndexMask0 = 00011..111
                   Debug.Assert((_TableIndexMask0 & (_TableIndexMask0 + 1)) == 0);
                   // PORT: Note: Mask1 no longer held as state var... always computed.
                   Debug.Assert((_TableIndexMask1 & (_TableIndexMask1 + 1)) == 0);
                }

                // if last segment is now empty remove it
                if (_BucketIndex(_bucketCount) == 0) {
#if DEBUG
                    // double-check that the supposedly empty segment is really empty
                    Debug.Assert(_Segment(_bucketCount) != null);

                    // Note: i = 1 // skip lastBucket
                    for (int i = 1; i < _segSize; ++i)  {
                        Bucket bucket = (_Segment(_bucketCount)[i]);
                        Debug.Assert(bucket.IsWriterLockHeld == false && bucket.IsReaderLockHeld == false);
                        bucket.AcquireReaderLock(); // no try necessary - dbg check only
                        Debug.Assert(bucket.Size == 0);
                        bucket.ReleaseReaderLock();
                    }
#endif // DEBUG
                    _Segment(_bucketCount, null); // remove last segment
                    // CONSIDER: resizing _segments when it gets small enough
                }

            }
            finally {
                // release the table lock before doing the reorg
                if (useLock)
                    ReleaseWriterLock();
            }

            //
            // Copy all entries from "lastBucket" to "newBucket"
            //
            newBucket.Merge(lastBucket, placeHolder);

        }
        finally {
            if (newBucket != null)
                newBucket.ReleaseWriterLock();
            if (lastBucket != null)
                lastBucket.ReleaseWriterLock();
        }
    } // _Contract

    
    public void AcquireReaderLock() { _lock.AcquireReaderLock(); }
    public void AcquireWriterLock() { _lock.AcquireWriterLock(); }
    public void ReleaseReaderLock() { _lock.ReleaseReaderLock(); }
    public void ReleaseWriterLock() { _lock.ReleaseWriterLock(); }
    // does this thread hold the write lock?
    public bool IsWriterLockHeld { get { return _lock.IsWriterLockHeld; } }
    // does any thread hold the read lock?
    public bool IsReaderLockHeld { get { return _lock.IsReaderLockHeld; } }


    [System.Diagnostics.Conditional("DEBUG")] 
    public void AssertValid() { 
        // STATIC_ASSERT
        Debug.Assert(((MIN_DIRSIZE & (MIN_DIRSIZE-1)) == 0)  // == (1 << N)
                      &&  ((1 << 3) <= MIN_DIRSIZE)
                      &&  (MIN_DIRSIZE < MAX_DIRSIZE)
                      &&  ((MAX_DIRSIZE & (MAX_DIRSIZE-1)) == 0)
                      &&  (MAX_DIRSIZE <= (1 << 30)));

        // Debug.Assert(_segments != null); -- now Directory is a struct 
        Debug.Assert(MIN_DIRSIZE <= _segments.Length  &&  _segments.Length <= MAX_DIRSIZE);
        Debug.Assert((_segments.Length & (_segments.Length-1)) == 0);
        Debug.Assert(_bucketCount > 0);
    }


    public static Type LockType { 
        get { 
            return typeof(ReadWriteSpinLock);
        } 
    }


//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Clear
// Synopsis: Remove all data from the table
//------------------------------------------------------------------------

    // PORT: TODO: Clear()
    void _Clear() { // Shrink to min size but don't destroy entirely
        Debug.Assert(IsWriterLockHeld);

        if (_segments.Length > MIN_DIRSIZE) {
            Segment [] segmentsNew = new Segment[MIN_DIRSIZE];
        
            for (int j = 0;  j < MIN_DIRSIZE;  j++) {
                segmentsNew[j] = _segments[j];
            }

            _segments = segmentsNew;

            _level = _segBits;
            _bucketCount = MIN_DIRSIZE * _segSize;
            _TableIndexMask0 = _segBits;

            for (int tmp = _bucketCount >> _segBits;
                    tmp > 1;
                    tmp >>= 1) {
                ++_level;
                _TableIndexMask0 =  _TableIndexMask1;
            }
        
            Debug.Assert(_H1(_bucketCount) == _bucketCount);
            _expansionIndex = _bucketCount & _TableIndexMask0;
        } 

        for (int iBkt = 0;  iBkt < _bucketCount;  ++iBkt) {
            
            Bucket bucket = _Bucket(iBkt);
            Debug.Assert(bucket != null);
            bucket.AcquireWriterLock();
            try {
#if DEBUG
                _entryCount -= bucket.Size;
#endif
                //
                // Size set property will (1) shrink to min size (if necessar) and 
                // (2) clear old hashcodes, key references, and object references.
                //
                bucket.Size = 0;
            }
            finally {
                bucket.ReleaseWriterLock();
            }
        }

        Debug.Assert(_entryCount == 0);
        _entryCount = 0;
    }



    internal sealed class Bucket {


        internal void AcquireReaderLock() {
            _lock.AcquireReaderLock();
        }


        internal void AcquireWriterLock() {
            _lock.AcquireWriterLock();
        }


        internal void ReleaseReaderLock() {
            _lock.ReleaseReaderLock();
        }


        internal void ReleaseWriterLock() {
            _lock.ReleaseWriterLock();
        }


        internal bool IsWriterLockHeld {
            get {
                return _lock.IsWriterLockHeld;
            }
        }


        internal bool IsReaderLockHeld {
            get {
                return _lock.IsReaderLockHeld;
            }
        }


        internal const int INITIAL_CAPACITY = 8;


        int _size;
        internal int [] _codes; // cached hashcodes
        internal DictionaryEntry [] _entries;
        ReadWriteSpinLock _lock;


        internal Bucket() : this(INITIAL_CAPACITY) {
        }


        internal Bucket(int capacity) {
            _lock = new ReadWriteSpinLock("Lkr.Bucket");
            _codes = new int[capacity];               // cached hashcodes
            _entries = new DictionaryEntry[capacity]; // key-value pairs
        }


        internal int Size { 
            get {
                Debug.Assert(_lock.IsLockHeld);
                return _size; 
            } 
            set {
                Debug.Assert(_lock.IsWriterLockHeld);
                _SetSize(value);
            }
        }


        int _Capacity { 
            get { 
                Debug.Assert(_lock.IsLockHeld);
                return _codes.Length; 
            } 
        }


        internal void Add(int code, object key, object value) {

            Debug.Assert(_lock.IsWriterLockHeld);

            int i = _size;
            Size = _size + 1; // grows arrays

            _codes[i] = code;
            _entries[i].Key = key;
            _entries[i].Value = value;
        }


        internal void RemoveAt(int index) {

            Debug.Assert(_lock.IsWriterLockHeld);
            Debug.Assert(0 <= index && index < _size);

            int last = _size-1;

            _codes[index] = _codes[last];
            _entries[index] = _entries[last];

            Size = _size - 1; // shrinks arrays
        }


#if DEBUG
        // 00.08.15 ctracy: HACK: 
        static int s_highestCapacity = INITIAL_CAPACITY;
#endif
        void _SetSize(int newSize) {
            Debug.Assert(_lock.IsWriterLockHeld);

            int newCapacity = _Capacity; // capacity starts as current capacity

            if (newSize < Size) {

                // Is shrink necessary?
                while (newCapacity > INITIAL_CAPACITY && newSize < ((newCapacity >> 1) - 2)) {
                    newCapacity >>= 1;
                }

                Debug.Assert(newSize <= newCapacity);
                newCapacity = Math.Max(newCapacity, INITIAL_CAPACITY);

                if (newCapacity == _Capacity) {
                    for (int i = newSize; i < Size; ++i) {
                        // allow GC to reclaim referenced memory
                        _codes[i] = 0;
                        _entries[i].Key = null;
                        _entries[i].Value = null;
                    }
                }
            }
            // Is grow necessary?
            else if (newSize > newCapacity) {
                while (newSize > newCapacity)
                    newCapacity <<= 1;
            }

            // Adjust Capacity - allocate new arrays and copy entries
            if (newCapacity != _Capacity) {
                Debug.Assert(newCapacity >= INITIAL_CAPACITY);
                Debug.Assert(newCapacity >= newSize);

#if DEBUG
                // 00.08.15 ctracy: HACK: 
                // if this fails we've got problems in our hash algorithm or a bug in the hashtable
                Debug.Assert(newCapacity < 300); 

                // 00.08.15 ctracy: HACK: REMOVE BEFORE SHIP
                if (newCapacity > s_highestCapacity) {
                    s_highestCapacity = newCapacity;
                    Debug.Trace("LkrHashtable", "LkrPerf: growing Bucket capacity to " + s_highestCapacity);
                }
#endif

                DictionaryEntry [] newEntries = new DictionaryEntry[newCapacity];
                int [] newCodes = new int[newCapacity];
                // Pub s Void Copy (Array sourceArray, Array destinationArray, Int32 length) 
                int copySize = Math.Min(_size, newSize);
                Array.Copy(_entries, newEntries, copySize);
                Array.Copy(_codes, newCodes, copySize);
                _entries = newEntries;
                _codes = newCodes;
            }

            _size = newSize;
        }


        // see _Contract for notes on PrepareMerge and Merge
        internal Bucket PrepareMerge(Bucket oldBucket) {

            Debug.Assert(_lock.IsWriterLockHeld);
            int newSize = Size + oldBucket.Size;
            int largerCapacity = Math.Max(_Capacity, oldBucket._Capacity);

            if (newSize > largerCapacity) {
                largerCapacity <<= 1;
                return new Bucket(largerCapacity);
            }

            return null;
        }


        // see _Contract for notes on PrepareMerge and Merge
        internal void Merge(Bucket oldBucket, Bucket placeHolder) {

            Debug.Assert(_lock.IsWriterLockHeld);
            Debug.Assert(oldBucket._lock.IsWriterLockHeld);
            int newSize = Size + oldBucket.Size;

            if (_Capacity < oldBucket._Capacity) {
                int [] tempCodes = this._codes;
                DictionaryEntry [] tempEntries = this._entries;
                int tempSize = this._size;
                this._codes   = oldBucket._codes;
                this._entries = oldBucket._entries;
                this._size    = oldBucket._size;
                oldBucket._codes   = tempCodes;
                oldBucket._entries = tempEntries;
                oldBucket._size    = tempSize;
            }

            if (placeHolder != null) {
                // Capacity adjustments are made in PrepareMerge() to 
                // localize memory allocation failures
                Debug.Assert(newSize <= placeHolder._Capacity);

                this._codes  .CopyTo(placeHolder._codes,   0);
                this._entries.CopyTo(placeHolder._entries, 0);
                this._codes   = placeHolder._codes;
                this._entries = placeHolder._entries;
            }

            Debug.Assert(newSize <= this._Capacity);

            // Pub s Void Copy (Array sourceArray, Int32 sourceIndex, 
            //                  Array destinationArray, Int32 destinationIndex, Int32 length)
            Array.Copy(oldBucket._codes,   0, 
                       this._codes,   this._size, oldBucket._size);
            Array.Copy(oldBucket._entries, 0, 
                       this._entries, this._size, oldBucket._size);
            this._size = newSize;

            // Release references and if necessary shrink memory of old bucket.
            try {
                oldBucket.Size = 0;  // ignore memory allocation failures at this point
            }
            catch {
                oldBucket._size = 0; // if allocation in _SetSize failes, make sure state is consistant
                throw;
            }
        }


        internal static Type LockType { 
            get { 
                return typeof(ReadWriteSpinLock); 
            } 
        }
    } // Bucket


    internal sealed class Segment {

        internal const int SmallBits = 3;
        internal const int SmallSegSize  = (1<<SmallBits); // bucket count per segment
        internal const int SmallSegMask  = SmallSegSize-1; // index mask
        internal const int SmallSegmentCount = 1; // initial # of segments per LinearHashtable
        internal const int SmallInitSize = SmallSegSize * SmallSegmentCount; // total initial buckets per LinearHashtable
        internal const int MediumBits = 6;
        internal const int MediumSegSize  = (1<<MediumBits);
        internal const int MediumSegMask  = MediumSegSize-1;
        internal const int MediumSegmentCount = 2;
        internal const int MediumInitSize = MediumSegSize * MediumSegmentCount;
        internal const int LargeBits = 9;
        internal const int LargeSegSize  = (1<<LargeBits);
        internal const int LargeSegMask  = LargeSegSize-1;
        internal const int LargeSegmentCount = 4;
        internal const int LargeInitSize = LargeSegSize * LargeSegmentCount;


        Bucket [] _buckets;


        internal Segment(int size) {

            Debug.Assert(   size == SmallSegSize || 
                            size == MediumSegSize || 
                            size == LargeSegSize);

            _buckets = new Bucket[size];
            for(int i = 0; i < size; ++i)
                _buckets[i] = new Bucket();
        }

        
        internal Bucket this[int index]  { 
            get { 
                return _buckets[index]; 
            }
            set { 
                _buckets[index] = value; 
            }
        }

    } // Segment
} // LinearHashtable


} // Util.Lkr
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\datacomp\adoid.h ===
//------------------------------------------------------------------------------
// <copyright file="ADOID.H" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ADOID.H
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
//--------------------------------------------------------------------
// Microsoft ADO
//
// (c) 1998 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module	adoid.h | ADO Guids
//
// @devnote None
//--------------------------------------------------------------------

#ifndef _ADOID_H_
#define _ADOID_H_

#define DEFINE_ADOGUID(name, l) \
    DEFINE_GUID(name, l, 0, 0x10, 0x80,0,0,0xAA,0,0x6D,0x2E,0xA4)

#define ADO_MAJOR	2		// major version of the ADO type library

#if (MDACVER >=21)
	#define ADO_VERSION 2.1
#else
	#define ADO_VERSION	2.0
#endif

// Type library
DEFINE_ADOGUID(LIBID_ADO20,				0x00000200);
DEFINE_ADOGUID(LIBID_ADOR20,			0x00000300);

// defined for backwards compatibility
#define LIBID_CADO10	LIBID_ADO20
#define LIBID_CADOR10	LIBID_ADOR20

// Error
DEFINE_ADOGUID(IID_IADOError,            0x00000500);
DEFINE_ADOGUID(IID_IADOErrors,           0x00000501);

// Property
DEFINE_ADOGUID(IID_IADOProperty,         0x00000503);
DEFINE_ADOGUID(IID_IADOProperties,       0x00000504);

// Field
DEFINE_ADOGUID(CLSID_CADOField,			 0x0000053A);
DEFINE_ADOGUID(IID_IADOField15,            0x00000505);
DEFINE_ADOGUID(IID_IADOField,            0x0000054C);
DEFINE_ADOGUID(IID_IADOFields15,           0x00000506);
DEFINE_ADOGUID(IID_IADOFields,           0x0000054D);


// Command
DEFINE_ADOGUID(CLSID_CADOCommand,		0x00000507);
DEFINE_ADOGUID(IID_IADOCommand15,			0x00000508);
DEFINE_ADOGUID(IID_IADOCommand,			0x0000054E);
DEFINE_ADOGUID(IID_IADOCommands,        0x00000509);

// Parameter
DEFINE_ADOGUID(CLSID_CADOParameter,		0x0000050B);
DEFINE_ADOGUID(IID_IADOParameter,        0x0000050C);
DEFINE_ADOGUID(IID_IADOParameters,       0x0000050D);

//Recordset
DEFINE_ADOGUID(CLSID_CADORecordset, 	 0x00000535);
DEFINE_ADOGUID(IID_IADORecordset15,		 0x0000050E);
DEFINE_ADOGUID(IID_IADORecordset,		 0x0000054F);
DEFINE_ADOGUID(IID_IADORecordsets,		 0x0000050F);
DEFINE_ADOGUID(IID_IADORecordsetConstruction,     0x00000283);

// Collections
DEFINE_ADOGUID(IID_IADOCollection,       0x00000512);
DEFINE_ADOGUID(IID_IADODynaCollection,   0x00000513);

// Connection
DEFINE_ADOGUID(CLSID_CADOConnection,	   0x00000514);
DEFINE_ADOGUID(IID_IADOConnection15,	   0x00000515);
DEFINE_ADOGUID(IID_IADOConnection,	   0x00000550);
DEFINE_ADOGUID(IID_IADOConnectionConstruction15,	   0x00000516);
DEFINE_ADOGUID(IID_IADOConnectionConstruction,	   0x00000551);
DEFINE_ADOGUID(IID_IADOConnections,		   0x00000518);

// events
// dispatch interfaces
DEFINE_ADOGUID(IID_IADORecordsetEvents,	   0x00000266);
DEFINE_ADOGUID(IID_IADOConnectionEvents,   0x00000400);
// vtable interfaces
DEFINE_ADOGUID(IID_IADORecordsetEventsVt,   0x00000403);
DEFINE_ADOGUID(IID_IADOConnectionEventsVt,  0x00000402);


#endif // _ADOID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\datacomp\adomd.h ===
//------------------------------------------------------------------------------
// <copyright file="ADOMD.H" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ADOMD.H
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Fri May 22 21:32:15 1998
 */
/* Compiler settings for ADOMD.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __ADOMD_h__
#define __ADOMD_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ICatalog_FWD_DEFINED__
#define __ICatalog_FWD_DEFINED__
typedef interface ICatalog ICatalog;
#endif 	/* __ICatalog_FWD_DEFINED__ */


#ifndef __ICellset_FWD_DEFINED__
#define __ICellset_FWD_DEFINED__
typedef interface ICellset ICellset;
#endif 	/* __ICellset_FWD_DEFINED__ */


#ifndef __Cell_FWD_DEFINED__
#define __Cell_FWD_DEFINED__
typedef interface Cell Cell;
#endif 	/* __Cell_FWD_DEFINED__ */


#ifndef __Axis_FWD_DEFINED__
#define __Axis_FWD_DEFINED__
typedef interface Axis Axis;
#endif 	/* __Axis_FWD_DEFINED__ */


#ifndef __Position_FWD_DEFINED__
#define __Position_FWD_DEFINED__
typedef interface Position Position;
#endif 	/* __Position_FWD_DEFINED__ */


#ifndef __Member_FWD_DEFINED__
#define __Member_FWD_DEFINED__
typedef interface Member Member;
#endif 	/* __Member_FWD_DEFINED__ */


#ifndef __Level_FWD_DEFINED__
#define __Level_FWD_DEFINED__
typedef interface Level Level;
#endif 	/* __Level_FWD_DEFINED__ */


#ifndef __CubeDef_FWD_DEFINED__
#define __CubeDef_FWD_DEFINED__
typedef interface CubeDef CubeDef;
#endif 	/* __CubeDef_FWD_DEFINED__ */


#ifndef __Dimension_FWD_DEFINED__
#define __Dimension_FWD_DEFINED__
typedef interface Dimension Dimension;
#endif 	/* __Dimension_FWD_DEFINED__ */


#ifndef __Hierarchy_FWD_DEFINED__
#define __Hierarchy_FWD_DEFINED__
typedef interface Hierarchy Hierarchy;
#endif 	/* __Hierarchy_FWD_DEFINED__ */


#ifndef __MD_Collection_FWD_DEFINED__
#define __MD_Collection_FWD_DEFINED__
typedef interface MD_Collection MD_Collection;
#endif 	/* __MD_Collection_FWD_DEFINED__ */


#ifndef __Members_FWD_DEFINED__
#define __Members_FWD_DEFINED__
typedef interface Members Members;
#endif 	/* __Members_FWD_DEFINED__ */


#ifndef __Levels_FWD_DEFINED__
#define __Levels_FWD_DEFINED__
typedef interface Levels Levels;
#endif 	/* __Levels_FWD_DEFINED__ */


#ifndef __Axes_FWD_DEFINED__
#define __Axes_FWD_DEFINED__
typedef interface Axes Axes;
#endif 	/* __Axes_FWD_DEFINED__ */


#ifndef __Positions_FWD_DEFINED__
#define __Positions_FWD_DEFINED__
typedef interface Positions Positions;
#endif 	/* __Positions_FWD_DEFINED__ */


#ifndef __Hierarchies_FWD_DEFINED__
#define __Hierarchies_FWD_DEFINED__
typedef interface Hierarchies Hierarchies;
#endif 	/* __Hierarchies_FWD_DEFINED__ */


#ifndef __Dimensions_FWD_DEFINED__
#define __Dimensions_FWD_DEFINED__
typedef interface Dimensions Dimensions;
#endif 	/* __Dimensions_FWD_DEFINED__ */


#ifndef __CubeDefs_FWD_DEFINED__
#define __CubeDefs_FWD_DEFINED__
typedef interface CubeDefs CubeDefs;
#endif 	/* __CubeDefs_FWD_DEFINED__ */


#ifndef __Catalog_FWD_DEFINED__
#define __Catalog_FWD_DEFINED__

#ifdef __cplusplus
typedef class Catalog Catalog;
#else
typedef struct Catalog Catalog;
#endif /* __cplusplus */

#endif 	/* __Catalog_FWD_DEFINED__ */


#ifndef __Cellset_FWD_DEFINED__
#define __Cellset_FWD_DEFINED__

#ifdef __cplusplus
typedef class Cellset Cellset;
#else
typedef struct Cellset Cellset;
#endif /* __cplusplus */

#endif 	/* __Cellset_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_ADOMD_0000
 * at Fri May 22 21:32:15 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 





















#define TARGET_IS_NT40_OR_LATER   1


extern RPC_IF_HANDLE __MIDL_itf_ADOMD_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ADOMD_0000_v0_0_s_ifspec;


#ifndef __ADOMD_LIBRARY_DEFINED__
#define __ADOMD_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: ADOMD
 * at Fri May 22 21:32:15 1998
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 


typedef /* [uuid] */ 
enum MemberTypeEnum
    {	adMemberUnknown	= 0,
	adMemberRegular	= 0x1,
	adMemberAll	= 0x2,
	adMemberMeasure	= 0x3,
	adMemberFormula	= 0x4
    }	MemberTypeEnum;


EXTERN_C const IID LIBID_ADOMD;

#ifndef __ICatalog_INTERFACE_DEFINED__
#define __ICatalog_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatalog
 * at Fri May 22 21:32:15 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ICatalog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("228136B1-8BD3-11D0-B4EF-00A0C9138CA4")
    ICatalog : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propputref] */ HRESULT STDMETHODCALLTYPE putref_ActiveConnection( 
            /* [in] */ IDispatch __RPC_FAR *pconn) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ActiveConnection( 
            /* [in] */ BSTR bstrConn) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ActiveConnection( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppConn) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_CubeDefs( 
            /* [retval][out] */ CubeDefs __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatalog __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatalog __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICatalog __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ICatalog __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_ActiveConnection )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pconn);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActiveConnection )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrConn);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActiveConnection )( 
            ICatalog __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppConn);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CubeDefs )( 
            ICatalog __RPC_FAR * This,
            /* [retval][out] */ CubeDefs __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } ICatalogVtbl;

    interface ICatalog
    {
        CONST_VTBL struct ICatalogVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatalog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatalog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatalog_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICatalog_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICatalog_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICatalog_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICatalog_get_Name(This,pbstr)	\
    (This)->lpVtbl -> get_Name(This,pbstr)

#define ICatalog_putref_ActiveConnection(This,pconn)	\
    (This)->lpVtbl -> putref_ActiveConnection(This,pconn)

#define ICatalog_put_ActiveConnection(This,bstrConn)	\
    (This)->lpVtbl -> put_ActiveConnection(This,bstrConn)

#define ICatalog_get_ActiveConnection(This,ppConn)	\
    (This)->lpVtbl -> get_ActiveConnection(This,ppConn)

#define ICatalog_get_CubeDefs(This,ppvObject)	\
    (This)->lpVtbl -> get_CubeDefs(This,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE ICatalog_get_Name_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB ICatalog_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref] */ HRESULT STDMETHODCALLTYPE ICatalog_putref_ActiveConnection_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pconn);


void __RPC_STUB ICatalog_putref_ActiveConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICatalog_put_ActiveConnection_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrConn);


void __RPC_STUB ICatalog_put_ActiveConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICatalog_get_ActiveConnection_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppConn);


void __RPC_STUB ICatalog_get_ActiveConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICatalog_get_CubeDefs_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [retval][out] */ CubeDefs __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB ICatalog_get_CubeDefs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatalog_INTERFACE_DEFINED__ */


#ifndef __ICellset_INTERFACE_DEFINED__
#define __ICellset_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICellset
 * at Fri May 22 21:32:15 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ICellset;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2281372A-8BD3-11D0-B4EF-00A0C9138CA4")
    ICellset : public IDispatch
    {
    public:
        virtual /* [id][vararg][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *idx,
            /* [retval][out] */ Cell __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [optional][in] */ VARIANT DataSource,
            /* [optional][in] */ VARIANT ActiveConnection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual /* [propputref] */ HRESULT STDMETHODCALLTYPE putref_Source( 
            /* [in] */ IDispatch __RPC_FAR *pcmd) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Source( 
            /* [in] */ BSTR bstrCmd) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Source( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvSource) = 0;
        
        virtual /* [propputref] */ HRESULT STDMETHODCALLTYPE putref_ActiveConnection( 
            /* [in] */ IDispatch __RPC_FAR *pconn) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ActiveConnection( 
            /* [in] */ BSTR bstrConn) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ActiveConnection( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppConn) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ LONG __RPC_FAR *plState) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Axes( 
            /* [retval][out] */ Axes __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FilterAxis( 
            /* [retval][out] */ Axis __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICellsetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICellset __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICellset __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICellset __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICellset __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICellset __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICellset __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICellset __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][vararg][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ICellset __RPC_FAR * This,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *idx,
            /* [retval][out] */ Cell __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            ICellset __RPC_FAR * This,
            /* [optional][in] */ VARIANT DataSource,
            /* [optional][in] */ VARIANT ActiveConnection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            ICellset __RPC_FAR * This);
        
        /* [propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Source )( 
            ICellset __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pcmd);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Source )( 
            ICellset __RPC_FAR * This,
            /* [in] */ BSTR bstrCmd);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Source )( 
            ICellset __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvSource);
        
        /* [propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_ActiveConnection )( 
            ICellset __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pconn);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActiveConnection )( 
            ICellset __RPC_FAR * This,
            /* [in] */ BSTR bstrConn);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActiveConnection )( 
            ICellset __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppConn);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            ICellset __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plState);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Axes )( 
            ICellset __RPC_FAR * This,
            /* [retval][out] */ Axes __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FilterAxis )( 
            ICellset __RPC_FAR * This,
            /* [retval][out] */ Axis __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            ICellset __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } ICellsetVtbl;

    interface ICellset
    {
        CONST_VTBL struct ICellsetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICellset_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICellset_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICellset_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICellset_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICellset_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICellset_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICellset_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICellset_get_Item(This,idx,ppvObject)	\
    (This)->lpVtbl -> get_Item(This,idx,ppvObject)

#define ICellset_Open(This,DataSource,ActiveConnection)	\
    (This)->lpVtbl -> Open(This,DataSource,ActiveConnection)

#define ICellset_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define ICellset_putref_Source(This,pcmd)	\
    (This)->lpVtbl -> putref_Source(This,pcmd)

#define ICellset_put_Source(This,bstrCmd)	\
    (This)->lpVtbl -> put_Source(This,bstrCmd)

#define ICellset_get_Source(This,pvSource)	\
    (This)->lpVtbl -> get_Source(This,pvSource)

#define ICellset_putref_ActiveConnection(This,pconn)	\
    (This)->lpVtbl -> putref_ActiveConnection(This,pconn)

#define ICellset_put_ActiveConnection(This,bstrConn)	\
    (This)->lpVtbl -> put_ActiveConnection(This,bstrConn)

#define ICellset_get_ActiveConnection(This,ppConn)	\
    (This)->lpVtbl -> get_ActiveConnection(This,ppConn)

#define ICellset_get_State(This,plState)	\
    (This)->lpVtbl -> get_State(This,plState)

#define ICellset_get_Axes(This,ppvObject)	\
    (This)->lpVtbl -> get_Axes(This,ppvObject)

#define ICellset_get_FilterAxis(This,ppvObject)	\
    (This)->lpVtbl -> get_FilterAxis(This,ppvObject)

#define ICellset_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][vararg][propget] */ HRESULT STDMETHODCALLTYPE ICellset_get_Item_Proxy( 
    ICellset __RPC_FAR * This,
    /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *idx,
    /* [retval][out] */ Cell __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB ICellset_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICellset_Open_Proxy( 
    ICellset __RPC_FAR * This,
    /* [optional][in] */ VARIANT DataSource,
    /* [optional][in] */ VARIANT ActiveConnection);


void __RPC_STUB ICellset_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICellset_Close_Proxy( 
    ICellset __RPC_FAR * This);


void __RPC_STUB ICellset_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref] */ HRESULT STDMETHODCALLTYPE ICellset_putref_Source_Proxy( 
    ICellset __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pcmd);


void __RPC_STUB ICellset_putref_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICellset_put_Source_Proxy( 
    ICellset __RPC_FAR * This,
    /* [in] */ BSTR bstrCmd);


void __RPC_STUB ICellset_put_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICellset_get_Source_Proxy( 
    ICellset __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvSource);


void __RPC_STUB ICellset_get_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref] */ HRESULT STDMETHODCALLTYPE ICellset_putref_ActiveConnection_Proxy( 
    ICellset __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pconn);


void __RPC_STUB ICellset_putref_ActiveConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICellset_put_ActiveConnection_Proxy( 
    ICellset __RPC_FAR * This,
    /* [in] */ BSTR bstrConn);


void __RPC_STUB ICellset_put_ActiveConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICellset_get_ActiveConnection_Proxy( 
    ICellset __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppConn);


void __RPC_STUB ICellset_get_ActiveConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICellset_get_State_Proxy( 
    ICellset __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plState);


void __RPC_STUB ICellset_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICellset_get_Axes_Proxy( 
    ICellset __RPC_FAR * This,
    /* [retval][out] */ Axes __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB ICellset_get_Axes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICellset_get_FilterAxis_Proxy( 
    ICellset __RPC_FAR * This,
    /* [retval][out] */ Axis __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB ICellset_get_FilterAxis_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICellset_get_Properties_Proxy( 
    ICellset __RPC_FAR * This,
    /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB ICellset_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICellset_INTERFACE_DEFINED__ */


#ifndef __Cell_INTERFACE_DEFINED__
#define __Cell_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Cell
 * at Fri May 22 21:32:15 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Cell;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2281372E-8BD3-11D0-B4EF-00A0C9138CA4")
    Cell : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Positions( 
            /* [retval][out] */ Positions __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FormattedValue( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FormattedValue( 
            /* [in] */ BSTR bstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Ordinal( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct CellVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Cell __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Cell __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Cell __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Cell __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Cell __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Cell __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Cell __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            Cell __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            Cell __RPC_FAR * This,
            /* [in] */ VARIANT var);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Positions )( 
            Cell __RPC_FAR * This,
            /* [retval][out] */ Positions __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            Cell __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FormattedValue )( 
            Cell __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FormattedValue )( 
            Cell __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Ordinal )( 
            Cell __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        END_INTERFACE
    } CellVtbl;

    interface Cell
    {
        CONST_VTBL struct CellVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Cell_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Cell_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Cell_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Cell_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Cell_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Cell_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Cell_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Cell_get_Value(This,pvar)	\
    (This)->lpVtbl -> get_Value(This,pvar)

#define Cell_put_Value(This,var)	\
    (This)->lpVtbl -> put_Value(This,var)

#define Cell_get_Positions(This,ppvObject)	\
    (This)->lpVtbl -> get_Positions(This,ppvObject)

#define Cell_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)

#define Cell_get_FormattedValue(This,pbstr)	\
    (This)->lpVtbl -> get_FormattedValue(This,pbstr)

#define Cell_put_FormattedValue(This,bstr)	\
    (This)->lpVtbl -> put_FormattedValue(This,bstr)

#define Cell_get_Ordinal(This,pl)	\
    (This)->lpVtbl -> get_Ordinal(This,pl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE Cell_get_Value_Proxy( 
    Cell __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB Cell_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE Cell_put_Value_Proxy( 
    Cell __RPC_FAR * This,
    /* [in] */ VARIANT var);


void __RPC_STUB Cell_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Cell_get_Positions_Proxy( 
    Cell __RPC_FAR * This,
    /* [retval][out] */ Positions __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB Cell_get_Positions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Cell_get_Properties_Proxy( 
    Cell __RPC_FAR * This,
    /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB Cell_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Cell_get_FormattedValue_Proxy( 
    Cell __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB Cell_get_FormattedValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE Cell_put_FormattedValue_Proxy( 
    Cell __RPC_FAR * This,
    /* [in] */ BSTR bstr);


void __RPC_STUB Cell_put_FormattedValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Cell_get_Ordinal_Proxy( 
    Cell __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);


void __RPC_STUB Cell_get_Ordinal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Cell_INTERFACE_DEFINED__ */


#ifndef __Axis_INTERFACE_DEFINED__
#define __Axis_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Axis
 * at Fri May 22 21:32:15 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Axis;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("22813732-8BD3-11D0-B4EF-00A0C9138CA4")
    Axis : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DimensionCount( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Positions( 
            /* [retval][out] */ Positions __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct AxisVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Axis __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Axis __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Axis __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Axis __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Axis __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Axis __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Axis __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            Axis __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DimensionCount )( 
            Axis __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Positions )( 
            Axis __RPC_FAR * This,
            /* [retval][out] */ Positions __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            Axis __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } AxisVtbl;

    interface Axis
    {
        CONST_VTBL struct AxisVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Axis_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Axis_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Axis_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Axis_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Axis_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Axis_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Axis_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Axis_get_Name(This,pbstr)	\
    (This)->lpVtbl -> get_Name(This,pbstr)

#define Axis_get_DimensionCount(This,pl)	\
    (This)->lpVtbl -> get_DimensionCount(This,pl)

#define Axis_get_Positions(This,ppvObject)	\
    (This)->lpVtbl -> get_Positions(This,ppvObject)

#define Axis_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE Axis_get_Name_Proxy( 
    Axis __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB Axis_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Axis_get_DimensionCount_Proxy( 
    Axis __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);


void __RPC_STUB Axis_get_DimensionCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE Axis_get_Positions_Proxy( 
    Axis __RPC_FAR * This,
    /* [retval][out] */ Positions __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB Axis_get_Positions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Axis_get_Properties_Proxy( 
    Axis __RPC_FAR * This,
    /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB Axis_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Axis_INTERFACE_DEFINED__ */


#ifndef __Position_INTERFACE_DEFINED__
#define __Position_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Position
 * at Fri May 22 21:32:15 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Position;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("22813734-8BD3-11D0-B4EF-00A0C9138CA4")
    Position : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Ordinal( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Members( 
            /* [retval][out] */ Members __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct PositionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Position __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Position __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Position __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Position __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Position __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Position __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Position __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Ordinal )( 
            Position __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Members )( 
            Position __RPC_FAR * This,
            /* [retval][out] */ Members __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } PositionVtbl;

    interface Position
    {
        CONST_VTBL struct PositionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Position_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Position_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Position_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Position_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Position_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Position_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Position_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Position_get_Ordinal(This,pl)	\
    (This)->lpVtbl -> get_Ordinal(This,pl)

#define Position_get_Members(This,ppvObject)	\
    (This)->lpVtbl -> get_Members(This,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE Position_get_Ordinal_Proxy( 
    Position __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);


void __RPC_STUB Position_get_Ordinal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE Position_get_Members_Proxy( 
    Position __RPC_FAR * This,
    /* [retval][out] */ Members __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB Position_get_Members_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Position_INTERFACE_DEFINED__ */


#ifndef __Member_INTERFACE_DEFINED__
#define __Member_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Member
 * at Fri May 22 21:32:15 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Member;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("22813736-8BD3-11D0-B4EF-00A0C9138CA4")
    Member : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_UniqueName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Caption( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ Member __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LevelDepth( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LevelName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ MemberTypeEnum __RPC_FAR *ptype) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ChildCount( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DrilledDown( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pf) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ParentSameAsPrev( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pf) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Children( 
            /* [retval][out] */ Members __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct MemberVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Member __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Member __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Member __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Member __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Member __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Member __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Member __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            Member __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UniqueName )( 
            Member __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Caption )( 
            Member __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            Member __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            Member __RPC_FAR * This,
            /* [retval][out] */ Member __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LevelDepth )( 
            Member __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LevelName )( 
            Member __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            Member __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            Member __RPC_FAR * This,
            /* [retval][out] */ MemberTypeEnum __RPC_FAR *ptype);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ChildCount )( 
            Member __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DrilledDown )( 
            Member __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pf);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ParentSameAsPrev )( 
            Member __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pf);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Children )( 
            Member __RPC_FAR * This,
            /* [retval][out] */ Members __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } MemberVtbl;

    interface Member
    {
        CONST_VTBL struct MemberVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Member_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Member_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Member_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Member_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Member_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Member_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Member_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Member_get_Name(This,pbstr)	\
    (This)->lpVtbl -> get_Name(This,pbstr)

#define Member_get_UniqueName(This,pbstr)	\
    (This)->lpVtbl -> get_UniqueName(This,pbstr)

#define Member_get_Caption(This,pbstr)	\
    (This)->lpVtbl -> get_Caption(This,pbstr)

#define Member_get_Description(This,pbstr)	\
    (This)->lpVtbl -> get_Description(This,pbstr)

#define Member_get_Parent(This,ppvObject)	\
    (This)->lpVtbl -> get_Parent(This,ppvObject)

#define Member_get_LevelDepth(This,pl)	\
    (This)->lpVtbl -> get_LevelDepth(This,pl)

#define Member_get_LevelName(This,pbstr)	\
    (This)->lpVtbl -> get_LevelName(This,pbstr)

#define Member_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)

#define Member_get_Type(This,ptype)	\
    (This)->lpVtbl -> get_Type(This,ptype)

#define Member_get_ChildCount(This,pl)	\
    (This)->lpVtbl -> get_ChildCount(This,pl)

#define Member_get_DrilledDown(This,pf)	\
    (This)->lpVtbl -> get_DrilledDown(This,pf)

#define Member_get_ParentSameAsPrev(This,pf)	\
    (This)->lpVtbl -> get_ParentSameAsPrev(This,pf)

#define Member_get_Children(This,ppvObject)	\
    (This)->lpVtbl -> get_Children(This,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE Member_get_Name_Proxy( 
    Member __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB Member_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Member_get_UniqueName_Proxy( 
    Member __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB Member_get_UniqueName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE Member_get_Caption_Proxy( 
    Member __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB Member_get_Caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Member_get_Description_Proxy( 
    Member __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB Member_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Member_get_Parent_Proxy( 
    Member __RPC_FAR * This,
    /* [retval][out] */ Member __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB Member_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Member_get_LevelDepth_Proxy( 
    Member __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);


void __RPC_STUB Member_get_LevelDepth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Member_get_LevelName_Proxy( 
    Member __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB Member_get_LevelName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Member_get_Properties_Proxy( 
    Member __RPC_FAR * This,
    /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB Member_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Member_get_Type_Proxy( 
    Member __RPC_FAR * This,
    /* [retval][out] */ MemberTypeEnum __RPC_FAR *ptype);


void __RPC_STUB Member_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Member_get_ChildCount_Proxy( 
    Member __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);


void __RPC_STUB Member_get_ChildCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Member_get_DrilledDown_Proxy( 
    Member __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pf);


void __RPC_STUB Member_get_DrilledDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Member_get_ParentSameAsPrev_Proxy( 
    Member __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pf);


void __RPC_STUB Member_get_ParentSameAsPrev_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Member_get_Children_Proxy( 
    Member __RPC_FAR * This,
    /* [retval][out] */ Members __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB Member_get_Children_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Member_INTERFACE_DEFINED__ */


#ifndef __Level_INTERFACE_DEFINED__
#define __Level_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Level
 * at Fri May 22 21:32:15 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Level;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2281373A-8BD3-11D0-B4EF-00A0C9138CA4")
    Level : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_UniqueName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Caption( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Depth( 
            /* [retval][out] */ short __RPC_FAR *pw) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Members( 
            /* [retval][out] */ Members __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct LevelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Level __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Level __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Level __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Level __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Level __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Level __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Level __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            Level __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UniqueName )( 
            Level __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Caption )( 
            Level __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            Level __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Depth )( 
            Level __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            Level __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Members )( 
            Level __RPC_FAR * This,
            /* [retval][out] */ Members __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } LevelVtbl;

    interface Level
    {
        CONST_VTBL struct LevelVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Level_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Level_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Level_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Level_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Level_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Level_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Level_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Level_get_Name(This,pbstr)	\
    (This)->lpVtbl -> get_Name(This,pbstr)

#define Level_get_UniqueName(This,pbstr)	\
    (This)->lpVtbl -> get_UniqueName(This,pbstr)

#define Level_get_Caption(This,pbstr)	\
    (This)->lpVtbl -> get_Caption(This,pbstr)

#define Level_get_Description(This,pbstr)	\
    (This)->lpVtbl -> get_Description(This,pbstr)

#define Level_get_Depth(This,pw)	\
    (This)->lpVtbl -> get_Depth(This,pw)

#define Level_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)

#define Level_get_Members(This,ppvObject)	\
    (This)->lpVtbl -> get_Members(This,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE Level_get_Name_Proxy( 
    Level __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB Level_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Level_get_UniqueName_Proxy( 
    Level __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB Level_get_UniqueName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Level_get_Caption_Proxy( 
    Level __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB Level_get_Caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Level_get_Description_Proxy( 
    Level __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB Level_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Level_get_Depth_Proxy( 
    Level __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pw);


void __RPC_STUB Level_get_Depth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Level_get_Properties_Proxy( 
    Level __RPC_FAR * This,
    /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB Level_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE Level_get_Members_Proxy( 
    Level __RPC_FAR * This,
    /* [retval][out] */ Members __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB Level_get_Members_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Level_INTERFACE_DEFINED__ */


#ifndef __CubeDef_INTERFACE_DEFINED__
#define __CubeDef_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: CubeDef
 * at Fri May 22 21:32:15 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_CubeDef;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2281373E-8BD3-11D0-B4EF-00A0C9138CA4")
    CubeDef : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Dimensions( 
            /* [retval][out] */ Dimensions __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct CubeDefVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            CubeDef __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            CubeDef __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            CubeDef __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            CubeDef __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            CubeDef __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            CubeDef __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            CubeDef __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            CubeDef __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            CubeDef __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            CubeDef __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Dimensions )( 
            CubeDef __RPC_FAR * This,
            /* [retval][out] */ Dimensions __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } CubeDefVtbl;

    interface CubeDef
    {
        CONST_VTBL struct CubeDefVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define CubeDef_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define CubeDef_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define CubeDef_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define CubeDef_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define CubeDef_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define CubeDef_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define CubeDef_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define CubeDef_get_Name(This,pbstr)	\
    (This)->lpVtbl -> get_Name(This,pbstr)

#define CubeDef_get_Description(This,pbstr)	\
    (This)->lpVtbl -> get_Description(This,pbstr)

#define CubeDef_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)

#define CubeDef_get_Dimensions(This,ppvObject)	\
    (This)->lpVtbl -> get_Dimensions(This,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE CubeDef_get_Name_Proxy( 
    CubeDef __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB CubeDef_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE CubeDef_get_Description_Proxy( 
    CubeDef __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB CubeDef_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE CubeDef_get_Properties_Proxy( 
    CubeDef __RPC_FAR * This,
    /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB CubeDef_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE CubeDef_get_Dimensions_Proxy( 
    CubeDef __RPC_FAR * This,
    /* [retval][out] */ Dimensions __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB CubeDef_get_Dimensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __CubeDef_INTERFACE_DEFINED__ */


#ifndef __Dimension_INTERFACE_DEFINED__
#define __Dimension_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Dimension
 * at Fri May 22 21:32:15 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Dimension;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("22813742-8BD3-11D0-B4EF-00A0C9138CA4")
    Dimension : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_UniqueName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Hierarchies( 
            /* [retval][out] */ Hierarchies __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct DimensionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Dimension __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Dimension __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Dimension __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Dimension __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Dimension __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Dimension __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Dimension __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            Dimension __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UniqueName )( 
            Dimension __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            Dimension __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            Dimension __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Hierarchies )( 
            Dimension __RPC_FAR * This,
            /* [retval][out] */ Hierarchies __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } DimensionVtbl;

    interface Dimension
    {
        CONST_VTBL struct DimensionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Dimension_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Dimension_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Dimension_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Dimension_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Dimension_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Dimension_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Dimension_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Dimension_get_Name(This,pbstr)	\
    (This)->lpVtbl -> get_Name(This,pbstr)

#define Dimension_get_UniqueName(This,pbstr)	\
    (This)->lpVtbl -> get_UniqueName(This,pbstr)

#define Dimension_get_Description(This,pbstr)	\
    (This)->lpVtbl -> get_Description(This,pbstr)

#define Dimension_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)

#define Dimension_get_Hierarchies(This,ppvObject)	\
    (This)->lpVtbl -> get_Hierarchies(This,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE Dimension_get_Name_Proxy( 
    Dimension __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB Dimension_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Dimension_get_UniqueName_Proxy( 
    Dimension __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB Dimension_get_UniqueName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Dimension_get_Description_Proxy( 
    Dimension __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB Dimension_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Dimension_get_Properties_Proxy( 
    Dimension __RPC_FAR * This,
    /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB Dimension_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE Dimension_get_Hierarchies_Proxy( 
    Dimension __RPC_FAR * This,
    /* [retval][out] */ Hierarchies __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB Dimension_get_Hierarchies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Dimension_INTERFACE_DEFINED__ */


#ifndef __Hierarchy_INTERFACE_DEFINED__
#define __Hierarchy_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Hierarchy
 * at Fri May 22 21:32:15 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Hierarchy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("22813746-8BD3-11D0-B4EF-00A0C9138CA4")
    Hierarchy : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_UniqueName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Levels( 
            /* [retval][out] */ Levels __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct HierarchyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Hierarchy __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Hierarchy __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Hierarchy __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Hierarchy __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Hierarchy __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Hierarchy __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Hierarchy __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            Hierarchy __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UniqueName )( 
            Hierarchy __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            Hierarchy __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            Hierarchy __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Levels )( 
            Hierarchy __RPC_FAR * This,
            /* [retval][out] */ Levels __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } HierarchyVtbl;

    interface Hierarchy
    {
        CONST_VTBL struct HierarchyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Hierarchy_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Hierarchy_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Hierarchy_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Hierarchy_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Hierarchy_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Hierarchy_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Hierarchy_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Hierarchy_get_Name(This,pbstr)	\
    (This)->lpVtbl -> get_Name(This,pbstr)

#define Hierarchy_get_UniqueName(This,pbstr)	\
    (This)->lpVtbl -> get_UniqueName(This,pbstr)

#define Hierarchy_get_Description(This,pbstr)	\
    (This)->lpVtbl -> get_Description(This,pbstr)

#define Hierarchy_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)

#define Hierarchy_get_Levels(This,ppvObject)	\
    (This)->lpVtbl -> get_Levels(This,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE Hierarchy_get_Name_Proxy( 
    Hierarchy __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB Hierarchy_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Hierarchy_get_UniqueName_Proxy( 
    Hierarchy __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB Hierarchy_get_UniqueName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Hierarchy_get_Description_Proxy( 
    Hierarchy __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB Hierarchy_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE Hierarchy_get_Properties_Proxy( 
    Hierarchy __RPC_FAR * This,
    /* [retval][out] */ /* external definition not present */ Properties __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB Hierarchy_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE Hierarchy_get_Levels_Proxy( 
    Hierarchy __RPC_FAR * This,
    /* [retval][out] */ Levels __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB Hierarchy_get_Levels_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Hierarchy_INTERFACE_DEFINED__ */


#ifndef __MD_Collection_INTERFACE_DEFINED__
#define __MD_Collection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: MD_Collection
 * at Fri May 22 21:32:15 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_MD_Collection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("22813751-8BD3-11D0-B4EF-00A0C9138CA4")
    MD_Collection : public IDispatch
    {
    public:
        virtual /* [helpstring][helpcontext] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [id][restricted] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *c) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct MD_CollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            MD_Collection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            MD_Collection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            MD_Collection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            MD_Collection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            MD_Collection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            MD_Collection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            MD_Collection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            MD_Collection __RPC_FAR * This);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            MD_Collection __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            MD_Collection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        END_INTERFACE
    } MD_CollectionVtbl;

    interface MD_Collection
    {
        CONST_VTBL struct MD_CollectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define MD_Collection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define MD_Collection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define MD_Collection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define MD_Collection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define MD_Collection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define MD_Collection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define MD_Collection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define MD_Collection_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define MD_Collection__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)

#define MD_Collection_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][helpcontext] */ HRESULT STDMETHODCALLTYPE MD_Collection_Refresh_Proxy( 
    MD_Collection __RPC_FAR * This);


void __RPC_STUB MD_Collection_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted] */ HRESULT STDMETHODCALLTYPE MD_Collection__NewEnum_Proxy( 
    MD_Collection __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB MD_Collection__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE MD_Collection_get_Count_Proxy( 
    MD_Collection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *c);


void __RPC_STUB MD_Collection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __MD_Collection_INTERFACE_DEFINED__ */


#ifndef __Members_INTERFACE_DEFINED__
#define __Members_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Members
 * at Fri May 22 21:32:15 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Members;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("22813757-8BD3-11D0-B4EF-00A0C9138CA4")
    Members : public MD_Collection
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ Member __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct MembersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Members __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Members __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Members __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Members __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Members __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Members __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Members __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            Members __RPC_FAR * This);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            Members __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            Members __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            Members __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ Member __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } MembersVtbl;

    interface Members
    {
        CONST_VTBL struct MembersVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Members_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Members_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Members_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Members_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Members_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Members_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Members_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Members_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define Members__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)

#define Members_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)


#define Members_get_Item(This,Index,ppvObject)	\
    (This)->lpVtbl -> get_Item(This,Index,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE Members_get_Item_Proxy( 
    Members __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ Member __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB Members_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Members_INTERFACE_DEFINED__ */


#ifndef __Levels_INTERFACE_DEFINED__
#define __Levels_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Levels
 * at Fri May 22 21:32:15 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Levels;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("22813758-8BD3-11D0-B4EF-00A0C9138CA4")
    Levels : public MD_Collection
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ Level __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct LevelsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Levels __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Levels __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Levels __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Levels __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Levels __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Levels __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Levels __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            Levels __RPC_FAR * This);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            Levels __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            Levels __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            Levels __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ Level __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } LevelsVtbl;

    interface Levels
    {
        CONST_VTBL struct LevelsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Levels_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Levels_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Levels_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Levels_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Levels_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Levels_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Levels_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Levels_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define Levels__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)

#define Levels_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)


#define Levels_get_Item(This,Index,ppvObject)	\
    (This)->lpVtbl -> get_Item(This,Index,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE Levels_get_Item_Proxy( 
    Levels __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ Level __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB Levels_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Levels_INTERFACE_DEFINED__ */


#ifndef __Axes_INTERFACE_DEFINED__
#define __Axes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Axes
 * at Fri May 22 21:32:15 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Axes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("22813759-8BD3-11D0-B4EF-00A0C9138CA4")
    Axes : public MD_Collection
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ Axis __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct AxesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Axes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Axes __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Axes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Axes __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Axes __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Axes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Axes __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            Axes __RPC_FAR * This);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            Axes __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            Axes __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            Axes __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ Axis __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } AxesVtbl;

    interface Axes
    {
        CONST_VTBL struct AxesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Axes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Axes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Axes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Axes_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Axes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Axes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Axes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Axes_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define Axes__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)

#define Axes_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)


#define Axes_get_Item(This,Index,ppvObject)	\
    (This)->lpVtbl -> get_Item(This,Index,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE Axes_get_Item_Proxy( 
    Axes __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ Axis __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB Axes_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Axes_INTERFACE_DEFINED__ */


#ifndef __Positions_INTERFACE_DEFINED__
#define __Positions_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Positions
 * at Fri May 22 21:32:15 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Positions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2281375A-8BD3-11D0-B4EF-00A0C9138CA4")
    Positions : public MD_Collection
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ Position __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct PositionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Positions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Positions __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Positions __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Positions __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Positions __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Positions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Positions __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            Positions __RPC_FAR * This);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            Positions __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            Positions __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            Positions __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ Position __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } PositionsVtbl;

    interface Positions
    {
        CONST_VTBL struct PositionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Positions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Positions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Positions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Positions_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Positions_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Positions_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Positions_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Positions_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define Positions__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)

#define Positions_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)


#define Positions_get_Item(This,Index,ppvObject)	\
    (This)->lpVtbl -> get_Item(This,Index,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE Positions_get_Item_Proxy( 
    Positions __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ Position __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB Positions_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Positions_INTERFACE_DEFINED__ */


#ifndef __Hierarchies_INTERFACE_DEFINED__
#define __Hierarchies_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Hierarchies
 * at Fri May 22 21:32:15 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Hierarchies;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2281375B-8BD3-11D0-B4EF-00A0C9138CA4")
    Hierarchies : public MD_Collection
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ Hierarchy __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct HierarchiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Hierarchies __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Hierarchies __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Hierarchies __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Hierarchies __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Hierarchies __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Hierarchies __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Hierarchies __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            Hierarchies __RPC_FAR * This);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            Hierarchies __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            Hierarchies __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            Hierarchies __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ Hierarchy __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } HierarchiesVtbl;

    interface Hierarchies
    {
        CONST_VTBL struct HierarchiesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Hierarchies_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Hierarchies_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Hierarchies_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Hierarchies_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Hierarchies_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Hierarchies_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Hierarchies_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Hierarchies_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define Hierarchies__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)

#define Hierarchies_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)


#define Hierarchies_get_Item(This,Index,ppvObject)	\
    (This)->lpVtbl -> get_Item(This,Index,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE Hierarchies_get_Item_Proxy( 
    Hierarchies __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ Hierarchy __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB Hierarchies_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Hierarchies_INTERFACE_DEFINED__ */


#ifndef __Dimensions_INTERFACE_DEFINED__
#define __Dimensions_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Dimensions
 * at Fri May 22 21:32:15 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Dimensions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2281375C-8BD3-11D0-B4EF-00A0C9138CA4")
    Dimensions : public MD_Collection
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ Dimension __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct DimensionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Dimensions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Dimensions __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Dimensions __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Dimensions __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Dimensions __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Dimensions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Dimensions __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            Dimensions __RPC_FAR * This);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            Dimensions __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            Dimensions __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            Dimensions __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ Dimension __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } DimensionsVtbl;

    interface Dimensions
    {
        CONST_VTBL struct DimensionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Dimensions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Dimensions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Dimensions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Dimensions_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Dimensions_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Dimensions_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Dimensions_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Dimensions_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define Dimensions__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)

#define Dimensions_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)


#define Dimensions_get_Item(This,Index,ppvObject)	\
    (This)->lpVtbl -> get_Item(This,Index,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE Dimensions_get_Item_Proxy( 
    Dimensions __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ Dimension __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB Dimensions_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Dimensions_INTERFACE_DEFINED__ */


#ifndef __CubeDefs_INTERFACE_DEFINED__
#define __CubeDefs_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: CubeDefs
 * at Fri May 22 21:32:15 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_CubeDefs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2281375D-8BD3-11D0-B4EF-00A0C9138CA4")
    CubeDefs : public MD_Collection
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ CubeDef __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct CubeDefsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            CubeDefs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            CubeDefs __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            CubeDefs __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            CubeDefs __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            CubeDefs __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            CubeDefs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            CubeDefs __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            CubeDefs __RPC_FAR * This);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            CubeDefs __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            CubeDefs __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            CubeDefs __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ CubeDef __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } CubeDefsVtbl;

    interface CubeDefs
    {
        CONST_VTBL struct CubeDefsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define CubeDefs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define CubeDefs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define CubeDefs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define CubeDefs_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define CubeDefs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define CubeDefs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define CubeDefs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define CubeDefs_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define CubeDefs__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)

#define CubeDefs_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)


#define CubeDefs_get_Item(This,Index,ppvObject)	\
    (This)->lpVtbl -> get_Item(This,Index,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE CubeDefs_get_Item_Proxy( 
    CubeDefs __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ CubeDef __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB CubeDefs_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __CubeDefs_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Catalog;

class DECLSPEC_UUID("228136B0-8BD3-11D0-B4EF-00A0C9138CA4")
Catalog;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Cellset;

class DECLSPEC_UUID("228136B8-8BD3-11D0-B4EF-00A0C9138CA4")
Cellset;
#endif
#endif /* __ADOMD_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\datacomp\datacomp.cxx ===
/**
 * XSP Data Component entry points implementation
 *
 * Copyright (c) 1999 Microsoft Corporation
 */


#include "precomp.h"
#include "adoint.h"
#include "adomd.h"
#include "initguid.h"
#include "adoid.h"
#define SZ_COL_SEPARATOR       L"XSP COL SEP"
#define SZ_NULL_VALUE          L"NULL"

//////////////////////////////////////////////////////////////////////////////
// Prototypes for functions defined here
extern "C"
{
    int   __stdcall    DataCompConnect          (LPCWSTR DSN, LPCWSTR UserName, LPCWSTR Password, LPWSTR strBufErrors, int size);    
    void  __stdcall    DataCompDisconnect       (int iPtr);
    void  __stdcall    DataCompCloseResultSet   (int iPtr);
    int   __stdcall    DataCompExecute          (int iPtr, LPCWSTR strQuery);
    int   __stdcall    DataCompNumResultRows    (int iPtr);
    int   __stdcall    DataCompNumResultColumns (int iPtr);
    int   __stdcall    DataCompGetColumnName    (int iPtr, int iCol, LPWSTR strBuffer, int size);
    int   __stdcall    DataCompGetRow           (int iPtr, int iRow, LPWSTR strBuffer, int size);
    int   __stdcall    DataCompGetErrors        (int iPtr, LPWSTR strBuffer, int size);    
}

// Forward decl.
class XSPDataComponentResultSet;
//////////////////////////////////////////////////////////////////////////////
// Class XSPDataComponentADOInterface: XSP's Data Component's ADO interface class
//
class XSPDataComponentADOInterface
{
private:
    XSPDataComponentADOInterface(); // Don't use this ctor
    XSPDataComponentADOInterface(const XSPDataComponentADOInterface & c); // Don't use the copy ctor

    BOOL               _fCreationStatus; // Object created successfully
    BOOL               _fCallCoUnint;    // should we call CoUinit
    _ADOConnection *   _ptrIConn;    

public:

    /////////////////////////////////////////////////////////////////////////
    // Constructor
    XSPDataComponentADOInterface(LPCWSTR DSN, LPCWSTR UserName, LPCWSTR Password, LPWSTR strBufErrors, int size);

    /////////////////////////////////////////////////////////////////////////
    // Destructor
    ~XSPDataComponentADOInterface();

    /////////////////////////////////////////////////////////////////////////
    // Return creation status
    BOOL  GetCreationStatus    ()     { return _fCreationStatus; }

    /////////////////////////////////////////////////////////////////////////
    // Execute query
    int  Execute(LPCWSTR strQuery);

    
    /////////////////////////////////////////////////////////////////////////
    // Get the errors
    int GetErrors(LPWSTR strBufErrors, int size);
};

typedef XSPDataComponentADOInterface * PXSPDataComponentADOInterface;

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class XSPDataComponentResultSet
{
    LPWSTR *           _strAllRows;
    LPWSTR             _strAllCols;
    int                _iRows;
    int                _iCols;
    BOOL               _fCreationStatus;

public:
    XSPDataComponentResultSet  (_ADORecordset * _ptrIRecSet);
    ~XSPDataComponentResultSet ();


    int  GetNumResultRows     () { return _iRows; }
    int  GetNumResultColumns  () { return _iCols; }
    BOOL GetCreationStatus    () { return _fCreationStatus; }
    int  GetColumnName        (int iCol, LPWSTR strBuffer, int size);
    int  GetRow               (int iRow, LPWSTR strBuffer, int size);

private:    
    BOOL  GetAllRows          (_ADORecordset * _ptrIRecSet);
    BOOL  GetAllColumns       (_ADORecordset * _ptrIRecSet);
    void  FreeAllRows         ();
};

typedef XSPDataComponentResultSet * PXSPDataComponentResultSet;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// Constructor
XSPDataComponentADOInterface::XSPDataComponentADOInterface(
   LPCWSTR DSN, LPCWSTR UserName, LPCWSTR Password, LPWSTR strBufErrors, int size)
    :  _fCreationStatus (FALSE), 
       _ptrIConn        (NULL),
       _fCallCoUnint    (FALSE)
{
    if(DSN == NULL) // Can not create connection without a DSN
        return;

     EnsureCoInitialized(&_fCallCoUnint);

    // Create the connection object
    if ( FAILED(CoCreateInstance(CLSID_CADOConnection, NULL, CLSCTX_ALL, 
                                 IID_IADOConnection, (LPVOID *)&_ptrIConn)) || 
         _ptrIConn == NULL  )
        return;
    
    BSTR bstrUser = SysAllocString(UserName ? UserName : L"");
    BSTR bstrPass = SysAllocString(Password ? Password : L"");
    BSTR bstrDSN  = SysAllocString(DSN      ? DSN      : L"");
    int  iOptions = -1;

    if(!FAILED(_ptrIConn->Open(bstrDSN, bstrUser, bstrPass, iOptions)))
        _fCreationStatus = TRUE;
    else
        GetErrors(strBufErrors, size);

    SysFreeString(bstrUser);
    SysFreeString(bstrPass);
    SysFreeString(bstrDSN);
}
    
///////////////////////////////////////////////////////////////////////////////
// Destructor
XSPDataComponentADOInterface::~XSPDataComponentADOInterface()
{
    if (_fCallCoUnint)
        CoUninitialize();//CoUninitialize();
    // Close the connection
    if(_ptrIConn)
    {
        _ptrIConn->Close();
        //_ptrIConn->Release();
    }
}

/////////////////////////////////////////////////////////////////////////////////
// Execute query
int  XSPDataComponentADOInterface::Execute      (LPCWSTR strQuery)
{
    _ADORecordset  *   _ptrIRecSet = NULL;
    VARIANT            varSrc, varConn;
    BOOL               fError = FALSE;

    // Create VARIANTs for the parameters to pass to the Recordset::Open call
    V_BSTR(&varSrc)      = SysAllocString(strQuery); // VARIANT for the query string
    V_VT(&varSrc)        = VT_BSTR;

    V_UNKNOWN(&varConn)  = _ptrIConn; // Variant for the Connection object
    V_VT(&varConn)       = VT_UNKNOWN; 

    // Create the recordset object
    if ( FAILED(CoCreateInstance(CLSID_CADORecordset, NULL, CLSCTX_ALL, 
                                 IID_IADORecordset, (LPVOID *)&_ptrIRecSet)) || 
         _ptrIRecSet == NULL  )
    {   // Failed
        _ptrIRecSet = NULL;
        fError = TRUE;
    }
    else
    {   
        if(FAILED(_ptrIRecSet->Open(varSrc, varConn, adOpenDynamic, adLockReadOnly, adCmdText)))
        {
            _ptrIRecSet->Release();
            _ptrIRecSet = NULL;
            fError = TRUE;
        }
    }

    SysFreeString(V_BSTR(&varSrc));

    XSPDataComponentResultSet * pRS = NULL;
    if(!fError)
    {
        pRS = new XSPDataComponentResultSet(_ptrIRecSet);
        if(pRS && !pRS->GetCreationStatus())
        {
            delete pRS;
            pRS = NULL;
        }
    }

    _ptrIRecSet->Close();
    _ptrIRecSet->Release();
    _ptrIRecSet = NULL;
    return int(pRS);
}

/////////////////////////////////////////////////////////////////////////////////
// Get execution errors
int XSPDataComponentADOInterface::GetErrors(LPWSTR strBufErrors, int size)
{
    if(_ptrIConn == NULL)
        return 0;

    ADOErrors * ptrErrs = NULL;

    if(FAILED(_ptrIConn->get_Errors(&ptrErrs)) || ptrErrs == NULL)
        return 0;
    
    long lCount = 0, lRet = 0, lCurLen = 0;
    BOOL fAppending = TRUE;

    if(FAILED(ptrErrs->get_Count(&lCount)))
    {
        ptrErrs->Release();
        return 0;
    }
    
    for(int iter=0; iter<lCount; iter++)
    {
        ADOError  * ptrErr = NULL;
        VARIANT     var;

        V_VT(&var) = VT_I4;
        V_I4(&var) = iter;        
        if(!FAILED(ptrErrs->get_Item(var, &ptrErr)) && ptrErr != NULL)
        {
            BSTR  bstr = NULL;
            if(!FAILED(ptrErr->get_Description(&bstr)) && bstr != NULL)
            {
                long lLen = lstrlen(bstr);
                lRet += lLen + 1;
                if(fAppending)
                {
                    if(size - lCurLen > lLen + 1)
                    {
                        if(lCurLen)
                            lstrcat(strBufErrors, L"\n");
                        lstrcat(strBufErrors, bstr);
                        lCurLen += lLen + 1;
                    }
                    else
                        fAppending = FALSE;

                }
                SysFreeString(bstr);
            }
            ptrErr->Release();
        }
    }

    if(ptrErrs) ptrErrs->Release();
    return lRet;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// Result set constructor
XSPDataComponentResultSet::XSPDataComponentResultSet(_ADORecordset * _ptrIRecSet)
  : _strAllRows      (NULL),
    _iRows           (0),
    _iCols           (0),
    _strAllCols      (NULL),
    _fCreationStatus (FALSE)
{
    _fCreationStatus = GetAllRows(_ptrIRecSet);
}

///////////////////////////////////////////////////////////////////////////////
// Result set destructor
XSPDataComponentResultSet::~XSPDataComponentResultSet()
{
    FreeAllRows();
}

///////////////////////////////////////////////////////////////////////////////
// Free internal cache
void XSPDataComponentResultSet::FreeAllRows()
{
    if(_strAllCols != NULL)
        GlobalFree(_strAllCols);
    _strAllCols = NULL;

    if(_strAllRows == NULL)
        return;

    for(int iter=0; iter<_iRows; iter++)
        if(_strAllRows[iter] != NULL)
            GlobalFree(_strAllRows[iter]);

    GlobalFree(_strAllRows);
    _strAllRows = NULL;
    _iRows = 0;
}

//////////////////////////////////////////////////////////////////////////////
// Populate internal cache of rows
BOOL XSPDataComponentResultSet::GetAllRows(_ADORecordset * _ptrIRecSet)
{
    if(_ptrIRecSet == NULL)
        return FALSE;

    FreeAllRows();

    HRESULT         hr;
    VARIANT         vBookmark, rgvFields, cRows, varField, varNewField;
    long            lIndex[2];

    vBookmark.vt = VT_ERROR;
    vBookmark.scode = DISP_E_PARAMNOTFOUND;    
    
    //Get all columns.            
    rgvFields.vt = VT_ERROR;
    rgvFields.scode = DISP_E_PARAMNOTFOUND;    
    
    hr = _ptrIRecSet->GetRows(adGetRowsRest, vBookmark, rgvFields, &cRows);
    if (FAILED(hr)) return FALSE;


    //Find out how many records were actually retrieved
    //(SafeArrays are 1-based)
    SafeArrayGetUBound(cRows.parray, 1, (long *) &_iCols);
    SafeArrayGetUBound(cRows.parray, 2, (long *) &_iRows);
    _iCols++;
    _iRows++;

    if(_iCols < 1)
        return TRUE;


    int iColSepLen = lstrlen(SZ_COL_SEPARATOR);

    if(_iRows > 0)
    {
        _strAllRows = (LPWSTR *) GlobalAlloc(GPTR, _iRows * sizeof(LPWSTR));
        if(_strAllRows == NULL)
            return FALSE;
    }

    for (lIndex[1] = 0; lIndex[1] < _iRows; lIndex[1]++)
    {
        int iLen = (_iCols - 1) * iColSepLen + 1;

        // Get the amount of memory to allocate
        for (lIndex[0] = 0; lIndex[0] < _iCols; lIndex[0]++)
        {
            ZeroMemory(&varField, sizeof(varField));
            ZeroMemory(&varNewField, sizeof(varNewField));
            SafeArrayGetElement(cRows.parray, &lIndex[0], &varField);
                        
            hr = VariantChangeType(&varNewField, &varField, 0, VT_BSTR);
            if(FAILED(hr))
                return FALSE;
            if(varNewField.bstrVal == NULL)
                iLen += lstrlen(SZ_NULL_VALUE);
            else
                iLen += lstrlen((LPCWSTR)varNewField.bstrVal);
            VariantClear(&varField);
            VariantClear(&varNewField);
        }

        // Allocate iLen WCHARS
        _strAllRows[lIndex[1]] = (LPWSTR) GlobalAlloc(GPTR, iLen * sizeof(WCHAR));
        if(_strAllRows[lIndex[1]] == NULL) 
            return FALSE;

        for (lIndex[0] = 0; lIndex[0] < _iCols; lIndex[0]++)
        {
            ZeroMemory(&varField, sizeof(varField));
            ZeroMemory(&varNewField, sizeof(varNewField));
            SafeArrayGetElement(cRows.parray, &lIndex[0], &varField);

            if(lIndex[0] > 0)
                wcscat(_strAllRows[lIndex[1]], SZ_COL_SEPARATOR);
            
            if(varField.vt == VT_BOOL && varField.boolVal != 0) 
                wcscat(_strAllRows[lIndex[1]], L"1");
            else
            {
                if(FAILED(VariantChangeType(&varNewField, &varField, 0, VT_BSTR)))
                    return FALSE;
                if(varNewField.bstrVal == NULL)
                    wcscat(_strAllRows[lIndex[1]], SZ_NULL_VALUE);
                else
                    wcscat(_strAllRows[lIndex[1]], (LPCWSTR)varNewField.bstrVal);
                VariantClear(&varNewField);
            }

            VariantClear(&varField);
        }
    }
    
    VariantClear(&cRows);
    
    return GetAllColumns(_ptrIRecSet);
}

////////////////////////////////////////////////////////////////////////////////
// Populate internal cache of column names
BOOL  XSPDataComponentResultSet::GetAllColumns(_ADORecordset * _ptrIRecSet)
{
    ADOFields *   ptrFields = NULL;
    
    // Step 1: Get the Fields collection
    if(FAILED(_ptrIRecSet->get_Fields(&ptrFields)) || ptrFields == NULL)
        return FALSE;

    int iLen = _iCols;

    for(int iCol=0; iCol<_iCols; iCol++)
    {
        ADOField  *   ptrField  = NULL;
        VARIANT       var;

        // Get the column (Field)
        V_VT(&var) = VT_I4;
        V_I4(&var) = iCol;
        if(FAILED(ptrFields->get_Item(var, &ptrField)) || ptrField == NULL)
        {            
            ptrFields->Release();
            return FALSE;
        }
        // Get the name of the field
        BSTR   bstr = NULL;        
        if(FAILED(ptrField->get_Name(&bstr)) || bstr == NULL)
        {            
            ptrField->Release();
            ptrFields->Release();
            return FALSE;
        }        

        int iLenStr = lstrlen(bstr);
        iLen += (iLenStr > 0 ? iLenStr : 1); 
        SysFreeString(bstr);
    
        ptrField->Release();
        ptrField = NULL;
    }

    _strAllCols = (LPWSTR) GlobalAlloc(GPTR, iLen * sizeof(WCHAR) + sizeof(WCHAR));
    int iPos = 0;

    for(iCol=0; iCol<_iCols; iCol++)
    {
        ADOField  *   ptrField  = NULL;
        VARIANT       var;

        // Get the column (Field)
        V_VT(&var) = VT_I4;
        V_I4(&var) = iCol;
        if(FAILED(ptrFields->get_Item(var, &ptrField)) || ptrField == NULL)
        {            
            ptrFields->Release();
            return FALSE;
        }
        // Get the name of the field
        BSTR   bstr = NULL;        
        if(FAILED(ptrField->get_Name(&bstr)) || bstr == NULL)
        {            
            ptrField->Release();
            ptrFields->Release();
            return FALSE;
        }        

        int iLenStr = lstrlen(bstr);
        if(iLenStr > 0)
            wcscpy(&_strAllCols[iPos], bstr);
        else
            wcscpy(&_strAllCols[iPos], L" ");
        iPos += (iLenStr > 0 ? iLenStr : 1); 

        iPos ++;
        SysFreeString(bstr);    
        ptrField->Release();
        ptrField = NULL;
    }
    ptrFields->Release();
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////
// Get a column name from the cache
int  XSPDataComponentResultSet::GetColumnName(int iCol, LPWSTR strBuffer, int size)
{
    if(iCol >= _iCols || _strAllCols == NULL)
        return 0;

    int iMax = GlobalSize(_strAllCols) / sizeof(WCHAR);
    int iPos = 0;
    for(int iter=0; iter<iCol && iPos < iMax; iter++)
    {
        iPos += lstrlen(&_strAllCols[iPos]);
        iPos ++;
    }
    if(iPos >= iMax)
        return 0;
    LPWSTR szCol = &_strAllCols[iPos];    
    int iLen = lstrlen(szCol) + 1;
    if(iLen < size)
        wcscpy(strBuffer, szCol);
    return (iLen < size) ? iLen : -iLen;
}

////////////////////////////////////////////////////////////////////////////////
// Get a row from the internal cache
int  XSPDataComponentResultSet::GetRow(int iRow, LPWSTR strBuffer, int size)
{
    if(_strAllRows == NULL)
        return FALSE;

    if(_strAllRows[iRow] == NULL)
    {
        if(strBuffer != NULL && size > 0)
        {
            strBuffer[0] = NULL;
            return 1;
        }
        return -1;
    }

    int iLen = lstrlen(_strAllRows[iRow]);
    if(strBuffer != NULL && size > iLen)
    {
        wcscpy(strBuffer, _strAllRows[iRow]);
        return iLen;        
    }
    return -iLen;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// Exported functions

//////////////////////////////////////////////////////////////////////////////
// Instantiate the class and connect to the DB Server
int  DataCompConnect          (LPCWSTR DSN, LPCWSTR UserName, LPCWSTR Password, LPWSTR strBufErrors, int size)
{ 
    PXSPDataComponentADOInterface pADOInt = new XSPDataComponentADOInterface(DSN, UserName, Password, strBufErrors, size);

    if(pADOInt && !pADOInt->GetCreationStatus())
    {
        delete pADOInt;
        pADOInt = NULL;
    }
    return int(pADOInt);
}   

//////////////////////////////////////////////////////////////////////////////
// Disconnect from the DB server and free the pointer
void DataCompDisconnect       (int iPtr)
{
    PXSPDataComponentADOInterface pADOInt = PXSPDataComponentADOInterface (iPtr);
    if(pADOInt != NULL)
        delete pADOInt; 
}

//////////////////////////////////////////////////////////////////////////////
// Disconnect from the DB server and free the pointer
void DataCompCloseResultSet  (int iPtr)
{
    PXSPDataComponentResultSet pADOInt = PXSPDataComponentResultSet (iPtr);
    if(pADOInt != NULL)
        delete pADOInt; 
}

//////////////////////////////////////////////////////////////////////////////
// Execute a query
int  DataCompExecute          (int iPtr, LPCWSTR strQuery)
{
    PXSPDataComponentADOInterface pADOInt = PXSPDataComponentADOInterface(iPtr);
    if(pADOInt == NULL)
        return 0;
    return pADOInt->Execute(strQuery);
}

//////////////////////////////////////////////////////////////////////////////
// Get the number of result rows
int  DataCompNumResultRows    (int iPtr) 
{ 
    PXSPDataComponentResultSet pADOInt = PXSPDataComponentResultSet(iPtr);
    if(pADOInt == NULL)
        return 0;
    return pADOInt->GetNumResultRows();
}

//////////////////////////////////////////////////////////////////////////////
// Get the number of result columns
int  DataCompNumResultColumns (int iPtr) 
{ 
    PXSPDataComponentResultSet pADOInt = PXSPDataComponentResultSet(iPtr);
    if(pADOInt == NULL)
        return 0;
    return pADOInt->GetNumResultColumns();
}

//////////////////////////////////////////////////////////////////////////////
// Get a column name
int  DataCompGetColumnName    (int iPtr, int iCol, LPWSTR strBuffer, int size)
{
    PXSPDataComponentResultSet pADOInt = PXSPDataComponentResultSet(iPtr);
    if(pADOInt == NULL)
        return 0;
    return pADOInt->GetColumnName(iCol, strBuffer, size);
}

//////////////////////////////////////////////////////////////////////////////
// Get a cell's contents
int  DataCompGetRow         (int iPtr, int iRow, LPWSTR strBuffer, int size)
{
    PXSPDataComponentResultSet pADOInt = PXSPDataComponentResultSet(iPtr);
    if(pADOInt == NULL)
        return 0;
    return pADOInt->GetRow(iRow, strBuffer, size);
}

//////////////////////////////////////////////////////////////////////////////
// Get the errors from ADO
int  DataCompGetErrors(int iPtr, LPWSTR strBuffer, int size)
{
    PXSPDataComponentADOInterface pADOInt = PXSPDataComponentADOInterface(iPtr);
    if(pADOInt == NULL)
        return 0;
    return pADOInt->GetErrors(strBuffer, size);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\codegen\vbcomp.cxx ===
/**
 * Code to invoke the VB compiler and build managed DLL's.
 *
 * Copyright (c) 1999 Microsoft Corporation
 */


#include "precomp.h"
#include "codegen.h"

//////////////////////////////////////////////////////////////////////////////
// Prototypes for functions defined here
extern "C"
{
    // This function is called by managed code through NDirect
    HRESULT __stdcall BuildVBProject(LPCWSTR pwzProject, LPCWSTR pwzOutputDll,
        LPCWSTR pwzCompilerOutput, boolean fDebug);
}


/**
 * Build a VB file into a managed DLL
 */
HRESULT BuildVBProject(LPCWSTR pwzProject, LPCWSTR pwzOutputDll,
    LPCWSTR pwzCompilerOutput, boolean fDebug)
{
    HRESULT hr;

    VBCompiler *pCompiler = new VBCompiler(
        pwzProject, pwzOutputDll, pwzCompilerOutput);

    if (pCompiler == NULL)
        return E_OUTOFMEMORY;

    if (fDebug)
        pCompiler->SetDebugMode();

    hr = pCompiler->Compile();

    delete pCompiler;

    return hr;
}


void VBCompiler::AppendCompilerOptions()
{
    // REVIEW: how to set debug mode?

    _sb->Append(L"-o ");
    _sb->Append(_pwzOutputDll);
    _sb->Append(L" -i ");
    _sb->Append(_pwzProject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\datacomp\adoint.h ===
//------------------------------------------------------------------------------
// <copyright file="ADOINT.H" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ADOINT.H
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
//--------------------------------------------------------------------
// Microsoft ADO
//
// (c) 1996-1998 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module	adoint.h | ADO Interface header
//
// @devnote None
//--------------------------------------------------------------------
#ifndef _ADOINT_H_
#define _ADOINT_H_

#ifndef _INC_TCHAR
#include <tchar.h>
#endif

#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif


/* this ALWAYS GENERATED file contains the definitions for the interfaces */
/* File created by MIDL compiler version 3.01.75 */
/* at Thu Jun 18 18:47:02 1998
 */
/* Compiler settings for m_bobj.odl:
    Os (OptLev=s), W4, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef __m_bobj_h__
#define __m_bobj_h__
#ifdef __cplusplus
extern "C"{
#endif 
/* Forward Declarations */ 
#ifndef ___ADOCollection_FWD_DEFINED__
#define ___ADOCollection_FWD_DEFINED__
typedef interface _ADOCollection _ADOCollection;
#endif 	/* ___ADOCollection_FWD_DEFINED__ */
#ifndef ___ADODynaCollection_FWD_DEFINED__
#define ___ADODynaCollection_FWD_DEFINED__
typedef interface _ADODynaCollection _ADODynaCollection;
#endif 	/* ___ADODynaCollection_FWD_DEFINED__ */
#ifndef ___ADO_FWD_DEFINED__
#define ___ADO_FWD_DEFINED__
typedef interface _ADO _ADO;
#endif 	/* ___ADO_FWD_DEFINED__ */
#ifndef __Error_FWD_DEFINED__
#define __Error_FWD_DEFINED__
typedef interface ADOError Error;
#endif 	/* __Error_FWD_DEFINED__ */
#ifndef __Errors_FWD_DEFINED__
#define __Errors_FWD_DEFINED__
typedef interface ADOErrors Errors;
#endif 	/* __Errors_FWD_DEFINED__ */
#ifndef ___Command15_FWD_DEFINED__
#define ___Command15_FWD_DEFINED__
typedef interface _Command15 _Command15;
#endif 	/* ___Command15_FWD_DEFINED__ */
#ifndef ___Command_FWD_DEFINED__
#define ___Command_FWD_DEFINED__
typedef interface _ADOCommand _Command;
#endif 	/* ___Command_FWD_DEFINED__ */
#ifndef __ConnectionEventsVt_FWD_DEFINED__
#define __ConnectionEventsVt_FWD_DEFINED__
typedef interface ConnectionEventsVt ConnectionEventsVt;
#endif 	/* __ConnectionEventsVt_FWD_DEFINED__ */
#ifndef __RecordsetEventsVt_FWD_DEFINED__
#define __RecordsetEventsVt_FWD_DEFINED__
typedef interface RecordsetEventsVt RecordsetEventsVt;
#endif 	/* __RecordsetEventsVt_FWD_DEFINED__ */
#ifndef __ConnectionEvents_FWD_DEFINED__
#define __ConnectionEvents_FWD_DEFINED__
typedef interface ConnectionEvents ConnectionEvents;
#endif 	/* __ConnectionEvents_FWD_DEFINED__ */
#ifndef __RecordsetEvents_FWD_DEFINED__
#define __RecordsetEvents_FWD_DEFINED__
typedef interface RecordsetEvents RecordsetEvents;
#endif 	/* __RecordsetEvents_FWD_DEFINED__ */
#ifndef ___Connection15_FWD_DEFINED__
#define ___Connection15_FWD_DEFINED__
typedef interface _Connection15 _Connection15;
#endif 	/* ___Connection15_FWD_DEFINED__ */
#ifndef ___Connection_FWD_DEFINED__
#define ___Connection_FWD_DEFINED__
typedef interface _ADOConnection _Connection;
#endif 	/* ___Connection_FWD_DEFINED__ */
#ifndef __ADOConnectionConstruction15_FWD_DEFINED__
#define __ADOConnectionConstruction15_FWD_DEFINED__
typedef interface ADOConnectionConstruction15 ADOConnectionConstruction15;
#endif 	/* __ADOConnectionConstruction15_FWD_DEFINED__ */
#ifndef __ADOConnectionConstruction_FWD_DEFINED__
#define __ADOConnectionConstruction_FWD_DEFINED__
typedef interface ADOConnectionConstruction ADOConnectionConstruction;
#endif 	/* __ADOConnectionConstruction_FWD_DEFINED__ */
#ifndef __Connection_FWD_DEFINED__
#define __Connection_FWD_DEFINED__
#ifdef __cplusplus
typedef class ADOConnection Connection;
#else
typedef struct ADOConnection Connection;
#endif /* __cplusplus */
#endif 	/* __Connection_FWD_DEFINED__ */
#ifndef __ADOCommandConstruction_FWD_DEFINED__
#define __ADOCommandConstruction_FWD_DEFINED__
typedef interface ADOCommandConstruction ADOCommandConstruction;
#endif 	/* __ADOCommandConstruction_FWD_DEFINED__ */
#ifndef __Command_FWD_DEFINED__
#define __Command_FWD_DEFINED__
#ifdef __cplusplus
typedef class ADOCommand Command;
#else
typedef struct ADOCommand Command;
#endif /* __cplusplus */
#endif 	/* __Command_FWD_DEFINED__ */
#ifndef ___Recordset15_FWD_DEFINED__
#define ___Recordset15_FWD_DEFINED__
typedef interface _Recordset15 _Recordset15;
#endif 	/* ___Recordset15_FWD_DEFINED__ */
#ifndef ___Recordset_FWD_DEFINED__
#define ___Recordset_FWD_DEFINED__
typedef interface _ADORecordset _Recordset;
#endif 	/* ___Recordset_FWD_DEFINED__ */
#ifndef __Recordset_FWD_DEFINED__
#define __Recordset_FWD_DEFINED__
#ifdef __cplusplus
typedef class ADORecordset Recordset;
#else
typedef struct ADORecordset Recordset;
#endif /* __cplusplus */
#endif 	/* __Recordset_FWD_DEFINED__ */
#ifndef __ADORecordsetConstruction_FWD_DEFINED__
#define __ADORecordsetConstruction_FWD_DEFINED__
typedef interface ADORecordsetConstruction ADORecordsetConstruction;
#endif 	/* __ADORecordsetConstruction_FWD_DEFINED__ */
#ifndef __Field15_FWD_DEFINED__
#define __Field15_FWD_DEFINED__
typedef interface Field15 Field15;
#endif 	/* __Field15_FWD_DEFINED__ */
#ifndef __Field_FWD_DEFINED__
#define __Field_FWD_DEFINED__
typedef interface ADOField Field;
#endif 	/* __Field_FWD_DEFINED__ */
#ifndef __Fields15_FWD_DEFINED__
#define __Fields15_FWD_DEFINED__
typedef interface Fields15 Fields15;
#endif 	/* __Fields15_FWD_DEFINED__ */
#ifndef __Fields_FWD_DEFINED__
#define __Fields_FWD_DEFINED__
typedef interface ADOFields Fields;
#endif 	/* __Fields_FWD_DEFINED__ */
#ifndef ___Parameter_FWD_DEFINED__
#define ___Parameter_FWD_DEFINED__
typedef interface _ADOParameter _Parameter;
#endif 	/* ___Parameter_FWD_DEFINED__ */
#ifndef __Parameter_FWD_DEFINED__
#define __Parameter_FWD_DEFINED__
#ifdef __cplusplus
typedef class ADOParameter Parameter;
#else
typedef struct ADOParameter Parameter;
#endif /* __cplusplus */
#endif 	/* __Parameter_FWD_DEFINED__ */
#ifndef __Parameters_FWD_DEFINED__
#define __Parameters_FWD_DEFINED__
typedef interface ADOParameters Parameters;
#endif 	/* __Parameters_FWD_DEFINED__ */
#ifndef __Property_FWD_DEFINED__
#define __Property_FWD_DEFINED__
typedef interface ADOProperty Property;
#endif 	/* __Property_FWD_DEFINED__ */
#ifndef __Properties_FWD_DEFINED__
#define __Properties_FWD_DEFINED__
typedef interface ADOProperties Properties;
#endif 	/* __Properties_FWD_DEFINED__ */
void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 
/****************************************
 * Generated header for interface: __MIDL_itf_m_bobj_0000
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 
extern RPC_IF_HANDLE __MIDL_itf_m_bobj_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_m_bobj_0000_v0_0_s_ifspec;
#ifndef __ADODB_LIBRARY_DEFINED__
#define __ADODB_LIBRARY_DEFINED__
/****************************************
 * Generated header for library: ADODB
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 
typedef /* [uuid][public] */ 
enum CursorTypeEnum
    {	adOpenUnspecified	= -1,
	adOpenForwardOnly	= 0,
	adOpenKeyset	= 1,
	adOpenDynamic	= 2,
	adOpenStatic	= 3
    }	CursorTypeEnum;
typedef /* [uuid] */ 
enum CursorOptionEnum
    {	adHoldRecords	= 0x100,
	adMovePrevious	= 0x200,
	adAddNew	= 0x1000400,
	adDelete	= 0x1000800,
	adUpdate	= 0x1008000,
	adBookmark	= 0x2000,
	adApproxPosition	= 0x4000,
	adUpdateBatch	= 0x10000,
	adResync	= 0x20000,
	adNotify	= 0x40000,
	adFind	= 0x80000
    }	CursorOptionEnum;
typedef /* [uuid] */ 
enum LockTypeEnum
    {	adLockUnspecified	= -1,
	adLockReadOnly	= 1,
	adLockPessimistic	= 2,
	adLockOptimistic	= 3,
	adLockBatchOptimistic	= 4
    }	LockTypeEnum;
typedef /* [uuid] */ 
enum ExecuteOptionEnum
    {	adOptionUnspecified	= -1,
	adAsyncExecute	= 0x10,
	adAsyncFetch	= 0x20,
	adAsyncFetchNonBlocking	= 0x40,
	adExecuteNoRecords	= 0x80
    }	ExecuteOptionEnum;
typedef /* [uuid] */ 
enum ConnectOptionEnum
    {	adConnectUnspecified	= -1,
	adAsyncConnect	= 0x10
    }	ConnectOptionEnum;
typedef /* [uuid] */ 
enum ObjectStateEnum
    {	adStateClosed	= 0,
	adStateOpen	= 0x1,
	adStateConnecting	= 0x2,
	adStateExecuting	= 0x4,
	adStateFetching	= 0x8
    }	ObjectStateEnum;
typedef /* [uuid] */ 
enum CursorLocationEnum
    {	adUseNone	= 1,
	adUseServer	= 2,
	adUseClient	= 3,
	adUseClientBatch	= 3
    }	CursorLocationEnum;
typedef /* [uuid] */ 
enum DataTypeEnum
    {	adEmpty	= 0,
	adTinyInt	= 16,
	adSmallInt	= 2,
	adInteger	= 3,
	adBigInt	= 20,
	adUnsignedTinyInt	= 17,
	adUnsignedSmallInt	= 18,
	adUnsignedInt	= 19,
	adUnsignedBigInt	= 21,
	adSingle	= 4,
	adDouble	= 5,
	adCurrency	= 6,
	adDecimal	= 14,
	adNumeric	= 131,
	adBoolean	= 11,
	adError	= 10,
	adUserDefined	= 132,
	adVariant	= 12,
	adIDispatch	= 9,
	adIUnknown	= 13,
	adGUID	= 72,
	adDate	= 7,
	adDBDate	= 133,
	adDBTime	= 134,
	adDBTimeStamp	= 135,
	adBSTR	= 8,
	adChar	= 129,
	adVarChar	= 200,
	adLongVarChar	= 201,
	adWChar	= 130,
	adVarWChar	= 202,
	adLongVarWChar	= 203,
	adBinary	= 128,
	adVarBinary	= 204,
	adLongVarBinary	= 205,
	adChapter	= 136,
	adFileTime	= 64,
	adDBFileTime	= 137,
	adPropVariant	= 138,
	adVarNumeric	= 139
    }	DataTypeEnum;
typedef /* [uuid] */ 
enum FieldAttributeEnum
    {	adFldUnspecified	= -1,
	adFldMayDefer	= 0x2,
	adFldUpdatable	= 0x4,
	adFldUnknownUpdatable	= 0x8,
	adFldFixed	= 0x10,
	adFldIsNullable	= 0x20,
	adFldMayBeNull	= 0x40,
	adFldLong	= 0x80,
	adFldRowID	= 0x100,
	adFldRowVersion	= 0x200,
	adFldCacheDeferred	= 0x1000,
	adFldNegativeScale	= 0x4000,
	adFldKeyColumn	= 0x8000
    }	FieldAttributeEnum;
typedef /* [uuid] */ 
enum EditModeEnum
    {	adEditNone	= 0,
	adEditInProgress	= 0x1,
	adEditAdd	= 0x2,
	adEditDelete	= 0x4
    }	EditModeEnum;
typedef /* [uuid] */ 
enum RecordStatusEnum
    {	adRecOK	= 0,
	adRecNew	= 0x1,
	adRecModified	= 0x2,
	adRecDeleted	= 0x4,
	adRecUnmodified	= 0x8,
	adRecInvalid	= 0x10,
	adRecMultipleChanges	= 0x40,
	adRecPendingChanges	= 0x80,
	adRecCanceled	= 0x100,
	adRecCantRelease	= 0x400,
	adRecConcurrencyViolation	= 0x800,
	adRecIntegrityViolation	= 0x1000,
	adRecMaxChangesExceeded	= 0x2000,
	adRecObjectOpen	= 0x4000,
	adRecOutOfMemory	= 0x8000,
	adRecPermissionDenied	= 0x10000,
	adRecSchemaViolation	= 0x20000,
	adRecDBDeleted	= 0x40000
    }	RecordStatusEnum;
typedef /* [uuid] */ 
enum GetRowsOptionEnum
    {	adGetRowsRest	= -1
    }	GetRowsOptionEnum;
typedef /* [uuid] */ 
enum PositionEnum
    {	adPosUnknown	= -1,
	adPosBOF	= -2,
	adPosEOF	= -3
    }	PositionEnum;
typedef 
enum BookmarkEnum
    {	adBookmarkCurrent	= 0,
	adBookmarkFirst	= 1,
	adBookmarkLast	= 2
    }	BookmarkEnum;
typedef /* [uuid] */ 
enum MarshalOptionsEnum
    {	adMarshalAll	= 0,
	adMarshalModifiedOnly	= 1
    }	MarshalOptionsEnum;
typedef /* [uuid] */ 
enum AffectEnum
    {	adAffectCurrent	= 1,
	adAffectGroup	= 2,
	adAffectAll	= 3,
	adAffectAllChapters	= 4
    }	AffectEnum;
typedef /* [uuid] */ 
enum ResyncEnum
    {	adResyncUnderlyingValues	= 1,
	adResyncAllValues	= 2
    }	ResyncEnum;
typedef /* [uuid] */ 
enum CompareEnum
    {	adCompareLessThan	= 0,
	adCompareEqual	= 1,
	adCompareGreaterThan	= 2,
	adCompareNotEqual	= 3,
	adCompareNotComparable	= 4
    }	CompareEnum;
typedef /* [uuid] */ 
enum FilterGroupEnum
    {	adFilterNone	= 0,
	adFilterPendingRecords	= 1,
	adFilterAffectedRecords	= 2,
	adFilterFetchedRecords	= 3,
	adFilterPredicate	= 4,
	adFilterConflictingRecords	= 5
    }	FilterGroupEnum;
typedef /* [uuid] */ 
enum SearchDirectionEnum
    {	adSearchForward	= 1,
	adSearchBackward	= -1
    }	SearchDirectionEnum;
typedef /* [hidden] */ SearchDirectionEnum SearchDirection;
typedef /* [uuid] */ 
enum PersistFormatEnum
    {	adPersistADTG	= 0,
	adPersistXML	= 1
    }	PersistFormatEnum;
typedef /* [uuid] */ 
enum StringFormatEnum
    {	adClipString	= 2
    }	StringFormatEnum;
typedef /* [uuid] */ 
enum ADCPROP_UPDATECRITERIA_ENUM
    {	adCriteriaKey	= 0,
	adCriteriaAllCols	= 1,
	adCriteriaUpdCols	= 2,
	adCriteriaTimeStamp	= 3
    }	ADCPROP_UPDATECRITERIA_ENUM;
typedef /* [uuid] */ 
enum ADCPROP_ASYNCTHREADPRIORITY_ENUM
    {	adPriorityLowest	= 1,
	adPriorityBelowNormal	= 2,
	adPriorityNormal	= 3,
	adPriorityAboveNormal	= 4,
	adPriorityHighest	= 5
    }	ADCPROP_ASYNCTHREADPRIORITY_ENUM;
typedef /* [uuid] */ 
enum ConnectPromptEnum
    {	adPromptAlways	= 1,
	adPromptComplete	= 2,
	adPromptCompleteRequired	= 3,
	adPromptNever	= 4
    }	ConnectPromptEnum;
typedef /* [uuid] */ 
enum ConnectModeEnum
    {	adModeUnknown	= 0,
	adModeRead	= 1,
	adModeWrite	= 2,
	adModeReadWrite	= 3,
	adModeShareDenyRead	= 4,
	adModeShareDenyWrite	= 8,
	adModeShareExclusive	= 0xc,
	adModeShareDenyNone	= 0x10
    }	ConnectModeEnum;
typedef /* [uuid] */ 
enum IsolationLevelEnum
    {	adXactUnspecified	= 0xffffffff,
	adXactChaos	= 0x10,
	adXactReadUncommitted	= 0x100,
	adXactBrowse	= 0x100,
	adXactCursorStability	= 0x1000,
	adXactReadCommitted	= 0x1000,
	adXactRepeatableRead	= 0x10000,
	adXactSerializable	= 0x100000,
	adXactIsolated	= 0x100000
    }	IsolationLevelEnum;
typedef /* [uuid] */ 
enum XactAttributeEnum
    {	adXactCommitRetaining	= 0x20000,
	adXactAbortRetaining	= 0x40000,
	adXactAsyncPhaseOne	= 0x80000,
	adXactSyncPhaseOne	= 0x100000
    }	XactAttributeEnum;
typedef /* [uuid] */ 
enum PropertyAttributesEnum
    {	adPropNotSupported	= 0,
	adPropRequired	= 0x1,
	adPropOptional	= 0x2,
	adPropRead	= 0x200,
	adPropWrite	= 0x400
    }	PropertyAttributesEnum;
typedef /* [uuid] */ 
enum ErrorValueEnum
    {	adErrInvalidArgument	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xbb9),
	adErrNoCurrentRecord	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xbcd),
	adErrIllegalOperation	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xc93),
	adErrInTransaction	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xcae),
	adErrFeatureNotAvailable	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xcb3),
	adErrItemNotFound	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xcc1),
	adErrObjectInADOCollection	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xd27),
	adErrObjectNotSet	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xd5c),
	adErrDataConversion	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xd5d),
	adErrObjectClosed	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xe78),
	adErrObjectOpen	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xe79),
	adErrProviderNotFound	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xe7a),
	adErrBoundToCommand	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xe7b),
	adErrInvalidParamInfo	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xe7c),
	adErrInvalidConnection	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xe7d),
	adErrNotReentrant	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xe7e),
	adErrStillExecuting	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xe7f),
	adErrOperationCancelled	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xe80),
	adErrStillConnecting	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xe81),
	adErrNotExecuting	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xe83),
	adErrUnsafeOperation	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xe84),
    }	ErrorValueEnum;
typedef /* [uuid] */ 
enum ParameterAttributesEnum
    {	adParamSigned	= 0x10,
	adParamNullable	= 0x40,
	adParamLong	= 0x80
    }	ParameterAttributesEnum;
typedef /* [uuid] */ 
enum ParameterDirectionEnum
    {	adParamUnknown	= 0,
	adParamInput	= 0x1,
	adParamOutput	= 0x2,
	adParamInputOutput	= 0x3,
	adParamReturnValue	= 0x4
    }	ParameterDirectionEnum;
typedef /* [uuid] */ 
enum CommandTypeEnum
    {	adCmdUnspecified	= -1,
	adCmdUnknown	= 0x8,
	adCmdText	= 0x1,
	adCmdTable	= 0x2,
	adCmdStoredProc	= 0x4,
	adCmdFile	= 0x100,
	adCmdTableDirect	= 0x200
    }	CommandTypeEnum;
typedef /* [uuid] */ 
enum EventStatusEnum
    {	adStatusOK	= 0x1,
	adStatusErrorsOccurred	= 0x2,
	adStatusCantDeny	= 0x3,
	adStatusCancel	= 0x4,
	adStatusUnwantedEvent	= 0x5
    }	EventStatusEnum;
typedef /* [uuid] */ 
enum EventReasonEnum
    {	adRsnAddNew	= 1,
	adRsnDelete	= 2,
	adRsnUpdate	= 3,
	adRsnUndoUpdate	= 4,
	adRsnUndoAddNew	= 5,
	adRsnUndoDelete	= 6,
	adRsnRequery	= 7,
	adRsnResynch	= 8,
	adRsnClose	= 9,
	adRsnMove	= 10,
	adRsnFirstChange	= 11,
	adRsnMoveFirst	= 12,
	adRsnMoveNext	= 13,
	adRsnMovePrevious	= 14,
	adRsnMoveLast	= 15
    }	EventReasonEnum;
typedef /* [uuid] */ 
enum SchemaEnum
    {	adSchemaProviderSpecific	= -1,
	adSchemaAsserts	= 0,
	adSchemaCatalogs	= 1,
	adSchemaCharacterSets	= 2,
	adSchemaCollations	= 3,
	adSchemaColumns	= 4,
	adSchemaCheckConstraints	= 5,
	adSchemaConstraintColumnUsage	= 6,
	adSchemaConstraintTableUsage	= 7,
	adSchemaKeyColumnUsage	= 8,
	adSchemaReferentialContraints	= 9,
	adSchemaTableConstraints	= 10,
	adSchemaColumnsDomainUsage	= 11,
	adSchemaIndexes	= 12,
	adSchemaColumnPrivileges	= 13,
	adSchemaTablePrivileges	= 14,
	adSchemaUsagePrivileges	= 15,
	adSchemaProcedures	= 16,
	adSchemaSchemata	= 17,
	adSchemaSQLLanguages	= 18,
	adSchemaStatistics	= 19,
	adSchemaTables	= 20,
	adSchemaTranslations	= 21,
	adSchemaProviderTypes	= 22,
	adSchemaViews	= 23,
	adSchemaViewColumnUsage	= 24,
	adSchemaViewTableUsage	= 25,
	adSchemaProcedureParameters	= 26,
	adSchemaForeignKeys	= 27,
	adSchemaPrimaryKeys	= 28,
	adSchemaProcedureColumns	= 29,
	adSchemaDBInfoKeywords	= 30,
	adSchemaDBInfoLiterals	= 31,
	adSchemaCubes	= 32,
	adSchemaDimensions	= 33,
	adSchemaHierarchies	= 34,
	adSchemaLevels	= 35,
	adSchemaMeasures	= 36,
	adSchemaProperties	= 37,
	adSchemaMembers	= 38
    }	SchemaEnum;
EXTERN_C const IID LIBID_ADODB;
#ifndef ___ADOCollection_INTERFACE_DEFINED__
#define ___ADOCollection_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: _ADOCollection
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID__ADOCollection;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000512-0000-0010-8000-00AA006D2EA4")
    _ADOCollection : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *c) = 0;
        
        virtual /* [id][restricted] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct _ADOCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _ADOCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _ADOCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _ADOCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _ADOCollection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _ADOCollection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _ADOCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _ADOCollection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            _ADOCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            _ADOCollection __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            _ADOCollection __RPC_FAR * This);
        
        END_INTERFACE
    } _ADOCollectionVtbl;
    interface _ADOCollection
    {
        CONST_VTBL struct _ADOCollectionVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define _ADOCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define _ADOCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define _ADOCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define _ADOCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define _ADOCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define _ADOCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define _ADOCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define _Collection_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)
#define _ADOCollection__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)
#define _ADOCollection_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [propget] */ HRESULT STDMETHODCALLTYPE _Collection_get_Count_Proxy( 
    _ADOCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *c);
void __RPC_STUB _Collection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][restricted] */ HRESULT STDMETHODCALLTYPE _ADOCollection__NewEnum_Proxy( 
    _ADOCollection __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB _ADOCollection__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
HRESULT STDMETHODCALLTYPE _ADOCollection_Refresh_Proxy( 
    _ADOCollection __RPC_FAR * This);
void __RPC_STUB _ADOCollection_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* ___ADOCollection_INTERFACE_DEFINED__ */
#ifndef ___ADODynaCollection_INTERFACE_DEFINED__
#define ___ADODynaCollection_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: _ADODynaCollection
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID__ADODynaCollection;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000513-0000-0010-8000-00AA006D2EA4")
_ADODynaCollection : public _ADOCollection
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ IDispatch __RPC_FAR *Object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ VARIANT Index) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct _ADODynaCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _ADODynaCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _ADODynaCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _ADODynaCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _ADODynaCollection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _ADODynaCollection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _ADODynaCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _ADODynaCollection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            _ADODynaCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            _ADODynaCollection __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            _ADODynaCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Append )( 
            _ADODynaCollection __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *Object);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            _ADODynaCollection __RPC_FAR * This,
            /* [in] */ VARIANT Index);
        
        END_INTERFACE
    } _ADODynaCollectionVtbl;
    interface _ADODynaCollection
    {
        CONST_VTBL struct _ADODynaCollectionVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define _ADODynaCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define _ADODynaCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define _ADODynaCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define _ADODynaCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define _ADODynaCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define _ADODynaCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define _ADODynaCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define _DynaCollection_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)
#define _ADODynaCollection__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)
#define _ADODynaCollection_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)
#define _ADODynaCollection_Append(This,Object)	\
    (This)->lpVtbl -> Append(This,Object)
#define _ADODynaCollection_Delete(This,Index)	\
    (This)->lpVtbl -> Delete(This,Index)
#endif /* COBJMACROS */
#endif 	/* C style interface */
HRESULT STDMETHODCALLTYPE _ADODynaCollection_Append_Proxy( 
    _ADODynaCollection __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *Object);
void __RPC_STUB _ADODynaCollection_Append_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
HRESULT STDMETHODCALLTYPE _ADODynaCollection_Delete_Proxy( 
    _ADODynaCollection __RPC_FAR * This,
    /* [in] */ VARIANT Index);
void __RPC_STUB _ADODynaCollection_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* ___ADODynaCollection_INTERFACE_DEFINED__ */
#ifndef ___ADO_INTERFACE_DEFINED__
#define ___ADO_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: _ADO
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID__ADO;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000534-0000-0010-8000-00AA006D2EA4")
    _ADO : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ ADOProperties __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct _ADOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _ADO __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _ADO __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _ADO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _ADO __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _ADO __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _ADO __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _ADO __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            _ADO __RPC_FAR * This,
            /* [retval][out] */ ADOProperties __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } _ADOVtbl;
    interface _ADO
    {
        CONST_VTBL struct _ADOVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define _ADO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define _ADO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define _ADO_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define _ADO_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define _ADO_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define _ADO_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define _ADO_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define _ADO_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _ADO_get_Properties_Proxy( 
    _ADO __RPC_FAR * This,
    /* [retval][out] */ ADOProperties __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB _ADO_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* ___ADO_INTERFACE_DEFINED__ */
#ifndef __Error_INTERFACE_DEFINED__
#define __Error_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: Error
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID_Error;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000500-0000-0010-8000-00AA006D2EA4")
    ADOError : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Number( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Source( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HelpFile( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HelpContext( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SQLState( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_NativeError( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct ErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ADOError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ADOError __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ADOError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ADOError __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ADOError __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ADOError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ADOError __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Number )( 
            ADOError __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Source )( 
            ADOError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            ADOError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HelpFile )( 
            ADOError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HelpContext )( 
            ADOError __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SQLState )( 
            ADOError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NativeError )( 
            ADOError __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        END_INTERFACE
    } ErrorVtbl;
    interface Error
    {
        CONST_VTBL struct ErrorVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define Error_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define Error_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define Error_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define Error_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define Error_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define Error_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define Error_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define Error_get_Number(This,pl)	\
    (This)->lpVtbl -> get_Number(This,pl)
#define Error_get_Source(This,pbstr)	\
    (This)->lpVtbl -> get_Source(This,pbstr)
#define Error_get_Description(This,pbstr)	\
    (This)->lpVtbl -> get_Description(This,pbstr)
#define Error_get_HelpFile(This,pbstr)	\
    (This)->lpVtbl -> get_HelpFile(This,pbstr)
#define Error_get_HelpContext(This,pl)	\
    (This)->lpVtbl -> get_HelpContext(This,pl)
#define Error_get_SQLState(This,pbstr)	\
    (This)->lpVtbl -> get_SQLState(This,pbstr)
#define Error_get_NativeError(This,pl)	\
    (This)->lpVtbl -> get_NativeError(This,pl)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [propget] */ HRESULT STDMETHODCALLTYPE Error_get_Number_Proxy( 
    ADOError __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB Error_get_Number_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE Error_get_Source_Proxy( 
    ADOError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB Error_get_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propget] */ HRESULT STDMETHODCALLTYPE Error_get_Description_Proxy( 
    ADOError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB Error_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE Error_get_HelpFile_Proxy( 
    ADOError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB Error_get_HelpFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE Error_get_HelpContext_Proxy( 
    ADOError __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB Error_get_HelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE Error_get_SQLState_Proxy( 
    ADOError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB Error_get_SQLState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE Error_get_NativeError_Proxy( 
    ADOError __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB Error_get_NativeError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __Error_INTERFACE_DEFINED__ */
#ifndef __Errors_INTERFACE_DEFINED__
#define __Errors_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: Errors
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID_Errors;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000501-0000-0010-8000-00AA006D2EA4")
    ADOErrors : public _ADOCollection
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ ADOError __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct ErrorsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ADOErrors __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ADOErrors __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ADOErrors __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ADOErrors __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ADOErrors __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ADOErrors __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ADOErrors __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ADOErrors __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            ADOErrors __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            ADOErrors __RPC_FAR * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ADOErrors __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ ADOError __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            ADOErrors __RPC_FAR * This);
        
        END_INTERFACE
    } ErrorsVtbl;
    interface Errors
    {
        CONST_VTBL struct ErrorsVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define Errors_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define Errors_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define Errors_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define Errors_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define Errors_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define Errors_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define Errors_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define Errors_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)
#define Errors__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)
#define Errors_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)
#define Errors_get_Item(This,Index,ppvObject)	\
    (This)->lpVtbl -> get_Item(This,Index,ppvObject)
#define Errors_Clear(This)	\
    (This)->lpVtbl -> Clear(This)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [id][propget] */ HRESULT STDMETHODCALLTYPE Errors_get_Item_Proxy( 
    ADOErrors __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ ADOError __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB Errors_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
HRESULT STDMETHODCALLTYPE Errors_Clear_Proxy( 
    ADOErrors __RPC_FAR * This);
void __RPC_STUB Errors_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __Errors_INTERFACE_DEFINED__ */
#ifndef ___Command15_INTERFACE_DEFINED__
#define ___Command15_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: _Command15
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][hidden][nonextensible][dual] */ 
EXTERN_C const IID IID__Command15;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000508-0000-0010-8000-00AA006D2EA4")
    _Command15 : public _ADO
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ActiveConnection( 
            /* [retval][out] */ _ADOConnection __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [propputref] */ HRESULT STDMETHODCALLTYPE putref_ActiveConnection( 
            /* [in] */ _ADOConnection __RPC_FAR *pCon) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ActiveConnection( 
            /* [in] */ VARIANT vConn) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CommandText( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CommandText( 
            /* [in] */ BSTR bstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CommandTimeout( 
            /* [retval][out] */ LONG __RPC_FAR *pl) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CommandTimeout( 
            /* [in] */ LONG Timeout) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Prepared( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfPrepared) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Prepared( 
            /* [in] */ VARIANT_BOOL fPrepared) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Execute( 
            /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
            /* [optional][in] */ VARIANT __RPC_FAR *Parameters,
            /* [defaultvalue][in] */ long Options,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppirs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateParameter( 
            /* [defaultvalue][in] */ BSTR Name,
            /* [defaultvalue][in] */ DataTypeEnum Type,
            /* [defaultvalue][in] */ ParameterDirectionEnum Direction,
            /* [defaultvalue][in] */ long Size,
            /* [optional][in] */ VARIANT Value,
            /* [retval][out] */ _ADOParameter __RPC_FAR *__RPC_FAR *ppiprm) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Parameters( 
            /* [retval][out] */ ADOParameters __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CommandType( 
            /* [in] */ CommandTypeEnum lCmdType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CommandType( 
            /* [retval][out] */ CommandTypeEnum __RPC_FAR *plCmdType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR bstrName) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct _Command15Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _Command15 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _Command15 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _Command15 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _Command15 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _Command15 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _Command15 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _Command15 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            _Command15 __RPC_FAR * This,
            /* [retval][out] */ ADOProperties __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActiveConnection )( 
            _Command15 __RPC_FAR * This,
            /* [retval][out] */ _ADOConnection __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_ActiveADOConnection )( 
            _Command15 __RPC_FAR * This,
            /* [in] */ _ADOConnection __RPC_FAR *pCon);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActiveConnection )( 
            _Command15 __RPC_FAR * This,
            /* [in] */ VARIANT vConn);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommandText )( 
            _Command15 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CommandText )( 
            _Command15 __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommandTimeout )( 
            _Command15 __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pl);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CommandTimeout )( 
            _Command15 __RPC_FAR * This,
            /* [in] */ LONG Timeout);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Prepared )( 
            _Command15 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfPrepared);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Prepared )( 
            _Command15 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fPrepared);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Execute )( 
            _Command15 __RPC_FAR * This,
            /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
            /* [optional][in] */ VARIANT __RPC_FAR *Parameters,
            /* [defaultvalue][in] */ long Options,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppirs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateParameter )( 
            _Command15 __RPC_FAR * This,
            /* [defaultvalue][in] */ BSTR Name,
            /* [defaultvalue][in] */ DataTypeEnum Type,
            /* [defaultvalue][in] */ ParameterDirectionEnum Direction,
            /* [defaultvalue][in] */ long Size,
            /* [optional][in] */ VARIANT Value,
            /* [retval][out] */ _ADOParameter __RPC_FAR *__RPC_FAR *ppiprm);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parameters )( 
            _Command15 __RPC_FAR * This,
            /* [retval][out] */ ADOParameters __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CommandType )( 
            _Command15 __RPC_FAR * This,
            /* [in] */ CommandTypeEnum lCmdType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommandType )( 
            _Command15 __RPC_FAR * This,
            /* [retval][out] */ CommandTypeEnum __RPC_FAR *plCmdType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            _Command15 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            _Command15 __RPC_FAR * This,
            /* [in] */ BSTR bstrName);
        
        END_INTERFACE
    } _Command15Vtbl;
    interface _Command15
    {
        CONST_VTBL struct _Command15Vtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define _Command15_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define _Command15_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define _Command15_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define _Command15_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define _Command15_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define _Command15_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define _Command15_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define _Command15_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)
#define _Command15_get_ActiveConnection(This,ppvObject)	\
    (This)->lpVtbl -> get_ActiveConnection(This,ppvObject)
#define _Command15_putref_ActiveConnection(This,pCon)	\
    (This)->lpVtbl -> putref_ActiveConnection(This,pCon)
#define _Command15_put_ActiveConnection(This,vConn)	\
    (This)->lpVtbl -> put_ActiveConnection(This,vConn)
#define _Command15_get_CommandText(This,pbstr)	\
    (This)->lpVtbl -> get_CommandText(This,pbstr)
#define _Command15_put_CommandText(This,bstr)	\
    (This)->lpVtbl -> put_CommandText(This,bstr)
#define _Command15_get_CommandTimeout(This,pl)	\
    (This)->lpVtbl -> get_CommandTimeout(This,pl)
#define _Command15_put_CommandTimeout(This,Timeout)	\
    (This)->lpVtbl -> put_CommandTimeout(This,Timeout)
#define _Command15_get_Prepared(This,pfPrepared)	\
    (This)->lpVtbl -> get_Prepared(This,pfPrepared)
#define _Command15_put_Prepared(This,fPrepared)	\
    (This)->lpVtbl -> put_Prepared(This,fPrepared)
#define _Command15_Execute(This,RecordsAffected,Parameters,Options,ppirs)	\
    (This)->lpVtbl -> Execute(This,RecordsAffected,Parameters,Options,ppirs)
#define _Command15_CreateParameter(This,Name,Type,Direction,Size,Value,ppiprm)	\
    (This)->lpVtbl -> CreateParameter(This,Name,Type,Direction,Size,Value,ppiprm)
#define _Command15_get_Parameters(This,ppvObject)	\
    (This)->lpVtbl -> get_Parameters(This,ppvObject)
#define _Command15_put_CommandType(This,lCmdType)	\
    (This)->lpVtbl -> put_CommandType(This,lCmdType)
#define _Command15_get_CommandType(This,plCmdType)	\
    (This)->lpVtbl -> get_CommandType(This,plCmdType)
#define _Command15_get_Name(This,pbstrName)	\
    (This)->lpVtbl -> get_Name(This,pbstrName)
#define _Command15_put_Name(This,bstrName)	\
    (This)->lpVtbl -> put_Name(This,bstrName)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [propget] */ HRESULT STDMETHODCALLTYPE _Command15_get_ActiveConnection_Proxy( 
    _Command15 __RPC_FAR * This,
    /* [retval][out] */ _ADOConnection __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB _Command15_get_ActiveConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propputref] */ HRESULT STDMETHODCALLTYPE _Command15_putref_ActiveConnection_Proxy( 
    _Command15 __RPC_FAR * This,
    /* [in] */ _ADOConnection __RPC_FAR *pCon);
void __RPC_STUB _Command15_putref_ActiveConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE _Command15_put_ActiveConnection_Proxy( 
    _Command15 __RPC_FAR * This,
    /* [in] */ VARIANT vConn);
void __RPC_STUB _Command15_put_ActiveConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE _Command15_get_CommandText_Proxy( 
    _Command15 __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB _Command15_get_CommandText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE _Command15_put_CommandText_Proxy( 
    _Command15 __RPC_FAR * This,
    /* [in] */ BSTR bstr);
void __RPC_STUB _Command15_put_CommandText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE _Command15_get_CommandTimeout_Proxy( 
    _Command15 __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pl);
void __RPC_STUB _Command15_get_CommandTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE _Command15_put_CommandTimeout_Proxy( 
    _Command15 __RPC_FAR * This,
    /* [in] */ LONG Timeout);
void __RPC_STUB _Command15_put_CommandTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE _Command15_get_Prepared_Proxy( 
    _Command15 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfPrepared);
void __RPC_STUB _Command15_get_Prepared_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE _Command15_put_Prepared_Proxy( 
    _Command15 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fPrepared);
void __RPC_STUB _Command15_put_Prepared_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
HRESULT STDMETHODCALLTYPE _Command15_Execute_Proxy( 
    _Command15 __RPC_FAR * This,
    /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
    /* [optional][in] */ VARIANT __RPC_FAR *Parameters,
    /* [defaultvalue][in] */ long Options,
    /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppirs);
void __RPC_STUB _Command15_Execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
HRESULT STDMETHODCALLTYPE _Command15_CreateParameter_Proxy( 
    _Command15 __RPC_FAR * This,
    /* [defaultvalue][in] */ BSTR Name,
    /* [defaultvalue][in] */ DataTypeEnum Type,
    /* [defaultvalue][in] */ ParameterDirectionEnum Direction,
    /* [defaultvalue][in] */ long Size,
    /* [optional][in] */ VARIANT Value,
    /* [retval][out] */ _ADOParameter __RPC_FAR *__RPC_FAR *ppiprm);
void __RPC_STUB _Command15_CreateParameter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _Command15_get_Parameters_Proxy( 
    _Command15 __RPC_FAR * This,
    /* [retval][out] */ ADOParameters __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB _Command15_get_Parameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE _Command15_put_CommandType_Proxy( 
    _Command15 __RPC_FAR * This,
    /* [in] */ CommandTypeEnum lCmdType);
void __RPC_STUB _Command15_put_CommandType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE _Command15_get_CommandType_Proxy( 
    _Command15 __RPC_FAR * This,
    /* [retval][out] */ CommandTypeEnum __RPC_FAR *plCmdType);
void __RPC_STUB _Command15_get_CommandType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE _Command15_get_Name_Proxy( 
    _Command15 __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
void __RPC_STUB _Command15_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE _Command15_put_Name_Proxy( 
    _Command15 __RPC_FAR * This,
    /* [in] */ BSTR bstrName);
void __RPC_STUB _Command15_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* ___Command15_INTERFACE_DEFINED__ */
#ifndef ___Command_INTERFACE_DEFINED__
#define ___Command_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: _Command
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID__Command;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0000054E-0000-0010-8000-00AA006D2EA4")
    _ADOCommand : public _Command15
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ LONG __RPC_FAR *plObjState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct _CommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _ADOCommand __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _ADOCommand __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _ADOCommand __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            _ADOCommand __RPC_FAR * This,
            /* [retval][out] */ ADOProperties __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActiveConnection )( 
            _ADOCommand __RPC_FAR * This,
            /* [retval][out] */ _ADOConnection __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_ActiveADOConnection )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ _ADOConnection __RPC_FAR *pCon);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActiveConnection )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ VARIANT vConn);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommandText )( 
            _ADOCommand __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CommandText )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommandTimeout )( 
            _ADOCommand __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pl);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CommandTimeout )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ LONG Timeout);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Prepared )( 
            _ADOCommand __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfPrepared);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Prepared )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fPrepared);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Execute )( 
            _ADOCommand __RPC_FAR * This,
            /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
            /* [optional][in] */ VARIANT __RPC_FAR *Parameters,
            /* [defaultvalue][in] */ long Options,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppirs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateParameter )( 
            _ADOCommand __RPC_FAR * This,
            /* [defaultvalue][in] */ BSTR Name,
            /* [defaultvalue][in] */ DataTypeEnum Type,
            /* [defaultvalue][in] */ ParameterDirectionEnum Direction,
            /* [defaultvalue][in] */ long Size,
            /* [optional][in] */ VARIANT Value,
            /* [retval][out] */ _ADOParameter __RPC_FAR *__RPC_FAR *ppiprm);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parameters )( 
            _ADOCommand __RPC_FAR * This,
            /* [retval][out] */ ADOParameters __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CommandType )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ CommandTypeEnum lCmdType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommandType )( 
            _ADOCommand __RPC_FAR * This,
            /* [retval][out] */ CommandTypeEnum __RPC_FAR *plCmdType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            _ADOCommand __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            _ADOCommand __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plObjState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cancel )( 
            _ADOCommand __RPC_FAR * This);
        
        END_INTERFACE
    } _CommandVtbl;
    interface _Command
    {
        CONST_VTBL struct _CommandVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define _Command_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define _Command_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define _Command_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define _Command_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define _Command_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define _Command_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define _Command_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define _Command_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)
#define _Command_get_ActiveConnection(This,ppvObject)	\
    (This)->lpVtbl -> get_ActiveConnection(This,ppvObject)
#define _Command_putref_ActiveConnection(This,pCon)	\
    (This)->lpVtbl -> putref_ActiveConnection(This,pCon)
#define _Command_put_ActiveConnection(This,vConn)	\
    (This)->lpVtbl -> put_ActiveConnection(This,vConn)
#define _Command_get_CommandText(This,pbstr)	\
    (This)->lpVtbl -> get_CommandText(This,pbstr)
#define _Command_put_CommandText(This,bstr)	\
    (This)->lpVtbl -> put_CommandText(This,bstr)
#define _Command_get_CommandTimeout(This,pl)	\
    (This)->lpVtbl -> get_CommandTimeout(This,pl)
#define _Command_put_CommandTimeout(This,Timeout)	\
    (This)->lpVtbl -> put_CommandTimeout(This,Timeout)
#define _Command_get_Prepared(This,pfPrepared)	\
    (This)->lpVtbl -> get_Prepared(This,pfPrepared)
#define _Command_put_Prepared(This,fPrepared)	\
    (This)->lpVtbl -> put_Prepared(This,fPrepared)
#define _Command_Execute(This,RecordsAffected,Parameters,Options,ppirs)	\
    (This)->lpVtbl -> Execute(This,RecordsAffected,Parameters,Options,ppirs)
#define _Command_CreateParameter(This,Name,Type,Direction,Size,Value,ppiprm)	\
    (This)->lpVtbl -> CreateParameter(This,Name,Type,Direction,Size,Value,ppiprm)
#define _Command_get_Parameters(This,ppvObject)	\
    (This)->lpVtbl -> get_Parameters(This,ppvObject)
#define _Command_put_CommandType(This,lCmdType)	\
    (This)->lpVtbl -> put_CommandType(This,lCmdType)
#define _Command_get_CommandType(This,plCmdType)	\
    (This)->lpVtbl -> get_CommandType(This,plCmdType)
#define _Command_get_Name(This,pbstrName)	\
    (This)->lpVtbl -> get_Name(This,pbstrName)
#define _Command_put_Name(This,bstrName)	\
    (This)->lpVtbl -> put_Name(This,bstrName)
#define _Command_get_State(This,plObjState)	\
    (This)->lpVtbl -> get_State(This,plObjState)
#define _Command_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [propget] */ HRESULT STDMETHODCALLTYPE _Command_get_State_Proxy( 
    _ADOCommand __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plObjState);
void __RPC_STUB _Command_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
HRESULT STDMETHODCALLTYPE _Command_Cancel_Proxy( 
    _ADOCommand __RPC_FAR * This);
void __RPC_STUB _Command_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* ___Command_INTERFACE_DEFINED__ */
#ifndef __ConnectionEventsVt_INTERFACE_DEFINED__
#define __ConnectionEventsVt_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: ConnectionEventsVt
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][hidden] */ 
EXTERN_C const IID IID_ConnectionEventsVt;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000402-0000-0010-8000-00AA006D2EA4")
    ConnectionEventsVt : public IUnknown
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE InfoMessage( 
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADOConnection __RPC_FAR *pConnection) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BeginTransComplete( 
            /* [in] */ LONG TransactionLevel,
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADOConnection __RPC_FAR *pConnection) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CommitTransComplete( 
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADOConnection __RPC_FAR *pConnection) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RollbackTransComplete( 
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADOConnection __RPC_FAR *pConnection) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE WillExecute( 
            /* [out][in] */ BSTR __RPC_FAR *Source,
            /* [out][in] */ CursorTypeEnum __RPC_FAR *CursorType,
            /* [out][in] */ LockTypeEnum __RPC_FAR *LockType,
            /* [out][in] */ long __RPC_FAR *Options,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADOCommand __RPC_FAR *pCommand,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset,
            /* [in] */ _ADOConnection __RPC_FAR *pConnection) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ExecuteComplete( 
            /* [in] */ LONG RecordsAffected,
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADOCommand __RPC_FAR *pCommand,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset,
            /* [in] */ _ADOConnection __RPC_FAR *pConnection) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE WillConnect( 
            /* [out][in] */ BSTR __RPC_FAR *ConnectionString,
            /* [out][in] */ BSTR __RPC_FAR *UserID,
            /* [out][in] */ BSTR __RPC_FAR *Password,
            /* [out][in] */ long __RPC_FAR *Options,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADOConnection __RPC_FAR *pConnection) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ConnectComplete( 
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADOConnection __RPC_FAR *pConnection) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Disconnect( 
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADOConnection __RPC_FAR *pConnection) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct ConnectionEventsVtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ConnectionEventsVt __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ConnectionEventsVt __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ConnectionEventsVt __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InfoMessage )( 
            ConnectionEventsVt __RPC_FAR * This,
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADOConnection __RPC_FAR *pConnection);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginTransComplete )( 
            ConnectionEventsVt __RPC_FAR * This,
            /* [in] */ LONG TransactionLevel,
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADOConnection __RPC_FAR *pConnection);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommitTransComplete )( 
            ConnectionEventsVt __RPC_FAR * This,
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADOConnection __RPC_FAR *pConnection);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RollbackTransComplete )( 
            ConnectionEventsVt __RPC_FAR * This,
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADOConnection __RPC_FAR *pConnection);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WillExecute )( 
            ConnectionEventsVt __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *Source,
            /* [out][in] */ CursorTypeEnum __RPC_FAR *CursorType,
            /* [out][in] */ LockTypeEnum __RPC_FAR *LockType,
            /* [out][in] */ long __RPC_FAR *Options,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADOCommand __RPC_FAR *pCommand,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset,
            /* [in] */ _ADOConnection __RPC_FAR *pConnection);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecuteComplete )( 
            ConnectionEventsVt __RPC_FAR * This,
            /* [in] */ LONG RecordsAffected,
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADOCommand __RPC_FAR *pCommand,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset,
            /* [in] */ _ADOConnection __RPC_FAR *pConnection);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WillConnect )( 
            ConnectionEventsVt __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *ConnectionString,
            /* [out][in] */ BSTR __RPC_FAR *UserID,
            /* [out][in] */ BSTR __RPC_FAR *Password,
            /* [out][in] */ long __RPC_FAR *Options,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADOConnection __RPC_FAR *pConnection);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConnectComplete )( 
            ConnectionEventsVt __RPC_FAR * This,
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADOConnection __RPC_FAR *pConnection);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            ConnectionEventsVt __RPC_FAR * This,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADOConnection __RPC_FAR *pConnection);
        
        END_INTERFACE
    } ConnectionEventsVtVtbl;
    interface ConnectionEventsVt
    {
        CONST_VTBL struct ConnectionEventsVtVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define ConnectionEventsVt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define ConnectionEventsVt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define ConnectionEventsVt_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define ConnectionEventsVt_InfoMessage(This,pError,adStatus,pConnection)	\
    (This)->lpVtbl -> InfoMessage(This,pError,adStatus,pConnection)
#define ConnectionEventsVt_BeginTransComplete(This,TransactionLevel,pError,adStatus,pConnection)	\
    (This)->lpVtbl -> BeginTransComplete(This,TransactionLevel,pError,adStatus,pConnection)
#define ConnectionEventsVt_CommitTransComplete(This,pError,adStatus,pConnection)	\
    (This)->lpVtbl -> CommitTransComplete(This,pError,adStatus,pConnection)
#define ConnectionEventsVt_RollbackTransComplete(This,pError,adStatus,pConnection)	\
    (This)->lpVtbl -> RollbackTransComplete(This,pError,adStatus,pConnection)
#define ConnectionEventsVt_WillExecute(This,Source,CursorType,LockType,Options,adStatus,pCommand,pRecordset,pConnection)	\
    (This)->lpVtbl -> WillExecute(This,Source,CursorType,LockType,Options,adStatus,pCommand,pRecordset,pConnection)
#define ConnectionEventsVt_ExecuteComplete(This,RecordsAffected,pError,adStatus,pCommand,pRecordset,pConnection)	\
    (This)->lpVtbl -> ExecuteComplete(This,RecordsAffected,pError,adStatus,pCommand,pRecordset,pConnection)
#define ConnectionEventsVt_WillConnect(This,ConnectionString,UserID,Password,Options,adStatus,pConnection)	\
    (This)->lpVtbl -> WillConnect(This,ConnectionString,UserID,Password,Options,adStatus,pConnection)
#define ConnectionEventsVt_ConnectComplete(This,pError,adStatus,pConnection)	\
    (This)->lpVtbl -> ConnectComplete(This,pError,adStatus,pConnection)
#define ConnectionEventsVt_Disconnect(This,adStatus,pConnection)	\
    (This)->lpVtbl -> Disconnect(This,adStatus,pConnection)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [id] */ HRESULT STDMETHODCALLTYPE ConnectionEventsVt_InfoMessage_Proxy( 
    ConnectionEventsVt __RPC_FAR * This,
    /* [in] */ ADOError __RPC_FAR *pError,
    /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
    /* [in] */ _ADOConnection __RPC_FAR *pConnection);
void __RPC_STUB ConnectionEventsVt_InfoMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE ConnectionEventsVt_BeginTransComplete_Proxy( 
    ConnectionEventsVt __RPC_FAR * This,
    /* [in] */ LONG TransactionLevel,
    /* [in] */ ADOError __RPC_FAR *pError,
    /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
    /* [in] */ _ADOConnection __RPC_FAR *pConnection);
void __RPC_STUB ConnectionEventsVt_BeginTransComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE ConnectionEventsVt_CommitTransComplete_Proxy( 
    ConnectionEventsVt __RPC_FAR * This,
    /* [in] */ ADOError __RPC_FAR *pError,
    /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
    /* [in] */ _ADOConnection __RPC_FAR *pConnection);
void __RPC_STUB ConnectionEventsVt_CommitTransComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE ConnectionEventsVt_RollbackTransComplete_Proxy( 
    ConnectionEventsVt __RPC_FAR * This,
    /* [in] */ ADOError __RPC_FAR *pError,
    /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
    /* [in] */ _ADOConnection __RPC_FAR *pConnection);
void __RPC_STUB ConnectionEventsVt_RollbackTransComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE ConnectionEventsVt_WillExecute_Proxy( 
    ConnectionEventsVt __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *Source,
    /* [out][in] */ CursorTypeEnum __RPC_FAR *CursorType,
    /* [out][in] */ LockTypeEnum __RPC_FAR *LockType,
    /* [out][in] */ long __RPC_FAR *Options,
    /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
    /* [in] */ _ADOCommand __RPC_FAR *pCommand,
    /* [in] */ _ADORecordset __RPC_FAR *pRecordset,
    /* [in] */ _ADOConnection __RPC_FAR *pConnection);
void __RPC_STUB ConnectionEventsVt_WillExecute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE ConnectionEventsVt_ExecuteComplete_Proxy( 
    ConnectionEventsVt __RPC_FAR * This,
    /* [in] */ LONG RecordsAffected,
    /* [in] */ ADOError __RPC_FAR *pError,
    /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
    /* [in] */ _ADOCommand __RPC_FAR *pCommand,
    /* [in] */ _ADORecordset __RPC_FAR *pRecordset,
    /* [in] */ _ADOConnection __RPC_FAR *pConnection);
void __RPC_STUB ConnectionEventsVt_ExecuteComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE ConnectionEventsVt_WillConnect_Proxy( 
    ConnectionEventsVt __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *ConnectionString,
    /* [out][in] */ BSTR __RPC_FAR *UserID,
    /* [out][in] */ BSTR __RPC_FAR *Password,
    /* [out][in] */ long __RPC_FAR *Options,
    /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
    /* [in] */ _ADOConnection __RPC_FAR *pConnection);
void __RPC_STUB ConnectionEventsVt_WillConnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE ConnectionEventsVt_ConnectComplete_Proxy( 
    ConnectionEventsVt __RPC_FAR * This,
    /* [in] */ ADOError __RPC_FAR *pError,
    /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
    /* [in] */ _ADOConnection __RPC_FAR *pConnection);
void __RPC_STUB ConnectionEventsVt_ConnectComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE ConnectionEventsVt_Disconnect_Proxy( 
    ConnectionEventsVt __RPC_FAR * This,
    /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
    /* [in] */ _ADOConnection __RPC_FAR *pConnection);
void __RPC_STUB ConnectionEventsVt_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __ConnectionEventsVt_INTERFACE_DEFINED__ */
#ifndef __RecordsetEventsVt_INTERFACE_DEFINED__
#define __RecordsetEventsVt_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: RecordsetEventsVt
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][hidden] */ 
EXTERN_C const IID IID_RecordsetEventsVt;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000403-0000-0010-8000-00AA006D2EA4")
    RecordsetEventsVt : public IUnknown
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE WillChangeField( 
            /* [in] */ LONG cFields,
            /* [in] */ VARIANT Fields,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FieldChangeComplete( 
            /* [in] */ LONG cFields,
            /* [in] */ VARIANT Fields,
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE WillChangeRecord( 
            /* [in] */ EventReasonEnum adReason,
            /* [in] */ LONG cRecords,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RecordChangeComplete( 
            /* [in] */ EventReasonEnum adReason,
            /* [in] */ LONG cRecords,
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE WillChangeRecordset( 
            /* [in] */ EventReasonEnum adReason,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RecordsetChangeComplete( 
            /* [in] */ EventReasonEnum adReason,
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE WillMove( 
            /* [in] */ EventReasonEnum adReason,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveComplete( 
            /* [in] */ EventReasonEnum adReason,
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndOfRecordset( 
            /* [out][in] */ VARIANT_BOOL __RPC_FAR *fMoreData,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FetchProgress( 
            /* [in] */ long Progress,
            /* [in] */ long MaxProgress,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FetchComplete( 
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct RecordsetEventsVtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            RecordsetEventsVt __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            RecordsetEventsVt __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            RecordsetEventsVt __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WillChangeADOField )( 
            RecordsetEventsVt __RPC_FAR * This,
            /* [in] */ LONG cFields,
            /* [in] */ VARIANT Fields,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FieldChangeComplete )( 
            RecordsetEventsVt __RPC_FAR * This,
            /* [in] */ LONG cFields,
            /* [in] */ VARIANT Fields,
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WillChangeRecord )( 
            RecordsetEventsVt __RPC_FAR * This,
            /* [in] */ EventReasonEnum adReason,
            /* [in] */ LONG cRecords,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RecordChangeComplete )( 
            RecordsetEventsVt __RPC_FAR * This,
            /* [in] */ EventReasonEnum adReason,
            /* [in] */ LONG cRecords,
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WillChangeADORecordset )( 
            RecordsetEventsVt __RPC_FAR * This,
            /* [in] */ EventReasonEnum adReason,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RecordsetChangeComplete )( 
            RecordsetEventsVt __RPC_FAR * This,
            /* [in] */ EventReasonEnum adReason,
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WillMove )( 
            RecordsetEventsVt __RPC_FAR * This,
            /* [in] */ EventReasonEnum adReason,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveComplete )( 
            RecordsetEventsVt __RPC_FAR * This,
            /* [in] */ EventReasonEnum adReason,
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndOfADORecordset )( 
            RecordsetEventsVt __RPC_FAR * This,
            /* [out][in] */ VARIANT_BOOL __RPC_FAR *fMoreData,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FetchProgress )( 
            RecordsetEventsVt __RPC_FAR * This,
            /* [in] */ long Progress,
            /* [in] */ long MaxProgress,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FetchComplete )( 
            RecordsetEventsVt __RPC_FAR * This,
            /* [in] */ ADOError __RPC_FAR *pError,
            /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
            /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
        
        END_INTERFACE
    } RecordsetEventsVtVtbl;
    interface RecordsetEventsVt
    {
        CONST_VTBL struct RecordsetEventsVtVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define RecordsetEventsVt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define RecordsetEventsVt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define RecordsetEventsVt_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define RecordsetEventsVt_WillChangeField(This,cFields,Fields,adStatus,pRecordset)	\
    (This)->lpVtbl -> WillChangeField(This,cFields,Fields,adStatus,pRecordset)
#define RecordsetEventsVt_FieldChangeComplete(This,cFields,Fields,pError,adStatus,pRecordset)	\
    (This)->lpVtbl -> FieldChangeComplete(This,cFields,Fields,pError,adStatus,pRecordset)
#define RecordsetEventsVt_WillChangeRecord(This,adReason,cRecords,adStatus,pRecordset)	\
    (This)->lpVtbl -> WillChangeRecord(This,adReason,cRecords,adStatus,pRecordset)
#define RecordsetEventsVt_RecordChangeComplete(This,adReason,cRecords,pError,adStatus,pRecordset)	\
    (This)->lpVtbl -> RecordChangeComplete(This,adReason,cRecords,pError,adStatus,pRecordset)
#define RecordsetEventsVt_WillChangeRecordset(This,adReason,adStatus,pRecordset)	\
    (This)->lpVtbl -> WillChangeRecordset(This,adReason,adStatus,pRecordset)
#define RecordsetEventsVt_RecordsetChangeComplete(This,adReason,pError,adStatus,pRecordset)	\
    (This)->lpVtbl -> RecordsetChangeComplete(This,adReason,pError,adStatus,pRecordset)
#define RecordsetEventsVt_WillMove(This,adReason,adStatus,pRecordset)	\
    (This)->lpVtbl -> WillMove(This,adReason,adStatus,pRecordset)
#define RecordsetEventsVt_MoveComplete(This,adReason,pError,adStatus,pRecordset)	\
    (This)->lpVtbl -> MoveComplete(This,adReason,pError,adStatus,pRecordset)
#define RecordsetEventsVt_EndOfRecordset(This,fMoreData,adStatus,pRecordset)	\
    (This)->lpVtbl -> EndOfRecordset(This,fMoreData,adStatus,pRecordset)
#define RecordsetEventsVt_FetchProgress(This,Progress,MaxProgress,adStatus,pRecordset)	\
    (This)->lpVtbl -> FetchProgress(This,Progress,MaxProgress,adStatus,pRecordset)
#define RecordsetEventsVt_FetchComplete(This,pError,adStatus,pRecordset)	\
    (This)->lpVtbl -> FetchComplete(This,pError,adStatus,pRecordset)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [id] */ HRESULT STDMETHODCALLTYPE RecordsetEventsVt_WillChangeField_Proxy( 
    RecordsetEventsVt __RPC_FAR * This,
    /* [in] */ LONG cFields,
    /* [in] */ VARIANT Fields,
    /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
    /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
void __RPC_STUB RecordsetEventsVt_WillChangeField_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE RecordsetEventsVt_FieldChangeComplete_Proxy( 
    RecordsetEventsVt __RPC_FAR * This,
    /* [in] */ LONG cFields,
    /* [in] */ VARIANT Fields,
    /* [in] */ ADOError __RPC_FAR *pError,
    /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
    /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
void __RPC_STUB RecordsetEventsVt_FieldChangeComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE RecordsetEventsVt_WillChangeRecord_Proxy( 
    RecordsetEventsVt __RPC_FAR * This,
    /* [in] */ EventReasonEnum adReason,
    /* [in] */ LONG cRecords,
    /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
    /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
void __RPC_STUB RecordsetEventsVt_WillChangeRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE RecordsetEventsVt_RecordChangeComplete_Proxy( 
    RecordsetEventsVt __RPC_FAR * This,
    /* [in] */ EventReasonEnum adReason,
    /* [in] */ LONG cRecords,
    /* [in] */ ADOError __RPC_FAR *pError,
    /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
    /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
void __RPC_STUB RecordsetEventsVt_RecordChangeComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE RecordsetEventsVt_WillChangeRecordset_Proxy( 
    RecordsetEventsVt __RPC_FAR * This,
    /* [in] */ EventReasonEnum adReason,
    /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
    /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
void __RPC_STUB RecordsetEventsVt_WillChangeRecordset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE RecordsetEventsVt_RecordsetChangeComplete_Proxy( 
    RecordsetEventsVt __RPC_FAR * This,
    /* [in] */ EventReasonEnum adReason,
    /* [in] */ ADOError __RPC_FAR *pError,
    /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
    /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
void __RPC_STUB RecordsetEventsVt_RecordsetChangeComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE RecordsetEventsVt_WillMove_Proxy( 
    RecordsetEventsVt __RPC_FAR * This,
    /* [in] */ EventReasonEnum adReason,
    /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
    /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
void __RPC_STUB RecordsetEventsVt_WillMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE RecordsetEventsVt_MoveComplete_Proxy( 
    RecordsetEventsVt __RPC_FAR * This,
    /* [in] */ EventReasonEnum adReason,
    /* [in] */ ADOError __RPC_FAR *pError,
    /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
    /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
void __RPC_STUB RecordsetEventsVt_MoveComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE RecordsetEventsVt_EndOfRecordset_Proxy( 
    RecordsetEventsVt __RPC_FAR * This,
    /* [out][in] */ VARIANT_BOOL __RPC_FAR *fMoreData,
    /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
    /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
void __RPC_STUB RecordsetEventsVt_EndOfRecordset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE RecordsetEventsVt_FetchProgress_Proxy( 
    RecordsetEventsVt __RPC_FAR * This,
    /* [in] */ long Progress,
    /* [in] */ long MaxProgress,
    /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
    /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
void __RPC_STUB RecordsetEventsVt_FetchProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE RecordsetEventsVt_FetchComplete_Proxy( 
    RecordsetEventsVt __RPC_FAR * This,
    /* [in] */ ADOError __RPC_FAR *pError,
    /* [out][in] */ EventStatusEnum __RPC_FAR *adStatus,
    /* [in] */ _ADORecordset __RPC_FAR *pRecordset);
void __RPC_STUB RecordsetEventsVt_FetchComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __RecordsetEventsVt_INTERFACE_DEFINED__ */
#ifndef __ConnectionEvents_DISPINTERFACE_DEFINED__
#define __ConnectionEvents_DISPINTERFACE_DEFINED__
/****************************************
 * Generated header for dispinterface: ConnectionEvents
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [uuid] */ 
EXTERN_C const IID DIID_ConnectionEvents;
#if defined(__cplusplus) && !defined(CINTERFACE)
    interface DECLSPEC_UUID("00000400-0000-0010-8000-00AA006D2EA4")
    ConnectionEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */
    typedef struct ConnectionEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ConnectionEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ConnectionEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ConnectionEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ConnectionEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ConnectionEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ConnectionEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ConnectionEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } ConnectionEventsVtbl;
    interface ConnectionEvents
    {
        CONST_VTBL struct ConnectionEventsVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define ConnectionEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define ConnectionEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define ConnectionEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define ConnectionEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define ConnectionEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define ConnectionEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define ConnectionEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#endif /* COBJMACROS */
#endif 	/* C style interface */
#endif 	/* __ConnectionEvents_DISPINTERFACE_DEFINED__ */
#ifndef __RecordsetEvents_DISPINTERFACE_DEFINED__
#define __RecordsetEvents_DISPINTERFACE_DEFINED__
/****************************************
 * Generated header for dispinterface: RecordsetEvents
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [uuid] */ 
EXTERN_C const IID DIID_RecordsetEvents;
#if defined(__cplusplus) && !defined(CINTERFACE)
    interface DECLSPEC_UUID("00000266-0000-0010-8000-00AA006D2EA4")
    RecordsetEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */
    typedef struct RecordsetEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            RecordsetEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            RecordsetEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            RecordsetEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            RecordsetEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            RecordsetEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            RecordsetEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            RecordsetEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } RecordsetEventsVtbl;
    interface RecordsetEvents
    {
        CONST_VTBL struct RecordsetEventsVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define RecordsetEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define RecordsetEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define RecordsetEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define RecordsetEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define RecordsetEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define RecordsetEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define RecordsetEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#endif /* COBJMACROS */
#endif 	/* C style interface */
#endif 	/* __RecordsetEvents_DISPINTERFACE_DEFINED__ */
#ifndef ___Connection15_INTERFACE_DEFINED__
#define ___Connection15_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: _Connection15
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][hidden][dual] */ 
EXTERN_C const IID IID__Connection15;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000515-0000-0010-8000-00AA006D2EA4")
    _Connection15 : public _ADO
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionString( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ConnectionString( 
            /* [in] */ BSTR bstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_CommandTimeout( 
            /* [retval][out] */ LONG __RPC_FAR *plTimeout) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_CommandTimeout( 
            /* [in] */ LONG lTimeout) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionTimeout( 
            /* [retval][out] */ LONG __RPC_FAR *plTimeout) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ConnectionTimeout( 
            /* [in] */ LONG lTimeout) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ BSTR CommandText,
            /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
            /* [defaultvalue][in] */ long Options,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppiRset) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BeginTrans( 
            /* [retval][out] */ long __RPC_FAR *TransactionLevel) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CommitTrans( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RollbackTrans( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [defaultvalue][in] */ BSTR ConnectionString,
            /* [defaultvalue][in] */ BSTR UserID,
            /* [defaultvalue][in] */ BSTR Password,
            /* [defaultvalue][in] */ long Options) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Errors( 
            /* [retval][out] */ ADOErrors __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultDatabase( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultDatabase( 
            /* [in] */ BSTR bstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_IsolationLevel( 
            /* [retval][out] */ IsolationLevelEnum __RPC_FAR *Level) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_IsolationLevel( 
            /* [in] */ IsolationLevelEnum Level) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Attributes( 
            /* [retval][out] */ long __RPC_FAR *plAttr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Attributes( 
            /* [in] */ long lAttr) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CursorLocation( 
            /* [retval][out] */ CursorLocationEnum __RPC_FAR *plCursorLoc) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CursorLocation( 
            /* [in] */ CursorLocationEnum lCursorLoc) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Mode( 
            /* [retval][out] */ ConnectModeEnum __RPC_FAR *plMode) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Mode( 
            /* [in] */ ConnectModeEnum lMode) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Provider( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Provider( 
            /* [in] */ BSTR Provider) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ LONG __RPC_FAR *plObjState) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE OpenSchema( 
            /* [in] */ SchemaEnum Schema,
            /* [optional][in] */ VARIANT Restrictions,
            /* [optional][in] */ VARIANT SchemaID,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *pprset) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct _Connection15Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _Connection15 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _Connection15 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _Connection15 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _Connection15 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _Connection15 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _Connection15 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _Connection15 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            _Connection15 __RPC_FAR * This,
            /* [retval][out] */ ADOProperties __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ConnectionString )( 
            _Connection15 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ConnectionString )( 
            _Connection15 __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommandTimeout )( 
            _Connection15 __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plTimeout);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CommandTimeout )( 
            _Connection15 __RPC_FAR * This,
            /* [in] */ LONG lTimeout);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ConnectionTimeout )( 
            _Connection15 __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plTimeout);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ConnectionTimeout )( 
            _Connection15 __RPC_FAR * This,
            /* [in] */ LONG lTimeout);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Version )( 
            _Connection15 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            _Connection15 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Execute )( 
            _Connection15 __RPC_FAR * This,
            /* [in] */ BSTR CommandText,
            /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
            /* [defaultvalue][in] */ long Options,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppiRset);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginTrans )( 
            _Connection15 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *TransactionLevel);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommitTrans )( 
            _Connection15 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RollbackTrans )( 
            _Connection15 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            _Connection15 __RPC_FAR * This,
            /* [defaultvalue][in] */ BSTR ConnectionString,
            /* [defaultvalue][in] */ BSTR UserID,
            /* [defaultvalue][in] */ BSTR Password,
            /* [defaultvalue][in] */ long Options);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Errors )( 
            _Connection15 __RPC_FAR * This,
            /* [retval][out] */ ADOErrors __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefaultDatabase )( 
            _Connection15 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DefaultDatabase )( 
            _Connection15 __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsolationLevel )( 
            _Connection15 __RPC_FAR * This,
            /* [retval][out] */ IsolationLevelEnum __RPC_FAR *Level);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IsolationLevel )( 
            _Connection15 __RPC_FAR * This,
            /* [in] */ IsolationLevelEnum Level);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attributes )( 
            _Connection15 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plAttr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Attributes )( 
            _Connection15 __RPC_FAR * This,
            /* [in] */ long lAttr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CursorLocation )( 
            _Connection15 __RPC_FAR * This,
            /* [retval][out] */ CursorLocationEnum __RPC_FAR *plCursorLoc);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CursorLocation )( 
            _Connection15 __RPC_FAR * This,
            /* [in] */ CursorLocationEnum lCursorLoc);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Mode )( 
            _Connection15 __RPC_FAR * This,
            /* [retval][out] */ ConnectModeEnum __RPC_FAR *plMode);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Mode )( 
            _Connection15 __RPC_FAR * This,
            /* [in] */ ConnectModeEnum lMode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Provider )( 
            _Connection15 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Provider )( 
            _Connection15 __RPC_FAR * This,
            /* [in] */ BSTR Provider);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            _Connection15 __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plObjState);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenSchema )( 
            _Connection15 __RPC_FAR * This,
            /* [in] */ SchemaEnum Schema,
            /* [optional][in] */ VARIANT Restrictions,
            /* [optional][in] */ VARIANT SchemaID,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *pprset);
        
        END_INTERFACE
    } _Connection15Vtbl;
    interface _Connection15
    {
        CONST_VTBL struct _Connection15Vtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define _Connection15_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define _Connection15_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define _Connection15_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define _Connection15_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define _Connection15_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define _Connection15_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define _Connection15_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define _Connection15_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)
#define _Connection15_get_ConnectionString(This,pbstr)	\
    (This)->lpVtbl -> get_ConnectionString(This,pbstr)
#define _Connection15_put_ConnectionString(This,bstr)	\
    (This)->lpVtbl -> put_ConnectionString(This,bstr)
#define _Connection15_get_CommandTimeout(This,plTimeout)	\
    (This)->lpVtbl -> get_CommandTimeout(This,plTimeout)
#define _Connection15_put_CommandTimeout(This,lTimeout)	\
    (This)->lpVtbl -> put_CommandTimeout(This,lTimeout)
#define _Connection15_get_ConnectionTimeout(This,plTimeout)	\
    (This)->lpVtbl -> get_ConnectionTimeout(This,plTimeout)
#define _Connection15_put_ConnectionTimeout(This,lTimeout)	\
    (This)->lpVtbl -> put_ConnectionTimeout(This,lTimeout)
#define _Connection15_get_Version(This,pbstr)	\
    (This)->lpVtbl -> get_Version(This,pbstr)
#define _Connection15_Close(This)	\
    (This)->lpVtbl -> Close(This)
#define _Connection15_Execute(This,CommandText,RecordsAffected,Options,ppiRset)	\
    (This)->lpVtbl -> Execute(This,CommandText,RecordsAffected,Options,ppiRset)
#define _Connection15_BeginTrans(This,TransactionLevel)	\
    (This)->lpVtbl -> BeginTrans(This,TransactionLevel)
#define _Connection15_CommitTrans(This)	\
    (This)->lpVtbl -> CommitTrans(This)
#define _Connection15_RollbackTrans(This)	\
    (This)->lpVtbl -> RollbackTrans(This)
#define _Connection15_Open(This,ConnectionString,UserID,Password,Options)	\
    (This)->lpVtbl -> Open(This,ConnectionString,UserID,Password,Options)
#define _Connection15_get_Errors(This,ppvObject)	\
    (This)->lpVtbl -> get_Errors(This,ppvObject)
#define _Connection15_get_DefaultDatabase(This,pbstr)	\
    (This)->lpVtbl -> get_DefaultDatabase(This,pbstr)
#define _Connection15_put_DefaultDatabase(This,bstr)	\
    (This)->lpVtbl -> put_DefaultDatabase(This,bstr)
#define _Connection15_get_IsolationLevel(This,Level)	\
    (This)->lpVtbl -> get_IsolationLevel(This,Level)
#define _Connection15_put_IsolationLevel(This,Level)	\
    (This)->lpVtbl -> put_IsolationLevel(This,Level)
#define _Connection15_get_Attributes(This,plAttr)	\
    (This)->lpVtbl -> get_Attributes(This,plAttr)
#define _Connection15_put_Attributes(This,lAttr)	\
    (This)->lpVtbl -> put_Attributes(This,lAttr)
#define _Connection15_get_CursorLocation(This,plCursorLoc)	\
    (This)->lpVtbl -> get_CursorLocation(This,plCursorLoc)
#define _Connection15_put_CursorLocation(This,lCursorLoc)	\
    (This)->lpVtbl -> put_CursorLocation(This,lCursorLoc)
#define _Connection15_get_Mode(This,plMode)	\
    (This)->lpVtbl -> get_Mode(This,plMode)
#define _Connection15_put_Mode(This,lMode)	\
    (This)->lpVtbl -> put_Mode(This,lMode)
#define _Connection15_get_Provider(This,pbstr)	\
    (This)->lpVtbl -> get_Provider(This,pbstr)
#define _Connection15_put_Provider(This,Provider)	\
    (This)->lpVtbl -> put_Provider(This,Provider)
#define _Connection15_get_State(This,plObjState)	\
    (This)->lpVtbl -> get_State(This,plObjState)
#define _Connection15_OpenSchema(This,Schema,Restrictions,SchemaID,pprset)	\
    (This)->lpVtbl -> OpenSchema(This,Schema,Restrictions,SchemaID,pprset)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _Connection15_get_ConnectionString_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB _Connection15_get_ConnectionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propput] */ HRESULT STDMETHODCALLTYPE _Connection15_put_ConnectionString_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [in] */ BSTR bstr);
void __RPC_STUB _Connection15_put_ConnectionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _Connection15_get_CommandTimeout_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plTimeout);
void __RPC_STUB _Connection15_get_CommandTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propput] */ HRESULT STDMETHODCALLTYPE _Connection15_put_CommandTimeout_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [in] */ LONG lTimeout);
void __RPC_STUB _Connection15_put_CommandTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _Connection15_get_ConnectionTimeout_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plTimeout);
void __RPC_STUB _Connection15_get_ConnectionTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propput] */ HRESULT STDMETHODCALLTYPE _Connection15_put_ConnectionTimeout_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [in] */ LONG lTimeout);
void __RPC_STUB _Connection15_put_ConnectionTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _Connection15_get_Version_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB _Connection15_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Connection15_Close_Proxy( 
    _Connection15 __RPC_FAR * This);
void __RPC_STUB _Connection15_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Connection15_Execute_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [in] */ BSTR CommandText,
    /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
    /* [defaultvalue][in] */ long Options,
    /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppiRset);
void __RPC_STUB _Connection15_Execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Connection15_BeginTrans_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *TransactionLevel);
void __RPC_STUB _Connection15_BeginTrans_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Connection15_CommitTrans_Proxy( 
    _Connection15 __RPC_FAR * This);
void __RPC_STUB _Connection15_CommitTrans_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Connection15_RollbackTrans_Proxy( 
    _Connection15 __RPC_FAR * This);
void __RPC_STUB _Connection15_RollbackTrans_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Connection15_Open_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [defaultvalue][in] */ BSTR ConnectionString,
    /* [defaultvalue][in] */ BSTR UserID,
    /* [defaultvalue][in] */ BSTR Password,
    /* [defaultvalue][in] */ long Options);
void __RPC_STUB _Connection15_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _Connection15_get_Errors_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [retval][out] */ ADOErrors __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB _Connection15_get_Errors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _Connection15_get_DefaultDatabase_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB _Connection15_get_DefaultDatabase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propput] */ HRESULT STDMETHODCALLTYPE _Connection15_put_DefaultDatabase_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [in] */ BSTR bstr);
void __RPC_STUB _Connection15_put_DefaultDatabase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _Connection15_get_IsolationLevel_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [retval][out] */ IsolationLevelEnum __RPC_FAR *Level);
void __RPC_STUB _Connection15_get_IsolationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propput] */ HRESULT STDMETHODCALLTYPE _Connection15_put_IsolationLevel_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [in] */ IsolationLevelEnum Level);
void __RPC_STUB _Connection15_put_IsolationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _Connection15_get_Attributes_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plAttr);
void __RPC_STUB _Connection15_get_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propput] */ HRESULT STDMETHODCALLTYPE _Connection15_put_Attributes_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [in] */ long lAttr);
void __RPC_STUB _Connection15_put_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Connection15_get_CursorLocation_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [retval][out] */ CursorLocationEnum __RPC_FAR *plCursorLoc);
void __RPC_STUB _Connection15_get_CursorLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Connection15_put_CursorLocation_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [in] */ CursorLocationEnum lCursorLoc);
void __RPC_STUB _Connection15_put_CursorLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _Connection15_get_Mode_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [retval][out] */ ConnectModeEnum __RPC_FAR *plMode);
void __RPC_STUB _Connection15_get_Mode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propput] */ HRESULT STDMETHODCALLTYPE _Connection15_put_Mode_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [in] */ ConnectModeEnum lMode);
void __RPC_STUB _Connection15_put_Mode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _Connection15_get_Provider_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB _Connection15_get_Provider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propput] */ HRESULT STDMETHODCALLTYPE _Connection15_put_Provider_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [in] */ BSTR Provider);
void __RPC_STUB _Connection15_put_Provider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _Connection15_get_State_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plObjState);
void __RPC_STUB _Connection15_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Connection15_OpenSchema_Proxy( 
    _Connection15 __RPC_FAR * This,
    /* [in] */ SchemaEnum Schema,
    /* [optional][in] */ VARIANT Restrictions,
    /* [optional][in] */ VARIANT SchemaID,
    /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *pprset);
void __RPC_STUB _Connection15_OpenSchema_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* ___Connection15_INTERFACE_DEFINED__ */
#ifndef ___Connection_INTERFACE_DEFINED__
#define ___Connection_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: _Connection
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][dual] */ 
EXTERN_C const IID IID__Connection;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000550-0000-0010-8000-00AA006D2EA4")
    _ADOConnection : public _Connection15
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct _ConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _ADOConnection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _ADOConnection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _ADOConnection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ ADOProperties __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ConnectionString )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ConnectionString )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommandTimeout )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plTimeout);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CommandTimeout )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ LONG lTimeout);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ConnectionTimeout )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plTimeout);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ConnectionTimeout )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ LONG lTimeout);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Version )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            _ADOConnection __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Execute )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ BSTR CommandText,
            /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
            /* [defaultvalue][in] */ long Options,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppiRset);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginTrans )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *TransactionLevel);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommitTrans )( 
            _ADOConnection __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RollbackTrans )( 
            _ADOConnection __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            _ADOConnection __RPC_FAR * This,
            /* [defaultvalue][in] */ BSTR ConnectionString,
            /* [defaultvalue][in] */ BSTR UserID,
            /* [defaultvalue][in] */ BSTR Password,
            /* [defaultvalue][in] */ long Options);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Errors )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ ADOErrors __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefaultDatabase )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DefaultDatabase )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsolationLevel )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ IsolationLevelEnum __RPC_FAR *Level);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IsolationLevel )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ IsolationLevelEnum Level);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attributes )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plAttr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Attributes )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ long lAttr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CursorLocation )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ CursorLocationEnum __RPC_FAR *plCursorLoc);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CursorLocation )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ CursorLocationEnum lCursorLoc);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Mode )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ ConnectModeEnum __RPC_FAR *plMode);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Mode )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ ConnectModeEnum lMode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Provider )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Provider )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ BSTR Provider);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plObjState);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenSchema )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ SchemaEnum Schema,
            /* [optional][in] */ VARIANT Restrictions,
            /* [optional][in] */ VARIANT SchemaID,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *pprset);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cancel )( 
            _ADOConnection __RPC_FAR * This);
        
        END_INTERFACE
    } _ConnectionVtbl;
    interface _Connection
    {
        CONST_VTBL struct _ConnectionVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define _Connection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define _Connection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define _Connection_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define _Connection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define _Connection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define _Connection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define _Connection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define _Connection_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)
#define _Connection_get_ConnectionString(This,pbstr)	\
    (This)->lpVtbl -> get_ConnectionString(This,pbstr)
#define _Connection_put_ConnectionString(This,bstr)	\
    (This)->lpVtbl -> put_ConnectionString(This,bstr)
#define _Connection_get_CommandTimeout(This,plTimeout)	\
    (This)->lpVtbl -> get_CommandTimeout(This,plTimeout)
#define _Connection_put_CommandTimeout(This,lTimeout)	\
    (This)->lpVtbl -> put_CommandTimeout(This,lTimeout)
#define _Connection_get_ConnectionTimeout(This,plTimeout)	\
    (This)->lpVtbl -> get_ConnectionTimeout(This,plTimeout)
#define _Connection_put_ConnectionTimeout(This,lTimeout)	\
    (This)->lpVtbl -> put_ConnectionTimeout(This,lTimeout)
#define _Connection_get_Version(This,pbstr)	\
    (This)->lpVtbl -> get_Version(This,pbstr)
#define _Connection_Close(This)	\
    (This)->lpVtbl -> Close(This)
#define _Connection_Execute(This,CommandText,RecordsAffected,Options,ppiRset)	\
    (This)->lpVtbl -> Execute(This,CommandText,RecordsAffected,Options,ppiRset)
#define _Connection_BeginTrans(This,TransactionLevel)	\
    (This)->lpVtbl -> BeginTrans(This,TransactionLevel)
#define _Connection_CommitTrans(This)	\
    (This)->lpVtbl -> CommitTrans(This)
#define _Connection_RollbackTrans(This)	\
    (This)->lpVtbl -> RollbackTrans(This)
#define _Connection_Open(This,ConnectionString,UserID,Password,Options)	\
    (This)->lpVtbl -> Open(This,ConnectionString,UserID,Password,Options)
#define _Connection_get_Errors(This,ppvObject)	\
    (This)->lpVtbl -> get_Errors(This,ppvObject)
#define _Connection_get_DefaultDatabase(This,pbstr)	\
    (This)->lpVtbl -> get_DefaultDatabase(This,pbstr)
#define _Connection_put_DefaultDatabase(This,bstr)	\
    (This)->lpVtbl -> put_DefaultDatabase(This,bstr)
#define _Connection_get_IsolationLevel(This,Level)	\
    (This)->lpVtbl -> get_IsolationLevel(This,Level)
#define _Connection_put_IsolationLevel(This,Level)	\
    (This)->lpVtbl -> put_IsolationLevel(This,Level)
#define _Connection_get_Attributes(This,plAttr)	\
    (This)->lpVtbl -> get_Attributes(This,plAttr)
#define _Connection_put_Attributes(This,lAttr)	\
    (This)->lpVtbl -> put_Attributes(This,lAttr)
#define _Connection_get_CursorLocation(This,plCursorLoc)	\
    (This)->lpVtbl -> get_CursorLocation(This,plCursorLoc)
#define _Connection_put_CursorLocation(This,lCursorLoc)	\
    (This)->lpVtbl -> put_CursorLocation(This,lCursorLoc)
#define _Connection_get_Mode(This,plMode)	\
    (This)->lpVtbl -> get_Mode(This,plMode)
#define _Connection_put_Mode(This,lMode)	\
    (This)->lpVtbl -> put_Mode(This,lMode)
#define _Connection_get_Provider(This,pbstr)	\
    (This)->lpVtbl -> get_Provider(This,pbstr)
#define _Connection_put_Provider(This,Provider)	\
    (This)->lpVtbl -> put_Provider(This,Provider)
#define _Connection_get_State(This,plObjState)	\
    (This)->lpVtbl -> get_State(This,plObjState)
#define _Connection_OpenSchema(This,Schema,Restrictions,SchemaID,pprset)	\
    (This)->lpVtbl -> OpenSchema(This,Schema,Restrictions,SchemaID,pprset)
#define _Connection_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [id] */ HRESULT STDMETHODCALLTYPE _Connection_Cancel_Proxy( 
    _ADOConnection __RPC_FAR * This);
void __RPC_STUB _Connection_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* ___Connection_INTERFACE_DEFINED__ */
#ifndef __ADOConnectionConstruction15_INTERFACE_DEFINED__
#define __ADOConnectionConstruction15_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: ADOConnectionConstruction15
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][restricted] */ 
EXTERN_C const IID IID_ADOConnectionConstruction15;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000516-0000-0010-8000-00AA006D2EA4")
    ADOConnectionConstruction15 : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DSO( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDSO) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppSession) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WrapDSOandSession( 
            /* [in] */ IUnknown __RPC_FAR *pDSO,
            /* [in] */ IUnknown __RPC_FAR *pSession) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct ADOConnectionConstruction15Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ADOConnectionConstruction15 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ADOConnectionConstruction15 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ADOConnectionConstruction15 __RPC_FAR * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DSO )( 
            ADOConnectionConstruction15 __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDSO);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            ADOConnectionConstruction15 __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppSession);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WrapDSOandSession )( 
            ADOConnectionConstruction15 __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDSO,
            /* [in] */ IUnknown __RPC_FAR *pSession);
        
        END_INTERFACE
    } ADOConnectionConstruction15Vtbl;
    interface ADOConnectionConstruction15
    {
        CONST_VTBL struct ADOConnectionConstruction15Vtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define ADOConnectionConstruction15_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define ADOConnectionConstruction15_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define ADOConnectionConstruction15_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define ADOConnectionConstruction15_get_DSO(This,ppDSO)	\
    (This)->lpVtbl -> get_DSO(This,ppDSO)
#define ADOConnectionConstruction15_get_Session(This,ppSession)	\
    (This)->lpVtbl -> get_Session(This,ppSession)
#define ADOConnectionConstruction15_WrapDSOandSession(This,pDSO,pSession)	\
    (This)->lpVtbl -> WrapDSOandSession(This,pDSO,pSession)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [propget] */ HRESULT STDMETHODCALLTYPE ADOConnectionConstruction15_get_DSO_Proxy( 
    ADOConnectionConstruction15 __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDSO);
void __RPC_STUB ADOConnectionConstruction15_get_DSO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE ADOConnectionConstruction15_get_Session_Proxy( 
    ADOConnectionConstruction15 __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppSession);
void __RPC_STUB ADOConnectionConstruction15_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
HRESULT STDMETHODCALLTYPE ADOConnectionConstruction15_WrapDSOandSession_Proxy( 
    ADOConnectionConstruction15 __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pDSO,
    /* [in] */ IUnknown __RPC_FAR *pSession);
void __RPC_STUB ADOConnectionConstruction15_WrapDSOandSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __ADOConnectionConstruction15_INTERFACE_DEFINED__ */
#ifndef __ADOConnectionConstruction_INTERFACE_DEFINED__
#define __ADOConnectionConstruction_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: ADOConnectionConstruction
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][restricted] */ 
EXTERN_C const IID IID_ADOConnectionConstruction;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000551-0000-0010-8000-00AA006D2EA4")
    ADOConnectionConstruction : public ADOConnectionConstruction15
    {
    public:
    };
    
#else 	/* C style interface */
    typedef struct ADOConnectionConstructionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ADOConnectionConstruction __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ADOConnectionConstruction __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ADOConnectionConstruction __RPC_FAR * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DSO )( 
            ADOConnectionConstruction __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDSO);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            ADOConnectionConstruction __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppSession);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WrapDSOandSession )( 
            ADOConnectionConstruction __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDSO,
            /* [in] */ IUnknown __RPC_FAR *pSession);
        
        END_INTERFACE
    } ADOConnectionConstructionVtbl;
    interface ADOConnectionConstruction
    {
        CONST_VTBL struct ADOConnectionConstructionVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define ADOConnectionConstruction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define ADOConnectionConstruction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define ADOConnectionConstruction_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define ADOConnectionConstruction_get_DSO(This,ppDSO)	\
    (This)->lpVtbl -> get_DSO(This,ppDSO)
#define ADOConnectionConstruction_get_Session(This,ppSession)	\
    (This)->lpVtbl -> get_Session(This,ppSession)
#define ADOConnectionConstruction_WrapDSOandSession(This,pDSO,pSession)	\
    (This)->lpVtbl -> WrapDSOandSession(This,pDSO,pSession)
#endif /* COBJMACROS */
#endif 	/* C style interface */
#endif 	/* __ADOConnectionConstruction_INTERFACE_DEFINED__ */
#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Connection;
Connection;
#endif
#ifndef __ADOCommandConstruction_INTERFACE_DEFINED__
#define __ADOCommandConstruction_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: ADOCommandConstruction
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][restricted] */ 
EXTERN_C const IID IID_ADOCommandConstruction;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000517-0000-0010-8000-00AA006D2EA4")
    ADOCommandConstruction : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_OLEDBCommand( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppOLEDBCommand) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_OLEDBCommand( 
            /* [in] */ IUnknown __RPC_FAR *pOLEDBCommand) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct ADOCommandConstructionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ADOCommandConstruction __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ADOCommandConstruction __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ADOCommandConstruction __RPC_FAR * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OLEDBCommand )( 
            ADOCommandConstruction __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppOLEDBCommand);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OLEDBCommand )( 
            ADOCommandConstruction __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pOLEDBCommand);
        
        END_INTERFACE
    } ADOCommandConstructionVtbl;
    interface ADOCommandConstruction
    {
        CONST_VTBL struct ADOCommandConstructionVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define ADOCommandConstruction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define ADOCommandConstruction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define ADOCommandConstruction_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define ADOCommandConstruction_get_OLEDBCommand(This,ppOLEDBCommand)	\
    (This)->lpVtbl -> get_OLEDBCommand(This,ppOLEDBCommand)
#define ADOCommandConstruction_put_OLEDBCommand(This,pOLEDBCommand)	\
    (This)->lpVtbl -> put_OLEDBCommand(This,pOLEDBCommand)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [propget] */ HRESULT STDMETHODCALLTYPE ADOCommandConstruction_get_OLEDBCommand_Proxy( 
    ADOCommandConstruction __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppOLEDBCommand);
void __RPC_STUB ADOCommandConstruction_get_OLEDBCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE ADOCommandConstruction_put_OLEDBCommand_Proxy( 
    ADOCommandConstruction __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pOLEDBCommand);
void __RPC_STUB ADOCommandConstruction_put_OLEDBCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __ADOCommandConstruction_INTERFACE_DEFINED__ */
#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Command;
Command;
#endif
#ifndef ___Recordset15_INTERFACE_DEFINED__
#define ___Recordset15_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: _Recordset15
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][nonextensible][hidden][dual] */ 
EXTERN_C const IID IID__Recordset15;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0000050E-0000-0010-8000-00AA006D2EA4")
    _Recordset15 : public _ADO
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AbsolutePosition( 
            /* [retval][out] */ PositionEnum __RPC_FAR *pl) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AbsolutePosition( 
            /* [in] */ PositionEnum Position) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_ActiveConnection( 
            /* [in] */ IDispatch __RPC_FAR *pconn) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ActiveConnection( 
            /* [in] */ VARIANT vConn) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ActiveConnection( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_BOF( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Bookmark( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvBookmark) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Bookmark( 
            /* [in] */ VARIANT vBookmark) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CacheSize( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CacheSize( 
            /* [in] */ long CacheSize) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CursorType( 
            /* [retval][out] */ CursorTypeEnum __RPC_FAR *plCursorType) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CursorType( 
            /* [in] */ CursorTypeEnum lCursorType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EOF( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ ADOFields __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LockType( 
            /* [retval][out] */ LockTypeEnum __RPC_FAR *plLockType) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_LockType( 
            /* [in] */ LockTypeEnum lLockType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_MaxRecords( 
            /* [retval][out] */ long __RPC_FAR *plMaxRecords) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_MaxRecords( 
            /* [in] */ long lMaxRecords) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_RecordCount( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Source( 
            /* [in] */ IDispatch __RPC_FAR *pcmd) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Source( 
            /* [in] */ BSTR bstrConn) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Source( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvSource) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddNew( 
            /* [optional][in] */ VARIANT FieldList,
            /* [optional][in] */ VARIANT Values) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CancelUpdate( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [defaultvalue][in] */ AffectEnum AffectRecords) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetRows( 
            /* [defaultvalue][in] */ long Rows,
            /* [optional][in] */ VARIANT Start,
            /* [optional][in] */ VARIANT Fields,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ long NumRecords,
            /* [optional][in] */ VARIANT Start) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveNext( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MovePrevious( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveFirst( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveLast( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [optional][in] */ VARIANT Source,
            /* [optional][in] */ VARIANT ActiveConnection,
            /* [defaultvalue][in] */ CursorTypeEnum CursorType,
            /* [defaultvalue][in] */ LockTypeEnum LockType,
            /* [defaultvalue][in] */ LONG Options) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Requery( 
            /* [defaultvalue][in] */ LONG Options) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE _xResync( 
            /* [defaultvalue][in] */ AffectEnum AffectRecords) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Update( 
            /* [optional][in] */ VARIANT Fields,
            /* [optional][in] */ VARIANT Values) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AbsolutePage( 
            /* [retval][out] */ PositionEnum __RPC_FAR *pl) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AbsolutePage( 
            /* [in] */ PositionEnum Page) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EditMode( 
            /* [retval][out] */ EditModeEnum __RPC_FAR *pl) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Filter( 
            /* [retval][out] */ VARIANT __RPC_FAR *Criteria) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Filter( 
            /* [in] */ VARIANT Criteria) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_PageCount( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_PageSize( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_PageSize( 
            /* [in] */ long PageSize) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Sort( 
            /* [retval][out] */ BSTR __RPC_FAR *Criteria) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Sort( 
            /* [in] */ BSTR Criteria) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ LONG __RPC_FAR *plObjState) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE _xClone( 
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE UpdateBatch( 
            /* [defaultvalue][in] */ AffectEnum AffectRecords) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CancelBatch( 
            /* [defaultvalue][in] */ AffectEnum AffectRecords) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CursorLocation( 
            /* [retval][out] */ CursorLocationEnum __RPC_FAR *plCursorLoc) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CursorLocation( 
            /* [in] */ CursorLocationEnum lCursorLoc) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE NextRecordset( 
            /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppiRs) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Supports( 
            /* [in] */ CursorOptionEnum CursorOptions,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_Collect( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [hidden][id][propput] */ HRESULT STDMETHODCALLTYPE put_Collect( 
            /* [in] */ VARIANT Index,
            /* [in] */ VARIANT value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_MarshalOptions( 
            /* [retval][out] */ MarshalOptionsEnum __RPC_FAR *peMarshal) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_MarshalOptions( 
            /* [in] */ MarshalOptionsEnum eMarshal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Find( 
            /* [in] */ BSTR Criteria,
            /* [defaultvalue][in] */ LONG SkipRecords,
            /* [defaultvalue][in] */ SearchDirectionEnum SearchDirection,
            /* [optional][in] */ VARIANT Start) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct _Recordset15Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _Recordset15 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _Recordset15 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _Recordset15 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ ADOProperties __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AbsolutePosition )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ PositionEnum __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AbsolutePosition )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ PositionEnum Position);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_ActiveADOConnection )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pconn);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActiveConnection )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ VARIANT vConn);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActiveConnection )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BOF )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Bookmark )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvBookmark);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Bookmark )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ VARIANT vBookmark);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CacheSize )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CacheSize )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ long CacheSize);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CursorType )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ CursorTypeEnum __RPC_FAR *plCursorType);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CursorType )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ CursorTypeEnum lCursorType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EOF )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ ADOFields __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LockType )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ LockTypeEnum __RPC_FAR *plLockType);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LockType )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ LockTypeEnum lLockType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaxRecords )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plMaxRecords);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaxRecords )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ long lMaxRecords);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecordCount )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Source )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pcmd);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Source )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ BSTR bstrConn);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Source )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvSource);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddNew )( 
            _Recordset15 __RPC_FAR * This,
            /* [optional][in] */ VARIANT FieldList,
            /* [optional][in] */ VARIANT Values);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelUpdate )( 
            _Recordset15 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            _Recordset15 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            _Recordset15 __RPC_FAR * This,
            /* [defaultvalue][in] */ AffectEnum AffectRecords);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRows )( 
            _Recordset15 __RPC_FAR * This,
            /* [defaultvalue][in] */ long Rows,
            /* [optional][in] */ VARIANT Start,
            /* [optional][in] */ VARIANT Fields,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ long NumRecords,
            /* [optional][in] */ VARIANT Start);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveNext )( 
            _Recordset15 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MovePrevious )( 
            _Recordset15 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveFirst )( 
            _Recordset15 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveLast )( 
            _Recordset15 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            _Recordset15 __RPC_FAR * This,
            /* [optional][in] */ VARIANT Source,
            /* [optional][in] */ VARIANT ActiveConnection,
            /* [defaultvalue][in] */ CursorTypeEnum CursorType,
            /* [defaultvalue][in] */ LockTypeEnum LockType,
            /* [defaultvalue][in] */ LONG Options);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Requery )( 
            _Recordset15 __RPC_FAR * This,
            /* [defaultvalue][in] */ LONG Options);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_xResync )( 
            _Recordset15 __RPC_FAR * This,
            /* [defaultvalue][in] */ AffectEnum AffectRecords);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Update )( 
            _Recordset15 __RPC_FAR * This,
            /* [optional][in] */ VARIANT Fields,
            /* [optional][in] */ VARIANT Values);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AbsolutePage )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ PositionEnum __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AbsolutePage )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ PositionEnum Page);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EditMode )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ EditModeEnum __RPC_FAR *pl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Filter )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *Criteria);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Filter )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ VARIANT Criteria);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PageCount )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PageSize )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PageSize )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ long PageSize);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Sort )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Criteria);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Sort )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ BSTR Criteria);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plObjState);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_xClone )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateBatch )( 
            _Recordset15 __RPC_FAR * This,
            /* [defaultvalue][in] */ AffectEnum AffectRecords);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelBatch )( 
            _Recordset15 __RPC_FAR * This,
            /* [defaultvalue][in] */ AffectEnum AffectRecords);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CursorLocation )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ CursorLocationEnum __RPC_FAR *plCursorLoc);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CursorLocation )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ CursorLocationEnum lCursorLoc);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NextADORecordset )( 
            _Recordset15 __RPC_FAR * This,
            /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppiRs);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Supports )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ CursorOptionEnum CursorOptions,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Collect )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [hidden][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Collect )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [in] */ VARIANT value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MarshalOptions )( 
            _Recordset15 __RPC_FAR * This,
            /* [retval][out] */ MarshalOptionsEnum __RPC_FAR *peMarshal);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MarshalOptions )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ MarshalOptionsEnum eMarshal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Find )( 
            _Recordset15 __RPC_FAR * This,
            /* [in] */ BSTR Criteria,
            /* [defaultvalue][in] */ LONG SkipRecords,
            /* [defaultvalue][in] */ SearchDirectionEnum SearchDirection,
            /* [optional][in] */ VARIANT Start);
        
        END_INTERFACE
    } _Recordset15Vtbl;
    interface _Recordset15
    {
        CONST_VTBL struct _Recordset15Vtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define _Recordset15_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define _Recordset15_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define _Recordset15_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define _Recordset15_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define _Recordset15_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define _Recordset15_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define _Recordset15_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define _Recordset15_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)
#define _Recordset15_get_AbsolutePosition(This,pl)	\
    (This)->lpVtbl -> get_AbsolutePosition(This,pl)
#define _Recordset15_put_AbsolutePosition(This,Position)	\
    (This)->lpVtbl -> put_AbsolutePosition(This,Position)
#define _Recordset15_putref_ActiveConnection(This,pconn)	\
    (This)->lpVtbl -> putref_ActiveConnection(This,pconn)
#define _Recordset15_put_ActiveConnection(This,vConn)	\
    (This)->lpVtbl -> put_ActiveConnection(This,vConn)
#define _Recordset15_get_ActiveConnection(This,pvar)	\
    (This)->lpVtbl -> get_ActiveConnection(This,pvar)
#define _Recordset15_get_BOF(This,pb)	\
    (This)->lpVtbl -> get_BOF(This,pb)
#define _Recordset15_get_Bookmark(This,pvBookmark)	\
    (This)->lpVtbl -> get_Bookmark(This,pvBookmark)
#define _Recordset15_put_Bookmark(This,vBookmark)	\
    (This)->lpVtbl -> put_Bookmark(This,vBookmark)
#define _Recordset15_get_CacheSize(This,pl)	\
    (This)->lpVtbl -> get_CacheSize(This,pl)
#define _Recordset15_put_CacheSize(This,CacheSize)	\
    (This)->lpVtbl -> put_CacheSize(This,CacheSize)
#define _Recordset15_get_CursorType(This,plCursorType)	\
    (This)->lpVtbl -> get_CursorType(This,plCursorType)
#define _Recordset15_put_CursorType(This,lCursorType)	\
    (This)->lpVtbl -> put_CursorType(This,lCursorType)
#define _Recordset15_get_EOF(This,pb)	\
    (This)->lpVtbl -> get_EOF(This,pb)
#define _Recordset15_get_Fields(This,ppvObject)	\
    (This)->lpVtbl -> get_Fields(This,ppvObject)
#define _Recordset15_get_LockType(This,plLockType)	\
    (This)->lpVtbl -> get_LockType(This,plLockType)
#define _Recordset15_put_LockType(This,lLockType)	\
    (This)->lpVtbl -> put_LockType(This,lLockType)
#define _Recordset15_get_MaxRecords(This,plMaxRecords)	\
    (This)->lpVtbl -> get_MaxRecords(This,plMaxRecords)
#define _Recordset15_put_MaxRecords(This,lMaxRecords)	\
    (This)->lpVtbl -> put_MaxRecords(This,lMaxRecords)
#define _Recordset15_get_RecordCount(This,pl)	\
    (This)->lpVtbl -> get_RecordCount(This,pl)
#define _Recordset15_putref_Source(This,pcmd)	\
    (This)->lpVtbl -> putref_Source(This,pcmd)
#define _Recordset15_put_Source(This,bstrConn)	\
    (This)->lpVtbl -> put_Source(This,bstrConn)
#define _Recordset15_get_Source(This,pvSource)	\
    (This)->lpVtbl -> get_Source(This,pvSource)
#define _Recordset15_AddNew(This,FieldList,Values)	\
    (This)->lpVtbl -> AddNew(This,FieldList,Values)
#define _Recordset15_CancelUpdate(This)	\
    (This)->lpVtbl -> CancelUpdate(This)
#define _Recordset15_Close(This)	\
    (This)->lpVtbl -> Close(This)
#define _Recordset15_Delete(This,AffectRecords)	\
    (This)->lpVtbl -> Delete(This,AffectRecords)
#define _Recordset15_GetRows(This,Rows,Start,Fields,pvar)	\
    (This)->lpVtbl -> GetRows(This,Rows,Start,Fields,pvar)
#define _Recordset15_Move(This,NumRecords,Start)	\
    (This)->lpVtbl -> Move(This,NumRecords,Start)
#define _Recordset15_MoveNext(This)	\
    (This)->lpVtbl -> MoveNext(This)
#define _Recordset15_MovePrevious(This)	\
    (This)->lpVtbl -> MovePrevious(This)
#define _Recordset15_MoveFirst(This)	\
    (This)->lpVtbl -> MoveFirst(This)
#define _Recordset15_MoveLast(This)	\
    (This)->lpVtbl -> MoveLast(This)
#define _Recordset15_Open(This,Source,ActiveConnection,CursorType,LockType,Options)	\
    (This)->lpVtbl -> Open(This,Source,ActiveConnection,CursorType,LockType,Options)
#define _Recordset15_Requery(This,Options)	\
    (This)->lpVtbl -> Requery(This,Options)
#define _Recordset15__xResync(This,AffectRecords)	\
    (This)->lpVtbl -> _xResync(This,AffectRecords)
#define _Recordset15_Update(This,Fields,Values)	\
    (This)->lpVtbl -> Update(This,Fields,Values)
#define _Recordset15_get_AbsolutePage(This,pl)	\
    (This)->lpVtbl -> get_AbsolutePage(This,pl)
#define _Recordset15_put_AbsolutePage(This,Page)	\
    (This)->lpVtbl -> put_AbsolutePage(This,Page)
#define _Recordset15_get_EditMode(This,pl)	\
    (This)->lpVtbl -> get_EditMode(This,pl)
#define _Recordset15_get_Filter(This,Criteria)	\
    (This)->lpVtbl -> get_Filter(This,Criteria)
#define _Recordset15_put_Filter(This,Criteria)	\
    (This)->lpVtbl -> put_Filter(This,Criteria)
#define _Recordset15_get_PageCount(This,pl)	\
    (This)->lpVtbl -> get_PageCount(This,pl)
#define _Recordset15_get_PageSize(This,pl)	\
    (This)->lpVtbl -> get_PageSize(This,pl)
#define _Recordset15_put_PageSize(This,PageSize)	\
    (This)->lpVtbl -> put_PageSize(This,PageSize)
#define _Recordset15_get_Sort(This,Criteria)	\
    (This)->lpVtbl -> get_Sort(This,Criteria)
#define _Recordset15_put_Sort(This,Criteria)	\
    (This)->lpVtbl -> put_Sort(This,Criteria)
#define _Recordset15_get_Status(This,pl)	\
    (This)->lpVtbl -> get_Status(This,pl)
#define _Recordset15_get_State(This,plObjState)	\
    (This)->lpVtbl -> get_State(This,plObjState)
#define _Recordset15__xClone(This,ppvObject)	\
    (This)->lpVtbl -> _xClone(This,ppvObject)
#define _Recordset15_UpdateBatch(This,AffectRecords)	\
    (This)->lpVtbl -> UpdateBatch(This,AffectRecords)
#define _Recordset15_CancelBatch(This,AffectRecords)	\
    (This)->lpVtbl -> CancelBatch(This,AffectRecords)
#define _Recordset15_get_CursorLocation(This,plCursorLoc)	\
    (This)->lpVtbl -> get_CursorLocation(This,plCursorLoc)
#define _Recordset15_put_CursorLocation(This,lCursorLoc)	\
    (This)->lpVtbl -> put_CursorLocation(This,lCursorLoc)
#define _Recordset15_NextRecordset(This,RecordsAffected,ppiRs)	\
    (This)->lpVtbl -> NextRecordset(This,RecordsAffected,ppiRs)
#define _Recordset15_Supports(This,CursorOptions,pb)	\
    (This)->lpVtbl -> Supports(This,CursorOptions,pb)
#define _Recordset15_get_Collect(This,Index,pvar)	\
    (This)->lpVtbl -> get_Collect(This,Index,pvar)
#define _Recordset15_put_Collect(This,Index,value)	\
    (This)->lpVtbl -> put_Collect(This,Index,value)
#define _Recordset15_get_MarshalOptions(This,peMarshal)	\
    (This)->lpVtbl -> get_MarshalOptions(This,peMarshal)
#define _Recordset15_put_MarshalOptions(This,eMarshal)	\
    (This)->lpVtbl -> put_MarshalOptions(This,eMarshal)
#define _Recordset15_Find(This,Criteria,SkipRecords,SearchDirection,Start)	\
    (This)->lpVtbl -> Find(This,Criteria,SkipRecords,SearchDirection,Start)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_AbsolutePosition_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ PositionEnum __RPC_FAR *pl);
void __RPC_STUB _Recordset15_get_AbsolutePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_put_AbsolutePosition_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ PositionEnum Position);
void __RPC_STUB _Recordset15_put_AbsolutePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propputref][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_putref_ActiveConnection_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pconn);
void __RPC_STUB _Recordset15_putref_ActiveConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_put_ActiveConnection_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ VARIANT vConn);
void __RPC_STUB _Recordset15_put_ActiveConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_ActiveConnection_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);
void __RPC_STUB _Recordset15_get_ActiveConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_BOF_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
void __RPC_STUB _Recordset15_get_BOF_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_Bookmark_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvBookmark);
void __RPC_STUB _Recordset15_get_Bookmark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_put_Bookmark_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ VARIANT vBookmark);
void __RPC_STUB _Recordset15_put_Bookmark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_CacheSize_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB _Recordset15_get_CacheSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_put_CacheSize_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ long CacheSize);
void __RPC_STUB _Recordset15_put_CacheSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_CursorType_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ CursorTypeEnum __RPC_FAR *plCursorType);
void __RPC_STUB _Recordset15_get_CursorType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_put_CursorType_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ CursorTypeEnum lCursorType);
void __RPC_STUB _Recordset15_put_CursorType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_EOF_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
void __RPC_STUB _Recordset15_get_EOF_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_Fields_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ ADOFields __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB _Recordset15_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_LockType_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ LockTypeEnum __RPC_FAR *plLockType);
void __RPC_STUB _Recordset15_get_LockType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_put_LockType_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ LockTypeEnum lLockType);
void __RPC_STUB _Recordset15_put_LockType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_MaxRecords_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plMaxRecords);
void __RPC_STUB _Recordset15_get_MaxRecords_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_put_MaxRecords_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ long lMaxRecords);
void __RPC_STUB _Recordset15_put_MaxRecords_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_RecordCount_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB _Recordset15_get_RecordCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propputref][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_putref_Source_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pcmd);
void __RPC_STUB _Recordset15_putref_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_put_Source_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ BSTR bstrConn);
void __RPC_STUB _Recordset15_put_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_Source_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvSource);
void __RPC_STUB _Recordset15_get_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset15_AddNew_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [optional][in] */ VARIANT FieldList,
    /* [optional][in] */ VARIANT Values);
void __RPC_STUB _Recordset15_AddNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset15_CancelUpdate_Proxy( 
    _Recordset15 __RPC_FAR * This);
void __RPC_STUB _Recordset15_CancelUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset15_Close_Proxy( 
    _Recordset15 __RPC_FAR * This);
void __RPC_STUB _Recordset15_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset15_Delete_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [defaultvalue][in] */ AffectEnum AffectRecords);
void __RPC_STUB _Recordset15_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset15_GetRows_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [defaultvalue][in] */ long Rows,
    /* [optional][in] */ VARIANT Start,
    /* [optional][in] */ VARIANT Fields,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);
void __RPC_STUB _Recordset15_GetRows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset15_Move_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ long NumRecords,
    /* [optional][in] */ VARIANT Start);
void __RPC_STUB _Recordset15_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset15_MoveNext_Proxy( 
    _Recordset15 __RPC_FAR * This);
void __RPC_STUB _Recordset15_MoveNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset15_MovePrevious_Proxy( 
    _Recordset15 __RPC_FAR * This);
void __RPC_STUB _Recordset15_MovePrevious_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset15_MoveFirst_Proxy( 
    _Recordset15 __RPC_FAR * This);
void __RPC_STUB _Recordset15_MoveFirst_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset15_MoveLast_Proxy( 
    _Recordset15 __RPC_FAR * This);
void __RPC_STUB _Recordset15_MoveLast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset15_Open_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [optional][in] */ VARIANT Source,
    /* [optional][in] */ VARIANT ActiveConnection,
    /* [defaultvalue][in] */ CursorTypeEnum CursorType,
    /* [defaultvalue][in] */ LockTypeEnum LockType,
    /* [defaultvalue][in] */ LONG Options);
void __RPC_STUB _Recordset15_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset15_Requery_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [defaultvalue][in] */ LONG Options);
void __RPC_STUB _Recordset15_Requery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [hidden] */ HRESULT STDMETHODCALLTYPE _Recordset15__xResync_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [defaultvalue][in] */ AffectEnum AffectRecords);
void __RPC_STUB _Recordset15__xResync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset15_Update_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [optional][in] */ VARIANT Fields,
    /* [optional][in] */ VARIANT Values);
void __RPC_STUB _Recordset15_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_AbsolutePage_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ PositionEnum __RPC_FAR *pl);
void __RPC_STUB _Recordset15_get_AbsolutePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_put_AbsolutePage_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ PositionEnum Page);
void __RPC_STUB _Recordset15_put_AbsolutePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_EditMode_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ EditModeEnum __RPC_FAR *pl);
void __RPC_STUB _Recordset15_get_EditMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_Filter_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *Criteria);
void __RPC_STUB _Recordset15_get_Filter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_put_Filter_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ VARIANT Criteria);
void __RPC_STUB _Recordset15_put_Filter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_PageCount_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB _Recordset15_get_PageCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_PageSize_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB _Recordset15_get_PageSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_put_PageSize_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ long PageSize);
void __RPC_STUB _Recordset15_put_PageSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_Sort_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Criteria);
void __RPC_STUB _Recordset15_get_Sort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_put_Sort_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ BSTR Criteria);
void __RPC_STUB _Recordset15_put_Sort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_Status_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB _Recordset15_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_State_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plObjState);
void __RPC_STUB _Recordset15_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [hidden] */ HRESULT STDMETHODCALLTYPE _Recordset15__xClone_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB _Recordset15__xClone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset15_UpdateBatch_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [defaultvalue][in] */ AffectEnum AffectRecords);
void __RPC_STUB _Recordset15_UpdateBatch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset15_CancelBatch_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [defaultvalue][in] */ AffectEnum AffectRecords);
void __RPC_STUB _Recordset15_CancelBatch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_CursorLocation_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ CursorLocationEnum __RPC_FAR *plCursorLoc);
void __RPC_STUB _Recordset15_get_CursorLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_put_CursorLocation_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ CursorLocationEnum lCursorLoc);
void __RPC_STUB _Recordset15_put_CursorLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset15_NextRecordset_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
    /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppiRs);
void __RPC_STUB _Recordset15_NextRecordset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset15_Supports_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ CursorOptionEnum CursorOptions,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
void __RPC_STUB _Recordset15_Supports_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_Collect_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);
void __RPC_STUB _Recordset15_get_Collect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [hidden][id][propput] */ HRESULT STDMETHODCALLTYPE _Recordset15_put_Collect_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [in] */ VARIANT value);
void __RPC_STUB _Recordset15_put_Collect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_get_MarshalOptions_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [retval][out] */ MarshalOptionsEnum __RPC_FAR *peMarshal);
void __RPC_STUB _Recordset15_get_MarshalOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset15_put_MarshalOptions_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ MarshalOptionsEnum eMarshal);
void __RPC_STUB _Recordset15_put_MarshalOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset15_Find_Proxy( 
    _Recordset15 __RPC_FAR * This,
    /* [in] */ BSTR Criteria,
    /* [defaultvalue][in] */ LONG SkipRecords,
    /* [defaultvalue][in] */ SearchDirectionEnum SearchDirection,
    /* [optional][in] */ VARIANT Start);
void __RPC_STUB _Recordset15_Find_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* ___Recordset15_INTERFACE_DEFINED__ */
#ifndef ___Recordset_INTERFACE_DEFINED__
#define ___Recordset_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: _Recordset
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID__Recordset;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0000054F-0000-0010-8000-00AA006D2EA4")
    _ADORecordset : public _Recordset15
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkDataSource) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_DataSource( 
            /* [in] */ IUnknown __RPC_FAR *punkDataSource) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Save( 
            /* [optional][in] */ BSTR FileName,
            /* [defaultvalue][in] */ PersistFormatEnum PersistFormat) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ActiveCommand( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCmd) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_StayInSync( 
            /* [in] */ VARIANT_BOOL bStayInSync) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_StayInSync( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbStayInSync) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetString( 
            /* [defaultvalue][optional][in] */ StringFormatEnum StringFormat,
            /* [defaultvalue][optional][in] */ long NumRows,
            /* [optional][in] */ BSTR ColumnDelimeter,
            /* [optional][in] */ BSTR RowDelimeter,
            /* [optional][in] */ BSTR NullExpr,
            /* [retval][out] */ BSTR __RPC_FAR *pRetString) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DataMember( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDataMember) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DataMember( 
            /* [in] */ BSTR bstrDataMember) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CompareBookmarks( 
            /* [in] */ VARIANT Bookmark1,
            /* [in] */ VARIANT Bookmark2,
            /* [retval][out] */ CompareEnum __RPC_FAR *pCompare) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [defaultvalue][in] */ LockTypeEnum LockType,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Resync( 
            /* [defaultvalue][in] */ AffectEnum AffectRecords,
            /* [defaultvalue][in] */ ResyncEnum ResyncValues) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct _RecordsetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _ADORecordset __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _ADORecordset __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _ADORecordset __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ ADOProperties __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AbsolutePosition )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ PositionEnum __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AbsolutePosition )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ PositionEnum Position);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_ActiveADOConnection )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pconn);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActiveConnection )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ VARIANT vConn);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActiveConnection )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BOF )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Bookmark )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvBookmark);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Bookmark )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ VARIANT vBookmark);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CacheSize )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CacheSize )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ long CacheSize);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CursorType )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ CursorTypeEnum __RPC_FAR *plCursorType);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CursorType )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ CursorTypeEnum lCursorType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EOF )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ ADOFields __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LockType )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ LockTypeEnum __RPC_FAR *plLockType);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LockType )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ LockTypeEnum lLockType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaxRecords )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plMaxRecords);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaxRecords )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ long lMaxRecords);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecordCount )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Source )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pcmd);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Source )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ BSTR bstrConn);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Source )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvSource);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddNew )( 
            _ADORecordset __RPC_FAR * This,
            /* [optional][in] */ VARIANT FieldList,
            /* [optional][in] */ VARIANT Values);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelUpdate )( 
            _ADORecordset __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            _ADORecordset __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            _ADORecordset __RPC_FAR * This,
            /* [defaultvalue][in] */ AffectEnum AffectRecords);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRows )( 
            _ADORecordset __RPC_FAR * This,
            /* [defaultvalue][in] */ long Rows,
            /* [optional][in] */ VARIANT Start,
            /* [optional][in] */ VARIANT Fields,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ long NumRecords,
            /* [optional][in] */ VARIANT Start);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveNext )( 
            _ADORecordset __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MovePrevious )( 
            _ADORecordset __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveFirst )( 
            _ADORecordset __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveLast )( 
            _ADORecordset __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            _ADORecordset __RPC_FAR * This,
            /* [optional][in] */ VARIANT Source,
            /* [optional][in] */ VARIANT ActiveConnection,
            /* [defaultvalue][in] */ CursorTypeEnum CursorType,
            /* [defaultvalue][in] */ LockTypeEnum LockType,
            /* [defaultvalue][in] */ LONG Options);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Requery )( 
            _ADORecordset __RPC_FAR * This,
            /* [defaultvalue][in] */ LONG Options);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_xResync )( 
            _ADORecordset __RPC_FAR * This,
            /* [defaultvalue][in] */ AffectEnum AffectRecords);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Update )( 
            _ADORecordset __RPC_FAR * This,
            /* [optional][in] */ VARIANT Fields,
            /* [optional][in] */ VARIANT Values);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AbsolutePage )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ PositionEnum __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AbsolutePage )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ PositionEnum Page);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EditMode )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ EditModeEnum __RPC_FAR *pl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Filter )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *Criteria);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Filter )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ VARIANT Criteria);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PageCount )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PageSize )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PageSize )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ long PageSize);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Sort )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Criteria);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Sort )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ BSTR Criteria);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plObjState);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_xClone )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateBatch )( 
            _ADORecordset __RPC_FAR * This,
            /* [defaultvalue][in] */ AffectEnum AffectRecords);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelBatch )( 
            _ADORecordset __RPC_FAR * This,
            /* [defaultvalue][in] */ AffectEnum AffectRecords);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CursorLocation )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ CursorLocationEnum __RPC_FAR *plCursorLoc);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CursorLocation )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ CursorLocationEnum lCursorLoc);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NextADORecordset )( 
            _ADORecordset __RPC_FAR * This,
            /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppiRs);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Supports )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ CursorOptionEnum CursorOptions,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Collect )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [hidden][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Collect )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [in] */ VARIANT value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MarshalOptions )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ MarshalOptionsEnum __RPC_FAR *peMarshal);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MarshalOptions )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ MarshalOptionsEnum eMarshal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Find )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ BSTR Criteria,
            /* [defaultvalue][in] */ LONG SkipRecords,
            /* [defaultvalue][in] */ SearchDirectionEnum SearchDirection,
            /* [optional][in] */ VARIANT Start);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cancel )( 
            _ADORecordset __RPC_FAR * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkDataSource);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_DataSource )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punkDataSource);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            _ADORecordset __RPC_FAR * This,
            /* [optional][in] */ BSTR FileName,
            /* [defaultvalue][in] */ PersistFormatEnum PersistFormat);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActiveCommand )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCmd);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StayInSync )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bStayInSync);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StayInSync )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbStayInSync);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetString )( 
            _ADORecordset __RPC_FAR * This,
            /* [defaultvalue][optional][in] */ StringFormatEnum StringFormat,
            /* [defaultvalue][optional][in] */ long NumRows,
            /* [optional][in] */ BSTR ColumnDelimeter,
            /* [optional][in] */ BSTR RowDelimeter,
            /* [optional][in] */ BSTR NullExpr,
            /* [retval][out] */ BSTR __RPC_FAR *pRetString);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataMember )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDataMember);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DataMember )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ BSTR bstrDataMember);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompareBookmarks )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ VARIANT Bookmark1,
            /* [in] */ VARIANT Bookmark2,
            /* [retval][out] */ CompareEnum __RPC_FAR *pCompare);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            _ADORecordset __RPC_FAR * This,
            /* [defaultvalue][in] */ LockTypeEnum LockType,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resync )( 
            _ADORecordset __RPC_FAR * This,
            /* [defaultvalue][in] */ AffectEnum AffectRecords,
            /* [defaultvalue][in] */ ResyncEnum ResyncValues);
        
        END_INTERFACE
    } _RecordsetVtbl;
    interface _Recordset
    {
        CONST_VTBL struct _RecordsetVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define _Recordset_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define _Recordset_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define _Recordset_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define _Recordset_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define _Recordset_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define _Recordset_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define _Recordset_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define _Recordset_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)
#define _Recordset_get_AbsolutePosition(This,pl)	\
    (This)->lpVtbl -> get_AbsolutePosition(This,pl)
#define _Recordset_put_AbsolutePosition(This,Position)	\
    (This)->lpVtbl -> put_AbsolutePosition(This,Position)
#define _Recordset_putref_ActiveConnection(This,pconn)	\
    (This)->lpVtbl -> putref_ActiveConnection(This,pconn)
#define _Recordset_put_ActiveConnection(This,vConn)	\
    (This)->lpVtbl -> put_ActiveConnection(This,vConn)
#define _Recordset_get_ActiveConnection(This,pvar)	\
    (This)->lpVtbl -> get_ActiveConnection(This,pvar)
#define _Recordset_get_BOF(This,pb)	\
    (This)->lpVtbl -> get_BOF(This,pb)
#define _Recordset_get_Bookmark(This,pvBookmark)	\
    (This)->lpVtbl -> get_Bookmark(This,pvBookmark)
#define _Recordset_put_Bookmark(This,vBookmark)	\
    (This)->lpVtbl -> put_Bookmark(This,vBookmark)
#define _Recordset_get_CacheSize(This,pl)	\
    (This)->lpVtbl -> get_CacheSize(This,pl)
#define _Recordset_put_CacheSize(This,CacheSize)	\
    (This)->lpVtbl -> put_CacheSize(This,CacheSize)
#define _Recordset_get_CursorType(This,plCursorType)	\
    (This)->lpVtbl -> get_CursorType(This,plCursorType)
#define _Recordset_put_CursorType(This,lCursorType)	\
    (This)->lpVtbl -> put_CursorType(This,lCursorType)
#define _Recordset_get_EOF(This,pb)	\
    (This)->lpVtbl -> get_EOF(This,pb)
#define _Recordset_get_Fields(This,ppvObject)	\
    (This)->lpVtbl -> get_Fields(This,ppvObject)
#define _Recordset_get_LockType(This,plLockType)	\
    (This)->lpVtbl -> get_LockType(This,plLockType)
#define _Recordset_put_LockType(This,lLockType)	\
    (This)->lpVtbl -> put_LockType(This,lLockType)
#define _Recordset_get_MaxRecords(This,plMaxRecords)	\
    (This)->lpVtbl -> get_MaxRecords(This,plMaxRecords)
#define _Recordset_put_MaxRecords(This,lMaxRecords)	\
    (This)->lpVtbl -> put_MaxRecords(This,lMaxRecords)
#define _Recordset_get_RecordCount(This,pl)	\
    (This)->lpVtbl -> get_RecordCount(This,pl)
#define _Recordset_putref_Source(This,pcmd)	\
    (This)->lpVtbl -> putref_Source(This,pcmd)
#define _Recordset_put_Source(This,bstrConn)	\
    (This)->lpVtbl -> put_Source(This,bstrConn)
#define _Recordset_get_Source(This,pvSource)	\
    (This)->lpVtbl -> get_Source(This,pvSource)
#define _Recordset_AddNew(This,FieldList,Values)	\
    (This)->lpVtbl -> AddNew(This,FieldList,Values)
#define _Recordset_CancelUpdate(This)	\
    (This)->lpVtbl -> CancelUpdate(This)
#define _Recordset_Close(This)	\
    (This)->lpVtbl -> Close(This)
#define _Recordset_Delete(This,AffectRecords)	\
    (This)->lpVtbl -> Delete(This,AffectRecords)
#define _Recordset_GetRows(This,Rows,Start,Fields,pvar)	\
    (This)->lpVtbl -> GetRows(This,Rows,Start,Fields,pvar)
#define _Recordset_Move(This,NumRecords,Start)	\
    (This)->lpVtbl -> Move(This,NumRecords,Start)
#define _Recordset_MoveNext(This)	\
    (This)->lpVtbl -> MoveNext(This)
#define _Recordset_MovePrevious(This)	\
    (This)->lpVtbl -> MovePrevious(This)
#define _Recordset_MoveFirst(This)	\
    (This)->lpVtbl -> MoveFirst(This)
#define _Recordset_MoveLast(This)	\
    (This)->lpVtbl -> MoveLast(This)
#define _Recordset_Open(This,Source,ActiveConnection,CursorType,LockType,Options)	\
    (This)->lpVtbl -> Open(This,Source,ActiveConnection,CursorType,LockType,Options)
#define _Recordset_Requery(This,Options)	\
    (This)->lpVtbl -> Requery(This,Options)
#define _Recordset__xResync(This,AffectRecords)	\
    (This)->lpVtbl -> _xResync(This,AffectRecords)
#define _Recordset_Update(This,Fields,Values)	\
    (This)->lpVtbl -> Update(This,Fields,Values)
#define _Recordset_get_AbsolutePage(This,pl)	\
    (This)->lpVtbl -> get_AbsolutePage(This,pl)
#define _Recordset_put_AbsolutePage(This,Page)	\
    (This)->lpVtbl -> put_AbsolutePage(This,Page)
#define _Recordset_get_EditMode(This,pl)	\
    (This)->lpVtbl -> get_EditMode(This,pl)
#define _Recordset_get_Filter(This,Criteria)	\
    (This)->lpVtbl -> get_Filter(This,Criteria)
#define _Recordset_put_Filter(This,Criteria)	\
    (This)->lpVtbl -> put_Filter(This,Criteria)
#define _Recordset_get_PageCount(This,pl)	\
    (This)->lpVtbl -> get_PageCount(This,pl)
#define _Recordset_get_PageSize(This,pl)	\
    (This)->lpVtbl -> get_PageSize(This,pl)
#define _Recordset_put_PageSize(This,PageSize)	\
    (This)->lpVtbl -> put_PageSize(This,PageSize)
#define _Recordset_get_Sort(This,Criteria)	\
    (This)->lpVtbl -> get_Sort(This,Criteria)
#define _Recordset_put_Sort(This,Criteria)	\
    (This)->lpVtbl -> put_Sort(This,Criteria)
#define _Recordset_get_Status(This,pl)	\
    (This)->lpVtbl -> get_Status(This,pl)
#define _Recordset_get_State(This,plObjState)	\
    (This)->lpVtbl -> get_State(This,plObjState)
#define _Recordset__xClone(This,ppvObject)	\
    (This)->lpVtbl -> _xClone(This,ppvObject)
#define _Recordset_UpdateBatch(This,AffectRecords)	\
    (This)->lpVtbl -> UpdateBatch(This,AffectRecords)
#define _Recordset_CancelBatch(This,AffectRecords)	\
    (This)->lpVtbl -> CancelBatch(This,AffectRecords)
#define _Recordset_get_CursorLocation(This,plCursorLoc)	\
    (This)->lpVtbl -> get_CursorLocation(This,plCursorLoc)
#define _Recordset_put_CursorLocation(This,lCursorLoc)	\
    (This)->lpVtbl -> put_CursorLocation(This,lCursorLoc)
#define _Recordset_NextRecordset(This,RecordsAffected,ppiRs)	\
    (This)->lpVtbl -> NextRecordset(This,RecordsAffected,ppiRs)
#define _Recordset_Supports(This,CursorOptions,pb)	\
    (This)->lpVtbl -> Supports(This,CursorOptions,pb)
#define _Recordset_get_Collect(This,Index,pvar)	\
    (This)->lpVtbl -> get_Collect(This,Index,pvar)
#define _Recordset_put_Collect(This,Index,value)	\
    (This)->lpVtbl -> put_Collect(This,Index,value)
#define _Recordset_get_MarshalOptions(This,peMarshal)	\
    (This)->lpVtbl -> get_MarshalOptions(This,peMarshal)
#define _Recordset_put_MarshalOptions(This,eMarshal)	\
    (This)->lpVtbl -> put_MarshalOptions(This,eMarshal)
#define _Recordset_Find(This,Criteria,SkipRecords,SearchDirection,Start)	\
    (This)->lpVtbl -> Find(This,Criteria,SkipRecords,SearchDirection,Start)
#define _Recordset_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)
#define _Recordset_get_DataSource(This,ppunkDataSource)	\
    (This)->lpVtbl -> get_DataSource(This,ppunkDataSource)
#define _Recordset_putref_DataSource(This,punkDataSource)	\
    (This)->lpVtbl -> putref_DataSource(This,punkDataSource)
#define _Recordset_Save(This,FileName,PersistFormat)	\
    (This)->lpVtbl -> Save(This,FileName,PersistFormat)
#define _Recordset_get_ActiveCommand(This,ppCmd)	\
    (This)->lpVtbl -> get_ActiveCommand(This,ppCmd)
#define _Recordset_put_StayInSync(This,bStayInSync)	\
    (This)->lpVtbl -> put_StayInSync(This,bStayInSync)
#define _Recordset_get_StayInSync(This,pbStayInSync)	\
    (This)->lpVtbl -> get_StayInSync(This,pbStayInSync)
#define _Recordset_GetString(This,StringFormat,NumRows,ColumnDelimeter,RowDelimeter,NullExpr,pRetString)	\
    (This)->lpVtbl -> GetString(This,StringFormat,NumRows,ColumnDelimeter,RowDelimeter,NullExpr,pRetString)
#define _Recordset_get_DataMember(This,pbstrDataMember)	\
    (This)->lpVtbl -> get_DataMember(This,pbstrDataMember)
#define _Recordset_put_DataMember(This,bstrDataMember)	\
    (This)->lpVtbl -> put_DataMember(This,bstrDataMember)
#define _Recordset_CompareBookmarks(This,Bookmark1,Bookmark2,pCompare)	\
    (This)->lpVtbl -> CompareBookmarks(This,Bookmark1,Bookmark2,pCompare)
#define _Recordset_Clone(This,LockType,ppvObject)	\
    (This)->lpVtbl -> Clone(This,LockType,ppvObject)
#define _Recordset_Resync(This,AffectRecords,ResyncValues)	\
    (This)->lpVtbl -> Resync(This,AffectRecords,ResyncValues)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_Cancel_Proxy( 
    _ADORecordset __RPC_FAR * This);
void __RPC_STUB _Recordset_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_DataSource_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkDataSource);
void __RPC_STUB _Recordset_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propputref][id] */ HRESULT STDMETHODCALLTYPE _Recordset_putref_DataSource_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punkDataSource);
void __RPC_STUB _Recordset_putref_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_Save_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [optional][in] */ BSTR FileName,
    /* [defaultvalue][in] */ PersistFormatEnum PersistFormat);
void __RPC_STUB _Recordset_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_ActiveCommand_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCmd);
void __RPC_STUB _Recordset_get_ActiveCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset_put_StayInSync_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bStayInSync);
void __RPC_STUB _Recordset_put_StayInSync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_StayInSync_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbStayInSync);
void __RPC_STUB _Recordset_get_StayInSync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_GetString_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [defaultvalue][optional][in] */ StringFormatEnum StringFormat,
    /* [defaultvalue][optional][in] */ long NumRows,
    /* [optional][in] */ BSTR ColumnDelimeter,
    /* [optional][in] */ BSTR RowDelimeter,
    /* [optional][in] */ BSTR NullExpr,
    /* [retval][out] */ BSTR __RPC_FAR *pRetString);
void __RPC_STUB _Recordset_GetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_DataMember_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrDataMember);
void __RPC_STUB _Recordset_get_DataMember_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset_put_DataMember_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ BSTR bstrDataMember);
void __RPC_STUB _Recordset_put_DataMember_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_CompareBookmarks_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ VARIANT Bookmark1,
    /* [in] */ VARIANT Bookmark2,
    /* [retval][out] */ CompareEnum __RPC_FAR *pCompare);
void __RPC_STUB _Recordset_CompareBookmarks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_Clone_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [defaultvalue][in] */ LockTypeEnum LockType,
    /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB _Recordset_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_Resync_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [defaultvalue][in] */ AffectEnum AffectRecords,
    /* [defaultvalue][in] */ ResyncEnum ResyncValues);
void __RPC_STUB _Recordset_Resync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* ___Recordset_INTERFACE_DEFINED__ */
#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Recordset;
Recordset;
#endif
#ifndef __ADORecordsetConstruction_INTERFACE_DEFINED__
#define __ADORecordsetConstruction_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: ADORecordsetConstruction
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][restricted] */ 
EXTERN_C const IID IID_ADORecordsetConstruction;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000283-0000-0010-8000-00AA006D2EA4")
    ADORecordsetConstruction : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Rowset( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppRowset) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Rowset( 
            /* [in] */ IUnknown __RPC_FAR *pRowset) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Chapter( 
            /* [retval][out] */ LONG __RPC_FAR *plChapter) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Chapter( 
            /* [in] */ LONG lChapter) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RowPosition( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppRowPos) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RowPosition( 
            /* [in] */ IUnknown __RPC_FAR *pRowPos) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct ADORecordsetConstructionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ADORecordsetConstruction __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ADORecordsetConstruction __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Rowset )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppRowset);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Rowset )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pRowset);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Chapter )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plChapter);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Chapter )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [in] */ LONG lChapter);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RowPosition )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppRowPos);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RowPosition )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pRowPos);
        
        END_INTERFACE
    } ADORecordsetConstructionVtbl;
    interface ADORecordsetConstruction
    {
        CONST_VTBL struct ADORecordsetConstructionVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define ADORecordsetConstruction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define ADORecordsetConstruction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define ADORecordsetConstruction_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define ADORecordsetConstruction_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define ADORecordsetConstruction_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define ADORecordsetConstruction_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define ADORecordsetConstruction_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define ADORecordsetConstruction_get_Rowset(This,ppRowset)	\
    (This)->lpVtbl -> get_Rowset(This,ppRowset)
#define ADORecordsetConstruction_put_Rowset(This,pRowset)	\
    (This)->lpVtbl -> put_Rowset(This,pRowset)
#define ADORecordsetConstruction_get_Chapter(This,plChapter)	\
    (This)->lpVtbl -> get_Chapter(This,plChapter)
#define ADORecordsetConstruction_put_Chapter(This,lChapter)	\
    (This)->lpVtbl -> put_Chapter(This,lChapter)
#define ADORecordsetConstruction_get_RowPosition(This,ppRowPos)	\
    (This)->lpVtbl -> get_RowPosition(This,ppRowPos)
#define ADORecordsetConstruction_put_RowPosition(This,pRowPos)	\
    (This)->lpVtbl -> put_RowPosition(This,pRowPos)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [propget] */ HRESULT STDMETHODCALLTYPE ADORecordsetConstruction_get_Rowset_Proxy( 
    ADORecordsetConstruction __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppRowset);
void __RPC_STUB ADORecordsetConstruction_get_Rowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE ADORecordsetConstruction_put_Rowset_Proxy( 
    ADORecordsetConstruction __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pRowset);
void __RPC_STUB ADORecordsetConstruction_put_Rowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE ADORecordsetConstruction_get_Chapter_Proxy( 
    ADORecordsetConstruction __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plChapter);
void __RPC_STUB ADORecordsetConstruction_get_Chapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE ADORecordsetConstruction_put_Chapter_Proxy( 
    ADORecordsetConstruction __RPC_FAR * This,
    /* [in] */ LONG lChapter);
void __RPC_STUB ADORecordsetConstruction_put_Chapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE ADORecordsetConstruction_get_RowPosition_Proxy( 
    ADORecordsetConstruction __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppRowPos);
void __RPC_STUB ADORecordsetConstruction_get_RowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE ADORecordsetConstruction_put_RowPosition_Proxy( 
    ADORecordsetConstruction __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pRowPos);
void __RPC_STUB ADORecordsetConstruction_put_RowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __ADORecordsetConstruction_INTERFACE_DEFINED__ */
#ifndef __Field15_INTERFACE_DEFINED__
#define __Field15_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: Field15
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][hidden][nonextensible][dual] */ 
EXTERN_C const IID IID_Field15;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000505-0000-0010-8000-00AA006D2EA4")
    Field15 : public _ADO
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ActualSize( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Attributes( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DefinedSize( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ DataTypeEnum __RPC_FAR *pDataType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ VARIANT Val) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Precision( 
            /* [retval][out] */ BYTE __RPC_FAR *pbPrecision) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_NumericScale( 
            /* [retval][out] */ BYTE __RPC_FAR *pbNumericScale) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppendChunk( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetChunk( 
            /* [in] */ long Length,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_OriginalValue( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_UnderlyingValue( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct Field15Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Field15 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Field15 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Field15 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Field15 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Field15 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Field15 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Field15 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            Field15 __RPC_FAR * This,
            /* [retval][out] */ ADOProperties __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActualSize )( 
            Field15 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attributes )( 
            Field15 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefinedSize )( 
            Field15 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            Field15 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            Field15 __RPC_FAR * This,
            /* [retval][out] */ DataTypeEnum __RPC_FAR *pDataType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            Field15 __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            Field15 __RPC_FAR * This,
            /* [in] */ VARIANT Val);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Precision )( 
            Field15 __RPC_FAR * This,
            /* [retval][out] */ BYTE __RPC_FAR *pbPrecision);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumericScale )( 
            Field15 __RPC_FAR * This,
            /* [retval][out] */ BYTE __RPC_FAR *pbNumericScale);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendChunk )( 
            Field15 __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChunk )( 
            Field15 __RPC_FAR * This,
            /* [in] */ long Length,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OriginalValue )( 
            Field15 __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UnderlyingValue )( 
            Field15 __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        END_INTERFACE
    } Field15Vtbl;
    interface Field15
    {
        CONST_VTBL struct Field15Vtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define Field15_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define Field15_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define Field15_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define Field15_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define Field15_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define Field15_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define Field15_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define Field15_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)
#define Field15_get_ActualSize(This,pl)	\
    (This)->lpVtbl -> get_ActualSize(This,pl)
#define Field15_get_Attributes(This,pl)	\
    (This)->lpVtbl -> get_Attributes(This,pl)
#define Field15_get_DefinedSize(This,pl)	\
    (This)->lpVtbl -> get_DefinedSize(This,pl)
#define Field15_get_Name(This,pbstr)	\
    (This)->lpVtbl -> get_Name(This,pbstr)
#define Field15_get_Type(This,pDataType)	\
    (This)->lpVtbl -> get_Type(This,pDataType)
#define Field15_get_Value(This,pvar)	\
    (This)->lpVtbl -> get_Value(This,pvar)
#define Field15_put_Value(This,Val)	\
    (This)->lpVtbl -> put_Value(This,Val)
#define Field15_get_Precision(This,pbPrecision)	\
    (This)->lpVtbl -> get_Precision(This,pbPrecision)
#define Field15_get_NumericScale(This,pbNumericScale)	\
    (This)->lpVtbl -> get_NumericScale(This,pbNumericScale)
#define Field15_AppendChunk(This,Data)	\
    (This)->lpVtbl -> AppendChunk(This,Data)
#define Field15_GetChunk(This,Length,pvar)	\
    (This)->lpVtbl -> GetChunk(This,Length,pvar)
#define Field15_get_OriginalValue(This,pvar)	\
    (This)->lpVtbl -> get_OriginalValue(This,pvar)
#define Field15_get_UnderlyingValue(This,pvar)	\
    (This)->lpVtbl -> get_UnderlyingValue(This,pvar)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [propget][id] */ HRESULT STDMETHODCALLTYPE Field15_get_ActualSize_Proxy( 
    Field15 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB Field15_get_ActualSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE Field15_get_Attributes_Proxy( 
    Field15 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB Field15_get_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE Field15_get_DefinedSize_Proxy( 
    Field15 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB Field15_get_DefinedSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE Field15_get_Name_Proxy( 
    Field15 __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB Field15_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE Field15_get_Type_Proxy( 
    Field15 __RPC_FAR * This,
    /* [retval][out] */ DataTypeEnum __RPC_FAR *pDataType);
void __RPC_STUB Field15_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE Field15_get_Value_Proxy( 
    Field15 __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);
void __RPC_STUB Field15_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE Field15_put_Value_Proxy( 
    Field15 __RPC_FAR * This,
    /* [in] */ VARIANT Val);
void __RPC_STUB Field15_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE Field15_get_Precision_Proxy( 
    Field15 __RPC_FAR * This,
    /* [retval][out] */ BYTE __RPC_FAR *pbPrecision);
void __RPC_STUB Field15_get_Precision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE Field15_get_NumericScale_Proxy( 
    Field15 __RPC_FAR * This,
    /* [retval][out] */ BYTE __RPC_FAR *pbNumericScale);
void __RPC_STUB Field15_get_NumericScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE Field15_AppendChunk_Proxy( 
    Field15 __RPC_FAR * This,
    /* [in] */ VARIANT Data);
void __RPC_STUB Field15_AppendChunk_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE Field15_GetChunk_Proxy( 
    Field15 __RPC_FAR * This,
    /* [in] */ long Length,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);
void __RPC_STUB Field15_GetChunk_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE Field15_get_OriginalValue_Proxy( 
    Field15 __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);
void __RPC_STUB Field15_get_OriginalValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE Field15_get_UnderlyingValue_Proxy( 
    Field15 __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);
void __RPC_STUB Field15_get_UnderlyingValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __Field15_INTERFACE_DEFINED__ */
#ifndef __Field_INTERFACE_DEFINED__
#define __Field_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: Field
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID_Field;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0000054C-0000-0010-8000-00AA006D2EA4")
    ADOField : public _ADO
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ActualSize( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Attributes( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DefinedSize( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ DataTypeEnum __RPC_FAR *pDataType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ VARIANT Val) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Precision( 
            /* [retval][out] */ BYTE __RPC_FAR *pbPrecision) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_NumericScale( 
            /* [retval][out] */ BYTE __RPC_FAR *pbNumericScale) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppendChunk( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetChunk( 
            /* [in] */ long Length,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_OriginalValue( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_UnderlyingValue( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DataFormat( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiDF) = 0;
        
        virtual /* [propputref] */ HRESULT STDMETHODCALLTYPE putref_DataFormat( 
            /* [in] */ IUnknown __RPC_FAR *piDF) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Precision( 
            /* [in] */ BYTE bPrecision) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_NumericScale( 
            /* [in] */ BYTE bScale) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Type( 
            /* [in] */ DataTypeEnum DataType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DefinedSize( 
            /* [in] */ long lSize) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Attributes( 
            /* [in] */ long lAttributes) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct FieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ADOField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ADOField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ADOField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ADOField __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ADOField __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ADOField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ADOField __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ ADOProperties __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActualSize )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attributes )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefinedSize )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ DataTypeEnum __RPC_FAR *pDataType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            ADOField __RPC_FAR * This,
            /* [in] */ VARIANT Val);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Precision )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ BYTE __RPC_FAR *pbPrecision);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumericScale )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ BYTE __RPC_FAR *pbNumericScale);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendChunk )( 
            ADOField __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChunk )( 
            ADOField __RPC_FAR * This,
            /* [in] */ long Length,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OriginalValue )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UnderlyingValue )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataFormat )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiDF);
        
        /* [propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_DataFormat )( 
            ADOField __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *piDF);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Precision )( 
            ADOField __RPC_FAR * This,
            /* [in] */ BYTE bPrecision);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_NumericScale )( 
            ADOField __RPC_FAR * This,
            /* [in] */ BYTE bScale);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Type )( 
            ADOField __RPC_FAR * This,
            /* [in] */ DataTypeEnum DataType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DefinedSize )( 
            ADOField __RPC_FAR * This,
            /* [in] */ long lSize);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Attributes )( 
            ADOField __RPC_FAR * This,
            /* [in] */ long lAttributes);
        
        END_INTERFACE
    } FieldVtbl;
    interface Field
    {
        CONST_VTBL struct FieldVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define Field_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define Field_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define Field_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define Field_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define Field_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define Field_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define Field_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define Field_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)
#define Field_get_ActualSize(This,pl)	\
    (This)->lpVtbl -> get_ActualSize(This,pl)
#define Field_get_Attributes(This,pl)	\
    (This)->lpVtbl -> get_Attributes(This,pl)
#define Field_get_DefinedSize(This,pl)	\
    (This)->lpVtbl -> get_DefinedSize(This,pl)
#define Field_get_Name(This,pbstr)	\
    (This)->lpVtbl -> get_Name(This,pbstr)
#define Field_get_Type(This,pDataType)	\
    (This)->lpVtbl -> get_Type(This,pDataType)
#define Field_get_Value(This,pvar)	\
    (This)->lpVtbl -> get_Value(This,pvar)
#define Field_put_Value(This,Val)	\
    (This)->lpVtbl -> put_Value(This,Val)
#define Field_get_Precision(This,pbPrecision)	\
    (This)->lpVtbl -> get_Precision(This,pbPrecision)
#define Field_get_NumericScale(This,pbNumericScale)	\
    (This)->lpVtbl -> get_NumericScale(This,pbNumericScale)
#define Field_AppendChunk(This,Data)	\
    (This)->lpVtbl -> AppendChunk(This,Data)
#define Field_GetChunk(This,Length,pvar)	\
    (This)->lpVtbl -> GetChunk(This,Length,pvar)
#define Field_get_OriginalValue(This,pvar)	\
    (This)->lpVtbl -> get_OriginalValue(This,pvar)
#define Field_get_UnderlyingValue(This,pvar)	\
    (This)->lpVtbl -> get_UnderlyingValue(This,pvar)
#define Field_get_DataFormat(This,ppiDF)	\
    (This)->lpVtbl -> get_DataFormat(This,ppiDF)
#define Field_putref_DataFormat(This,piDF)	\
    (This)->lpVtbl -> putref_DataFormat(This,piDF)
#define Field_put_Precision(This,bPrecision)	\
    (This)->lpVtbl -> put_Precision(This,bPrecision)
#define Field_put_NumericScale(This,bScale)	\
    (This)->lpVtbl -> put_NumericScale(This,bScale)
#define Field_put_Type(This,DataType)	\
    (This)->lpVtbl -> put_Type(This,DataType)
#define Field_put_DefinedSize(This,lSize)	\
    (This)->lpVtbl -> put_DefinedSize(This,lSize)
#define Field_put_Attributes(This,lAttributes)	\
    (This)->lpVtbl -> put_Attributes(This,lAttributes)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [propget][id] */ HRESULT STDMETHODCALLTYPE Field_get_ActualSize_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB Field_get_ActualSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE Field_get_Attributes_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB Field_get_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE Field_get_DefinedSize_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB Field_get_DefinedSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE Field_get_Name_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB Field_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE Field_get_Type_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ DataTypeEnum __RPC_FAR *pDataType);
void __RPC_STUB Field_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE Field_get_Value_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);
void __RPC_STUB Field_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE Field_put_Value_Proxy( 
    ADOField __RPC_FAR * This,
    /* [in] */ VARIANT Val);
void __RPC_STUB Field_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE Field_get_Precision_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ BYTE __RPC_FAR *pbPrecision);
void __RPC_STUB Field_get_Precision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE Field_get_NumericScale_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ BYTE __RPC_FAR *pbNumericScale);
void __RPC_STUB Field_get_NumericScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE Field_AppendChunk_Proxy( 
    ADOField __RPC_FAR * This,
    /* [in] */ VARIANT Data);
void __RPC_STUB Field_AppendChunk_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE Field_GetChunk_Proxy( 
    ADOField __RPC_FAR * This,
    /* [in] */ long Length,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);
void __RPC_STUB Field_GetChunk_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE Field_get_OriginalValue_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);
void __RPC_STUB Field_get_OriginalValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE Field_get_UnderlyingValue_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);
void __RPC_STUB Field_get_UnderlyingValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE Field_get_DataFormat_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiDF);
void __RPC_STUB Field_get_DataFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propputref] */ HRESULT STDMETHODCALLTYPE Field_putref_DataFormat_Proxy( 
    ADOField __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *piDF);
void __RPC_STUB Field_putref_DataFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE Field_put_Precision_Proxy( 
    ADOField __RPC_FAR * This,
    /* [in] */ BYTE bPrecision);
void __RPC_STUB Field_put_Precision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE Field_put_NumericScale_Proxy( 
    ADOField __RPC_FAR * This,
    /* [in] */ BYTE bScale);
void __RPC_STUB Field_put_NumericScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE Field_put_Type_Proxy( 
    ADOField __RPC_FAR * This,
    /* [in] */ DataTypeEnum DataType);
void __RPC_STUB Field_put_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE Field_put_DefinedSize_Proxy( 
    ADOField __RPC_FAR * This,
    /* [in] */ long lSize);
void __RPC_STUB Field_put_DefinedSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE Field_put_Attributes_Proxy( 
    ADOField __RPC_FAR * This,
    /* [in] */ long lAttributes);
void __RPC_STUB Field_put_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __Field_INTERFACE_DEFINED__ */
#ifndef __Fields15_INTERFACE_DEFINED__
#define __Fields15_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: Fields15
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][hidden][nonextensible][dual] */ 
EXTERN_C const IID IID_Fields15;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000506-0000-0010-8000-00AA006D2EA4")
    Fields15 : public _ADOCollection
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ ADOField __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct Fields15Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Fields15 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Fields15 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Fields15 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Fields15 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Fields15 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Fields15 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Fields15 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            Fields15 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            Fields15 __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            Fields15 __RPC_FAR * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            Fields15 __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ ADOField __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } Fields15Vtbl;
    interface Fields15
    {
        CONST_VTBL struct Fields15Vtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define Fields15_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define Fields15_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define Fields15_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define Fields15_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define Fields15_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define Fields15_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define Fields15_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define Fields15_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)
#define Fields15__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)
#define Fields15_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)
#define Fields15_get_Item(This,Index,ppvObject)	\
    (This)->lpVtbl -> get_Item(This,Index,ppvObject)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [id][propget] */ HRESULT STDMETHODCALLTYPE Fields15_get_Item_Proxy( 
    Fields15 __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ ADOField __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB Fields15_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __Fields15_INTERFACE_DEFINED__ */
#ifndef __Fields_INTERFACE_DEFINED__
#define __Fields_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: Fields
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID_Fields;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0000054D-0000-0010-8000-00AA006D2EA4")
    ADOFields : public Fields15
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ BSTR Name,
            /* [in] */ DataTypeEnum Type,
            /* [defaultvalue][in] */ long DefinedSize,
            /* [defaultvalue][in] */ FieldAttributeEnum Attrib) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ VARIANT Index) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct FieldsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ADOFields __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ADOFields __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ADOFields __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ADOFields __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ADOFields __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ADOFields __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ADOFields __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ADOFields __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            ADOFields __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            ADOFields __RPC_FAR * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ADOFields __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ ADOField __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Append )( 
            ADOFields __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ DataTypeEnum Type,
            /* [defaultvalue][in] */ long DefinedSize,
            /* [defaultvalue][in] */ FieldAttributeEnum Attrib);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            ADOFields __RPC_FAR * This,
            /* [in] */ VARIANT Index);
        
        END_INTERFACE
    } FieldsVtbl;
    interface Fields
    {
        CONST_VTBL struct FieldsVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define Fields_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define Fields_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define Fields_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define Fields_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define Fields_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define Fields_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define Fields_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define Fields_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)
#define Fields__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)
#define Fields_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)
#define Fields_get_Item(This,Index,ppvObject)	\
    (This)->lpVtbl -> get_Item(This,Index,ppvObject)
#define Fields_Append(This,Name,Type,DefinedSize,Attrib)	\
    (This)->lpVtbl -> Append(This,Name,Type,DefinedSize,Attrib)
#define Fields_Delete(This,Index)	\
    (This)->lpVtbl -> Delete(This,Index)
#endif /* COBJMACROS */
#endif 	/* C style interface */
HRESULT STDMETHODCALLTYPE Fields_Append_Proxy( 
    ADOFields __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ DataTypeEnum Type,
    /* [defaultvalue][in] */ long DefinedSize,
    /* [defaultvalue][in] */ FieldAttributeEnum Attrib);
void __RPC_STUB Fields_Append_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
HRESULT STDMETHODCALLTYPE Fields_Delete_Proxy( 
    ADOFields __RPC_FAR * This,
    /* [in] */ VARIANT Index);
void __RPC_STUB Fields_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __Fields_INTERFACE_DEFINED__ */
#ifndef ___Parameter_INTERFACE_DEFINED__
#define ___Parameter_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: _Parameter
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID__Parameter;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0000050C-0000-0010-8000-00AA006D2EA4")
    _ADOParameter : public _ADO
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR bstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ VARIANT val) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ DataTypeEnum __RPC_FAR *psDataType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Type( 
            /* [in] */ DataTypeEnum sDataType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Direction( 
            /* [in] */ ParameterDirectionEnum lParmDirection) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ ParameterDirectionEnum __RPC_FAR *plParmDirection) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Precision( 
            /* [in] */ BYTE bPrecision) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Precision( 
            /* [retval][out] */ BYTE __RPC_FAR *pbPrecision) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_NumericScale( 
            /* [in] */ BYTE bScale) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_NumericScale( 
            /* [retval][out] */ BYTE __RPC_FAR *pbScale) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Size( 
            /* [in] */ long l) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppendChunk( 
            /* [in] */ VARIANT Val) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Attributes( 
            /* [retval][out] */ LONG __RPC_FAR *plParmAttribs) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Attributes( 
            /* [in] */ LONG lParmAttribs) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct _ParameterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _ADOParameter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _ADOParameter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _ADOParameter __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            _ADOParameter __RPC_FAR * This,
            /* [retval][out] */ ADOProperties __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            _ADOParameter __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            _ADOParameter __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ VARIANT val);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            _ADOParameter __RPC_FAR * This,
            /* [retval][out] */ DataTypeEnum __RPC_FAR *psDataType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Type )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ DataTypeEnum sDataType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Direction )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ ParameterDirectionEnum lParmDirection);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Direction )( 
            _ADOParameter __RPC_FAR * This,
            /* [retval][out] */ ParameterDirectionEnum __RPC_FAR *plParmDirection);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Precision )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ BYTE bPrecision);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Precision )( 
            _ADOParameter __RPC_FAR * This,
            /* [retval][out] */ BYTE __RPC_FAR *pbPrecision);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_NumericScale )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ BYTE bScale);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumericScale )( 
            _ADOParameter __RPC_FAR * This,
            /* [retval][out] */ BYTE __RPC_FAR *pbScale);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Size )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ long l);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Size )( 
            _ADOParameter __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendChunk )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ VARIANT Val);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attributes )( 
            _ADOParameter __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plParmAttribs);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Attributes )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ LONG lParmAttribs);
        
        END_INTERFACE
    } _ParameterVtbl;
    interface _Parameter
    {
        CONST_VTBL struct _ParameterVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define _Parameter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define _Parameter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define _Parameter_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define _Parameter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define _Parameter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define _Parameter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define _Parameter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define _Parameter_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)
#define _Parameter_get_Name(This,pbstr)	\
    (This)->lpVtbl -> get_Name(This,pbstr)
#define _Parameter_put_Name(This,bstr)	\
    (This)->lpVtbl -> put_Name(This,bstr)
#define _Parameter_get_Value(This,pvar)	\
    (This)->lpVtbl -> get_Value(This,pvar)
#define _Parameter_put_Value(This,val)	\
    (This)->lpVtbl -> put_Value(This,val)
#define _Parameter_get_Type(This,psDataType)	\
    (This)->lpVtbl -> get_Type(This,psDataType)
#define _Parameter_put_Type(This,sDataType)	\
    (This)->lpVtbl -> put_Type(This,sDataType)
#define _Parameter_put_Direction(This,lParmDirection)	\
    (This)->lpVtbl -> put_Direction(This,lParmDirection)
#define _Parameter_get_Direction(This,plParmDirection)	\
    (This)->lpVtbl -> get_Direction(This,plParmDirection)
#define _Parameter_put_Precision(This,bPrecision)	\
    (This)->lpVtbl -> put_Precision(This,bPrecision)
#define _Parameter_get_Precision(This,pbPrecision)	\
    (This)->lpVtbl -> get_Precision(This,pbPrecision)
#define _Parameter_put_NumericScale(This,bScale)	\
    (This)->lpVtbl -> put_NumericScale(This,bScale)
#define _Parameter_get_NumericScale(This,pbScale)	\
    (This)->lpVtbl -> get_NumericScale(This,pbScale)
#define _Parameter_put_Size(This,l)	\
    (This)->lpVtbl -> put_Size(This,l)
#define _Parameter_get_Size(This,pl)	\
    (This)->lpVtbl -> get_Size(This,pl)
#define _Parameter_AppendChunk(This,Val)	\
    (This)->lpVtbl -> AppendChunk(This,Val)
#define _Parameter_get_Attributes(This,plParmAttribs)	\
    (This)->lpVtbl -> get_Attributes(This,plParmAttribs)
#define _Parameter_put_Attributes(This,lParmAttribs)	\
    (This)->lpVtbl -> put_Attributes(This,lParmAttribs)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [propget] */ HRESULT STDMETHODCALLTYPE _Parameter_get_Name_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB _Parameter_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE _Parameter_put_Name_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [in] */ BSTR bstr);
void __RPC_STUB _Parameter_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _Parameter_get_Value_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);
void __RPC_STUB _Parameter_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propput] */ HRESULT STDMETHODCALLTYPE _Parameter_put_Value_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [in] */ VARIANT val);
void __RPC_STUB _Parameter_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE _Parameter_get_Type_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [retval][out] */ DataTypeEnum __RPC_FAR *psDataType);
void __RPC_STUB _Parameter_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE _Parameter_put_Type_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [in] */ DataTypeEnum sDataType);
void __RPC_STUB _Parameter_put_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE _Parameter_put_Direction_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [in] */ ParameterDirectionEnum lParmDirection);
void __RPC_STUB _Parameter_put_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE _Parameter_get_Direction_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [retval][out] */ ParameterDirectionEnum __RPC_FAR *plParmDirection);
void __RPC_STUB _Parameter_get_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE _Parameter_put_Precision_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [in] */ BYTE bPrecision);
void __RPC_STUB _Parameter_put_Precision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE _Parameter_get_Precision_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [retval][out] */ BYTE __RPC_FAR *pbPrecision);
void __RPC_STUB _Parameter_get_Precision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE _Parameter_put_NumericScale_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [in] */ BYTE bScale);
void __RPC_STUB _Parameter_put_NumericScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE _Parameter_get_NumericScale_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [retval][out] */ BYTE __RPC_FAR *pbScale);
void __RPC_STUB _Parameter_get_NumericScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE _Parameter_put_Size_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [in] */ long l);
void __RPC_STUB _Parameter_put_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE _Parameter_get_Size_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB _Parameter_get_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
HRESULT STDMETHODCALLTYPE _Parameter_AppendChunk_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [in] */ VARIANT Val);
void __RPC_STUB _Parameter_AppendChunk_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE _Parameter_get_Attributes_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plParmAttribs);
void __RPC_STUB _Parameter_get_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE _Parameter_put_Attributes_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [in] */ LONG lParmAttribs);
void __RPC_STUB _Parameter_put_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* ___Parameter_INTERFACE_DEFINED__ */
#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Parameter;
Parameter;
#endif
#ifndef __Parameters_INTERFACE_DEFINED__
#define __Parameters_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: Parameters
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID_Parameters;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0000050D-0000-0010-8000-00AA006D2EA4")
    ADOParameters : public _ADODynaCollection
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ _ADOParameter __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct ParametersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ADOParameters __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ADOParameters __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ADOParameters __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ADOParameters __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ADOParameters __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ADOParameters __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ADOParameters __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ADOParameters __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            ADOParameters __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            ADOParameters __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Append )( 
            ADOParameters __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *Object);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            ADOParameters __RPC_FAR * This,
            /* [in] */ VARIANT Index);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ADOParameters __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ _ADOParameter __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } ParametersVtbl;
    interface Parameters
    {
        CONST_VTBL struct ParametersVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define Parameters_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define Parameters_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define Parameters_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define Parameters_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define Parameters_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define Parameters_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define Parameters_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define Parameters_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)
#define Parameters__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)
#define Parameters_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)
#define Parameters_Append(This,Object)	\
    (This)->lpVtbl -> Append(This,Object)
#define Parameters_Delete(This,Index)	\
    (This)->lpVtbl -> Delete(This,Index)
#define Parameters_get_Item(This,Index,ppvObject)	\
    (This)->lpVtbl -> get_Item(This,Index,ppvObject)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [id][propget] */ HRESULT STDMETHODCALLTYPE Parameters_get_Item_Proxy( 
    ADOParameters __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ _ADOParameter __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB Parameters_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __Parameters_INTERFACE_DEFINED__ */
#ifndef __Property_INTERFACE_DEFINED__
#define __Property_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: Property
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID_Property;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000503-0000-0010-8000-00AA006D2EA4")
    ADOProperty : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ VARIANT __RPC_FAR *pval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ VARIANT val) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ DataTypeEnum __RPC_FAR *ptype) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Attributes( 
            /* [retval][out] */ long __RPC_FAR *plAttributes) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Attributes( 
            /* [in] */ long lAttributes) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct PropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ADOProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ADOProperty __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ADOProperty __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ADOProperty __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ADOProperty __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ADOProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ADOProperty __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            ADOProperty __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            ADOProperty __RPC_FAR * This,
            /* [in] */ VARIANT val);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ADOProperty __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            ADOProperty __RPC_FAR * This,
            /* [retval][out] */ DataTypeEnum __RPC_FAR *ptype);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attributes )( 
            ADOProperty __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plAttributes);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Attributes )( 
            ADOProperty __RPC_FAR * This,
            /* [in] */ long lAttributes);
        
        END_INTERFACE
    } PropertyVtbl;
    interface Property
    {
        CONST_VTBL struct PropertyVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define Property_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define Property_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define Property_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define Property_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define Property_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define Property_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define Property_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define Property_get_Value(This,pval)	\
    (This)->lpVtbl -> get_Value(This,pval)
#define Property_put_Value(This,val)	\
    (This)->lpVtbl -> put_Value(This,val)
#define Property_get_Name(This,pbstr)	\
    (This)->lpVtbl -> get_Name(This,pbstr)
#define Property_get_Type(This,ptype)	\
    (This)->lpVtbl -> get_Type(This,ptype)
#define Property_get_Attributes(This,plAttributes)	\
    (This)->lpVtbl -> get_Attributes(This,plAttributes)
#define Property_put_Attributes(This,lAttributes)	\
    (This)->lpVtbl -> put_Attributes(This,lAttributes)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [id][propget] */ HRESULT STDMETHODCALLTYPE Property_get_Value_Proxy( 
    ADOProperty __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pval);
void __RPC_STUB Property_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propput] */ HRESULT STDMETHODCALLTYPE Property_put_Value_Proxy( 
    ADOProperty __RPC_FAR * This,
    /* [in] */ VARIANT val);
void __RPC_STUB Property_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE Property_get_Name_Proxy( 
    ADOProperty __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB Property_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE Property_get_Type_Proxy( 
    ADOProperty __RPC_FAR * This,
    /* [retval][out] */ DataTypeEnum __RPC_FAR *ptype);
void __RPC_STUB Property_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE Property_get_Attributes_Proxy( 
    ADOProperty __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plAttributes);
void __RPC_STUB Property_get_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE Property_put_Attributes_Proxy( 
    ADOProperty __RPC_FAR * This,
    /* [in] */ long lAttributes);
void __RPC_STUB Property_put_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __Property_INTERFACE_DEFINED__ */
#ifndef __Properties_INTERFACE_DEFINED__
#define __Properties_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: Properties
 * at Thu Jun 18 18:47:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID_Properties;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000504-0000-0010-8000-00AA006D2EA4")
    ADOProperties : public _ADOCollection
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ ADOProperty __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct PropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ADOProperties __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ADOProperties __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ADOProperties __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ADOProperties __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ADOProperties __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ADOProperties __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ADOProperties __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ADOProperties __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            ADOProperties __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            ADOProperties __RPC_FAR * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ADOProperties __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ ADOProperty __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } PropertiesVtbl;
    interface Properties
    {
        CONST_VTBL struct PropertiesVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define Properties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define Properties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define Properties_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define Properties_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define Properties_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define Properties_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define Properties_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define Properties_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)
#define Properties__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)
#define Properties_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)
#define Properties_get_Item(This,Index,ppvObject)	\
    (This)->lpVtbl -> get_Item(This,Index,ppvObject)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [id][propget] */ HRESULT STDMETHODCALLTYPE Properties_get_Item_Proxy( 
    ADOProperties __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ ADOProperty __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB Properties_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __Properties_INTERFACE_DEFINED__ */
#endif /* __ADODB_LIBRARY_DEFINED__ */
/* Additional Prototypes for ALL interfaces */
/* end of Additional Prototypes */
#ifdef __cplusplus
}
#endif
#endif
#define ADOCommand _ADOCommand
#define ADORecordset _ADORecordset
#define ADOTransaction _ADOTransaction
#define ADOParameter _ADOParameter
#define ADOConnection _ADOConnection
#define ADOCollection _ADOCollection
#define ADODynaCollection _ADODynaCollection


#endif // _ADOINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\myweb\decab.cxx ===
/**
 * Asynchronous pluggable protocol for personal tier
 *
 * Copyright (C) Microsoft Corporation, 1999
 */

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ndll.h"
#include "setupapi.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

static inline bool
is_null_char(TCHAR c) {
    return c == L'\0';
}

static
inline bool is_dir_sep(TCHAR c) {
    return c == L'\\' || c == L'/';
}

void
MaybeAppendWhack(PTSTR pathname)
{
    if( NULL != pathname )
    {
        int len = wcslen(pathname);
        if(!len || !is_dir_sep(pathname[len]) )
            wcscat(pathname, L"\\");
    }
}

int
DirectoryExists(PCTSTR pathname)
{
    DWORD attr = GetFileAttributes(pathname);
    return ( attr != (DWORD)-1 && (attr & FILE_ATTRIBUTE_DIRECTORY));
}

int
MakePath(PCTSTR pathname)
{
    if( NULL == pathname || is_null_char(*pathname))
        return 0;
    //MessageBox(NULL, pathname, "MakePathTree", MB_OK);

    TCHAR drive[ _MAX_PATH ];
    TCHAR dirs[ _MAX_PATH ];
    _wsplitpath(pathname, drive, dirs, NULL, NULL);
    int err = 0;

    // go through each component in dirs, creating it if it
    // doesn't exist
    if( !DirectoryExists(dirs) )
    {
        TCHAR* dir;
        TCHAR* seps = L"\\/";
        TCHAR aggregate[ _MAX_PATH ];
        wcscpy(aggregate, drive);
      
        for( dir = wcstok(dirs, seps); NULL != dir; dir = wcstok(NULL, seps)) 
        {
            MaybeAppendWhack(aggregate);
            wcscat(aggregate, dir);
	  
            //MessageBox(NULL, aggregate, "MakePathTree", MB_OK);
            if( !DirectoryExists(aggregate) )
                if(!CreateDirectory(aggregate, NULL) )
                    err++;
        }
    }
   
    return (0 == err);
}


UINT WINAPI
CabFileHandler( LPVOID context, 
                UINT notification,
                UINT_PTR param1,
                UINT_PTR param2 )
{
    if (notification != SPFILENOTIFY_FILEINCABINET)
        return NO_ERROR;
    
    FILE_IN_CABINET_INFO *  info   = (FILE_IN_CABINET_INFO*)param1;

    wcscpy(info->FullTargetName, (LPCWSTR) context);
    MaybeAppendWhack(info->FullTargetName);
    wcscat(info->FullTargetName, info->NameInCabinet);

    if(MakePath(info->FullTargetName))
        return FILEOP_DOIT;
    else
        return FILEOP_SKIP;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\myweb\addlocal.cs ===
//------------------------------------------------------------------------------
// <copyright file="addlocal.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   addlocal.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace  System.Web.MyWebAdminUI {

using System;
using System.IO; 
using System.Collections;
using System.Web;
using System.Web.Util;
using System.Web.UI;
using System.Web.UI.WebControls;


  /// <include file='doc\addlocal.uex' path='docs/doc[@for="addlocalPage"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  public class addlocalPage : Page {


    /// <include file='doc\addlocal.uex' path='docs/doc[@for="addlocalPage.ActionLabel"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected Label ActionLabel;
		
    /// <include file='doc\addlocal.uex' path='docs/doc[@for="addlocalPage.Page_Load"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public void Page_Load(Object sender, EventArgs e) 
    {
      String appurl = Request.QueryString["installurl"];
	    String strAction = Request.QueryString["Reason"];
            
      if (strAction != null && strAction.Length > 0 && appurl != null)
      {
        if (strAction.Equals("2"))
        {
          ActionLabel.Text="The manifest for the application <br>(" + add_ProtSchem(appurl) + ")<br> could not be found.";
        }
        else if (strAction.Equals("1"))
        {
          ActionLabel.Text="The application <br><b>(" + add_ProtSchem(appurl) + ")</b><br> is already installed on this computer."; 
        }
        else if (strAction.Equals("3"))
        {
          ActionLabel.Text="The <b>default.aspx</b> file for this application could not be found.";
        }
        else if (strAction.Equals("4") )
        {
          ActionLabel.Text="The file path entered <b>(" + add_ProtSchem(appurl) + ")</b> does not exist in the local system.";
        }
        
      }
    }


    /// <include file='doc\addlocal.uex' path='docs/doc[@for="addlocalPage.add_ProtSchem"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public String add_ProtSchem(String app_url)
    {
    
	    if(!app_url.StartsWith("myweb://") )
	    {
        if( (app_url.IndexOf(":") != 1)&& !app_url.StartsWith("\\\\"))
	      {
		      app_url = "myweb://" + app_url;

		    }
	    }

	    return app_url;
    }


  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\myweb\default.cs ===
//------------------------------------------------------------------------------
// <copyright file="default.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   default.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace  System.Web.MyWebAdminUI {

using System;
using System.IO; 
using System.Collections;
using System.Web;
using System.Web.Util;
using System.Web.UI;
using System.Web.UI.WebControls;


/// <include file='doc\default.uex' path='docs/doc[@for="defaultPage"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
public class defaultPage : Page {

    /// <include file='doc\default.uex' path='docs/doc[@for="defaultPage.ApplicationList"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected DataList ApplicationList;
    /// <include file='doc\default.uex' path='docs/doc[@for="defaultPage.helplink"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public String helplink;

    /// <include file='doc\default.uex' path='docs/doc[@for="defaultPage.Page_Load"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public void Page_Load(Object sender, EventArgs e) 
    {
      MyWebApplication [] apps = MyWeb.GetInstalledApplications();

	    if (apps == null) 
      {
        return;
      }

      ApplicationList.DataSource = new ArrayList(apps);
      Page.DataBind();

 	
      for (int i=0; i<ApplicationList.Items.Count; i++) 
      {
        Repeater r = (Repeater) ApplicationList.Items[i].FindControl("InnerRepeater");
        r.DataSource = (String [])apps[i].Manifest.CustomUrlDescriptions;
        r.DataBind();
      }

    }

    /// <include file='doc\default.uex' path='docs/doc[@for="defaultPage.getApplicationUrl"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public String getApplicationUrl(Object data)
    {

	    String ApplicationUrl;
	
	    if (((MyWebApplication)data).Manifest.Url.Length >0 )
	    {
        ApplicationUrl = "myweb://"+((MyWebApplication)data).Manifest.ApplicationUrl +addSlash(((MyWebApplication)data).Manifest.Url);
      }
      else
      {
        ApplicationUrl = "myweb://" +(((MyWebApplication)data).Manifest.ApplicationUrl + "/default.aspx");
	    }

	    return ApplicationUrl;

    }


    /// <include file='doc\default.uex' path='docs/doc[@for="defaultPage.getNameUrl"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public String getNameUrl(Object data)
    {
      String NameUrl;

      if(((MyWebApplication)data).Manifest.Name.Length >0 )
      {
        NameUrl = (((MyWebApplication)data).Manifest.Name );
      }
      else
      {
        NameUrl= "myweb://"+ (((MyWebApplication)data).Manifest.ApplicationUrl);
      }

      return NameUrl;
    }



    /// <include file='doc\default.uex' path='docs/doc[@for="defaultPage.getHelpUrl"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public String getHelpUrl(Object data)
    {
      String HelpUrl;

      if(((MyWebApplication)data).Manifest.HelpUrl.Length >0 ) 
      {
        HelpUrl = "myweb://"+(((MyWebApplication)data).Manifest.ApplicationUrl) + addSlash(((MyWebApplication)data).Manifest.HelpUrl);
      }
      else
      {

        String temp;

        if (((MyWebApplication)data).Manifest.Name.Length >0 )
        {
          temp = (((MyWebApplication)data).Manifest.Name );

        }
        else
        {
          temp= "myweb://"+ (((MyWebApplication)data).Manifest.ApplicationUrl); 

        }

        HelpUrl= "help.aspx?singleApp=yes&name="+ temp;

      }
	    
	    
      return HelpUrl;
    }      


   /// <include file='doc\default.uex' path='docs/doc[@for="defaultPage.getIconUrl"]/*' />
   /// <devdoc>
   ///    <para>[To be supplied.]</para>
   /// </devdoc>
   public String getIconUrl(Object data)
   {
      String IconUrl;

      if(((MyWebApplication)data).Manifest.IconUrl.Length >0)
      {
        IconUrl =((MyWebApplication)data).Manifest.IconUrl;
        //IconUrl ="myweb://" + ((MyWebApplication)data).Manifest.ApplicationUrl + addSlash(((MyWebApplication)data).Manifest.IconUrl);
      }
      else
      {
        IconUrl= "/images/default.gif";
      }
      return IconUrl;
   }


   /// <include file='doc\default.uex' path='docs/doc[@for="defaultPage.addSlash"]/*' />
   /// <devdoc>
   ///    <para>[To be supplied.]</para>
   /// </devdoc>
   public String addSlash(String url)
   {
 
      if(!url.StartsWith("/"))
      {
        url = "/" + url;
      }
  
      return url;
   }


  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\myweb\ieworkerrequest.cs ===
//------------------------------------------------------------------------------
// <copyright file="IEWorkerRequest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**
 * The XSP IE hosting support
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Hosting {
    using System.Text;
    using System.Configuration.Assemblies;                                                       
    using System.Collections;
    using System.IO;
    using System.Globalization;
    using Microsoft.Win32;
    using System.Web;
    using System.Web.Util;
    using System.Web.Configuration;

/**
 * Implementation of HttpWorkerRequest for IE APP
 */
    internal class IEWorkerRequest : HttpWorkerRequest {
        // IE request as integer

        private IntPtr _ierequest;
        //private String _configdir;

        // Misc request data

        private String _uriPath;
        private String _queryString;
        private String _verb;
        private String _status;
        private String _pathTranslated;
        private String _appPath;
        private String _appPathTranslated;

        private String _headers = "";
        private bool _headersSent;

        public enum IERequestStrings {
            UriPath             = 0,
            QueryString         = 1,
            RawUrl              = 2,
            Verb                = 3,
            PathTranslated      = 4,
            AppPath             = 5,
            AppPathTranslated   = 6,
        }

        internal IEWorkerRequest(IntPtr ierequest) {
            _ierequest = ierequest;
        }

        public override String GetProtocol() {
            return "myweb";
        }

        public override String GetUriPath() {
            if (_uriPath == null)
                _uriPath = GetRequestString(IERequestStrings.UriPath);
            return _uriPath;
        }

        public override String GetFilePathTranslated() {

            if (_pathTranslated == null)
                _pathTranslated = MapPath(GetUriPath());
            return _pathTranslated;
        }


        public override String GetQueryString() {
            if (_queryString == null)
                _queryString = GetRequestString(IERequestStrings.QueryString);
            return _queryString;
        }

        public override String GetRawUrl() {
            String qs = GetQueryString();

            if (qs != null && qs.Length > 0)
                return GetUriPath() + "?" + qs;
            else
                return GetUriPath();
        }

        public override String GetHttpVerbName() {
            if (_verb == null)
                _verb = GetRequestString(IERequestStrings.Verb);
            return _verb;
        }

        public override String GetHttpVersion() {
            return "MyWeb/1.0";
        }       

        public override String  GetRemoteAddress() {
            return "127.0.0.1";

        }

        public override int GetRemotePort() {
            return 80;
        }

        public override String GetLocalAddress() {
            return "127.0.0.1";
        }

        public override int GetLocalPort() {
            return 0;
        }

        public override String GetAppPath() {
            if (_appPath == null)
                _appPath = GetRequestString(IERequestStrings.AppPath);
            return _appPath;
        }

        public override String GetAppPathTranslated() {
            if (_appPathTranslated == null) {
                _appPathTranslated = GetRequestString(IERequestStrings.AppPathTranslated);

                if (_appPathTranslated != null && !_appPathTranslated.EndsWith("\\"))
                    _appPathTranslated = _appPathTranslated + "\\";
            }

            return _appPathTranslated;
        }

        public override String GetServerVariable(String name) {
            int            size      = 256;
            StringBuilder  buf       = new StringBuilder(size);

            size = UnsafeNativeMethods.IEWRGetKnownRequestHeader(_ierequest, name, buf, size);        
            if (size == 0) {
                name = "HTTP_" + name;
                size = UnsafeNativeMethods.IEWRGetKnownRequestHeader(_ierequest, name, buf, size);        
                if (size == 0)
                    return String.Empty;
            }

            if (size < 0) {
                size  = 2 - size;
                buf   = new StringBuilder(size);
                size = UnsafeNativeMethods.IEWRGetKnownRequestHeader(_ierequest, name, buf, size);
                if (size <= 0)
                    return String.Empty;
            }

            return buf.ToString();
        }

        public override String GetKnownRequestHeader(int index) {
            int            size      = 256;
            StringBuilder  buf       = new StringBuilder(size);
            String         strHeader = GetKnownRequestHeaderName(index);

            size = UnsafeNativeMethods.IEWRGetKnownRequestHeader(_ierequest, strHeader, buf, size);        
            if (size == 0)
                return "";

            if (size < 0) {
                size  = 2 - size;
                buf   = new StringBuilder(size);
                size = UnsafeNativeMethods.IEWRGetKnownRequestHeader(_ierequest, strHeader, buf, size);
                if (size <= 0)
                    return "";
            }

            return buf.ToString();
        }

        public override void SendStatus(int statusCode, String statusDescription) {
            _status = statusCode.ToString() + " " + statusDescription;
        }


        public override void SendKnownResponseHeader(int index, String value) {
            if (_headersSent)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_append_header_after_headers_sent));

            _headers += GetKnownResponseHeaderName(index) + ": " + value + "\r\n";
        }


        public override void SendUnknownResponseHeader(String name, String value) {
            if (_headersSent)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_append_header_after_headers_sent));

            _headers += name + ": " + value + "\r\n";

        }


        public override void SendCalculatedContentLength(int contentLength) {
            if (!_headersSent) {
                _headers += "Content-Length: " + contentLength.ToString() + "\r\n";
            }
        }

        public override bool HeadersSent() {
            return _headersSent;
        }

        public override void CloseConnection() {
            // TODO: 
        }

        public override void SendResponseFromMemory(byte[] data, int length) {
            if (!_headersSent)
                SendHeaders();

            if (length > 0)
                WriteBytes(data, length);
        }


        public override void SendResponseFromFile(String filename, long offset, long length) {
            if (!_headersSent)
                SendHeaders();

            if (length == 0)
                return;

            FileStream f = null;

            try {
                f = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read);
                SendResponseFromFileStream(f, offset, length);
            }
            finally {
                if (f != null)
                    f.Close();
            }
        }


        public override void SendResponseFromFile(IntPtr handle, long offset, long length) {
            if (!_headersSent)
                SendHeaders();

            if (length == 0)
                return;

            FileStream f = null;

            try {
                f = new FileStream(handle, FileAccess.Read, false);
                SendResponseFromFileStream(f, offset, length);
            }
            finally {
                if (f != null)
                    f.Close();
            }
        }

        private void SendResponseFromFileStream(FileStream f, long offset, long length) {
            long fileSize = f.Length;

            if (length == -1)
                length = fileSize - offset;

            if (offset < 0 || length > fileSize - offset)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_range));

            if (length > 0) {
                if (offset > 0)
                    f.Seek(offset, SeekOrigin.Begin);

                byte[] fileBytes = new byte[(int)length];
                f.Read(fileBytes, 0, (int)length);            
                WriteBytes(fileBytes, (int)length);
            }
        }

        public override void FlushResponse(bool finalFlush) {
            // only flush headers - the data is write through

            if (!_headersSent)
                SendHeaders();
        }


        public override void EndOfRequest() {
            FlushResponse(true);
            UnsafeNativeMethods.IEWRCompleteRequest(_ierequest);
        }

        public override String MapPath(String virtualPath) {
            int size = 256, r;
            StringBuilder buf = new StringBuilder(size);

            r = UnsafeNativeMethods.IEWRMapPath(_ierequest, virtualPath, buf, size);
            if (r < 0) {
                size = -r;
                buf = new StringBuilder(size);
                r = UnsafeNativeMethods.IEWRMapPath(_ierequest, virtualPath, buf, size);
            }

            if (r != 1)
                return null;

            return buf.ToString();
        }

        //
        // Gets the string from 
        //
        private String GetRequestString(IERequestStrings key) {
            int size;

            size = UnsafeNativeMethods.IEWRGetStringLength(_ierequest, key);

            if (size == 0) return "";

            StringBuilder buf = new StringBuilder(size);
            if (UnsafeNativeMethods.IEWRGetString(_ierequest, key, buf, size) != size)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_retrieve_request_string, key.ToString()));

            return buf.ToString();
        }

        void SendHeaders() {
            if (_headersSent)
                return;

            _headers = "MyWeb/1.0 " + _status + "\r\nServer: Microsoft-MyWeb/1.0\r\nDate: " + 
                       HttpUtility.FormatHttpDateTime(DateTime.Now) + "\r\n" + _headers;

            _headersSent = true;
            _headers += "\r\n";

            UnsafeNativeMethods.IEWRSendHeaders(_ierequest, _headers);

        }

        void WriteBytes(byte[] bytes, int length) {
            UnsafeNativeMethods.IEWRSendBytes(_ierequest, bytes, length);
        }

        /*
        private String ConfigDir {
            get {
                if (_configdir == null) {
                    try {
                        RegistryKey key = Registry.LocalMachine.OpenSubKey(ModName.REG_MACHINE_APP);
                        if (key != null)
                            _configdir = (String)key.GetValue("ConfigDir");
                    }
                    catch (Exception) {
                        // eat exceptions
                    }

                    // if configdir doesn't exist or doesn't contain config file, use rootdir
                    if (    _configdir == null || 
                            _configdir.Length == 0 || 
                            !File.Exists(HttpConfigurationSystemBase.MachineConfigurationFilePath)) {

                        _configdir = HttpRuntime.AspInstallDirectory;
                    }

                }

                return _configdir;
            }
        }
        */

        public override String MachineConfigPath {
            get {
                return HttpConfigurationSystemBase.MachineConfigurationFilePath;
            }
        }

        public override String MachineInstallDirectory {
            get {
                return HttpRuntime.AspInstallDirectory;
            }
        }

        public override byte[] GetPreloadedEntityBody() {
            int iSize = UnsafeNativeMethods.IEWRGetPostedDataSize(_ierequest);
            if (iSize < 1)
                return null;
            byte [] buf = new byte[iSize];
            int iRet = UnsafeNativeMethods.IEWRGetPostedData(_ierequest, buf, iSize);
            if (iRet < 0)
                return null;
            else
                return buf;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\myweb\help.cs ===
//------------------------------------------------------------------------------
// <copyright file="help.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   help.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace  System.Web.MyWebAdminUI {

  using System;
  using System.IO; 
  using System.Collections;
  using System.Web;
  using System.Web.Util;
  using System.Web.UI;
  using System.Web.UI.WebControls;
  using System.Web.UI.HtmlControls;

  /// <include file='doc\help.uex' path='docs/doc[@for="helpPage"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  public class helpPage : Page {

  /// <include file='doc\help.uex' path='docs/doc[@for="helpPage.singleApp"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  public String singleApp;
  /// <include file='doc\help.uex' path='docs/doc[@for="helpPage.nameLabel"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  protected Label nameLabel;

  /// <include file='doc\help.uex' path='docs/doc[@for="helpPage.Page_Load"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  public void Page_Load(Object sender, EventArgs e) 
  {
    singleApp = Request.QueryString["singleApp"]; //determining if help has been triggered from an individual application or from the My Web toolbar

    if (singleApp == "yes")
    {
      nameLabel.Text = Request.QueryString["name"];
    }
  }

  }
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\myweb\install.cs ===
//------------------------------------------------------------------------------
// <copyright file="install.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   install.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace  System.Web.MyWebAdminUI {

using System;
using System.IO; 
using System.Collections;
using System.Web;
using System.Web.Util;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

  /// <include file='doc\install.uex' path='docs/doc[@for="installPage"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  public class installPage : Page {

    /// <include file='doc\install.uex' path='docs/doc[@for="installPage.HiddenUrl"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected HtmlInputHidden HiddenUrl;
    /// <include file='doc\install.uex' path='docs/doc[@for="installPage.localInstall"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected Label localInstall;
    /// <include file='doc\install.uex' path='docs/doc[@for="installPage.UrlText"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected TextBox UrlText;
    
    /// <include file='doc\install.uex' path='docs/doc[@for="installPage.app"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public MyWebApplication app;
    /// <include file='doc\install.uex' path='docs/doc[@for="installPage.manifest"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public MyWebManifest    manifest;
    /// <include file='doc\install.uex' path='docs/doc[@for="installPage.addlocal"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public bool addlocal = false;

    /// <include file='doc\install.uex' path='docs/doc[@for="installPage.Page_Load"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public void Page_Load(Object sender, EventArgs e) 
    {
      if (!IsPostBack)
      {
		    String NoURL=Request["NoURL"];
			
		    if (NoURL =="1")
		    {
			    HiddenUrl.Value = Request["LocalPath"];
			    addlocal = true;
			    manifest = MyWeb.GetManifestForLocalApplication(HiddenUrl.Value);
			    localInstall.Text = "<center><p>A local application is being installed. A URL must be entered for each local application.<br> Enter the URL for this application below: </p></center>";
		    }
		    else if(NoURL=="2")
		    {
          HiddenUrl.Value = Request["LocalPath"];
			    addlocal = true;
			    manifest = MyWeb.GetManifestForLocalApplication(HiddenUrl.Value);
			    localInstall.Text = "<center><p>The URL entered already exists. Please enter a different URL.</p></center>";
		    }

		    else if(NoURL=="3")
		    {
          String SpecChar = Request["SpecChar"];
		      HiddenUrl.Value = Request["LocalPath"];
			    addlocal = true;
			    manifest = MyWeb.GetManifestForLocalApplication(HiddenUrl.Value);
			    localInstall.Text = "<center><p>The URL entered contains the following special character:<b>'"+ SpecChar +"'</b><br> Please omit this character from the URL.</p></center>";
          UrlText.Text = Request["localURL"];
		    }
		    else
		    {
		      bool fShowInstall = true;
          int  iAction = 0;
          String appurl = Request["installurl"];

          if (appurl == null)
          {
            appurl = Request["MyWebPage"];
          }
      
      
          if (appurl != null && appurl.Length > 0) 
          {

            app = MyWeb.GetApplication(appurl);
            if (app != null)
            {
              iAction = 1;
              fShowInstall = true;
            }
      
      
            else
            {	

       	      if(appurl.StartsWith("\\\\") && (appurl.LastIndexOf('\\') < 2) )
				      {	
					      addlocal = true;
				      }

              else if ((appurl[1]==':') && (appurl.Length == 2))
              {
                fShowInstall = true;
					      iAction = 4;
              }

				
				      else if (appurl[1] == ':' && appurl[2] != '/' )
				      {
					      if(Directory.Exists(appurl) )
					      {
					        addlocal = true;
				          
					      } 
							
					      else 
					      { 	
						      if (File.Exists(appurl) )
						      {
							      addlocal = true;
							      int slash = appurl.LastIndexOf('\\');
							      appurl = appurl.Substring(0, slash);
					
						      }

						      else 
                  {
                    //directory is not valid
                    fShowInstall = true;
					          iAction = 4;

                  }
						
					      }

				      }

				    if (addlocal)
				    {  
          
              manifest = MyWeb.GetManifestForLocalApplication(appurl);   
          
          
              //checking if the manifest exists

              if(manifest.Url != null && manifest.Url.Length > 0)
              {
                if( !(FindSpecialChar(manifest.Url) == "a"))
                {

                  Response.Redirect("myweb://Home/myweb1.aspx?success=specialChar&SpecChar="+FindSpecialChar(manifest.Url) +"&Path=" + appurl);
                }
                else
                {
                  HiddenUrl.Value = appurl;
                  fShowInstall = false;
                  String temp = appurl.Replace('\\' , '/');
					        UrlText.Text = "localhost/" +temp.Substring(3);
					        localInstall.Text ="<center><p>A local path has been detected. A URL must be entered for each local application.<br> Below is the suggested URL. You may choose to edit it or leave it unmodified.</p></center>";
                }
              }
              else
              {

                if (File.Exists(appurl + "\\default.aspx") )
                {
                  HiddenUrl.Value = appurl;
                  fShowInstall = false;
                  String temp = appurl.Replace('\\' , '/');
					        UrlText.Text = "localhost/" +temp.Substring(3);
					        localInstall.Text ="<center><p>A local path has been detected. A URL must be entered for each local application.<br> Below is the suggested URL. You may choose to edit it or leave it unmodified.</p></center>";
					    
					      }
					      else
					      {
					        fShowInstall = true;
					        iAction = 3;
					      }					  
              }

					
					    if(!fShowInstall)
					    {
          
				        //if the app exists, checking that local application has not been already installed
				
					      MyWebApplication [] apps = MyWeb.GetInstalledApplications();

					      if (apps != null)
					      {

						      for (int i=0; i < apps.Length; i++)
						      {
							      if (apps[i].LocalApplication)
							      {
							        String Oldtemp = apps[i].Manifest.InstalledLocation.ToLower(CultureInfo.InvariantCulture);
								      String Newtemp = appurl.ToLower(CultureInfo.InvariantCulture);

								      if (Oldtemp.EndsWith("\\") && !Newtemp.EndsWith("\\") )
								      {
								        Newtemp=Newtemp + "\\";	
								      }
								      else if (Newtemp.EndsWith("\\") && !Oldtemp.EndsWith("\\") )
								      {
								        Oldtemp=Oldtemp + "\\";
								      }
								
								      if(Oldtemp.Equals(Newtemp) )
								      {
								        iAction = 1;
								        fShowInstall = true;
								      }
							      }

						      }
					      }
              }
				    }

				      if ((!addlocal) && (iAction != 3) && (iAction !=4))
				      {
                
                  manifest = MyWeb.GetManifest(appurl);
            
                  if (manifest != null)
                  {
                    if( !(FindSpecialChar(manifest.Url) == "a"))
                    {
                      Response.Redirect("myweb://Home/myweb1.aspx?success=specialChar&SpecChar="+FindSpecialChar(manifest.Url) +"&Path=" + appurl);
                    }
                    else
                    {
                      HiddenUrl.Value = appurl;
                      fShowInstall = false;
                      // populate the details
                    }
                  }
                  else 
                  { 
                    iAction = 2;
                  }

              }
            } 

          }

             if(fShowInstall)
             {
                String strRedirect = "myweb://Home/addlocal.aspx?Reason=" + iAction ;
                if (appurl != null && appurl.Length > 0)
                {
                  strRedirect += "&installurl=" + appurl;
                }
                Response.Redirect(strRedirect);
                return;
              }
    
             if(manifest.Url !=null && manifest.Url.Length >0 )
             {
                DataBind();
             }
      
            }
          }
        }


      /// <include file='doc\install.uex' path='docs/doc[@for="installPage.Install"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public void Install(Object sender, EventArgs e) 
      {
        MyWebManifest manifest = MyWeb.GetManifest(HiddenUrl.Value);

	      if(manifest ==null)
	      {
		      Response.Redirect("myweb://Home/myweb1.aspx?success=no");
	      }
	      else 
	      {
 		      if (manifest.Install() ==null)
		      {
            Response.Redirect("myweb://Home/myweb1.aspx?success=no");
          }
          else 
          {
            Response.Redirect("myweb://Home/myweb1.aspx?success=yes&URL=" + HiddenUrl.Value);
          }
        }
      }  
        

      /// <include file='doc\install.uex' path='docs/doc[@for="installPage.InstallLocalApp"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public void InstallLocalApp(Object sender, EventArgs e)
      {
	      String localPath = HiddenUrl.Value;
	      //manifest = MyWeb.GetManifestForLocalApplication(localPath);

	      String localURL;

        localURL =UrlText.Text;
        
	      if (localURL.Length >0 && localURL != null )
	      {
          if( !(FindSpecialChar(localURL) == "a"))
          {
            Response.Redirect("myweb://Home/install.aspx?NoURL=3&LocalPath=" + localPath + "&SpecChar=" + FindSpecialChar(localURL)+"&localURL=" + localURL);
          }

          else
          {
          
 		        localURL = localURL.Replace(' ', '_');
		        localURL = localURL.Replace('\\', '/');

            app = MyWeb.GetApplication(localURL);
            if(app!=null)
            {
              Response.Redirect("myweb://Home/install.aspx?NoURL=2&LocalPath=" + localPath);
            }

		  
		        MyWeb.InstallLocalApplication(localURL, localPath);	
		        Response.Redirect("myweb://Home/myweb1.aspx?success=yes&URL=" + localURL +"&Local=true");	

          }
		      
	      }
	      else 
        {
		      Response.Redirect("myweb://Home/install.aspx?NoURL=1&LocalPath=" + localPath);	
        }

      }

      /// <include file='doc\install.uex' path='docs/doc[@for="installPage.FindSpecialChar"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      protected String FindSpecialChar(String value) 
      {
        int temp;
        String specialChar = "a";
        
        if (value.IndexOf('?') >=0 )
        {
          temp = value.IndexOf('?');
          specialChar = value[temp].ToString();
        } 
        else if (value.IndexOf('#') >=0 )
        {
          temp = value.IndexOf('#');
          specialChar = value[temp].ToString();
        } 
        else if (value.IndexOf('&') >=0 )
        {
          temp = value.IndexOf('&');
          specialChar = value[temp].ToString();
        } 
        else if (value.IndexOf('*') >=0 )
        {
          temp = value.IndexOf('*');
          specialChar = value[temp].ToString();
        } 
        else if (value.IndexOf('+') >=0 )
        {
          temp = value.IndexOf('+');
          specialChar = value[temp].ToString();
        } 
        else if (value.IndexOf('|') >=0 )
        {
          temp = value.IndexOf('|');
          specialChar = value[temp].ToString();
        } 
        else if (value.IndexOf(':') >=0 )
        {
          temp = value.IndexOf(':');
          specialChar = value[temp].ToString();
        } 
        else if (value.IndexOf('"') >=0 )
        {
          temp = value.IndexOf('"');
          specialChar = value[temp].ToString();
        } 
        else if (value.IndexOf('<') >=0 )
        {
          temp = value.IndexOf('<');
          specialChar = value[temp].ToString();
        } 
        else if (value.IndexOf('>') >=0 )
        {
          temp = value.IndexOf('>');
          specialChar = value[temp].ToString();
        } 
        
        
        return specialChar;
          
      }
          
        
       

    
    }
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\myweb\functions.cxx ===
/**
 * Asynchronous pluggable protocol for personal tier
 *
 * Copyright (C) Microsoft Corporation, 1999
 */

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ndll.h"
#include "appdomains.h"
#include "_isapiruntime.h"
#include "wininet.h"
#include "myweb.h"

#define IEWR_URIPATH            0
#define IEWR_QUERYSTRING        1
#define IEWR_VERB               3
#define IEWR_APPPATH            5
#define IEWR_APPPATHTRANSLATED  6

extern BOOL g_fRunningMyWeb;
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOL         (WINAPI * g_pInternetSetCookieW  ) (LPCTSTR, LPCTSTR, LPCTSTR)                             = NULL;
BOOL         (WINAPI * g_pInternetGetCookieW  ) (LPCTSTR, LPCTSTR, LPTSTR, LPDWORD)                     = NULL;
HINTERNET    (WINAPI * g_pInternetOpen        ) (LPCTSTR, DWORD, LPCTSTR, LPCTSTR, DWORD)               = NULL;
void         (WINAPI * g_pInternetCloseHandle ) (HINTERNET)                                             = NULL;
HINTERNET    (WINAPI * g_pInternetOpenUrl     ) (HINTERNET, LPCTSTR, LPCTSTR, DWORD, DWORD, DWORD_PTR)  = NULL;
BOOL         (WINAPI * g_pInternetReadFile    ) (HINTERNET, LPVOID, DWORD, LPDWORD)                     = NULL;

IInternetSecurityManager * g_pInternetSecurityManager = NULL;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Exported functions: Called from managed code

int _stdcall 
IEWRCompleteRequest(PTProtocol *pRequest)
{
    return pRequest->Finish();
}

int _stdcall 
IEWRGetStringLength(PTProtocol *pRequest, int key)
{
    return pRequest->GetStringLength(key);
}

int _stdcall 
IEWRGetString(PTProtocol *pRequest, int key, WCHAR * buf, int size)
{
    return pRequest->GetString(key, buf, size);
}

int _stdcall 
IEWRSendHeaders(PTProtocol *pRequest, LPSTR headers)
{
    return pRequest->SendHeaders(headers);
}

int _stdcall 
IEWRSendBytes(PTProtocol *pRequest, BYTE *bytes, int length)
{
    return pRequest->WriteBytes(bytes, length);
}

int _stdcall 
IEWRMapPath(PTProtocol *pRequest, WCHAR *virtualPath, WCHAR * buf, int size)
{
    return pRequest->MapPath(virtualPath, buf, size);
}

int _stdcall 
IEWRGetKnownRequestHeader(PTProtocol *pRequest, LPCWSTR szHeader, LPWSTR buf, int size)
{
  return pRequest->GetKnownRequestHeader(szHeader, buf, size);  
}

int _stdcall 
IEWRGetPostedDataSize(PTProtocol *pRequest)
{
  return pRequest->GetPostedDataSize();
}

int _stdcall 
IEWRGetPostedData(PTProtocol *pRequest, BYTE * buf, int iSize)
{
  return pRequest->GetPostedData(buf, iSize);
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
int _stdcall 
MyWebGetNumInstalledApplications()
{
    return CMyWebAdmin::GetNumInstalledApplications();
}

int _stdcall 
MyWebGetApplicationIndexForUrl(LPCWSTR szUrlConst)
{
    return CMyWebAdmin::GetApplicationIndexForUrl(szUrlConst);
}

int _stdcall 
MyWebGetApplicationManifestFile(
        LPCWSTR     szUrl, 
        LPWSTR      szFileBuf,
        int         iFileBufSize,
        LPWSTR      szUrlBuf,
        int         iUrlBufSize)
{
    return CMyWebAdmin::GetApplicationManifestFile(
            szUrl, 
            szFileBuf,
            iFileBufSize,
            szUrlBuf,
            iUrlBufSize);
}

int _stdcall 
MyWebGetApplicationDetails (
        int             iIndex,
        LPWSTR          szDir,
        int             iDirSize,
        LPWSTR          szUrl,
        int             iUrlSize,        
        __int64 *       pDates)
{
    return CMyWebAdmin::GetApplicationDetails (
            iIndex,
            szDir,
            iDirSize,
            szUrl,
            iUrlSize,        
            pDates);
}


int _stdcall 
MyWebInstallApp (
        LPCWSTR    szCabFile,
        LPCWSTR    szUrl,
        LPCWSTR    szAppDir,
        LPCWSTR    szAppManifest,
        LPWSTR     szError,
        int        iErrorSize )
{
    return CMyWebAdmin::InstallApp (
            szCabFile,
            szUrl,
            szAppDir,
            szAppManifest,
            szError,
            iErrorSize );
}

int _stdcall 
MyWebReInstallApp (
        LPCWSTR    szCabFile,
        LPCWSTR    szUrl,
        LPCWSTR    szAppDir,
        LPCWSTR    szAppManifest,
        LPWSTR     szError,
        int        iErrorSize )
{
    return CMyWebAdmin::ReInstallApp (
            szCabFile,
            szUrl,
            szAppDir,
            szAppManifest,
            szError,
            iErrorSize );
}

int _stdcall 
MyWebRemoveApp(
        LPCWSTR    szAppUrl)
{
    return CMyWebAdmin::RemoveApp(
            szAppUrl);
}


int _stdcall 
MyWebMoveApp(
        LPCWSTR    szAppUrl, 
        LPCWSTR    szNewLocation,
        LPWSTR     szError,
        int        iErrorSize)
{
    return CMyWebAdmin::MoveApp(
            szAppUrl, 
            szNewLocation,
            szError,
            iErrorSize);
}

int _stdcall 
MyWebGetInstallLocationForUrl(
        LPCWSTR    szConfigValue, 
        LPCWSTR    szAppUrl,
        LPCWSTR    szRandom,
        LPWSTR     szBuf,
        int        iBufSize)
{
    return CMyWebAdmin::GetInstallLocationForUrl(
            szConfigValue, 
            szAppUrl,
            szRandom,
            szBuf,
            iBufSize);
}

int _stdcall 
MyWebInstallLocalApplication(
        LPCWSTR    szAppUrl,
        LPCWSTR    szAppDir)
{
    return CMyWebAdmin::InstallLocalApplication(
            szAppUrl, 
            szAppDir);
}


int __stdcall
MyWebRunningOnMyWeb()
{
    return g_fRunningMyWeb;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
HRESULT InitializePTProtocol()
{
    if (g_Started)
        return TRUE;

    HRESULT             hr             = S_OK;
    IInternetSession *  pSession       = NULL;
    HINSTANCE           hWinInet       = NULL;

    CMyWebAdmin::Initialize();

    ////////////////////////////////////////////////////////////
    // Step 2: Register with the UrlMON session. This will keep us alive 
    //         across invocations. Consider registering as property on 
    //         IWebBrowserApp::PutProperty. IWebBrowserApp will time out 
    //         the reference.

    hr = CoInternetGetSession(0, &pSession, 0);
    ON_ERROR_EXIT();
    
    hr = pSession->RegisterNameSpace(
            &g_PTProtocolFactory, CLSID_PTProtocol, SZ_PROTOCOL_NAME, 0, NULL, 0);
    ON_ERROR_EXIT();

    ////////////////////////////////////////////////////////////
    // Step 3: Obtain  entry points from WININET.DLL
    hWinInet = GetModuleHandle(WININET_MODULE_FULL_NAME_L);
    if(hWinInet == NULL)
        hWinInet = LoadLibrary(WININET_MODULE_FULL_NAME_L);
    if(hWinInet == NULL)
        EXIT_WITH_LAST_ERROR();

    g_pInternetSetCookieW = (BOOL (WINAPI *)(LPCTSTR, LPCTSTR, LPCTSTR))
        GetProcAddress(hWinInet, "InternetSetCookieW");
    g_pInternetGetCookieW = (BOOL (WINAPI *)(LPCTSTR, LPCTSTR, LPTSTR, LPDWORD))
        GetProcAddress(hWinInet, "InternetGetCookieW");
    g_pInternetOpen = (HINTERNET (WINAPI *)(LPCTSTR, DWORD, LPCTSTR, LPCTSTR, DWORD))
        GetProcAddress(hWinInet, "InternetOpenW");
    g_pInternetCloseHandle = (void (WINAPI *)(HINTERNET))
        GetProcAddress(hWinInet, "InternetCloseHandle");
    g_pInternetOpenUrl = (HINTERNET (WINAPI *)(HINTERNET, LPCTSTR, LPCTSTR, DWORD, DWORD, DWORD_PTR))
        GetProcAddress(hWinInet, "InternetOpenUrlW");
    g_pInternetReadFile = (BOOL (WINAPI *)(HINTERNET, LPVOID, DWORD, LPDWORD))
        GetProcAddress(hWinInet, "InternetReadFile");
        
    if ( g_pInternetSetCookieW   == NULL ||
         g_pInternetGetCookieW   == NULL ||
         g_pInternetOpen         == NULL ||
         g_pInternetCloseHandle  == NULL ||
         g_pInternetOpenUrl      == NULL ||
         g_pInternetReadFile     == NULL  )
    {
        EXIT_WITH_LAST_ERROR();            
    }

    ////////////////////////////////////////////////////////////
    // Step 4: Init app domain factory
    hr = InitAppDomainFactory();
    ON_ERROR_EXIT();

    hr = CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER,
                          IID_IInternetSecurityManager, (void**)&g_pInternetSecurityManager);
    
    ON_ERROR_CONTINUE();
    g_Started = TRUE;

 Cleanup:
    if(pSession)
        pSession->Release(); 
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT 
GetPTProtocolClassObject(
        REFIID    iid, 
        void **   ppv)
{
    HRESULT hr;

    hr = InitializePTProtocol();
    ON_ERROR_EXIT();

    hr = g_PTProtocolFactory.QueryInterface(iid, ppv);
    ON_ERROR_EXIT();

 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

LPWSTR
DuplicateString ( LPCWSTR szString)
{
  if (szString == NULL)
    return NULL;

  LPWSTR szReturn = (LPWSTR) MemAlloc((wcslen(szString) + 1) * sizeof(WCHAR));

  if (szReturn != NULL)
    wcscpy(szReturn, szString);

  return szReturn;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Cleanup for process shutdown.

void
TerminatePTProtocol()
{
    // TODO: This is never called. Figure out how to get proper shutdown. Consider possible refcount leaks.

    if (g_Started)
    {
        CMyWebAdmin::Close();
        TerminateExtension(0);
        g_Started = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\myweb\myweb.cs ===
//------------------------------------------------------------------------------
// <copyright file="MyWeb.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**
 * MyWeb class
 */

namespace System.Web {
    using System.Web.Util;
    using System.Text;
    using System.Web.Configuration;
    using System.Collections;
    using System.Globalization;
    
    /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWeb"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Used by an application to retrieve information about installed MyWeb
    ///       applications. MyWeb methods are intended for use solely by the
    ///       administrative facility and require an administrative Uri as part of the request
    ///       context in order to succeed.
    ///    </para>
    /// </devdoc>
    public sealed class MyWeb {
        private static readonly int INTERNET_CONNECTION_OFFLINE = 0x20; // from wininet.h

        //////////////////////////////////////////////////////////////////////
        // Check if we are running whithin IE
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWeb.RunningOnMyWeb"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a
        ///       value specifying whether the application is executing in the MyWeb environment.
        ///    </para>
        /// </devdoc>
        static public bool RunningOnMyWeb { 
            get {
                if (!_RunningOnMyWebChecked) {
                    _RunningOnMyWebChecked = true;
                    _RunningOnMyWeb = (NativeMethods.MyWebRunningOnMyWeb() != 0);
                }
                return _RunningOnMyWeb; 
            }
        }

        //////////////////////////////////////////////////////////////////////
        // Check if we have an internet connection
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWeb.Connected"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies whether the application is "working online". This delegates to the
        ///       WinInet InternetGetConnectedState facility which is shared with IE, Outlook,
        ///       etc. It is possible to technically be online (have an active network connection)
        ///       and have this property evaluate to false if the user has selected that
        ///       state manually by choosing "Work Offline" from an application's menu.
        ///    </para>
        /// </devdoc>
        static public bool Connected { 
            get {
                int [] iFlags = new int [1];            
                iFlags[0] = 0;

                int iRet = NativeMethods.InternetGetConnectedState(iFlags, 0);

                if (iRet == 0)
                    return false;
                else
                    return((iFlags[0] & INTERNET_CONNECTION_OFFLINE) == 0);
            }
        }

        //////////////////////////////////////////////////////////////////////
        // Get the connection name
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWeb.ConnectionName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns
        ///       the name of the current network connection as provided by the WinInet
        ///       InternetGetConnectedStateEx facility.
        ///    </para>
        /// </devdoc>
        static public String ConnectionName { 
            get {
                int [] iFlags = new int [1];            
                StringBuilder str = new StringBuilder(1024);
                NativeMethods.InternetGetConnectedStateEx(iFlags, str, 1024, 0);
                return str.ToString();
            }
        }

        //////////////////////////////////////////////////////////////////////
        // Get the default install location
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWeb.GetDefaultInstallLocation"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        ///    <para>Returns the default install directory for MyWeb applications.</para>
        /// </devdoc>
        static public String GetDefaultInstallLocation() {
            if (!RunningOnMyWeb || !IsAdminApp())
                return null;

            String strReturn = (String) HttpContext.Current.GetConfigDictionaryValue("myweb", "defaultinstalllocation");
            if (strReturn == null || strReturn.Length < 1)
                strReturn = "%ProgramFiles%\\myweb";

            return strReturn;
        }

        //////////////////////////////////////////////////////////////////////
        // Get the array of installed application
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWeb.GetInstalledApplications"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        ///    <para>Returns an array consisting of all installed MyWeb applications. Returns
        ///    <see langword='null'/> if there are no installed applications, or if not running 
        ///       in the context of the administrative application (as determined by the Uri
        ///       obtained from the context).</para>
        /// </devdoc>
        static public MyWebApplication [] GetInstalledApplications() {
            if (!RunningOnMyWeb || !IsAdminApp())
                return null;

            MyWebApplication []    apps       = null;
            int                    iNumApps   = 0;
            int                    iter       = 0;

            iNumApps = NativeMethods.MyWebGetNumInstalledApplications();
            if (iNumApps < 1)
                return null;

            apps = new MyWebApplication[iNumApps];
            for (iter=0; iter<iNumApps; iter++)
                apps[iter] = new MyWebApplication(iter);

            Array.Sort(apps, InvariantComparer.Default);
            return apps;
        }

        //////////////////////////////////////////////////////////////////////
        // Get an application from an URL whithin it
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWeb.GetApplication"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        ///    <para>Returns a MyWebApplication object for the given MyWeb Uri. If the application
        ///       for that Uri does not exist, it returns <see langword='null'/>.</para>
        /// </devdoc>
        static public MyWebApplication GetApplication(String strUrl) {
            if (!RunningOnMyWeb || !IsAdminApp())
                return null;

            int iIndex = NativeMethods.MyWebGetApplicationIndexForUrl(strUrl);
            if (iIndex >= 0)
                return new MyWebApplication(iIndex);
            else
                return null;
        }


        //////////////////////////////////////////////////////////////////////
        // Get a Manifest for an URL
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWeb.GetManifest"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        ///    <para>Retrieves a MyWebManifest object for the given MyWeb Uri. If an application
        ///       for that Uri does not exist, it returns <see langword='null'/>.</para>
        /// </devdoc>
        static public MyWebManifest GetManifest(String strUrl) {
            if (!RunningOnMyWeb || !IsAdminApp())
                return null;
            StringBuilder    strBFile    = new StringBuilder(300);
            StringBuilder    strBAppUrl  = new StringBuilder(strUrl.Length + 2);
            int              iRet        = 0;

            while (strUrl != null && strUrl.Length > 0) {
                Debug.Trace("myweb", "Attempting to get manifest for url " + strUrl);
                iRet = NativeMethods.MyWebGetApplicationManifestFile(strUrl, strBFile, 300, strBAppUrl, strUrl.Length + 2);            
                if (iRet != 0) {
                    Debug.Trace("myweb", "faled to get manifest for url " + strUrl);
                    return null;
                }

                try {
                    MyWebManifest manifest = MyWebManifest.CreateFromFile(strBFile.ToString(), strBAppUrl.ToString(), false, false);
                    if (manifest != null)
                        return manifest;
                }
                catch (Exception) {
                }
                Debug.Trace("myweb", "no softpkg in url " + strUrl);
                int iPos = strUrl.LastIndexOf('/');
                if (iPos < 0)
                    strUrl = null;
                else
                    strUrl = strUrl.Substring(0, iPos);
            }
            return null;
        }

        //////////////////////////////////////////////////////////////////////
        // Install a local application
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWeb.InstallLocalApplication"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        static public MyWebApplication InstallLocalApplication(String strAppUrl, String strDir) {
            if (!RunningOnMyWeb || !IsAdminApp())
                return null;

            if (strAppUrl[strAppUrl.Length - 1] == '/')
                strAppUrl = strAppUrl.Substring(0, strAppUrl.Length-1);

            if (strAppUrl.LastIndexOf("://") >= 0) {
                int iPos = strAppUrl.LastIndexOf("://");
                iPos += 3;
                strAppUrl = strAppUrl.Substring(iPos, strAppUrl.Length - iPos);
            }

            int iRet = NativeMethods.MyWebInstallLocalApplication(strAppUrl, strDir);

            if (iRet != 0)
                return GetApplication(strAppUrl);
            else
                return null;
        }
        //////////////////////////////////////////////////////////////////////
        // Get a Manifest from a dir
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWeb.GetManifestForLocalApplication"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        static public MyWebManifest GetManifestForLocalApplication(String strDir) {
            if (!RunningOnMyWeb || !IsAdminApp())
                return null;
            if (!strDir.EndsWith("\\"))
                strDir += "\\";
            return MyWebManifest.CreateFromFile(strDir + "myweb.osd", 
                                                "", false, true);
        }
        ///////////////////////////////////////////////////////////////////// 
        ///////////////////////////////////////////////////////////////////// 
        /////////////////////////////////////////////////////////////////////
        // Private stuff
        static internal bool IsAdminApp() {
            HttpContext context = HttpContext.Current;
            String strUrl = context.Request.Url.ToString().ToLower(CultureInfo.InvariantCulture);
            Debug.Trace("myweb", "isadminapp url " + strUrl);
            bool fReturn = 
            ((context.WorkerRequest is System.Web.Hosting.IEWorkerRequest) &&
             strUrl.StartsWith("myweb://home/"));

            Debug.Trace("myweb", "fReturn " + fReturn.ToString());
            return fReturn;
        }

        static private bool  _RunningOnMyWebChecked;
        static private bool  _RunningOnMyWeb;
    }

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

    /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebApplication"]/*' />
    /// <devdoc>
    ///    <para>Marked internal for Beta 1 per ErikOls.</para>
    /// </devdoc>
    public sealed class MyWebApplication : IComparable {
        ////////////////////////////////////////////////////////////////////////
        // Public properties
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebApplication.Manifest"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  MyWebManifest Manifest { get { return _Manifest;}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebApplication.InstalledDate"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  DateTime      InstalledDate { get { return _InstalledDate;}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebApplication.LastAccessDate"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  DateTime      LastAccessDate { get { return _LastAccessDate;}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebApplication.LocalApplication"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  bool          LocalApplication { get { return _LocalApplication;}}

        ////////////////////////////////////////////////////////////////////////
        // Public methods
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebApplication.Remove"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public int Remove() {
            return Manifest.Remove();
        }

        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebApplication.Move"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public int Move(String strDestinationDir) {
            return Manifest.Move(strDestinationDir);
        }

        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebApplication.Update"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public int Update() {
            if (!MyWeb.IsAdminApp())
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Operation_requires_url_to_be_myweb_home));

            MyWebManifest manifest = MyWeb.GetManifest(Manifest.ApplicationUrl);

            if (manifest == null)
                return 0;

            StringBuilder strError = new StringBuilder(1024);
            int iReturn = 0;
            iReturn = NativeMethods.MyWebReInstallApp(manifest.CabFile, 
                                           manifest.ApplicationUrl, 
                                           manifest.InstalledLocation, 
                                           manifest.ManifestFile,
                                           strError,
                                           1024);

            if (iReturn != 0 && iReturn != 1) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Literal, strError.ToString()));
            }

            _Manifest = manifest;
            return iReturn;
        }

        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebApplication.CompareTo"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public int  CompareTo(Object obj)
        {
            if (obj == null)
                return 1;

            if (!(obj is MyWebApplication))
                throw new ArgumentException();
            
            MyWebApplication myWebApp = (MyWebApplication) obj;
            String strThis  = (Manifest.Name.Length < 1 ? Manifest.ApplicationUrl : Manifest.Name);
            String strOther = (myWebApp.Manifest.Name.Length < 1 ? myWebApp.Manifest.ApplicationUrl : myWebApp.Manifest.Name);
            
            return String.Compare(strThis, strOther, false, CultureInfo.InvariantCulture);
        }
 
        ////////////////////////////////////////////////////////////////////////
        // CTor: Create from an installed app
        internal MyWebApplication(int iIndex) {
            if (!MyWeb.IsAdminApp())
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Operation_requires_url_to_be_myweb_home));

            StringBuilder  strBFile = new StringBuilder(300);
            StringBuilder  strBUrl  = new StringBuilder(1024);
            long []        pLongs   = new long[3];

            if (NativeMethods.MyWebGetApplicationDetails(iIndex, strBFile, 300, strBUrl, 1024, pLongs) != 0)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Unable_to_create_app_object));

            _Manifest = MyWebManifest.CreateFromFile(strBFile.ToString() + "\\myweb.osd", strBUrl.ToString(), true, true);
            _InstalledDate  = DateTime.FromFileTime(pLongs[0]);
            _LastAccessDate = DateTime.FromFileTime(pLongs[1]);
            _LocalApplication = (pLongs[2] != 0);
        }


        ////////////////////////////////////////////////////////////////////////
        // CTor: Create from a manifest that just got installed 
        internal MyWebApplication(MyWebManifest manifest) {
            _Manifest       = manifest;
            _InstalledDate  = DateTime.Now;
            _LastAccessDate = DateTime.Now;
        }

        private  MyWebManifest _Manifest;
        private  DateTime      _InstalledDate;
        private  DateTime      _LastAccessDate;
        private  bool          _LocalApplication;
    }

    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    
    /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest"]/*' />
    /// <devdoc>
    ///    <para>Marked internal for Beta 1 per ErikOls.</para>
    /// </devdoc>
    public sealed class MyWebManifest {
        //////////////////////////////////////////////////////////////////////
        // Properties
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.Name"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String      Name { get { return _Properties[_Name];}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.Version"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String      Version { get { return _Properties[_Version];}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.ManifestFile"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String      ManifestFile { get { return _Properties[_ManifestFile];}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.Title"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String      Title { get { return _Properties[_Title];}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.CabFile"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String      CabFile { get { return _Properties[_CabFile];}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.License"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String      License { get { return _Properties[_License];}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.InstalledLocation"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String      InstalledLocation { get { return _Properties[_InstalledLocation];}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.Abstract"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String      Abstract { get { return _Properties[_Abstract];}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.Size"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String      Size { get { return _Properties[_Size];}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.Url"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String      Url { get { return _Properties[_Url];}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.ApplicationUrl"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String      ApplicationUrl { get { return _Properties[_ApplicationUrl];}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.Installed"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  bool        Installed { get { return _Installed;}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.CustomUrls"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String []   CustomUrls { get { return _CustomUrls;}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.Author"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String      Author { get { return _Properties[_Author];}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.CustomUrlDescriptions"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String []   CustomUrlDescriptions { get { return _CustomUrlDs;}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.HelpUrl"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String      HelpUrl { get { return _Properties[_HelpUrl];}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.IconUrl"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String      IconUrl { get { return _Properties[_IconUrl];}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.RemoteIconUrl"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String      RemoteIconUrl { get { return _Properties[_RemoteIconUrl];}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.RemoteHelpUrl"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String      RemoteHelpUrl { get { return _Properties[_RemoteHelpUrl];}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.Source"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String      Source { get { return _Properties[_Source];}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.OnInstallUrl"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String      OnInstallUrl { get { return _Properties[_OnInstallUrl];}}
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.OnUpdateUrl"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public  String      OnUpdateUrl { get { return _Properties[_OnUpdateUrl];}}

        //////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////
        // Methods

        //////////////////////////////////////////////////////////////////////
        // Install an application
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.Install"]/*' />
        /// <devdoc>
        /// </devdoc>
        public MyWebApplication Install() {
            return Install(null);
        }  

        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.Install1"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public MyWebApplication Install(String strLocation) {
            if (Installed)
                return null;

            if (!MyWeb.IsAdminApp())
                return null;

            if (strLocation != null)
                _Properties[_InstalledLocation] = strLocation;

            StringBuilder strError = new StringBuilder(1024);

            if (NativeMethods.MyWebInstallApp(CabFile, 
                                   ApplicationUrl, 
                                   InstalledLocation, 
                                   ManifestFile,
                                   strError,
                                   1024) != 0) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Literal, strError.ToString()));
                //return null;
            }
            else {
                _Installed = true;
                return new MyWebApplication(this);
            }
        }  

        //////////////////////////////////////////////////////////////////////
        // Remove an app
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.Remove"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public int Remove() {
            int iReturn = 0;
            if (MyWeb.IsAdminApp()) {
                iReturn = NativeMethods.MyWebRemoveApp(ApplicationUrl);
                _Installed = false;
            }
            return iReturn;
        }

        //////////////////////////////////////////////////////////////////////
        // Move an app
        /// <include file='doc\MyWeb.uex' path='docs/doc[@for="MyWebManifest.Move"]/*' />
        /// <devdoc>
        ///    <para>Marked internal for Beta 1 per ErikOls.</para>
        /// </devdoc>
        public int Move(String strNewLocation) {

            if (!MyWeb.IsAdminApp())
                return 0;

            int iReturn = 0;
            StringBuilder strError = new StringBuilder(1024);
            iReturn = NativeMethods.MyWebMoveApp(ApplicationUrl, 
                                      strNewLocation,
                                      strError,
                                      1024);
            if (iReturn != 0 && iReturn != 1) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Literal, strError.ToString()));
            }

            _Properties[_InstalledLocation] = strNewLocation;
            return iReturn;
        }


        //////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////
        // Private stuff

        //////////////////////////////////////////////////////////////////////
        // Create a manifest from a manifest file
        static internal MyWebManifest CreateFromFile(
                                                    String        strFile, 
                                                    String        strUrl, 
                                                    bool          installed,
                                                    bool          donotfail) {
            String []          strProperties = null;
            ConfigXmlDocument    xmlDoc        = null;
            ConfigXmlCursor      cursor        = null;
            int                iter          = 0;
            int                iRet          = 0;
            StringBuilder      strBuf        = new StringBuilder(1024);
            bool               fFound        = false;
            ArrayList          customUrls    = new ArrayList();
            ArrayList          customUrlDs   = new ArrayList();
            String             strRandom     = System.Web.SessionState.SessionId.Create();

            ////////////////////////////////////////////////////////////
            // Step 1: Parse the file and get the other properties        
            try {
                xmlDoc = new ConfigXmlDocument();
                xmlDoc.Load(strFile);
                cursor = xmlDoc.GetCursor();
                cursor.MoveToFirstChild();
            }
            catch (Exception e) {
                if (!donotfail)
                    throw e;
                cursor = null;
            }

            if (cursor != null) {
                do {
                    if (cursor.Type == ConfigXmlElement.Element && cursor.Name.ToLower(CultureInfo.InvariantCulture).Equals("softpkg")) {
                        fFound = true;
                        break;
                    }
                } 
                while ( cursor.MoveNext() );
            }

            if (!fFound && !donotfail)
                return null;

            ////////////////////////////////////////////////////////////
            // Step 2: Get the non-manifest file properties
            strProperties = new String[NUM_PROPERTIES];
            for (iter=0; iter<NUM_PROPERTIES; iter++)
                strProperties[iter] = String.Empty;

            strProperties[_ApplicationUrl] = strUrl.Replace('\\', '/');            
            strProperties[_ManifestFile] = strFile;            

            if (!installed) {
                iRet = NativeMethods.MyWebGetInstallLocationForUrl(MyWeb.GetDefaultInstallLocation(), 
                                                        strUrl, strRandom, strBuf, 1024);

                if (iRet < 0) {
                    iRet = -iRet + 100;
                    strBuf = new StringBuilder(iRet);
                    iRet = NativeMethods.MyWebGetInstallLocationForUrl(MyWeb.GetDefaultInstallLocation(), 
                                                            strUrl, strRandom, strBuf, iRet);            
                }
                if (iRet <= 0)
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Unable_to_get_app_location));

                strProperties[_InstalledLocation] = strBuf.ToString();
            }
            else {
                strProperties[_InstalledLocation] = strFile.Substring(0, strFile.LastIndexOf('\\'));
            }


            if (cursor == null && donotfail)
                return new MyWebManifest(strProperties, installed, new String[0], new String[0]);

            strProperties[_Name]      = cursor.AttributeText("name");
            strProperties[_Version]   = cursor.AttributeText("version");
            cursor.MoveToFirstChild();
            do {
                if (cursor.Type == ConfigXmlElement.Element) {
                    String strName = cursor.Name.ToLower(CultureInfo.InvariantCulture);

                    if (strName.Equals("implementation")) {
                        strProperties[_CabFile] = GetCabFileNameFromCursor(cursor);
                    }
                    else if (strName.Equals("license")) {
                        strProperties[_License] = cursor.AttributeText("href");
                    }
                    else if (strName.Equals("customurl")) {
                        String strC = cursor.AttributeText("href");
                        String strD = cursor.AttributeText("description");
                        customUrls.Add(strC);
                        customUrlDs.Add(strD);                    
                    }
                    else
                        for (iter=0; iter<_OtherProperties.Length; iter++)
                            if (strName.Equals(_OtherProperties[iter])) {
                                strProperties[OTHER_PROP_START + iter] = GetCursorText(cursor);
                                break;
                            }
                }
            }
            while (cursor.MoveNext());                

            return new MyWebManifest(strProperties, installed, customUrls.ToArray(), customUrlDs.ToArray());
        }


        private static String GetCabFileNameFromCursor(ConfigXmlCursor cursor) {
            String strReturn = String.Empty;

            if (cursor.MoveToFirstChild()) {
                do
                    if (cursor.Type == ConfigXmlElement.Element && cursor.Name.ToLower(CultureInfo.InvariantCulture).Equals("codebase")) {
                        strReturn = cursor.AttributeText("href");
                        break;
                    }
                while (cursor.MoveNext());
                cursor.MoveToParent();
            }

            return strReturn;
        }

        //////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////
        // Private stuff
        private String []  _Properties;
        private String []  _CustomUrls;
        private String []  _CustomUrlDs;
        private bool       _Installed;

        // Constants...
        private static readonly char [] CHAR_TAB              = {'\t'};
        private static readonly char [] CHAR_COMMA            = {','};
        private static readonly int     _Name                 = 0;
        private static readonly int     _Version              = 1;
        private static readonly int     _ManifestFile         = 2;
        private static readonly int     _CabFile              = 3;
        private static readonly int     _License              = 4;
        private static readonly int     _InstalledLocation    = 5;
        private static readonly int     _ApplicationUrl       = 6;

        private static readonly int     OTHER_PROP_START      = 7;
        private static readonly int     _Title                = OTHER_PROP_START + 0;
        private static readonly int     _Abstract             = OTHER_PROP_START + 1;
        private static readonly int     _Size                 = OTHER_PROP_START + 2;
        private static readonly int     _Author               = OTHER_PROP_START + 3;
        private static readonly int     _Source               = OTHER_PROP_START + 4;
        private static readonly int     _HelpUrl              = OTHER_PROP_START + 5;
        private static readonly int     _IconUrl              = OTHER_PROP_START + 6;
        private static readonly int     _RemoteIconUrl        = OTHER_PROP_START + 7;
        private static readonly int     _RemoteHelpUrl        = OTHER_PROP_START + 8;
        private static readonly int     _OnInstallUrl         = OTHER_PROP_START + 9;
        private static readonly int     _OnUpdateUrl          = OTHER_PROP_START + 10;    
        private static readonly int     _Url                  = OTHER_PROP_START + 11;

        private static readonly int     NUM_PROPERTIES        = OTHER_PROP_START + 12;

        private static readonly String [/*NUM_PROPERTIES - OTHER_PROP_START*/] _OtherProperties = {
            "title",
            "abstract",
            "size",
            "author",
            "source",
            "helpurl",
            "iconurl",
            "remoteiconurl",
            "remotehelpurl",
            "oninstallurl",
            "onupdateurl",
            "homepage",
        };



        //////////////////////////////////////////////////////////////////////
        // Private CTor
        private MyWebManifest(String [] strProperties, bool installed, Object [] customUrls, Object [] customUrlDs) 
        {
            _Installed = installed;     

            _CustomUrls  = new String[customUrls.Length];
            _CustomUrlDs = new String[customUrlDs.Length];
            for (int iter=0; iter<customUrls.Length; iter++)
                _CustomUrls[iter] = (String) customUrls[iter];

            for (int iter=0; iter<customUrlDs.Length; iter++)
                _CustomUrlDs[iter] = (String) customUrlDs[iter];

            _Properties = new String[NUM_PROPERTIES];
            for (int iter=0; iter<NUM_PROPERTIES; iter++) {
                if (strProperties[iter] != null && strProperties[iter].Length > 0)
                    _Properties[iter] = String.Copy(strProperties[iter]);

                if (_Properties[iter] == null)
                    _Properties[iter] = String.Empty;
            }

            if (_Properties[_IconUrl] != null && _Properties[_IconUrl].Length > 0)
            {
                String strUrl;
                if (_Properties[_IconUrl].IndexOf("://") >= 0)
                {
                    strUrl = _Properties[_IconUrl];
                }
                else
                {
                    if (_Properties[_IconUrl].StartsWith("/"))
                    {
                        strUrl = "myweb:/" + _Properties[_IconUrl];
                    }
                    else
                    {
                        strUrl = "myweb://" + ApplicationUrl + "/" + _Properties[_IconUrl];
                    }
                }

                int iLenTrim = 8 /*Length of "myweb://" */ + ApplicationUrl.Length;
                if (strUrl.Length > iLenTrim)
                {
                    String strDir = InstalledLocation + strUrl.Substring(iLenTrim);
                    _Properties[_IconUrl] = strDir.Replace('/', '\\');
                }
                Debug.Trace("myweb", "Icon url is " + _Properties[_IconUrl]);
                
            }
        }

        private static String GetCursorText(ConfigXmlCursor cursor) 
        {
            String strText = String.Empty;

            if (cursor.MoveToFirstChild()) {
                while (cursor.Type == ConfigXmlElement.Whitespace || cursor.Type == ConfigXmlElement.Text) {
                    strText += cursor.Text; // grab the text
                    if (!cursor.MoveNext())
                        break;
                }
                cursor.MoveToParent();
            }
            return strText.Trim();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\myweb\myweb.h ===
/**
 * MyWeb.h header file
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _MyWeb_H
#define _MyWeb_H

#include "dirmoncompletion.h"

/////////////////////////////////////////////////////////////////////////////
// Const declarations
#define IEWR_URIPATH            0
#define IEWR_QUERYSTRING        1
#define IEWR_VERB               3
#define IEWR_APPPATH            5
#define IEWR_APPPATHTRANSLATED  6
#define SZ_PROTOCOL_NAME        L"myweb"
#define PROTOCOL_NAME_LEN       5
#define SZ_PROTOCOL_PREFIX      SZ_PROTOCOL_NAME L":"
#define SZ_PROTOCOL_SCHEME      SZ_PROTOCOL_NAME L"://"
#define PROTOCOL_SCHEME_LEN     8
#define SZ_MYWEB_MANIFEST_FILE  L"myweb.osd"
#define SZ_REG_MYWEBS_KEY       REGPATH_MACHINE_APP_L L"\\MyWeb"
#define SZ_REG_MYWEBS_APPROOT   L"AppDirectory"
#define SZ_REG_APP_DOMAIN       L"AppDomain"
#define SZ_REG_APP_TRUSTED      L"Trusted"
#define SZ_REG_APP_ACCESS_DATE  L"AppLastAccessDate"
#define SZ_REG_APP_CREATE_DATE  L"AppCreationDate"
#define SZ_REG_APP_IS_LOCAL     L"IsLocalApp"
#define SZ_REG_APP_DEFAULT_PAGE L"DefaultPage"
#define SZ_URL_ADMIN            L"myweb://Home/"
#define SZ_URL_ADMIN_INSTALL    L"?Action=Install&MyWebPage="
#define SZ_URL_ADMIN_AXD        L"myweb.axd"
#define SZ_URL_ADMIN_ASPX_DEFAULT  L"default.aspx"
#define SZ_URL_ADMIN_ASPX_INSTALL  L"install.aspx"
#define SZ_MYWEB_MANIFEST_W_SLASH  L"\\myweb.osd"
#define SZ_MYWEB_TAG               "myweb"
#define SZ_ADMIN_DIR_TAG           "admindir"
#define SZ_INTERNAL_HANDLER        L"internal-handler"
#define SZ_URL_ADMIN_DEF_PAGE      L"myweb://Home/default.aspx"
#define SZ_URL_ADMIN_INSTALL_PAGE  L"myweb://Home/install.aspx?Action=Install&MyWebPage="

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Global Objects
extern  LONG                    g_PtpObjectCount;
extern  CLSID                   CLSID_PTProtocol;
extern  LONG                    g_PtpObjectCount;
extern  BOOL                    g_Started;
extern  IInternetSecurityManager * g_pInternetSecurityManager;

/////////////////////////////////////////////////////////////////////////////
// Imported "IE" functions
extern  BOOL         (WINAPI * g_pInternetSetCookieW  ) (LPCTSTR, LPCTSTR, LPCTSTR);
extern  BOOL         (WINAPI * g_pInternetGetCookieW  ) (LPCTSTR, LPCTSTR, LPTSTR, LPDWORD);
extern  HINTERNET    (WINAPI * g_pInternetOpen        ) (LPCTSTR, DWORD, LPCTSTR, LPCTSTR, DWORD);
extern  void         (WINAPI * g_pInternetCloseHandle ) (HINTERNET);
extern  HINTERNET    (WINAPI * g_pInternetOpenUrl     ) (HINTERNET, LPCTSTR, LPCTSTR, DWORD, DWORD, DWORD_PTR);
extern  BOOL         (WINAPI * g_pInternetReadFile    ) (HINTERNET, LPVOID, DWORD, LPDWORD);

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Clases and interfaces

interface IMyWebPrivateUnknown
{
public:
   STDMETHOD  (PrivateQueryInterface) (REFIID riid, void ** ppv) = 0;
   STDMETHOD_ (ULONG, PrivateAddRef)  () = 0;
   STDMETHOD_ (ULONG, PrivateRelease) () = 0;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class PTProtocol : public IMyWebPrivateUnknown, public IInternetProtocol, public IWinInetHttpInfo
{
public:
    PTProtocol        (IUnknown *pUnkOuter);
    ~PTProtocol       ();

    // IMyWebPrivateUnknown methods
    STDMETHOD_        (ULONG, PrivateAddRef)    ();
    STDMETHOD_        (ULONG, PrivateRelease)   ();
    STDMETHOD         (PrivateQueryInterface)   (REFIID, void **);

    // IUnknown methods
    STDMETHOD_        (ULONG, AddRef)           ();
    STDMETHOD_        (ULONG, Release)          ();
    STDMETHOD         (QueryInterface)          (REFIID, void **);

    // InternetProtocol methods
    STDMETHOD         (Start)                   (LPCWSTR, IInternetProtocolSink *, IInternetBindInfo *, DWORD, DWORD);
    STDMETHOD         (Continue)                (PROTOCOLDATA *pProtData);
    STDMETHOD         (Abort)                   (HRESULT hrReason,DWORD );
    STDMETHOD         (Terminate)               (DWORD );
    STDMETHOD         (Suspend)                 ();
    STDMETHOD         (Resume)                  ();
    STDMETHOD         (Read)                    (void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD         (Seek)                    (LARGE_INTEGER , DWORD , ULARGE_INTEGER *) ;
    STDMETHOD         (LockRequest)             (DWORD );
    STDMETHOD         (UnlockRequest)           ();

  // IWinInetHttpInfo
    STDMETHOD         (QueryInfo)               (DWORD dwOption, LPVOID pBuffer, DWORD *pcbBuf, DWORD *pdwFlags, DWORD *pdwReserved);
    STDMETHOD         (QueryOption)             (DWORD , LPVOID, DWORD *);


  // Public functions called by exported functions
    HRESULT           WriteBytes                (BYTE *buf, DWORD dwLength);
    HRESULT           SendHeaders               (LPSTR buffer);
    HRESULT           SaveCookie                (LPSTR header);
    int               GetString                 (int key, WCHAR *buf, int size);
    int               GetStringLength           (int key);
    int               MapPath                   (WCHAR *virtualPath, WCHAR *physicalPath, int length);
    HRESULT           Finish                    ();
    int               GetKnownRequestHeader     (LPCWSTR szHeader, LPWSTR buf, int size);
    int               GetPostedDataSize         ();
    int               GetPostedData             (BYTE * buf, int iSize);
    

private:
    // Private functions
    HRESULT           ExtractUrlInfo            ();
    HRESULT           GetAppBaseDir             (LPCTSTR base, LPTSTR appRoot);
    WCHAR *           MapString                 (int key);
    void              Cleanup                   ();
    BOOL              CheckIfAdminUrl           ();

    static HRESULT    DealWithBuffer            (LPSTR szHeaders, LPSTR szHeader, 
                                                 DWORD dwOpt, DWORD dwOption, 
                                                 LPVOID pBuffer, LPDWORD pcbBuf);

    static LPWSTR     CreateRequestHeaders      (LPCWSTR szHeaders);

    long                    m_dwRefCount;
    IUnknown *              m_pUnkOuter;
    IInternetProtocolSink * m_pProtocolSink;  
    CRITICAL_SECTION        m_csOutputWriter;
    DWORD                   m_dwOutput;
    IStream *               m_pOutputRead;
    IStream *               m_pOutputWrite;
    BOOL                    m_fStartCalled;
    BOOL                    m_fAbortingRequest;
    BOOL                    m_fDoneWithRequest;
    BOOL                    m_fRedirecting;
    BOOL                    m_fAdminMode;
    DWORD                   m_dwInputDataSize;
    BYTE *                  m_pInputData;
    IStream *               m_pInputRead;
    WCHAR *                 m_strVerb;
    WCHAR *                 m_strCookiePath;    // "myWeb://www.site.com/app/something/else"
    WCHAR *                 m_strUriPath;       // "/app/something/else"
    WCHAR *                 m_strQueryString;   // "?aaa=bbb"
    WCHAR *                 m_strAppOrigin;     // "www.site.com"
    WCHAR *                 m_strAppRoot;       //  "/app"
    WCHAR *                 m_strAppRootTranslated;  // "c:\program files\site myweb app"
    WCHAR *                 m_strRequestHeaders;
    char  *                 m_strRequestHeadersA;
    WCHAR *                 m_strCookie;
    WCHAR *                 m_strRequestHeadersUpr;
    char  *                 m_strResponseHeaderA;
    WCHAR *                 m_strUrl;
    WCHAR                   m_strAppDomain[40];
    BOOL                    m_fTrusted;
    xspmrt::_ISAPIRuntime * m_pManagedRuntime;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class PTProtocolFactory : public IClassFactory, public IInternetProtocolInfo
{
public:
    // IUnknown Methods
    STDMETHOD_    (ULONG, AddRef)    ();
    STDMETHOD_    (ULONG, Release)   ();
    STDMETHOD     (QueryInterface)   (REFIID, void **);

    // IClassFactory Moethods
    STDMETHOD     (LockServer)       (BOOL);
    STDMETHOD     (CreateInstance)   (IUnknown*,REFIID,void**);

    // IInternetProtocolInfo Methods
    STDMETHOD     (CombineUrl)       (LPCWSTR,LPCWSTR,DWORD,LPWSTR,DWORD,DWORD *,DWORD);
    STDMETHOD     (CompareUrl)       (LPCWSTR, LPCWSTR, DWORD);
    STDMETHOD     (ParseUrl)         (LPCWSTR, PARSEACTION, DWORD, LPWSTR, DWORD, DWORD *, DWORD);
    STDMETHOD     (QueryInfo)        (LPCWSTR, QUERYOPTION, DWORD, LPVOID, DWORD, DWORD *, DWORD);
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Static function to support My Web admin UI 
class CMyWebAdmin : public DirMonCompletion
{
public:
    static void    Initialize                 ();

    static void    Close                      ();

    static LPWSTR  GetAdminDir                ();    

    static int     GetNumInstalledApplications();

    static int     GetApplicationIndexForUrl  (LPCWSTR     szUrlConst );

    static HRESULT GetApplicationManifestFile (LPCWSTR     szUrl, 
                                               LPWSTR      szFileBuf,
                                               int         iFileBufSize,
                                               LPWSTR      szUrlBuf,
                                               int         iUrlBufSize);

    static HRESULT GetApplicationDetails      (int         iIndex,
                                               LPWSTR      szDir,
                                               int         iDirSize,
                                               LPWSTR      szUrl,
                                               int         iUrlSize,        
                                               __int64 *   pDates);

    static HRESULT InstallApp                 (LPCWSTR     szCabFile,
                                               LPCWSTR     szUrl,
                                               LPCWSTR     szAppDir,
                                               LPCWSTR     szAppManifest,
                                               LPWSTR      szError,
                                               int         iErrorSize  );


    static HRESULT ReInstallApp               (LPCWSTR     szCabFile,
                                               LPCWSTR     szUrl,
                                               LPCWSTR     szAppDir,
                                               LPCWSTR     szAppManifest,
                                               LPWSTR      szError,
                                               int         iErrorSize  );

    static HRESULT RemoveApp                  (LPCWSTR     szAppUrl);

    static HRESULT MoveApp                    (LPCWSTR     szAppUrl, 
                                               LPCWSTR     szNewLocation,
                                               LPWSTR      szError,
                                               int         iErrorSize );

    static int     GetInstallLocationForUrl   (LPCWSTR     szConfigValue, 
                                               LPCWSTR     szAppUrl,
                                               LPCWSTR     szRandom,
                                               LPWSTR      szBuf,
                                               int         iBufSize);

    static HRESULT GetAppSettings             (LPCTSTR     base, 
                                               LPTSTR      appRoot,
                                               LPTSTR      appDomain,
                                               LPBOOL      pfTrusted);

    static HRESULT InstallLocalApplication    (LPCWSTR     appUrl, 
                                               LPCWSTR     appDir);

private:
    static HRESULT CopyFileOverInternet       (LPCWSTR     szUrl,
                                               LPCWSTR     szFile);
    static HRESULT MakeDirectoriesForPath     (LPCWSTR     szPath);


    static HRESULT InstallInternetFiles       (LPCWSTR     szCabFile, 
                                               LPCWSTR     szUrl, 
                                               LPCWSTR     szPath);

    static HRESULT CopyManifestFile           (LPCWSTR     szAppDir,
                                               LPCWSTR     szManifestFile);

    static HRESULT CreateRegistryForApp       (LPCWSTR     szUrl, 
                                               LPCWSTR     szPhyPath,
                                               BOOL        fIsLocal);

    static HKEY    GetAppKey                  (int         iIndex, 
                                               WCHAR *     szKey);    

    static  void   ParseConfigForAdminDir     ();

    virtual HRESULT CallCallback              (int         action = 0, 
                                               WCHAR *     pFilename = NULL);   

    static  DWORD  GetNextWord                (char *      strWord, 
                                               char *      buf, 
                                               DWORD       dwBufSize);
    static  void   NormalizeAdminDir          ();

    static  void   FillErrorString            (HRESULT     hr, 
                                               LPCWSTR     szConstError, 
                                               LPWSTR      szErrorBuf, 
                                               int         iErrorBufSize);

    static  BOOL   DeleteDirectory            (LPCWSTR     szDir);
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Gloabal functions
void
TerminatePTProtocol();

HRESULT 
GetPTProtocolClassObject(REFIID iid, void **ppv);

HRESULT 
InitializePTProtocol();

UINT WINAPI
CabFileHandler( LPVOID context, 
                UINT notification,
                UINT_PTR param1,
                UINT_PTR param2 );

LPWSTR
DuplicateString ( LPCWSTR szString);

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


extern  PTProtocolFactory  g_PTProtocolFactory;


#define SZ_ERROR_STRING                       " <html> <head> <style> H1 \
{ font-family:\"Arial, Helvetica, Geneva, SunSans-Regular, sans-serif\";\
font-weight:bold;font-size:26pt;color:red } H2 { font-family:\"Arial, Helvetica, \
Geneva, SunSans-Regular, sans-serif\";font-weight:bold;font-size:18pt;color:black \
} </style> <title>Fatal Error</title> </head> <body bgcolor=\"white\"> <table \
width=100%> <span> <H1>" PRODUCT_NAME " Error<hr width=100%></H1> <h2> <i>Fatal Error</i> </h2> \
</span> <font face=\"Arial, Helvetica, Geneva, SunSans-Regular, sans-serif\"> <b> \
Description: </b> A fatal error has occurred during the execution of the current \
web request. &nbsp; Unfortunately no stack trace or additional error information \
is available for display. &nbsp;Common sources of these types of fatal \
errors include: <ul> <li>Setup Configuration Problems</li> <li>Access \
Violations (AVs) </li> <li>Failures in Unmanaged (Interop) Code</li> </ul> \
Consider attaching a debugger to learn more about the specific failure. \
<br><br> <hr width=100%> </font> </table> </body></html> "

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\myweb\myweb4.cs ===
//------------------------------------------------------------------------------
// <copyright file="myweb4.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   myweb4.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace  System.Web.MyWebAdminUI {

  using System;
  using System.IO; 
  using System.Collections;
  using System.Web;
  using System.Web.Util;
  using System.Web.UI;
  using System.Web.UI.WebControls;
  using System.Web.UI.HtmlControls;

  /// <include file='doc\myweb4.uex' path='docs/doc[@for="myweb4Page"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  public class myweb4Page : Page {

    /// <include file='doc\myweb4.uex' path='docs/doc[@for="myweb4Page.successLabel"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected Label successLabel;
    /// <include file='doc\myweb4.uex' path='docs/doc[@for="myweb4Page.noSuccessLabel"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected Label noSuccessLabel;
    /// <include file='doc\myweb4.uex' path='docs/doc[@for="myweb4Page.UpdatedList"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected DataList UpdatedList;
    /// <include file='doc\myweb4.uex' path='docs/doc[@for="myweb4Page.NotUpdatedList"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected DataList NotUpdatedList;

  
    /// <include file='doc\myweb4.uex' path='docs/doc[@for="myweb4Page.Page_Load"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public void Page_Load(Object sender, EventArgs e) 
    {
      String sync = Request.QueryString["sync"];

      if (sync == "no")
      {
        successLabel.Text ="No applications were selected for update.";
      }

      ArrayList appsUpdated = (ArrayList)Application["appsUpdated"];

      if (appsUpdated.Count >0)
      {
        successLabel.Text ="The following applications were updated successfully:<br><br>";
      }

      ArrayList appsNotUpdated = (ArrayList)Application["appsNotUpdated"];

      if (appsNotUpdated.Count > 0)
      {
        noSuccessLabel.Text ="<br><br>The following applications could not be updated:<br><br>";
      }

      if (appsUpdated.Count ==0 && appsNotUpdated.Count ==0)
      {
        successLabel.Text = "No applications have been selected for update.";
      }
 
      UpdatedList.DataSource = appsUpdated;
 
      UpdatedList.DataBind();
 
      NotUpdatedList.DataSource = appsNotUpdated;
      NotUpdatedList.DataBind();

 
    }


  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\myweb\myweb3.cs ===
//------------------------------------------------------------------------------
// <copyright file="myweb3.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   myweb3.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace  System.Web.MyWebAdminUI {

  using System;
  using System.IO; 
  using System.Collections;
  using System.Web;
  using System.Web.Util;
  using System.Web.UI;
  using System.Web.UI.WebControls;
  using System.Web.UI.HtmlControls;

  /// <include file='doc\myweb3.uex' path='docs/doc[@for="myweb3Page"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  public class myweb3Page : Page {

    /// <include file='doc\myweb3.uex' path='docs/doc[@for="myweb3Page.RemoveLabel"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected Label RemoveLabel;

    /// <include file='doc\myweb3.uex' path='docs/doc[@for="myweb3Page.Page_Load"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public void Page_Load(Object sender, EventArgs e) 
    {
      String temp = Request.QueryString["remove"];
      String installedLocation = Request.QueryString["installedLocation"];
      String name = Request.QueryString["name"];
  
      if (temp == "0")
      {
        RemoveLabel.Text = "The application <b>"+ name + "</b> was removed successfully.";
      }
      else if (temp == "1")
      {
        RemoveLabel.Text = "The application <b>"+ name + "</b> has been successfully deactivated.<br>However some of the files may need to be removed manually from the following location:<p><center><b>"+installedLocation+"</b></center></p>";
      }
      else
      {
        RemoveLabel.Text = "The application <b>"+ name + "</b> has been successfully deactivated.<br>However some of the files may need to be removed manually from the following location:<center><b>"+installedLocation+"</b></center>";
      }

    }

  }
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\myweb\myweb1.cs ===
//------------------------------------------------------------------------------
// <copyright file="myweb1.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   myweb1.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace  System.Web.MyWebAdminUI {

  using System;
  using System.IO; 
  using System.Collections;
  using System.Web;
  using System.Web.Util;
  using System.Web.UI;
  using System.Web.UI.WebControls;
  using System.Web.UI.HtmlControls;

  /// <include file='doc\myweb1.uex' path='docs/doc[@for="myweb1Page"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  public class myweb1Page : Page {


    /// <include file='doc\myweb1.uex' path='docs/doc[@for="myweb1Page.local"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public String local;
    /// <include file='doc\myweb1.uex' path='docs/doc[@for="myweb1Page.appurl"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public String appurl;
    /// <include file='doc\myweb1.uex' path='docs/doc[@for="myweb1Page.success"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public String success;

    /// <include file='doc\myweb1.uex' path='docs/doc[@for="myweb1Page.InstallLabel"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected Label InstallLabel;
    /// <include file='doc\myweb1.uex' path='docs/doc[@for="myweb1Page.CustomLabel"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected Label CustomLabel;
		
    /// <include file='doc\myweb1.uex' path='docs/doc[@for="myweb1Page.Page_Load"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public void Page_Load(Object sender, EventArgs e) 
    {
      success = Request["success"];
	    local=Request["Local"];
	    appurl = Request["URL"];
	
	    if (success=="notfound")
	    {
		    InstallLabel.Text="The application could not be installed.  Files cannot be found.";
	    }		
	    else if (success=="no")
	    {
		    InstallLabel.Text="The application could not be installed.";
	    }
	    else if (success =="yes")
	    {
		    InstallLabel.Text="The application was successfully installed. <br>The URL alias for your application is: <br><br>";

		   /* if (local =="true" && !appurl.StartsWith("myweb://") )
        {
			    CustomLabel.Text = "myweb://" +appurl;
		    }
        else 
        {
          CustomLabel.Text = appurl;
        }*/

        CustomLabel.Text = add_ProtSchem(appurl);
	
	    }
	    else if (success =="specialChar" )
	    {
        String SpecChar = Request["SpecChar"];
        String Path = Request["Path"];

        InstallLabel.Text= "The application found at <br><b>(" + Path + ")</b><br> cannot be installed.<br> One of its files contains one or more illegal characters.";

	    }
           
    }

    /// <include file='doc\myweb1.uex' path='docs/doc[@for="myweb1Page.Launch_Application"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public void Launch_Application(Object sender, EventArgs e)
    {
      MyWebApplication app = MyWeb.GetApplication(appurl);

      if (app ==null)
	    {
		    Response.Redirect("myweb://Home/myweb1.aspx?success=notfound");
	    }
      else 
	    {
	      String LaunchURL = (app.Manifest.Url.Length >0)?(add_ProtSchem(appurl) + add_RelUrl(appurl, app.Manifest.Url)):(add_ProtSchem(appurl) + "/default.aspx" );
		    Response.Redirect(LaunchURL);
  	  }
    }


    /// <include file='doc\myweb1.uex' path='docs/doc[@for="myweb1Page.addSlash"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public String addSlash(String url)
    {
 
      if(!url.StartsWith("/"))
      {
        url = "/" + url;
      }
  
      return url;
    } 


    /// <include file='doc\myweb1.uex' path='docs/doc[@for="myweb1Page.add_ProtSchem"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public String add_ProtSchem(String app_url)
    {
    
	    if(!app_url.StartsWith("myweb://"))
	    {
		    app_url = "myweb://" + app_url;
	    }

	    return app_url;
    }


    /// <include file='doc\myweb1.uex' path='docs/doc[@for="myweb1Page.add_RelUrl"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public String add_RelUrl(String app_url, String rel_url)
    {
      if(!app_url.EndsWith(".aspx"))
      {
        return addSlash(rel_url);
      }

      else
      {  return "";
      }

    }
      
    
    





  



  }
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\myweb\myweb2.cs ===
//------------------------------------------------------------------------------
// <copyright file="myweb2.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   myweb2.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace  System.Web.MyWebAdminUI {

  using System;
  using System.IO; 
  using System.Collections;
  using System.Web;
  using System.Web.Util;
  using System.Web.UI;
  using System.Web.UI.WebControls;
  using System.Web.UI.HtmlControls;

  /// <include file='doc\myweb2.uex' path='docs/doc[@for="myweb2Page"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  public class myweb2Page : Page {

    
    /// <include file='doc\myweb2.uex' path='docs/doc[@for="myweb2Page.success"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public String success;
    /// <include file='doc\myweb2.uex' path='docs/doc[@for="myweb2Page.appurl"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public String appurl;
    /// <include file='doc\myweb2.uex' path='docs/doc[@for="myweb2Page.UpdateLabel"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected Label UpdateLabel;

    /// <include file='doc\myweb2.uex' path='docs/doc[@for="myweb2Page.Page_Load"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public void Page_Load(Object sender, EventArgs e) 
    {
      appurl = Request["URL"];   
	    success = Request["success"];
	    String installedLocation = Request["installedLocation"];
      String name = Request["name"];
  
	    if (success =="local")
	    {
		    UpdateLabel.Text = "This application <b>"+ name +"</b> is local.  Local applications cannot be updated.";
	    }
	    else if (success == "notfound")
	    {
		    UpdateLabel.Text = "The application <b>"+ name + "</b> could be found.<br>Files do not exist or server is down.";
	    }
	    else if (success == "0")
	    {
        UpdateLabel.Text = "The application <b>"+ name + "</b> was updated successfully.";
      }
      else if (success == "1")
	    {
        UpdateLabel.Text = "The application <b>"+ name + "</b> was updated successfully.<br>However, some files from the previous version may have to be removed manually from the following location:<p><center><b>" + installedLocation + "</b></center></p>";
      }
      else if (success =="NoApp" )
      {
        UpdateLabel.Text = "The application <b>"+ name + "</b> to be updated was not found.";
    }
    else 
    {
      UpdateLabel.Text = "The application <b>"+ name + "</b> could not be updated.";
    }
  }


   /// <include file='doc\myweb2.uex' path='docs/doc[@for="myweb2Page.Launch_Application"]/*' />
   /// <devdoc>
   ///    <para>[To be supplied.]</para>
   /// </devdoc>
   public void Launch_Application(Object sender, EventArgs e)
   {
	   MyWebApplication app = MyWeb.GetApplication(appurl);
			
	   String LaunchURL = (app.Manifest.Url.Length >0 )?(add_ProtSchem(appurl) + add_RelUrl(appurl, app.Manifest.Url)): "myweb://" + (appurl + "/default.aspx" );
			
     Response.Redirect(LaunchURL);
   }


   /// <include file='doc\myweb2.uex' path='docs/doc[@for="myweb2Page.addSlash"]/*' />
   /// <devdoc>
   ///    <para>[To be supplied.]</para>
   /// </devdoc>
   public String addSlash(String url)
   {
 
     if(!url.StartsWith("/"))
     {
       url = "/" + url;
     }
  
    return url;
  }

  /// <include file='doc\myweb2.uex' path='docs/doc[@for="myweb2Page.add_ProtSchem"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  public String add_ProtSchem(String app_url)
  {
	  if(!app_url.StartsWith("myweb://"))
	  {
		  app_url = "myweb://" + app_url;
	  }

	  return app_url;
  }


  /// <include file='doc\myweb2.uex' path='docs/doc[@for="myweb2Page.add_RelUrl"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  public String add_RelUrl(String app_url, String rel_url)
    {
      if(!app_url.EndsWith(".aspx"))
      {
        return addSlash(rel_url);
      }

      else
      {  return "";
      }

    }
      


  }
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\myweb\mywebadmin.cxx ===
/**
 * Personal Tier Admin UI Suppport
 *
 * Copyright (C) Microsoft Corporation, 1999
 */

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ndll.h"
#include "appdomains.h"
#include "_isapiruntime.h"
#include "wininet.h"
#include "myweb.h"
#include "setupapi.h"
#include "windows.h"
#include "wchar.h"
#include "dirmoncompletion.h"

#define SZ_END_COMMENT             "-->"
#define SZ_START_COMMENT           "<!--"
#define SZ_START_TAG               "<"
#define SZ_END_TAG                 "/>"
#define SZ_END_TAG_2               "</"

extern g_fRunningMyWeb;

CMyWebAdmin *  g_pMyWebAdmin                  = NULL;
WCHAR          g_szAdminDir   [_MAX_PATH + 4] = L"";
WCHAR          g_szConfigFile [_MAX_PATH + 4] = L"";

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void
AppDomainRestart(char * pAppId);

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
void
CMyWebAdmin::Initialize()
{
    g_pMyWebAdmin = NULL;
    ZeroMemory(g_szConfigFile, sizeof(g_szConfigFile));
    ZeroMemory(g_szAdminDir, sizeof(g_szAdminDir));
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
void
CMyWebAdmin::Close()
{
    if (g_pMyWebAdmin)
        delete g_pMyWebAdmin;
    g_pMyWebAdmin = NULL;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
LPWSTR
CMyWebAdmin::GetAdminDir()
{
    if (g_pMyWebAdmin == NULL)
    {
        g_pMyWebAdmin = new CMyWebAdmin;

        HMODULE hIsapi = GetModuleHandle(ISAPI_MODULE_FULL_NAME_L);
        if(hIsapi != NULL)
        {
            GetModuleFileName(hIsapi, g_szConfigFile, MAX_PATH);
            WCHAR * szSlash = wcsrchr(g_szConfigFile, L'\\');
            if (szSlash != NULL)
            {
                szSlash[1] = NULL;
                g_pMyWebAdmin->Init(g_szConfigFile, FALSE, NULL);

                wcscat(g_szConfigFile, WSZ_WEB_CONFIG_FILE);
                //ParseConfigForAdminDir();
                NormalizeAdminDir();
            }
        } 
    }

    return g_szAdminDir;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
void
CMyWebAdmin::ParseConfigForAdminDir()
{
    BOOL         fRet        = FALSE;
    HANDLE       hFile       = INVALID_HANDLE_VALUE;
    char *       buf         = NULL;
    DWORD        dwBufSize   = 0;
    DWORD        dwRead      = 0;
    BOOL         fInComment  = FALSE;
    BOOL         fTagStart   = FALSE;
    BOOL         fInMyTag    = FALSE;
    DWORD        dwPos       = 0;
    char         strWord[1002];
    char         strWord2[8];
    BOOL         fLastWordWasEqualTo     = FALSE;
    int          iIndex                  = -1;


    hFile = CreateFile(g_szConfigFile,
                        GENERIC_READ,
                        FILE_SHARE_READ, 
                        NULL, 
                        OPEN_EXISTING, 
                        FILE_ATTRIBUTE_NORMAL, 
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        goto Cleanup;
    
    dwBufSize = GetFileSize(hFile, NULL);
    if (dwBufSize == 0)
        goto Cleanup;

    buf = (char *) MemAllocClear(dwBufSize);
    if (buf == NULL)
        goto Cleanup;
    
    if ( ! ReadFile(hFile, buf, dwBufSize, &dwRead, NULL) )
        goto Cleanup;
    
    while(dwPos < dwRead)
    {
        DWORD dwAdvance = GetNextWord(strWord, &buf[dwPos], dwRead - dwPos); 
        int iLen = strlen(strWord);
        if (iLen < 1)
            break;
        
        if (fInComment)
        {
            if (iLen > 3)
            {
                char szLast3[4];
                strcpy(szLast3, &strWord[iLen - 3]);
                strcpy(strWord, szLast3);
            }

            if (strcmp(strWord, SZ_END_COMMENT) == 0)
                fInComment = FALSE;

            dwPos += dwAdvance;
            continue;
        }

        strncpy(strWord2, strWord, 4);
        strWord2[4] = NULL;
        if (strcmp(strWord2, SZ_START_COMMENT) == 0)
        {
            dwPos += 4;
            fInComment = TRUE;
            continue;
        }


        if (fInMyTag)
        {
            if (fLastWordWasEqualTo && iIndex >= 0)
            {
                int iStart = 0;
                if (strWord[iStart] == '"')
                    iStart++;
                int iEnd = strlen(strWord);
                if (strWord[iEnd-1] == '"')
                    iEnd--;
                if (iEnd >= iStart)
                {
                    WCHAR  szDir[_MAX_PATH + 1];
                    ZeroMemory(szDir, sizeof(szDir));
                    ZeroMemory(g_szAdminDir, sizeof(g_szAdminDir));
                    MultiByteToWideChar(CP_ACP, 0, &strWord[iStart], iEnd - iStart, g_szAdminDir, _MAX_PATH);
                }   
                TRACE(L"myweb", g_szAdminDir);
                fRet = TRUE;
                iIndex = -1;
                fLastWordWasEqualTo = FALSE;
                goto Cleanup;
            }
            else
            {
                if (strcmp(strWord, "=") == 0)
                {
                    fLastWordWasEqualTo = TRUE;
                }
                else
                {
                    fLastWordWasEqualTo = FALSE;
                    if (_strcmpi(SZ_ADMIN_DIR_TAG, strWord) == 0)
                        iIndex = 0;
                }
            }
            
            if (_strcmpi(strWord, SZ_END_TAG) == 0 || _strcmpi(strWord, SZ_END_TAG_2) == 0)
            {
                fInMyTag = fLastWordWasEqualTo = FALSE;
                iIndex = -1;
            }
        }

        if (fTagStart && _strcmpi(strWord, SZ_MYWEB_TAG) == 0)
        {
            dwPos += dwAdvance;
            fInMyTag = TRUE;
            continue;
        }

        fTagStart = (strcmp(strWord, SZ_START_TAG) == 0);

        strWord[4] = NULL;
        if (strcmp(strWord, SZ_START_COMMENT) == 0)
        {
            dwAdvance = 4;
            fInComment = TRUE;
        }

        dwPos += dwAdvance;        
    }

 Cleanup:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    if (buf != NULL)
        MemFree(buf);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CMyWebAdmin::CallCallback(
        int      , 
        WCHAR *  pFilename)
{
    if (pFilename == NULL || _wcsicmp(pFilename, WSZ_WEB_CONFIG_FILE) == 0)
    {
        //ParseConfigForAdminDir();
        NormalizeAdminDir();
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Get the number of installed myweb apps
int
CMyWebAdmin::GetNumInstalledApplications()
{
    HRESULT hr                       = S_OK;
    HKEY    hKey                     = NULL;
    HKEY    hKeyApp                  = NULL;
    DWORD   dwRet                    = 0;
    DWORD   dwType                   = 0;
    DWORD   dwSize                   = 0;
    DWORD   dwFile                   = 0;
    int     iter                     = 0;
    WCHAR   szAppKey[_MAX_PATH + 1]  = L"";
    WCHAR   szAppRoot[_MAX_PATH + 1] = L"";


    if(RegOpenKeyEx(HKEY_CURRENT_USER, SZ_REG_MYWEBS_KEY, 0, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
    {
        if (RegCreateKeyEx(HKEY_CURRENT_USER, SZ_REG_MYWEBS_KEY, 0, NULL, 0,
                       KEY_ALL_ACCESS, NULL, &hKey, NULL) != ERROR_SUCCESS)
        {
            EXIT_WITH_LAST_ERROR();
        }        
    }

    RegQueryInfoKey(hKey, NULL, NULL, NULL, &dwRet, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

    for(iter=int(dwRet)-1; iter>=0; iter--)
    {
        dwSize = sizeof(szAppRoot);

        hKeyApp = GetAppKey(iter, szAppKey);
        dwFile = 0;
        if (hKeyApp != NULL && RegQueryValueEx(hKeyApp, SZ_REG_MYWEBS_APPROOT, 
                                               NULL, &dwType, (LPBYTE)szAppRoot, &dwSize) == ERROR_SUCCESS)
        {
            // Check if the app really exists
            dwFile = GetFileAttributes(szAppRoot);
            if (dwFile == (DWORD) -1)
                dwFile = 0;
        }

        if (hKeyApp != NULL)
            RegCloseKey(hKeyApp);
        hKeyApp = NULL;

        if ((dwFile & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            // App doesn't exist
            dwRet--;
            RegDeleteKey(hKey, szAppKey);        
        }
    }

 Cleanup:
    if (hKeyApp != NULL)
        RegCloseKey(hKeyApp);
    RegCloseKey(hKey);

    if (dwRet < 1000000)
      return int(dwRet);
    else
      return 0;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Given an URL, get the app index

int
CMyWebAdmin::GetApplicationIndexForUrl(
        LPCWSTR szUrlConst )
{
    int      iIndex      = -1;
    HRESULT  hr          = S_OK;
    LPWSTR   szUrlCopy   = NULL;
    LPWSTR   szUrl       = NULL;
    LPWSTR   szApp       = NULL;
    HKEY     hKey        = NULL;
    DWORD    dwSize      = 0;
    int      iter        = 0;

    //////////////////////////////////////////////////////////////////////
    // Step 1: Copy the URL and set the start to beyond the protocol (myweb://)
    szUrlCopy = DuplicateString(szUrlConst);
    ON_OOM_EXIT(szUrlCopy);

    szUrl = wcsstr(szUrlCopy, L"://");
    if (szUrl == NULL)
        szUrl = szUrlCopy;
    else
        szUrl = &szUrl[3];
    
    //////////////////////////////////////////////////////////////////////
    // Step 2: Keep truncating to the last '/' and see if that app exists
    while(hKey == NULL && szUrl[0] != NULL)
    {
        hKey = GetAppKey(-1, szUrl);
        if (hKey == NULL)
        { // App not found

            /////////////////////////////
            // Trancate the last '/'
            WCHAR * szLastSlash = wcsrchr(szUrl, L'/');
            if (szLastSlash != NULL)
                szLastSlash[0] = NULL;
            else
                szUrl[0] = NULL;
        }
    }


    /////////////////////////////////////////
    // Not found: exit with failure
    if (hKey == NULL)
        goto Cleanup;

    RegCloseKey(hKey);
    hKey = NULL;
    
    //////////////////////////////////////////////////////////////////////////
    // Step 2: Knowning that the app exists, find the index by enumerating
    //         from the base key

    // Open the base key
    if (RegOpenKeyEx(HKEY_CURRENT_USER, SZ_REG_MYWEBS_KEY, 0, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
    {
        if (RegCreateKeyEx(HKEY_CURRENT_USER, SZ_REG_MYWEBS_KEY, 0, NULL, 0,
                       KEY_ALL_ACCESS, NULL, &hKey, NULL) != ERROR_SUCCESS)
        {
            EXIT_WITH_LAST_ERROR();
        }
    }

    // Alloc mem for the app-name 
    szApp = (WCHAR *) MemAllocClear(1024);
    dwSize = 512;
    ON_OOM_EXIT(szApp);

    // iter over all apps
    for(iter=0; RegEnumKeyEx(hKey, iter, szApp, &dwSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS; iter++)
    {
        if (_wcsicmp(szApp, szUrl) == 0) // Found it?
        {
            iIndex = iter;
            break;
        }
        dwSize = 512;
    }

 Cleanup:
    MemFree(szUrlCopy);
    MemFree(szApp);
    if (hKey != NULL) 
        RegCloseKey(hKey);

    return (hr==S_OK) ? iIndex : hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Given an URL, suck in the manifest file into local disk.
//    Returns: Manifest file name on disk (temp file), and app URL where the
//             Manifest file came from
HRESULT
CMyWebAdmin::GetApplicationManifestFile (
        LPCWSTR     szUrl, 
        LPWSTR      szFileBuf,
        int         iFileBufSize,
        LPWSTR      szUrlBuf,
        int         iUrlBufSize)
{
    if (szUrl == NULL || szFileBuf == NULL || szUrlBuf == NULL || iFileBufSize < _MAX_PATH + 20 || iUrlBufSize < 1)
        return E_INVALIDARG;
    
    WCHAR *    szBuf                       = NULL;
    HRESULT    hr                          = S_OK;
    int        iLen                        = wcslen(szUrl);
    WCHAR      szTempPath[_MAX_PATH + 20]  = L"";
    WCHAR *    szSlash                     = NULL;

    if (iLen < 1)
        return E_INVALIDARG;     

    //////////////////////////////////////////////////////////////////////
    // Step 1: Costruct the temp file name where the manifest will be copied to
    GetTempPath(_MAX_PATH, szTempPath);
    GetTempFileName(szTempPath, L"web", 0, szFileBuf);

    //////////////////////////////////////////////////////////////////////
    // Step 2: Construct the base URL: must be http:// (not myweb://) 
    szBuf = (WCHAR *) MemAllocClear(iLen * sizeof(WCHAR) + 100);
    ON_OOM_EXIT(szBuf);

    szSlash = wcsstr(szUrl, SZ_PROTOCOL_SCHEME /*L"myweb://"*/);
    if (szSlash != NULL) // Is it of the format myweb:// ?
    { // Yes: Replace http:// with myweb://
        wcscpy(szBuf, L"http://");
        wcscat(szBuf, &szSlash[PROTOCOL_SCHEME_LEN]);
    }
    else
    { // No: constrct the http:// url
        szSlash = (WCHAR *) szUrl;
        while(szSlash[0] == L'/' || szSlash[0] == L':')
            szSlash++;
        
        WCHAR * szSlash2 = wcsstr(szUrl, L"http://");
        if (szSlash2 == NULL)
        {
            wcscpy(szBuf, L"http://");
            wcscat(szBuf, szSlash);
        }
        else
        {
            wcscpy(szBuf, szSlash);
        }
    }

    // Make sure it ends with a '/'
    iLen = wcslen(szBuf);
    if (szBuf[iLen-1] != L'/')
        szBuf[iLen] = L'/';

    //////////////////////////////////////////////////////////////////////
    // Step 3: See if the web server has the URL/myweb.osd file: If not,
    //         then truncate at the last '/' and try again
    while(wcslen(szBuf) > 7)
    {
        // Add the myweb.osd
        wcscat(szBuf, SZ_MYWEB_MANIFEST_FILE);

        // See if the web server has this file
        hr = CopyFileOverInternet(szBuf, szFileBuf); 
        if (hr == S_OK) // Yes! Got the file
            break; 

        // File doesn't exists: truncate at the last slash
        szSlash = wcsrchr(szBuf, L'/');
        if (szSlash == NULL)
            break;
        szSlash[0] = NULL; // Last slash truncated
        
        szSlash = wcsrchr(szBuf, L'/');
        if (szSlash == NULL)
            break;        
        szSlash[1] = NULL; // Truncate the app name
    }
           
    ON_ERROR_EXIT(); // Unable to get the file
    

    //////////////////////////////////////////////////////////////////////
    // Step 4: Construct the URL: Returned to the caller. szBuf contains the
    //         URL for the manifest file: truncate at the last '/'
    szSlash = wcsrchr(szBuf, L'/'); 
    if (szSlash == NULL)
        EXIT_WITH_HRESULT(E_FAIL);    
    szSlash[0] = NULL;

    // Copy the url without the http://
    if ((int) wcslen(szBuf) < iUrlBufSize + 7)
        wcscpy(szUrlBuf, &szBuf[7]);
    else
        EXIT_WITH_WIN32_ERROR(ERROR_INSUFFICIENT_BUFFER);

 Cleanup:
    MemFree(szBuf);
    return hr;
}
    
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Given an URL: Copy it to the given file name
HRESULT
CMyWebAdmin::CopyFileOverInternet(
        LPCWSTR  szUrl,
        LPCWSTR  szFile)
{
    HRESULT          hr                  = S_OK;
    HINTERNET        hInternet           = NULL;
    HINTERNET        hTransfer           = NULL;
    HANDLE           hFile               = INVALID_HANDLE_VALUE;
    DWORD            dwRead           = 0;
    DWORD            dwWritten           = 0;
    BYTE             buffer[4096];

    TRACE(L"myweb", (LPWSTR) szUrl);

    //////////////////////////////////////////////////////////////////////
    // Step 1: Open the http connection
    hInternet = g_pInternetOpen(L"MyWeb", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    ON_ZERO_EXIT_WITH_LAST_ERROR(hInternet);

    hTransfer = g_pInternetOpenUrl(hInternet, szUrl, NULL, 0, INTERNET_FLAG_RELOAD, 0);
    ON_ZERO_EXIT_WITH_LAST_ERROR(hTransfer);


    //////////////////////////////////////////////////////////////////////
    // Step 2: Copy the file
    while(g_pInternetReadFile(hTransfer, buffer, sizeof(buffer), &dwRead) && dwRead != 0)
    {
        // Open the disk file
        if (hFile == INVALID_HANDLE_VALUE)
        {
            hFile = CreateFile(szFile, GENERIC_WRITE, 0, NULL, 
                               OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            
        }

        // Failed to open the disk file
        if(hFile == INVALID_HANDLE_VALUE)
            EXIT_WITH_LAST_ERROR();

        // Write bytes to the disk file
        if ( !WriteFile(hFile, buffer, dwRead, &dwWritten, NULL) || dwWritten != dwRead)
            EXIT_WITH_LAST_ERROR();
    }

 Cleanup:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (hInternet != NULL)
        g_pInternetCloseHandle(hInternet);
    if (hTransfer != NULL)
        g_pInternetCloseHandle(hTransfer);
    return hr;    
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Get the registry settings for an application
HRESULT
CMyWebAdmin::GetApplicationDetails(
        int             iIndex,
        LPWSTR          szDir,
        int             iDirSize,
        LPWSTR          szUrl,
        int             iUrlSize,        
        __int64 *       pDates)
{    
    if (szDir == NULL || szUrl == NULL || iDirSize < 1 || iUrlSize < 1 || pDates == NULL)
        return E_INVALIDARG;

    WCHAR   szAppUrl[1024]    = L"";
    HKEY    hKey              = GetAppKey(iIndex, szAppUrl);
    DWORD   dwSize            = 0;
    DWORD   dwType            = 0;
    DWORD   dwValue           = 0;
    HRESULT hr                = S_OK;

    if (hKey == NULL)
        return E_FAIL;

    if ((int) wcslen(szAppUrl) < iUrlSize)
        wcscpy(szUrl, szAppUrl);
    else
        EXIT_WITH_HRESULT(E_FAIL);


    // Get the app dir
    dwSize = iDirSize;
    dwType = REG_SZ;
    if (RegQueryValueEx(hKey, SZ_REG_MYWEBS_APPROOT, 0, &dwType, (BYTE *)szDir, &dwSize) != ERROR_SUCCESS)
        EXIT_WITH_LAST_ERROR();

    dwSize =  sizeof(__int64);
    dwType = REG_QWORD;
    if (RegQueryValueEx(hKey, SZ_REG_APP_CREATE_DATE, 0, &dwType, (BYTE *)&pDates[0], &dwSize) != ERROR_SUCCESS)
    {
        SYSTEMTIME  oSysTime;
        GetSystemTime(&oSysTime);
        SystemTimeToFileTime(&oSysTime, (FILETIME *) &pDates[0]);
        RegSetValueEx(hKey, SZ_REG_APP_CREATE_DATE, 0, REG_QWORD, (CONST BYTE *)&pDates[0], sizeof(pDates[0]));        
    }

    dwSize =  sizeof(__int64);
    dwType = REG_QWORD;
    if (RegQueryValueEx(hKey, SZ_REG_APP_ACCESS_DATE, 0, &dwType, (BYTE *)&pDates[1], &dwSize) != ERROR_SUCCESS)
    {
        SYSTEMTIME  oSysTime;
        GetSystemTime(&oSysTime);
        SystemTimeToFileTime(&oSysTime, (FILETIME *) &pDates[1]);
        RegSetValueEx(hKey, SZ_REG_APP_ACCESS_DATE, 0, REG_QWORD, (CONST BYTE *)&pDates[1], sizeof(pDates[1]));
    }

    dwSize =  sizeof(DWORD);
    dwType = REG_DWORD;
    if (RegQueryValueEx(hKey, SZ_REG_APP_IS_LOCAL, 0, &dwType, (BYTE *)&dwValue, &dwSize) != ERROR_SUCCESS)
    {
        dwValue = 0;
        RegSetValueEx(hKey, SZ_REG_APP_IS_LOCAL, 0, REG_DWORD, (CONST BYTE *)&dwValue, sizeof(DWORD));
    }

    pDates[2] = dwValue;

 Cleanup:
    RegCloseKey(hKey);
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Install an App
HRESULT
CMyWebAdmin::InstallApp (
        LPCWSTR    szCabFile,
        LPCWSTR    szUrl,
        LPCWSTR    szAppDir,
        LPCWSTR    szAppManifest,
        LPWSTR     szError,
        int        iErrorSize)
{
    LPCWSTR  szConstError = NULL;
    HRESULT  hr           = S_OK;
    BOOL     fDirsMade    = FALSE;

    szConstError = L"Unable to create the directory structure for this application: "; 
    hr = MakeDirectoriesForPath(szAppDir);    
    ON_ERROR_EXIT();
    fDirsMade = TRUE;

    szConstError = L"Unable to get the cab file from the Web Server: "; 
    hr = InstallInternetFiles(szCabFile, szUrl, szAppDir);
    ON_ERROR_EXIT();

    szConstError = L"Unable to copy the manifest file to the application root: "; 
    hr = CopyManifestFile(szAppDir, szAppManifest);
    ON_ERROR_EXIT();

    szConstError = L"Unable to create the registry structure for this application: "; 
    hr = CreateRegistryForApp(szUrl, szAppDir, FALSE);
    ON_ERROR_EXIT();

 Cleanup:
    if (hr != S_OK)
    {
        FillErrorString(hr, szConstError, szError, iErrorSize);
        if (fDirsMade)
            DeleteDirectory(szAppDir);
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Install an App
HRESULT
CMyWebAdmin::ReInstallApp (
        LPCWSTR    szCabFile,
        LPCWSTR    szUrl,
        LPCWSTR    szAppDir,
        LPCWSTR    szAppManifest,
        LPWSTR     szError,
        int        iErrorSize )
{

    LPCWSTR                    szConstError           = NULL;
    HRESULT                    hr                     = S_OK;
    HKEY                       hKey                   = NULL;
    WCHAR                      szOldDir[_MAX_PATH]    = L"";
    DWORD                      dwType                 = REG_SZ;
    DWORD                      cb                     = sizeof(szOldDir);
    BOOL                       fRemoveFailed          = FALSE;
    BOOL                       fDirsMade              = FALSE;

    szConstError = L"Unable to create the directory structure for this application: "; 
    hr = MakeDirectoriesForPath(szAppDir);
    ON_ERROR_EXIT();
    fDirsMade = TRUE;

    szConstError = L"Unable to get the cab file from the Web Server: "; 
    hr = InstallInternetFiles(szCabFile, szUrl, szAppDir);
    ON_ERROR_EXIT();

    szConstError = L"Unable to copy the manifest file to the application root: "; 
    hr = CopyManifestFile(szAppDir, szAppManifest);
    ON_ERROR_EXIT();

    ////////////////////////////////////////////////////////////
    // Destroy the old app: Step 1: Get it's reg key
    hKey = GetAppKey(-1, (LPWSTR) szUrl);
    ON_ZERO_EXIT_WITH_LAST_ERROR(hKey);

    // Step 2: Shut down the app domain
    cb = sizeof(szOldDir);
    if (RegQueryValueEx(hKey, SZ_REG_APP_DOMAIN, NULL, &dwType, (LPBYTE)szOldDir, &cb) == ERROR_SUCCESS)
    {
        char szDomainA[104];
        szDomainA[0] = NULL;
        szDomainA[100] = NULL;
        WideCharToMultiByte(CP_ACP, 0, szOldDir, -1, szDomainA, 100, NULL, NULL);        
        AppDomainRestart(szDomainA);
    }

    // Step 3: Get the old app dir
    szConstError = L"Unable to create the registry structure for this application: "; 
    cb = sizeof(szOldDir);
    if ( RegQueryValueEx(hKey, SZ_REG_MYWEBS_APPROOT, NULL, &dwType, (LPBYTE)szOldDir, &cb) != ERROR_SUCCESS)
        EXIT_WITH_LAST_ERROR();

    // Step 4: Set the new app dir in the registry
    if ( RegSetValueEx(hKey, SZ_REG_MYWEBS_APPROOT, 0, REG_SZ, 
                       (CONST BYTE *)szAppDir, wcslen(szAppDir) * sizeof(WCHAR)) 
         != ERROR_SUCCESS)
    {
        EXIT_WITH_LAST_ERROR();
    }

    fRemoveFailed = !DeleteDirectory(szOldDir);

 Cleanup:
    if (hKey != NULL)
        RegCloseKey(hKey);    
    if (hr != S_OK)
    {
        FillErrorString(hr, szConstError, szError, iErrorSize);
        if (fDirsMade)
            DeleteDirectory(szAppDir);
    }
    if (hr == S_OK && fRemoveFailed)
        hr = 1;
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Make all dir for a dir-path
HRESULT
CMyWebAdmin::MakeDirectoriesForPath(
        LPCWSTR     szPath)
{
    int      iLen = wcslen(szPath);
    HRESULT  hr   = S_OK;

    for(int iter=3; iter<iLen; iter++)
    {
        if (szPath[iter] == L'\\')
        {
            WCHAR * szTemp = (WCHAR *) szPath;
            WCHAR c = szPath[iter];
            szTemp[iter] = NULL;
            if ( CreateDirectory(szPath, NULL) == FALSE && GetLastError() != ERROR_ALREADY_EXISTS)
            {
                szTemp[iter] = c;
                EXIT_WITH_LAST_ERROR();
            }
            szTemp[iter] = c;
        }
    }

    if ( CreateDirectory(szPath, NULL) == FALSE && GetLastError() != ERROR_ALREADY_EXISTS)
        EXIT_WITH_LAST_ERROR();

 Cleanup:
    return hr;
}    

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CMyWebAdmin::InstallInternetFiles(
        LPCWSTR   szCabFile, 
        LPCWSTR   szUrl, 
        LPCWSTR   szPath)
{
    HRESULT          hr            = S_OK;
    LPWSTR           szFileToCopy  = NULL;
    LPWSTR           szFileCopied  = NULL;
    LPWSTR           szTemp        = NULL;
    BOOL             fRmCabFile    = FALSE;

    szTemp = wcsstr(szCabFile, L"http://");
    if (szTemp == NULL)
    {
        szFileToCopy = (LPWSTR) MemAllocClear((wcslen(szUrl) + wcslen(szCabFile)) * sizeof(WCHAR) + 200);
        ON_OOM_EXIT(szFileToCopy);
        wcscpy(szFileToCopy, L"http://");
        wcscat(szFileToCopy, szUrl);
        wcscat(szFileToCopy, szCabFile);
    }
    else
    {
        szFileToCopy = (LPWSTR) szCabFile;
    }

    szFileCopied = (LPWSTR) MemAllocClear(wcslen(szPath) * sizeof(WCHAR) + 200);
    ON_OOM_EXIT(szFileCopied);

    wcscpy(szFileCopied, szPath);
    wcscat(szFileCopied, L"\\myweb.cab");

    hr = CopyFileOverInternet(szFileToCopy, szFileCopied);
    ON_ERROR_EXIT();

    fRmCabFile = TRUE;

    if ( SetupIterateCabinet(szFileCopied, 0, CabFileHandler, (LPVOID) szPath) == FALSE)
        EXIT_WITH_LAST_ERROR();

 Cleanup:
    if (fRmCabFile)
        DeleteFile(szFileCopied);
    
    MemFree(szFileCopied);
    if (szFileToCopy != szCabFile)
        MemFree(szFileToCopy);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CMyWebAdmin::CopyManifestFile(
        LPCWSTR   szAppDir,
        LPCWSTR   szManifestFile)
{
    LPWSTR   szFile = NULL;
    HRESULT  hr     = S_OK;

    szFile = (LPWSTR) MemAllocClear(wcslen(szAppDir) * sizeof(WCHAR) + 200);
    ON_OOM_EXIT(szFile);

    wcscpy(szFile, szAppDir);
    wcscat(szFile, SZ_MYWEB_MANIFEST_W_SLASH);

    if (CopyFile(szManifestFile, szFile, FALSE) == FALSE)
        EXIT_WITH_LAST_ERROR();

    DeleteFile(szManifestFile);

 Cleanup:
    MemFree(szFile);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CMyWebAdmin::CreateRegistryForApp(
        LPCWSTR    szUrl, 
        LPCWSTR    szPhyPath,
        BOOL       fIsLocal)
{
    HRESULT        hr            = S_OK;
    HKEY           hKey          = NULL;
    LPWSTR         szTemp        = NULL;
    GUID           oGuid;
    SYSTEMTIME     oSysTime;
    FILETIME       oFileTime;

    ////////////////////////////////////////////////////////////
    // Step 1: Create the key name
    szTemp = (LPWSTR) MemAllocClear(wcslen(szUrl) * sizeof(WCHAR) + 200);
    ON_OOM_EXIT(szTemp);

    wcscpy(szTemp, SZ_REG_MYWEBS_KEY);
    wcscat(szTemp, L"\\");
    wcscat(szTemp, szUrl);

    ////////////////////////////////////////////////////////////
    // Step 2: Create the key
    if ( RegCreateKeyEx(HKEY_CURRENT_USER, szTemp, 0, NULL, 
                        0, KEY_ALL_ACCESS, NULL, &hKey, NULL) 
         != ERROR_SUCCESS)
    {
        EXIT_WITH_LAST_ERROR();
    }

    ////////////////////////////////////////////////////////////
    // Step 3: Set the app-root reg value
    if ( RegSetValueEx(hKey, SZ_REG_MYWEBS_APPROOT, 0, REG_SZ, 
                       (CONST BYTE *)szPhyPath, wcslen(szPhyPath) * sizeof(WCHAR)) 
         != ERROR_SUCCESS)
    {
        EXIT_WITH_LAST_ERROR();
    }

    ////////////////////////////////////////////////////////////
    // Step 4: Set the dates
    GetSystemTime(&oSysTime);
    SystemTimeToFileTime(&oSysTime, &oFileTime);
    RegSetValueEx(hKey, SZ_REG_APP_CREATE_DATE, 0, REG_QWORD, 
                  (CONST BYTE *)&oFileTime, sizeof(oFileTime));
    RegSetValueEx(hKey, SZ_REG_APP_ACCESS_DATE, 0, REG_QWORD, 
                  (CONST BYTE *)&oFileTime, sizeof(oFileTime));
    

    RegSetValueEx(hKey, SZ_REG_APP_IS_LOCAL, 0, REG_DWORD, 
                  (CONST BYTE *)&fIsLocal, sizeof(DWORD));

    ////////////////////////////////////////////////////////////
    // Step 5: Set the app domain id
    CoCreateGuid(&oGuid);
    StringFromGUID2(oGuid, szTemp, 100);
    RegSetValueEx(hKey, SZ_REG_APP_DOMAIN, 0, REG_SZ, 
                  (CONST BYTE *)szTemp, wcslen(szTemp) * sizeof(WCHAR));

 Cleanup:
    if (hKey != NULL) 
        RegCloseKey(hKey);
    MemFree(szTemp);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CMyWebAdmin::RemoveApp(
        LPCWSTR    szAppUrl)
{
    if (szAppUrl == NULL)
        return E_INVALIDARG;
    
    HKEY hKey = GetAppKey(-1, (LPWSTR) szAppUrl);
    if (hKey == NULL)
        return E_FAIL;    

    WCHAR                szDir[_MAX_PATH + 1] = L"";
    DWORD                dwValue              = 0;
    DWORD                dwType               = 0;
    DWORD                cb                   = MAX_PATH * sizeof(WCHAR);   
    WCHAR                szDomain[40]         = L"";
    HRESULT              hr                   = S_OK;
    BOOL                 fRemoveFailed        = FALSE;

    if (RegQueryValueEx(hKey, SZ_REG_MYWEBS_APPROOT, NULL, &dwType, (LPBYTE)szDir, &cb) != ERROR_SUCCESS)
        EXIT_WITH_LAST_ERROR();

    cb = sizeof(szDomain);
    if (RegQueryValueEx(hKey, SZ_REG_APP_DOMAIN, NULL, &dwType, (LPBYTE)szDomain, &cb) == ERROR_SUCCESS)
    {
        char szDomainA[100];
        szDomainA[0] = NULL;
        WideCharToMultiByte(CP_ACP, 0, szDomain, -1, szDomainA, 100, NULL, NULL);        
        AppDomainRestart(szDomainA);
    }

    cb = sizeof(DWORD);
    if (RegQueryValueEx(hKey, SZ_REG_APP_IS_LOCAL, NULL, &dwType, (LPBYTE)&dwValue, &cb) != ERROR_SUCCESS)
        dwValue = 0;

    RegCloseKey(hKey);
    hKey = NULL;
    
    if (dwValue == 0)
    {
        fRemoveFailed = !DeleteDirectory(szDir);        
    }

    if (RegOpenKeyEx(HKEY_CURRENT_USER, SZ_REG_MYWEBS_KEY, 0, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
        EXIT_WITH_LAST_ERROR();
    RegDeleteKey(hKey, szAppUrl);

 Cleanup:
    if (hKey != NULL)
        RegCloseKey(hKey);
    if (hr == S_OK && fRemoveFailed)
        hr = 1;
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CMyWebAdmin::MoveApp(
        LPCWSTR    szAppUrl, 
        LPCWSTR    szNewLocation,
        LPWSTR     szError,
        int        iErrorSize)
{
    HKEY    hKey = GetAppKey(-1, (LPWSTR) szAppUrl);

    if (hKey == NULL)
        return E_FAIL;
    
    LPCWSTR              szConstError = NULL;
    HRESULT              hr = S_OK;
    WCHAR                szDir[_MAX_PATH + 1] = L"";
    DWORD                dwType, cb = MAX_PATH * sizeof(WCHAR);   
    STARTUPINFO          si;
    PROCESS_INFORMATION  pi;
    WCHAR                szCmd[_MAX_PATH * 2];
    WCHAR                szDomain[40] = L"";
    int                  iLen;
    BOOL                 fRemoveFailed          = FALSE;

    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));

    szConstError = L"Unable to get registry information for this application: "; 
    if (RegQueryValueEx(hKey, SZ_REG_MYWEBS_APPROOT, NULL, &dwType, (LPBYTE)szDir, &cb) != ERROR_SUCCESS)
        EXIT_WITH_LAST_ERROR();

    cb = sizeof(szDomain);
    if (RegQueryValueEx(hKey, SZ_REG_APP_DOMAIN, NULL, &dwType, (LPBYTE)szDomain, &cb) == ERROR_SUCCESS)
    {
        char szDomainA[100];
        szDomainA[0] = NULL;
        WideCharToMultiByte(CP_ACP, 0, szDomain, -1, szDomainA, 100, NULL, NULL);        
        AppDomainRestart(szDomainA);
    }

    dwType = GetFileAttributes(szDir);
    if (dwType == (DWORD) -1 || (dwType & FILE_ATTRIBUTE_DIRECTORY) == 0)
        EXIT_WITH_HRESULT(E_FAIL);
    
    szConstError = L"Unable to copy files to new directory: "; 
    if(GetEnvironmentVariable(L"SystemRoot", szCmd, MAX_PATH) == 0)
        EXIT_WITH_HRESULT(E_FAIL);
    
    wcscat(szCmd, L"\\system32\\xcopy.exe /E /Y /V /C /I /Q /H /R /K \"");
    wcscat(szCmd, szDir);
    iLen = wcslen(szCmd);
    if (szCmd[iLen-1] == L'\\')
        szCmd[iLen-1] = NULL;

    wcscat(szCmd, L"\" \"");
    wcscat(szCmd, szNewLocation);
    iLen = wcslen(szCmd);
    if (szCmd[iLen-1] == L'\\')
        szCmd[iLen-1] = NULL;
    wcscat(szCmd, L"\"");

    si.cb = sizeof(si);
    
    if ( !CreateProcess(NULL, szCmd, NULL, NULL, TRUE, 
                        CREATE_NO_WINDOW, NULL, NULL, &si, &pi))
    {
        EXIT_WITH_LAST_ERROR();
    }

    if ( WaitForSingleObject(pi.hProcess, 5 * 60 * 1000) == WAIT_TIMEOUT)
    {
        EXIT_WITH_WIN32_ERROR(ERROR_TIMEOUT);
    }
    
    szConstError = L"Unable to update registry: "; 
    if ( RegSetValueEx(hKey, SZ_REG_MYWEBS_APPROOT, 0, REG_SZ, 
                       (CONST BYTE *)szNewLocation, lstrlen(szNewLocation) * sizeof(WCHAR)) 
         != ERROR_SUCCESS)
    {
        EXIT_WITH_LAST_ERROR();
    }


    fRemoveFailed = !DeleteDirectory(szDir);    
    
 Cleanup:
    if(pi.hProcess)
        CloseHandle(pi.hProcess);
    if(pi.hThread)
        CloseHandle(pi.hThread);
    if (hKey != NULL)
        RegCloseKey(hKey);
    if (hr != S_OK)
        FillErrorString(hr, szConstError, szError, iErrorSize);
    if (hr == S_OK && fRemoveFailed)
        hr = 1;    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

int
CMyWebAdmin::GetInstallLocationForUrl(
        LPCWSTR    szConfigValue, 
        LPCWSTR    szAppUrl,
        LPCWSTR    szRandom,
        LPWSTR     szBuf,
        int        iBufSize)
{
    if (szConfigValue == NULL || szAppUrl == NULL || szBuf == NULL || iBufSize < 1)
        return 0;

    szBuf[0] = NULL;

    int      iRet, iLen, iter;
    GUID     oGuid;
    HRESULT  hr = S_OK;
    WCHAR    szRandomString[84] = L"";

    if (szRandom != NULL && wcslen(szRandom) > 1 && wcslen(szRandom) <= 80)
    {
        wcscpy(szRandomString, szRandom);
    }
    else
    {
        CoCreateGuid(&oGuid);
        StringFromGUID2(oGuid, szRandomString, 80);
    }

    iRet = ExpandEnvironmentStrings(szConfigValue, szBuf, iBufSize);
    ON_ZERO_EXIT_WITH_LAST_ERROR(iRet);

    if (iRet > iBufSize)
    {
        iRet = -(iRet + (int) wcslen(szAppUrl) + 82);
        EXIT_WITH_HRESULT(E_FAIL);
    }
    iLen = wcslen(szBuf);

    if (iLen < 1)
    {
        iRet = -(iRet + (int) wcslen(szAppUrl) + 82);
        EXIT_WITH_HRESULT(E_FAIL);
    }


    if (iLen + (int) wcslen(szAppUrl) + 80 > iBufSize)
    {
        iRet = -(iRet + (int) wcslen(szAppUrl) + 82);
        EXIT_WITH_HRESULT(E_FAIL);
    }

    if (szBuf[iLen-1] != L'\\')
        wcscat(szBuf, L"\\");

    wcscat(szBuf, szAppUrl);
    wcscat(szBuf, szRandomString);
   
    for(iter=wcslen(szBuf)-1; iter>=0; iter--)
        if (szBuf[iter] == L'/')
            szBuf[iter] = L'\\';

 Cleanup:
    if (hr == S_OK)
        return 1;
    return iRet;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HKEY
CMyWebAdmin::GetAppKey(
        int        iIndex, 
        WCHAR *    szKey  )
{
    HKEY    hKey                    = NULL;
    HRESULT hr                      = S_OK;
    HKEY    hKeySub                 = NULL;
    DWORD   dwNameSize              = _MAX_PATH;        
    WCHAR   szName[_MAX_PATH+1]     = L"";
    
    if (RegCreateKeyEx(HKEY_CURRENT_USER, SZ_REG_MYWEBS_KEY, 0, NULL, 0,
                       KEY_ALL_ACCESS, NULL, &hKey, NULL) != ERROR_SUCCESS)
    {
        EXIT_WITH_LAST_ERROR();
    }

    if (szKey == NULL || szKey[0] == NULL)
    { 
        if (RegEnumKeyEx(hKey, iIndex, szName, &dwNameSize, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
            EXIT_WITH_LAST_ERROR();

        if (szKey != NULL && szKey[0] == NULL)
            wcscpy(szKey, szName);
    }
    else
    {
        wcsncpy(szName, szKey, dwNameSize);
        szName[dwNameSize] = NULL;
    }

    if (RegOpenKeyEx(hKey, szName, 0, KEY_ALL_ACCESS, &hKeySub) != ERROR_SUCCESS)
        EXIT_WITH_LAST_ERROR();
 Cleanup:
    if(hKey) RegCloseKey(hKey);
    if (hr != S_OK)
        return NULL;
    return hKeySub;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CMyWebAdmin::GetAppSettings(
        LPCTSTR   base, 
        LPTSTR    appRoot,
        LPTSTR    appDomain,
        LPBOOL    pfTrusted)
{
    HKEY hKey = GetAppKey(-1, (WCHAR *) base);

    (*pfTrusted) = 0;

    if (hKey == NULL)
        return E_FAIL;

    HRESULT     hr     = S_OK;
    GUID        oGuid;
    SYSTEMTIME  oSysTime;
    FILETIME    oFileTime;
    DWORD       dwType = 0;
    appRoot[0] = L'\0';

    DWORD cb = MAX_PATH * sizeof(WCHAR);
    if(RegQueryValueEx(hKey, SZ_REG_MYWEBS_APPROOT, NULL, &dwType, (LPBYTE)appRoot, &cb) == ERROR_SUCCESS)
    {
        dwType = GetFileAttributes(appRoot);
        if (dwType == (DWORD) -1 || (dwType & FILE_ATTRIBUTE_DIRECTORY) == 0)
            appRoot[0] = NULL;
        else
            hr = S_OK;
    }

    cb = 40 * sizeof(WCHAR);
    if(RegQueryValueEx(hKey, SZ_REG_APP_DOMAIN, NULL, &dwType, (LPBYTE)appDomain, &cb) != ERROR_SUCCESS)
    {
        CoCreateGuid(&oGuid);
        StringFromGUID2(oGuid, appDomain, 40);   
        RegSetValueEx(hKey, SZ_REG_APP_DOMAIN, 0, REG_SZ, (CONST BYTE *)appDomain, lstrlen(appDomain) * sizeof(WCHAR));
    }

    cb = sizeof(DWORD);
    if(RegQueryValueEx(hKey, SZ_REG_APP_TRUSTED, NULL, &dwType, (LPBYTE)pfTrusted, &cb) != ERROR_SUCCESS)
    {
        (*pfTrusted) = 0;
        RegSetValueEx(hKey, SZ_REG_APP_TRUSTED, 0, REG_DWORD, (CONST BYTE *)pfTrusted, sizeof(DWORD));
    }


    GetSystemTime(&oSysTime);
    SystemTimeToFileTime(&oSysTime, &oFileTime);
    RegSetValueEx(hKey, SZ_REG_APP_ACCESS_DATE, 0, REG_QWORD, (CONST BYTE *)&oFileTime, sizeof(oFileTime));
    RegCloseKey(hKey);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
HRESULT
CMyWebAdmin::InstallLocalApplication    (
        LPCWSTR     appUrl, 
        LPCWSTR     appDir)
{
    return CreateRegistryForApp(appUrl, appDir, TRUE);
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

DWORD
CMyWebAdmin::GetNextWord(char * strWord, char * buf, DWORD dwBufSize)
{
    if (dwBufSize < 1)
        return 0;
    
    DWORD dwStart = 0;
    DWORD dwEnd   = 0;

    while(dwStart < dwBufSize && isspace(buf[dwStart]))
        dwStart ++;

    dwEnd = dwStart;

    if (buf[dwStart] == '\"')
    {
        dwEnd++;
        while(dwEnd < dwBufSize && buf[dwEnd] != '\"')
            dwEnd++;
        if (dwEnd < dwBufSize)
            dwEnd++;
    }
    else
    {
        if (isalnum(buf[dwStart]) || buf[dwStart] == '\"')
        {
            while(dwEnd < dwBufSize && (isalnum(buf[dwEnd]) || buf[dwEnd] == '\"'))
                dwEnd ++;
        }
        else
        {
            while(dwEnd < dwBufSize && !isalnum(buf[dwEnd]) && !isspace(buf[dwEnd]) && buf[dwEnd] != '\"')
                dwEnd ++;
        }
    }

    DWORD dwRet = dwEnd - dwStart;
    if (dwRet > 1000)
    {
        strncpy(strWord, &buf[dwStart], 1000);
        strWord[1000] = NULL;
    }
    else
    {
        strncpy(strWord, &buf[dwStart], dwRet);
        strWord[dwRet] = NULL;
    }

    return dwEnd;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void
CMyWebAdmin::NormalizeAdminDir()
{
    WCHAR szDir[_MAX_PATH + 2];

    if (g_szAdminDir[0] == NULL)
        wcscpy(g_szAdminDir, L"%XSPINSTALLDIR%\\myweb");

    if (!ExpandEnvironmentStrings(g_szAdminDir, szDir, _MAX_PATH))
        wcscpy(szDir, g_szAdminDir);
    
    _wcsupr(szDir);
    
    WCHAR * pStart = wcsstr(szDir, L"%XSPINSTALLDIR%");
    if (pStart == NULL)
    {
        wcscpy(g_szAdminDir, szDir);
    }
    else
    {
        wcscpy(g_szAdminDir, g_szConfigFile);
        pStart = wcsrchr(g_szAdminDir, L'\\');
        if (pStart != NULL)
            pStart[0] = NULL;
        
        
        int iPos = wcslen(g_szAdminDir);
        wcsncat(&g_szAdminDir[iPos], &szDir[wcslen(L"%XSPINSTALLDIR%")], _MAX_PATH - iPos - 1);
        g_szAdminDir[_MAX_PATH - 1] = NULL;
    }
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void
CMyWebAdmin::FillErrorString(
        HRESULT     hr, 
        LPCWSTR     szConstError, 
        LPWSTR      szErrorBuf, 
        int         iErrorBufSize)
{
    if (szErrorBuf == NULL || iErrorBufSize < 2)
        return;

    WCHAR szErr[1024];
    ZeroMemory(szErr, sizeof(szErr));

    if (szConstError == NULL)
        szConstError = L"An error occurred while performing this operation: "; 

    FormatMessage(
            FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            hr,
            LANG_SYSTEM_DEFAULT,
            szErr,
            1024,
            NULL);
    if ((DWORD) iErrorBufSize < wcslen(szErr) + wcslen(szConstError) + 20)
        return;

    wsprintf(szErrorBuf, L"%s Hresult: %08x \t %s", szConstError, hr, szErr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOL
CMyWebAdmin::DeleteDirectory(
        LPCWSTR szDir)
{
    if (szDir == NULL)
        return TRUE;

    WIN32_FIND_DATA  oFindData;
    HANDLE           hSearch = NULL;
    WCHAR            szPath[1024];
    BOOL             fReturn = TRUE;
    int              iLen;
    
    ZeroMemory(&oFindData, sizeof(oFindData));

    wcscpy(szPath, szDir);
    iLen = wcslen(szPath);

    if (szPath[iLen-1] != L'\\')
    {
        szPath[iLen++] = L'\\';
    }

    szPath[iLen] = L'*';
    szPath[iLen+1] = NULL;

    for ( BOOL fContinue = ((hSearch = FindFirstFile(szPath, &oFindData)) != INVALID_HANDLE_VALUE); 
          fContinue; 
          fContinue = FindNextFile(hSearch, &oFindData))
    {
        if (wcscmp(oFindData.cFileName, L".")==0 || wcscmp(oFindData.cFileName, L"..")==0)
            continue;

        szPath[iLen] = NULL;
        wcscat(szPath, oFindData.cFileName);

        if (oFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            fReturn = (DeleteDirectory(szPath) && fReturn);
        else
            fReturn = (DeleteFile(szPath) && fReturn);
    }

    if (hSearch != INVALID_HANDLE_VALUE)
        FindClose(hSearch);

    fReturn = (RemoveDirectory(szDir) && fReturn);

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\myweb\ptprotocolfactory.cxx ===
/**
 * Asynchronous pluggable protocol for personal tier
 *
 * Copyright (C) Microsoft Corporation, 1999
 */

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ndll.h"
#include "appdomains.h"
#include "_isapiruntime.h"
#include "wininet.h"
#include "myweb.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
PTProtocolFactory::QueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown ||
        iid == IID_IInternetProtocolInfo)
    {
        *ppv = (IInternetProtocolInfo *)this;
    }
    else
        if (iid == IID_IClassFactory)
        {
            *ppv = (IClassFactory *)this;
        }
        else
        {
            return E_NOINTERFACE;
        }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////

ULONG
PTProtocolFactory::AddRef()
{
    return InterlockedIncrement(&g_PtpObjectCount);
}

ULONG
PTProtocolFactory::Release()
{
    return InterlockedDecrement(&g_PtpObjectCount);
}

HRESULT
PTProtocolFactory::LockServer(BOOL lock)
{
    return (lock ? 
            InterlockedIncrement(&g_PtpObjectCount) : 
            InterlockedDecrement(&g_PtpObjectCount));
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
PTProtocolFactory::CreateInstance(
        IUnknown * pUnkOuter,
        REFIID     iid,
        void **    ppv)
{
    HRESULT hr = S_OK;
    PTProtocol *pProtocol = NULL;

    if (pUnkOuter && iid != IID_IUnknown)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    pProtocol = new PTProtocol(pUnkOuter);
    ON_OOM_EXIT(pProtocol);

    if (iid == IID_IUnknown)
    {
        *ppv = (IMyWebPrivateUnknown *)pProtocol;
        pProtocol->PrivateAddRef();
    }
    else
    {
        hr = pProtocol->QueryInterface(iid, ppv);
        ON_ERROR_EXIT();
    }

 Cleanup:
    if (pProtocol)
        pProtocol->PrivateRelease();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
PTProtocolFactory::CombineUrl(
        LPCWSTR, 
        LPCWSTR, 
        DWORD, 
        LPWSTR,  
        DWORD, 
        DWORD *, 
        DWORD)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT
PTProtocolFactory::CompareUrl(LPCWSTR, LPCWSTR, DWORD)
{
    return INET_E_DEFAULT_ACTION;
}


HRESULT
PTProtocolFactory::ParseUrl(
        LPCWSTR       pwzUrl,
        PARSEACTION   ParseAction,
        DWORD         ,
        LPWSTR        pwzResult,
        DWORD         cchResult,
        DWORD *       pcchResult,
        DWORD         )
{
    // Only thing we handle is security zones...
    if (ParseAction != PARSE_SECURITY_URL && ParseAction != PARSE_SECURITY_DOMAIN)
        return INET_E_DEFAULT_ACTION;

    // Check to make sure args are okay
    if ( pwzUrl == NULL || pwzResult == NULL || cchResult < 4 || wcslen(pwzUrl) < PROTOCOL_NAME_LEN)
        return INET_E_DEFAULT_ACTION;

    // Check if the protocol starts with myweb
    for(int iter=0; iter<PROTOCOL_NAME_LEN; iter++)
        if (towlower(pwzUrl[iter]) != SZ_PROTOCOL_NAME[iter])
            return INET_E_DEFAULT_ACTION; // Doesn't start with myweb

    
    // Copy in the corresponding http protocol
    wcscpy(pwzResult, L"http");   
    wcsncpy(&pwzResult[4], &pwzUrl[PROTOCOL_NAME_LEN], cchResult - 5);
    pwzResult[cchResult-1] = NULL;
    (*pcchResult) = wcslen(pwzResult);

    return S_OK;
}

HRESULT
PTProtocolFactory::QueryInfo(LPCWSTR, QUERYOPTION, DWORD,
                             LPVOID, DWORD, DWORD *, DWORD)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\myweb\ptprotocol.cxx ===
/**
 * Asynchronous pluggable protocol for personal tier
 *
 * Copyright (C) Microsoft Corporation, 1999
 */

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ndll.h"
#include "appdomains.h"
#include "_isapiruntime.h"
#include "wininet.h"
#include "myweb.h"
#include "setupapi.h"
#include "windows.h"
#include "wchar.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

CLSID   CLSID_PTProtocol = { 0x03be83e6, 
                             0xaf00, 
                             0x11d2, 
                             {0xb8, 0x7c, 0x00, 0xc0, 0x4f, 0x8e, 0xfc, 0xbf}};

LONG                    g_PtpObjectCount        = 0;
BOOL                    g_Started               = FALSE;
PTProtocolFactory       g_PTProtocolFactory;
BOOL                    g_fRunningMyWeb         = FALSE;

LPSTR g_szErrorString = " <html> <head> <style> H1 { font-family:\"Arial, Helvetica, Geneva, SunSans-Regular, sans-serif\";font-weight:bold;font-size:26pt;color:red } H2 { font-family:\"Arial, Helvetica, Geneva, SunSans-Regular, sans-serif\";font-weight:bold;font-size:18pt;color:black } </style> <title>Fatal Error</title> </head> <body bgcolor=\"white\"> <table width=100%> <span> <H1>" PRODUCT_NAME " Error<hr width=100%></H1> <h2> <i>Fatal Error</i> </h2> </span> <font face=\"Arial, Helvetica, Geneva, SunSans-Regular, sans-serif\"> <b> Description: </b> A fatal error has occurred during the execution of the current web request. &nbsp; Unfortunately no stack trace or additional error information is available for display. &nbsp;Common sources of these types of fatal errors include: <ul> <li>Setup Configuration Problems</li> <li>Access Violations (AVs) </li> <li>COM+ <-> Classic COM Interop Bugs</li> </ul> Consider attaching a debugger to learn more about the specific failure. <br><br> <hr width=100%> </font> </table> </body></html> ";

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class PTProtocol ctor

PTProtocol::PTProtocol(
        IUnknown *   pUnkOuter)
    : m_dwRefCount                (1),
      m_pProtocolSink             (NULL),
      m_strCookie                 (NULL),   
      m_strCookiePath             (NULL),
      m_strUriPath                (NULL),
      m_strQueryString            (NULL),
      m_strAppOrigin              (NULL),
      m_strAppRoot                (NULL),
      m_strAppRootTranslated      (NULL),
      m_strRequestHeaders         (NULL),
      m_strRequestHeadersA        (NULL),
      m_dwInputDataSize           (0),
      m_pInputData                (NULL),
      m_pInputRead                (NULL),
      m_pOutputRead               (NULL),
      m_pOutputWrite              (NULL),
      m_fStartCalled              (FALSE),
      m_fAbortingRequest          (FALSE),
      m_fDoneWithRequest          (FALSE),
      m_dwOutput                  (0),
      m_strRequestHeadersUpr      (NULL),
      m_strResponseHeaderA        (NULL),
      m_pManagedRuntime           (NULL),
      m_strVerb                   (NULL),
      m_fRedirecting              (FALSE),
      m_fAdminMode                (FALSE),
      m_strUrl                    (NULL),
      m_fTrusted                  (FALSE)
{
    g_fRunningMyWeb = TRUE;
    m_pUnkOuter = pUnkOuter;

    if (m_pUnkOuter != NULL)
        AddRef();

    InitializeCriticalSection(&m_csOutputWriter);
    ZeroMemory(m_strAppDomain, sizeof(m_strAppDomain));
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void
PTProtocol::Cleanup()
{
    ClearInterface(&m_pOutputRead);
    ClearInterface(&m_pOutputWrite);
    ClearInterface(&m_pProtocolSink);
    ClearInterface(&m_pManagedRuntime);
    ClearInterface(&m_pInputRead);

    if(m_strCookiePath) 
    {
        MemFree(m_strCookiePath);
        m_strUriPath = NULL;
    }

    if(m_strAppOrigin) 
    {
        MemFree(m_strAppOrigin);
        m_strAppOrigin = NULL;
    }

    if(m_strAppRootTranslated)
    {
        MemFree(m_strAppRootTranslated);
        m_strAppRootTranslated = NULL;
    }

    if(m_strRequestHeaders)
    {
        MemFree(m_strRequestHeaders);
        m_strRequestHeaders = NULL;
    }
    if(m_strRequestHeadersA)
    {
        MemFree(m_strRequestHeadersA);
        m_strRequestHeadersA = NULL;
    }

    if(m_strCookie)
    {
        MemFree(m_strCookie);
        m_strCookie = NULL;
    }

    if (m_strRequestHeadersUpr != NULL)
    {
        MemFree(m_strRequestHeadersUpr);
        m_strRequestHeadersUpr = NULL;      
    }

    if (m_strResponseHeaderA != NULL)
    {
        MemFree(m_strResponseHeaderA);
        m_strResponseHeaderA = NULL;
    }
    if (m_strUrl != NULL)
    {
        MemFree(m_strUrl);
        m_strUrl = NULL;
    }
    if (m_pInputData != NULL)
    {
        MemFree(m_pInputData);
        m_pInputData = NULL;
    }

    m_strCookie             = NULL;   
    m_strCookiePath         = NULL;
    m_strUriPath            = NULL;
    m_strQueryString        = NULL;
    m_strAppOrigin          = NULL;
    m_strAppRoot            = NULL;
    m_strAppRootTranslated  = NULL;
    m_strRequestHeaders     = NULL;
    m_strRequestHeadersA    = NULL;
    m_dwInputDataSize       = NULL;
    m_pInputRead            = NULL;
    m_fStartCalled          = NULL;
    m_fAbortingRequest      = NULL;
    m_fDoneWithRequest      = NULL;
    m_dwOutput              = NULL;
    m_strRequestHeadersUpr  = NULL;
    m_strResponseHeaderA    = NULL;
    m_strVerb               = NULL;
    m_fTrusted              = FALSE;

    TRACE(L"myweb", L"out of cleanup");    
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

PTProtocol::~PTProtocol()
{
    Cleanup();
    DeleteCriticalSection(&m_csOutputWriter);
    if (m_pUnkOuter != NULL && m_pUnkOuter != (IUnknown *)(IMyWebPrivateUnknown *)this)
        m_pUnkOuter->Release();
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Private QI

ULONG
PTProtocol::PrivateAddRef()
{
    return ++m_dwRefCount;
}

ULONG
PTProtocol::PrivateRelease()
{
    if (--m_dwRefCount > 0)
        return m_dwRefCount;

    delete this;
    return 0;
}

HRESULT
PTProtocol::PrivateQueryInterface(
        REFIID      iid, 
        void**      ppv)
{
    *ppv = NULL;

    if (iid == IID_IInternetProtocol ||
        iid == IID_IInternetProtocolRoot)
    {
        *ppv = (IInternetProtocol *)this;
    }
    else if (iid == IID_IUnknown)
    {
        *ppv = (IUnknown *)(IMyWebPrivateUnknown *)this;
    }
    else if (iid == IID_IWinInetHttpInfo)
    {
        *ppv = (IWinInetHttpInfo *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Public (delegated) QI

ULONG
PTProtocol::AddRef()
{
    if (m_pUnkOuter != NULL)
      m_pUnkOuter->AddRef();
    return PrivateAddRef();
}

ULONG
PTProtocol::Release()
{
    if (m_pUnkOuter != NULL) 
      m_pUnkOuter->Release();
    return PrivateRelease();
}

HRESULT
PTProtocol::QueryInterface(
        REFIID    iid, 
        void **   ppv)
{
    if (m_pUnkOuter != NULL)
      return m_pUnkOuter->QueryInterface(iid, ppv);
    else
      return PrivateQueryInterface(iid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
PTProtocol::Start(
        LPCWSTR                   url,
        IInternetProtocolSink *   pProtocolSink,
        IInternetBindInfo *       pBindInfo,
        DWORD                     grfSTI,
        DWORD                           )
{
    HRESULT             hr                = S_OK;
    WCHAR *             Strings[]         = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    DWORD               cStrings          = sizeof(Strings) / sizeof(Strings[0]);
    DWORD               cookieSize        = 0;
    IServiceProvider *  pServiceProvider  = NULL;
    IHttpNegotiate *    pHttpNegotiate    = NULL;
    BINDINFO            oBindInfo;

    ZeroMemory(&oBindInfo, sizeof(oBindInfo));
    ReplaceInterface(&m_pProtocolSink, pProtocolSink);

    if (grfSTI & PI_PARSE_URL)
        goto Cleanup;

    if (pProtocolSink == NULL)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    // get bindinfo
    oBindInfo.cbSize = sizeof(BINDINFO);
    if (pBindInfo != NULL)
    {
         DWORD  dwBindF = 0;
        hr = pBindInfo->GetBindInfo(&dwBindF, &oBindInfo);
        ON_ERROR_EXIT();
    }

    if (oBindInfo.dwCodePage == 0)
        oBindInfo.dwCodePage = CP_ACP;


    // extract root, uri path and query string from url
    m_strUrl = DuplicateString(url);
    ON_OOM_EXIT(m_strUrl);

    hr = ExtractUrlInfo();    
    ON_ERROR_EXIT();

    // get to headers in MSHtml
    hr = pBindInfo->QueryInterface(IID_IServiceProvider, (void **) &pServiceProvider);
    ON_ERROR_EXIT();
    if(pServiceProvider != NULL)
    {
        hr = pServiceProvider->QueryService(IID_IHttpNegotiate, IID_IHttpNegotiate, (void **) &pHttpNegotiate);
        ON_ERROR_EXIT();
        if(pHttpNegotiate != NULL)
        {
            LPWSTR szHeaders = NULL;
            hr = pHttpNegotiate->BeginningTransaction(m_strUrl, NULL, 0, &szHeaders);
            pHttpNegotiate->Release();
            pHttpNegotiate = NULL;
            ON_ERROR_EXIT();

            if (szHeaders != NULL)
            {
                m_strRequestHeaders = CreateRequestHeaders(szHeaders);
                CoTaskMemFree(szHeaders);
            }
        }

        pServiceProvider->Release();
        pServiceProvider = NULL;
    }

    // determine verb
    switch (oBindInfo.dwBindVerb)
    {
    case BINDVERB_GET:  
        m_strVerb = L"GET";  
        break;

    case BINDVERB_POST: 
        m_strVerb = L"POST";
        break;

    case BINDVERB_PUT: 
        m_strVerb = L"PUT";
        break;

    default:
        if (oBindInfo.szCustomVerb != NULL && oBindInfo.dwBindVerb == BINDVERB_CUSTOM)
        {
            m_strVerb = DuplicateString(oBindInfo.szCustomVerb); 
            ON_OOM_EXIT(m_strVerb);
        }
        else
        {
            m_strVerb = L"GET";
        }
        break;
    }

    // get mime type of posted data from binding
    hr = pBindInfo->GetBindString(BINDSTRING_POST_DATA_MIME, Strings, cStrings, &cStrings);
    if(hr == S_OK && cStrings)
    {
        for(DWORD i = 0; i < cStrings; i++)
            CoTaskMemFree(Strings[i]);
    }

    // don't fail if we failed to get bind string, 
    hr = S_OK;

    // retrieve cookie
    cookieSize = 0;
    if(g_pInternetGetCookieW(m_strCookiePath, NULL, NULL, &cookieSize) && cookieSize)
    {
        m_strCookie = (WCHAR *)MemAllocClear(cookieSize * sizeof(WCHAR) + 100);
        ON_OOM_EXIT(m_strCookie);
        g_pInternetGetCookieW(m_strCookiePath, NULL, m_strCookie, &cookieSize);
    }


    // Input data
    if (oBindInfo.stgmedData.tymed == TYMED_HGLOBAL && oBindInfo.cbstgmedData > 0)
    {
        m_dwInputDataSize = oBindInfo.cbstgmedData;       
        m_pInputData = (BYTE *) MemAllocClear(m_dwInputDataSize);
        if (m_pInputData != NULL)
        {
            memcpy(m_pInputData, (BYTE *)oBindInfo.stgmedData.hGlobal, m_dwInputDataSize);
        }
        else
        {
            m_dwInputDataSize = 0;
        }
    }
    else if (oBindInfo.stgmedData.tymed == TYMED_ISTREAM)
    {
        STATSTG statstg;

        ReplaceInterface(&m_pInputRead, oBindInfo.stgmedData.pstm);

        if(m_pInputRead) 
        {
            hr = m_pInputRead->Stat(&statstg, STATFLAG_NONAME);
            if(hr == S_OK)
                m_dwInputDataSize = statstg.cbSize.LowPart;
            else
                m_dwInputDataSize = (DWORD)-1;
        }
    }

    hr = CreateStreamOnHGlobal(NULL, true, &m_pOutputWrite);
    ON_ERROR_EXIT();

    hr = m_pOutputWrite->Clone(&m_pOutputRead);
    ON_ERROR_EXIT();

 Cleanup:

    PROTOCOLDATA        protData;
    protData.dwState = (hr ? 2 : 1);
    protData.grfFlags = PI_FORCE_ASYNC;
    protData.pData = NULL;
    protData.cbData = 0;

    pProtocolSink->Switch(&protData);
    if (oBindInfo.cbSize)
    {
        ReleaseBindInfo(&oBindInfo);
        ZeroMemory(&oBindInfo, sizeof(oBindInfo));
    }

    return E_PENDING;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
PTProtocol::Continue(
        PROTOCOLDATA *  pProtData)
{
    HRESULT     hr                            = S_OK;
    CHAR        appDomainPath[MAX_PATH]       = "";
    CHAR        strAppDomainA[40]             = "";
    CHAR        strUrlOfAppOrigin[MAX_PATH]   = "";
    IUnknown *  pAppDomainObject              = NULL;
    int         iZone                         = 0;
    int         iRestart                      = 0;
    
    ASSERT(m_pManagedRuntime == NULL && m_strAppRootTranslated[0] != NULL);

    if (m_fAdminMode)
    {
        m_pProtocolSink->ReportProgress(BINDSTATUS_REDIRECTING, m_strUrl);
    }

    if (!m_fTrusted)
    {
        WCHAR * pStart = wcsstr(m_strUrl, L"://");
        WCHAR  szUrl[_MAX_PATH + 10];

        if (pStart == NULL)
            pStart = m_strUrl;
        else
            pStart = &pStart[3];

        wcscpy(szUrl, L"http://");
        int iPos = wcslen(szUrl);
        wcsncpy(&szUrl[iPos], pStart, _MAX_PATH);
        szUrl[_MAX_PATH] = NULL;

        WideCharToMultiByte(CP_ACP, 0, szUrl, -1, strUrlOfAppOrigin, _MAX_PATH - 1, NULL, NULL);
        strUrlOfAppOrigin[_MAX_PATH - 1] = NULL;        

        
        if (g_pInternetSecurityManager == NULL || FAILED(g_pInternetSecurityManager->MapUrlToZone(szUrl, (LPDWORD) &iZone, 0)))
            iZone = URLZONE_INTERNET;
    }

    if(pProtData->dwState == 1)
    {
        WideCharToMultiByte(CP_ACP, 0, m_strAppRootTranslated, -1, appDomainPath, MAX_PATH, NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, m_strAppDomain, -1, strAppDomainA, 40, NULL, NULL);
        hr = GetAppDomain(strAppDomainA, appDomainPath, &pAppDomainObject, strUrlOfAppOrigin, iZone);
        ON_ERROR_EXIT();

        if (pAppDomainObject == NULL)
            EXIT_WITH_HRESULT(E_POINTER);
        
        hr = pAppDomainObject->QueryInterface(__uuidof(xspmrt::_ISAPIRuntime), (LPVOID*) &m_pManagedRuntime);
        ON_ERROR_EXIT();
        
        if (m_pManagedRuntime == NULL)
            EXIT_WITH_HRESULT(E_POINTER);
        
        // Call the initialization method on managed runtime
        hr = m_pManagedRuntime->StartProcessing();
        ON_ERROR_EXIT();
        
        hr = m_pManagedRuntime->ProcessRequest((int)this, 2, &iRestart);
        ON_ERROR_EXIT();
    }
    else
        hr = E_FAIL;

 Cleanup:
    if (pAppDomainObject != NULL)
    {
        pAppDomainObject->Release();
    }

    if (hr != S_OK)
    {
        WriteBytes((BYTE *)g_szErrorString, strlen(g_szErrorString));
        Finish();
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT 
PTProtocol::Finish()
{
    HRESULT hr = S_OK;

    if (m_fDoneWithRequest == FALSE)
    {
        m_fDoneWithRequest = TRUE;

        m_pProtocolSink->ReportData(BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE, 0, m_dwOutput);

        if (m_fAbortingRequest == FALSE)
            m_pProtocolSink->ReportResult(S_OK, 0, NULL);
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
PTProtocol::Abort(
        HRESULT hrReason,
        DWORD           )
{
    HRESULT hr = S_OK;

    m_fAbortingRequest = TRUE;
    if (m_pProtocolSink != NULL)
    {
        hr = m_pProtocolSink->ReportResult(hrReason, 0, 0);
        ON_ERROR_EXIT();
    }

 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
PTProtocol::Terminate(
        DWORD )
{
    Cleanup();
    return S_OK;
}

HRESULT
PTProtocol::Suspend()
{
    return E_NOTIMPL;
}

HRESULT
PTProtocol::Resume()
{
    return E_NOTIMPL;
}

HRESULT
PTProtocol::Read(
        void *pv, 
        ULONG cb, 
        ULONG *pcbRead)
{
    HRESULT hr;

    hr = m_pOutputRead->Read(pv, cb, pcbRead);

    // We must only return S_FALSE when we have hit the absolute end of the stream
    // If we think there is more data coming down the wire, then we return E_PENDING
    // here. Even if we return S_OK and no data, UrlMON will still think we've hit
    // the end of the stream.

    if (S_OK == hr && 0 == *pcbRead)
    {
        hr = m_fDoneWithRequest ? S_FALSE : E_PENDING;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
PTProtocol::Seek(
        LARGE_INTEGER offset, 
        DWORD origin, 
        ULARGE_INTEGER *pPos)
{
    return m_pOutputRead->Seek(offset, origin, pPos);
}


HRESULT
PTProtocol::LockRequest(
        DWORD )
{
    return S_OK;
}

HRESULT
PTProtocol::UnlockRequest()
{
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
PTProtocol::SendHeaders(
        LPSTR headers)
{
    HRESULT    hr                = S_OK;
    DWORD      dwLen             = 0;
    DWORD      dwCode            = 0;
    char       szBuf    [1024]   = "";
    WCHAR      szBufW   [1024]   = L"";

    TRACE(L"myweb", L"in send headers");
    if(headers == NULL)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    m_strResponseHeaderA = (char *) MemAllocClear(strlen(headers) + 100);
    ON_OOM_EXIT(m_strResponseHeaderA);

    strcpy(m_strResponseHeaderA, headers);

    MultiByteToWideChar(CP_ACP, 0, m_strResponseHeaderA, -1, szBufW, 1024);
    TRACE(L"myweb", szBufW);        

    dwLen = sizeof(dwCode);
    hr = DealWithBuffer(m_strResponseHeaderA, (LPSTR) "MyWeb/1.0", HTTP_QUERY_STATUS_CODE, 
                        HTTP_QUERY_FLAG_NUMBER, &dwCode, &dwLen);

    if (hr == S_OK)
    {
        TRACE(L"myweb", L"found status code");        
        swprintf(szBufW, L"status code = %d in base 10", dwCode);
    }
    else
    {
        swprintf(szBufW, L"Did not find status code: hr = %d in base 10", hr);
    }

    TRACE(L"myweb", szBufW);

    m_fRedirecting = (dwCode == 302);

    if (m_fRedirecting)
    {
        TRACE(L"myweb", L"redirecting");

        dwLen = sizeof(szBuf) - 1;
        hr = DealWithBuffer(m_strResponseHeaderA, (LPSTR) "Location:", 0, 0, szBuf, &dwLen);

        if (hr == S_OK)
        {
            TRACE(L"myweb", L"found Location");        
        }
        else
        {
            swprintf(szBufW, L"Did not find location. hr = %d in base 10", hr);
        }

        if (hr != S_OK)
        {
            m_fRedirecting = FALSE;
            TRACE(L"myweb", L"redirecting: no location");
        }
    }

    SaveCookie(headers);

    if (m_fRedirecting == FALSE)
    {        
        TRACE(L"myweb", L"redirecting: no redirect");
        dwLen = sizeof(szBuf) - 1;
        hr = DealWithBuffer(m_strResponseHeaderA, (LPSTR) "Content-Type:", 0, 0, szBuf, &dwLen);
        if (hr != S_OK)
        {
            m_pProtocolSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, L"text/html");
        }
        else
        {

            LPSTR szSemiColon = strchr(szBuf, ';');
            if (szSemiColon != NULL)
                szSemiColon[0] = NULL;
            MultiByteToWideChar(CP_ACP, 0, szBuf, -1, szBufW, 1024);
            
            m_pProtocolSink->ReportProgress(BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE, szBufW);
        }
    }
    else
    {
        m_dwRefCount++; // HACK: When redirecting, for some reason, this is required
        int iPos = 0;
        if (strstr(szBuf, "://") == NULL)
        {
            if (szBuf[0] != '/')
            {
                wcscpy(szBufW, m_strUrl);
                WCHAR * p = wcsrchr(szBufW, L'/');
                if (p != NULL)
                {
                    p[1] = NULL;
                }                
            }
            else
            {
                wcscpy(szBufW, m_strUrl);
                WCHAR * p = wcschr(&szBufW[PROTOCOL_SCHEME_LEN], L'/');
                if (p != NULL)
                {
                    p[0] = NULL;
                }
            }

            iPos += wcslen(szBufW);            
        }
        

        MultiByteToWideChar(CP_ACP, 0, szBuf, -1, &szBufW[iPos], 1024 - iPos);

        m_pProtocolSink->ReportProgress(BINDSTATUS_REDIRECTING, szBufW);

        m_pProtocolSink->ReportResult(INET_E_REDIRECTING, 0, szBufW); 

        TRACE(L"myweb", szBufW);
        m_fDoneWithRequest = TRUE;
    }
    TRACE(L"myweb", L"out of send headers");

 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT 
PTProtocol::SaveCookie(
        LPSTR header)
{
    HRESULT hr = S_OK;
    LPSTR cookie, tail;
    WCHAR *cookieBody;
    int bodyLength;

    for(cookie = stristr(header, "Set-Cookie:");
        cookie != NULL;
        cookie = *tail ? stristr(tail, "Set-Cookie:") : NULL)
    {
        cookie += 11;
        while(*cookie && isspace(*cookie))
            cookie++;
        tail = cookie;
        while(*tail && *tail != '\r')
            tail++;
        bodyLength = tail - cookie;

        if(bodyLength)
        {
            cookieBody = (WCHAR *)MemAlloc(sizeof(WCHAR) *(bodyLength + 1));
            ON_OOM_EXIT(cookieBody);

            MultiByteToWideChar(CP_ACP, 0, cookie, bodyLength, cookieBody, bodyLength);
            cookieBody[bodyLength] = '\0';

            if(!g_pInternetSetCookieW(m_strCookiePath, NULL, cookieBody))
                EXIT_WITH_LAST_ERROR();
        }
    }
 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
PTProtocol::WriteBytes(
        BYTE *  buffer, 
        DWORD   dwLength)
{
    if (m_fRedirecting)
        return S_OK;

    HRESULT hr = S_OK;
    DWORD flags = 0;

    EnterCriticalSection(&m_csOutputWriter);

    if (!m_pOutputWrite)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    hr = m_pOutputWrite->Write(buffer, dwLength, &dwLength);
    ON_ERROR_EXIT();

    m_dwOutput += dwLength;

    if (!m_fStartCalled)
    {
        m_fStartCalled = TRUE;
        flags |= BSCF_FIRSTDATANOTIFICATION;
    }

    if (m_fDoneWithRequest)
    {
        flags |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
    }

    hr = m_pProtocolSink->ReportData(flags, dwLength, m_dwOutput);
    ON_ERROR_EXIT();

 Cleanup:
    LeaveCriticalSection(&m_csOutputWriter);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

int
PTProtocol::GetKnownRequestHeader (
        LPCWSTR  szHeader,
        LPWSTR   buf,
        int      size)
{
    TRACE(L"myweb", L"in GetKnownRequestHeader1");

    if (szHeader == NULL || szHeader[0] == NULL || wcslen(szHeader) > 256)
        return 0;

    TRACE(L"myweb", L"in GetKnownRequestHeader2");
    LPCWSTR  szReturn        = NULL;
    LPCWSTR  szStart         = NULL;
    int      iLen            = 0;
    HRESULT  hr              = S_OK;
    WCHAR    szHeadUpr[260]  = L"";

    wcscpy(szHeadUpr, szHeader);
    _wcsupr(szHeadUpr);

    if (wcscmp(szHeadUpr, L"COOKIE") == 0)
    {
        szReturn = m_strCookie;
        iLen = (m_strCookie ? wcslen(m_strCookie) : 0);
        goto Cleanup;
    }

    if (m_strRequestHeadersUpr == NULL && m_strRequestHeaders != NULL)
    {
        m_strRequestHeadersUpr = DuplicateString(m_strRequestHeaders);
        ON_OOM_EXIT(m_strRequestHeadersUpr);
        _wcsupr(m_strRequestHeadersUpr);
    }

    if (m_strRequestHeadersUpr == NULL)
        goto Cleanup;
        
    szStart = wcsstr(m_strRequestHeadersUpr, szHeadUpr);
    if (szStart == NULL)
        goto Cleanup;

    iLen = wcslen(szHeadUpr);
    szReturn = &(m_strRequestHeaders[iLen + 1 + (DWORD(szStart) - DWORD(m_strRequestHeadersUpr)) / sizeof(WCHAR)]);

    while(*szReturn == L' ')
        szReturn++;

    for (iLen = 0; szReturn[iLen] != L'\r' && szReturn[iLen] != NULL; iLen++);

 Cleanup:
    TRACE(L"myweb", L"out GetKnownRequestHeader");

    if (szReturn == NULL || iLen == 0)
        return 0;

    if (iLen >= size)
        return -(iLen + 1);

    buf[iLen] = NULL;
    memcpy(buf, szReturn, iLen*sizeof(WCHAR));
    return iLen;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOL
PTProtocol::CheckIfAdminUrl()
{
    if (_wcsicmp(m_strUrl, L"myweb:") == 0 || _wcsicmp(m_strUrl, L"myweb:/") == 0 || 
        _wcsicmp(m_strUrl, L"myweb://") == 0 || _wcsicmp(m_strUrl, L"myweb:///") == 0 ||
        _wcsicmp(m_strUrl, SZ_URL_ADMIN) == 0)
    {
        WCHAR szAll[1024];
        LPWSTR  szAdminDir = CMyWebAdmin::GetAdminDir();

        wcscpy(szAll, SZ_URL_ADMIN);
        if (szAdminDir && _wcsicmp(szAdminDir, SZ_INTERNAL_HANDLER))
            wcscat(szAll, SZ_URL_ADMIN_ASPX_DEFAULT);
        else
            wcscat(szAll, SZ_URL_ADMIN_AXD);

        MemFree(m_strUrl);
        m_strUrl = DuplicateString(szAll);
        return TRUE;
    }

    if (wcslen(m_strUrl) > wcslen(SZ_URL_ADMIN))
    {
        int iLen = wcslen(SZ_URL_ADMIN);
        WCHAR c = m_strUrl[iLen];
        m_strUrl[iLen] = NULL;
        int iCmp = _wcsicmp(m_strUrl, SZ_URL_ADMIN);
        m_strUrl[iLen] = c;
        if (iCmp == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// given the url like MyWeb://www.site.com/app/something/else?querystring=aa
// sets
//      m_strUriPath        to /app/something/else
//      m_strQueryString    to querystring=aa
//      m_strAppRoot        to /app or
//                         /app/something or 
//                         com/something/else,
//          depending on which was successfully mapped to 
//      m_strAppRootTranslated to, for instance, c:\program files\site app\
//      m_strAppOrigin      to www.site.com
//      m_strCookiePath     to myweb://www.site.com/app/something/else
//
// if application was not installed, attempts to install it
//
HRESULT
PTProtocol::ExtractUrlInfo()
{
    HRESULT hr = S_OK;
    WCHAR slash = L'/';
    WCHAR *p;
    WCHAR appRootTranslated[MAX_PATH];
    
    m_fAdminMode = CheckIfAdminUrl();
    
    // copy the cookie path into member variable
    m_strCookiePath = DuplicateString(m_strUrl);
    ON_OOM_EXIT(m_strCookiePath);

    // locate, store and strip query string, if any
    p = wcschr(m_strCookiePath, L'?');
    if(p != NULL)
    {
        m_strQueryString = p + 1;
        *p = L'\0';
    }

    // skip through blablabla:// 
    p = wcschr(m_strCookiePath, L':');
    if(p == NULL || p[1] != slash || p[2] != slash || p[3] == L'\0')  
        EXIT_WITH_HRESULT(E_INVALIDARG);

    // copy full origin path
    m_strAppOrigin = DuplicateString(p + 3);
    ON_OOM_EXIT(m_strAppOrigin);

    appRootTranslated[0] = NULL;

    if (m_fAdminMode == FALSE)
    {
        for(p = wcsrchr(m_strAppOrigin, slash); p != NULL && appRootTranslated[0] == NULL; p = wcsrchr(m_strAppOrigin, slash))
        {
            *p = L'\0';
            CMyWebAdmin::GetAppSettings(m_strAppOrigin, appRootTranslated, m_strAppDomain, &m_fTrusted);
        }
    }
    else
    {
        p = wcschr(m_strAppOrigin, slash);
        if (p != NULL)
            *p = NULL;

    }

    if(m_fAdminMode == FALSE && appRootTranslated[0] == L'\0')
    {
        WCHAR   szAll[1024];
        LPWSTR  szAdminDir = CMyWebAdmin::GetAdminDir();

        wcscpy(szAll, SZ_URL_ADMIN);
        if (szAdminDir && _wcsicmp(szAdminDir, SZ_INTERNAL_HANDLER))
            wcscat(szAll, SZ_URL_ADMIN_ASPX_INSTALL);
        else
            wcscat(szAll, SZ_URL_ADMIN_AXD);


        m_fAdminMode = TRUE;
        int iLen = wcslen(szAll) + wcslen(SZ_URL_ADMIN_INSTALL) + wcslen(m_strUrl) + 5;
        WCHAR * szTemp = (WCHAR *) MemAllocClear(iLen * sizeof(WCHAR) + 100);
        ON_OOM_EXIT(szTemp);
        wcscpy(szTemp, szAll);
        wcscat(szTemp, SZ_URL_ADMIN_INSTALL);
        if (wcslen(m_strUrl) > 8)
        {
            wcscat(szTemp, &m_strUrl[8]);
        }
        MemFree(m_strUrl);
        m_strUrl = szTemp;

        // copy the cookie path into member variable
        MemFree(m_strCookiePath);
        m_strCookiePath = DuplicateString(m_strUrl);
        ON_OOM_EXIT(m_strCookiePath);

        // locate, store and strip query string, if any
        m_strQueryString = wcschr(m_strCookiePath, L'?');
        m_strQueryString[0] = NULL;
        m_strQueryString++;

        // copy full origin path
        m_strAppOrigin = DuplicateString(&m_strUrl[PROTOCOL_SCHEME_LEN]);
        ON_OOM_EXIT(m_strAppOrigin);
        p = wcschr(m_strAppOrigin, slash);
        if (p != NULL)
            *p = NULL;
    }

    if (m_fAdminMode)
    {
        LPWSTR  szAdminDir = CMyWebAdmin::GetAdminDir();

        if (szAdminDir && _wcsicmp(szAdminDir, SZ_INTERNAL_HANDLER))
            wcscpy(appRootTranslated, szAdminDir); 
        else
            wcscpy(appRootTranslated, L"c:\\");
        
        TRACE(L"myweb", L"AdminDir is: ");
        TRACE(L"myweb", szAdminDir);
        wcscpy(m_strAppDomain, L"Admin");
    }

    m_strAppRootTranslated = DuplicateString(appRootTranslated);
    ON_OOM_EXIT(m_strAppRootTranslated);

    m_strAppRoot = m_strAppOrigin;
    /*
      m_strAppRoot = wcschr(m_strAppOrigin, slash);
      if(m_strAppRoot == NULL)
      m_strAppRoot = L"/";
    */  
    m_strUriPath = wcsstr(&m_strCookiePath[PROTOCOL_SCHEME_LEN], m_strAppRoot);            

    if (m_fAdminMode)
        m_fTrusted = TRUE;

 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

WCHAR *
PTProtocol::MapString(
   int key)
{
    switch(key)
    {
    case IEWR_URIPATH:
        return m_strUriPath;
    case IEWR_QUERYSTRING:
        return m_strQueryString;
    case IEWR_VERB:
        return m_strVerb;
    case IEWR_APPPATH:
        return m_strAppRoot;
    case IEWR_APPPATHTRANSLATED:
        return m_strAppRootTranslated;
    default:
        return NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

int
PTProtocol::GetStringLength(
        int key)
{
    WCHAR *targetString = MapString(key);
    return targetString ? lstrlen(targetString) + 1 : 0;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

int 
PTProtocol::GetString(
        int        key, 
        WCHAR *    buf, 
        int        size)
{
    WCHAR *targetString = MapString(key);
    int len; 

    if(targetString == NULL)
        return 0;

    len = lstrlen(targetString);

    if(len >= size)
        return 0;

    lstrcpy(buf, targetString);

    return len + 1;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

int
PTProtocol::MapPath(
        WCHAR *  virtualPath, 
        WCHAR *  physicalPath, 
        int      length)
{
    int requiredLength = lstrlen(m_strAppRootTranslated) + 2;
    int rootLength = lstrlen(m_strAppRoot);
    int i = 0;

    if(virtualPath && virtualPath[0] != '\0')
    {
        requiredLength += lstrlen(virtualPath) - rootLength;
    }

    if(requiredLength <= 0)
        return 0;

    if(requiredLength > length)
        return - requiredLength;

    while(m_strAppRootTranslated[i])
    {
        physicalPath[i] = m_strAppRootTranslated[i];
        i++;
    }

    if(virtualPath && virtualPath[0] != L'\0')
    {

        if(rootLength  > 0 && _memicmp(virtualPath, m_strAppRoot, sizeof(WCHAR) * rootLength))
            return 0;

        virtualPath += rootLength;
        if(*virtualPath && *virtualPath != L'/')
            physicalPath[i++] = L'\\';

        while(*virtualPath)
        {
            if(*virtualPath == L'/')
                physicalPath[i++] = L'\\';
            else
                physicalPath[i++] = *virtualPath;
            virtualPath++;
        }
    }

    physicalPath[i] = L'\0';

    return 1;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
PTProtocol::QueryOption(DWORD, LPVOID, DWORD*)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
PTProtocol::QueryInfo(
        DWORD        dwOption, 
        LPVOID       pBuffer, 
        LPDWORD      pcbBuf, 
        LPDWORD      , 
        LPDWORD      )
{
    if (pcbBuf == NULL)
        return E_FAIL;

    TRACE(L"myweb", L"in QueryInfo");


    HRESULT hr              = S_OK;
    LPSTR   szHeader        = NULL;
    LPSTR   szHeaders       = NULL;
    DWORD   dwOpt           = (dwOption & HTTP_QUERY_HEADER_MASK);
    DWORD   dwLen           = 0;

    if (m_strRequestHeaders != NULL && m_strRequestHeadersA == NULL)
    {
        int iLen = (wcslen(m_strRequestHeaders) + 1) * sizeof(WCHAR) + 100;
        m_strRequestHeadersA = (char *) MemAllocClear(iLen + 100);
        ON_OOM_EXIT(m_strRequestHeadersA);
        WideCharToMultiByte(CP_ACP, 0, m_strRequestHeaders, -1, m_strRequestHeadersA, iLen, NULL, NULL);        
    }

    szHeaders = ((dwOption & HTTP_QUERY_FLAG_REQUEST_HEADERS) ? m_strRequestHeadersA : m_strResponseHeaderA);

    if (szHeaders == NULL)
        return E_FAIL;

    dwLen = strlen(szHeaders);

    switch(dwOpt)
    {
    case HTTP_QUERY_RAW_HEADERS_CRLF: 
    case HTTP_QUERY_RAW_HEADERS:
        if (*pcbBuf < dwLen + 1)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }
        else
        {
            if (dwOpt == HTTP_QUERY_RAW_HEADERS_CRLF)
            {
                strcpy((char *) pBuffer, szHeaders);
            }
            else
            {
                DWORD iPos = 0;
                for(DWORD iter=0; iter<dwLen; iter++)
                    if (szHeaders[iter] == '\r' && szHeaders[iter+1] == '\n')
                    {
                        ((char *)pBuffer)[iPos++] = '0';
                        iter++;
                    }
                    else
                    {
                        ((char *)pBuffer)[iPos++] = szHeaders[iter];
                    }

                *pcbBuf = iPos;
            }
        }
        goto Cleanup;
    case HTTP_QUERY_ACCEPT:
        szHeader = "Accept:";
        break;
    case HTTP_QUERY_ACCEPT_CHARSET: 
        szHeader = "Accept-Charset:";
        break;
    case HTTP_QUERY_ACCEPT_ENCODING: 
        szHeader = "Accept-Encoding:";
        break;
    case HTTP_QUERY_ACCEPT_LANGUAGE: 
        szHeader = "Accept-Language:";
        break;
    case HTTP_QUERY_ACCEPT_RANGES: 
        szHeader = "Accept-Ranges:";
        break;
    case HTTP_QUERY_AGE: 
        szHeader = "Age:";
        break;
    case HTTP_QUERY_ALLOW: 
        szHeader = "Allow:";
        break;
    case HTTP_QUERY_AUTHORIZATION: 
        szHeader = "Authorization:";
        break;
    case HTTP_QUERY_CACHE_CONTROL: 
        szHeader = "Cache-Control:";
        break;
    case HTTP_QUERY_CONNECTION: 
        szHeader = "Connection:";
        break;
    case HTTP_QUERY_CONTENT_BASE: 
        szHeader = "Content-Base:";
        break;
    case HTTP_QUERY_CONTENT_DESCRIPTION: 
        szHeader = "Content-Description:";
        break;
    case HTTP_QUERY_CONTENT_DISPOSITION: 
        szHeader = "Content-Disposition:";
        break;
    case HTTP_QUERY_CONTENT_ENCODING: 
        szHeader = "Content-encoding:";
        break;
    case HTTP_QUERY_CONTENT_ID: 
        szHeader = "Content-ID:";
        break;
    case HTTP_QUERY_CONTENT_LANGUAGE: 
        szHeader = "Content-Language:";
        break;
    case HTTP_QUERY_CONTENT_LENGTH: 
        szHeader = "Content-Langth:";
        break;
    case HTTP_QUERY_CONTENT_LOCATION: 
        szHeader = "Content-Location:";
        break;
    case HTTP_QUERY_CONTENT_MD5: 
        szHeader = "Content-MD5:";
        break;
    case HTTP_QUERY_CONTENT_TRANSFER_ENCODING: 
        szHeader = "Content-Transfer-Encoding:";
        break;
    case HTTP_QUERY_CONTENT_TYPE: 
        szHeader = "Content-Type:";
        break;
    case HTTP_QUERY_COOKIE: 
        szHeader = "Cookie:";
        break;
    case HTTP_QUERY_COST: 
        szHeader = "Cost:";
        break;
    case HTTP_QUERY_CUSTOM: 
        szHeader = "Custom:";
        break;
    case HTTP_QUERY_DATE: 
        szHeader = "Date:";
        break;
    case HTTP_QUERY_DERIVED_FROM: 
        szHeader = "Derived-From:";
        break;
    case HTTP_QUERY_ECHO_HEADERS: 
        szHeader = "Echo-Headers:";
        break;
    case HTTP_QUERY_ECHO_HEADERS_CRLF: 
        szHeader = "Echo-Headers-Crlf:";
        break;
    case HTTP_QUERY_ECHO_REPLY: 
        szHeader = "Echo-Reply:";
        break;
    case HTTP_QUERY_ECHO_REQUEST: 
        szHeader = "Echo-Request:";
        break;
    case HTTP_QUERY_ETAG: 
        szHeader = "ETag:";
        break;
    case HTTP_QUERY_EXPECT: 
        szHeader = "Expect:";
        break;
    case HTTP_QUERY_EXPIRES: 
        szHeader = "Expires:";
        break;
    case HTTP_QUERY_FORWARDED: 
        szHeader = "Forwarded:";
        break;
    case HTTP_QUERY_FROM: 
        szHeader = "From:";
        break;
    case HTTP_QUERY_HOST: 
        szHeader = "Host:";
        break;
    case HTTP_QUERY_IF_MATCH: 
        szHeader = "If-Match:";
        break;
    case HTTP_QUERY_IF_MODIFIED_SINCE: 
        szHeader = "If-Modified-Since:";
        break;
    case HTTP_QUERY_IF_NONE_MATCH: 
        szHeader = "If-None-Match:";
        break;
    case HTTP_QUERY_IF_RANGE: 
        szHeader = "If-Range:";
        break;
    case HTTP_QUERY_IF_UNMODIFIED_SINCE:
        szHeader = "If-Unmodified-since:";
        break;
    case HTTP_QUERY_LINK:
        szHeader = "Link:";
        break;
    case HTTP_QUERY_LAST_MODIFIED: 
        szHeader = "Last-Modified:";
        break;
    case HTTP_QUERY_LOCATION: 
        szHeader = "Location:";
        break;
    case HTTP_QUERY_MAX_FORWARDS: 
        szHeader = "Max-Forwards:";
        break;
    case HTTP_QUERY_MESSAGE_ID: 
        szHeader = "Message_Id:";
        break;
    case HTTP_QUERY_MIME_VERSION: 
        szHeader = "Mime-Version:";
        break;
    case HTTP_QUERY_ORIG_URI: 
        szHeader = "Orig-Uri:";
        break;
    case HTTP_QUERY_PRAGMA: 
        szHeader = "Pragma:";
        break;
    case HTTP_QUERY_PROXY_AUTHENTICATE: 
        szHeader = "Authenticate:";
        break;
    case HTTP_QUERY_PROXY_AUTHORIZATION: 
        szHeader = "Proxy-Authorization:";
        break;
    case HTTP_QUERY_PROXY_CONNECTION: 
        szHeader = "Proxy-Connection:";
        break;
    case HTTP_QUERY_PUBLIC: 
        szHeader = "Public:";
        break;
    case HTTP_QUERY_RANGE: 
        szHeader = "Range:";
        break;
    case HTTP_QUERY_REFERER: 
        szHeader = "Referer:";
        break;
    case HTTP_QUERY_REFRESH: 
        szHeader = "Refresh:";
        break;
    case HTTP_QUERY_REQUEST_METHOD: 
        szHeader = "Request-Method:";
        break;
    case HTTP_QUERY_RETRY_AFTER: 
        szHeader = "Retry-After:";
        break;
    case HTTP_QUERY_SERVER: 
        szHeader = "Server:";
        break;
    case HTTP_QUERY_SET_COOKIE: 
        szHeader = "Set-Cookie:";
        break;
    case HTTP_QUERY_STATUS_CODE: 
        szHeader = "MyWeb/1.0"; // Special!!!
        break;
    case HTTP_QUERY_STATUS_TEXT: 
        szHeader = "MyWeb/1.0"; // Special!!!
        break;
    case HTTP_QUERY_TITLE: 
        szHeader = "Title:";
        break;
    case HTTP_QUERY_TRANSFER_ENCODING: 
        szHeader = "Transfer-Encoding:";
        break;
    case HTTP_QUERY_UNLESS_MODIFIED_SINCE: 
        szHeader = "Unless-Modified-Since:";
        break;
    case HTTP_QUERY_UPGRADE: 
        szHeader = "Upgrade:";
        break;
    case HTTP_QUERY_URI: 
        szHeader = "Uri:";
        break;
    case HTTP_QUERY_USER_AGENT: 
        szHeader = "User-Agent:";
        break;
    case HTTP_QUERY_VARY: 
        szHeader = "Vary:";
        break;
    case HTTP_QUERY_VERSION: 
        szHeader = "Version:";
        break;
    case HTTP_QUERY_VIA: 
        szHeader = "Via:";
        break;
    case HTTP_QUERY_WARNING: 
        szHeader = "Warning:";
        break;
    case HTTP_QUERY_WWW_AUTHENTICATE:
        szHeader = "WWW-Authenticate:";
        break;
    default:
        goto Cleanup;
    }

    if (dwOption & HTTP_QUERY_FLAG_SYSTEMTIME)
    {
        if (*pcbBuf < sizeof(SYSTEMTIME) || pBuffer == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto Cleanup;
        }
        else
        {
            LPSYSTEMTIME pSys = (LPSYSTEMTIME) pBuffer;
            GetSystemTime(pSys);
            *pcbBuf = sizeof(SYSTEMTIME);
            goto Cleanup;
        }
    }


    hr = DealWithBuffer(szHeaders, szHeader, dwOpt, dwOption, pBuffer, pcbBuf);
    if (hr == E_FAIL && szHeaders == m_strResponseHeaderA && m_strRequestHeadersA != NULL)
        hr = DealWithBuffer(m_strRequestHeadersA, szHeader, dwOpt, dwOption, pBuffer, pcbBuf);
        

 Cleanup:
    TRACE(L"myweb", L"out QueryInfo");
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
PTProtocol::DealWithBuffer(
        LPSTR    szHeaders, 
        LPSTR    szHeader, 
        DWORD    dwOpt, 
        DWORD    dwOption, 
        LPVOID   pBuffer, 
        LPDWORD  pcbBuf)
{
    if (szHeaders == NULL || szHeader == NULL || pBuffer == NULL || pcbBuf == NULL)
        return E_FAIL;

    LPSTR szValue = stristr(szHeaders, szHeader);
    if (szValue == NULL)
        return E_FAIL;

    DWORD dwStart  = strlen(szHeader);
    while(isspace(szValue[dwStart]) && szValue[dwStart] != '\r')
        dwStart++;

    DWORD dwEnd    = dwStart;
   
    switch(dwOpt)
    {
    case HTTP_QUERY_STATUS_CODE:
        dwEnd = dwStart + 3;
        break;
    case HTTP_QUERY_STATUS_TEXT:
        dwStart += 4;// Fall thru to default
        dwEnd = dwStart;
    default:
        while(szValue[dwEnd] != NULL && szValue[dwEnd] != '\r')
            dwEnd++;
        dwEnd--;
    }

    DWORD dwReq = (dwEnd - dwStart + 1);

    if ((dwOption & HTTP_QUERY_FLAG_NUMBER) && *pcbBuf < 4)
    {
        *pcbBuf = 4;
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);            
    }
    if ((dwOption & HTTP_QUERY_FLAG_NUMBER) == 0 && *pcbBuf < dwReq)
    {
        *pcbBuf = dwReq;
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER); 
    }
 

    if (dwOption & HTTP_QUERY_FLAG_NUMBER)
    {
        LPDWORD lpD = (LPDWORD) pBuffer;
        *lpD = atoi(&szValue[dwStart]);
        *pcbBuf = 4;
    }
    else
    {
        memcpy(pBuffer, &szValue[dwStart], dwReq);
        ((char *) pBuffer)[dwReq] = NULL;
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

LPWSTR
PTProtocol::CreateRequestHeaders(LPCWSTR  szHeaders)
{

    HRESULT   hr        = S_OK; 
    BOOL      fAddUA    = TRUE;
    BOOL      fAddHost  = TRUE;
    int       iLen      = 200;
    LPWSTR    szRet     = NULL;

    if (szHeaders != NULL)
    {
        iLen += wcslen(szHeaders) + 1;

        if (wcsstr(szHeaders, L"User-Agent:") != NULL)
            fAddUA = FALSE;

        if (wcsstr(szHeaders, L"Host:") != NULL)
            fAddHost = FALSE;
    }
        
    szRet  = (LPWSTR) MemAllocClear(iLen * sizeof(WCHAR) + 256);
    ON_OOM_EXIT(szRet);

    wcscat(szRet, L"SERVER_SOFTWARE: Microsoft-MyWeb/1.0\r\n");
    wcscat(szRet, L"HTTPS: OFF\r\n");

    if (fAddUA)
        wcscat(szRet, L"User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)\r\n");

    if (fAddHost)
    {
        DWORD dw1, dw2;
        wcscat(szRet, L"Host:");        
        dw1 = wcslen(szRet);
        dw2 = 100;
        GetComputerName(&szRet[dw1], &dw2);
        wcscat(szRet, L"\r\n");
    }

    if (szHeaders != NULL)
        wcscat(szRet, szHeaders);

 Cleanup:
    return szRet;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

int
PTProtocol::GetPostedDataSize()
{
    return (m_pInputData ? m_dwInputDataSize : 0);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

int
PTProtocol::GetPostedData(BYTE * buf, int iSize)
{
    if (m_dwInputDataSize < 1)
        return 1;
    if ((int) m_dwInputDataSize > iSize)
        return - int(m_dwInputDataSize);
    memcpy(buf, m_pInputData, m_dwInputDataSize);
    return 1;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\myweb\remove.cs ===
//------------------------------------------------------------------------------
// <copyright file="remove.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   remove.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace  System.Web.MyWebAdminUI {

  using System;
  using System.IO; 
  using System.Collections;
  using System.Web;
  using System.Web.Util;
  using System.Web.UI;
  using System.Web.UI.WebControls;
  using System.Web.UI.HtmlControls;

  /// <include file='doc\remove.uex' path='docs/doc[@for="removePage"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  public class removePage : Page {

    /// <include file='doc\remove.uex' path='docs/doc[@for="removePage.UrlHidden"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected HtmlInputHidden UrlHidden;
    /// <include file='doc\remove.uex' path='docs/doc[@for="removePage.AppName"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected Label AppName;
    
    /// <include file='doc\remove.uex' path='docs/doc[@for="removePage.remove"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public bool remove = false; 
		
    /// <include file='doc\remove.uex' path='docs/doc[@for="removePage.Page_Load"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public void Page_Load(Object sender, EventArgs e) 
    {
      if (!IsPostBack) 
      {
        String appurl = Request.QueryString["url"];
        MyWebApplication app = MyWeb.GetApplication(appurl);

		  if (app == null)
		  {
			  remove= false;
		  }
		
      if (app != null && appurl != null && appurl.Length>0) 
      {
        UrlHidden.Value = appurl;
        AppName.Text = (app.Manifest.Name.Length >0) ? (app.Manifest.Name):"myweb://"+(app.Manifest.ApplicationUrl);
        remove = true;
      }
    }
        
  }

  /// <include file='doc\remove.uex' path='docs/doc[@for="removePage.Submit_Click"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  public void Submit_Click(Object sender, EventArgs e) 
  {
    MyWebApplication app = MyWeb.GetApplication(UrlHidden.Value);

    String installedLocation = app.Manifest.InstalledLocation;
    String name = app.Manifest.Name;

    if ((name == null) && (name.Length == 0) )
    {
      name = app.Manifest.ApplicationUrl;
    }
  
  
    if (app != null)
    { 
      int remove = app.Remove();
    
      Response.Redirect("myweb://Home/myweb3.aspx?remove=" + remove.ToString() + "&installedLocation=" + installedLocation + "&name=" + name );
        
    }
  }
  }
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\myweb\mywebadminhandler.cs ===
//------------------------------------------------------------------------------
/// <copyright file="MyWebAdminHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**
 * Personal Tier Admin
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */


namespace System.Web.Handlers {
    using System.Text;
    using System.IO;
    using System.Collections;
    using System.Web;


    internal class MyWebAdminHandler : IHttpHandler {
        static private  readonly char[]     _strTab        = new char[] {'\t'};
        public virtual void ProcessRequest(HttpContext context) {
            String strAction = context.Request["Action"];
            if (strAction != null) {
                if (String.Compare(strAction, "remove", true, CultureInfo.InvariantCulture) == 0) {
                    RemoveApplication(context);
                }

                if (String.Compare(strAction, "move", true, CultureInfo.InvariantCulture) == 0) {
                    MoveApplication(context);
                    return;
                }

                if (String.Compare(strAction, "install", true, CultureInfo.InvariantCulture) == 0) {
                    InstallApplication(context);
                }

                if (String.Compare(strAction, "update", true, CultureInfo.InvariantCulture) == 0) {
                    UpdateApplication(context);
                }
            }
            ShowAdminPage(context);
        }

        private static void ShowAdminPage(HttpContext context) {
            HttpResponse Response = context.Response;
            context.Response.Write("<H1>Manage MyWeb Applications</H1>");
            MyWebApplication [] apps = MyWeb.GetInstalledApplications();
            if (apps == null || apps.Length < 1)
                context.Response.Write("No apps");
            else
                context.Response.Write("There are " + apps.Length + " installed apps");            

            if (apps != null)
                for (int iter=0; iter<apps.Length; iter++) {
                    Response.Write("<p>--------------------------------------------------<p>");
                    Response.Write("<b>Name: </b>" + apps[iter].Manifest.Name + "<br>");
                    Response.Write("<b>Location: </b>" + apps[iter].Manifest.InstalledLocation + "<br>");
                    Response.Write("<b>Url: </b>" + apps[iter].Manifest.Url + "<br>");
                    Response.Write("<b>IconUrl: </b>" + apps[iter].Manifest.IconUrl + "<br>");
                    Response.Write("<b>HelpUrl: </b>" + apps[iter].Manifest.HelpUrl + "<br>");
                    Response.Write("<b>DiskSize: </b>" + apps[iter].Manifest.Size + "<br>");
                    Response.Write("<b>Author: </b>" + apps[iter].Manifest.Author + "<br>");
                    Response.Write("<b>Source: </b>" + apps[iter].Manifest.Source + "<br>");
                    Response.Write("<b>Title: </b>" + apps[iter].Manifest.Title + "<br>");
                    Response.Write("<b>ManifestFile: </b>" + apps[iter].Manifest.ManifestFile + "<br>");
                    Response.Write("<b>Version: </b>" + apps[iter].Manifest.Version + "<br>");
                    Response.Write("<b>CabFile: </b>" + apps[iter].Manifest.CabFile + "<br>");
                    Response.Write("<b>License: </b>" + apps[iter].Manifest.License + "<br>");
                    Response.Write("<b>ApplicationUrl: </b>" + apps[iter].Manifest.ApplicationUrl + "<br>");
                    Response.Write("<b>RemoteIconUrl: </b>" + apps[iter].Manifest.RemoteIconUrl + "<br>");
                    Response.Write("<b>RemoteHelpUrl: </b>" + apps[iter].Manifest.RemoteHelpUrl + "<br>");

                    Response.Write("<a href=myweb://Home/myweb.axd?Action=remove&app=" + 
                                   apps[iter].Manifest.ApplicationUrl + 
                                   "><b>Remove this app</b></a> , ");            

                    Response.Write("<a href=myweb://Home/myweb.axd?Action=Move&app=" + 
                                   apps[iter].Manifest.ApplicationUrl + 
                                   "><b> Move this app</b></a>");

                    Response.Write("<a href=myweb://Home/myweb.axd?Action=update&app=" + 
                                   apps[iter].Manifest.ApplicationUrl + 
                                   "><b> Check for updates</b></a>");
                }

            Response.Write("<p>----------------------------------<p>");
            Response.Write("Install an app:");
            Response.Write("<form method=POST action=\"myweb://Home/myweb.axd\" >" +
                           "<input type=hidden name=\"Action\" value=\"install\" />" +
                           "<input type=text   name=\"app\"/>" +
                           "<input type=submit name=\"Submit\" value=\"Submit\"/>");
        }

        public bool IsReusable {
            get { return true; }
        }

        private static void RemoveApplication(HttpContext context) {
            String strApp = context.Request["app"];
            if (strApp == null)
                context.Response.Write("No app name");
            else {
                MyWebApplication app = MyWeb.GetApplication(strApp);
                if (app == null)
                    context.Response.Write("App not found");
                else {
                    app.Remove();
                    context.Response.Write("Removed app");
                }
            }
        }

        private static void MoveApplication(HttpContext context) {
            String strApp = context.Request["app"];
            if (strApp == null) {
                context.Response.Write("No app name");
                return;
            }
            String strLoc = context.Request["newlocation"];
            if (strLoc == null) {
                context.Response.Write("New location for app " + strApp + ": ");
                context.Response.Write("<form method=POST action=\"myweb://Home/myweb.axd\" >" +
                                       "<input type=hidden name=\"Action\" value=\"Move\" />" +
                                       "<input type=hidden name=\"app\" value=\"" + strApp + "\" />" +
                                       "<input type=text name=\"newlocation\" />" +
                                       "<input type=submit name=\"Move\" value=\"Move\"/>");
                return;
            }

            MyWebApplication app = MyWeb.GetApplication(strApp);
            if (app == null)
                context.Response.Write("App not found");
            else {
                if (app.Move(strLoc) == 0)
                    context.Response.Write("Moved app");
                else
                    context.Response.Write("Not able to move app");
            }
        }

        private static void InstallApplication(HttpContext context) {
            String strApp = context.Request["app"];
            if (strApp == null)
                context.Response.Write("No app name");
            else {
                if (MyWeb.GetApplication(strApp) != null)
                    context.Response.Write("App already exists");
                else {
                    MyWebManifest manifest = MyWeb.GetManifest(strApp);
                    if (manifest == null)
                        context.Response.Write("Manifest not found");
                    else {

                        if (manifest.Install() != null)
                            context.Response.Write("Installed successfully");
                        else
                            context.Response.Write("Couldnt install");
                    }
                }
            }
        }

        private static void UpdateApplication(HttpContext context) {
            String strApp = context.Request["app"];
            if (strApp == null) {
                context.Response.Write("No app name");
                return;
            }
            MyWebApplication app = MyWeb.GetApplication(strApp);
            if (app == null) {
                context.Response.Write("App not found");
                return;
            }

            MyWebManifest manifest = MyWeb.GetManifest(strApp);
            if (manifest == null) {
                context.Response.Write("manifest not found");
                return;
            }
            String strC = context.Request["confirmed"];
            if (strC == null || strC.Equals("y") == false) {
                context.Response.Write("Current installed version: " + app.Manifest.Version);
                context.Response.Write("<p>Version on server: " + manifest.Version);
                if (!manifest.Version.Equals(app.Manifest.Version))
                    context.Response.Write("<a href=\"myweb://Home/myweb.axd?Action=update&app=" + strApp +
                                           "&confirmed=y\"/> Update now (recommended) </a>");
                else
                    context.Response.Write("<a href=\"myweb://Home/myweb.axd?Action=update&app=" + strApp +
                                           "&confirmed=y\"/> Update now (not-recommended) </a>");
            }
            else {
                app.Remove();
                if (manifest.Install() != null) {
                    context.Response.Write("Successfully updated");
                }
                else {
                    context.Response.Write("couldnt update: app has been removed");
                }
            }            
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\npt\precomp.h ===
/**
 * Precompiled header for npt.
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

// Standard headers

#include <windows.h>
#include <objbase.h>
#include <httpext.h>
#include <shlwapi.h>
#include <malloc.h>

// XSP Headers

#include "dbg.h"
#include "util.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\myweb\update.cs ===
//------------------------------------------------------------------------------
// <copyright file="update.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   update.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace  System.Web.MyWebAdminUI {

  using System;
  using System.Data;
  using System.IO; 
  using System.Collections;
  using System.Web;
  using System.Web.Util;
  using System.Web.UI;
  using System.Web.UI.WebControls;
  using System.Web.UI.HtmlControls;

  /// <include file='doc\update.uex' path='docs/doc[@for="updatePage"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  public class updatePage : Page {

    /// <include file='doc\update.uex' path='docs/doc[@for="updatePage.UrlHidden"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected HtmlInputHidden UrlHidden;
    /// <include file='doc\update.uex' path='docs/doc[@for="updatePage.AppName"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected Label AppName;
    /// <include file='doc\update.uex' path='docs/doc[@for="updatePage.OldVersion"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected Label OldVersion;
    /// <include file='doc\update.uex' path='docs/doc[@for="updatePage.NewVersion"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected Label NewVersion;

    /// <include file='doc\update.uex' path='docs/doc[@for="updatePage.update"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public bool update = false;

    /// <include file='doc\update.uex' path='docs/doc[@for="updatePage.Page_Load"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public void Page_Load(Object sender, EventArgs e) 
    {
	    if (!IsPostBack) 
	    {
        String appurl = Request.QueryString["url"];
        MyWebApplication app = MyWeb.GetApplication(appurl);

		    //checking if local
		
		    if(app.LocalApplication)
		    {
		      Response.Redirect("myweb://Home/myweb2.aspx?success=local" );
		    }
		    else if (app != null && appurl != null && appurl.Length>0) 
		    {
          UrlHidden.Value = appurl;
          AppName.Text =(app.Manifest.Name.Length >0) ? (app.Manifest.Name):"the Local Application selected";;
			    String oldVersion = app.Manifest.Version;
			    oldVersion = oldVersion.ToLower(CultureInfo.InvariantCulture);
			    MyWebManifest newManifest = MyWeb.GetManifest(appurl);

			    if(newManifest == null)
			    {
				    Response.Redirect("myweb://Home/myweb2.aspx?success=notfound");
			    }

			    else
			    {
				    String newVersion = newManifest.Version;
				    newVersion = newVersion.ToLower(CultureInfo.InvariantCulture);
					
				    if (!oldVersion.Equals(newVersion) )
				    {	
					    update=true;
					    NewVersion.Text = newVersion;
					    OldVersion.Text = oldVersion;
				    }
			    }
        }
      }
    }

    /// <include file='doc\update.uex' path='docs/doc[@for="updatePage.Submit_Click"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public void Submit_Click(Object sender, EventArgs e) 
    {
      MyWebApplication app = MyWeb.GetApplication(UrlHidden.Value);

      String installedLocation = app.Manifest.InstalledLocation;

      String name = app.Manifest.Name;
  
      if (app != null)
      {	

        int update = app.Update();

        Response.Redirect("myweb://Home/myweb2.aspx?name=" + name + "&success=" + update.ToString() + "&URL=" + UrlHidden.Value + "&installedLocation=" + installedLocation);     

      }
      else if (app ==null)
      {
        Response.Redirect("myweb://Home/myweb2.aspx?name=" + name + "&success=NoApp");
      }
            
    }

  }
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\npt\ptprot.cxx ===
/**
 * Asynchronous pluggable protocol for personal tier
 *
 * Copyright (C) Microsoft Corporation, 1999
 */

#include "precomp.h"
#include "ptprot.h"
#include "ndll.h"

#pragma warning(disable:4100)

GUID CLSID_CDwnBindInfo = { 0x3050f3c2, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b };
GUID IID_IDwnBindInfo =   { 0x3050f3c3, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b };


// External Functions

DWORD __stdcall HttpExtensionProc(EXTENSION_CONTROL_BLOCK *pEcb);
BOOL __stdcall GetExtensionVersion(HSE_VERSION_INFO *pVersionInfo);
BOOL __stdcall TerminateExtension(DWORD);

// Definitions

#define TAG TAG_INTERNAL

// Global variables

CLSID CLSID_PTProtocol = { 0x03be83e6, 0xaf00, 0x11d2, {0xb8, 0x7c, 0x00, 0xc0, 0x4f, 0x8e, 0xfc, 0xbf}};
BOOL g_Started = FALSE;
char g_UserAgent[128];
PTProtocolFactory g_PTProtocolFactory;

BOOL (WINAPI *g_pInternetSetCookie)(LPCSTR, LPCSTR, LPCSTR) = NULL;
BOOL (WINAPI *g_pInternetGetCookie)(LPCSTR, LPCSTR, LPSTR, LPDWORD) = NULL;

/**
 * Setup for first time use in process.
 */
HRESULT
InitializePTProtocol()
{
    HRESULT hr = S_OK;
    IInternetSession *pSession = NULL;
    HMODULE hWinInet;

    if(!g_Started) 
    {

        HSE_VERSION_INFO info;
        GetExtensionVersion(&info);

        DWORD dw = ARRAY_SIZE(g_UserAgent);
        hr = ObtainUserAgentString(0, g_UserAgent, &dw);
        ON_ERROR_EXIT();

        // Register with the UrlMON session. This will keep us alive 
        // across invocations. Consider registering as property on 
        // IWebBrowserApp::PutProperty. IWebBrowserApp will time out 
        // the reference.

        hr = CoInternetGetSession(0, &pSession, 0);
        ON_ERROR_EXIT();

        hr = pSession->RegisterNameSpace(&g_PTProtocolFactory, CLSID_PTProtocol, L"xsp", 0, NULL, 0);
        ON_ERROR_EXIT();

        // Obtain GetCookie/SetCookie entry points from WININET.DLL
        hWinInet = GetModuleHandle(L"WININET.DLL");
        if(hWinInet == NULL)
            hWinInet = LoadLibrary(L"WININET.DLL");
        if(hWinInet == NULL)
            EXIT_WITH_LAST_ERROR();

        g_pInternetSetCookie = (BOOL (WINAPI *)(LPCSTR, LPCSTR, LPCSTR))
            GetProcAddress(hWinInet, "InternetSetCookieA");
        g_pInternetGetCookie = (BOOL (WINAPI *)(LPCSTR, LPCSTR, LPSTR, LPDWORD))
            GetProcAddress(hWinInet, "InternetGetCookieA");

        g_Started = TRUE;
    }
Cleanup:
    ReleaseInterface(pSession);
    return hr;
}

/**
 * Cleanup for process shutdown.
 */
void
TerminatePTProtocol()
{
    // TODO: This is never called. Figure out how to get proper shutdown. Consider possible refcount leaks.

    if (g_Started)
    {
        TerminateExtension(0);
        g_Started = FALSE;
    }
}

/**
 * Convert an XSP Url to a FILE: url.
 */

HRESULT
CreateFileUrl(const WCHAR *xspUrl, WCHAR **ppFileUrl)
{
    HRESULT hr = S_OK;

    int len;
    const WCHAR * start;

    start = wcschr(xspUrl, L':');

    if (start != NULL)
    {
        start = start + 1;
    }
    else
    {
        start = xspUrl;
    }

    len = lstrlen(start);

    *ppFileUrl = (WCHAR *)MemAlloc((len + sizeof("file:") + 1) * sizeof(WCHAR));
    ON_OOM_EXIT(*ppFileUrl);

    memcpy(*ppFileUrl, L"file:", 5 * sizeof(WCHAR));
    memcpy(*ppFileUrl + 5, start, len * sizeof(WCHAR));
    (*ppFileUrl)[5 + len] = 0;

Cleanup:
    return hr;
}

HRESULT
CreatePathInfo(const WCHAR *url, CHAR **ppPathInfo, DWORD cp)
{
	HRESULT hr = S_OK;
	CHAR *src, *dst;
	DWORD dwLen;

	if(((url[0] == L'f' || url[0] == L'F') &&
	   (url[1] == L'i' || url[1] == L'I') &&
	   (url[2] == L'l' || url[2] == L'L') &&
	   (url[3] == L'e' || url[3] == L'E') &&
	   (url[4] == L':') && (url[5] == L'/') && (url[6] == L'/'))) {

		// "file://" prefix found, skip it
		url += 7;
	}

	dwLen = lstrlen(url) + 1;
	*ppPathInfo = (CHAR *) MemAlloc(dwLen * 2);
	ON_OOM_EXIT(*ppPathInfo);
	(*ppPathInfo)[0] = 0;

	WideCharToMultiByte(cp, 0, url, dwLen, *ppPathInfo, dwLen * 2, NULL, NULL);

	// convert all backslashes to slashes
	src = dst = *ppPathInfo;
	while(*src)
	{
		*src = *dst;
		if(*src == '\\')
			*dst = '/';
		else
			*dst = *src;
		src++;
		dst++;
	}

Cleanup:
	return hr;
}

// Class PTProtocol

PTProtocol::PTProtocol(IUnknown *pUnkOuter)
{
    _refs = 1;
    _pUnkOuter = pUnkOuter ? pUnkOuter : (IUnknown *)(IPrivateUnknown *)this;
    _hFile = INVALID_HANDLE_VALUE;
	_cookie = NULL;
	_xspUrl = NULL;
    ZeroMemory(&_ECB, sizeof(_ECB));
    InitializeCriticalSection(&_csOutputWriter);
}

PTProtocol::~PTProtocol()
{
	MemFree(_cookie);
	MemFree(_xspUrl);
    MemFree(_ECB.lpszPathInfo);
    MemFree(_ECB.lpszPathTranslated);
    MemFree(_ECB.lpszMethod);
    MemFree(_ECB.lpszContentType);
    MemFree(_ECB.lpszQueryString);
    Cleanup();
}

void
PTProtocol::Cleanup()
{
    if (_hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_hFile);
        _hFile = INVALID_HANDLE_VALUE;
    }

    ClearInterface(&_pOutputRead);
    ClearInterface(&_pOutputWrite);
    ClearInterface(&_pProtocolSink);
    ClearInterface(&_pBindInfo);
    ClearInterface(&_pHttpNegotiate);

    _done = true;

    if (_bindinfo.cbSize)
    {
        ReleaseBindInfo(&_bindinfo);
        ZeroMemory(&_bindinfo, sizeof(_bindinfo));
    }

    DeleteCriticalSection(&_csOutputWriter);
}

ULONG
PTProtocol::PrivateAddRef()
{
    return _refs += 1;
}

ULONG
PTProtocol::PrivateRelease()
{
    if (--_refs > 0)
        return _refs;

    delete this;
    return 0;
}

HRESULT
PTProtocol::PrivateQueryInterface(
    REFIID iid, 
    void **ppv)
{
    *ppv = NULL;

    if (iid == IID_IInternetProtocol ||
        iid == IID_IInternetProtocolRoot)
    {
        *ppv = (IInternetProtocol *)this;
    }
    else if (iid == IID_IUnknown)
    {
        *ppv = (IUnknown *)(IPrivateUnknown *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

ULONG
PTProtocol::AddRef()
{
    _pUnkOuter->AddRef();
    return PrivateAddRef();
}

ULONG
PTProtocol::Release()
{
    _pUnkOuter->Release();
    return PrivateRelease();
}

HRESULT
PTProtocol::QueryInterface(
    REFIID iid, 
    void **ppv)
{
    return _pUnkOuter->QueryInterface(iid, ppv);
}

// InternetProtocol

HRESULT
PTProtocol::Start(
        LPCWSTR url,
        IInternetProtocolSink *pProtocolSink,
        IInternetBindInfo *pBindInfo,
        DWORD grfSTI,
        DWORD )
{

    HRESULT hr = S_OK;
    WCHAR * fileUrl = NULL;
    WCHAR   fileName[MAX_PATH];
    CHAR  * mimeType = NULL;
    DWORD   dw;
    DWORD   cookieSize;
    WCHAR * query;
    PROTOCOLDATA protData;
    WCHAR *Strings[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    DWORD cStrings = ARRAY_SIZE(Strings);

    if (grfSTI & PI_PARSE_URL)
        goto Cleanup;

    if (!pProtocolSink)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    _grfSTI = grfSTI;
    ReplaceInterface(&_pProtocolSink, pProtocolSink);
    ReplaceInterface(&_pBindInfo, pBindInfo);

    // Get MIME type from binding

    hr = pBindInfo->GetBindString(BINDSTRING_POST_DATA_MIME, 
            Strings, cStrings, &cStrings);
    if(hr == S_OK && cStrings)
    {
        DWORD i;

        mimeType = DupStrA(Strings[0]);
        ON_OOM_EXIT(mimeType);

		/*
        _mimeType = (WCHAR *)MemAlloc((strlen(mimeType) + 1) * sizeof(WCHAR));
        ON_OOM_EXIT(_mimeType);
        wsprintf(_mimeType, L"%S", mimeType);
		*/

        for(i = 0; i < cStrings; i++)
            CoTaskMemFree(Strings[i]);
    }


    _bindinfo.cbSize = sizeof(BINDINFO);
    if (pBindInfo)
    {
        hr = pBindInfo->GetBindInfo(&_bindf, &_bindinfo);
        ON_ERROR_EXIT();
    }

    if (_bindinfo.dwCodePage == 0)
        _bindinfo.dwCodePage = CP_ACP;

    // Convert to a file Url for call to PathCrateFromUrl below.

    hr = CreateFileUrl(url, &fileUrl);
    ON_ERROR_EXIT();

    if(0){

		// we were trying to get to headers in MSHtml (but failed)

        IServiceProvider *pServiceProvider;
        IHttpNegotiate *pHttpNegotiate;


        hr = pBindInfo->QueryInterface(IID_IServiceProvider, (void **) &pServiceProvider);
        if(hr == S_OK && pServiceProvider)
        {
            hr = pServiceProvider->QueryService(IID_IDwnBindInfo, IID_IDwnBindInfo, (void **) &pHttpNegotiate);
            if(hr == S_OK && pHttpNegotiate) {
                WCHAR *pExtraHeaders = NULL;
                hr = pHttpNegotiate->BeginningTransaction(url, NULL, 0, &pExtraHeaders);
                if(hr == S_OK && pExtraHeaders)
                {
                    CoTaskMemFree(pExtraHeaders);
                }
            }

            hr = pServiceProvider->QueryService(IID_IHttpNegotiate, IID_IDwnBindInfo, (void **) &pHttpNegotiate);
            if(hr == S_OK && pHttpNegotiate) {
                WCHAR *pExtraHeaders = NULL;
                hr = pHttpNegotiate->BeginningTransaction(url, NULL, 0, &pExtraHeaders);
                if(hr == S_OK && pExtraHeaders)
                {
                    CoTaskMemFree(pExtraHeaders);
                }
            }

            hr = pServiceProvider->QueryService(IID_IHttpNegotiate, IID_IHttpNegotiate, (void **) &pHttpNegotiate);
            if(hr == S_OK && pHttpNegotiate)
            {
                WCHAR *pExtraHeaders = NULL;
                IHttpNegotiate *pHttpNegotiate2;

                hr = pHttpNegotiate->BeginningTransaction(url, NULL, 0, &pExtraHeaders);
                if(hr == S_OK && pExtraHeaders)
                {
                    CoTaskMemFree(pExtraHeaders);
                }

                hr = pHttpNegotiate->QueryInterface(IID_IDwnBindInfo, (void **) &pHttpNegotiate2);
                if(pHttpNegotiate2) 
                {
                    hr = pHttpNegotiate2->BeginningTransaction(url, NULL, 0, &pExtraHeaders);
                    if(hr == S_OK && pExtraHeaders)
                    {
                        CoTaskMemFree(pExtraHeaders);
                    }
                    pHttpNegotiate2->Release();
                }

                pHttpNegotiate->Release();
            }
            pServiceProvider->Release();
        }
    }
    

    // Chop the query string off the Url.

    query = wcschr(fileUrl, L'?');
    if (query != NULL)
    {
        *query = NULL;
        query += 1;
    }
    else
    {
        query = L"";
    }

    // Get the file name from the Url. We build a file
    // Url because PathCreateFromUrl ignores Urls without the
    // "file:" scheme.  This would all be much easier if we
    // could get at the BreakParts and BuildDosPath functions
    // inside of SHLWAPI.DLL.
    
    dw = ARRAY_SIZE(fileName);
    hr = PathCreateFromUrl(fileUrl, fileName, &dw, 0);
    ON_ERROR_EXIT();


    if ((dw > 3 && wcscmp(fileName + dw - 4, L".xsp") == 0) ||
        (dw > 4 && wcscmp(fileName + dw - 5, L".aspx") == 0))
    {
        // It's an XSP file. Fill out the ECB for later processing.

        _ECB.cbSize                 = sizeof(_ECB);
        _ECB.dwVersion              = MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR);
        _ECB.ConnID                 = (HCONN) this;
        _ECB.dwHTTPStatusCode       = 200;
        _ECB.GetServerVariable      = GetServerVariable;
        _ECB.WriteClient            = WriteClient;
        _ECB.ReadClient             = ReadClient;
        _ECB.lpszContentType        = mimeType;
        _ECB.ServerSupportFunction  = ServerSupportFunction;
        _ECB.lpszLogData[0]         = '\0';

        hr = CreatePathInfo(fileUrl, &_ECB.lpszPathInfo, _bindinfo.dwCodePage);
		ON_ERROR_EXIT();

		_xspUrl = DupStrA(fileUrl, _bindinfo.dwCodePage);
		ON_OOM_EXIT(_xspUrl);

		cookieSize = 0;
		
		if(g_pInternetGetCookie(_xspUrl, NULL, NULL, &cookieSize) && cookieSize)
	    {
			_cookie = (CHAR *)MemAlloc(++cookieSize);
			ON_OOM_EXIT(_cookie);
			g_pInternetGetCookie(_xspUrl, NULL, _cookie, &cookieSize);
	    }

        _ECB.lpszQueryString = DupStrA(query, _bindinfo.dwCodePage);
        ON_OOM_EXIT(_ECB.lpszQueryString);

        _ECB.lpszPathTranslated = DupStrA(fileName, _bindinfo.dwCodePage);
        ON_OOM_EXIT(_ECB.lpszPathTranslated);

        // Input data

        if (_bindinfo.stgmedData.tymed == TYMED_HGLOBAL)
        {
            _ECB.cbTotalBytes = _bindinfo.cbstgmedData;
            _ECB.cbAvailable = _bindinfo.cbstgmedData;
            _ECB.lpbData = (BYTE *)_bindinfo.stgmedData.hGlobal;
        }
        else if (_bindinfo.stgmedData.tymed == TYMED_ISTREAM)
        {
            STATSTG statstg;

            ReplaceInterface(&_pInputRead, _bindinfo.stgmedData.pstm);

            if(_pInputRead) 
            {
                hr = _pInputRead->Stat(&statstg, STATFLAG_NONAME);
                if(hr == S_OK)
                    _ECB.cbTotalBytes = statstg.cbSize.LowPart;
                else
                    _ECB.cbTotalBytes = (DWORD)-1;
            }

        }

        // Verb

        switch (_bindinfo.dwBindVerb)
        {
            case BINDVERB_GET:  
                _ECB.lpszMethod = DupStr("GET");  
                break;

            case BINDVERB_POST: 
                _ECB.lpszMethod = DupStr("POST"); 
                break;

            case BINDVERB_PUT:  
                _ECB.lpszMethod = DupStr("PUT");  
                break;

            default:
                if (_bindinfo.szCustomVerb == NULL || _bindinfo.dwBindVerb != BINDVERB_CUSTOM)
                {
                    _ECB.lpszMethod = DupStr("GET");
                }
                else
                {
                    _ECB.lpszMethod = DupStrA(_bindinfo.szCustomVerb); 
                    ON_OOM_EXIT(_ECB.lpszMethod);
                }
                break;
        }

        hr = CreateStreamOnHGlobal(NULL, true, &_pOutputWrite);
        ON_ERROR_EXIT();

        hr = _pOutputWrite->Clone(&_pOutputRead);
        ON_ERROR_EXIT();

        protData.dwState = 1;
    }
    else
    {
        // It's a file.  Open it for later processing.
        _hFile = CreateFile(fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);
        if (_hFile == INVALID_HANDLE_VALUE)
            EXIT_WITH_LAST_ERROR();

        GetFileMimeType(fileName);

        protData.dwState = 2;
    }

    protData.grfFlags = PI_FORCE_ASYNC;
    protData.pData = NULL;
    protData.cbData = 0;

    pProtocolSink->Switch(&protData);
    hr = E_PENDING;

Cleanup:
    MemFree(fileUrl);
    return hr;
}

HRESULT
PTProtocol::Continue(
    PROTOCOLDATA *pProtData)
{
    HRESULT hr = S_OK;
    DWORD result;

    switch (pProtData->dwState)
    {
        case 1: 

            // TODO: Cleanup handling of MIME type.

            if (_mimeType && *_mimeType)
                _pProtocolSink->ReportProgress(BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE, _mimeType);
            else
                _pProtocolSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, L"text/html");

            result = HttpExtensionProc(&_ECB);
            if (result != HSE_STATUS_PENDING)
                hr = Finish();

            break;

        case 2:
            {
                // TODO: use real file protocol instead of this.
                DWORD cb;

                _started = TRUE;

                
                if (_mimeType && *_mimeType)
                    _pProtocolSink->ReportProgress(BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE, _mimeType);
                else
                    _pProtocolSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, L"text/html");


                cb = GetFileSize(_hFile, NULL);
                hr = _pProtocolSink->ReportData(BSCF_FIRSTDATANOTIFICATION | BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE, cb, cb);

                Finish();
            }

            break;

        default: 
            EXIT_WITH_HRESULT(E_FAIL);
            break;
    }
        
Cleanup:
    return hr;
}

HRESULT 
PTProtocol::Finish()
{
    HRESULT hr = S_OK;

    if (!_done)
    {
        _done = TRUE;

        _pProtocolSink->ReportData(BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE, 0, _cbOutput);

        if (!_aborted)
            _pProtocolSink->ReportResult(S_OK, 0, NULL);
    }
    return hr;
}

HRESULT
PTProtocol::Abort(
    HRESULT hrReason,
    DWORD )
{
    HRESULT hr = S_OK;

    _aborted = true;
    if (_pProtocolSink)
    {
        hr = _pProtocolSink->ReportResult(hrReason, 0, 0);
        ON_ERROR_EXIT();
    }

Cleanup:
    return hr;
}

HRESULT
PTProtocol::Terminate(
    DWORD )
{
    Cleanup();
    return S_OK;
}

HRESULT
PTProtocol::Suspend()
{
    return E_NOTIMPL;
}

HRESULT
PTProtocol::Resume()
{
    return E_NOTIMPL;
}

HRESULT
PTProtocol::Read(
    void *pv, 
    ULONG cb, 
    ULONG *pcbRead)
{
    HRESULT hr = S_OK;

    if (_hFile != INVALID_HANDLE_VALUE)
    {
        BOOL result = ReadFile(_hFile, pv, cb, pcbRead, NULL);
        if (!result)
            hr = GetLastWin32Error();
    }
    else
    {
        hr = _pOutputRead->Read(pv, cb, pcbRead);
    }

    // We must only return S_FALSE when we have hit the absolute end of the stream
    // If we think there is more data coming down the wire, then we return E_PENDING
    // here. Even if we return S_OK and no data, UrlMON will still think we've hit
    // the end of the stream.

    if (S_OK == hr && 0 == *pcbRead)
    {
        hr = _done ? S_FALSE : E_PENDING;
    }
																		
    return hr;
}

HRESULT
PTProtocol::Seek(
    LARGE_INTEGER offset, 
    DWORD origin, 
    ULARGE_INTEGER *pPos)
{
    return _pOutputRead->Seek(offset, origin, pPos);
}

HRESULT
PTProtocol::LockRequest(
    DWORD )
{
    return S_OK;
}

HRESULT
PTProtocol::UnlockRequest()
{
    return S_OK;
}

HRESULT
PTProtocol::CopyServerVariable(
    void *buffer, 
    DWORD *pSize, 
    char *value)
{
    HRESULT hr = S_OK;

    DWORD size = strlen(value) + 1;

    if (size <= *pSize && buffer != NULL)
    {
        CopyMemory(buffer, value, size);
        *pSize = size;
    }
    else
    {
        if (buffer)
            CopyMemory(buffer, value, *pSize);

        *pSize = size;

        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

    return hr;
}

HRESULT
PTProtocol::CopyServerVariable(
    void *buffer, 
    DWORD *pSize, 
    WCHAR *value,
    UINT cp)
{
    HRESULT hr = S_OK;
    int size = 0;

    if (*pSize > 0)
    {
        size = WideCharToMultiByte(cp, 0, value, -1, (char *)buffer, *pSize, NULL, NULL);
    }

    if (*pSize == 0 || size == 0)
    {
        *pSize = WideCharToMultiByte(cp, 0, value, -1, NULL, 0, NULL, NULL);
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

    return hr;
}

HRESULT
PTProtocol::CopyServerVariable(
    void *buffer,
    DWORD *pSize,
    BINDSTRING name)
{
    HRESULT hr;
    WCHAR * value[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    ULONG   numValue = ARRAY_SIZE(value);

    hr = _pBindInfo->GetBindString(name, value, ARRAY_SIZE(value), &numValue);
    ON_ERROR_EXIT();

    hr = CopyServerVariable(buffer, pSize, value[0]);
    ON_ERROR_EXIT();

Cleanup:
    for (int i = 0; i < ARRAY_SIZE(value); i++)
        CoTaskMemFree(value[i]);

    return hr;
}

/**
 * Returns environment variable value.
 */
HRESULT 
PTProtocol::GetServerVariable(
    char* name,
    void * buffer,
    DWORD *pSize
    )
{
    HRESULT hr = S_OK;

    ASSERT(name);
    
    if (strcmp(name, "ALL_HTTP") == 0)
    {
        // TODO: build this from the real headers.
        hr = CopyServerVariable(
                buffer,
                pSize,
                "HTTP_ACCEPT:*/*\r\n"
                "HTTP_ACCEPT_LANGUAGE:en-us\r\n"
                "HTTP_CONNECTION:Keep-Alive\r\n"
                "HTTP_HOST:localhost\r\n"
                "HTTP_USER_AGENT:random\r\n"
                "HTTP_ACCEPT_ENCODING:gzip, deflate\r\n"
                );
    }
    else if (strcmp(name, "ALL_RAW") == 0)
    {
        // TODO: build this from the real headers.
        hr = CopyServerVariable(
                buffer, 
                pSize,
                "Accept: */*\r\n"
                "Accept-Language: en-us\r\n"
                "Connection: Keep-Alive\r\n"
                "Host: localhost\r\n"
                "User-Agent: random\r\n"
                "Accept-Encoding: gzip, deflate\r\n"
                );
    }
    else if (strcmp(name, "APPL_MD_PATH") == 0)
    {
        hr = CopyServerVariable(buffer, pSize, "/LM/W3SVC/1/Root");
    }
    else if (strcmp(name, "APPL_PHYSICAL_PATH") == 0) 
    {
        char tmppath[MAX_PATH];

        strcpy(tmppath, _ECB.lpszPathTranslated);
        char *p = strrchr(tmppath, '\\');
        if(p != NULL) 
        {
            *p = '\0';
        }
        hr = CopyServerVariable(buffer, pSize, tmppath);

    }
    else if (strcmp(name, "PATH_INFO") == 0) 
    {
        hr = CopyServerVariable(buffer, pSize, _ECB.lpszPathInfo);
    }
    else if (strcmp(name, "PATH_TRANSLATED") == 0) 
    {
        hr = CopyServerVariable(buffer, pSize, _ECB.lpszPathTranslated);
    }
    else if (strcmp(name, "QUERY_STRING") == 0) 
    {
        hr = CopyServerVariable(buffer, pSize, _ECB.lpszQueryString);
    }
    else if (strcmp(name, "REMOTE_ADDR") == 0 ||
             strcmp(name, "LOCAL_ADDR") == 0 ||
             strcmp(name, "REMOTE_HOST") == 0)
    {
        hr = CopyServerVariable(buffer, pSize, "127.0.0.1");
    }
    else if (strcmp(name, "REQUEST_METHOD") == 0) 
    {
        hr = CopyServerVariable(buffer, pSize, _ECB.lpszMethod);
    }
    else if (strcmp(name, "SCRIPT_NAME") == 0) 
    {
        hr = CopyServerVariable(buffer, pSize, _ECB.lpszPathInfo);
    }
    else if (strcmp(name, "SERVER_NAME") == 0 ||
             strcmp(name, "HTTP_HOST") == 0 ||
             strcmp(name, "REMOTE_HOST") == 0)
    {
        hr = CopyServerVariable(buffer, pSize, "localhost");
    }
    else if (strcmp(name, "SERVER_PORT") == 0) 
    {
        hr = CopyServerVariable(buffer, pSize, "80");
    }
    else if (strcmp(name, "URL") == 0) 
    {
        hr = CopyServerVariable(buffer, pSize, _ECB.lpszPathInfo);
    }
    else if (strcmp(name, "HTTP_ACCEPT") == 0) 
    {
        hr = CopyServerVariable(buffer, pSize, BINDSTRING_ACCEPT_MIMES);
    }
    else if (strcmp(name, "HTTP_ACCEPT_LANGUAGE") == 0) 
    {
        hr = CopyServerVariable(buffer, pSize, BINDSTRING_LANGUAGE);
    }
    else if (strcmp(name, "HTTP_CONNECTION") == 0) 
    {
        hr = CopyServerVariable(buffer, pSize, "Keep-Alive");
    }
    else if (strcmp(name, "HTTP_USER_AGENT") == 0) 
    {
        // A call _pBindInfo->GetBindString(BINDSTRING_USER_AGENT, ...)
        // to returns the emtpy string.  Wonderful. We will "obtain"
        // the user agent string using a side channel.

        // hr = CopyServerVariable(buffer, pSize, BINDSTRING_USER_AGENT);
        hr = CopyServerVariable(buffer, pSize, g_UserAgent);
    }
    else if (strcmp(name, "GATEWAY_INTERFACE") == 0)
    {
        hr = CopyServerVariable(buffer, pSize, "CGI/1.1");        
    }
    else if (strcmp(name, "HTTP_ACCEPT_ENCODINGS") == 0) 
    {
        hr = CopyServerVariable(buffer, pSize, BINDSTRING_ACCEPT_ENCODINGS);
    }
    else if (strcmp(name, "CONTENT_TYPE") == 0)
    {
        hr = CopyServerVariable(buffer, pSize, _ECB.lpszContentType);
    }
    else if (strcmp(name, "HTTP_COOKIE") == 0)
    {
        if(_cookie)
        {
            hr = CopyServerVariable(buffer, pSize, _cookie);
        }
    }
#if 0
    else if (strcmp(name, "HTTP_REFERER") == 0) 
    {
        hr = CopyServerVariable(buffer, pSize, BINDSTRING_ACCEPT_ENCODINGS);
    }
#endif
    else if (strcmp(name, "HTTPS") == 0) 
    {
        hr = CopyServerVariable(buffer, pSize, "off");
    }
    else
    {
        TRACE1(TAG, L"Unimplemented GetServerVariable:%S", name);
        CopyServerVariable(buffer, pSize, "");
        SetLastError(ERROR_INVALID_INDEX);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);
    }

#if DBG
    if(hr != S_OK &&
       hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) && 
       hr != HRESULT_FROM_WIN32(ERROR_INVALID_INDEX))
        TRACE_ERROR(hr);
#endif

    return hr;
}

HRESULT  
PTProtocol::WriteClient(
    void *pv,
    DWORD *pcb,
    DWORD dwReserved)
{
    HRESULT hr = S_OK;
    DWORD flags = 0;

    EnterCriticalSection(&_csOutputWriter);

    if (!_pOutputWrite)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    hr = _pOutputWrite->Write(pv, *pcb, pcb);
    ON_ERROR_EXIT();

    _cbOutput += *pcb;

    if (!_started)
    {
        _started = TRUE;
        flags |= BSCF_FIRSTDATANOTIFICATION;
    }

    if (_done)
    {
        flags |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
    }

    hr = _pProtocolSink->ReportData(flags, *pcb, _cbOutput);
    ON_ERROR_EXIT();

Cleanup:
    // call async IO completion callback if set
    if (hr == S_OK && dwReserved == HSE_IO_ASYNC && _AsyncIoCallback != NULL)
        (*_AsyncIoCallback)(&_ECB, _pAsyncIoContext, 0, 0);

    LeaveCriticalSection(&_csOutputWriter);
    return hr;
}

HRESULT   
PTProtocol::ReadClient(
    void *pv,
    DWORD *pcb
    )
{
    HRESULT hr = S_OK;

    if (_pInputRead == NULL)
    {
        EXIT_WITH_WIN32_ERROR(ERROR_NOT_SUPPORTED);
    }
    else
    {
        hr = _pInputRead->Read(pv, *pcb, pcb);
        ON_ERROR_EXIT();
    }

Cleanup:
    return hr;
}

HRESULT 
PTProtocol::SaveCookie(char *header)
{
    HRESULT hr = S_OK;
    char *cookie, *tail, *cookieBody;
    int bodyLength;

    for(cookie = stristr(header, "Set-Cookie:");
        cookie != NULL;
        cookie = *tail ? stristr(tail, "Set-Cookie") : NULL)
    {
        cookie += 11;
        while(*cookie && isspace(*cookie))
            cookie++;
        tail = cookie;
        while(*tail && *tail != '\r')
            tail++;
        bodyLength = tail - cookie;

        if(bodyLength)
        {
            cookieBody = (char *)_alloca(bodyLength);
            memmove(cookieBody, cookie, bodyLength);
            cookieBody[bodyLength] = '\0';

            if(!g_pInternetSetCookie(_xspUrl, NULL, cookieBody))
                EXIT_WITH_LAST_ERROR();
        }
    }
Cleanup:
    return hr;
}

HRESULT 
PTProtocol::GetFileMimeType(WCHAR *fileName)
{
    WCHAR *pExt = wcsrchr(fileName, L'.');
    HKEY hKey = NULL;
    DWORD cbData;
    DWORD dwType;
    HRESULT hr = S_OK;

    if(pExt == NULL || pExt[1] == L'\0')
        EXIT_WITH_HRESULT(S_FALSE);

    if(RegOpenKeyEx(HKEY_CLASSES_ROOT, pExt, 0, KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS)
        EXIT_WITH_LAST_ERROR();

    cbData = 0;
    if(RegQueryValueEx(hKey, L"Content Type", NULL, NULL, NULL, &cbData) != ERROR_SUCCESS)
        EXIT_WITH_HRESULT(S_FALSE);

    _mimeType = (WCHAR *) MemAlloc(cbData * sizeof(WCHAR));
    if(RegQueryValueEx(hKey, L"Content Type", NULL, &dwType, (BYTE *)_mimeType, &cbData) != ERROR_SUCCESS)
        EXIT_WITH_LAST_ERROR();

Cleanup:
    if(hKey) RegCloseKey(hKey);
    return hr;
}

HRESULT
PTProtocol::MapPath(LPVOID lpvBuffer,LPDWORD lpdwSize)
{
    HRESULT hr = S_OK;
    char *curdir = NULL;
    const char *dir = _ECB.lpszPathTranslated;

    // try to map within the supplied-pathinfo hierarchy

    int lpath = strlen((CHAR *)lpvBuffer);
    int lroot = strlen(_ECB.lpszPathInfo);
    int lrdir = strlen(_ECB.lpszPathTranslated);

    // but if we're outside this directory, root at the current directory instead of pathtranslated

    if (lpath < lroot || strncmp(_ECB.lpszPathInfo, (CHAR *)lpvBuffer, lroot) != 0)
    {
        WCHAR *curdirw = (WCHAR *) MemAlloc(MAX_PATH * sizeof(WCHAR));
        ON_OOM_EXIT(curdirw);
        if (!GetCurrentDirectory(MAX_PATH, (WCHAR *)curdirw))
            EXIT_WITH_LAST_ERROR();
        curdir = DupStrA(curdirw);
        MemFree(curdirw);
        ON_OOM_EXIT(curdir);

        lroot = 0;
        lrdir = strlen(curdir);
        dir = curdir;
    }
    
    // strip trailing slashes

    if (lroot > 0 && _ECB.lpszPathInfo[lroot - 1] == '/')
        lroot --;

    if (lrdir > 0 && dir[lrdir - 1] == '\\')
        lrdir --;

    // detect insufficient memory

    if (*lpdwSize <= (unsigned)(lrdir + lpath - lroot + 1))
    {
        *lpdwSize = (lrdir + lpath - lroot + 1);
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return hr;
    }

    // reconcatenate and change / to "\"

    memmove(lrdir + (CHAR *)lpvBuffer, lroot + (CHAR *)lpvBuffer, lpath - lroot + 1);
    memcpy((CHAR *)lpvBuffer, dir, lrdir);

    char *pch;
    for (pch = (CHAR *)lpvBuffer + lrdir; *pch; pch++)
    {
        if (*pch == '/')
            *pch = '\\';
    }

    // free any allocated memory

Cleanup:
    MemFree(curdir);

    return hr;
}


HRESULT
PTProtocol::ServerSupportFunction(
    DWORD dwHSERequest,
    void *pv,
    DWORD *pcb,
    LPDWORD lpdwDataType
    )
{
    DWORD dw;
    HRESULT hr = S_OK;

    // Please, note that despite all the futzing with string lengths, IIS 
    // actually assumes every header to be zero-terminated. 

    switch(dwHSERequest)
    {
    case HSE_REQ_SEND_RESPONSE_HEADER:

        if(pv) 
        {
            dw = strlen((char *)pv);

            hr = SaveCookie((char *)pv);
            ON_ERROR_EXIT();

            hr = WriteClient(pv, &dw, 0);
            ON_ERROR_EXIT();
        }

        if(lpdwDataType)
        {
            dw = strlen((char *) lpdwDataType);

            hr = SaveCookie((char *) lpdwDataType);
            ON_ERROR_EXIT();

            hr = WriteClient((void *) lpdwDataType, &dw, 0);
            ON_ERROR_EXIT();
        }

        dw = 4;
        hr = WriteClient("\r\n\r\n", &dw, 0);
        ON_ERROR_EXIT();

        break;

    case HSE_REQ_SEND_RESPONSE_HEADER_EX:
        {
            HSE_SEND_HEADER_EX_INFO *pHeader = (HSE_SEND_HEADER_EX_INFO *)pv;

            ASSERT(pHeader);

            hr = SaveCookie((char *) pHeader->pszHeader);
            ON_ERROR_EXIT();

            hr = SaveCookie((char *) pHeader->pszStatus);
            ON_ERROR_EXIT();

            hr = WriteClient((void *)pHeader->pszHeader, &pHeader->cchHeader, 0);
            ON_ERROR_EXIT();

            hr = WriteClient((void *)pHeader->pszStatus, &pHeader->cchStatus, 0);
            ON_ERROR_EXIT();

            dw = 4;
            hr = WriteClient("\r\n\r\n", &dw, 0);
            ON_ERROR_EXIT();

        }
        break;

	case HSE_REQ_MAP_URL_TO_PATH:
    case HSE_REQ_MAP_URL_TO_PATH_EX:
        hr = MapPath(pv, pcb);
        break;

	case HSE_REQ_IO_COMPLETION:
        _AsyncIoCallback = (PFN_HSE_IO_COMPLETION)pv;
        _pAsyncIoContext = lpdwDataType;

		break;

    case HSE_REQ_DONE_WITH_SESSION:
        Finish();
        break;

    default:
        TRACE1(TAG_INTERNAL, L"Unimplemented SSF Request: %d", dwHSERequest);
        EXIT_WITH_WIN32_ERROR(ERROR_NOT_SUPPORTED);
    }

Cleanup:
    return hr;
}

BOOL 
PTProtocol::GetServerVariable(
    HCONN hconn,
    char* name,
    void * buffer,
    DWORD *pSize)
{
    HRESULT hr = ((PTProtocol *)hconn)->GetServerVariable(name, buffer, pSize);
    return hr == S_OK;
}

BOOL
PTProtocol::WriteClient(
    HCONN hconn,
    void *pv,
    DWORD *pcb,
    DWORD reserved)
{
    HRESULT hr = ((PTProtocol *)hconn)->WriteClient(pv, pcb, reserved);
    return hr == S_OK;
}

BOOL
PTProtocol::ReadClient(
    HCONN hconn,
    void *pv,
    DWORD *pcb)
{
    HRESULT hr = ((PTProtocol *)hconn)->ReadClient(pv, pcb);
    return hr == S_OK;
}

BOOL 
PTProtocol::ServerSupportFunction(
    HCONN hconn,
    DWORD request,
    void *pv, 
    DWORD *pcb,
    DWORD *pType)
{
    HRESULT hr = ((PTProtocol *)hconn)->ServerSupportFunction(request, pv, pcb, pType);
    return hr == S_OK;
}

PTProtocolFactory::PTProtocolFactory()
{
}

PTProtocolFactory::~PTProtocolFactory()
{
}

HRESULT
PTProtocolFactory::QueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown ||
        iid == IID_IInternetProtocolInfo)
    {
        *ppv = (IInternetProtocolInfo *)this;
    }
    else if (iid == IID_IClassFactory)
    {
        *ppv = (IClassFactory *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

ULONG
PTProtocolFactory::AddRef()
{
    return IncrementDllObjectCount();
}

ULONG
PTProtocolFactory::Release()
{
    return DecrementDllObjectCount();
}

HRESULT
PTProtocolFactory::LockServer(BOOL lock)
{
    return lock ? IncrementDllObjectCount() : DecrementDllObjectCount();
}

HRESULT
PTProtocolFactory::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID iid,
    void **ppv)
{
    HRESULT hr = S_OK;
    PTProtocol *pProtocol = NULL;

    if (pUnkOuter && iid != IID_IUnknown)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    pProtocol = new PTProtocol(pUnkOuter);
    ON_OOM_EXIT(pProtocol);

    if (iid == IID_IUnknown)
    {
        *ppv = (IPrivateUnknown *)pProtocol;
        pProtocol->PrivateAddRef();
    }
    else
    {
        hr = pProtocol->QueryInterface(iid, ppv);
        ON_ERROR_EXIT();
    }

Cleanup:
    if (pProtocol)
        pProtocol->PrivateRelease();

    return hr;
}

HRESULT
PTProtocolFactory::CombineUrl(LPCWSTR baseUrl, LPCWSTR relativeUrl, DWORD combineFlags,
    LPWSTR pResult, DWORD cchResult, DWORD *pcchResult, DWORD reserved)
{
    HRESULT hr = S_OK;
    WCHAR *fileUrl = NULL;
    const WCHAR *p = relativeUrl;


    // TODO: CombineUrl needs work. 
    // It does not handle case where relativeUrl is actually absolute.
    // The memmove thing is kind'o cheesy

    hr = CreateFileUrl(baseUrl, &fileUrl);
    ON_ERROR_EXIT();

    hr = CoInternetCombineUrl(fileUrl, relativeUrl, combineFlags, pResult, cchResult, pcchResult, reserved);
    ON_ERROR_EXIT();

    // assuming protocol to consist of alnums followed by ":"
    while(*p && iswalnum(*p)) 
        p++;

    if(*p == L':') 
        goto Cleanup;

    // anything else we just jam "xsp:" into
    memcpy(pResult, L"xsp:", 4 * sizeof(WCHAR));
    memmove(pResult + 4, pResult + 5, (lstrlen(pResult + 5) + 1) * sizeof(WCHAR));

Cleanup:
    MemFree(fileUrl);
    return hr;
}

HRESULT
PTProtocolFactory::CompareUrl(LPCWSTR pwzUrl1, LPCWSTR pwzUrl2, DWORD dwCompareFlags)
{
    return INET_E_DEFAULT_ACTION;
}


HRESULT
PTProtocolFactory::ParseUrl(LPCWSTR url, PARSEACTION parseAction, DWORD dwParseFlags,
    LPWSTR result, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved)
{
    HRESULT hr = INET_E_DEFAULT_ACTION;

#if 0
    if (parseAction == PARSE_CANONICALIZE)
    {
        hr = S_OK;

        int len = lstrlen(url);

        // If it does not end with ".xsp", then map it to the file system.

        if (len < 4 || wcscmp(url + len - 4, L".xsp") != 0)
        {
            const WCHAR *start = wcschr(url, L':');
            start = start ? start + 1 : url;

            wcscpy(result, L"file:");
            wcscat(result, start);

            *pcchResult = lstrlen(result);
        }
    }
#endif

    return hr;
}

HRESULT
PTProtocolFactory::QueryInfo(LPCWSTR pwzUrl, QUERYOPTION QueryOption, DWORD dwQueryFlags,
    LPVOID pBuffer, DWORD cbBuffer, DWORD *pcbBuf, DWORD dwReserved)
{
    return E_NOTIMPL;
}


HRESULT 
GetPTProtocolClassObject(REFIID iid, void **ppv)
{
    HRESULT hr;

    hr = InitializePTProtocol();
    ON_ERROR_EXIT();

    hr = g_PTProtocolFactory.QueryInterface(iid, ppv);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT IUnknown_QueryService(IUnknown* punk, REFGUID rsid, REFIID riid, void ** ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    *ppvObj = 0;

    if (punk)
    {
        IServiceProvider *pSrvPrv;
        hr = punk->QueryInterface(IID_IServiceProvider, (void **) &pSrvPrv);
        if (hr == NOERROR)
        {
            hr = pSrvPrv->QueryService(rsid,riid, ppvObj);
            pSrvPrv->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\myweb\sync.cs ===
//------------------------------------------------------------------------------
// <copyright file="sync.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   sync.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace  System.Web.MyWebAdminUI {

  using System;
  using System.Data;
  using System.IO; 
  using System.Collections;
  using System.Web;
  using System.Web.Util;
  using System.Web.UI;
  using System.Web.UI.WebControls;
  using System.Web.UI.HtmlControls;

  /// <include file='doc\sync.uex' path='docs/doc[@for="syncPage"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  public class syncPage : Page {


    /// <include file='doc\sync.uex' path='docs/doc[@for="syncPage.SyncLabel"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected Label SyncLabel;
    /// <include file='doc\sync.uex' path='docs/doc[@for="syncPage.UpdateDataList"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected DataList UpdateDataList;
    /// <include file='doc\sync.uex' path='docs/doc[@for="syncPage.update"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public bool update = false;
    /// <include file='doc\sync.uex' path='docs/doc[@for="syncPage.appsForUpdate"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public ArrayList appsForUpdate = new ArrayList(); 

    /// <include file='doc\sync.uex' path='docs/doc[@for="syncPage.Page_Load"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public void Page_Load(Object sender, EventArgs e) 
    {
	    if (!IsPostBack) 
	    {
        MyWebApplication [] apps = MyWeb.GetInstalledApplications();
        ArrayList appsNotFound = new ArrayList();
        
	      if (apps==null) 
        {
          SyncLabel.Text="There are no applications to be updated.";
          update = false;
        }
        else 
        {

          DataTable dt = new DataTable();
          DataRow dr;

          dt.Columns.Add(new DataColumn("Application", typeof(string)));
          dt.Columns.Add(new DataColumn("InstalledVersion", typeof(string)));
          dt.Columns.Add(new DataColumn("NewVersion", typeof(string)));
    
          
        
          for (int i=0; i<apps.Length; i++)
          {
            if(!apps[i].LocalApplication)
            {
              String oldVersion=apps[i].Manifest.Version;
              oldVersion = oldVersion.ToLower(CultureInfo.InvariantCulture);
              MyWebManifest newManifest = MyWeb.GetManifest(apps[i].Manifest.ApplicationUrl);

              if(newManifest == null )
              {
                appsNotFound.Add(apps[i].Manifest.Name);
              }
              else
              {
                String newVersion = newManifest.Version;

                if(newManifest.Version.Length <= 0 && newManifest.Version ==null)
                {
                  appsNotFound.Add(apps[i].Manifest.Name);
                }
                else
                {
                  newVersion = newVersion.ToLower(CultureInfo.InvariantCulture);

                  if(!oldVersion.Equals(newVersion) )
                  {
                    dr = dt.NewRow();

                    dr[0] = apps[i].Manifest.Name;
                    dr[1] = apps[i].Manifest.Version;
                    dr[2] = newManifest.Version;

                    dt.Rows.Add(dr);
                    appsForUpdate.Add(apps[i]);
                  }
                }
              }
            }
          } 

        if(appsForUpdate.Count <=0)
          {
            SyncLabel.Text="None of the installed applications are eligible for update.";
            update = false;
          }
          else
          {
      
            UpdateDataList.DataSource =new DataView(dt);
            UpdateDataList.DataBind();
            update = true;
            SyncLabel.Text="The following applications are eligible for update.  Deselect the applications you do not wish to update.";
            Application["appsForUpdate"] = appsForUpdate;
      
          }
       
        }

        }
      }



    /// <include file='doc\sync.uex' path='docs/doc[@for="syncPage.Submit_Click"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public void Submit_Click(Object sender, EventArgs e) 
    {
      ArrayList appsForUpdate = (ArrayList)Application["appsForUpdate"];
      ArrayList appsUpdated = new ArrayList();
      ArrayList appsNotUpdated = new ArrayList();
  
      

      for (int i=0; i<UpdateDataList.Items.Count; i++)
      {
    
        bool temp=((CheckBox)UpdateDataList.Items[i].FindControl("UpdateCheck")).Checked;

    
        if (temp)
        {
      
          if (((MyWebApplication)appsForUpdate[i]).Update()==1 )
          {
            appsUpdated.Add(((MyWebApplication)appsForUpdate[i]).Manifest.Name);
          }

          else if (((MyWebApplication)appsForUpdate[i]).Update()==0 )
          {
            appsUpdated.Add(((MyWebApplication)appsForUpdate[i]).Manifest.Name);
          }
          else
          {
            appsNotUpdated.Add(((MyWebApplication)appsForUpdate[i]).Manifest.Name);
          }
        }
    
      }

      Application["appsUpdated"] = appsUpdated;
      Application["appsNotUpdated"] = appsNotUpdated;

      Response.Redirect("myweb://Home/myweb4.aspx");

    }

 
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\perftoolrt\iperftest.cs ===
//------------------------------------------------------------------------------
// <copyright file="IPerfTest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**
 * PerfTest interface
 *
 * Copyright (c) 1998 Microsoft Corporation
 */
namespace XSP.Tool
{

    /// <include file='doc\IPerfTest.uex' path='docs/doc[@for="IPerfTest"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface IPerfTest 
    {
        /// <include file='doc\IPerfTest.uex' path='docs/doc[@for="IPerfTest.DoTest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void DoTest();
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\perftoolrt\makefile.inc ===
!include $(DNAROOT)\src\xsp\mkinc.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\npt\ptprot.h ===
/**
 * Protocol definition.
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _PROTOCOL_H
#define _PROTOCOL_H

interface IPrivateUnknown
{
public:
   STDMETHOD(PrivateQueryInterface) (REFIID riid, void ** ppv) = 0;
   STDMETHOD_(ULONG, PrivateAddRef) () = 0;
   STDMETHOD_(ULONG, PrivateRelease) () = 0;
};

class PTProtocol :
    public IPrivateUnknown,
    public IInternetProtocol
{
public:

    PTProtocol(IUnknown *pUnkOuter);
    ~PTProtocol();

    DECLARE_MEMCLEAR_NEW_DELETE();

    // IPrivateUnknown methods

    STDMETHOD_(ULONG, PrivateAddRef)();
    STDMETHOD_(ULONG, PrivateRelease)();
    STDMETHOD(PrivateQueryInterface)(REFIID, void **);

    // IUnknown methods

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID, void **);

    // InternetProtocol methods

    STDMETHOD(Start)(LPCWSTR, IInternetProtocolSink *, IInternetBindInfo *, DWORD, DWORD);
    STDMETHOD(Continue)(PROTOCOLDATA *pProtData);
    STDMETHOD(Abort)(HRESULT hrReason,DWORD );
    STDMETHOD(Terminate)(DWORD );
    STDMETHOD(Suspend)();
    STDMETHOD(Resume)();
    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD(Seek)(LARGE_INTEGER , DWORD , ULARGE_INTEGER *) ;
    STDMETHOD(LockRequest)(DWORD );
    STDMETHOD(UnlockRequest)();

    // ECB functions

    HRESULT GetServerVariable(LPSTR, LPVOID, LPDWORD);
    HRESULT WriteClient(LPVOID, LPDWORD, DWORD);
    HRESULT ReadClient(LPVOID, LPDWORD); 
    HRESULT ServerSupportFunction(DWORD, LPVOID, LPDWORD, LPDWORD); 

    static BOOL WINAPI GetServerVariable(HCONN, LPSTR, LPVOID, LPDWORD);
    static BOOL WINAPI WriteClient(HCONN, LPVOID, LPDWORD, DWORD);
    static BOOL WINAPI ReadClient(HCONN, LPVOID, LPDWORD); 
    static BOOL WINAPI ServerSupportFunction(HCONN, DWORD, LPVOID, LPDWORD, LPDWORD); 



private:

    void Cleanup();
    HRESULT Finish();

    static HRESULT CopyServerVariable(void *buffer, DWORD *pSize, char *value);
    static HRESULT CopyServerVariable(void *buffer, DWORD *pSize, WCHAR *value, UINT cp = CP_ACP);
    HRESULT CopyServerVariable(void *buffer, DWORD *pSize, BINDSTRING name);
    HRESULT SaveCookie(char *header);
    HRESULT GetFileMimeType(WCHAR *fileName);
	HRESULT MapPath(LPVOID lpvBuffer, LPDWORD lpdwSize);


    long                    _refs;
    bool                    _aborted;
    bool                    _done;
    bool                    _started;
    WCHAR *                 _mimeType;
    CHAR *                  _cookie;
	CHAR *					_xspUrl;
    IUnknown *              _pUnkOuter;
    IStream *               _pOutputRead;
    IStream *               _pOutputWrite;
    IStream *               _pInputRead;
    IInternetProtocolSink * _pProtocolSink;  
    IInternetBindInfo *     _pBindInfo;
    IHttpNegotiate *        _pHttpNegotiate;
    DWORD                   _grfSTI;
    BINDINFO                _bindinfo;
    DWORD                   _bindf;
    EXTENSION_CONTROL_BLOCK _ECB;     
    PFN_HSE_IO_COMPLETION   _AsyncIoCallback;   // callback for async write completion
    void *                  _pAsyncIoContext;   // argument to the completion callback

    ULONG                   _cbOutput;
	HANDLE					_hFile;
    CRITICAL_SECTION        _csOutputWriter;
};

class PTProtocolFactory :
    public IClassFactory,
    public IInternetProtocolInfo
{
public:
    PTProtocolFactory();
    ~PTProtocolFactory();

    // IUnknown Methods

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID, void **);

    // IClassFactory Moethods

    STDMETHOD(LockServer)(BOOL);
    STDMETHOD(CreateInstance)(IUnknown*,REFIID,void**);

    // IInternetProtocolInfo Methods

    STDMETHOD(CombineUrl)(LPCWSTR,LPCWSTR,DWORD,LPWSTR,DWORD,DWORD *,DWORD);
    STDMETHOD(CompareUrl)(LPCWSTR, LPCWSTR, DWORD);
    STDMETHOD(ParseUrl)(LPCWSTR, PARSEACTION, DWORD, LPWSTR, DWORD, DWORD *, DWORD);
    STDMETHOD(QueryInfo)(LPCWSTR, QUERYOPTION, DWORD, LPVOID, DWORD, DWORD *, DWORD);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tool\baseobject.cxx ===
/**
 * BaseObject automation object implementation
 *
 * Copyright (C) Microsoft Corporation, 1998
 */

#include "precomp.h"
#include "_exe.h"

ITypeLib * g_pTypeLib = NULL;

HRESULT
GetTypeInfoOfGuid(REFIID iid, ITypeInfo **ppTypeInfo)
{
        HRESULT hr = S_OK;

    if (!g_pTypeLib)
    {
                WCHAR path[MAX_PATH];
        GetModuleFileName(g_Instance, path, MAX_PATH);

        hr = LoadTypeLib(path, &g_pTypeLib);
        ON_ERROR_EXIT();
    }

        hr = g_pTypeLib->GetTypeInfoOfGuid(iid, ppTypeInfo);
    ON_ERROR_EXIT();

Cleanup:
        return hr;
}

BaseObject::BaseObject()
{
        _refs = 1;
}

BaseObject::~BaseObject()
{
        ReleaseInterface(_pTypeInfo);
}

/**
 * Implements IUnknown::QueryInteface.
 */
HRESULT
BaseObject::QueryInterface(
    REFIID iid,
    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDispatch)
    {
        *ppv = GetPrimaryPtr();
    }
    else if (iid == IID_IConnectionPointContainer)
    {
        *ppv = (IConnectionPointContainer *)this;
    }
    else if (iid == IID_IProvideClassInfo ||
            iid == IID_IProvideClassInfo2 ||
            iid == IID_IProvideMultipleClassInfo)
    {
        *ppv = (IProvideMultipleClassInfo *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

/**
 * Implements IUnknown::AddRef.
 */
ULONG
BaseObject::AddRef()
{
    _refs += 1;
    return _refs;
}

/**
 * Implements IUnknown::Release.
 */
ULONG
BaseObject::Release()
{
    if (--_refs == 0)
    {
                delete this;
        return 0;
    }

    return _refs;
}

/**
 * Implements IDispatch::GetTypeInfo.
 */
HRESULT
BaseObject::GetTypeInfo(
    UINT,
    ULONG,
    ITypeInfo ** ppTypeInfo)
{
        HRESULT hr = S_OK;

        if (!_pTypeInfo)
        {
                hr = GetTypeInfoOfGuid(*GetPrimaryIID(), &_pTypeInfo);
        ON_ERROR_EXIT();
        }

        *ppTypeInfo = _pTypeInfo;
        (*ppTypeInfo)->AddRef();

Cleanup:
        return hr;
}

/**
 * Implements IDispatch::GetTypeInfoCount.
 */
HRESULT
BaseObject::GetTypeInfoCount(
    UINT * pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

/**
 * Implements IDispatch::GetIDsOfNames.
 */
HRESULT
BaseObject::GetIDsOfNames(
    REFIID,
    LPOLESTR * pNames,
    UINT cNames,
    LCID,
    DISPID * pDispid)
{
    HRESULT hr;

        if (_pTypeInfo == NULL)
        {
                hr = GetTypeInfoOfGuid(*GetPrimaryIID(), &_pTypeInfo);
        ON_ERROR_EXIT();
        }

    hr = _pTypeInfo->GetIDsOfNames(pNames, cNames, pDispid);

Cleanup:
        return hr;
}

/**
 * Implements IDispatch::Invoke.
 */
HRESULT
BaseObject::Invoke(
    DISPID dispidMember,
    REFIID,
    LCID,
    WORD wFlags,
    DISPPARAMS * pParams,
    VARIANT * pResult,
    EXCEPINFO * pExcepInfo,
    UINT * puArgErr)
{
    HRESULT hr;

        if (!_pTypeInfo)
        {
                hr = GetTypeInfoOfGuid(*GetPrimaryIID(), &_pTypeInfo);
        ON_ERROR_EXIT();
        }

    hr = _pTypeInfo->Invoke(GetPrimaryPtr(), dispidMember, wFlags, pParams, pResult, pExcepInfo, puArgErr);

Cleanup:
        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tool\makefile.inc ===
$(O)\tool.tlb : $(O)\tool.h

$(O)\tool.res : ..\tool.rc ..\util.vbs $(O)\tool.tlb ..\toolreg.inf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tool\delegate.cxx ===
/**
 * Delegate object implementation
 *
 * Copyright (C) Microsoft Corporation, 1998
 */

#include "precomp.h"

class Delegate : public IDispatch
{
public:

        Delegate(IDispatch *pObject, DISPID dispid);
        ~Delegate();

    DECLARE_MEMCLEAR_NEW_DELETE();

    // IUnknown methods

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID, void **);

    // IDispatch interface

    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo);
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo);
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR * * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid);
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);

private:

    long _refs;
    DISPID _dispid;
    IDispatch *_pObject;
};

Delegate::Delegate(IDispatch *pObject, DISPID dispid)
{
    _refs = 1;
    _dispid = dispid;
    ReplaceInterface(&_pObject, pObject);
}

Delegate::~Delegate()
{
    ReleaseInterface(_pObject);
}

/**
 * Implements IUnknown::QueryInteface.
 */
HRESULT
Delegate::QueryInterface(
    REFIID iid,
    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDispatch)
    {
        *ppv = (IDispatch *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

/**
 * Implements IUnknown::AddRef.
 */
ULONG
Delegate::AddRef()
{
    _refs += 1;
    return _refs;
}

/**
 * Implements IUnknown::Release.
 */
ULONG
Delegate::Release()
{
    if (--_refs == 0)
    {
        delete this;
        return 0;
    }

    return _refs;
}

/**
 * Implements IDispatch::GetTypeInfo.
 */
HRESULT
Delegate::GetTypeInfo(
    UINT ,
    ULONG ,
    ITypeInfo ** )
{
    return E_NOTIMPL;
}

/**
 * Implements IDispatch::GetTypeInfoCount.
 */
HRESULT
Delegate::GetTypeInfoCount(
    UINT * pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

/**
 * Implements IDispatch::GetIDsOfNames.
 */
HRESULT
Delegate::GetIDsOfNames(
    REFIID,
    LPOLESTR * pNames,
    UINT cNames,
    LCID,
    DISPID * pDispid)
{
    HRESULT hr = S_OK;

    if (cNames != 1 || _wcsicmp(pNames[0], L"Invoke") != 0)
        EXIT_WITH_HRESULT(DISP_E_UNKNOWNNAME);

    *pDispid = DISPID_VALUE;

Cleanup:
    return hr;
}

/**
 * Implements IDispatch::Invoke.
 */
HRESULT
Delegate::Invoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS * pParams,
    VARIANT * pResult,
    EXCEPINFO * pExcepInfo,
    UINT * puArgErr)
{
    HRESULT hr;

    if (dispidMember != DISPID_VALUE)
        EXIT_WITH_HRESULT(DISP_E_MEMBERNOTFOUND);

    hr = _pObject->Invoke(_dispid, iid, lcid, wFlags, pParams, pResult, pExcepInfo, puArgErr);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT 
CreateDelegate(
    WCHAR *name, 
    IDispatch *pObject, 
    IDispatch **ppDelegate
    )
{
    HRESULT hr;
    DISPID dispid;

    hr = pObject->GetIDsOfNames(IID_NULL, &name, 1, 0, &dispid);
    ON_ERROR_EXIT();

    *ppDelegate = new Delegate(pObject, dispid);
    ON_OOM_EXIT(*ppDelegate);

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tool\main.cxx ===
/**
 * XSP Tool main module.
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

#include "precomp.h"
#include "_exe.h"

DEFINE_DBG_COMPONENT(L"xsptool.exe");

#ifdef CAN_IMPORT_MANAGED_TYPELIB
#import "xspmrt.tlb" raw_native_types,raw_interfaces_only
#else
#include "_isapiruntime.h"
#endif

extern "C" BOOL TerminateExtension(DWORD); 

BOOL g_Never = FALSE;
BOOL g_AllowDebug = FALSE;
HINSTANCE g_Instance;
IClassFactory *g_pManagedFactory;

void PrintHelp()
{
    printf("xsptool /d | /? | ?expression | statement | /f file | <nothing>\n");
    printf("   /?            - Print this help\n");
    printf("   /d            - Allow just-in-time debugging.\n");
    printf("   /f file       - Execute script file.\n");
    printf("   statement     - Execute statement.\n");
    printf("   ?expresion    - Evaluate expression and print result.\n");
    printf("   <nothing>     - Enter interactive loop.\n");
    printf("\n");
    printf("   Execute the 'help' statement for help on available commands\n");
}

/**
 * Main function for XSP Tool
 */
extern "C" int __cdecl
wmain(
	int argc, 
	WCHAR* argv[]
	)
{
    BOOL doFile = FALSE;
    BOOL doExpression = FALSE;
    BOOL doHelp = FALSE;

    g_Instance = GetModuleHandle(NULL);
    ASSERT(g_Instance != 0);

    // Prevents buffering to fix remote.exe behavior
    setbuf(stdout, NULL);

    // Init ISAPI DLL
    InitializeLibrary();

    // Force hard link to aspnet_isapi.dll for
    // automatic load of symbols in the debugger.
    if (g_Never) TerminateExtension(0);

    WCHAR expression[MAX_PATH];
    int fillCount = 0;

    HRESULT hr = S_OK;
    IDispatch *pScriptHost = NULL;
    WCHAR *fileName = NULL;

    expression[0] = 0;

    CoInitializeEx(0, COINIT_MULTITHREADED);

    for (int i = 1; i < argc; i++)
    {
        if (wcscmp(argv[i], L"-?") == 0 ||
            wcscmp(argv[i], L"/?") == 0)
        {
            doHelp = TRUE;
        }
        else if (wcscmp(argv[i], L"-d") == 0 ||
            wcscmp(argv[i], L"/d") == 0)
        {
            g_AllowDebug = TRUE;
        }
        else if (wcscmp(argv[i], L"-f") == 0 ||
            wcscmp(argv[i], L"/f") == 0)
        {
            i++;
            if (i < argc)
            {
                fileName = argv[i];
                doFile = TRUE;
            }
            else
            {
                wprintf(L"xsptool: Error, file name not specified.");
                EXIT_WITH_HRESULT(E_FAIL);
            }
        }
        else if (argv[i][0] == L'-' || argv[i][0] == L'/')
        {
            wprintf(L"xsptool: Error, unknown option '%s'\n", argv[0], argv[i]);
            EXIT_WITH_HRESULT(E_FAIL);
        }
        else
        {
            doExpression = TRUE;

            if (fillCount > 1)
                wcscat(expression, L",");

            if (fillCount > 0)
                wcscat(expression, L" \"");

            wcscat(expression, argv[i]);

            if (fillCount > 0)
                wcscat(expression, L"\"");

            fillCount += 1;
        }
    }

    if (doHelp)
    {
        PrintHelp();
    }

    if (doFile)
    {
        hr = ScriptHost::ExecuteFile(fileName, &pScriptHost);
        ON_ERROR_EXIT();
    }

    if (doExpression)
    {
        hr = ScriptHost::ExecuteString(expression);
        ON_ERROR_EXIT();
    }

    if (!doHelp && !doFile && !doExpression)
    {
        hr = ScriptHost::Interactive();
        ON_ERROR_EXIT();
    }
    
Cleanup:
    ReleaseInterface(pScriptHost);
	ClearInterface(&g_pTypeLib);
    ScriptHost::Terminate();
	CoUninitialize();
    return hr ? 1 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tool\ecbhost.cxx ===
/**
 * Simple ECB host implementation
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 */
#include "precomp.h"
#include "_exe.h"
#include "_isapiruntime.h"
#include "appdomains.h"

#if ICECAP
#include "icecap.h"
#endif

//
// Exported function to hookup to script host.
//
HRESULT CreateEcbHost(IDispatch **ppIDispatch);


#define ECBHOST_USER_AGENT "XspTool (Windows NT)"

//
// Local functions prototypes and macros
//
HRESULT GetWebRootDir(WCHAR ** ppPathTranslated);
HRESULT CallDelegate(IDispatch *, VARIANT *, WCHAR *);
HRESULT CopyToServerVariable(PVOID &, PDWORD &, const CHAR *);

class Ecb;

/**
 * EcbHost class definition
 */
class EcbHost 
    : public BaseObject, 
      public IEcbHost 
{
    // ISAPI DLL data - path, handle and entry points
    const CHAR *                _szDllPath;
    HINSTANCE                   _hDll;
    PFN_GETEXTENSIONVERSION     _pfnGetExtensionVersion;
    PFN_HTTPEXTENSIONPROC       _pfnHttpExtensionProc;
    PFN_TERMINATEEXTENSION      _pfnTerminateExtension;
    xspmrt::_ISAPIRuntime *      _pManagedRuntime;


    // User-provided virtual root and corresponding dir
    const WCHAR *                _PathInfo;
    const CHAR *                 _szPathInfo;
    const WCHAR *                _PathTranslated;
    const CHAR *                 _szPathTranslated;

    // This event is fired when the result is ready
    // (result may arrive on any thread)
    HANDLE                      _hResultArrivedEvent;

    // Queued processed Ecb
    //
    CReadWriteSpinLock          _EcbQueueLock;
    long                        _QueueLength;
    LIST_ENTRY                  _EcbList;

    long                        _EcbCount;
    long                        _MaxActiveRequests;

    BOOL                        _IsDisplayHeaders;
    BOOL                        _UseUTF8;

    char *                      _pSessionCookie;
    CReadWriteSpinLock          _SessionCookieLock;

public:

    // Scripting host support
    const IID *GetPrimaryIID() { return &__uuidof(IEcbHost); }
    IUnknown * GetPrimaryPtr() { return (IEcbHost *)(this); }
    STDMETHOD(QueryInterface(REFIID, void **));

    DELEGATE_IDISPATCH_TO_BASE();

    // Constructor and destructor
    DECLARE_MEMCLEAR_NEW_DELETE();
    EcbHost();
    ~EcbHost();

    // access functions
    const CHAR * GetDllPath() const { return _szDllPath; }
    const WCHAR * GetPathInfo() const { return _PathInfo; }
    const WCHAR * GetPathTranslated() const { return _PathTranslated; }
    const CHAR * GetSZPathInfo() const { return _szPathInfo; }
    const CHAR * GetSZPathTranslated() const { return _szPathTranslated; }
    xspmrt::_ISAPIRuntime * GetManagedRuntime() const { return _pManagedRuntime; }


    DWORD CallExtensionProc(Ecb *pEcb)
    {
        return _pfnHttpExtensionProc(reinterpret_cast<EXTENSION_CONTROL_BLOCK *>(pEcb));
    }

    HRESULT SignalResultArrived();
    void    QueueResponse(Ecb *pEcb);
    HRESULT MapPath(LPVOID lpvBuffer, LPDWORD lpdwSize);

    void IncEcbCount() { InterlockedIncrement(&_EcbCount); }
    void DecEcbCount() { InterlockedDecrement(&_EcbCount); }

    HRESULT DrainResponseQueue();

    // COM interface
    HRESULT __stdcall Use(
        BSTR PathInfo,
        BSTR PathTranslated,
        BSTR DllPath 
        );

    HRESULT __stdcall Reset( void );

    HRESULT __stdcall Get(
        BSTR File,
        BSTR QueryString, 
        BSTR Headers, 
        BSTR  *pResponse);

    HRESULT __stdcall Post(
        BSTR File,
        BSTR QueryString, 
        BSTR Headers,
        BSTR Data,
        BSTR  *pResponse);

    HRESULT __stdcall ProcessSyncRequest(
        BSTR Verb,
        BSTR File,
        BSTR QueryString,
        BSTR Headers,
        BSTR Data,
        BSTR  *pResponse);

    HRESULT __stdcall AsyncGet( 
        BSTR File,
        BSTR QueryString,
        BSTR Headers,
        IDispatch  *pCallback,
        VARIANT  *pCookie);
        
    HRESULT __stdcall AsyncPost( 
        BSTR File,
        BSTR QueryString,
        BSTR Headers,
        BSTR Data,
        IDispatch  *pCallback,
        VARIANT  *pCookie);
        
    HRESULT __stdcall ProcessAsyncRequest(
        BSTR Verb,
        BSTR File,
        BSTR QueryString,
        BSTR Headers,
        BSTR Data,
        IDispatch  *pCallback,
        VARIANT  *pCookie);

    HRESULT __stdcall Drain( 
        long Requests);

    HRESULT __stdcall get_ActiveRequests( 
        long *pEcbCount);

    HRESULT __stdcall get_MaxActiveRequests(
        long *pMaxActiveRequests);

    HRESULT __stdcall put_MaxActiveRequests(
        long pMaxActiveRequests);

    HRESULT __stdcall Throughput(
        BSTR File,
        long nThreads,
        long nSeconds,
        BSTR QueryString,
        BSTR Verb,
        BSTR Headers,
        BSTR Data,
        double *pResult);
      
    HRESULT __stdcall get_IsDisplayHeaders(
        VARIANT_BOOL * IsDisplayHeaders);

    HRESULT __stdcall put_IsDisplayHeaders(
        VARIANT_BOOL IsDisplayHeaders);

    HRESULT __stdcall get_UseUTF8(
        VARIANT_BOOL *pUseUTF8);

    HRESULT __stdcall put_UseUTF8(
        VARIANT_BOOL UseUTF8);
};


/**
 * Ecb class definition (Ecb is what WAM_EXEC_INFO is in IIS)
 */
class Ecb 
{
    EXTENSION_CONTROL_BLOCK _ECB;               // as seen by HttpExtensionProc
    EcbHost *               _pEcbHost;          // pointer to EcbHost 
    LONG                    _RefCount;          // Ecb object refcount

    CHAR *                  _szUrl;             // url with entry point removed

    BYTE *                  _pResponse;         // response buffer
    size_t                  _ResponseLength;    // response buffer length
    size_t                  _ResponseSize;      // response buffer size
    BOOL                    _fUseUTF8;          // use UTF8 for response decoding

    char *                  _pStatus;           // status string
    char *                  _pResponseHeaders;  // header string
    char *                  _pSessionCookie;    // session cookie : "AspSessionId=..."

    BOOL                    _fHeadersReceived;  // were headers received?
    BOOL                    _fDisplayHeaders;   // display headers in Process(A)SyncRequest?

    long                    _Counter;           // used by Throughput()
    long                    _Duration;          // used by Throughput()

    BOOL                    _WaitForCompletion; // this is "synchronous" request
    IDispatch  *            _pCallback;         // 
    VARIANT                 Cookie;

    PFN_HSE_IO_COMPLETION   _AsyncIoCallback;   // callback for async write completion
    void *                  _pAsyncIoContext;   // argument to the completion callback


public:
    LIST_ENTRY              _EcbList;           // list of ecbs (used in async requests)

    DECLARE_MEMCLEAR_NEW_DELETE();
    Ecb();
    ~Ecb();

    EcbHost * GetEcbHost() const { return _pEcbHost; }

    size_t GetResponseLength() const { return _ResponseLength; }
    char * GetResponseBuffer() const { return (char *) _pResponse; }
    void ResetResponse();


    void IncrementCounter(LONG addValue)
    {
        InterlockedExchangeAdd(&_Counter, addValue);
    }

    long GetCounter() const { return _Counter; }

    void SetStressDuration(long duration) { _Duration = duration; }
    long GetStressDuration() { return _Duration; }

    HRESULT Init(
        EcbHost * pEcbHost,
        BSTR Verb,
        BSTR File,
        BSTR QueryString,
        BSTR Headers,
        BOOL WaitForCompletion,
        BOOL DisplayHeaders,
        BOOL UseUTF8,
        BSTR Data = NULL,
        IDispatch  *pCallback = NULL,
        VARIANT  *pCookie = NULL
        );

    HRESULT DoCallback();

    ULONG AddRef() { return InterlockedIncrement(&_RefCount); }
    ULONG Release();

    HRESULT GetServerVariable(
        LPSTR lpszVariableName,
        LPVOID lpvBuffer,
        LPDWORD lpdwSize 
        );

    HRESULT WriteClient(
        LPVOID Buffer,
        LPDWORD lpdwBytes,
        DWORD dwReserved 
        );

    HRESULT ReadClient(
        LPVOID lpvBuffer,
        LPDWORD lpdwSize 
        );

    HRESULT ServerSupportFunction(
        DWORD dwHSERequest,
        LPVOID lpvBuffer,
        LPDWORD lpdwSize,
        LPDWORD lpdwDataType 
        );

    HRESULT GetXspSessionCookieFromResponse(char ** pCookie);
    HRESULT SetXspSessionCookieForRequest(char * pCookie);
};



/**
 * Constructor
 */
EcbHost::EcbHost() : 
    _SessionCookieLock("EcbHost._SessionCookieLock"), 
    _EcbQueueLock("EcbHost._EcbQueueLock")
{
    _MaxActiveRequests  = -1;
    InitializeListHead(&_EcbList);
}



/**
 * Destructor. 
 */
EcbHost::~EcbHost()
{
    //
    // Make sure we are completely uninitialized
    // (calling Reset() extra time is safe)
    //

    Reset();
}

/**
 * IUnknown::QueryInteface.
 */
HRESULT
EcbHost::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == __uuidof(IEcbHost))
    {
        *ppv = (IEcbHost *)this;
    }
    else
    {
        return BaseObject::QueryInterface(iid, ppv);
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

/**
 * Signal other threads that result has arrived.
 */
HRESULT
EcbHost::SignalResultArrived()
{
    HRESULT hr = S_OK;

    if(!SetEvent(_hResultArrivedEvent))
        EXIT_WITH_LAST_ERROR();
Cleanup:
    return hr;
}

/**
 * Queue single response.
 */
void
EcbHost::QueueResponse(Ecb *pEcb)
{
    _EcbQueueLock.AcquireWriterLock();

    InsertTailList(&_EcbList, &pEcb->_EcbList);

    _QueueLength++;

    _EcbQueueLock.ReleaseWriterLock();
}

/**
 * Drain all the responses from the queue
 */
HRESULT
EcbHost::DrainResponseQueue()
{
    HRESULT     hr = S_OK;
    LIST_ENTRY  *ecbListEntry;

    // Snap off the queue in critical section
    _EcbQueueLock.AcquireWriterLock();

    ecbListEntry = _EcbList.Flink;

    InitializeListHead(&_EcbList);
    _QueueLength = 0;

    _EcbQueueLock.ReleaseWriterLock();

    // Process the snapped queue
    
    while (ecbListEntry != &_EcbList)
    {
        Ecb * pEcb = CONTAINING_RECORD(ecbListEntry, Ecb, _EcbList);
        ecbListEntry = ecbListEntry->Flink;

        hr = pEcb->DoCallback();
        ON_ERROR_CONTINUE();

        delete pEcb;
    }

    return hr;
}



/**
 * Free any allocated resources.
 */
HRESULT
EcbHost::Reset()
{
    HRESULT     hr = S_OK;
    LIST_ENTRY  *ecbListEntry;

    // Free all queued Ecbs inside critsection
    _EcbQueueLock.AcquireWriterLock();

    ecbListEntry = _EcbList.Flink;

    InitializeListHead(&_EcbList);
    _QueueLength = 0;

    while (ecbListEntry != &_EcbList)
    {
        Ecb * pEcb = CONTAINING_RECORD(ecbListEntry, Ecb, _EcbList);
        ecbListEntry = ecbListEntry->Flink;
        delete pEcb;
    }

    _EcbQueueLock.ReleaseWriterLock();

    MemClear(&_szDllPath);
    MemClear(&_PathInfo);
    MemClear(&_szPathInfo);
    MemClear(&_PathTranslated);
    MemClear(&_szPathTranslated);

    _SessionCookieLock.AcquireWriterLock();
    MemClear(&_pSessionCookie);
    _SessionCookieLock.ReleaseWriterLock();

    if(_hResultArrivedEvent) {
        SetEvent(_hResultArrivedEvent);
        Sleep(10);
        CloseHandle(_hResultArrivedEvent);
        _hResultArrivedEvent = NULL;
    }

    //
    // Just like IIS does, we call TerminateExtension()
    // and don't pay any attention to the result
    //

    if(_pfnTerminateExtension) {
        _pfnTerminateExtension(HSE_TERM_MUST_UNLOAD);
        _pfnTerminateExtension = NULL;
    }

    _pfnGetExtensionVersion = NULL;
    _pfnHttpExtensionProc = NULL;


    //
    // If the DLL is loaded, free it
    //

    if(_hDll) {
        FreeLibrary(_hDll);
        _hDll = NULL;
    }

    if(_pManagedRuntime)
    {
        hr = _pManagedRuntime->StopProcessing();
        _pManagedRuntime->Release();
        _pManagedRuntime = NULL;
    }

    UninitAppDomainFactory();

    return hr;
}


/**
 * Initialize EcbHost instance. Load the specified ISAPI 
 * extension DLL, retrieve its entry points and call 
 * GetExtensionVersion().
 */
HRESULT __stdcall
EcbHost::Use(
    BSTR PathInfo,
    BSTR PathTranslated,
    BSTR DllPath
    )
{
    HRESULT hr = S_OK;

    // Prevent any leaks -- free everything

    Reset();

    // Store path infos

    // if no DLL specified, use ASPNET_ISAPI.DLL
    if(DllPath != NULL && *DllPath != 0) 
    {
        _szDllPath = DupStrA(DllPath);
    } else {
        _szDllPath = DupStr(ISAPI_MODULE_FULL_NAME);
    }
    ON_OOM_EXIT(_szDllPath);

    _PathInfo = DupStr(PathInfo ? PathInfo : L"/");
    ON_OOM_EXIT(_PathInfo);
    _szPathInfo = DupStrA(_PathInfo);
    ON_OOM_EXIT(_szPathInfo);

    // if no path specified, use web root dir  
    if(PathTranslated == NULL || *PathTranslated == 0)
    {
        hr = GetWebRootDir((WCHAR **) &_PathTranslated);
        if(hr != S_OK) 
        {
            // hmm, maybe no IIS on this machine?
            hr = S_OK;
            _PathTranslated = (WCHAR *) MemAlloc(MAX_PATH * sizeof(WCHAR));
            ON_OOM_EXIT(_PathTranslated);
            if(!GetCurrentDirectory(MAX_PATH, (WCHAR *) _PathTranslated))
                EXIT_WITH_LAST_ERROR();
        }
    } else {
        WCHAR    fullPath[_MAX_PATH] = L"";
        WCHAR *  dummy = NULL;
        DWORD    dwRet = GetFullPathName(PathTranslated, ARRAY_SIZE(fullPath), fullPath, &dummy);
        int      l = 0;

        if (dwRet == 0 || dwRet >= _MAX_PATH)
            EXIT_WITH_HRESULT(E_UNEXPECTED);

        l = wcslen(fullPath);
        if (l < 1)
            EXIT_WITH_HRESULT(E_UNEXPECTED);

        // must end with '\'
        if (fullPath[l-1] == L'\\' || l == 1)
        {
            _PathTranslated = DupStr(fullPath);
            ON_OOM_EXIT(_PathTranslated);
        }
        else
        {
            WCHAR *p = (WCHAR *)MemAlloc(sizeof(WCHAR) * (l+2));
            ON_OOM_EXIT(p);

            memcpy(p, fullPath, sizeof(WCHAR) * l);
            p[l] = L'\\';
            p[l+1] = L'\0';

            _PathTranslated = p;
        }
    }

    _szPathTranslated = DupStrA(_PathTranslated);
    ON_OOM_EXIT(_szPathTranslated);

    // Init app domain factory
    hr = InitAppDomainFactory();
    ON_ERROR_EXIT();

    // Create managed runtime

    IUnknown *punk;
    punk = NULL;

    hr = GetAppDomain("XSPTOOL", (char *)_szPathTranslated, (IUnknown **) &punk, NULL, 0);
    ON_ERROR_EXIT();

    hr = punk->QueryInterface(__uuidof(xspmrt::_ISAPIRuntime), (LPVOID*)&_pManagedRuntime);
    punk->Release();
    ON_ERROR_EXIT();

    // Call the initialization method on managed runtime
    hr = _pManagedRuntime->StartProcessing();
    ON_ERROR_EXIT();

    // CReate synchronzation event
    _hResultArrivedEvent = CreateEvent(NULL, TRUE, FALSE, L"EcbHostResultArrived");
    if(_hResultArrivedEvent == NULL)
        EXIT_WITH_LAST_ERROR();

    //  Try to load library

    _hDll = LoadLibraryA(_szDllPath);
    if(_hDll == NULL) 
        EXIT_WITH_LAST_ERROR();
    
    // Retrieve ISAPI entry points

    _pfnGetExtensionVersion = (PFN_GETEXTENSIONVERSION) 
        GetProcAddress(_hDll, "GetExtensionVersion");
    if( _pfnGetExtensionVersion == NULL) 
        EXIT_WITH_LAST_ERROR();

    _pfnHttpExtensionProc = (PFN_HTTPEXTENSIONPROC)
        GetProcAddress(_hDll, "HttpExtensionProc");
    if(_pfnHttpExtensionProc == NULL)
        EXIT_WITH_LAST_ERROR();

    // Just like IIS does, call GetExtensionVersion()

    HSE_VERSION_INFO ExtensionVersion;

    if(!_pfnGetExtensionVersion(&ExtensionVersion)) 
        EXIT_WITH_LAST_ERROR();

    // This entry point is optional 

    _pfnTerminateExtension = (PFN_TERMINATEEXTENSION)
        GetProcAddress(_hDll, "TerminateExtension");

Cleanup:
    return hr;
}


/**
 * Perform synchronous "GET" request.
 */
HRESULT __stdcall 
EcbHost::Get(
    BSTR File,
    BSTR QueryString, 
    BSTR Headers, 
    BSTR  *pResponse
    )
{
    return ProcessSyncRequest(
                L"GET", 
                File, 
                QueryString, 
                Headers,
                NULL,
                pResponse);
}

HRESULT __stdcall 
EcbHost::Post(
    BSTR File,
    BSTR QueryString, 
    BSTR Headers,
    BSTR Data,
    BSTR  *pResponse)
{
    return ProcessSyncRequest(
                L"POST", 
                File, 
                QueryString, 
                Headers,
                Data,
                pResponse);
}


HRESULT __stdcall
EcbHost::ProcessSyncRequest(
    BSTR Verb,
    BSTR File,
    BSTR QueryString,
    BSTR Headers,
    BSTR Data,
    BSTR  *pResponse
    )
{
    HRESULT hr;
    Ecb * pEcb = NULL;
    WCHAR * pWideResponse = NULL;
    size_t ResponseLength;
    CHAR * pResponseBuffer = NULL;
    char *pSessionCookie, *pSessionCookieOld;


    if(_hDll == NULL)
    {
        hr = Use(NULL, NULL, NULL);
        ON_ERROR_EXIT();
    }

    pEcb = new Ecb();
    ON_OOM_EXIT(pEcb);

    ResetEvent(_hResultArrivedEvent);

    hr = pEcb->Init(this, File, Verb, QueryString, Headers, TRUE, _IsDisplayHeaders, _UseUTF8, Data);

    if (_pSessionCookie != NULL)
    {
        _SessionCookieLock.AcquireReaderLock();
        hr = pEcb->SetXspSessionCookieForRequest(_pSessionCookie);
        _SessionCookieLock.ReleaseReaderLock();
        ON_ERROR_EXIT();
    }

    pEcb->AddRef();

    if (CallExtensionProc(pEcb) == HSE_STATUS_PENDING) 
    {

        // wait until ISAPI calls SSF(DONE_WITH_SESSION)
        WaitForSingleObject(_hResultArrivedEvent, INFINITE);
    } else {

        // no pending, no need to hold a reference
        pEcb->Release();
    }

    pResponseBuffer = pEcb->GetResponseBuffer();
    if(pResponseBuffer == NULL) {
        pResponseBuffer = "(NULL)";
    }

    ResponseLength = pEcb->GetResponseLength();
    if(ResponseLength == 0) 
    {
        ResponseLength = strlen(pResponseBuffer);
    } 

    pWideResponse = new WCHAR[ResponseLength];
    ON_OOM_EXIT(pWideResponse);

    if(MultiByteToWideChar(
        _UseUTF8 ? CP_UTF8 : CP_ACP, 
        0, 
        pResponseBuffer, 
        ResponseLength,
        pWideResponse,
        ResponseLength
        ) == 0) 
    {
        EXIT_WITH_LAST_ERROR();
    }

    hr = pEcb->GetXspSessionCookieFromResponse(&pSessionCookie);
    ON_ERROR_EXIT();
    if (pSessionCookie != NULL)
    {
        _SessionCookieLock.AcquireWriterLock();
        pSessionCookieOld = _pSessionCookie;
        _pSessionCookie = pSessionCookie;
        _SessionCookieLock.ReleaseWriterLock();
        delete [] pSessionCookieOld;
    }

    *pResponse = SysAllocStringLen(pWideResponse, ResponseLength);
    ON_OOM_EXIT(*pResponse);

Cleanup:
    if (pEcb != NULL)
    {
        pEcb->Release();
    }

    delete pWideResponse;

    return hr;
}



HRESULT __stdcall 
EcbHost::AsyncGet( 
    BSTR File,
    BSTR QueryString,
    BSTR Headers,
    IDispatch  *pCallback,
    VARIANT  *pCookie)
{
    return ProcessAsyncRequest(
                L"GET",
                File,
                QueryString,
                Headers,
                NULL,
                pCallback,
                pCookie);
}
    
HRESULT __stdcall 
EcbHost::AsyncPost( 
    BSTR File,
    BSTR QueryString,
    BSTR Headers,
    BSTR Data,
    IDispatch  *pCallback,
    VARIANT  *pCookie)
{
    return ProcessAsyncRequest(
                L"POST",
                File,
                QueryString,
                Headers,
                Data,
                pCallback,
                pCookie);
}
    
HRESULT __stdcall 
EcbHost::ProcessAsyncRequest( 
    BSTR Verb,
    BSTR File,
    BSTR QueryString,
    BSTR Headers,
    BSTR Data,
    IDispatch  *pCallback,
    VARIANT  *pCookie)
{
    HRESULT hr = S_OK;
    Ecb * pEcb = NULL;

    if(_hDll == NULL)
    {
        hr = Use(NULL, NULL, NULL);
        ON_ERROR_EXIT();
    }


    pEcb = new Ecb();
    ON_OOM_EXIT(pEcb);

    hr = pEcb->Init(this, File, Verb, QueryString, Headers, 
        FALSE, _IsDisplayHeaders, _UseUTF8, Data, pCallback, pCookie);
    ON_ERROR_EXIT();

    // We are going to give pEcb to ISAPI, account for this
    pEcb->AddRef();


    // if there is a limit to the number of active requests
    if(_MaxActiveRequests != -1) 
    {
        while(_EcbCount > _MaxActiveRequests)
        {
            // process already queued responses
            DrainResponseQueue();

            // if no more responses, let other threads run
            if(_QueueLength == 0)
                Sleep(100);
        }
    }

    // Call into ISAPI
    if(CallExtensionProc(pEcb) != HSE_STATUS_PENDING) 
    {
        // no pending, no need to hold a reference
        pEcb->Release();
    }

Cleanup:
    pEcb->Release();

    return hr;
}
    
HRESULT __stdcall 
EcbHost::Drain( 
    long Requests
    )
{
    HRESULT hr = S_OK;

    while(_EcbCount > Requests) 
    {

        DrainResponseQueue();

        if(_QueueLength == 0) 
        {
            // There are no more responses, let other threads run
            Sleep(100);
        }

    }

    return hr;
}

    
HRESULT __stdcall 
EcbHost::get_ActiveRequests( 
        long *pEcbCount)
{
    ASSERT(pEcbCount);

    *pEcbCount = _EcbCount;

    return S_OK;
}


HRESULT __stdcall 
EcbHost::get_MaxActiveRequests(
        long *pMaxActiveRequests)
{
    ASSERT(pMaxActiveRequests);

    *pMaxActiveRequests = _MaxActiveRequests;

    return S_OK;
}

HRESULT __stdcall 
EcbHost::put_MaxActiveRequests(
        long MaxActiveRequests)
{
    _MaxActiveRequests = MaxActiveRequests;

    return S_OK;
}


HRESULT
WarmUp(Ecb *pEcb, xspmrt::_ISAPIRuntime * runtime)
{
    HRESULT hr = S_OK;
    char *  pCookie = NULL;
    int     i;
    int     restart;

    for (i = 0; i < 10; i++)
    {
        pEcb->AddRef();

        hr = runtime->ProcessRequest((int)pEcb, FALSE, &restart);
        ON_ERROR_EXIT();

        if (i == 0)
        {
            hr = pEcb->GetXspSessionCookieFromResponse(&pCookie);
            ON_ERROR_EXIT();

            if (pCookie != NULL)
            {
                hr = pEcb->SetXspSessionCookieForRequest(pCookie);
                delete [] pCookie;
                ON_ERROR_EXIT();
            }
        }

        pEcb->ResetResponse();
    }

Cleanup:
    return hr;
}


HRESULT
GetTiming(Ecb *pEcb, xspmrt::_ISAPIRuntime * runtime, DWORD * pcounter)
{
    HRESULT hr = S_OK;
    __int64 endTime, now;
    DWORD counter = 0;
    int restart;

    GetSystemTimeAsFileTime((FILETIME *)&endTime);
    endTime = endTime + (((__int64) pEcb->GetStressDuration()) * TICKS_PER_SEC);

    for (;;)
    {
        GetSystemTimeAsFileTime((FILETIME *)&now);
        if (now >= endTime)
            break;

        pEcb->AddRef();

        hr = runtime->ProcessRequest((int)pEcb, FALSE, &restart);
        ON_ERROR_EXIT();

        pEcb->ResetResponse();

        counter++;
    }

    *pcounter = counter;

Cleanup:
    return hr;
}


#define THROUGHPUT_TEST_DURATION 10

DWORD WINAPI 
ThroughputProc(LPVOID pVoid)
{
    HRESULT                 hr;
    Ecb *                   pEcb = (Ecb *)pVoid;
    xspmrt::_ISAPIRuntime * runtime = pEcb->GetEcbHost()->GetManagedRuntime();
    DWORD                   counter;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    ON_ERROR_EXIT();


    hr = WarmUp(pEcb, runtime);
    ON_ERROR_EXIT();

#if ICECAP
    StartProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
    NameProfile("ThroughputThread", PROFILE_THREADLEVEL,  PROFILE_CURRENTID);
    CommentMarkProfile(1, "Start Timing");
#endif

    hr = GetTiming(pEcb, runtime, &counter);
    ON_ERROR_EXIT();

#if ICECAP
    CommentMarkProfile(2, "End Timing");
    StopProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
#endif

    pEcb->IncrementCounter(counter);

Cleanup:
    CoUninitialize();

    return 0;
}

HRESULT __stdcall 
EcbHost::Throughput(
        BSTR File,
        long nThreads,
        long nSeconds,
        BSTR QueryString,
        BSTR Verb,
        BSTR Headers,
        BSTR Data,
        double *pResult)
{
    HRESULT hr = S_OK;
    HANDLE * Threads = NULL;
    Ecb * pEcb = NULL;
    long i, Counter;

    *pResult = 0.0;

    // make sure the host is initialized
    if(_hDll == NULL)
    {
        hr = Use(NULL, NULL, NULL);
        ON_ERROR_EXIT();
    }

    // if no nThreads, make it the number of CPUs we have
    if(nThreads == 0) 
    {
        SYSTEM_INFO si;

        GetSystemInfo(&si);
        nThreads = si.dwNumberOfProcessors;
    }

    Threads = new HANDLE[nThreads];

    // allocate and initialize new Ecb
    pEcb = new Ecb [nThreads];
    ON_OOM_EXIT(pEcb);
    for(i = 0; i < nThreads; i++) 
    {
        hr = pEcb[i].Init(this, File, Verb, QueryString, Headers, FALSE, FALSE, _UseUTF8, Data);
        pEcb[i].SetStressDuration(nSeconds);
        ON_ERROR_EXIT();
    }

    hr = pEcb->GetEcbHost()->GetManagedRuntime()->DoGCCollect();
    ON_ERROR_EXIT();

    // create as many threads as there are processors
    for(i = 0; i < nThreads; i++)
    {
        DWORD dwThreadId;

        Threads[i] = CreateThread(NULL, 0, ThroughputProc, pEcb + i, 0, &dwThreadId);
        if(Threads[i] == NULL)
            EXIT_WITH_LAST_ERROR();
    }

    // wait until all threads are done and close all handles
    WaitForMultipleObjects(nThreads, Threads, TRUE, INFINITE);

    Counter = 0;
    for(i = 0; i < nThreads; i++)
    {
        Counter += pEcb[i].GetCounter();
        CloseHandle(Threads[i]);
    }

    *pResult = ((double) Counter) / ((double)pEcb->GetStressDuration());

Cleanup:
    delete [] Threads;
    delete [] pEcb;
    return hr;
}

        
HRESULT __stdcall 
EcbHost::get_IsDisplayHeaders(VARIANT_BOOL * IsDisplayHeaders)
{
    *IsDisplayHeaders = (_IsDisplayHeaders) ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}


HRESULT __stdcall 
EcbHost::put_IsDisplayHeaders(VARIANT_BOOL IsDisplayHeaders)
{
    _IsDisplayHeaders = (IsDisplayHeaders != VARIANT_FALSE);
    return S_OK;
}


HRESULT __stdcall 
EcbHost::get_UseUTF8(VARIANT_BOOL *pUseUTF8)
{
    *pUseUTF8 = (_UseUTF8) ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

HRESULT __stdcall 
EcbHost::put_UseUTF8(VARIANT_BOOL UseUTF8)
{
    _UseUTF8 = (UseUTF8 != VARIANT_FALSE);
    return S_OK;
}



HRESULT
EcbHost::MapPath(
    LPVOID lpvBuffer,
    LPDWORD lpdwSize
    )
{
    HRESULT hr = S_OK;
    char *curdir = NULL;
    const char *dir = _szPathTranslated;

    // try to map within the supplied-pathinfo hierarchy

    int lpath = strlen((CHAR *)lpvBuffer);
    int lroot = strlen(_szPathInfo);
    int lrdir = strlen(_szPathTranslated);

    // but if we're outside this directory, root at the current directory instead of pathtranslated

    if (lpath < lroot || strncmp(_szPathInfo, (CHAR *)lpvBuffer, lroot) != 0)
    {
        WCHAR *curdirw = (WCHAR *) MemAlloc(MAX_PATH * sizeof(WCHAR));
        ON_OOM_EXIT(curdirw);
        if (!GetCurrentDirectory(MAX_PATH, (WCHAR *)curdirw))
        {
            MemFree(curdirw);
            EXIT_WITH_LAST_ERROR();
        }

        curdir = DupStrA(curdirw);
        MemFree(curdirw);
        ON_OOM_EXIT(curdir);

        lroot = 0;
        lrdir = strlen(curdir);
        dir = curdir;
    }
    
    // strip trailing slashes

    if (lroot > 0 && _szPathInfo[lroot - 1] == '/')
        lroot --;

    if (lrdir > 0 && dir[lrdir - 1] == '\\')
        lrdir --;

    // detect insufficient memory

    if (*lpdwSize <= (unsigned)(lrdir + lpath - lroot + 1))
    {
        *lpdwSize = (lrdir + lpath - lroot + 1);
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return hr;
    }

    // reconcatenate and change / to \

    memmove(lrdir + (CHAR *)lpvBuffer, lroot + (CHAR *)lpvBuffer, lpath - lroot + 1);
    memcpy((CHAR *)lpvBuffer, dir, lrdir);

    char *pch;
    for (pch = (CHAR *)lpvBuffer + lrdir; *pch; pch++)
    {
        if (*pch == '/')
            *pch = '\\';
    }

    // free any allocated memory

Cleanup:
    MemFree(curdir);

    return hr;
}
    


/**
 * Wrapper for Ecb::GetServerVariable
 */
BOOL WINAPI 
GetServerVariable(
    HCONN       ConnID,
    LPSTR       lpszVariableName,
    LPVOID      lpvBuffer,
    LPDWORD     lpdwSize 
    )
{
    Ecb * pECB = static_cast<Ecb *>(ConnID);

    return (pECB->GetServerVariable(
                    lpszVariableName, 
                    lpvBuffer, 
                    lpdwSize
                    ) == S_OK);
}                                 

/**
 * Wrapper for Ecb::WriteClient
 */
BOOL WINAPI 
WriteClient(
    HCONN      ConnID,
    LPVOID     Buffer,
    LPDWORD    lpdwBytes,
    DWORD      dwReserved 
    )
{
    Ecb * pECB = static_cast<Ecb *>(ConnID);

    return (pECB->WriteClient(
                    Buffer, 
                    lpdwBytes, 
                    dwReserved
                    ) == S_OK);
}

/**
 * Wrapper for Ecb::ReadClient
 */
BOOL WINAPI 
ReadClient(
    HCONN      ConnID,
    LPVOID     lpvBuffer,
    LPDWORD    lpdwSize 
    )
{
    Ecb * pEcb = static_cast<Ecb *>(ConnID);

    return (pEcb->ReadClient(lpvBuffer, lpdwSize) == S_OK);
}


/**
 * Wrapper for Ecb::ServerSupportFunction
 */
BOOL WINAPI 
ServerSupportFunction(
    HCONN      ConnID,
    DWORD      dwHSERequest,
    LPVOID     lpvBuffer,
    LPDWORD    lpdwSize,
    LPDWORD    lpdwDataType 
    )
{
    Ecb * pECB = static_cast<Ecb *>(ConnID);

    return (pECB->ServerSupportFunction(
                    dwHSERequest,
                    lpvBuffer,
                    lpdwSize,
                    lpdwDataType 
                    ) == S_OK);
}




/**
 * Constructor
 */
Ecb::Ecb()
{
    _RefCount = 1; 
}

/**
 * Destructor
 */
Ecb::~Ecb()
{

    _pEcbHost->DecEcbCount();

    VariantClear(&Cookie);

    MemFree(_ECB.lpszMethod);
    MemFree(_ECB.lpszQueryString);
    MemFree(_ECB.lpszPathInfo);
    MemFree(_ECB.lpszPathTranslated);
    MemFree(_ECB.lpszContentType);
    MemFree(_ECB.lpbData);
    MemFree(_pResponse);
    MemFree(_pStatus);
    MemFree(_pResponseHeaders);
    MemFree(_pSessionCookie);
    MemFree(_szUrl);
}


void 
Ecb::ResetResponse()
{
    _ResponseLength = 0; 
    MemClear(&_pStatus);
    MemClear(&_pResponseHeaders);
    _fHeadersReceived = FALSE;
}

/**
 * Prepare Ecb for a call
 */
HRESULT
Ecb::Init(
    EcbHost * pEcbHost,
    BSTR File,
    BSTR Verb,
    BSTR QueryString,
    BSTR Headers,
    BOOL WaitForCompletion,
    BOOL DisplayHeaders,
    BOOL UseUTF8,
    BSTR Data,
    IDispatch *pCallback,
    VARIANT  *pCookie
    )
{
    HRESULT hr = S_OK;
    WCHAR * pContentType;
    char * pLastSlash = NULL;

    _pEcbHost = pEcbHost;
    _pEcbHost->IncEcbCount();

    _fDisplayHeaders = DisplayHeaders;
    _fUseUTF8 = UseUTF8;
    _WaitForCompletion = WaitForCompletion;
    _pCallback = pCallback;
    VariantInit(&Cookie);

    if (pCookie != NULL) 
    {
        hr = VariantCopy(&Cookie, pCookie);
        ON_ERROR_EXIT();
    }

    _ECB.cbSize = sizeof(_ECB);
    _ECB.dwVersion = MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR);
    _ECB.ConnID = (HCONN) this;
    _ECB.dwHTTPStatusCode = 200;
    _ECB.lpszLogData[0] = '\0';

    _ECB.lpszMethod = DupStrA(Verb);
    ON_OOM_EXIT(_ECB.lpszMethod);

    _ECB.lpszQueryString = DupStrA(QueryString);
    ON_OOM_EXIT(_ECB.lpszQueryString);

    _ECB.lpszPathInfo = DupConcatStrA(_pEcbHost->GetPathInfo(), File, '/');
    ON_OOM_EXIT(_ECB.lpszPathInfo);

    // attempt to recover user-supplied "Content-Type:" from headers, if any
    pContentType = NULL;
    if(Headers) 
    {
        _wcslwr(Headers);
        pContentType = wcsstr(Headers,L"content-type:");

        if(pContentType)
        {
            // Found, skip past it
            pContentType += wcslen(L"content-type:");

            WCHAR c;

            // Skip any blank space after colon
            for(;;) {
                c = *pContentType;
                if (c != L' ')
                    break;
                pContentType++;
            }

            // Find the end of it and zero-terminate it
            for(WCHAR *p = pContentType;;)
            {
                c = *p;
                if(c == L'\0' || c == L'\r' || c == L'\n')
                {
                    *p = '\0';
                    break;
                }
                p++;
            }
        }
    }

    if(pContentType == NULL)
        pContentType = L"text/plain";

    _ECB.lpszContentType = DupStrA(pContentType);
    ON_OOM_EXIT(_ECB.lpszContentType);

    _ECB.lpszPathTranslated = DupConcatStrA(_pEcbHost->GetPathTranslated(), File, '\\');
    ON_OOM_EXIT(_ECB.lpszPathTranslated);
    
    _ECB.lpbData = (BYTE *)DupStrA(Data);
    if(_ECB.lpbData != NULL) 
    {
        _ECB.cbTotalBytes = _ECB.cbAvailable = strlen((char *)_ECB.lpbData);
    } else {
        _ECB.cbTotalBytes = _ECB.cbAvailable = 0;
    }

    _szUrl = DupConcatStrA(_pEcbHost->GetPathInfo(), File, '/');
    ON_OOM_EXIT(_szUrl);

    _ECB.GetServerVariable = ::GetServerVariable;
    _ECB.WriteClient = ::WriteClient;
    _ECB.ReadClient = ::ReadClient;
    _ECB.ServerSupportFunction = ::ServerSupportFunction;

    // See if entry point is present
    pLastSlash = strrchr(_szUrl, '/');
    if(pLastSlash) 
    {
        char *pDotAfterSlash = strchr(pLastSlash, '.');
        if(pDotAfterSlash == NULL) 
        {
            // No dots after last slash. Must be entry point. Strip it.
            *pLastSlash = '\0';
        }
    }

Cleanup:
    return hr;
}

/**
 *
 */
HRESULT
Ecb::DoCallback()
{
    HRESULT hr = NULL;

    WCHAR *pWideResult = NULL;

    if(_pCallback != NULL)
    {
        if(_ResponseLength != 0)
        {
            pWideResult = new WCHAR[_ResponseLength];
            ON_OOM_EXIT(pWideResult);

            MultiByteToWideChar(
                _fUseUTF8 ? CP_UTF8 : CP_ACP, 
                0, 
                (const char *)(_pResponse), 
                _ResponseLength, 
                pWideResult, 
                _ResponseLength);

            hr = CallDelegate(_pCallback, &Cookie, pWideResult);

        } else {

            hr = CallDelegate(_pCallback, &Cookie, L"(NULL)");
        }
    }

Cleanup:
    delete [] pWideResult; 

    return hr;
}

/**
 * Refcounting release which may lead to destruction
 */
ULONG
Ecb::Release()
{
    LONG lResult = InterlockedDecrement(&_RefCount);

    ASSERT(lResult >= 0);
    
    // If there are still references, return
    if(lResult > 0) 
    {
        return lResult;
    }

    if(!_WaitForCompletion) 
    {

        // Don't delete Async requests, queue them instead
        _pEcbHost->QueueResponse(this);

    } else {

        // Delete Ecb for sync requests
        delete this;
    }

    return 0L;
}

/**
 * Return environment variable value.
 */
HRESULT 
Ecb::GetServerVariable(
    LPSTR lpszVariableName,
    LPVOID lpvBuffer,
    LPDWORD lpdwSize
    )
{
    HRESULT hr = S_OK;

    ASSERT(lpszVariableName);

    if (strcmp(lpszVariableName, "ALL_HTTP") == 0)
    {
        hr = CopyToServerVariable(
                lpvBuffer, 
                lpdwSize,
                "HTTP_ACCEPT:*/*\r\n"
                "HTTP_ACCEPT_LANGUAGE:en-us\r\n"
                "HTTP_CONNECTION:Keep-Alive\r\n"
                "HTTP_HOST:localhost\r\n"
                "HTTP_USER_AGENT:" ECBHOST_USER_AGENT "\r\n"
                "HTTP_ACCEPT_ENCODING:gzip, deflate\r\n"
                );
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "ALL_RAW") == 0)
    {
        hr = CopyToServerVariable(
                lpvBuffer, 
                lpdwSize,
                "Accept: */*\r\n"
                "Accept-Language: en-us\r\n"
                "Connection: Keep-Alive\r\n"
                "Host: localhost\r\n"
                "User-Agent: " ECBHOST_USER_AGENT "\r\n"
                "Accept-Encoding: gzip, deflate\r\n"
                );
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "APPL_MD_PATH") == 0)
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, "/LM/W3SVC/1/Root");
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, _pEcbHost->GetSZPathInfo());
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "APPL_PHYSICAL_PATH") == 0) 
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, _pEcbHost->GetSZPathTranslated());
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "PATH_INFO") == 0) 
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, _ECB.lpszPathInfo);
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "PATH_TRANSLATED") == 0) 
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, _ECB.lpszPathTranslated);
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "QUERY_STRING") == 0) 
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, _ECB.lpszQueryString);
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "REMOTE_ADDR") == 0) 
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, "127.0.0.1");
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "REMOTE_HOST") == 0) 
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, "localhost");
        goto Cleanup;
    }


    if(strcmp(lpszVariableName, "REQUEST_METHOD") == 0) 
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, _ECB.lpszMethod);
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "SCRIPT_NAME") == 0) 
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, _ECB.lpszPathInfo);
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "SERVER_NAME") == 0) 
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, "localhost");
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "SERVER_PORT") == 0) 
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, "80");
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "URL") == 0) 
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, _szUrl);
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "HTTP_ACCEPT") == 0) 
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, "*/*");
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "HTTP_ACCEPT_LANGUAGE") == 0) 
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, "en-us");
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "HTTP_CONNECTION") == 0) 
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, "Keep-Alive");
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "HTTP_HOST") == 0) 
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, "localhost");
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "HTTP_USER_AGENT") == 0) 
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, ECBHOST_USER_AGENT);
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "HTTP_COOKIE") == 0 && _pSessionCookie != NULL) 
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, _pSessionCookie);
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "HTTP_ACCEPT_ENCODING") == 0) 
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, "gzip, deflate");
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "HTTPS") == 0) 
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, "off");
        goto Cleanup;
    }

    if(strcmp(lpszVariableName, "HTTP_REFERER") == 0) 
    {
        hr = CopyToServerVariable(lpvBuffer, lpdwSize, "");
        goto Cleanup;
    }


#if 0
    WCHAR buffer[1024];

    MultiByteToWideChar(CP_ACP, 0, lpszVariableName, -1, buffer, ARRAY_SIZE(buffer));

    TRACE1(TAG_INTERNAL, L"Unimplemented GetServerVariable:%s", buffer);
#endif

    // Return ""

    if (lpvBuffer != NULL && *lpdwSize != 0)
        *((CHAR *)lpvBuffer) = '\0';

    *lpdwSize = 0;                  

Cleanup:
    if(hr != S_OK && hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
    {
        TRACE_ERROR(hr);
    }
    return hr;
}

/**
 * Simple buffered write
 */
HRESULT  
Ecb::WriteClient(
    LPVOID Buffer,
    LPDWORD lpdwBytes,
    DWORD dwReserved
    )
{
    HRESULT hr = S_OK;

    if(lpdwBytes == NULL || Buffer == NULL)
        EXIT_WITH_WIN32_ERROR(ERROR_INVALID_PARAMETER);

    // ignore zero-length writes just like IIS does
    if(*lpdwBytes == 0)
        EXIT();

    // if buffer is not large enough, resize it
    while(*lpdwBytes + _ResponseLength >= _ResponseSize) 
    {
        DWORD NewResponseSize;
        BYTE* pNewResponseBuffer;

        NewResponseSize = _ResponseSize ? (_ResponseSize * 2) : 1024;
        pNewResponseBuffer = (BYTE*) MemReAlloc(_pResponse, NewResponseSize); 
        ON_OOM_EXIT(pNewResponseBuffer);

        _pResponse = pNewResponseBuffer;
        _ResponseSize = NewResponseSize;
    }

    // Append response data to the buffer
    CopyMemory(_pResponse + _ResponseLength, Buffer, *lpdwBytes);
    _ResponseLength += *lpdwBytes;

Cleanup:

    // call async IO completion callback if set
    if (hr == S_OK && dwReserved == HSE_IO_ASYNC && _AsyncIoCallback != NULL)
        (*_AsyncIoCallback)(&_ECB, _pAsyncIoContext, 0, 0);

    return hr;
}

/**
 * ReadClient -- NOT IMPLEMENTED. 
 */
HRESULT   
Ecb::ReadClient(
    LPVOID lpvBuffer,
    LPDWORD lpdwSize 
    )
{
    HRESULT hr;

    UNREFERENCED_PARAMETER(lpvBuffer);
    UNREFERENCED_PARAMETER(lpdwSize);

    EXIT_WITH_WIN32_ERROR(ERROR_NOT_SUPPORTED);

Cleanup:
    return hr;
}

/**
 * Very basic implementation of server support function.
 */
HRESULT
Ecb::ServerSupportFunction(
    DWORD dwHSERequest,
    LPVOID lpvBuffer,
    LPDWORD lpdwSize,
    LPDWORD lpdwDataType
    )
{
    DWORD Count;
    HRESULT hr = S_OK;
    int     statusLength, responseHeadersLength;

    switch(dwHSERequest)
    {
    case HSE_REQ_SEND_RESPONSE_HEADER:
        {
            if (_fHeadersReceived)
                EXIT_WITH_HRESULT(E_UNEXPECTED);

            _fHeadersReceived = TRUE;

            _pStatus = DupStr((LPSTR) lpvBuffer);
            statusLength = _pStatus ? strlen(_pStatus) : 0;

            _pResponseHeaders = DupStr((LPSTR) lpdwDataType);
            responseHeadersLength = _pResponseHeaders ? strlen(_pResponseHeaders) : 0;

            if (_fDisplayHeaders)
            {
                if (statusLength > 0)
                {
                    hr = WriteClient((void *)_pStatus, (DWORD *) &statusLength, 0);
                    ON_ERROR_EXIT();

                    Count = 2;
                    hr = WriteClient("\r\n", &Count, 0);
                    ON_ERROR_EXIT();
                }

                if (responseHeadersLength > 0)
                {
                    hr = WriteClient((void *)_pResponseHeaders, (DWORD *) &responseHeadersLength, 0);
                    ON_ERROR_EXIT();
                }
            }
        }
        break;

    case HSE_REQ_SEND_RESPONSE_HEADER_EX:
        {
            HSE_SEND_HEADER_EX_INFO *pHdr = (HSE_SEND_HEADER_EX_INFO *)lpvBuffer;
            ASSERT(pHdr);

            if (_fHeadersReceived)
                EXIT_WITH_HRESULT(E_UNEXPECTED);

            _fHeadersReceived = TRUE;

            _pStatus = DupStr(pHdr->pszStatus);
            statusLength = _pStatus ? strlen(_pStatus) : 0;

            _pResponseHeaders = DupStr(pHdr->pszHeader);
            responseHeadersLength = _pResponseHeaders ? strlen(_pResponseHeaders) : 0;

            if (_fDisplayHeaders)
            {
                if (statusLength > 0)
                {
                    hr = WriteClient((void *)_pStatus, (DWORD *) &statusLength, 0);
                    ON_ERROR_EXIT();

                    Count = 2;
                    hr = WriteClient("\r\n", &Count, 0);
                    ON_ERROR_EXIT();
                }

                if (responseHeadersLength > 0)
                {
                    hr = WriteClient((void *)_pResponseHeaders, (DWORD *) &responseHeadersLength, 0);
                    ON_ERROR_EXIT();
                }
            }
        }
        break;

    case HSE_REQ_DONE_WITH_SESSION:

        if(_WaitForCompletion) 
        {
            hr = _pEcbHost->SignalResultArrived();
            ON_ERROR_EXIT();
        }
        Release();
        break;

    case HSE_REQ_MAP_URL_TO_PATH:
    case HSE_REQ_MAP_URL_TO_PATH_EX:
        hr = _pEcbHost->MapPath(lpvBuffer, lpdwSize);
        break;

    case HSE_REQ_IO_COMPLETION:
        _AsyncIoCallback = (PFN_HSE_IO_COMPLETION)lpvBuffer;
        _pAsyncIoContext = lpdwDataType;
        break;

    case HSE_REQ_GET_IMPERSONATION_TOKEN:  {
        BOOL fRet = OpenProcessToken(
                GetCurrentProcess(), 
                TOKEN_ALL_ACCESS, 
                (HANDLE *) lpvBuffer);
        ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);
    }
    break;
        
    default:
        TRACE1(TAG_INTERNAL, L"Unimplemented SSF Request: %d", dwHSERequest);
        EXIT_WITH_WIN32_ERROR(ERROR_NOT_SUPPORTED);
    }

Cleanup:
    return hr;
}
 


char SessionIdName[] = "AspSessionId=";

HRESULT
Ecb::SetXspSessionCookieForRequest(char * pCookie)
{
    HRESULT hr = S_OK;
    ASSERT(pCookie != NULL);

    _pSessionCookie = DupStr(pCookie);
    ON_OOM_EXIT(_pSessionCookie);

Cleanup:
    return hr;
}

HRESULT
Ecb::GetXspSessionCookieFromResponse(char ** pCookie)
{
    HRESULT hr = S_OK;
    char    *pSessionId, *pSessionIdEnd;
    BOOL    done;
    int     len;

    *pCookie = NULL;
    if (_pResponseHeaders != NULL)
    {
        pSessionId = strstr(_pResponseHeaders, SessionIdName);
        if (pSessionId != NULL)
        {
            pSessionIdEnd = pSessionId + (ARRAY_SIZE(SessionIdName) - 1);
            done = FALSE;
            while (!done)
            {
                switch (*pSessionIdEnd++)
                {
                case ';':
                case ',':
                case ' ':
                case '\r':
                case '\n':
                    done = TRUE;
                    break;
                }
            }
            
            len = pSessionIdEnd - pSessionId;
            *pCookie = new char[len + 1];
            ON_OOM_EXIT(*pCookie);
            CopyMemory(*pCookie, pSessionId, len * sizeof(*pSessionId));
            (*pCookie)[len] = '\0';
        }
    }

Cleanup:    
    return hr;
}

/**
 * Create an instance of EcbHost.
 */
HRESULT CreateEcbHost(IDispatch ** ppIDispatch)
{
    HRESULT hr = S_OK;

    EcbHost * pEcbHost = new EcbHost;
    ON_OOM_EXIT(pEcbHost);

    hr = pEcbHost->QueryInterface(IID_IDispatch, (void **) ppIDispatch);

    pEcbHost->Release();

Cleanup:
    return hr;
}


/**
 * Retrieve W3SVC/1/ROOT/Path into *ppPathTranslated.
 * It is caller's responsibility to free it.
 */
HRESULT 
GetWebRootDir(
    WCHAR ** ppPathTranslated
    )
{
    HRESULT hr = S_OK;

    BIND_OPTS opts;
    IADs *pADs = NULL;
    BSTR VrPath = NULL;
    VARIANT RootPath;

    *ppPathTranslated = NULL;

    VrPath = SysAllocString(L"Path");
    ON_OOM_EXIT(VrPath);

    VariantInit(&RootPath);

    ZeroMemory(&opts, sizeof(opts));
    opts.cbStruct = sizeof(opts);

    hr = CoGetObject(L"IIS://localhost/w3svc/1/ROOT", &opts, __uuidof(IADs), (void **)&pADs);
    ON_ERROR_EXIT();

    hr = pADs->Get(VrPath, &RootPath);
    ON_ERROR_EXIT();

    *ppPathTranslated = DupStr(V_BSTR(&RootPath));

Cleanup:

    VariantClear(&RootPath);

    if(VrPath) 
        SysFreeString(VrPath);
    return hr;
}

/**
 * Call into managed code through Delegate mechanism
 */
HRESULT
CallDelegate(
    IDispatch * pDelegate, 
    VARIANT *   pCookie, 
    WCHAR *     WideResult
    )
{
    HRESULT     hr;
    VARIANT     args[2];
    DISPPARAMS  dp;
    EXCEPINFO   ei;
    UINT        uArgErr = 0;


    // Prepare exception handling for a call
    ExcepInfoInit(&ei);

    // Prepare arguments
    args[0] = *pCookie;
    V_BSTR(&args[1]) = SysAllocString(WideResult);
    ON_OOM_EXIT(V_BSTR(&args[1]));

    V_VT(&args[1]) = VT_BSTR;

    // Prepare dispatch parameters
    dp.rgvarg            = args;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs             = ARRAY_SIZE(args);
    dp.cNamedArgs        = 0;

    if(pDelegate) 
    {

        // Invoke the function, return result
        hr = pDelegate->Invoke(
                DISPID_VALUE,
                IID_NULL,
                0,
                DISPATCH_METHOD,
                &dp,
                NULL,
                &ei,
                &uArgErr);
    } else {
        EXIT_WITH_WIN32_ERROR(ERROR_INVALID_PARAMETER);
    }

Cleanup:
    SysFreeString(V_BSTR(&args[1]));
    ExcepInfoClear(&ei);

    return hr;
}
    


/**
 * Concatenate the specified string to server variable buffer.
 * If insufficient space available, just move as many bytes as possible 
 * to *pcbData. Update the buffer pointer and the available byte count.
 */
HRESULT 
CopyToServerVariable(
    PVOID &pvData, 
    PDWORD &pcbData, 
    const CHAR *pString
    )
{
    HRESULT hr = S_OK;
    CHAR *pBuffer = static_cast<CHAR *>(pvData);
    size_t StringLength, CopyLength;
    
    ASSERT(pString);

    StringLength = strlen(pString) + 1;


    if(StringLength <= *pcbData)
    {
        // if original string was zero-terminated,
        // so will be the target
        MoveMemory(pBuffer, pString, StringLength);
        pBuffer += StringLength;
        *pcbData += StringLength;

    } else {
        // The string will not fit into buffer
        // and it is not garanteed to be zero-terminated
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        SetLastError(ERROR_INSUFFICIENT_BUFFER);

        CopyLength = min((int) *pcbData, (int) StringLength);

        if(pBuffer && (CopyLength != 0)) {
            MoveMemory(pBuffer, pString, CopyLength);
            pBuffer += CopyLength;
        }

        *pcbData = StringLength;
    }

    pvData = static_cast<PVOID>(pBuffer);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tool\regcollect.cxx ===
/**
 * regcollect.cxx
 * 
 * Implements a collection of registry value names.
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */


#include "precomp.h"
#include "_exe.h"

struct 
{
    LPWSTR  name;
    HKEY    key;
} 
g_StrToKey[] = 
{
    L"HKCU",                HKEY_CURRENT_USER,
    L"HKLM",                HKEY_LOCAL_MACHINE,
    L"HKCR",                HKEY_CLASSES_ROOT, 
    L"HKEY_CURRENT_USER",   HKEY_CURRENT_USER,      
    L"HKEY_LOCAL_MACHINE",  HKEY_LOCAL_MACHINE,     
    L"HKEY_CLASSES_ROOT",   HKEY_CLASSES_ROOT,      
    L"HKEY_USERS",          HKEY_USERS,             
    L"HKEY_CURRENT_CONFIG", HKEY_CURRENT_CONFIG,    
};


/**
 * Open the key.
 * 
 * @param KeyName
 */
HRESULT 
RegValueCollection::Init(BSTR KeyName)
{
    HRESULT hr = S_OK;
    long    err;
    int     i;    
    int     prefixLen = 0;

    for (i = ARRAY_SIZE(g_StrToKey); --i > 0;)
    {
        prefixLen = wcslen(g_StrToKey[i].name);
        if (!_wcsnicmp(g_StrToKey[i].name, KeyName, prefixLen))
            break;
    }

    if (i == -1)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    err = RegOpenKeyEx(g_StrToKey[i].key, KeyName + prefixLen + 1, 0, KEY_READ, &_key);
    ON_WIN32_ERROR_EXIT(err);

Cleanup:
    return hr;    
}



RegValueCollection::~RegValueCollection()
{
    if (_key != NULL)
    {
        RegCloseKey(_key);
    }
}



STDMETHODIMP
RegValueCollection::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == __uuidof(IRegValueCollection))
    {
        *ppv = (IRegValueCollection *)this;
    }
    else
    {
        return BaseObject::QueryInterface(iid, ppv);
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}



/**
 * Return the number of values.
 * 
 * @param Count
 * @return 
 */
STDMETHODIMP
RegValueCollection::get_Count(long *Count)
{
    HRESULT hr = S_OK;
    long    err;

    *Count = 0;
    err = RegQueryInfoKey(
            _key, NULL, NULL, NULL, NULL, NULL, NULL,
            (DWORD *) Count, NULL, NULL, NULL, NULL);


    ON_WIN32_ERROR_EXIT(err);

Cleanup:
    return hr;
}



/**
 * This method is not yet needed.
 * 
 * @param Index
 * @param Value
 * @return 
 */
STDMETHODIMP
RegValueCollection::get_Item(VARIANT Index, VARIANT * Value)
{
    UNREFERENCED_PARAMETER(Index);
    UNREFERENCED_PARAMETER(Value);

    return E_NOTIMPL;
}


/**
 * Implements the enumerator object for a collection.
 * 
 */
class FAR RegEnumVariant : public IEnumVARIANT
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    RegEnumVariant(RegValueCollection * pCollection, int i);
    virtual ~RegEnumVariant();

    // IUnknown methods 
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IEnumVARIANT methods 
    STDMETHOD(Next)(ULONG cElements, VARIANT FAR* pvar, ULONG FAR* pcElementFetched);
    STDMETHOD(Skip)(ULONG cElements);
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumVARIANT FAR* FAR* ppenum);
    
    static HRESULT Create(RegValueCollection * pCollection, int i, IUnknown ** ppenum);

private:
    RegValueCollection *    _pCollection;
    long                    _refs;
    int                     _i;
};

RegEnumVariant::RegEnumVariant(RegValueCollection * pCollection, int i)
{
    _refs = 1;

    _i = i;
    _pCollection = pCollection;
    _pCollection->AddRef();
}

RegEnumVariant::~RegEnumVariant()
{
    _pCollection->Release();
}

ULONG
RegEnumVariant::AddRef()
{
    _refs += 1;
    return _refs;
}

ULONG
RegEnumVariant::Release()
{
    if (--_refs == 0)
    {
        delete this;
        return 0;
    }

    return _refs;
}

HRESULT
RegEnumVariant::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IEnumVARIANT || iid == IID_IUnknown)
    {
        *ppv = (IEnumVARIANT *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


/**
 * Return the next cElements. If there aren't cElements available,
 * return whatever is remaining in the enumeration and return S_FALSE.
 * 
 * @param cElements Number of elements desired.
 * @param pvar Array of elements to return.
 * @param pcElementFetched Number of elements actually returned.
 * @return 
 */
STDMETHODIMP
RegEnumVariant::Next(ULONG cElements, VARIANT FAR* pvar, ULONG FAR* pcElementFetched)
{
    HRESULT hr = S_OK;
    long    err;
    int     c;
    DWORD   cbName;
    BSTR    str;    
    int     iStart;
    ULONG   dummy;
    WCHAR   buf[1024];


    if (pcElementFetched == NULL)
    {
        pcElementFetched = &dummy;
    }

    iStart = _i;
    for (c = (int) cElements; --c >= 0;)
    {
        VariantInit(&pvar[c]);
    }

    for (c = (int) cElements; --c >= 0; _i++)
    {
        cbName = ARRAY_SIZE(buf);
        err = RegEnumValue(_pCollection->_key, _i, buf, &cbName, NULL, NULL, NULL, NULL);
        if (err == ERROR_NO_MORE_ITEMS)
            EXIT_WITH_SUCCESSFUL_HRESULT(S_FALSE);

        ON_WIN32_ERROR_EXIT(err);
        
        str = SysAllocString(buf);
        ON_OOM_EXIT(str);

        pvar[c].vt = VT_BSTR;
        pvar[c].bstrVal = str;
    }

Cleanup:
    if (SUCCEEDED(hr))
    {
        *pcElementFetched = _i - iStart;
    }
    else
    {
        for (c = (int) cElements; --c >= 0;)
        {
            VariantClear(&pvar[c]);
        }

        *pcElementFetched = 0;
        _i = iStart;
    }

    return hr;
}



/**
 * Skip over some elements in the enumeration.
 * 
 * @param cElements Number of elements to skip.
 * @return 
 */
STDMETHODIMP
RegEnumVariant::Skip(ULONG cElements)
{
    _i += cElements;

    return S_OK;
}



/**
 * Reset the enumeration to the beginning.
 * 
 * @return 
 */
STDMETHODIMP
RegEnumVariant::Reset()
{
    _i = 0;

    return S_OK;
}


/**
 * Create a new RegEnumVariant.
 * 
 * @param pCollection The collection to enumerate.
 * @param i The start index.
 * @param ppenum The resulting enumeration.
 * @return 
 */
HRESULT
RegEnumVariant::Create(RegValueCollection * pCollection, int i, IUnknown ** ppenum)
{
    HRESULT hr = S_OK;

    *ppenum = (IEnumVARIANT *) new RegEnumVariant(pCollection, i);
    ON_OOM_EXIT(*ppenum);
    
Cleanup:
    return hr;
}


/**
 * Clone the enumeration.
 * 
 * @param ppenum The clone.
 * @return 
 */
STDMETHODIMP
RegEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    return Create(_pCollection, _i, (IUnknown **) ppenum);
}



/**
 * Create an enumeration of this collection.
 * 
 * @param ppenum The enumeration.
 * @return 
 */
STDMETHODIMP
RegValueCollection::get__NewEnum(IUnknown ** ppenum)
{
    return RegEnumVariant::Create(this, 0, ppenum);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\perftoolrt\perftoolrt.cs ===
//------------------------------------------------------------------------------
// <copyright file="PerfToolRT.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**
 * PerfTool Managed Runtime
 *
 * Copyright (c) 1998 Microsoft Corporation
 */
namespace XSP.Tool
{
    using System.Text;
    using System.Runtime.InteropServices;
    using System;
    using System.IO;
    using System.Reflection;
    using System.Web;
    using System.Web.Util;

    class _NDirectNOOP : IPerfTest {

        public void DoTest() {
        }
    }

    class _NDirect0 : IPerfTest {
        [DllImport( "XSPTOOL.EXE", CharSet=CharSet.Ansi)]
        private static extern int NDirect0(int x);

        public void DoTest() {
            NDirect0(0);
        }
    }

    class _NDirectIn1A : IPerfTest {
        [DllImport( "XSPTOOL.EXE", CharSet=CharSet.Ansi)]
        private static extern int NDirectIn1A(string S1);

        public void DoTest() {
            NDirectIn1A("string 1");
        }
    }

    class _NDirectIn2A : IPerfTest {
        [DllImport( "XSPTOOL.EXE", CharSet=CharSet.Ansi)]
        private static extern int NDirectIn2A(string S1, string S2);

        public void DoTest() {
            NDirectIn2A("string 1", "string 2");
        }
    }

    class _NDirectIn3A : IPerfTest {
        [DllImport( "XSPTOOL.EXE", CharSet=CharSet.Ansi)]
        private static extern int NDirectIn3A(string S1, string S2, string S3);

        public void DoTest() {
            NDirectIn3A("string 1", "string 2", "string3");
        }
    }

    class _NDirectIn4A : IPerfTest {
        [DllImport( "XSPTOOL.EXE", CharSet=CharSet.Ansi)]
        private static extern int NDirectIn4A(string S1, string S2, string S3, string S4);

        public void DoTest() {
            NDirectIn4A("string 1", "string 2", "string3", "string 4");
        }
    }

    class _NDirectIn1U : IPerfTest {
        [DllImport( "XSPTOOL.EXE", CharSet=CharSet.Unicode)]
        private static extern int NDirectIn1U(string S1);

        public void DoTest() {
            NDirectIn1U("string 1");
        }
    }

    class _NDirectIn2U : IPerfTest {
        [DllImport( "XSPTOOL.EXE", CharSet=CharSet.Unicode)]
        private static extern int NDirectIn2U(string S1, string S2);

        public void DoTest() {
            NDirectIn2U("string 1", "string 2");
        }
    }

    class _NDirectIn3U : IPerfTest {
        [DllImport( "XSPTOOL.EXE", CharSet=CharSet.Unicode)]
        private static extern int NDirectIn3U(string S1, string S2, string S3);

        public void DoTest() {
            NDirectIn3U("string 1", "string 2", "String3");
        }
    }

    class _NDirectIn4U : IPerfTest {
        [DllImport( "XSPTOOL.EXE", CharSet=CharSet.Unicode)]
        private static extern int NDirectIn4U(string S1, string S2, string S3, string S4);

        public void DoTest() {
            NDirectIn4U("string 1", "string 2", "String3", "string 4");
        }
    }


    class _NDirectOut1A : IPerfTest {
        [DllImport( "XSPTOOL.EXE", CharSet=CharSet.Ansi)]
        private static extern void NDirectOut1A(StringBuilder S1);

        public void DoTest() {
            StringBuilder S1 = new StringBuilder(32);

            NDirectOut1A(S1); 
        }
    }

    class _NDirectOut2A : IPerfTest {
        [DllImport( "XSPTOOL.EXE", CharSet=CharSet.Ansi)]
        private static extern void NDirectOut2A(StringBuilder S1, StringBuilder S2);

        public void DoTest() {
            StringBuilder S1 = new StringBuilder(32);
            StringBuilder S2 = new StringBuilder(32);

            NDirectOut2A(S1, S2); 
        }
    }

    class _NDirectOut3A : IPerfTest {
        [DllImport( "XSPTOOL.EXE", CharSet=CharSet.Ansi)]
        private static extern void NDirectOut3A(StringBuilder S1, StringBuilder S2, StringBuilder S3);

        public void DoTest() {
            StringBuilder S1 = new StringBuilder(32);
            StringBuilder S2 = new StringBuilder(32);
            StringBuilder S3 = new StringBuilder(32);

            NDirectOut3A(S1, S2, S3); 
        }
    }

    class _NDirectOut4A : IPerfTest {
        [DllImport( "XSPTOOL.EXE", CharSet=CharSet.Ansi)]
        private static extern void NDirectOut4A(StringBuilder S1, StringBuilder S2, StringBuilder S3, StringBuilder S4);

        public void DoTest() {
            StringBuilder S1 = new StringBuilder(32);
            StringBuilder S2 = new StringBuilder(32);
            StringBuilder S3 = new StringBuilder(32);
            StringBuilder S4 = new StringBuilder(32);

            NDirectOut4A(S1, S2, S3, S4); 
        }
    }

    class _NDirectOut1U : IPerfTest {
        [DllImport( "XSPTOOL.EXE", CharSet=CharSet.Unicode)]
        private static extern void NDirectOut1U(StringBuilder S1);

        public void DoTest() {
            StringBuilder S1 = new StringBuilder(32);

            NDirectOut1U(S1); 
        }
    }

    class _NDirectOut2U : IPerfTest {
        [DllImport( "XSPTOOL.EXE", CharSet=CharSet.Unicode)]
        private static extern void NDirectOut2U(StringBuilder S1, StringBuilder S2);

        public void DoTest() {
            StringBuilder S1 = new StringBuilder(32);
            StringBuilder S2 = new StringBuilder(32);

            NDirectOut2U(S1, S2); 
        }
    }

    class _NDirectOut3U : IPerfTest {
        [DllImport( "XSPTOOL.EXE", CharSet=CharSet.Unicode)]
        private static extern void NDirectOut3U(StringBuilder S1, StringBuilder S2, StringBuilder S3);

        public void DoTest() {
            StringBuilder S1 = new StringBuilder(32);
            StringBuilder S2 = new StringBuilder(32);
            StringBuilder S3 = new StringBuilder(32);

            NDirectOut3U(S1, S2, S3); 
        }
    }

    class _NDirectOut4U : IPerfTest {
        [DllImport( "XSPTOOL.EXE", CharSet=CharSet.Unicode)]
        private static extern void NDirectOut4U(StringBuilder S1, StringBuilder S2, StringBuilder S3, StringBuilder S4);

        public void DoTest() {
            StringBuilder S1 = new StringBuilder(32);
            StringBuilder S2 = new StringBuilder(32);
            StringBuilder S3 = new StringBuilder(32);
            StringBuilder S4 = new StringBuilder(32);

            NDirectOut4U(S1, S2, S3, S4); 
        }
    }

    class Hello0 : IPerfTest {
        public void DoTest() {
            // nothing
        }
    }

    class Hello1 : IPerfTest {
        public void DoTest() {
        }
    }

    class NullWriter : StringWriter {
        StringBuilder sb;

        NullWriter(StringBuilder sb) {
            this.sb = sb;
        }

        //Methods 
        public override StringBuilder GetStringBuilder () {
            return sb; 
        }

        public override string ToString () {
            return "NullWriter"; 
        }

        public override void Write (char value) {
        }
        public override void Write (char [] buffer, int index, int count) {
        }
        public override void Write (string value) {
        }
    }

/*
class HelloWorldHandler : IHttpHandler
{
    public void ProcessRequest(HttpContext context)
    {
        context.Response.Write("<p>Hello World</p>\n");
    }

    public bool IsReusable 
    {
        get { return true; }
    }
}

class Hello2 : IPerfTest
{

    public void DoTest()
    {
        StringBuilder sb = new StringBuilder();
        StringWriter writer = new NullWriter(sb);

        try 
        {
            HttpContext context = new HttpContext(
                new HttpRequest("hello.xsp", "http://localhost/foo.xsp", "", ""),
                new HttpResponse(writer));

            IHttpHandler obj  = new HelloWorldHandler();
            obj.ProcessRequest(context);
        }

        catch(Exception e)
        {
        }
    }
}
*/

    class HelloArray : IPerfTest {
        [DllImport( "XSPTOOL.EXE", CharSet=CharSet.Ansi)]
        private static extern int NDirectIn1A(byte [] x);

        byte[] x;

        HelloArray() {
            int i;

            int ArraySize = 23;

            x = new byte[ArraySize];

            for (i = 0; i < ArraySize; i++)
                x[i] = (byte)(1000 - i);

        }

        public void DoTest() {
            NDirectIn1A(x);
        }
    }


    /// <include file='doc\PerfToolRT.uex' path='docs/doc[@for="IPerfToolRT"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [ComImport, uuid("81aad719-ddac-4d09-b39d-c5c138a829ee"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    public interface IPerfToolRT {
        /// <include file='doc\PerfToolRT.uex' path='docs/doc[@for="IPerfToolRT.SetupForNDirect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        
        void SetupForNDirect(
                            [In, MarshalAs(UnmanagedType.I4)]
                            /// <summary>
                            ///    <para>[To be supplied.]</para>
                            /// </summary>
                            int numArgs,
                            [In, MarshalAs(UnmanagedType.I4)]
                            /// <summary>
                            ///    <para>[To be supplied.]</para>
                            /// </summary>
                            int Unicode,
                            [In, MarshalAs(UnmanagedType.I4)]
                            /// <summary>
                            ///    <para>[To be supplied.]</para>
                            /// </summary>
                            int ProduceStrings);
        /// <include file='doc\PerfToolRT.uex' path='docs/doc[@for="IPerfToolRT.DoTest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        
        void DoTest();
        /// <include file='doc\PerfToolRT.uex' path='docs/doc[@for="IPerfToolRT.DoTest1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        
        void DoTest1(
                    [In, MarshalAs(UnmanagedType.I8)]
                    /// <summary>
                    ///    <para>[To be supplied.]</para>
                    /// </summary>
                    long number);
    }

    /// <include file='doc\PerfToolRT.uex' path='docs/doc[@for="PerfToolRT"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class PerfToolRT : IPerfToolRT {
        private Type _ObjectType = null;
        private IPerfTest _obj = null;

        void Setup(string ClassName) {

            if (ClassName == null || ClassName.Length == 0) {
                _ObjectType = null;
                _obj = null;
            }
            else {
                _ObjectType = Type.GetType(ClassName);
                if (_ObjectType != null) {
                    _obj = (IPerfTest) _ObjectType.CreateInstance();
                }
                else {
                    throw new ArgumentException();
                }
            }
        }

        /// <include file='doc\PerfToolRT.uex' path='docs/doc[@for="PerfToolRT.SetupForNDirect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetupForNDirect(int numArgs, int Unicode, int ProduceStrings) {
            _ObjectType = null;

            switch (numArgs) {
                case -1:
                    _obj = new _NDirectNOOP();
                    break;

                case 0:
                    _obj = new _NDirect0();
                    break;

                case 1 : 
                    if (ProduceStrings != 0) {
                        if (Unicode != 0) {
                            _obj = new _NDirectOut1U();
                        }
                        else {
                            _obj = new _NDirectOut1A();
                        }
                    }
                    else {
                        if (Unicode != 0) {
                            _obj = new _NDirectIn1U();
                        }
                        else {
                            _obj = new _NDirectIn1A();
                        }
                    }
                    break;

                case 2 : 
                    if (ProduceStrings != 0) {
                        if (Unicode != 0) {
                            _obj = new _NDirectOut2U();
                        }
                        else {
                            _obj = new _NDirectOut2A();
                        }
                    }
                    else {
                        if (Unicode != 0) {
                            _obj = new _NDirectIn2U();
                        }
                        else {
                            _obj = new _NDirectIn2A();
                        }
                    }
                    break;

                case 3 : 
                    if (ProduceStrings != 0) {
                        if (Unicode != 0) {
                            _obj = new _NDirectOut3U();
                        }
                        else {
                            _obj = new _NDirectOut3A();
                        }
                    }
                    else {
                        if (Unicode != 0) {
                            _obj = new _NDirectIn3U();
                        }
                        else {
                            _obj = new _NDirectIn3A();
                        }
                    }
                    break;

                case 4 : 
                    if (ProduceStrings != 0) {
                        if (Unicode != 0) {
                            _obj = new _NDirectOut4U();
                        }
                        else {
                            _obj = new _NDirectOut4A();
                        }
                    }
                    else {
                        if (Unicode != 0) {
                            _obj = new _NDirectIn4U();
                        }
                        else {
                            _obj = new _NDirectIn4A();
                        }
                    }
                    break;

                default:
                    throw new ArgumentException();
            }
        }



        /// <include file='doc\PerfToolRT.uex' path='docs/doc[@for="PerfToolRT.DoTest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void DoTest() {
            if (_obj != null) {
                _obj.DoTest();
            }
        }

        /// <include file='doc\PerfToolRT.uex' path='docs/doc[@for="PerfToolRT.DoTest1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void DoTest1(long number) {
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tool\perftool.cxx ===
/**
 * Simple PerfTool object implementation
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 */
#include "precomp.h"
#include "_exe.h"

#include "_perftoolrt.h"
#include "_isapiruntime.h"

#define RELEASE(x) if(x) { x->Release(); x = NULL; }

//
// Exported function to hookup to script host.
//
HRESULT CreatePerfTool(IDispatch **ppIDispatch);

//
// Local functions prototypes and macros
//
#define UNUSED(x) (void)(x)
#define FreePtr(x) if(x) {  MemFree((void *)x); x = NULL; } 

class PerfTool;

struct PerfThreadContext 
{
    PerfTool *pPerfTool;
    int ThreadNumber;
};

DWORD WINAPI PerfToolWorkerProc(void *pContext);


/**
 * PerfTool class definition
 */
class PerfTool 
    : public BaseObject, 
      public IPerfTool 
{
    volatile BOOL _fMeasurementInProgress;
    volatile BOOL _fCountCalls;
    int _ThreadCount;
    long *_CallCounts;
    HANDLE *_ThreadHandles;
    perftoolrt::_PerfToolRT * _pPerfRT;

public:

    // Scripting host support
    const IID *GetPrimaryIID() { return &__uuidof(IPerfTool); }
    IUnknown * GetPrimaryPtr() { return (IPerfTool *)(this); }
    STDMETHOD(QueryInterface(REFIID, void **));

    DELEGATE_IDISPATCH_TO_BASE();

    // Call into managed runtime
    void DoTest()
    {
        if(_pPerfRT != NULL) 
        {
            _pPerfRT->DoTest();
        }
    }

    // Worker thread access functions
    BOOL IsMeasurementInProgress() const 
    {
        return _fMeasurementInProgress;
    }

    BOOL AreWeCountingCalls() const
    {
        return _fCountCalls;
    }

    void SetCallCount(int ThreadNumber, long CallCount)
    {
        ASSERT(_CallCounts);
        ASSERT(ThreadNumber < _ThreadCount);

        _CallCounts[ThreadNumber] = CallCount;
    }

    HRESULT PrepareTest(int ThreadCount);
    double UnprepareTest();


    HRESULT _DoTest1(long number);


    // COM interface
    HRESULT __stdcall DoTest1(
        long number);

    HRESULT __stdcall get_ClassThroughput( 
        BSTR ClassName,
        long nThreads,
        long Duration,
        long WarmupTime,
        long CooldownTime,
        double *pResult);

    HRESULT __stdcall get_NativeThroughput(
        long nThreads,
        long Duration,
        long WarmupTime,
        long CoooldownTime,
        double *pResult);

    HRESULT __stdcall get_ClassAdjustedThroughput( 
        BSTR ClassName,
        long nThreads,
        long Duration,
        long WarmupTime,
        long CooldownTime,
        double *pResult);

    HRESULT __stdcall get_NDirectThroughput( 
        long nArgs,
        long fUnicode,
        long fBuildStrings,
        long nThreads,
        long Duration,
        long WarmupTime,
        long CooldownTime,
        double *pResult);

    HRESULT __stdcall get_NDirectAdjustedThroughput( 
        long nArgs,
        long fUnicode,
        long fBuildStrings,
        long nThreads,
        long Duration,
        long WarmupTime,
        long CooldownTime,
        double *pResult);
      
      
};

/**
 * Worker thread proc
 */
DWORD WINAPI 
PerfToolWorkerProc(void *pContext)
{
    PerfTool *pTool = ((PerfThreadContext *)pContext)->pPerfTool;
    int ThreadNumber = ((PerfThreadContext *)pContext)->ThreadNumber;
    long CallCount = 0;

    while(pTool->IsMeasurementInProgress())
    {

        pTool->DoTest();

        while(pTool->AreWeCountingCalls()) 
        {
            pTool->DoTest();
            CallCount++;
        }

        pTool->SetCallCount(ThreadNumber, CallCount);
    } 

    MemFree(pContext);

    return 0;
}

/**
 * Implements IUnknown::QueryInteface.
 */
HRESULT
PerfTool::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == __uuidof(IPerfTool))
    {
        *ppv = (IPerfTool *)this;
    }
    else
    {
        return BaseObject::QueryInterface(iid, ppv);
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


// Prepare for test -- allocate arrays for thread handles and counts,
// create threads, etc.
HRESULT 
PerfTool::PrepareTest(int ThreadCount)
{
    HRESULT hr = S_OK;
    HANDLE Handle;
    int ThreadNumber = 0;
    DWORD ThreadId;

    _ThreadCount = ThreadCount;

    if(ThreadCount == 0)
        EXIT_WITH_WIN32_ERROR(ERROR_INVALID_PARAMETER);

    _ThreadHandles = (HANDLE *)MemAllocClear(ThreadCount * sizeof(HANDLE));
    ON_OOM_EXIT(_ThreadHandles);

    _CallCounts = (long *)MemAllocClear(ThreadCount * sizeof(long));
    ON_OOM_EXIT(_CallCounts);

    // Make worker threads run
    _fMeasurementInProgress = TRUE;

    // But don't let them count calls yet
    _fCountCalls = FALSE;

    // Start our threads
    for(ThreadNumber = 0; ThreadNumber < ThreadCount; ThreadNumber++)
    {
        PerfThreadContext *pc = (PerfThreadContext *)MemAlloc(sizeof(*pc));

        ON_OOM_EXIT(pc);

        pc->pPerfTool = this;
        pc->ThreadNumber = ThreadNumber;

        Handle = CreateThread(
            NULL, 
            0,
            (LPTHREAD_START_ROUTINE) PerfToolWorkerProc,
            pc,
            0,
            &ThreadId);

        if(Handle == NULL)
            EXIT_WITH_LAST_ERROR();

        _ThreadHandles[ThreadNumber] = Handle;
    }
Cleanup:
    return hr;
}

/**
 * Wait until all threads done, calculate throughput, free arrays
 */
double 
PerfTool::UnprepareTest()
{
    double Result = 0.0;
    int ThreadNo;
    HANDLE Handle;

    _fMeasurementInProgress = FALSE;

    if(_ThreadCount != 0) 
    {

        if(_ThreadHandles != NULL) 
        {
            // Wait until all workers finished
            WaitForMultipleObjects(_ThreadCount, _ThreadHandles, TRUE, INFINITE);

            for(ThreadNo = 0; ThreadNo < _ThreadCount; ThreadNo++) 
            {
                Handle = _ThreadHandles[ThreadNo];
                if(Handle == NULL)
                    break;
                CloseHandle(Handle);
            }
            FreePtr(_ThreadHandles);
        }


        if(_CallCounts)
        {
            for(ThreadNo = 0; ThreadNo < _ThreadCount; ThreadNo++)
            {
                Result += 1.0 * _CallCounts[ThreadNo];
            }
            FreePtr(_CallCounts);
        }
    }

    return Result;
}

/**
 * The only reason for this function is that we want to "wt" 
 * _DoTest1() below -- that is to count instructions in 
 * native->managed->native roundtrip 
 */
HRESULT __stdcall 
PerfTool::DoTest1(
    long number
    )
{
    HRESULT hr;


    hr = CoCreateInstance(
            __uuidof(perftoolrt::perftoolrt),      // CLSID
            NULL,
            CLSCTX_INPROC_SERVER,
            __uuidof(perftoolrt::_PerfToolRT),	   // IID
            (LPVOID*)&_pPerfRT);
    ON_ERROR_EXIT();

    hr = _DoTest1(number);

Cleanup:
    RELEASE(_pPerfRT);
    return hr;                                
}

/**
 * This is called by DoTest1() so that we can wt it
 */
HRESULT 
PerfTool::_DoTest1(
    long number
    )
{
    HRESULT hr;

    hr = _pPerfRT->DoTest1(number);
    return hr;                                
}


/**
 * Measures multi-threaded throughput of DoTest() method 
 * for the specified class.
 */
HRESULT __stdcall 
PerfTool::get_ClassThroughput( 
    BSTR ClassName,
    long nThreads,
    long Duration,
    long WarmupTime,
    long CooldownTime,
    double *pResult
    )
{
    HRESULT hr = S_OK;
    __int64 StartTime = 0, EndTime = 0;
    double TotalCalls = 0.0;

    // Require number of threads, duration and result pointer
    if(nThreads == 0 || Duration == 0 || pResult == NULL)
    {
        EXIT_WITH_WIN32_ERROR(ERROR_INVALID_PARAMETER);
    }

    {
        IDispatch *pDispatch = NULL;

        // CoCreate as IDispatch

        hr = CoCreateInstance(
                __uuidof(xspmrt::ISAPIRuntime),      // CLSID
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IDispatch,
                (LPVOID*)&pDispatch);
        ON_ERROR_EXIT();
    }

    if(ClassName != NULL)
    {

        hr = CoCreateInstance(
                __uuidof(perftoolrt::perftoolrt),      // CLSID
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IDispatch,     // IID
                (LPVOID*)&_pPerfRT);
        ON_ERROR_EXIT();

        // 0421
        // hr = _pPerfRT->Setup(ClassName);
        // ON_ERROR_EXIT();
    }

    hr = PrepareTest(nThreads);
    ON_ERROR_EXIT();

    // Warmup
    Sleep(WarmupTime * 1000);

    // Note the time when all threads started
    GetSystemTimeAsFileTime((FILETIME *) &StartTime);

    // Start counting calls
    _fCountCalls = TRUE;

    // Idle this thread for specified Duration
    Sleep(Duration * 1000);

    // Stop counting and calculate the throughput
    _fCountCalls = FALSE;
    GetSystemTimeAsFileTime((FILETIME *) &EndTime);

    // Cooldown 
    Sleep(CooldownTime * 1000);

Cleanup:    

    // wait for threads to exit, free arrays, etc
    TotalCalls = UnprepareTest();

    RELEASE(_pPerfRT);

    if (EndTime == StartTime) 
    {
        *pResult = 0.0;
    } else {
        *pResult = (1.0 * TICKS_PER_SEC * TotalCalls) / (EndTime - StartTime);
    }

    return hr;
}

/**
 * Measures multi-threaded throughput of do-nothing C++ function calls
 * in conditions similar to the above case
 */
HRESULT __stdcall 
PerfTool::get_NativeThroughput( 
    long nThreads,
    long Duration,
    long WarmupTime,
    long CooldownTime,
    double *pResult
    )
{
    return get_ClassThroughput(
                NULL, 
                nThreads, 
                Duration, 
                WarmupTime, 
                CooldownTime, 
                pResult);
}

/**
 * Measures adjusted multi-threaded throughput of do-nothing C++ function calls
 * in conditions similar to the above case
 */
HRESULT __stdcall 
PerfTool::get_ClassAdjustedThroughput( 
    BSTR ClassName,
    long nThreads,
    long Duration,
    long WarmupTime,
    long CooldownTime,
    double *pResult
    )
{
    HRESULT hr = S_OK;
    double ClassThroughput, NullThroughput;
    double ClassPerf, NullPerf, AdjustedPerf;
    
    *pResult = 0.0;
        
    hr = get_ClassThroughput(
            ClassName, 
            nThreads, 
            Duration, 
            WarmupTime, 
            CooldownTime, 
            &ClassThroughput);
    ON_ERROR_EXIT();

    hr = get_ClassThroughput(
            L"", 
            nThreads, 
            Duration, 
            WarmupTime, 
            CooldownTime, 
            &NullThroughput);
    ON_ERROR_EXIT();

    if(fabs(ClassThroughput) < DBL_EPSILON || fabs(NullThroughput) < DBL_EPSILON)
        EXIT_WITH_WIN32_ERROR(ERROR_ARITHMETIC_OVERFLOW);

    ClassPerf = 1.0 / ClassThroughput;
    NullPerf = 1.0 / NullThroughput;
    AdjustedPerf = ClassPerf - NullPerf;

    if(AdjustedPerf < DBL_EPSILON) 
        *pResult = DBL_MAX;
    else 
        *pResult = 1.0 / AdjustedPerf;

Cleanup:
    return hr;
}

/**
 * Measures multi-threaded throughput of various N/Direct function calls
 * in conditions similar to the above case
 */
HRESULT __stdcall 
PerfTool::get_NDirectThroughput( 
    long nArgs,
    long fUnicode,
    long fBuildStrings,
    long nThreads,
    long Duration,
    long WarmupTime,
    long CooldownTime,
    double *pResult
    )
{
    HRESULT hr = S_OK;
    __int64 StartTime = 0, EndTime = 0;
    double TotalCalls = 0.0;

    // Require number of threads, duration and result pointer
    if(nThreads == 0 || Duration == 0 || pResult == NULL)
    {
        EXIT_WITH_WIN32_ERROR(ERROR_INVALID_PARAMETER);
    }

    hr = CoCreateInstance(
            __uuidof(perftoolrt::perftoolrt),      // CLSID
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IUnknown,
            (LPVOID*)&_pPerfRT);
    ON_ERROR_EXIT();

    hr = _pPerfRT->SetupForNDirect(nArgs, fUnicode, fBuildStrings);
    ON_ERROR_EXIT();

    hr = PrepareTest(nThreads);
    ON_ERROR_EXIT();

    // Warmup
    Sleep(WarmupTime * 1000);

    // Note the time when all threads started
    GetSystemTimeAsFileTime((FILETIME *) &StartTime);

    // Start counting calls
    _fCountCalls = TRUE;

    // Idle this thread for specified Duration
    Sleep(Duration * 1000);

    // Stop counting and calculate the throughput
    _fCountCalls = FALSE;
    GetSystemTimeAsFileTime((FILETIME *) &EndTime);

    // Cooldown 
    Sleep(CooldownTime * 1000);

Cleanup:    

    // wait for threads to exit, free arrays, etc
    TotalCalls = UnprepareTest();

    RELEASE(_pPerfRT);

    if (EndTime == StartTime) 
    {
        *pResult = 0.0;
    } else {
        *pResult = (1.0 * TICKS_PER_SEC * TotalCalls) / (EndTime - StartTime);
    }

    return hr;
}

/**
 * Measures adjusted multi-threaded throughput of do-nothing C++ function calls
 * in conditions similar to the above case
 */
HRESULT __stdcall 
PerfTool::get_NDirectAdjustedThroughput( 
    long nArgs,
    long fUnicode,
    long fBuildStrings,
    long nThreads,
    long Duration,
    long WarmupTime,
    long CooldownTime,
    double *pResult
    )
{
    HRESULT hr = S_OK;
    double NDirectThroughput, NullThroughput;
    double NDirectPerf, NullPerf, AdjustedPerf;
    
    *pResult = 0.0;
        
    hr = get_NDirectThroughput(
            nArgs, 
            fUnicode,
            fBuildStrings,
            nThreads, 
            Duration, 
            WarmupTime, 
            CooldownTime, 
            &NDirectThroughput);
    ON_ERROR_EXIT();

    hr = get_NDirectThroughput(
            -1,
            fUnicode, 
            fBuildStrings,
            nThreads, 
            Duration, 
            WarmupTime, 
            CooldownTime, 
            &NullThroughput);
    ON_ERROR_EXIT();

    if(fabs(NDirectThroughput) < DBL_EPSILON || fabs(NullThroughput) < DBL_EPSILON)
        EXIT_WITH_WIN32_ERROR(ERROR_ARITHMETIC_OVERFLOW);

    NDirectPerf = 1.0 / NDirectThroughput;
    NullPerf = 1.0 / NullThroughput;
    AdjustedPerf = NDirectPerf - NullPerf;

    if(AdjustedPerf < DBL_EPSILON) 
        *pResult = DBL_MAX;
    else 
        *pResult = 1.0 / AdjustedPerf;

Cleanup:
    return hr;
}


/**
 * Creates PerfTool instance
 */
HRESULT CreatePerfTool(IDispatch **ppIDispatch)
{
    HRESULT hr = S_OK;

    PerfTool * pPerfTool = new PerfTool;
    ON_OOM_EXIT(pPerfTool);

    hr = pPerfTool->QueryInterface(IID_IDispatch, (void **) ppIDispatch);

    RELEASE(pPerfTool);

Cleanup:
    return hr;
}

#pragma optimize("",off)
/**
 * N/Direct test functions
 */

extern "C" __declspec(dllexport)
int WINAPI NDirect0(int)
{
    return 150;
}

extern "C" __declspec(dllexport)
int WINAPI NDirectIn1U(WCHAR *)
{
    return 1;
}

extern "C" __declspec(dllexport)
int WINAPI NDirectIn2U(WCHAR *, WCHAR *)
{
    return 2;
}

extern "C" __declspec(dllexport)
int WINAPI NDirectIn3U(WCHAR *, WCHAR *, WCHAR *)
{
    return 3;
}

extern "C" __declspec(dllexport)
int WINAPI NDirectIn4U(WCHAR *, WCHAR *, WCHAR *, WCHAR *)
{
    return 4;
}


extern "C" __declspec(dllexport)
int WINAPI NDirectIn1A(CHAR *x)
{
    UNUSED(x);

    return -1;
}

extern "C" __declspec(dllexport)
int WINAPI NDirectIn2A(CHAR *, CHAR *)
{
    return -2;
}

extern "C" __declspec(dllexport)
int WINAPI NDirectIn3A(WCHAR *, WCHAR *, WCHAR *)
{
    return -3;
}

extern "C" __declspec(dllexport)
int WINAPI NDirectIn4A(WCHAR *, WCHAR *, WCHAR *, WCHAR *)
{
    return -4;
}


extern "C" __declspec(dllexport)
void WINAPI NDirectOut1U(WCHAR *s1)
{
    wcscpy(s1, L"Hello1");
}

extern "C" __declspec(dllexport)
void WINAPI NDirectOut2U(WCHAR *s1, WCHAR *s2)
{
    wcscpy(s1, L"Hello1");
    wcscpy(s2, L"Hello2");
}

extern "C" __declspec(dllexport)
void WINAPI NDirectOut3U(WCHAR *s1, WCHAR *s2, WCHAR *s3)
{
    wcscpy(s1, L"Hello1");
    wcscpy(s2, L"Hello2");
    wcscpy(s3, L"Hello3");
}

extern "C" __declspec(dllexport)
void WINAPI NDirectOut4U(WCHAR *s1, WCHAR *s2, WCHAR *s3, WCHAR *s4)
{
    wcscpy(s1, L"Hello1");
    wcscpy(s2, L"Hello2");
    wcscpy(s3, L"Hello3");
    wcscpy(s4, L"Hello4");
}

extern "C" __declspec(dllexport)
void WINAPI NDirectOut1A(CHAR *s1)
{
    strcpy(s1, "Hello1");
}

extern "C" __declspec(dllexport)
void WINAPI NDirectOut2A(CHAR *s1, CHAR *s2)
{
    strcpy(s1, "Hello1");
    strcpy(s2, "Hello2");
}

extern "C" __declspec(dllexport)
void WINAPI NDirectOut3A(CHAR *s1, CHAR *s2, CHAR *s3)
{
    strcpy(s1, "Hello1");
    strcpy(s2, "Hello2");
    strcpy(s3, "Hello3");
}

extern "C" __declspec(dllexport)
void WINAPI NDirectOut4A(CHAR *s1, CHAR *s2, CHAR *s3, CHAR *s4)
{
    strcpy(s1, "Hello1");
    strcpy(s2, "Hello2");
    strcpy(s3, "Hello3");
    strcpy(s4, "Hello4");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tool\register.cxx ===
/**
 * XSP Registration function. 
 *
 * Copyright (C) Microsoft Corporation, 1998
 */

#include "precomp.h"
#include "_exe.h"
#include "fxver.h"
#include "ndll.h"

HRESULT RegisterEnvironmentVariables();
HRESULT UnregisterEnvironmentVariables();

/**
 * Register the stuff in the same directory as this executable.
 */
HRESULT 
RegisterXSP()
{
    HRESULT hr;

    hr = UnregisterXSP(false);
    ON_ERROR_CONTINUE();

    hr = RegisterISAPI();
    ON_ERROR_EXIT();

    hr = InstallInfSections(g_Instance, false, L"Tool.Install\0");
    ON_ERROR_EXIT();

#if 0
    /*
     * adams (3/28/00)
     * Registering environment variables is causing more problems
     * than it's worth.
     */

    hr = RegisterEnvironmentVariables();
    ON_ERROR_EXIT();

    printf("If this is the first time you are registering XSP,\r\n"
           "you may need to reboot for changes to system PATH= and CORPATH=\r\n"
           "to take in.\r\n");
#endif

Cleanup:
    return hr;
}

/**
 * Register the stuff in the same directory as this executable.
 */
HRESULT 
UnregisterXSP(bool bUnregisterISAPI)
{
    HRESULT hr;

#if 0
    /*
     * adams (3/28/00)
     * Registering environment variables is causing more problems
     * than it's worth.
     */
    hr = UnregisterEnvironmentVariables();
    ON_ERROR_CONTINUE();
#endif

    hr = InstallInfSections(g_Instance, false, L"Tool.Uninstall\0");
    ON_ERROR_CONTINUE();

    if (bUnregisterISAPI)
    {
        hr = UnregisterISAPI();
        ON_ERROR_CONTINUE();

        printf("XSP is removed from system PATH= and CORPATH=,\r\n"
               "however you may need to reboot for these changes to be picked up by services.\r\n");
    }

    return S_OK;
}

HRESULT
AppendRegistryValue(HKEY hRootKey, WCHAR *subkey, WCHAR *value, WCHAR *path)
{
    HRESULT hr = S_OK;
    DWORD cbData, dwType;
    WCHAR *fullPath = NULL;
    WCHAR *instance;
    HKEY hKey = NULL;

    if(ERROR_SUCCESS != RegOpenKeyEx(hRootKey, subkey, 0, 
        KEY_QUERY_VALUE | KEY_SET_VALUE, &hKey))
    {
        EXIT_WITH_LAST_ERROR();
    }

    // Find how big the value is (and if it is not there, it is also ok)
    cbData = 0;
    RegQueryValueEx(hKey, value, NULL, &dwType, NULL, &cbData);

    // We need as much space plus space for path, for ";" and for terminating NULL
    cbData += (lstrlen(path) + 2) * sizeof(WCHAR);
    fullPath = (WCHAR *)MemAlloc(cbData);
    ON_OOM_EXIT(fullPath);
    fullPath[0] = 0;

    // Get the value and its type 
    if(ERROR_SUCCESS != RegQueryValueEx(hKey, value, NULL, 
        &dwType, (BYTE *)fullPath, &cbData))
    {
        dwType = REG_SZ;
    }

    // Check if this path is already present
    instance = wcsstr(fullPath, path);
    cbData = lstrlen(path);

    if (instance == NULL || (instance[cbData] != L';' && instance[cbData] != 0))
    {
        // Substring not found or it does not end with ";" or "\0" -- append
        DWORD len = lstrlen(fullPath);
        if(len && fullPath[len-1] != L';') lstrcat(fullPath, L";");
        lstrcat(fullPath, path);
        cbData = (lstrlen(fullPath) + 1) * sizeof(WCHAR);
        if(ERROR_SUCCESS != RegSetValueEx(hKey, value, 0, dwType, 
            (CONST BYTE *)fullPath, cbData))
        {
            EXIT_WITH_LAST_ERROR();
        }
    }

Cleanup:
    MemFree(fullPath);
    if(hKey != NULL) RegCloseKey(hKey);

    return hr;
}

HRESULT
RemoveRegistryValue(HKEY hRootKey, WCHAR *subkey, WCHAR *value, WCHAR *path)
{
    HRESULT hr = S_OK;
    DWORD cbData, dwType;
    WCHAR *fullPath = NULL;
    WCHAR *instance;
    HKEY hKey = NULL;

    if(ERROR_SUCCESS != RegOpenKeyEx(hRootKey, subkey, 0, 
        KEY_QUERY_VALUE | KEY_SET_VALUE, &hKey))
    {
        EXIT_WITH_LAST_ERROR();
    }

    // Find how big the value is (and if it is not there, it is also ok)
    cbData = 0;
    RegQueryValueEx(hKey, value, NULL, &dwType, NULL, &cbData);
        cbData += sizeof(WCHAR);
    fullPath = (WCHAR *)MemAlloc(cbData);
    ON_OOM_EXIT(fullPath);
    fullPath[0] = 0;

    // Get the value and its type 
    if(ERROR_SUCCESS != RegQueryValueEx(hKey, value, NULL, 
        &dwType, (BYTE *)fullPath, &cbData))
    {
        dwType = REG_SZ;
    }

    // Check if this path is present
    instance = wcsstr(fullPath, path);
    cbData = lstrlen(path);

    // verify that the path lies between ;;
    if  (instance != NULL && (instance[cbData] == L';' || instance[cbData] == 0)
                          && (instance == fullPath || instance[-1] == L';'))
    {
        DWORD cbBytesToMove;

        // remove one of the semicolons
        if (instance[cbData] == L';')
        {
            cbData++;
        }
        else if (instance > fullPath)
        {
            instance--;
            cbData++;
        }
        
        cbBytesToMove = (lstrlen(instance) - cbData + 1) * sizeof(WCHAR);
        if(cbBytesToMove)
                MoveMemory(instance, instance + cbData, cbBytesToMove);
        cbData = (lstrlen(fullPath) + 1) * sizeof(WCHAR);
        if  (ERROR_SUCCESS != RegSetValueEx(
                hKey, value, 0, dwType, (CONST BYTE *)fullPath, cbData))
        {
            EXIT_WITH_LAST_ERROR();
        }
    }

Cleanup:
    MemFree(fullPath);
    if(hKey != NULL) RegCloseKey(hKey);

    return hr;
}

HRESULT
BroadcastEnvironmentUpdate()
{
    HRESULT hr = S_OK;
    DWORD result;
    DWORD dwReturnValue;

    result = SendMessageTimeout(
            HWND_BROADCAST, WM_SETTINGCHANGE, 0,
            (LPARAM) L"Environment", SMTO_ABORTIFHUNG, 5000, &dwReturnValue);

    ON_ZERO_EXIT_WITH_LAST_ERROR(result);

Cleanup:
    return hr;
}


#if 0

/*
 * adams (3/28/00)
 * Registering environment variables is causing more problems
 * than it's worth.
 */

HRESULT 
RegisterEnvironmentVariables()
{
    HRESULT hr = S_OK;
    WCHAR searchPath[MAX_PATH];
    WCHAR codegenPath[MAX_PATH];
    WCHAR *filePart;
    
    if (SearchPath(NULL, ISAPI_MODULE_FULL_NAME_L, NULL, 
            ARRAY_SIZE(searchPath), searchPath, &filePart) == 0)
    {
        EXIT_WITH_LAST_ERROR();
    }

    *filePart = L'\0';

    wcscpy(codegenPath, searchPath);
    wcscat(codegenPath,  L"codegen");

    hr = AppendRegistryValue(HKEY_LOCAL_MACHINE, 
                L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment", 
                L"CORPATH", searchPath);
    ON_ERROR_EXIT();

    hr = AppendRegistryValue(HKEY_LOCAL_MACHINE, 
                L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment", 
                L"CORPATH", codegenPath);
    ON_ERROR_EXIT();

    hr = AppendRegistryValue(HKEY_LOCAL_MACHINE, 
                L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment", 
                L"PATH", searchPath);
    ON_ERROR_EXIT();

    hr = BroadcastEnvironmentUpdate();
    ON_ERROR_CONTINUE();
    hr = S_OK;

Cleanup:
    return hr;
}

HRESULT 
UnregisterEnvironmentVariables()
{
    HRESULT hr = S_OK;
    WCHAR   installPath[MAX_PATH];
    WCHAR   codegenPath[MAX_PATH];
    DWORD   cbData, dwType, len;
    HKEY    hKey = NULL;

    installPath[0] = 0;

    // Attempt to retrieve current XSP location
    cbData = sizeof(installPath);
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_MACHINE_APP_L, 0, KEY_QUERY_VALUE, &hKey);
    if (hKey) 
    {
        RegQueryValueEx(hKey, L"InstallDir", NULL, &dwType, (BYTE *)installPath, &cbData);
        RegCloseKey(hKey);
    }

    len = lstrlen(installPath);

    // If no location, don't do anything
    if (len == 0) EXIT();

    // Append "ext" to the XSP Path
    if (installPath[len - 1] != L'\\')
    {
        wcscat(installPath, L"\\");
    }

    wcscpy(codegenPath, installPath);
    wcscat(codegenPath,  L"codegen");

    hr = RemoveRegistryValue(HKEY_LOCAL_MACHINE, 
                L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment", 
                L"CORPATH", codegenPath);
    ON_ERROR_EXIT();

    hr = RemoveRegistryValue(HKEY_LOCAL_MACHINE, 
                L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment", 
                L"CORPATH", installPath);
    ON_ERROR_EXIT();

    hr = AppendRegistryValue(HKEY_LOCAL_MACHINE, 
                L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment", 
                L"PATH", installPath);
    ON_ERROR_EXIT();

    hr = BroadcastEnvironmentUpdate();
    ON_ERROR_CONTINUE();
    hr = S_OK;

Cleanup:
    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tool\ent\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tool\_perftoolrt.h ===
/**
 * Contains IID and interface definition for ISAPIRuntime managed class.
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

#pragma once
#pragma pack(push, 8)

#include <comdef.h>

namespace perftoolrt
{

struct __declspec(uuid("03C344CC-8BD2-11D2-9F5C-00A0C922E798")) perftoolrt;

struct __declspec(uuid("81aad719-ddac-4d09-b39d-c5c138a829ee")) _PerfToolRT;

struct _PerfToolRT : IUnknown
{
    virtual HRESULT __stdcall SetupForNDirect (
        long numArgs,
        long Unicode,
        long ProduceStrings ) = 0;
    virtual HRESULT __stdcall DoTest ( ) = 0;
    virtual HRESULT __stdcall DoTest1 (
        __int64 number ) = 0;};


} // namespace xsp

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tool\_exe.h ===
/**
 * _exe.h
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */


#ifndef __EXE_H
#define __EXE_H

#include "tool.h"

extern ITypeLib * g_pTypeLib;
extern HINSTANCE g_Instance;
extern BOOL g_AllowDebug;

HRESULT CreateEcbHost(IDispatch **ppIDispatch);
HRESULT CreatePerfTool(IDispatch **ppIDispatch);

HRESULT GetTypeInfoOfGuid(REFIID iid, ITypeInfo **ppTypeInfo);

HRESULT RegisterXSP();
HRESULT UnregisterXSP(bool bUnregisterISAPI);

/**
 * Base class for implementing Automation objects.
 */

class __declspec(novtable) BaseObject : public IDispatch
{
public:

    BaseObject();
    virtual ~BaseObject();

    DECLARE_MEMCLEAR_NEW_DELETE();

    // IUnknown methods

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID, void **);

    // IDispatch interface

    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo);
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo);
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR * * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid);
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);


protected: 

    virtual const IID *GetPrimaryIID() = 0;
    virtual IUnknown * GetPrimaryPtr() = 0;

private:

    long _refs;
    ITypeInfo *_pTypeInfo;
};

#define DELEGATE_IDISPATCH_TO_BASE() \
    STDMETHOD_(ULONG, AddRef)() { return BaseObject::AddRef(); }\
    STDMETHOD_(ULONG, Release)() { return BaseObject::Release(); }\
    STDMETHOD(GetTypeInfoCount)(UINT *pctinfo) { return BaseObject::GetTypeInfoCount(pctinfo); }\
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo) { return BaseObject::GetTypeInfo(itinfo, lcid, pptinfo); }\
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR ** rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid) { return BaseObject::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }\
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr) { return BaseObject::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }\


class ScriptHost : public IDispatch
{ 
public:

    ScriptHost();
    ~ScriptHost();

    DECLARE_MEMCLEAR_NEW_DELETE();

    // IUnknown methods

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID, void **);

    // IDispatch methods

    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo);
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo);
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR * * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid);
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);

    // ScriptHost methods
    
    static HRESULT ExecuteString(WCHAR *string);
    static HRESULT ExecuteFile(WCHAR *path, IDispatch **ppObject);
    static HRESULT ExecuteResource(WCHAR *name, IDispatch **ppObject);
    static HRESULT Interactive();
    static void    Terminate();

private:

    HRESULT Initialize();
    HRESULT ParseFile(WCHAR *fileName);
    HRESULT EvalString(WCHAR *string, VARIANT * pResult);
    HRESULT EvalAndPrintString(WCHAR *string);

    void ReportError(EXCEPINFO *pExcepInfo, int lineNumber, int columnNumber, WCHAR *line);

    class Site : 
        public BaseObject,
        public IActiveScriptSite, 
        public IActiveScriptSiteWindow,
        public IActiveScriptSiteDebug,
        public IHost
    {
    public:

        Site(ScriptHost *pHost);

        // BaseObject methods

        IUnknown * GetPrimaryPtr() { return (IHost *)this;   }
        const IID *GetPrimaryIID() { return &__uuidof(IHost); }

        // IDispatch/IUnknown methods

        STDMETHOD(QueryInterface)(REFIID, void **);
        STDMETHOD_(ULONG, AddRef)() { return BaseObject::AddRef(); }
        STDMETHOD_(ULONG, Release)() { return BaseObject::Release(); }
        STDMETHOD(GetTypeInfoCount)(UINT *pctinfo) { return BaseObject::GetTypeInfoCount(pctinfo); }
        STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo) { return BaseObject::GetTypeInfo(itinfo, lcid, pptinfo); }
        STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR ** rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid); 
        STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);

        // IHost methods

        STDMETHOD(LoadScript)(BSTR , IDispatch **);
        STDMETHOD(IncludeScript)(BSTR );
        STDMETHOD(PromptOpenFile)(BSTR, BSTR, BSTR*);
        STDMETHOD(PromptSaveFile)(BSTR, BSTR, BSTR, BSTR*);
        STDMETHOD(get_ScriptPath)(long , BSTR  *);
        STDMETHOD(get_CurrentTime)(long  *);
        STDMETHOD(Echo)(BSTR );
        STDMETHOD(EchoDebug)(BSTR );
        STDMETHOD(Assert)(VARIANT_BOOL , BSTR );
        STDMETHOD(Interactive)();
        STDMETHOD(Help)(IDispatch *);
        STDMETHOD(Register)();
        STDMETHOD(Unregister)();
        STDMETHOD(CreateDelegate)(BSTR, IDispatch**);
        STDMETHOD(Sleep)(long);
        STDMETHOD(Eval)(BSTR, VARIANT *);
        STDMETHOD(GetRegValueCollection)(BSTR Key, IDispatch **);

        // IActiveScriptSite methods

        STDMETHOD(GetLCID)(LCID *plcid);
        STDMETHOD(GetItemInfo)(LPCOLESTR, DWORD, IUnknown **, ITypeInfo **);
        STDMETHOD(GetDocVersionString)(BSTR *);
        STDMETHOD(RequestItems)();
        STDMETHOD(RequestTypeLibs)();
        STDMETHOD(OnScriptTerminate)(const VARIANT *, const EXCEPINFO *pexepinfo);
        STDMETHOD(OnStateChange)(SCRIPTSTATE );
        STDMETHOD(OnScriptError)(IActiveScriptError *);
        STDMETHOD(OnEnterScript)();
        STDMETHOD(OnLeaveScript)();

        // IActiveScriptSiteWindow methods

        STDMETHOD(GetWindow)(HWND *);
        STDMETHOD(EnableModeless)(BOOL);

        // IActiveScriptSiteDebug methods

        STDMETHOD(GetDocumentContextFromPosition)(DWORD, ULONG, ULONG, IDebugDocumentContext**);
        STDMETHOD(GetApplication)(IDebugApplication  **);
        STDMETHOD(GetRootApplicationNode)(IDebugApplicationNode **);
        STDMETHOD(OnScriptErrorDebug)(IActiveScriptErrorDebug *, BOOL *, BOOL *);

    private:
        HRESULT GetExtension(int i, IDispatch **);

    public:
        ScriptHost *_pHost;
        ULONG _refs;
    };
    friend class Site;

        WCHAR _ScriptPath[MAX_PATH];
    IActiveScript *_pScript;
    IActiveScriptParse *_pScriptParse;
    IDispatch *_pScriptObject;
    Site *_pSite;
    ULONG _refs;
};


class RegValueCollection : 
    public BaseObject, 
    public IRegValueCollection
{
public:
    HRESULT Init(BSTR keyName);
    virtual ~RegValueCollection();

    DECLARE_MEMCLEAR_NEW_DELETE();

    // BaseObject methods
    IUnknown * GetPrimaryPtr() { return (IRegValueCollection *)this;   }
    const IID *GetPrimaryIID() { return &__uuidof(IRegValueCollection); }
    STDMETHOD(QueryInterface)(REFIID, void **);

    DELEGATE_IDISPATCH_TO_BASE();

    // IRegValueCollection methods
    STDMETHOD(get_Count)(long *Count);
    STDMETHOD(get_Item)(VARIANT Index, VARIANT * Value);
    STDMETHOD(get__NewEnum)(IUnknown ** );

    HKEY    _key;    
};


#endif // ifndef __EXE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tool\scripthost.cxx ===
/**
 * ScriptHost object implementation
 *
 * Copyright (C) Microsoft Corporation, 1998
 */

#include "precomp.h"
#include "_exe.h"

/*
 * XSPTool extensions.
 *
 * XSPTool can be extended by adding Automation objects to
 * the script engine namespace. XSPTool takes care of showing
 * help for the objects, creating them when referenced and
 * destroying them when the process exits.
 *
 * The array s_ExtensionInfo gives the name used for the
 * extension object, a help string and information about how 
 * to create the extension object. XSPTool supports three 
 * mechanisms for creating objects:
 *
 * CoCreateInstance
 *    s_ExtensionInfo::CreateStr is the CLSID of the object
 *    to create.
 *
 * Local function
 *    s_ExtensionInfo::CreateFn points to the creation function.
 *    By using local functions, objects can be added to XSPTool
 *    without resistering them as COM classes with the system.
 *
 * Script in resource file.
 *    s_ExtensionInfo::CreateStr is the name of a resource
 *    containing a script. The type of the resource is 50.
 */
static struct
{
    WCHAR * Name;
    WCHAR *Help;
    HRESULT (*CreateFn)(IDispatch **);
    WCHAR *CreateStr;
}
s_ExtensionInfo[] =
{
    { L"FileSystem", 
            L"Provides access to file system.", 
            NULL, L"{0D43FE01-F093-11CF-8940-00A0C9054228}" },

    { L"Shell",      
            L"Run command, access to environment and registry.", 
            NULL, L"{F935DC22-1CF0-11d0-ADB9-00C04FD58A0B}" },

    { L"Util",    
            L"Miscellaneous utilities.", 
            NULL, L"util.vbs" },

    { L"EcbHost",
            L"Simple ECB Host extension",
            CreateEcbHost, NULL },

    { L"PerfTool",
            L"Measures Managed code throughput",
            CreatePerfTool, NULL },

};

#define RT_SCRIPT MAKEINTRESOURCE(50)
#define HOST_NAME L"Host"
#define CHECK_HOST() if (_pHost == NULL) return E_UNEXPECTED;

static s_InteractiveNesting = 0;
static IDispatch * s_pExtension[ARRAY_SIZE(s_ExtensionInfo)];

ScriptHost::ScriptHost()
{
    _refs = 1;
}

ScriptHost::~ScriptHost()
{

    ReleaseInterface(_pScriptParse);
    ReleaseInterface(_pScriptObject);

    if (_pScript)
    {
        _pScript->Close();
        _pScript->Release();
    }

    if (_pSite)
    {
        _pSite->_pHost = NULL;
        _pSite->Release();
    }
}

/**
 * Implements IUnknown::QueryInteface.
 */
HRESULT
ScriptHost::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IDispatch || iid == IID_IUnknown)
    {
        *ppv = (IDispatch *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

/**
 * Implements IUnknown::AddRef.
 */
ULONG
ScriptHost::AddRef()
{
    _refs += 1;
    return _refs;
}

/**
 * Implements IUnknown::Release.
 */
ULONG
ScriptHost::Release()
{
    if (--_refs == 0)
    {
        delete this;
        return 0;
    }

    return _refs;
}

/**
 * Create script engine and get it ready for action.
 */
HRESULT
ScriptHost::Initialize()
{
    HRESULT hr;
    static const CLSID CLSID_VBS = { 0xb54f3741, 0x5b07, 0x11cf, 0xa4, 0xb0, 0x0, 0xaa, 0x0, 0x4a, 0x55, 0xe8 };

    _pSite = new Site(this);
    ON_OOM_EXIT(_pSite);

    hr = CoCreateInstance(CLSID_VBS, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void **)&_pScript);
    ON_ERROR_EXIT();

    hr = _pScript->SetScriptSite(_pSite);
    ON_ERROR_EXIT();

    hr = _pScript->QueryInterface(IID_IActiveScriptParse, (void **)&_pScriptParse);
    ON_ERROR_EXIT();

    hr = _pScriptParse->InitNew();
    ON_ERROR_EXIT();

    hr = _pScript->AddNamedItem(HOST_NAME, SCRIPTITEM_ISVISIBLE | SCRIPTITEM_GLOBALMEMBERS);
    ON_ERROR_EXIT();

    hr = _pScript->GetScriptDispatch(NULL, &_pScriptObject);
    ON_ERROR_EXIT();

    hr = _pScript->SetScriptState(SCRIPTSTATE_CONNECTED);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

/**
 * Load a file into the script engine.
 */
HRESULT
ScriptHost::ParseFile(WCHAR *path)
{
    HRESULT     hr;
    HANDLE      file = INVALID_HANDLE_VALUE;
    DWORD       fileSize;
    DWORD       countRead;
    char *      buffer = 0;
    WCHAR *     wideBuffer = 0;
    WCHAR *     pFilePart;

    GetFullPathName(path, ARRAY_SIZE(_ScriptPath), _ScriptPath, &pFilePart);

    // Load script file

    file = CreateFile(_ScriptPath,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            0,
            NULL);
    if (file == INVALID_HANDLE_VALUE)
        EXIT_WITH_LAST_ERROR();

    fileSize = GetFileSize(file, NULL);
    if (fileSize == 0xFFFFFFFF)
        EXIT_WITH_LAST_ERROR();

    buffer = new char[fileSize + 1];
    wideBuffer = new TCHAR[fileSize + 1];
    if (!buffer || !wideBuffer)
        EXIT_WITH_OOM();

    if (!ReadFile(file, buffer, fileSize, &countRead, 0))
        EXIT_WITH_LAST_ERROR();
    buffer[countRead] = 0;

    MultiByteToWideChar(CP_ACP, 0, buffer, -1, wideBuffer, fileSize + 1);

    hr = _pScriptParse->ParseScriptText(wideBuffer, HOST_NAME, NULL, NULL, 0, 0, 0L, NULL, NULL);
    ON_ERROR_EXIT();

Cleanup:
    delete [] buffer;
    delete [] wideBuffer;
    if (file != INVALID_HANDLE_VALUE)
        CloseHandle(file);

    return hr;
}

/**
 * Evaluate string and print result.
 */
HRESULT
ScriptHost::EvalAndPrintString(
    WCHAR *string
    )
{
    VARIANT result;
    VARIANT stringResult;
    HRESULT hr;

    VariantInit(&result);
    VariantInit(&stringResult);

    hr = EvalString(string, &result);
    ON_ERROR_EXIT();

    hr = VariantChangeType(&stringResult, &result, 0, VT_BSTR);
    if (hr == S_OK && V_BSTR(&stringResult)[0] != 0)
    {
        wprintf(L"%s\n", V_BSTR(&stringResult));
    }

Cleanup:
    VariantClear(&result);
    VariantClear(&stringResult);
    return hr;
}


HRESULT
ScriptHost::EvalString(
    WCHAR *string,
    VARIANT *pResult
    )
{
    EXCEPINFO excepInfo;
    HRESULT hr;
    long flags = 0;

    VariantInit(pResult);
    ExcepInfoInit(&excepInfo);

    if (string[0] == L'?')
    {
        flags |= SCRIPTTEXT_ISEXPRESSION;
        string += 1;
    }

    hr = _pScriptParse->ParseScriptText(string, HOST_NAME, NULL, NULL, 0, 0, flags, pResult, &excepInfo);
    ON_ERROR_EXIT();

Cleanup:
    ExcepInfoClear(&excepInfo);
    return hr;
}



HRESULT
ScriptHost::ExecuteString(
    WCHAR *string
    )
{
    HRESULT hr;
    ScriptHost *pHost;

    pHost = new ScriptHost();
    ON_OOM_EXIT(pHost);

    hr = pHost->Initialize();
    ON_ERROR_EXIT();

    hr = pHost->EvalAndPrintString(string);

Cleanup:
    if (pHost)
        pHost->Release();

    return hr;
}

HRESULT
ScriptHost::Interactive()
{
    HRESULT hr;
    ScriptHost *pHost;

    pHost = new ScriptHost();
    ON_OOM_EXIT(pHost);

    hr = pHost->Initialize();
    ON_ERROR_EXIT();

    hr = pHost->_pSite->Interactive();
    ON_ERROR_EXIT();

Cleanup:
    if (pHost)
        pHost->Release();

    return hr;
}

HRESULT
ScriptHost::ExecuteFile(
    WCHAR *path,
    IDispatch **ppObject
    )
{
    HRESULT hr;
    ScriptHost *pHost = NULL;

    *ppObject = NULL;

    pHost = new ScriptHost();
    ON_OOM_EXIT(pHost);

    hr = pHost->Initialize();
    ON_ERROR_EXIT();

    hr = pHost->ParseFile(path);
    ON_ERROR_EXIT();

    *ppObject = pHost;

Cleanup:
    if (hr)
    {
        pHost->Release();
    }
    return hr;
}

HRESULT
ScriptHost::ExecuteResource(
    WCHAR *name,
    IDispatch **ppObject
    )
{
    HRESULT     hr;
    ScriptHost *pHost = NULL;
    DWORD       bufferSize;
    char *      buffer = 0;
    WCHAR *     wideBuffer = 0;
    HGLOBAL     hgbl;
    HRSRC       hrsrc;
    
    *ppObject = NULL;

    pHost = new ScriptHost();
    ON_OOM_EXIT(pHost);

    hr = pHost->Initialize();
    ON_ERROR_EXIT();

    hrsrc = FindResource(g_Instance, name, RT_SCRIPT);
    if (!hrsrc)
        EXIT_WITH_LAST_ERROR();

    hgbl = LoadResource(g_Instance, hrsrc);
    if (!hgbl)
        EXIT_WITH_LAST_ERROR();

    if (GetModuleFileName(g_Instance, pHost->_ScriptPath, ARRAY_SIZE(pHost->_ScriptPath)) == 0)
        EXIT_WITH_LAST_ERROR();

    buffer = (char *)LockResource(hgbl);
    if (buffer == NULL)
        EXIT_WITH_HRESULT(E_FAIL);

    bufferSize = SizeofResource(g_Instance, hrsrc);
    if (bufferSize == 0)
        EXIT_WITH_LAST_ERROR();

    wideBuffer = new WCHAR[bufferSize + 1];
    ON_OOM_EXIT(wideBuffer);

    MultiByteToWideChar(CP_ACP, 0, buffer, bufferSize, wideBuffer, bufferSize);
    wideBuffer[bufferSize] = 0;

    hr = pHost->_pScriptParse->ParseScriptText(wideBuffer, HOST_NAME, NULL, NULL, 0, 0, 0L, NULL, NULL);
    ON_ERROR_EXIT();

    *ppObject = pHost;

Cleanup:
    delete [] wideBuffer;

    if (hr)
    {
        pHost->Release();
    }
    return hr;
}

void
ScriptHost::Terminate()
{
    for (int i = 0; i < ARRAY_SIZE(s_pExtension); i++)
        ClearInterface(&s_pExtension[i]);
}

void
ScriptHost::ReportError(
    EXCEPINFO *pExcepInfo,
    int lineNumber,
    int /*columnNumber*/,
    WCHAR *line)
{
    TCHAR *     description;
    TCHAR       descriptionBuffer[256];

    if (pExcepInfo->bstrDescription)
    {
        description = pExcepInfo->bstrDescription;
    }
    else
    {
        descriptionBuffer[0] = 0;
        if (FormatMessage(
                FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                pExcepInfo->scode,
                LANG_SYSTEM_DEFAULT,
                descriptionBuffer,
                ARRAY_SIZE(descriptionBuffer),
                NULL) == 0)
        {
            wsprintf(descriptionBuffer, L"Error %08x", pExcepInfo->scode);
        }

        description = descriptionBuffer;
    }

    if (pExcepInfo->bstrSource)
        wprintf(L"%s\n", pExcepInfo->bstrSource);

    wprintf(L"%s\n", description);

    if (_ScriptPath[0])
        wprintf(L"File: %s, line: %d, text: %s\n", _ScriptPath, lineNumber, line ? line : L"");
}

/**
 * Implements IDispatch::GetTypeInfoCount
 */

HRESULT
ScriptHost::GetTypeInfoCount(
    UINT FAR* pCount
    )
{
    if (_pScriptObject == NULL)
        return E_UNEXPECTED;

    return _pScriptObject->GetTypeInfoCount(pCount);
}

/**
 * Implements IDispatch::GetTypeInfo
 */
HRESULT
ScriptHost::GetTypeInfo(
    UINT index, LCID lcid,
    ITypeInfo FAR* FAR* ppTypeInfo
    )
{
    if (_pScriptObject == NULL)
        return E_UNEXPECTED;

    return _pScriptObject->GetTypeInfo(index, lcid, ppTypeInfo);
}

/**
 * Implements IDispatch::GetIDsOfNames
 */
HRESULT
ScriptHost::GetIDsOfNames(
    REFIID iid,
    OLECHAR * * pNames,
    UINT cNames,
    LCID lcid,
    DISPID * pdispid)
{
    if (_pScriptObject == NULL)
        return E_UNEXPECTED;

    return _pScriptObject->GetIDsOfNames(iid, pNames, cNames, lcid, pdispid);
}

/**
 * Implements IDispatch::Invoke
 */
HRESULT
ScriptHost::Invoke(
    DISPID dispid,
    REFIID iid,
    LCID lcid,
    WORD flags,
    DISPPARAMS * pParams,
    VARIANT * pResult,
    EXCEPINFO * pExcepInfo,
    UINT * puArgErr)
{
    if (_pScriptObject == NULL)
        return E_UNEXPECTED;

    return _pScriptObject->Invoke(dispid, iid, lcid, flags, pParams, pResult, pExcepInfo, puArgErr);
}

/**
 * constructor
 */
ScriptHost::Site::Site(ScriptHost *pHost)
{
    _refs = 1;
    _pHost = pHost;
}

/**
 * Implements IUnknown::QueryInteface.
 */
HRESULT
ScriptHost::Site::QueryInterface(REFIID iid, void ** ppv)
{

    extern BOOL g_AllowDebug;

    if (iid == IID_IActiveScriptSite)
    {
        *ppv = (IActiveScriptSite *)this;
    }
    else if (iid == IID_IActiveScriptSiteWindow)
    {
        *ppv = (IActiveScriptSiteWindow *)this;
    }
    else if (!g_AllowDebug && iid == IID_IActiveScriptSiteDebug)
    {
        *ppv = (IActiveScriptSiteDebug *)this;
    }
    else if (iid == __uuidof(IHost))
    {
        *ppv = (IHost *)this;
    }
    else
    {
        return BaseObject::QueryInterface(iid, ppv);
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

/**
 * Implements IActiveScriptSite::GetLCID.
 */
HRESULT
ScriptHost::Site::GetLCID(LCID *)
{
    // Use system settings
    return E_NOTIMPL;
}


HRESULT
ScriptHost::Site::GetExtension(int i, IDispatch **ppObject)
{
    HRESULT hr = S_OK;

    if (s_pExtension[i] == NULL)
    {
        if (s_ExtensionInfo[i].CreateFn != NULL)
        {
            hr = s_ExtensionInfo[i].CreateFn(&s_pExtension[i]);
            ON_ERROR_EXIT();
        }
        else if (s_ExtensionInfo[i].CreateStr[0] == '{')
        {
            CLSID clsid;

            hr = CLSIDFromString(s_ExtensionInfo[i].CreateStr, &clsid);
            ON_ERROR_EXIT();

            hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IDispatch, (void **)&s_pExtension[i]);
            ON_ERROR_EXIT();
        }
        else
        {
            hr = ScriptHost::ExecuteResource(s_ExtensionInfo[i].CreateStr, (IDispatch **)&s_pExtension[i]);
            ON_ERROR_EXIT();
        }
    }

    *ppObject = s_pExtension[i];
    (*ppObject)->AddRef();

Cleanup:
    return hr;
}


/**
 * Implements IActiveScriptSite::GetItemInfo.
 */

HRESULT
ScriptHost::Site::GetItemInfo(
      LPCOLESTR   name,
      DWORD       returnMask,
      IUnknown**  ppUnk,
      ITypeInfo** ppTypeInfo)
{
    CHECK_HOST();
    HRESULT hr = S_OK;

    if (returnMask & SCRIPTINFO_ITYPEINFO)
        *ppTypeInfo = NULL;

    if (returnMask & SCRIPTINFO_IUNKNOWN)
        *ppUnk = NULL;

    if (wcscmp(HOST_NAME, name) == 0)
    {
        *ppUnk = (IHost *)this;
        (*ppUnk)->AddRef();
    }
    else
    {
        hr = TYPE_E_ELEMENTNOTFOUND;
    }

    return hr;
}

/**
 * Implements IActiveScriptSite::GetDocVersionString.
 */
HRESULT
ScriptHost::Site::GetDocVersionString(
    BSTR *
    )
{
    return E_NOTIMPL;
}

/**
 * Implements IActiveScriptSite::RequestItems.
 */
HRESULT
ScriptHost::Site::RequestItems()
{
    CHECK_HOST();
    HRESULT hr;

    hr = _pHost->_pScript->AddNamedItem(HOST_NAME, SCRIPTITEM_ISVISIBLE | SCRIPTITEM_GLOBALMEMBERS);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

/**
 * Implements IActiveScriptSite::RequestTypeLibs
 */
HRESULT
ScriptHost::Site::RequestTypeLibs()
{
    CHECK_HOST();
    return S_OK;
}

/**
 * Implements IActiveScriptSite::OnScriptTerminate.
 */
HRESULT
ScriptHost::Site::OnScriptTerminate(
    const VARIANT *,
    const EXCEPINFO *)
{
    return S_OK;
}

/**
 * Implements IActiveScriptSite::OnStateChange.
 */
HRESULT
ScriptHost::Site::OnStateChange(
    SCRIPTSTATE 
    )
{
    return S_OK;
}

/**
 * Implements IActiveScriptSite::OnScriptError.
 */
HRESULT
ScriptHost::Site::OnScriptError(
    IActiveScriptError *pError)
{
    CHECK_HOST();
    BSTR        line = NULL;
    EXCEPINFO   excepInfo;
    DWORD       sourceContext;
    ULONG       lineNumber;
    LONG        columnNumber;
    HRESULT     hr;

    ExcepInfoInit(&excepInfo);

    hr = pError->GetExceptionInfo(&excepInfo);
    ON_ERROR_EXIT();

    hr = pError->GetSourcePosition(&sourceContext, &lineNumber, &columnNumber);
    ON_ERROR_EXIT();

    hr = pError->GetSourceLineText(&line);
    if (hr)
        hr = S_OK;  // Ignore this error, there may not be source available

    _pHost->ReportError(&excepInfo, lineNumber, columnNumber, line);

Cleanup:
    ExcepInfoClear(&excepInfo);
    if (line)
        SysFreeString(line);
    return hr;
}

/**
 * Implements IActiveScriptSite::OnEnterScript.
 */
HRESULT
ScriptHost::Site::OnEnterScript()
{
    return S_OK;
}

/**
 * Implements IActiveScriptSite::OnLeaveScript.
 */

HRESULT
ScriptHost::Site::OnLeaveScript()
{
    return S_OK;
}

/**
 * Implements IActiveScriptSiteWindow.
 */

HRESULT
ScriptHost::Site::GetWindow(
    HWND *pHwnd
    )
{
    *pHwnd = NULL;
    return S_OK;
}

/**
 * Implements IActiveScriptSiteWindow::EnableModeless
 */

HRESULT
ScriptHost::Site::EnableModeless(
    BOOL 
    )
{
    return S_OK;
}

/**
 * Implements IActiveScriptSiteDebug::GetDocumentContextFromPosition
 */
HRESULT
ScriptHost::Site::GetDocumentContextFromPosition(
    DWORD, ULONG, ULONG, IDebugDocumentContext**
    )
{
    return E_NOTIMPL;
}

HRESULT
ScriptHost::Site::GetApplication(
    IDebugApplication  **
    )
{
    return E_NOTIMPL;
}

/**
 * Implements IActiveScriptSiteDebug::GetRootApplicationNode
 */
HRESULT
ScriptHost::Site::GetRootApplicationNode(
    IDebugApplicationNode **
    )
{
    return E_NOTIMPL;
}

/**
 * Implements IActiveScriptSiteDebug::OnScriptErrorDebug
 */
HRESULT
ScriptHost::Site::OnScriptErrorDebug(
    IActiveScriptErrorDebug *,
    BOOL *pEnterDebugger,
    BOOL *pCallOnScriptErrorWhenContinuing)
{
    extern BOOL g_AllowDebug;

    *pEnterDebugger = g_AllowDebug;
    *pCallOnScriptErrorWhenContinuing = !g_AllowDebug;
    return S_OK;
}

/**
 * Implements IDispatch::GetIDsOfNames
 */
HRESULT
ScriptHost::Site::GetIDsOfNames(
    REFIID iid,
    OLECHAR * * pNames,
    UINT cNames,
    LCID lcid,
    DISPID * pdispid)
{
    CHECK_HOST();
    HRESULT hr = S_OK;

    for (int i = 0; i < ARRAY_SIZE(s_ExtensionInfo); i++)
    {
        if (_wcsicmp(pNames[0], s_ExtensionInfo[i].Name) == 0)
        {
            if (cNames > 1)
                EXIT_WITH_HRESULT(E_FAIL);

            pdispid[0] = i + 1;
            break;
        }
    }

    if (i >= ARRAY_SIZE(s_ExtensionInfo))
    {
        hr = BaseObject::GetIDsOfNames(iid, pNames, cNames, lcid, pdispid);
		// Error return here is benign. Let it bubble out without tracing.
    }

Cleanup:
    return hr;
}

/**
 * Implements IDispatch::Invoke
 */
HRESULT
ScriptHost::Site::Invoke(
    DISPID dispid,
    REFIID iid,
    LCID lcid,
    WORD flags,
    DISPPARAMS * pParams,
    VARIANT * pResult,
    EXCEPINFO * pExcepInfo,
    UINT * puArgErr)
{
    CHECK_HOST();
    HRESULT hr = S_OK;

    if (1 <= dispid && dispid < ARRAY_SIZE(s_ExtensionInfo) + 1)
    {
        if (pResult)
        {
            hr = GetExtension(dispid - 1, &V_DISPATCH(pResult));
            ON_ERROR_EXIT();
            pResult->vt = VT_DISPATCH;
        }
    }
    else
    {
        hr = BaseObject::Invoke(dispid, iid, lcid, flags, pParams, pResult, pExcepInfo, puArgErr);
        ON_ERROR_EXIT();
    }

Cleanup:
    return hr;
}

/**
 * Implements IHost::get_CurrentTime
 */
HRESULT
ScriptHost::Site::get_CurrentTime(
    long  *pTime
    )
{
    LONGLONG f;
    LONGLONG t;

    QueryPerformanceFrequency((LARGE_INTEGER *)&f);
    QueryPerformanceCounter((LARGE_INTEGER *)&t);

    *pTime = (long)((t * 1000) / f);

    return S_OK;
}

/**
 * Implements IHost::Echo
 */
HRESULT
ScriptHost::Site::Echo(
    BSTR line
    )
{
	HRESULT hr = S_OK;
	LONG Length;
	
	Length = lstrlen(line);
	if(Length != 0)
	{
		CHAR * Buffer = (CHAR *) MemAlloc(Length * sizeof(WCHAR));

		ON_OOM_EXIT(Buffer);

		Length = WideCharToMultiByte(CP_ACP, 0, line, Length, Buffer, Length * sizeof(WCHAR), NULL, NULL);
		if(Length)
		{
			_setmode(_fileno(stdout), _O_BINARY);
			fwrite(Buffer, Length, 1, stdout);
			_setmode(_fileno(stdout), _O_TEXT);
		}

		MemFree(Buffer);
	} 

	wprintf(L"\n");

Cleanup:
    return hr;
}

/**
 * Implements IHost::EchoDebug
 */
HRESULT
ScriptHost::Site::EchoDebug(
    BSTR line
    )
{
    OutputDebugString(L"XSPTOOL:");
    OutputDebugString(line);
    OutputDebugString(L"\n");
    return S_OK;
}

#undef Assert
/**
 * Implements IHost::Assert
 */
HRESULT
ScriptHost::Site::Assert(
    VARIANT_BOOL assertion,
    BSTR message
    )
{
    if (assertion)
        return S_OK;

    WCHAR *fileName;
    char mbFileName[MAX_PATH];
    char mbMessage[MAX_PATH];

    // Try to chop of directory name.

    fileName = wcsrchr(_pHost->_ScriptPath, '\\');
    fileName = fileName ? fileName + 1 : _pHost->_ScriptPath;

    WideCharToMultiByte(CP_ACP, 0, fileName, -1, mbFileName, ARRAY_SIZE(mbFileName), NULL, NULL);
    WideCharToMultiByte(CP_ACP, 0, message, -1, mbMessage, ARRAY_SIZE(mbMessage), NULL, NULL);

#if DBG
    // BUGBUG: garybu need to hook this up in retail.
    if (DbgpAssert(DbgComponent, mbMessage, mbFileName, 0, NULL))
        DebugBreak();
#endif

    return S_OK;
}

static WCHAR s_ScriptPath[MAX_PATH];

HRESULT
ScriptHost::Site::PromptOpenFile(BSTR title, BSTR filter, BSTR *pResult)
{
    CHECK_HOST();
    int             i;
    HRESULT         hr = S_OK;
    OPENFILENAME    ofn;
    WCHAR           buffer[MAX_PATH];

    for (i = 0; i < ARRAY_SIZE(buffer) - 2 && filter[i]; i++)
    {
        buffer[i] = filter[i] == L'|' ? '\0' : filter[i];
    }
    buffer[i++] = 0; 
    buffer[i] = 0;

    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.lpstrFilter = buffer;
    ofn.lpstrFile = s_ScriptPath;
    ofn.nFilterIndex = 1;
    ofn.nMaxFile = ARRAY_SIZE(s_ScriptPath);
    ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST;
    ofn.lpstrTitle = title[0] ? title : NULL;

    *pResult = SysAllocString(GetOpenFileName(&ofn) ? s_ScriptPath : L"");
    ON_OOM_EXIT(*pResult);

Cleanup:
    return hr;
}

HRESULT
ScriptHost::Site::PromptSaveFile(BSTR name, BSTR title, BSTR filter, BSTR *pResult)
{
    CHECK_HOST();
    int             i;
    HRESULT         hr = S_OK;
    OPENFILENAME    ofn;
    WCHAR           buffer[MAX_PATH];

    for (i = 0; i < ARRAY_SIZE(buffer) - 2 && filter[i]; i++)
    {
        buffer[i] = filter[i] == L'|' ? '\0' : filter[i];
    }
    buffer[i++] = 0; 
    buffer[i] = 0;

    wcscpy(s_ScriptPath, name);

    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.lpstrFilter = buffer;
    ofn.lpstrFile = s_ScriptPath;
    ofn.nFilterIndex = 1;
    ofn.nMaxFile = ARRAY_SIZE(s_ScriptPath);
    ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_OVERWRITEPROMPT;
    ofn.lpstrTitle = title[0] ? title : NULL;

    *pResult = SysAllocString(GetSaveFileName(&ofn) ? s_ScriptPath : L"");
    ON_OOM_EXIT(*pResult);

Cleanup:
    return hr;
}

HRESULT
ScriptHost::Site::IncludeScript(
    WCHAR *fileName)
{
    CHECK_HOST();
    HRESULT hr;

    hr = _pHost->ParseFile(fileName);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT
ScriptHost::Site::LoadScript(WCHAR *fileName, IDispatch **ppObject)
{
    CHECK_HOST();
    HRESULT hr;

    hr = _pHost->ExecuteFile(fileName, ppObject);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT
ScriptHost::Site::get_ScriptPath(
    long i,
    BSTR * pPath
    )
{
    CHECK_HOST();
    WCHAR path[MAX_PATH];
    WCHAR *p = NULL;
    HRESULT hr = S_OK;

    *pPath = NULL;

    if (_pHost->_ScriptPath[0] != 0)
        wcscpy(path, _pHost->_ScriptPath);
    else
        GetCurrentDirectory(ARRAY_SIZE(path), path);

    for (; i >= 0; i--)
    {
        p = wcsrchr(path, '\\');
        if (p)
        {
            *p = 0;
        }
        else
        {
            EXIT_WITH_HRESULT(E_FAIL);
        }
    }

    if (p)
    {
        p[0] = '\\';
        p[1] = 0;
    }

    *pPath = SysAllocString(path);
    ON_OOM_EXIT(*pPath);

Cleanup:
    return hr;
}

HRESULT
ScriptHost::Site::Help(
    IDispatch *pObject
    )
{
    int i;
    ITypeInfo *pTypeInfo = NULL;
    TYPEATTR *pTypeAttr;
    FUNCDESC *pFuncDesc;
    int cFuncs;
    int iFunc;
    int invkind;
    int memid;
    int flags;
    int returnType;
    UINT nameCount;
    BSTR names[16];
    BSTR documentation = NULL;
    HRESULT hr = S_OK;

    ZeroMemory(names, sizeof(names));

    if (pObject == NULL)
    {
        wprintf(L"Command line help\n");
        wprintf(L"  xsptool /?\n");
        wprintf(L"Commands\n");
        wprintf(L"  ? <expression> : Evaluate expression and print result.\n");
        wprintf(L"  <statement> : Execute statement.\n");
        wprintf(L"  bye, exit, q : Exit interactive mode.\n");
        wprintf(L"  help <object> : Prints help on object.\n");
        wprintf(L"Objects\n  " HOST_NAME L" : Script host utilities.\n");
        for (i = 0; i < ARRAY_SIZE(s_ExtensionInfo); i++)
        {
            wprintf(L"  %s : %s\n", s_ExtensionInfo[i].Name, s_ExtensionInfo[i].Help);
        }
    }
    else
    {
        hr = pObject->GetTypeInfo(0, 0, &pTypeInfo);
        ON_ERROR_EXIT();

        hr = pTypeInfo->GetTypeAttr(&pTypeAttr);
        ON_ERROR_EXIT();

        cFuncs = pTypeAttr->cFuncs;

        pTypeInfo->ReleaseTypeAttr(pTypeAttr);

        for (iFunc = 0; iFunc < cFuncs; iFunc++)
        {
            if ((iFunc + 1) % 20 == 0)
            {
                WCHAR buffer[32];

                wprintf(L"more> ");
                if (fgetws(buffer, ARRAY_SIZE(buffer), stdin) == NULL)
                    break;
            }

            hr = pTypeInfo->GetFuncDesc(iFunc, &pFuncDesc);
            ON_ERROR_EXIT();

            memid = pFuncDesc->memid;
            flags = pFuncDesc->wFuncFlags;
            invkind = pFuncDesc->invkind;
            returnType = pFuncDesc->elemdescFunc.tdesc.vt;

            pTypeInfo->ReleaseFuncDesc(pFuncDesc);

            if (flags & (FUNCFLAG_FHIDDEN|FUNCFLAG_FRESTRICTED))
                continue;

            if (invkind == INVOKE_PROPERTYPUT || invkind == INVOKE_PROPERTYPUTREF)
                continue;

            for (i = 0; i < ARRAY_SIZE(names); i++)
            {
                SysFreeString(names[i]);
                names[i] = NULL;
            }

            hr = pTypeInfo->GetNames(memid, names, ARRAY_SIZE(names), &nameCount);
            ON_ERROR_EXIT();

            SysFreeString(documentation);
            documentation = NULL;

            hr = pTypeInfo->GetDocumentation(memid, NULL, &documentation, NULL, NULL);
            ON_ERROR_EXIT();

            if (invkind != INVOKE_FUNC)
                wprintf(L"= %s", names[0]);
            else if (returnType == VT_VOID || returnType == VT_HRESULT)
                wprintf(L"  %s", names[0]);
            else
                wprintf(L"? %s", names[0]);

            for (i = 1; i < (int)nameCount; i++)
            {
                wprintf(i == 1 ? L" %s" : L", %s", names[i]);
            }

            if (documentation != NULL && documentation[0] != 0)
            {
                wprintf(L"  # %s", documentation);
            }

            wprintf(L"\n");
        }

    }

Cleanup:
    for (i = 0; i < ARRAY_SIZE(names); i++)
        SysFreeString(names[i]);

    SysFreeString(documentation);

    ReleaseInterface(pTypeInfo);

    return S_OK;
}

HRESULT
ScriptHost::Site::Interactive()
{
    CHECK_HOST();
    WCHAR buffer[1024];
    WCHAR prompt[32];

    s_InteractiveNesting += 1;

    for (int i = 0; i < s_InteractiveNesting; i++)
    {
        prompt[i] = L'>';
    }
    prompt[i++] = L' ';
    prompt[i] = 0;

    while (!feof(stdin))
    {
        wprintf(prompt);

        if (fgetws(buffer, ARRAY_SIZE(buffer), stdin) != NULL)
        {
            if (_wcsicmp(buffer, L"exit\n") == 0 ||
                _wcsicmp(buffer, L"bye\n") == 0  ||
                _wcsicmp(buffer, L"q\n") == 0)
                break;

            _pHost->EvalAndPrintString(buffer);
        }
    }

    s_InteractiveNesting -= 1;

    return S_OK;
}

HRESULT
ScriptHost::Site::Register()
{
    HRESULT hr;

    hr = RegisterXSP();
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT
ScriptHost::Site::Unregister()
{
    HRESULT hr;

    hr = UnregisterXSP(true);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}




HRESULT CreateDelegate(WCHAR *name, IDispatch *pObject, IDispatch **ppDelegate);

HRESULT
ScriptHost::Site::CreateDelegate(BSTR name, IDispatch **ppDelegate)
{
    CHECK_HOST();
    HRESULT hr;

    hr = ::CreateDelegate(name, _pHost->_pScriptObject, ppDelegate);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT
ScriptHost::Site::Sleep(long Duration)
{

    ::Sleep(Duration);

    return S_OK;
}

HRESULT
ScriptHost::Site::Eval(BSTR Script, VARIANT *pResult)
{
    CHECK_HOST();

    return _pHost->EvalString(Script, pResult);
}


HRESULT
ScriptHost::Site::GetRegValueCollection(BSTR key, IDispatch **Object)
{
    CHECK_HOST();

    HRESULT                 hr = S_OK;
    RegValueCollection *    pRegValueCollection;
    
    *Object = NULL;

    pRegValueCollection = new RegValueCollection();
    ON_OOM_EXIT(pRegValueCollection);

    hr = pRegValueCollection->Init(key);
    ON_ERROR_EXIT();

    *Object = (IDispatch *) (IRegValueCollection *) pRegValueCollection;

Cleanup:
    if (hr)
    {
        pRegValueCollection->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tool\exp\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tool\redist\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tool\std\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tool\tool.cxx ===
//------------------------------------------------------------------------------
// <copyright file="tool.cxx" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   tool.cxx
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
renamed main.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tool\sources.inc ===
!include $(DNAROOT)\src\xsp\place.inc

!if "$(ASPNET_PRODUCT)" == "redist"
SYNCHRONIZE_BLOCK=1
!endif

TARGETNAME=xsptool
TARGETPATH=$(O)
TARGETTYPE=PROGRAM

UMENTRY=wmain
UMTYPE=console

NTTARGETFILE0=$(O)\tool.res

PRECOMPILED_CXX=1
PRECOMPILED_SHARED_INCLUDE=precomp.h
PRECOMPILED_SHARED_PCH=..\..\inc\$(ASPNET_PRODUCT)\$(O)\precomp.pch

TARGETLIBS= \
        $(SDK_LIB_PATH)\kernel32.lib            \
        $(SDK_LIB_PATH)\user32.lib              \
        $(SDK_LIB_PATH)\uuid.lib                \
        $(SDK_LIB_PATH)\ole32.lib               \
        $(SDK_LIB_PATH)\oleaut32.lib            \
        $(SDK_LIB_PATH)\advapi32.lib            \
        $(SDK_LIB_PATH)\comdlg32.lib            \
        $(SDK_LIB_PATH)\version.lib             \
        $(XSPBASEDIR)\isapi\$(ASPNET_PRODUCT)\$(O)\$(ASPNET_NAME_PREFIX)isapi.lib   \
        $(URTSDKTARGET)\lib\mscoree.lib         \

LINKLIBS=\
        $(XSPBASEDIR)\inc\$(ASPNET_PRODUCT)\$(O)\precomp.lib      \
        $(XSPBASEDIR)\util\$(ASPNET_PRODUCT)\$(O)\util.lib        \

SOURCES=                           \
        ..\tool.idl                \
        ..\tool.rc                 \
        ..\baseobject.cxx          \
        ..\delegate.cxx            \
        ..\ecbhost.cxx             \
        ..\main.cxx                \
        ..\perftool.cxx            \
        ..\regcollect.cxx          \
        ..\register.cxx            \
        ..\scripthost.cxx          \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tpool\threads.h ===
/*++

Copyright (c) 1989-1998 Microsoft Corporation

Module Name:

    threads.h

Abstract:

    This module is the header file for thread pools. Thread pools can be used for
    one time execution of tasks, for waits and for one shot or periodic timers.

Author:

    Gurdeep Singh Pall (gurdeep) Nov 13, 1997

Environment:

    These routines are statically linked in the caller's executable and
    are callable in only from user mode. They make use of Nt system services.


Revision History:

    Aug-19 lokeshs - modifications to thread pool apis.

--*/

//todo remove below
#define DBG1 1



// Structures used by the Thread pool

// Timer structures

// Timer Queues and Timer entries both use RTLP_GENERIC_TIMER structure below.
// Timer Queues are linked using List.
// Timers are attached to the Timer Queue using TimerList
// Timers are linked to each other using List

#define RTLP_TIMER RTLP_GENERIC_TIMER
#define PRTLP_TIMER PRTLP_GENERIC_TIMER

#define RTLP_TIMER_QUEUE RTLP_GENERIC_TIMER
#define PRTLP_TIMER_QUEUE PRTLP_GENERIC_TIMER

struct _RTLP_WAIT ;

typedef struct _RTLP_GENERIC_TIMER {

    LIST_ENTRY List ;                   // All Timers and Queues are linked using this.
    ULONG DeltaFiringTime ;             // Time difference in Milliseconds from the TIMER entry
                                        // just before this entry
    union {
        ULONG RefCount ;        // Timer RefCount
        ULONG * RefCountPtr ;   // Pointer to Wait->Refcount
    } ;                         // keeps count of async callbacks still executing

    ULONG State ;               // State of timer: CREATED, DELETE, ACTIVE. DONT_FIRE

    union {

        // Used for Timer Queues

        struct  {

            LIST_ENTRY  TimerList ;     // Timers Hanging off of the queue
            LIST_ENTRY  UncancelledTimerList ;//List of one shot timers not cancelled
                                              //not used for wait timers
            #if DBG1
            ULONG NextDbgId; //ksl
            #endif
            
        } ;

        // Used for Timers

        struct  {
            struct _RTLP_GENERIC_TIMER *Queue ;// Queue to which this timer belongs
            struct _RTLP_WAIT *Wait ;  // Pointer to Wait event if timer is part of waits. else NULL
            ULONG Flags ;              // Flags indicating special treatment for this timer
            PVOID Function ;           // Function to call when timer fires
            PVOID Context ;            // Context to pass to function when timer fires
            ULONG Period ;             // In Milliseconds. Used for periodic timers.
            LIST_ENTRY TimersToFireList;//placed in this list if the timer is fired
        } ;
    } ;

    HANDLE CompletionEvent ;   // Event signalled when the timer is finally deleted

    #if DBG1
    ULONG DbgId; //ksl
    ULONG ThreadId ;
    ULONG ThreadId2 ;
    #endif

}  RTLP_GENERIC_TIMER, *PRTLP_GENERIC_TIMER ;

#if DBG1
ULONG NextTimerDbgId;
ULONG NextWaitDbgId;
#endif


// Structurs used by Wait Threads

// Wait structure

typedef struct _RTLP_WAIT {

    struct _RTLP_WAIT_THREAD_CONTROL_BLOCK *ThreadCB ;
    HANDLE WaitHandle ;         // Object to wait on
    ULONG State ;               // REGISTERED, ACTIVE,DELETE state flags
    ULONG RefCount ;            // initially set to 1. When 0, then ready to be deleted
    HANDLE CompletionEvent ;
    struct _RTLP_GENERIC_TIMER *Timer ; // For timeouts on the wait
    ULONG Flags ;               // Flags indicating special treatment for this wait
    PVOID Function ;            // Function to call when wait completes
    PVOID Context ;             // Context to pass to function
    ULONG Timeout ;             // In Milliseconds.
    #if DBG1
    ULONG DbgId ;
    ULONG ThreadId ;
    ULONG ThreadId2 ;
    #endif
    
} RTLP_WAIT, *PRTLP_WAIT ;


// Wait Thread Control Block

typedef struct _RTLP_WAIT_THREAD_CONTROL_BLOCK {

    LIST_ENTRY WaitThreadsList ;// List of all the thread control blocks

    HANDLE ThreadHandle ;       // Handle for this thread
    ULONG ThreadId ;            // Used to check if callback is in WaitThread

    ULONG NumWaits ;            // Number of active waits + handles not being waited upon
    ULONG NumActiveWaits ;      // Total number of waits.
    HANDLE ActiveWaitArray[64] ;// Array used for waiting
    PRTLP_WAIT ActiveWaitPointers[64] ;// Array of pointers to active Wait blocks.
    HANDLE TimerHandle ;        // Handle to the NT timer used for timeouts
    RTLP_TIMER_QUEUE TimerQueue;// Queue in which all timers are kept
    RTLP_TIMER TimerBlocks[63] ;// All the timers required for wait timeouts - max of 63 since wait[0]
                                // is used for NT timer object
    LIST_ENTRY FreeTimerBlocks ;// List of Free Blocks

    LARGE_INTEGER Current64BitTickCount ;
    LONGLONG Firing64BitTickCount ;
    
    RTL_CRITICAL_SECTION WaitThreadCriticalSection ;
                                // Used for addition and deletion of waits

} RTLP_WAIT_THREAD_CONTROL_BLOCK, *PRTLP_WAIT_THREAD_CONTROL_BLOCK ;


// Structure used for attaching all I/O worker threads

typedef struct _RTLP_IOWORKER_TCB {

    LIST_ENTRY List ;           // List of IO Worker threads
    HANDLE     ThreadHandle ;   // Handle of this thread
    ULONG      Flags ;          // WT_EXECUTEINPERSISTENTIOTHREAD
    BOOLEAN    LongFunctionFlag ;// Is the thread currently executing long fn
} RTLP_IOWORKER_TCB, *PRTLP_IOWORKER_TCB ;

typedef struct _RTLP_WAITWORKER {
    union {
        PRTLP_WAIT Wait ;
        PRTLP_TIMER Timer ;
    } ;
    BOOLEAN WaitThreadCallback ; //callback queued by Wait thread or Timer thread
    BOOLEAN TimerCondition ;//true if fired because wait timed out.
} RTLP_ASYNC_CALLBACK, * PRTLP_ASYNC_CALLBACK ;


// structure used for calling worker function

typedef struct _RTLP_WORK {

    WORKERCALLBACKFUNC Function ;
    ULONG Flags ;
    
} RTLP_WORK, *PRTLP_WORK ;


// Structure used for storing events

typedef struct _RTLP_EVENT {

    LIST_ENTRY List ;
    HANDLE Handle ;

} RTLP_EVENT, *PRTLP_EVENT ;



// Globals used by the thread pool

ULONG StartedTPInitialization ; // Used for Initializing ThreadPool
ULONG CompletedTPInitialization;// Used to check if ThreadPool is initialized

ULONG StartedWorkerInitialization ;     // Used for Worker thread startup synchronization
ULONG CompletedWorkerInitialization ;   // Used to check if Worker thread pool is initialized

ULONG StartedWaitInitialization ;       // Used for Wait thread startup synchronization
ULONG CompletedWaitInitialization ;     // Used to check if Wait thread pool is initialized

ULONG StartedTimerInitialization ;      // Used by Timer thread startup synchronization
ULONG CompletedTimerInitialization ;    // Used for to check if Timer thread is initialized

ULONG StartedEventCacheInitialization ; // Used for initializing event cache
ULONG CompletedEventCacheInitialization;// Used for initializing event cache

HANDLE TimerThreadHandle ;              // Holds the timer thread handle
ULONG TimerThreadId ;                   // Used to check if current thread is a timer thread

ULONG NumIOWorkerThreads ;              // Count of IO Worker Threads alive
ULONG NumWorkerThreads ;                // Count of Worker Threads alive
ULONG NumMinWorkerThreads ;             // Min worker threads should be alive: 1 if ioCompletion used, else 0
ULONG NumIOWorkRequests ;               // Count of IO Work Requests pending
ULONG NumLongIOWorkRequests ;           // IO Worker threads executing long worker functions
ULONG NumWorkRequests ;                 // Count of Work Requests pending.
ULONG NumLongWorkRequests ;             // Worker threads executing long worker functions
ULONG NumUnusedEvents ;                 // Count of Unused events in the cache

ULONG LastThreadCreationTickCount ;     // Tick count at which the last thread was created

LIST_ENTRY IOWorkerThreads ;            // List of IOWorkerThreads
PRTLP_IOWORKER_TCB PersistentIOTCB ;    // ptr to TCB of persistest IO worker thread
HANDLE WorkerCompletionPort ;           // Completion port used for queuing tasks to Worker threads

LIST_ENTRY WaitThreads ;                // List of all wait threads created
LIST_ENTRY EventCache ;                 // Events used for synchronization


LIST_ENTRY TimerQueues ;                // All timer queues are linked in this list
HANDLE     TimerHandle ;                // Holds handle of NT Timer used by the Timer Thread
ULONG      NumTimerQueues ;             // Number of timer queues

RTL_CRITICAL_SECTION WorkerCriticalSection ;    // Exclusion used by worker threads
RTL_CRITICAL_SECTION WaitCriticalSection ;      // Exclusion used by wait threads
RTL_CRITICAL_SECTION TimerCriticalSection ;     // Exclusion used by timer threads
RTL_CRITICAL_SECTION EventCacheCriticalSection ;// Exclusion used for handle allocation

RTLP_START_THREAD RtlpStartThread ;
PRTLP_START_THREAD RtlpStartThreadFunc = RtlpStartThread ;
RTLP_EXIT_THREAD RtlpExitThread ;
PRTLP_EXIT_THREAD RtlpExitThreadFunc = RtlpExitThread ;

#if DBG1
PVOID CallbackFn1, CallbackFn2, Context1, Context2 ;
#endif


// defines used in the thread pool

#define THREAD_CREATION_DAMPING_TIME1    1000    // In Milliseconds. Time between starting successive threads.
#define THREAD_CREATION_DAMPING_TIME2    5000    // In Milliseconds. Time between starting successive threads.
#define THREAD_TERMINATION_DAMPING_TIME 10000    // In Milliseconds. Time between stopping successive threads.
#define NEW_THREAD_THRESHOLD            7       // Number of requests outstanding before we start a new thread
#define MAX_WORKER_THREADS              1000    // Max effective worker threads
#define INFINITE_TIME                   (ULONG)~0   // In milliseconds
#define RTLP_MAX_TIMERS                 0x00080000  // 524288 timers per process
#define MAX_UNUSED_EVENTS               40


// Macros


#define ONE_MILLISECOND_TIMEOUT(TimeOut) {      \
        TimeOut.LowPart  = 0xffffd8f0 ;         \
        TimeOut.HighPart = 0xffffffff ;         \
        }

#define HUNDRED_MILLISECOND_TIMEOUT(TimeOut) {  \
        TimeOut.LowPart  = 0xfff0bdc0 ;         \
        TimeOut.HighPart = 0xffffffff ;         \
        }

#define ONE_SECOND_TIMEOUT(TimeOut) {           \
        TimeOut.LowPart  = 0xff676980 ;         \
        TimeOut.HighPart = 0xffffffff ;         \
        }

#define USE_PROCESS_HEAP 1

#define RtlpFreeTPHeap(Ptr) \
    RtlFreeHeap( RtlProcessHeap(), 0, (Ptr) )

#define RtlpAllocateTPHeap(Size, Flags) \
    RtlAllocateHeap( RtlProcessHeap(), (Flags), (Size) )

// used to allocate Wait thread

#define ACQUIRE_GLOBAL_WAIT_LOCK() \
    RtlEnterCriticalSection (&WaitCriticalSection)

#define RELEASE_GLOBAL_WAIT_LOCK() \
    RtlLeaveCriticalSection(&WaitCriticalSection)


// taken before a timer/queue is deleted and when the timers
// are being fired. Used to assure that no timers will be fired later.

#define ACQUIRE_GLOBAL_TIMER_LOCK() \
    RtlEnterCriticalSection (&TimerCriticalSection)

#define RELEASE_GLOBAL_TIMER_LOCK() \
    RtlLeaveCriticalSection(&TimerCriticalSection)

// used in RtlpThreadPoolCleanup to find if a component is initialized

#define IS_COMPONENT_INITIALIZED(StartedVariable, CompletedVariable, Flag) \
{\
    LARGE_INTEGER TimeOut ;     \
    Flag = FALSE ;              \
                                \
    if ( StartedVariable ) {    \
                                \
        if ( !CompletedVariable ) { \
                                    \
            ONE_MILLISECOND_TIMEOUT(TimeOut) ;  \
                                                \
            while (!(volatile ULONG) CompletedVariable) \
                NtDelayExecution (FALSE, &TimeOut) ;    \
                                                        \
            if (CompletedVariable == 1)                 \
                Flag = TRUE ;                           \
                                                        \
        } else {                                        \
            Flag = TRUE ;                               \
        }                                               \
    }                                                   \
}    


// macro used to set dbg function/context

#define DBG_SET_FUNCTION(Fn, Context) { \
    CallbackFn1 = CallbackFn2 ;         \
    CallbackFn2 = (Fn) ;                \
    Context1 = Context2 ;               \
    Context2 = (Context ) ;             \
}


// used to move the wait array
/*
VOID
RtlpShiftWaitArray(
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB ThreadCB,
    ULONG SrcIndex,
    ULONG DstIndex,
    ULONG Count
    )
*/
#define RtlpShiftWaitArray(ThreadCB, SrcIndex, DstIndex, Count) {  \
                                                            \
    RtlCopyMemory (&(ThreadCB)->ActiveWaitArray[DstIndex],  \
                    &(ThreadCB)->ActiveWaitArray[SrcIndex], \
                    sizeof (HANDLE) * (Count)) ;            \
                                                            \
    RtlCopyMemory (&(ThreadCB)->ActiveWaitPointers[DstIndex],\
                    &(ThreadCB)->ActiveWaitPointers[SrcIndex],\
                    sizeof (HANDLE) * (Count)) ;            \
}

LARGE_INTEGER   Last64BitTickCount ;
LARGE_INTEGER   Resync64BitTickCount ;
LARGE_INTEGER   Firing64BitTickCount ;

#define RtlpGetResync64BitTickCount()  Resync64BitTickCount.QuadPart
#define RtlpSetFiring64BitTickCount(Timeout) \
            Firing64BitTickCount.QuadPart = (Timeout)


    
// signature for timer and wait entries

#define SET_SIGNATURE(ptr)          (ptr)->State |= 0xfedc0000
#define CHECK_SIGNATURE(ptr)        ASSERT( ((ptr)->State & 0xffff0000) == 0xfedc0000 )
#define SET_DEL_SIGNATURE(ptr)      ((ptr)->State |= 0xfedcb000)
#define CHECK_DEL_SIGNATURE(ptr)    ASSERT( (((ptr)->State & 0xffff0000) == 0xfedc0000) \
                                        && ( ! ((ptr)->State & 0x0000f000)) )
#define CLEAR_SIGNATURE(ptr)        ((ptr)->State = ((ptr)->State & 0x0000ffff) | 0xcdef0000)





// Prototypes for thread pool private functions

NTSTATUS
RtlpInitializeWorkerThreadPool (
    ) ;

NTSTATUS
RtlpInitializeWaitThreadPool (
    ) ;

NTSTATUS
RtlpInitializeTimerThreadPool (
    ) ;

NTSTATUS
RtlpStartThread (
    IN  PUSER_THREAD_START_ROUTINE Function,
    OUT HANDLE *ThreadHandle
    ) ;

LONG
RtlpWaitThread (
    IN PVOID  WaitHandle
    ) ;

LONG
RtlpWorkerThread (
    PVOID  NotUsed
    ) ;

LONG
RtlpIOWorkerThread (
    PVOID  NotUsed
    ) ;

LONG
RtlpTimerThread (
    PVOID  NotUsed
    ) ;

VOID
RtlpAddTimerQueue (
    PVOID Queue
    ) ;

VOID
RtlpAddTimer (
    PRTLP_TIMER Timer
    ) ;

VOID
RtlpResetTimer (
    HANDLE TimerHandle,
    ULONG DueTime,
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB
    ) ;


VOID
RtlpFireTimersAndReorder (
    PRTLP_TIMER_QUEUE Queue,
    ULONG *NewFiringTime,
    PLIST_ENTRY TimersToFireList
    ) ;

VOID
RtlpFireTimers (
    PLIST_ENTRY TimersToFireList
    ) ;

VOID
RtlpInsertTimersIntoDeltaList (
    PLIST_ENTRY NewTimerList,
    PLIST_ENTRY DeltaTimerList,
    ULONG TimeRemaining,
    ULONG *NewFiringTime
    ) ;

BOOLEAN
RtlpInsertInDeltaList (
    PLIST_ENTRY DeltaList,
    PRTLP_GENERIC_TIMER NewTimer,
    ULONG TimeRemaining,
    ULONG *NewFiringTime
    ) ;

BOOLEAN
RtlpRemoveFromDeltaList (
    PLIST_ENTRY DeltaList,
    PRTLP_GENERIC_TIMER Timer,
    ULONG TimeRemaining,
    ULONG* NewFiringTime
    ) ;

BOOLEAN
RtlpReOrderDeltaList (
    PLIST_ENTRY DeltaList,
    PRTLP_GENERIC_TIMER Timer,
    ULONG TimeRemaining,
    ULONG* NewFiringTime,
    ULONG ChangedFiringTime
    ) ;


VOID
RtlpAddWait (
    PRTLP_WAIT Wait
    ) ;

NTSTATUS
RtlpDeregisterWait (
    PRTLP_WAIT Wait,
    HANDLE PartialCompletionEvent,
    PULONG StatusPtr
    ) ;

NTSTATUS
RtlpDeactivateWait (
    PRTLP_WAIT Wait
    ) ;

VOID
RtlpDeleteWait (
    PRTLP_WAIT Wait
    ) ;

VOID
RtlpProcessWaitCompletion (
    PRTLP_WAIT Wait,
    ULONG ArrayIndex
    ) ;

VOID
RtlpProcessTimeouts (
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB
    ) ;

ULONG
RtlpGetTimeRemaining (
    HANDLE TimerHandle
    ) ;


VOID
RtlpServiceTimer (
    PVOID NotUsedArg,
    ULONG NotUsedLowTimer,
    LONG NotUsedHighTimer
    ) ;

ULONG
RtlpGetQueueRelativeTime (
    PRTLP_TIMER_QUEUE Queue
    ) ;

VOID
RtlpCancelTimer (
    PRTLP_TIMER TimerToCancel
    ) ;

VOID
RtlpCancelTimerEx (
    PRTLP_TIMER Timer,
    BOOLEAN DeletingQueue
    ) ;

VOID
RtlpDeactivateTimer (
    PRTLP_TIMER_QUEUE Queue,
    PRTLP_TIMER Timer
    ) ;


NTSTATUS
RtlpDeleteTimerQueue (
    PRTLP_TIMER_QUEUE Queue
    ) ;

VOID
RtlpDeleteTimerQueueComplete (
    PRTLP_TIMER_QUEUE Queue
    ) ;

LONGLONG
Rtlp64BitTickCount(
    ) ;

NTSTATUS
RtlpFindWaitThread (
    PRTLP_WAIT_THREAD_CONTROL_BLOCK *ThreadCB
) ;

VOID
RtlpExecuteIOWorkItem (
    PVOID Function,
    PVOID Context,
    PVOID NotUsed
    ) ;

VOID
RtlpExecuteLongIOWorkItem (
    PVOID Function,
    PVOID Context,
    PVOID NotUsed
    ) ;

NTSTATUS
RtlpQueueIOWorkerRequest (
    WORKERCALLBACKFUNC Function,
    PVOID Context,
    ULONG Flags
    ) ;

NTSTATUS
RtlpStartWorkerThread (
    ) ;

NTSTATUS
RtlpStartIOWorkerThread (
    ) ;


NTSTATUS
RtlpQueueWorkerRequest (
    WORKERCALLBACKFUNC Function,
    PVOID Context,
    ULONG Flags
    ) ;


#define THREAD_TYPE_WORKER 1
#define THREAD_TYPE_IO_WORKER 2

BOOLEAN
RtlpDoWeNeedNewWorkerThread (
    ULONG ThreadType
    ) ;

VOID
RtlpUpdateTimer (
    PRTLP_TIMER Timer,
    PRTLP_TIMER UpdatedTimer
    ) ;

VOID
RtlpDeleteTimer (
    PRTLP_TIMER Timer
    ) ;

PRTLP_EVENT
RtlpGetWaitEvent (
    VOID
    ) ;

VOID
RtlpFreeWaitEvent (
    PRTLP_EVENT Event
    ) ;

VOID
RtlpInitializeEventCache (
    VOID
    ) ;

VOID
RtlpFreeWaitEvent (
    PRTLP_EVENT Event
    ) ;

PRTLP_EVENT
RtlpGetWaitEvent (
    VOID
    ) ;

VOID
RtlpDeleteWaitAPC (
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB,
    PRTLP_WAIT Wait,
    HANDLE Handle
    ) ;

VOID
RtlpDoNothing (
    PVOID NotUsed1,
    PVOID NotUsed2,
    PVOID NotUsed3
    ) ;

VOID
RtlpExecuteWorkerRequest (
    NTSTATUS Status,
    PVOID Context,
    PVOID ActualFunction
    ) ;

NTSTATUS
RtlpInitializeTPHeap (
    ) ;

NTSTATUS
RtlpWaitForEvent (
    HANDLE Event,
    HANDLE ThreadHandle
    ) ;

VOID
RtlpThreadCleanup (
    ) ;

VOID
RtlpWorkerThreadCleanup (
    NTSTATUS Status,
    PVOID NotUsed,
    PVOID NotUsed2
    ) ;

PVOID
RtlpForceAllocateTPHeap(
    ULONG dwSize,
    ULONG dwFlags
    );
    

//to make sure that a wait is not deleted before being registered
#define STATE_REGISTERED   0x0001

//set when wait registered. Removed when one shot wait fired.
//when deregisterWait called, tells whether to be removed from ActiveArray
//If timer active, then have to remove it from delta list and reset the timer.
#define STATE_ACTIVE       0x0002

//when deregister wait is called(RefCount may be >0)
#define STATE_DELETE       0x0004

//set when cancel timer called. The APC will clean it up.
#define STATE_DONTFIRE     0x0008

//set when one shot timer fired.
#define STATE_ONE_SHOT_FIRED 0x0010
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tpool\wrapper.c ===
//------------------------------------------------------------------------------
// <copyright file="wrapper.c" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   wrapper.c
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
//
//  Avoid naming conflicts in threads.c
//  Replace RtlFuncA    to TPoolRtlFuncA.
//

#define RtlRegisterWait                  TPoolRtlRegisterWait
#define RtlDeregisterWait                TPoolRtlDeregisterWait
#define RtlDeregisterWaitEx              TPoolRtlDeregisterWaitEx
#define RtlQueueWorkItem                 TPoolRtlQueueWorkItem
#define RtlSetIoCompletionCallback       TPoolRtlSetIoCompletionCallback
#define RtlCreateTimerQueue              TPoolRtlCreateTimerQueue
#define RtlCreateTimer                   TPoolRtlCreateTimer
#define RtlUpdateTimer                   TPoolRtlUpdateTimer
#define RtlDeleteTimer                   TPoolRtlDeleteTimer
#define RtlDeleteTimerQueueEx            TPoolRtlDeleteTimerQueueEx
#define RtlThreadPoolCleanup             TPoolRtlThreadPoolCleanup

// Include threads.c to do the real work.
#define _NTSYSTEM_ 1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <conroute.h>

typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK;

// This file is copied from \windows\base\client\error.c
#include "error.c"

//
//  Avoid naming conflicts in thread.c
//  Replace FuncA to TPoolFuncA.
//

#define DeleteTimerQueueEx              TPoolDeleteTimerQueueEx           
#define DeleteTimerQueueTimer           TPoolDeleteTimerQueueTimer        
#define ChangeTimerQueueTimer           TPoolChangeTimerQueueTimer        
#define CreateTimerQueueTimer           TPoolCreateTimerQueueTimer        
#define CreateTimerQueue                TPoolCreateTimerQueue             
#define BindIoCompletionCallback        TPoolBindIoCompletionCallback     
#define QueueUserWorkItem               TPoolQueueUserWorkItem            
#define UnregisterWaitEx                TPoolUnregisterWaitEx             
#define UnregisterWait                  TPoolUnregisterWait               
#define RegisterWaitForSingleObjectEx   TPoolRegisterWaitForSingleObjectEx
#define RegisterWaitForSingleObject     TPoolRegisterWaitForSingleObject  


// This file is copied from \ntos\rtl\threads.c
#include "threads.c"

#undef _NTSYSTEM_

// Include thread.c for the wrappers to RtlCodeBase.
#define _NTSYSTEM_ 0

//This file is copied from \nt\private\windows\base\client\thread.c
#include "thread.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tpool\error.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains the Win32 error APIs.

Author:

    Mark Lucovsky (markl) 24-Sep-1990

Revision History:

--*/

#if NOT_IN_TPOOL

#include "basedll.h"

UINT
GetErrorMode()
{

    UINT PreviousMode;
    NTSTATUS Status;

    Status = NtQueryInformationProcess(
                NtCurrentProcess(),
                ProcessDefaultHardErrorMode,
                (PVOID) &PreviousMode,
                sizeof(PreviousMode),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return 0;
        }

    if (PreviousMode & 1) {
        PreviousMode &= ~SEM_FAILCRITICALERRORS;
        }
    else {
        PreviousMode |= SEM_FAILCRITICALERRORS;
        }
    return PreviousMode;
}


UINT
SetErrorMode(
    UINT uMode
    )
{

    UINT PreviousMode;
    UINT NewMode;

    PreviousMode = GetErrorMode();

    NewMode = uMode;
    if (NewMode & SEM_FAILCRITICALERRORS ) {
        NewMode &= ~SEM_FAILCRITICALERRORS;
        }
    else {
        NewMode |= SEM_FAILCRITICALERRORS;
        }
    if ( NT_SUCCESS(NtSetInformationProcess(
                        NtCurrentProcess(),
                        ProcessDefaultHardErrorMode,
                        (PVOID) &NewMode,
                        sizeof(NewMode)
                        ) ) ){
        }

    return( PreviousMode );
}

DWORD
GetLastError(
    VOID
    )

/*++

Routine Description:

    This function returns the most recent error code set by a Win32 API
    call.  Applications should call this function immediately after a
    Win32 API call returns a failure indications (e.g.  FALSE, NULL or
    -1) to determine the cause of the failure.

    The last error code value is a per thread field, so that multiple
    threads do not overwrite each other's last error code value.

Arguments:

    None.

Return Value:

    The return value is the most recent error code as set by a Win32 API
    call.

--*/

{
    return (DWORD)NtCurrentTeb()->LastErrorValue;
}

VOID
SetLastError(
    DWORD dwErrCode
    )

/*++

Routine Description:

    This function set the most recent error code and error string in per
    thread storage.  Win32 API functions call this function whenever
    they return a failure indication (e.g.  FALSE, NULL or -1).
    This function
    is not called by Win32 API function calls that are successful, so
    that if three Win32 API function calls are made, and the first one
    fails and the second two succeed, the error code and string stored
    by the first one are still available after the second two succeed.

    Applications can retrieve the values saved by this function using
    GetLastError.  The use of this function is optional, as an
    application need only call if it is interested in knowing the
    specific reason for an API function failure.

    The last error code value is kept in thread local storage so that
    multiple threads do not overwrite each other's values.

Arguments:

    dwErrCode - Specifies the error code to store in per thread storage
        for the current thread.

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    NtCurrentTeb()->LastErrorValue = (LONG)dwErrCode;
}

#endif // #if NOT_IN_TPOOL

ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This API sets the "last error value" and the "last error string"
    based on the value of Status. For status codes that don't have
    a corresponding error string, the string is set to null.

Arguments:

    Status - Supplies the status value to store as the last error value.

Return Value:

    The corresponding Win32 error code that was stored in the
    "last error value" thread variable.

--*/

{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}

#if NOT_IN_TPOOL

HANDLE
WINAPI
CreateIoCompletionPort(
    HANDLE FileHandle,
    HANDLE ExistingCompletionPort,
    ULONG_PTR CompletionKey,
    DWORD NumberOfConcurrentThreads
    )

/*++

Routine Description:

    This function creates an I/O completion port.  Completion ports
    provide another mechanism that can be used to to recive I/O
    completion notification.

    Completion ports act as a queue.  The Win32 I/O system can be
    instructed to queue I/O completion notification packets to
    completion ports.  This API provides this mechanism.  If a file
    handle is created for overlapped I/O completion
    (FILE_FLAG_OVERLAPPED) , a completion port can be associated with
    the file handle.  When I/O operations are done on a file handle that
    has an associated completion port, the I/O system will queue a
    completion packet when the I/O operation completes.  The
    GetQueuedCompletionStatus is used to pick up these queued I/O
    completion packets.

    This API can be used to create a completion port and associate it
    with a file.  If you supply a completion port, it can be used to
    associate the specified file with the specified completion port.

Arguments:

    FileHandle - Supplies a handle to a file opened for overlapped I/O
        completion.  This file is associated with either the specified
        completion port, or a new completion port is created, and the
        file is associated with that port.  Once associated with a
        completion port, the file handle may not be used in ReadFileEx
        or WriteFileEx operations.  It is not advisable to share an
        associated file handle through either handle inheritence or
        through DuplicateHandle.  I/O operations done on these
        duplicates will also generate a completion notification.

    ExistingCompletionPort - If this parameter is specified, it supplies
        an existing completion port that is to be associated with the
        specified file handle.  Otherwise, a new completion port is
        created and associated with the specified file handle.

    CompletionKey - Supplies a per-file completi