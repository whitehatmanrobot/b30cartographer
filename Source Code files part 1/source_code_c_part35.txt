Language();
	int               GetProductVersion();
	int               GetProductAssignment();
	int               GetProductInstanceType();
	const IMsiString& GetPackageMediaPath();
	const IMsiString& GetPackageCode();
	bool              GetAppCompatCAEnabled();
	const GUID*       GetAppCompatDB(GUID* pguidOutputBuffer);
	const GUID*       GetAppCompatID(GUID* pguidOutputBuffer);
	const GUID*       GUIDFromProdInfoData(GUID* pGuidOutputBuffer, int iField);

	IMsiRecord*   LinkedRegInfoExists(const ICHAR** rgszRegKeys, Bool& rfExists, const ibtBinaryType);

	iesEnum PopulateMediaList(const MsiString& strSourceListMediaKey, const IMsiRecord& riParams, int iFirstField, int iNumberOfMedia);
	iesEnum PopulateNonMediaList(const MsiString& strSourceListKey, const IMsiRecord& riParams, int iNumberOfMedia, int& iNetIndex, int& iURLIndex);

	iesEnum GetCurrentSourcePathAndType(IMsiPath*& rpiSourcePath, int& iSourceType);
	iesEnum GetSourceRootAndType(IMsiPath*& rpiSourceRoot, int& iSourceType);
	iesEnum ResolveMediaRecSourcePath(IMsiRecord& riMediaRec, int iIndex);
	iesEnum ResolveSourcePath(IMsiRecord& riParams, IMsiPath*& rpiSourcePath, bool& fCabinetCopy);
	
	IMsiRecord* EnsureUserDataKey();
	IMsiRecord* GetProductFeatureUsageKey(const IMsiString*& rpiSubKey);
	IMsiRecord* GetProductInstalledPropertiesKey(HKEY&rhRoot, const IMsiString*& rpiSubKey);
	IMsiRecord* GetProductInstalledFeaturesKey(const IMsiString*& rpiSubKey);
	IMsiRecord* GetProductInstalledComponentsKey(const ICHAR* szComponentId, const IMsiString*& rpiSubKey);
	IMsiRecord* GetInstalledPatchesKey(const ICHAR* szPatchCode, const IMsiString*& rpiSubKey);
	IMsiRecord* GetProductSecureTransformsKey(const IMsiString*& rpiSubKey);

	IMsiRecord* RegisterComponent(const IMsiString& riProductKey, const IMsiString& riComponentsKey, INSTALLSTATE iState, const IMsiString& riKeyPath, unsigned int uiDisk, int iSharedDllRefCount, const ibtBinaryType);
	IMsiRecord* UnregisterComponent(const IMsiString& riProductKey, const IMsiString& riComponentsKey, const ibtBinaryType);
	bool        IsChecksumOK(IMsiPath& riFilePath, const IMsiString& ristrFileName,
									 IErrorCode iErr, imsEnum* imsUsersChoice,
									 bool fErrorDialog, bool fVitalFile, bool fRetryButton);
	bool        ValidateSourceMediaLabelOrPackage(IMsiVolume* pSourceVolume, const unsigned int uiDisk, const ICHAR* szLabel);
	iesEnum     GetAssemblyCacheItem(const IMsiString& ristrComponentId,
															  IAssemblyCacheItem*& rpiASM,
															  iatAssemblyType& iatAT);
	iesEnum     ApplyPatchCore(IMsiPath& riTargetPath, IMsiPath& riTempFolder, const IMsiString& ristrTargetName,
										IMsiRecord& riParams, const IMsiString*& rpistrOutputFileName,
										const IMsiString*& rpistrOutputFilePath);

 protected:  // objects available to operators
	IMsiServices&             m_riServices;
	IMsiConfigurationManager& m_riConfigurationManager;
	IMsiMessage&              m_riMessage;
	IMsiDirectoryManager*     m_piDirectoryManager;
	CScriptGenerate*          m_pRollbackScript;
 protected:  // constructor
	CMsiOpExecute(IMsiConfigurationManager& riConfigurationManager, IMsiMessage& riMessage,
					  IMsiDirectoryManager* piDirectoryManager, Bool fRollbackEnabled,
					  unsigned int fFlags, HKEY* phKey);
	~CMsiOpExecute();
 protected:  // state information for use by operator functions, add as necessary
	ixsEnum       m_ixsState;
	int           m_iProgressTotal;
	IMsiRecord*   m_piProductInfo; // set by ixoProductInfo
	PMsiRecord    m_pProgressRec; // set by ixoActionStart and ixoProgressTotal, used by DispatchProgress
	PMsiRecord    m_pConfirmCancelRec; // used by DispatchMessage
	PMsiRecord    m_pRollbackAction;  // ActionStart data for rollback
	PMsiRecord    m_pCleanupAction;   // ActionStart data for rollback cleanup
	CActionState  m_state;  // action state variables, file folders, reg keys, etc..
	IMsiRecord*   m_rgpiSharedRecords[cMaxSharedRecord+2];  // used by GetSharedRecord
	//example: file folders, reg keys
	int           m_cSuppressProgress;
	Bool          m_fCancel; // used to catch imsCancel messages that are ignored
	Bool          m_fRebootReplace; // true when we have marked a file for reboot replacement

	istEnum       m_istScriptType;
	PMsiDatabase  m_pDatabase;     // temp database for caching data
	PMsiTable     m_pFileCacheTable; // table containing cached file info - set by ixoFileCopy, used by following ops
	PMsiCursor    m_pFileCacheCursor;
	int           m_colFileCacheFilePath, m_colFileCacheState, m_colFileCacheTempLocation, m_colFileCacheVersion, m_colFileCacheRemainingPatches, m_colFileCacheRemainingPatchesToSkip;	

	PMsiTable     m_pShellNotifyCacheTable; // table containing shell notifications for later processing
	PMsiCursor    m_pShellNotifyCacheCursor;
	int           m_colShellNotifyCacheShortcutPath, m_colShellNotifyCacheFileName, m_colShellNotifyCachePath2;

	MsiString     m_strUserProfile;
	MsiString     m_strUserAppData;

	bool          m_fUserChangedDuringInstall; // The user changed in the middle of a suspended install.

	// info required by the advertise actions
	
	PMsiPath      m_pCachePath;
		// NOTE:  If the path you use is intended to roam, you must use a relative path to %USERPROFILE% instead.
		// hard-coded paths will choke.
		// See also:  CMsiOpExecute::GetUserProfileEnvPath()
	
	HKEY          m_hKey;
	HKEY          m_hOLEKey;
	HKEY          m_hOLEKey64;
	HKEY          m_hKeyRm;
	Bool          m_fKey;
	HKEY          m_hPublishRootKey;
	HKEY          m_hPublishRootOLEKey;
	HKEY          m_hPublishRootKeyRm;
	MsiString     m_strPublishSubKey;
	MsiString     m_strPublishOLESubKey;
	MsiString     m_strPublishSubKeyRm;
	HKEY          m_hUserDataKey;
	MsiString     m_strUserDataKey;
	IMsiRecord*   m_piStackRec[MAX_RECORD_STACK_SIZE + 1];
	int           m_iWriteFIFO;
	int           m_iReadFIFO;
	int           m_fFlags;
	Bool          m_fReverseADVTScript; // flag to force the reversal of the advertise script operations 
	CActionThreadData* m_pActionThreadData;  // linked list of custom action threads
	irlEnum       m_irlRollbackLevel;

	PMsiPath      m_pEnvironmentWorkingPath95;
	MsiString     m_strEnvironmentWorkingFile95;
	PMsiPath      m_pEnvironmentPath95;
	MsiString	  m_strEnvironmentFile95;
	Bool          m_fShellRefresh;
	bool          m_fFontRefresh;
	bool          m_fResetTTFCache;
	bool          m_fStartMenuUninstallRefresh;
	bool          m_fEnvironmentRefresh;
	bool          m_fUserSpecificCache;
	int           m_iScriptVersion;
	int           m_iScriptVersionMinor;
	bool          m_fSfpCancel;
	bool          m_fRunScriptElevated; 
		// enables CAs, etc to elevate. If this is false, CAs will never elevate, even if the script is
		// elevated itself
	
	bool          m_fAssigned;

	bool          m_fRemapHKCU;

	PMsiTable     m_pAssemblyCacheTable;
	int           m_colAssemblyMappingAssemblyName;
	int           m_colAssemblyMappingComponentId;
	int           m_colAssemblyMappingAssemblyType;
	int           m_colAssemblyMappingASM;
	IMsiRecord*   CreateAssemblyCacheTable();
	IMsiRecord*   CacheAssemblyMapping(const IMsiString& ristrComponentId, const IMsiString& ristrAssemblyName, iatAssemblyType iatType);

	PMsiTable     m_pAssemblyUninstallTable;
	int           m_colAssemblyUninstallComponentId;
	int           m_colAssemblyUninstallAssemblyName;
	int           m_colAssemblyUninstallAssemblyType;
	IMsiRecord*   CreateTableForAssembliesToUninstall();
	IMsiRecord*   CacheAssemblyForUninstalling(const IMsiString& ristrComponentId, const IMsiString& ristrAssemblyName, iatAssemblyType iatAT);
	static IMsiRecord*   IsAssemblyInstalled(const IMsiString& rstrComponentId, const IMsiString& ristrAssemblyName, iatAssemblyType iatAT, bool& rfInstalled, IAssemblyCache** ppIAssemblyCache, IAssemblyName** ppIAssemblyName);
	static IMsiRecord*   UninstallAssembly(const IMsiString& rstrComponentId, const IMsiString& strAssemblyName, iatAssemblyType iatAT);

	int           m_iMaxNetSource;
	int           m_iMaxURLSource;
	
	DWORD         m_rgDisplayOnceMessages[2];

	CDeleteUrlLocalFileOnClose*  m_pUrlLocalCabinet;
};

//____________________________________________________________________________
//
// CMsiExecute - implementation class for IMsiExecute
//____________________________________________________________________________

class CMsiExecute : public IMsiExecute, public CMsiOpExecute
{
 protected: // IMsiExecute implemented virtual functions
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	iesEnum       __stdcall RunScript(const ICHAR* szScriptFile, bool fForceElevation);
	IMsiRecord*   __stdcall EnumerateScript(const ICHAR* szScriptFile, IEnumMsiRecord*& rpiEnum);
	iesEnum       __stdcall ExecuteRecord(ixoEnum ixoOpCode, IMsiRecord& riParams);
	iesEnum       __stdcall RemoveRollbackFiles(MsiDate date);
	iesEnum       __stdcall Rollback(MsiDate date, bool fUserChangedDuringInstall);
	iesEnum       __stdcall RollbackFinalize(iesEnum iesState, MsiDate date, bool fUserChangedDuringInstall);
	IMsiServices& __stdcall GetServices();
	iesEnum       __stdcall GetTransformsList(IMsiRecord& riProductInfoParams, IMsiRecord& riProductPublishParams, const IMsiString*& rpiTransformsList);

 protected: // constructor/destructor
	void* operator new(size_t cb) {void* pv = AllocObject(cb); return memset(pv, 0, cb);}
	void operator delete(void * pv) { FreeObject(pv); }
	CMsiExecute(IMsiConfigurationManager& riConfigurationManager, IMsiMessage& riMessage,
					IMsiDirectoryManager* piDirectoryManager,	Bool fRollbackEnabled,
					unsigned int fFlags, HKEY* phKey);
   ~CMsiExecute();  // protected to prevent construction on stack
	friend IMsiExecute* CreateExecutor(IMsiConfigurationManager& riConfigurationManager,
												  IMsiMessage& riMessage, IMsiDirectoryManager* piDirectoryManager,
												  Bool fRollbackEnabled, unsigned int fFlags, HKEY* phKey);
 protected:
	iesEnum RunInstallScript(IMsiStream& rpiScript, const ICHAR* szScriptFile);
	iesEnum RunRollbackScript(IMsiStream& rpiScript, const ICHAR* szScriptFile);
	iesEnum GenerateRollbackScriptName(IMsiPath*& rpiPath, const IMsiString*& rpistr);
	iesEnum RemoveRollbackScriptAndBackupFiles(const IMsiString& ristrScriptFile);
	iesEnum DoMachineVsUserInitialization();
	void DeleteRollbackScriptList(RBSInfo* pListHead);
	IMsiRecord* GetSortedRollbackScriptList(MsiDate date, Bool fAfter, RBSInfo*& rpListHead);
	void ClearExecutorData();
	iesEnum CommitAssemblies();

 private:   // script accessors
	IMsiRecord*   OpenScriptRead(const ICHAR* szScript, IMsiStream*& rpiStream);

 private:    // state data
	int           m_iRefCnt;
	typedef iesEnum (CMsiOpExecute::*FOpExecute)(IMsiRecord& riParams);
	static FOpExecute rgOpExecute[]; // operation dispatch array
	static int rgOpTypes[];
 public:   // used by members and CEnumScriptRecord
// readscriptrecord made into a global function, declared in common.h, t-guhans
//	static IMsiRecord* ReadScriptRecord(IMsiServices& riServices, IMsiStream& riStream);

// 	friend class CEnumScriptRecord;  // access to ReadScriptRecord()
};


#endif // __EXECUTE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\_msiutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       _msiutil.h
//
//--------------------------------------------------------------------------

#ifndef __MSIUTIL_H
#define __MSIUTIL_H

#include "_engine.h"
#include <winsafer.h>

//____________________________________________________________________________
//
// Helper function prototypes
//____________________________________________________________________________

UINT ModeBitsToString(DWORD dwMode, const ICHAR* rgchModes, ICHAR* rgchBuffer);
UINT StringToModeBits(const ICHAR* szMode, const ICHAR* rgchPossibleModes, DWORD &dwMode);
UINT MapInstallActionReturnToError(iesEnum ies);
HRESULT SetMinProxyBlanketIfAnonymousImpLevel (IUnknown * piUnknown);

const ICHAR szInstallPackageExtension[]        = TEXT(".msi");
const ICHAR szPatchPackageExtension[]          = TEXT(".msp");

UINT RunEngine(ireEnum ireProductSpec,   // type of string specifying product
			   const ICHAR* szProduct,      // required, matches ireProductSpec
			   const ICHAR* szAction,       // optional, engine defaults to "INSTALL"
			   const ICHAR* szCommandLine,  // optional command line
				iuiEnum iuiLevel,
				iioEnum iioOptions);

// only to be called from newly created threads
int CreateAndRunEngine(ireEnum ireProductSpec,   // type of string specifying product
			   const ICHAR* szProduct,      // required, matches ireProductSpec
			   const ICHAR* szAction,       // optional, engine defaults to "INSTALL"
			   const ICHAR* szCommandLine,  // optional command line
			   CMsiEngine*  piParentEngine, // parent engine object for nested call only
				iioEnum      iioOptions);    // install options

int CreateInitializedEngine(
			const ICHAR* szDatabasePath, // may be null if open piStorage passed
			const ICHAR* szProductCode,  // optional, product code if already determined
			const ICHAR* szCommandLine,
            BOOL         fServiceRequired,  // If true we should either be running as a service or we must connect to it
			iuiEnum iuiLevel,            // only used if no global level set
			IMsiStorage* piStorage,      // optional, else uses szDatabasePath
			IMsiDatabase* piDatabase,    // optional, else uses piStorage or szDatabasePath
			CMsiEngine* piParentEngine,  // optional, only if nested install
			iioEnum      iioOptions,     // install options
			IMsiEngine *& rpiEngine,     // returned engine object
			SAFER_LEVEL_HANDLE  hSaferLevel);   // handle to Safer authorization level (will be present except when ireProductSpec == ireDatabaseHandle)


int ConfigureOrReinstallFeatureOrProduct(
	const ICHAR* szProduct,
	const ICHAR* szFeature,
	INSTALLSTATE eInstallState,
	DWORD dwReinstallMode,
	int iInstallLevel,
	iuiEnum iuiLevel,
	const ICHAR* szCommandLine);

Bool              ExpandPath(const ICHAR* szPath, CAPITempBufferRef<ICHAR>& rgchExpandedPath, const ICHAR* szCurrentDirectory=0);

int ApplyPatch(
	const ICHAR* szPackagePath,
	const ICHAR* szProduct,
	INSTALLTYPE  eInstallType,
	const ICHAR* szCommandLine);

UINT GetLoggedOnUserCountXP(void);
UINT GetLoggedOnUserCountWin2K(void);
UINT GetLoggedOnUserCount(void);

HRESULT GetFileSignatureInformation(const ICHAR* szFile, DWORD dwFlags, PCCERT_CONTEXT* ppCertContext, BYTE* pbHash, DWORD* pcbHash);

// fn: clears out any IsolatedComponent entries that were created for a component that is now disabled
IMsiRecord* RemoveIsolateEntriesForDisabledComponent(IMsiEngine& riEngine, const ICHAR szComponent[]);

UINT CreateAndVerifyInstallerDirectory();

enum idapEnum
{
	idapMachineLocal = 0,
	idapUserLocal    = 1,
	idapScript       = 2,
};

enum tpEnum // Transform Path Enum
{
	tpUnknown        = 0, // has not yet been determined
	tpUnknownSecure  = 1, // has not yet been determined, but we know it's secure
	tpRelative       = 2, // relative path, path = [current directory]\transform.mst; [path to msi]\transform.mst
	tpRelativeSecure = 3, // relative path, path = [path to msi]\transform.mst
	tpAbsolute       = 4, // absolute path, path = transform.mst
};

UINT DoAdvertiseProduct(const ICHAR* szPackagePath, const ICHAR* szScriptfilePath, const ICHAR* szTransforms, idapEnum idapAdvertisement, LANGID lgidLanguage, DWORD dwPlatform, DWORD dwOptions);

enum stEnum;

const ICHAR szDigitalSignature[] = TEXT("\005DigitalSignature");
const ICHAR szTransform[] = TEXT("transform");
const ICHAR szDatabase[]  = TEXT("package");
const ICHAR szPatch[]     = TEXT("patch");
const ICHAR szObject[]    = TEXT("object");


bool VerifyMsiObjectAgainstSAFER(IMsiServices& riServices, IMsiStorage* piStorage, const ICHAR* szMsiObject, const ICHAR* szFriendlyName, stEnum stType, SAFER_LEVEL_HANDLE *phSaferLevel);
bool UpdateSaferLevelInMessageContext(SAFER_LEVEL_HANDLE hNewSaferLevel);

// those that want a record
IMsiRecord* OpenAndValidateMsiStorageRec(const ICHAR* szFile, stEnum stType, IMsiServices& riServices, IMsiStorage*& rpiStorage, bool fCallSAFER, const ICHAR* szFriendlyName, SAFER_LEVEL_HANDLE *phSaferLevel);
// those that want a UINT
UINT OpenAndValidateMsiStorage(const ICHAR* szFile, stEnum stType, IMsiServices& riServices, IMsiStorage*& rpiStorage, bool fCallSAFER, const ICHAR* szFriendlyName, SAFER_LEVEL_HANDLE *phSaferLevel);

UINT GetPackageCodeAndLanguageFromStorage(IMsiStorage& riStorage, ICHAR* szPackageCode, LANGID* piLangId=0);
UINT GetProductCodeFromPackage(const ICHAR* szPackage, ICHAR* szProductCode);

DWORD CopyTempDatabase(const ICHAR* szDatabasePath, const IMsiString*& ristrNewDatabasePath, Bool& fRemovable, const IMsiString*& rpiVolumeLabel, IMsiServices& riServices, stEnum stType);

// mutex helper functions

// CMutex: wrapper class for handling Mutex's
class CMutex
{
 public:
	CMutex() { m_h = NULL; }
	~CMutex() { Release(); }
	int Grab(const ICHAR* szName, DWORD dwWait);
	void Release();
 private:
	HANDLE m_h;
};

const ICHAR szMsiExecuteMutex[] = TEXT("_MSIExecute");

int               GrabExecuteMutex(CMutex& m);
int               GrabMutex(const ICHAR* szName, DWORD dwWait, HANDLE& rh);

bool              FMutexExists(const ICHAR* szName, HANDLE& rh);

//____________________________________________________________________________
//
// Constants
//____________________________________________________________________________

const int ERROR_INSTALL_REBOOT     = -1;
const int ERROR_INSTALL_REBOOT_NOW = -2;
const int cchCachedProductCodes = 4;
const iuiEnum iuiDefaultUILevel = iuiBasic;

enum plEnum
{
	plLocalCache   = 1,
	plSource       = 2,
	plInProgress   = 4,
	plAny          = 7,
	plNoLocalCache = 6,
}; // Package Location

enum stEnum
{
	stDatabase,
	stPatch,
	stTransform,
	stIgnore
}; // storage type

const ICHAR szInstallMutex[] = TEXT("_MSILockServer");

//____________________________________________________________________________
//
// Expected or required lengths of various strings. (not including NULL)
//
// cchMax*        -- the string will contain at most this many characters
// cchExpectedMax -- the string will usually contain at most this many
//                   characters, but may possible contain more
// cch* (not either of the 1st 2) -- the string must contain exactly this
//                                   many characters
//____________________________________________________________________________

const int cchMaxFeatureName           = MAX_FEATURE_CHARS;
const int cchGUID                     = 38;
const int cchGUIDPacked               = 32;
const int cchGUIDCompressed           = 20;  // used in descriptors only
const int cchComponentId              = cchGUID;
const int cchComponentIdPacked        = cchGUIDPacked;
const int cchComponentIdCompressed    = cchGUIDCompressed;
const int cchProductCode              = cchGUID;
const int cchProductCodePacked        = cchGUIDPacked;
const int cchProductCodeCompressed    = cchGUIDCompressed;
const int cchPackageCode              = cchGUID;
const int cchPackageCodePacked        = cchGUIDPacked;
const int cchMaxQualifier             = 100;
const int cchMaxReinstallModeFlags    = 20;
const int cchExpectedMaxProductName   = 200;
const int cchExpectedMaxOrgName       = 200;
const int cchExpectedMaxUserName      = 200;
const int cchExpectedMaxPID           = 200;
const int cchExpectedMaxProperty      = 100;
const int cchExpectedMaxProductProperty = 100;
const int cchExpectedMaxPropertyValue = 100;
const int cchExpectedMaxFeatureComponentList = 100;
const int cchMaxCommandLine = 1024;  // used for MSIUNICODE->Ansi conversion
const int cchMaxPropertyName          = 25;
const int cchMaxPath                  = MAX_PATH;
const int cchExpectedMaxPath          = MAX_PATH;
const int cchMaxDescriptor            = cchProductCode + cchComponentId + 1 +
												   cchMaxFeatureName;
const int cchExpectedMaxFeatureHelp   = 100;
const int cchExpectedMaxFeatureTitle  = 100;
const int cchExpectedMaxMessage       = 100;
const int cchPatchCode                = cchGUID;
const int cchPatchCodePacked          = cchGUIDPacked;
const int cchExpectedMaxPatchList     = 3*(cchGUID + 1); //!! ??
const int cchExpectedMaxPatchTransformList = 100;
const int cchMaxTableName             = 31;

//____________________________________________________________________________
//
// Registry handle wrapper
//____________________________________________________________________________

static const ICHAR* rgszRoot[] = { TEXT("HKCR\\"), TEXT("HKCU\\"), TEXT("HKLM\\"), TEXT("HKU\\"), TEXT("Unknown\\") };

class CRegHandleStatic
{
public:
	CRegHandleStatic();
	CRegHandleStatic(HKEY h);
#ifdef DEBUG
	~CRegHandleStatic();
#endif //DEBUG
	void Destroy();
	void operator =(HKEY h);
	operator HKEY() const;
	void SetSubKey(const ICHAR* szSubKey);
	void SetSubKey(CRegHandleStatic& riKey, const ICHAR* szSubKey);
	void SetKey(HKEY hRoot, const ICHAR* szSubKey);
	HKEY* operator &();
	const ICHAR* GetKey();
	void ResetWithoutClosing();
//  operator CRegHandleStatic&() { return *this;}
	operator const INT_PTR();               //--merced: changed int to INT_PTR
//   operator Bool() { return m_h==0?fFalse:fTrue; }
//   HKEY* operator &() { return &m_h;}
//   operator &() { return m_h;}

private:
	void AquireLock();
	void ReleaseLock();

	HKEY m_h;
	CAPITempBuffer<ICHAR,1> m_rgchKey;
	int m_iLock; // only one thread allowed access to m_h
};

class CRegHandle : public CRegHandleStatic
{
public:
	~CRegHandle();
	operator CRegHandle&() { return *this;}

};

inline CRegHandleStatic::CRegHandleStatic() : m_h(0), m_iLock(0)
{
	m_rgchKey[0] = 0;
}

inline CRegHandleStatic::CRegHandleStatic(HKEY h) : m_h(h), m_iLock(0)
{
	m_rgchKey[0] = 0;
}

inline void CRegHandleStatic::AquireLock()
{
	while (TestAndSet(&m_iLock) == true)
	{
		Sleep(100); // seems like a reasonable interval
	}
}

inline void CRegHandleStatic::ReleaseLock()
{
	m_iLock = 0;	
}

inline void CRegHandleStatic::operator =(HKEY h)
{
	AquireLock();
	if(m_h != 0)
		WIN::RegCloseKey(m_h);
	m_h = h;
	ReleaseLock();
	m_rgchKey[0] = 0;
}

inline void CRegHandleStatic::ResetWithoutClosing()
{
	AquireLock();
	m_h = 0;
	ReleaseLock();
	m_rgchKey[0] = 0;
}

inline void CRegHandleStatic::SetSubKey(const ICHAR* szSubKey)
{
	SetKey(m_h, szSubKey);
}

inline void CRegHandleStatic::SetSubKey(CRegHandleStatic& riKey, const ICHAR* szSubKey)
{
	// new size is length of base key + '\\' + length of subkey + '\0'
	size_t cchLen = IStrLen(riKey.GetKey()) + 1 + (szSubKey ? IStrLen(szSubKey) : 0) + 1;
	if (m_rgchKey.GetSize() < cchLen)
	{
		if (!m_rgchKey.SetSize(cchLen))
		{
			Assert(0);
			m_rgchKey[0] = L'\0';
			return;
		}
	}

	if (FAILED(StringCchCopy(m_rgchKey, m_rgchKey.GetSize(), riKey.GetKey())) ||
		FAILED(StringCchLength(m_rgchKey, m_rgchKey.GetSize(), &cchLen)) ||
		FAILED(StringCchCopy(static_cast<ICHAR*>(m_rgchKey)+cchLen, m_rgchKey.GetSize()-cchLen, TEXT("\\"))))
	{
		Assert(0);
		m_rgchKey[0] = L'\0';
		return;
	}

	if (szSubKey)
	{
		cchLen++;
		if (FAILED(StringCchCopy(static_cast<ICHAR*>(m_rgchKey)+cchLen, m_rgchKey.GetSize()-cchLen, szSubKey)))
		{
			Assert(0);
			m_rgchKey[0] = L'\0';
			return;
		}
	}
}

inline void CRegHandleStatic::SetKey(HKEY hRoot, const ICHAR* szSubKey)
{
	INT_PTR h = (INT_PTR)hRoot & ~((INT_PTR)HKEY_CLASSES_ROOT);

	if (h > 4)
		h = 4;

	size_t cchLen = IStrLen(rgszRoot[h]) + (szSubKey ? IStrLen(szSubKey) : 0) + 1;
	if (m_rgchKey.GetSize() < cchLen)
	{
		if (!m_rgchKey.SetSize(cchLen))
		{
			Assert(0);
			m_rgchKey[0] = L'\0';
			return;
		}
	}
	if (FAILED(StringCchCopy(m_rgchKey, m_rgchKey.GetSize(), rgszRoot[h])) ||
		FAILED(StringCchCat(m_rgchKey, m_rgchKey.GetSize(), szSubKey)))
	{
		Assert(0);
		m_rgchKey[0] = L'\0';
		return;
	}
}

inline const ICHAR* CRegHandleStatic::GetKey()
{
	return m_rgchKey;
}

inline CRegHandleStatic::operator HKEY() const
{
	return m_h;
}

inline HKEY* CRegHandleStatic::operator &()
{
	AquireLock();
	if (m_h != 0)
	{
		WIN::RegCloseKey(m_h);
		m_h = 0;
		m_rgchKey[0] = 0;
	}
	ReleaseLock();
	return &m_h;
}

inline CRegHandleStatic::operator const INT_PTR()   //--merced: changed int to INT_PTR.
{
	return (INT_PTR) m_h;                           //--merced: changed int to INT_PTR.
}

inline void CRegHandleStatic::Destroy()
{
	AquireLock();
	if(m_h != 0)
	{
		WIN::RegCloseKey(m_h);
		m_h = 0;
		m_rgchKey[0] = 0;
	}
	ReleaseLock();
}

#ifdef DEBUG
inline CRegHandleStatic::~CRegHandleStatic()
{
	AssertSz(m_h == 0, "RegHandle not closed");
}
#endif //DEBUG

inline CRegHandle::~CRegHandle()
{
	Destroy();
}

// FN:get the "visible" product assignment type
DWORD GetProductAssignmentType(const ICHAR* szProductSQUID, iaaAppAssignment& riType, CRegHandle& hKey);
DWORD GetProductAssignmentType(const ICHAR* szProductSQUID, iaaAppAssignment& riType);


//____________________________________________________________________________
//
// CMsiAPIMessage definition - state for externally set UI settings and callback
//____________________________________________________________________________

class CMsiExternalUI
{
 public:
	LPVOID             m_pvContext;
	INSTALLUI_HANDLERA m_pfnHandlerA;
	INSTALLUI_HANDLERW m_pfnHandlerW;
	int                m_iMessageFilter;
};

class CMsiAPIMessage : public CMsiExternalUI
{
 public:
	imsEnum            Message(imtEnum imt, IMsiRecord& riRecord);
	imsEnum            Message(imtEnum imt, const ICHAR* szMessage) const;
	INSTALLUILEVEL     SetInternalHandler(UINT dwUILevel, HWND *phWnd);
	Bool               FSetInternalHandlerValue(UINT dwUILevel);
	void               Destroy();  // can only call at DLL unload
	INSTALLUI_HANDLERW SetExternalHandler(INSTALLUI_HANDLERW pfnHandlerW, INSTALLUI_HANDLERA pfnHandlerA, DWORD dwMessageFilter, LPVOID pvContext);
	CMsiExternalUI*    FindOldHandler(INSTALLUI_HANDLERW pfnHandlerW);
 public:  // internal UI values
	iuiEnum            m_iuiLevel;
	HWND               m_hwnd;
	bool               m_fEndDialog;
	bool               m_fNoModalDialogs;
	bool               m_fHideCancel;
	bool               m_fSourceResolutionOnly;
 public: // constructor (static)
	CMsiAPIMessage();
 private:
	int              m_cLocalContexts;
	int              m_cAllocatedContexts;
	CMsiExternalUI*  m_rgAllocatedContexts;
};

//____________________________________________________________________________
//
// CApiConvertString -- does appropriate string conversion
//____________________________________________________________________________

// reduce stack usage by initializing all conversion buffers to 1. Buffers will
// automatically resize and reallocate frome the heap if needed.
const int cchApiConversionBuf = 255;

class CApiConvertString
{
public:
	explicit CApiConvertString(const char* szParam);
	explicit CApiConvertString(const WCHAR* szParam);
	operator const char*()
	{
		if (!m_szw)
			return m_sza;
		else
		{
			int cchParam = lstrlenW(m_szw)+1;
			if (cchParam > cchApiConversionBuf*(sizeof(WCHAR)/sizeof(char)))
				m_rgchOppositeBuf.SetSize(cchParam/(sizeof(WCHAR)/sizeof(char))+1);

			*m_rgchOppositeBuf = 0;
			int iRet = WideCharToMultiByte(CP_ACP, 0, m_szw, -1, reinterpret_cast<char*>(static_cast<WCHAR*>(m_rgchOppositeBuf)),
									  m_rgchOppositeBuf.GetSize()*(sizeof(WCHAR)/sizeof(char)), 0, 0);

			if ((0 == iRet) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
			{
				iRet = WideCharToMultiByte(CP_ACP, 0, m_szw, -1, 0, 0, 0, 0);
				if (iRet)
				{
					m_rgchOppositeBuf.SetSize(iRet/(sizeof(WCHAR)/sizeof(char))+1);
					*m_rgchOppositeBuf = 0;
					iRet = WideCharToMultiByte(CP_ACP, 0, m_szw, -1, reinterpret_cast<char*>(static_cast<WCHAR*>(m_rgchOppositeBuf)),
								  m_rgchOppositeBuf.GetSize()*(sizeof(WCHAR)/sizeof(char)), 0, 0);
				}
				Assert(iRet != 0);
			}

			return  reinterpret_cast<char*>(static_cast<WCHAR*>(m_rgchOppositeBuf));
		}
	}

	operator const WCHAR*()
	{
		if (!m_sza)
			return m_szw;
		else
		{
			int cchParam = lstrlenA(m_sza)+1;
			if (cchParam > cchApiConversionBuf)
				m_rgchOppositeBuf.SetSize(cchParam+1);

			*m_rgchOppositeBuf = 0;
			int iRet = MultiByteToWideChar(CP_ACP, 0, m_sza, -1, m_rgchOppositeBuf, m_rgchOppositeBuf.GetSize());
			if ((0 == iRet) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
			{
				iRet = MultiByteToWideChar(CP_ACP, 0, m_sza, -1, 0, 0);
				if (iRet)
				{
					m_rgchOppositeBuf.SetSize(iRet);
					*m_rgchOppositeBuf = 0;
					iRet = MultiByteToWideChar(CP_ACP, 0, m_sza, -1, m_rgchOppositeBuf, m_rgchOppositeBuf.GetSize());
				}
				Assert(iRet != 0);
			}


			return m_rgchOppositeBuf;
		}
	}

protected:
	void* operator new(size_t) {return 0;} // restrict use to temporary objects
	CAPITempBuffer<WCHAR, cchApiConversionBuf+1> m_rgchOppositeBuf;
	const char* m_sza;
	const WCHAR* m_szw;
};

inline CApiConvertString::CApiConvertString(const WCHAR* szParam)
{
	m_szw = szParam;
	m_sza = 0;
}

inline CApiConvertString::CApiConvertString(const char* szParam)
{
	m_szw = 0;
	m_sza = szParam;
}

//____________________________________________________________________________
//
// CMsiConvertString class. An extension of the CApiConvertString class.
// This class adds the ability to convert to an IMsiString&.
//____________________________________________________________________________

class CMsiConvertString : public CApiConvertString
{
public:
	CMsiConvertString(const char* szParam)  : CApiConvertString(szParam), m_piStr(0), fLoaded(fFalse) {};
	CMsiConvertString(const WCHAR* szParam) : CApiConvertString(szParam), m_piStr(0), fLoaded(fFalse) {};
	~CMsiConvertString();
	const IMsiString& operator *();
protected:
	void* operator new(size_t) {return 0;} // restrict use to temporary objects
	const IMsiString* m_piStr;
	Bool fLoaded;
};

inline CMsiConvertString::~CMsiConvertString()
{
	if (m_piStr)
		m_piStr->Release();
	if (fLoaded)
		ENG::FreeServices();
}


//____________________________________________________________________________
//
// Stuff I don't know where goes quite yet
//____________________________________________________________________________

extern CMsiAPIMessage g_message;
extern ICHAR   g_szLogFile[MAX_PATH+1];
extern DWORD   g_dwLogMode;
extern bool    g_fFlushEachLine;


iuiEnum GetStandardUILevel();

enum pplProductPropertyLocation
{
	pplAdvertised,
	pplUninstall,
	pplSourceList,
	pplIntegerPolicy,
	pplNext,
};

enum ptPropertyType // bits
{
	ptProduct = 0x1,
	ptPatch   = 0x2,
	ptSQUID   = 0x4,
};


struct ProductPropertyA
{
	const char* szProperty;
	const char* szValueName;
	pplProductPropertyLocation ppl;
	ptPropertyType pt;
};

struct ProductPropertyW
{
	const WCHAR* szProperty;
	const WCHAR* szValueName;
	pplProductPropertyLocation ppl;
	ptPropertyType pt;
};

extern ProductPropertyA g_ProductPropertyTableA[];
extern ProductPropertyW g_ProductPropertyTableW[];

// defines for guid separators
#define chComponentGUIDSeparatorToken    '>'
#define chGUIDAbsentToken                '<'
#define chGUIDCOMToCOMPlusInteropToken   '|'

enum ipgEnum
{
	ipgFull       = 0,  // no compression
	ipgPacked     = 1,  // remove punctuation and reorder low byte first
	ipgCompressed = 2,  // max text compression, can't use in reg keys or value names
	ipgPartial    = 3,  // partial translation, between ipgCompressed and ipgPacked
//  ipgMapped     = 4,  // pack as mapped token (not implemented)
	ipgTrimmed    = 5,  // remove punctuation only - don't reorder
};

Bool PackGUID(const char* szGUID, char* szSQUID, ipgEnum ipg=ipgPacked);
Bool UnpackGUID(const char* szSQUID, char* szGUID, ipgEnum ipg=ipgPacked);

Bool PackGUID(const WCHAR* szGUID, WCHAR* szSQUID, ipgEnum ipg=ipgPacked);
Bool UnpackGUID(const WCHAR* szSQUID, WCHAR* szGUID, ipgEnum ipg=ipgPacked);
inline bool GetCOMPlusInteropDll(ICHAR* szFullPath, size_t cchFullPath)
{
	Assert(szFullPath);
	// the server is always <system32folder>\mscoree.dll
	return ::MakeFullSystemPath(TEXT("mscoree"), szFullPath, cchFullPath);
}


inline const IMsiString& GetPackedGUID(const ICHAR* szGuid)
{
	MsiString strPackedGuid;
	ICHAR* szBuf = strPackedGuid.AllocateString((cchGUIDPacked), /*fDBCS=*/fFalse);
	AssertNonZero(PackGUID(szGuid, szBuf));
	return strPackedGuid.Return();
}

inline const IMsiString& GetUnpackedGUID(const ICHAR* szSQUID)
{
	MsiString strUnpackedGuid;
	ICHAR* szBuf = strUnpackedGuid.AllocateString((cchGUID),/*fDBCS=*/fFalse);
	AssertNonZero(UnpackGUID(szSQUID, szBuf));
	return strUnpackedGuid.Return();
}

unsigned int GetIntegerPolicyValue(const ICHAR* szName, Bool fMachine, Bool* pfUsedDefault=0);
void GetStringPolicyValue(const ICHAR* szName, Bool fMachine, CAPITempBufferRef<ICHAR>& rgchValue);

#if defined(UNICODE) || defined(MSIUNICODE)
#define ResetCachedPolicyValues ResetCachedPolicyValuesW
void ResetCachedPolicyValuesW();
#else
#define ResetCachedPolicyValues ResetCachedPolicyValuesA
void ResetCachedPolicyValuesA();
#endif

void GetTempDirectory(CAPITempBufferRef<ICHAR>& rgchDir);
void GetEnvironmentVariable(const ICHAR* sz,CAPITempBufferRef<ICHAR>& rgch);

#ifdef UNICODE
#define MsiRegEnumValue MsiRegEnumValueW
LONG MsiRegEnumValueW(
#else
#define MsiRegEnumValue MsiRegEnumValueA
LONG MsiRegEnumValueA(
#endif
							 HKEY hKey, DWORD dwIndex, CAPITempBufferRef<ICHAR>& rgchValueNameBuf, LPDWORD lpcbValueName, LPDWORD lpReserved,
							 LPDWORD lpType, CAPITempBufferRef<ICHAR>& rgchValueBuf, LPDWORD lpcbValue);

#ifdef UNICODE
#define MsiRegQueryValueEx MsiRegQueryValueExW
LONG MsiRegQueryValueExW(
#else
#define MsiRegQueryValueEx MsiRegQueryValueExA
LONG MsiRegQueryValueExA(
#endif
			HKEY hKey, const ICHAR* lpValueName, LPDWORD lpReserved, LPDWORD lpType, CAPITempBufferRef<ICHAR>& rgchBuf, LPDWORD lpcbBuf);


#ifdef UNICODE
#define OpenSourceListKey OpenSourceListKeyW
DWORD OpenSourceListKeyW(
#else
#define OpenSourceListKey OpenSourceListKeyA
DWORD OpenSourceListKeyA(
#endif
						  const ICHAR* szProductOrPatchCodeGUID, Bool fPatch, CRegHandle &phKey, Bool fWrite, bool fSetKeyString);

DWORD OpenAdvertisedProductKey(const ICHAR* szProductGUID, CRegHandle &phKey, bool fSetKeyString, iaaAppAssignment* piRet);
DWORD OpenAdvertisedPatchKey(const ICHAR* szPatchGUID, CRegHandle &phKey, bool fSetKeyString);
DWORD OpenSourceListKeyPacked(const ICHAR* szProductOrPatchCodeSQUID, Bool fPatch, CRegHandle &phKey, Bool fWrite, bool fSetKeyString);
DWORD OpenAdvertisedSubKey(const ICHAR* szSubKey, const ICHAR* szItemGUID, CRegHandle &phKey, bool fSetKeyString, int iKey,  iaaAppAssignment* piRet);

DWORD OpenInstalledFeatureKey(const ICHAR* szProductSQUID, CRegHandle& rhKey, bool fSetKeyString);

DWORD OpenInstalledProductTransformsKey(const ICHAR* szProduct, CRegHandle& rhKey, bool fSetKeyString);

DWORD OpenSpecificUsersWritableAdvertisedProductKey(enum iaaAppAssignment iaaAsgnType, const ICHAR* szUserSID, const ICHAR* szProductSQUID, CRegHandle &riHandle, bool fSetKeyString);
DWORD OpenWritableAdvertisedProductKey(const ICHAR* szProduct, CRegHandle& pHandle, bool fSetKeyString);

enum apEnum
{
	apReject = 0,
	apImpersonate,
	apElevate,
	apNext,
};

apEnum AcceptProduct(const ICHAR* szProductCode, bool fAdvertised, bool fMachine);
bool SafeForDangerousSourceActions(const ICHAR* szProductKey);
UINT MsiGetWindowsDirectory(LPTSTR lpBuffer, UINT cchBuffer);
DWORD MsiGetCurrentThreadId();

class EnumEntity
{
public:
	EnumEntity() : m_dwThreadId(0), m_uiKey(0), m_uiOffset(0), m_iPrevIndex(0) { m_szComponent[0] = '\0'; m_szwComponent[0] = L'\0';}

	unsigned int GetKey()        { return m_uiKey;       }
	unsigned int GetOffset()     { return m_uiOffset;    }
	unsigned int GetPrevIndex()  { return m_iPrevIndex;  }
	DWORD        GetThreadId()   { return m_dwThreadId;  }
	const char*  GetComponentA() { return m_szComponent; }
	const WCHAR* GetComponentW() { return m_szwComponent;}

	void SetKey(unsigned int uiKey)       { m_uiKey      = uiKey;      }
	void SetOffset(unsigned int uiOffset) { m_uiOffset   = uiOffset;   }
	void SetPrevIndex(int iPrevIndex)     { m_iPrevIndex = iPrevIndex; }
	void SetThreadId(DWORD dwThreadId)    { m_dwThreadId = dwThreadId; }
	void SetComponent(const char* szComponent)  { if (szComponent) StringCchCopyA(m_szComponent, ARRAY_ELEMENTS(m_szComponent),  szComponent); else m_szComponent[0] = 0; }
	void SetComponent(const WCHAR* szComponent) { if (szComponent) StringCchCopyW(m_szwComponent, ARRAY_ELEMENTS(m_szwComponent), szComponent); else m_szwComponent[0] = 0; }

protected:
	DWORD        m_dwThreadId;
	unsigned int m_uiKey;
	unsigned int m_uiOffset;
	int          m_iPrevIndex;
	char         m_szComponent[MAX_PATH]; // overloaded for use with assembly names
	WCHAR        m_szwComponent[MAX_PATH];// overloaded for use with assembly names
};

// for the following class we expect the Destroy() function to be called
class EnumEntityList
{
public:
	EnumEntityList() : m_cEntries(0), m_iLock(0)
#ifdef DEBUG
	, m_fDestroyed(false)
#endif
	{
	}
#ifdef DEBUG
	~EnumEntityList(){AssertSz(m_fDestroyed, "EnumEntityList::Destroy() not called");}
#endif
	unsigned int FindEntry();
	bool GetInfo(unsigned int& uiKey, unsigned int& uiOffset, int& iPrevIndex, const char** szComponent=0, const WCHAR** szwComponent=0);
	bool SetInfo(unsigned int uiKey, unsigned int uiOffset, int iPrevIndex, const char* szComponent, const WCHAR* szwComponent);
	bool SetInfo(unsigned int uiKey, unsigned int uiOffset, int iPrevIndex, const WCHAR* szComponent);
	void RemoveThreadInfo();
	void Destroy(){
		m_rgEnumList.Destroy();
#ifdef DEBUG
		m_fDestroyed = true;
#endif
	}

protected:
	CAPITempBuffer<EnumEntity, 1> m_rgEnumList;
	unsigned int m_cEntries;
	int m_iLock;
#ifdef DEBUG
	bool m_fDestroyed;
#endif
};

//______________________________________________________________________________
//
//  CMsiMessageBox - definition
//______________________________________________________________________________

class CMsiMessageBox
{
 public:
	CMsiMessageBox(const ICHAR* szText, const ICHAR* szCaption,
					int iBtnDef, int iBtnEsc, int idBtn1, int idBtn2, int idBtn3,
					UINT iCodepage, WORD iLangId);
   ~CMsiMessageBox();
	virtual bool InitSpecial();  // dialog-specific code called at end of initialization
	virtual BOOL HandleCommand(UINT idControl);  // WM_COMMAND handler
	int Execute(HWND hwnd, int idDlg, int idIcon);  // execute dialog with given dialog template

 protected:
	void SetControlText(int idControl, HFONT hfont, const ICHAR* szText);
	void InitializeDialog(); // called from dialog proc at WM_INITDIALOG
	int  SetButtonNames();   // returns number of buttons not found
	void AdjustButtons();    // rearranges buttons for 1 and 2 button cases, CMsiMessageBox only
	void SetMsgBoxSize();    // scales dialog to fit text, CMsiMessageBox only
	void CenterMsgBox();

	static INT_PTR CALLBACK MsgBoxDlgProc(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
	static LRESULT CALLBACK MBIconProc   (HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);

	HWND          m_hDlg;
	const ICHAR*  m_szCaption;
	const ICHAR*  m_szText;
	int           m_rgidBtn[3];
	UINT          m_cButtons;
	UINT          m_iBtnDef;  // 0 to use template, else button 1, 2, 3
	UINT          m_iBtnEsc;  // 0 to suppress, else button 1, 2, 3
	UINT          m_idIcon;   // icon to be enabled, 0 if none
	UINT          m_iCodepage;
	UINT          m_iLangId;
	HFONT         m_hfontButton;
	HFONT         m_hfontText;
	HWND          m_hwndFocus;
	bool          m_fMirrored;
};

unsigned int MsiGetCodepage(int iLangId);  // returns 0 (CP_ACP) if language unsupported
HFONT MsiCreateFont(UINT iCodepage);
void  MsiDestroyFont(HFONT& rhfont);
LANGID MsiGetDefaultUILangID();
unsigned int MsiGetSystemDataCodepage();  // codepage to best display file and registry data

inline unsigned int MsiGetSystemDataCodepage()
{
#ifdef UNICODE
	LANGID iLangId = MsiGetDefaultUILangID();
	if (PRIMARYLANGID(iLangId) != LANG_ENGLISH)
		return ::MsiGetCodepage(iLangId);
#endif
	return WIN::GetACP();
}

inline DWORD MSI_HRESULT_TO_WIN32(HRESULT hRes)
{
	if (hRes)
	{
		if (HRESULT_FACILITY(hRes) == FACILITY_WIN32)
			return HRESULT_CODE(hRes);
		else
			return ERROR_INSTALL_SERVICE_FAILURE;
	}
	else
	{
		return 0;
	}
}

//______________________________________________________________________________
//
//  MsiSwitchLanguage - helper function used to implement the language switching
//                      mechanism used in string resource lookup.
//______________________________________________________________________________

inline bool __stdcall MsiSwitchLanguage(int& iRetry, WORD& wLanguage)
{
	Assert(iRetry >=0);
	switch (iRetry++)
	{
		case 0:             break;    // first try requested language, if not 0
		case 1: wLanguage = (WORD)MsiGetDefaultUILangID(); break; // UI language (NT5) or user locale language
		case 2: wLanguage = (WORD)WIN::GetSystemDefaultLangID(); break;
		case 3: wLanguage = LANG_ENGLISH; break;   // base English (not US), should normally be present
		case 4: wLanguage = LANG_NEUTRAL; break;   // LoadString logic if all else fails, picks anything
		default: return false;  // resource not present
	}
	if (wLanguage == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SINGAPORE))   // this one language does not default to base language
		wLanguage  = MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED);

	return true;
}

inline DWORD MSI_WIN32_TO_HRESULT(DWORD dwError)
{
	return HRESULT_FROM_WIN32(dwError);
}

// classes used in engine.cpp and execute.cpp to enumerate, globally, component clients

// enum that defines the visibility that is desired for the component client enumeration
enum cetEnumType{
	cetAll, // all component clients
	cetVisibleToUser, // only those clients visible to this user (user assigned + machine assigned)
	cetAssignmentTypeUser, // only those clients assigned to this user
	cetAssignmentTypeMachine, // only those clients assigned to the machine
};


class CEnumUsers
{
public:
	CEnumUsers(cetEnumType cetArg); // constructor
	DWORD Next(const IMsiString*& ristrUserId); // enumeration fn
protected:
	CRegHandle m_hUserDataKey;
	int m_iUser;
	cetEnumType m_cetEnumType;
};

class CEnumComponentClients
{
public:
	CEnumComponentClients(const IMsiString& ristrUserId, const IMsiString& ristrComponent); // constructor
	DWORD Next(const IMsiString*& ristrProductKey); // enumeration fn
protected:
	CRegHandle m_hComponentKey;
	int m_iClient;
	MsiString m_strUserId;
	MsiString m_strComponent;
};

class CClientThreadImpersonate
{
public:
	CClientThreadImpersonate(const DWORD dwThreadID);
	~CClientThreadImpersonate();
private:
	bool m_fImpersonated;
};

// struct to save off product code and context mapping
struct sProductContext{
	ICHAR rgchProductSQUID[cchProductCodePacked+1];
	iaaAppAssignment iaaContext;
};

// class to wrap product context caching logic
// ensures atomic read/ write to product context cache when determining product context
// product context caching only done in service for installation session threads
class CProductContextCache{
public:
	CProductContextCache(const ICHAR* szProductSQUID)
	{
		Assert(szProductSQUID);
		StringCbCopy(m_rgchProductSQUID, sizeof(m_rgchProductSQUID), szProductSQUID);
		m_fUseCache = (g_scServerContext == scService && IsThreadSafeForSessionImpersonation()); // use product context caching only in service for installation session threads
		if(m_fUseCache)
		{
			Assert(g_fInitialized);
			WIN::EnterCriticalSection(&g_csCacheCriticalSection);		
		}
	}
	~CProductContextCache()
	{
		if(m_fUseCache)
			WIN::LeaveCriticalSection(&g_csCacheCriticalSection);
	}
	bool  GetProductContext(iaaAppAssignment& riaaContext)
	{
		riaaContext = (iaaAppAssignment)-1; // set default
		if(m_fUseCache)
		{
			for(int cIndex  = 0; cIndex < g_cProductCacheCount; cIndex++)
			{
				if(!IStrComp(m_rgchProductSQUID, g_rgProductContext[cIndex].rgchProductSQUID))
				{
					riaaContext = g_rgProductContext[cIndex].iaaContext;
					DEBUGMSGLX2(TEXT("Using cached product context: %s for product: %s"), riaaContext == iaaUserAssign ? TEXT("User assigned"): riaaContext == iaaUserAssignNonManaged ? TEXT("User non-assigned") : TEXT("machine assigned"), m_rgchProductSQUID);
					return true;
				}
			}
		}
		return false;
	}
	bool SetProductContext(iaaAppAssignment iaaContext)
	{
		if(m_fUseCache)
		{
			if(g_cProductCacheCount == g_rgProductContext.GetSize())
			{
				g_rgProductContext.Resize(g_rgProductContext.GetSize() + 20);
			}
			// caller ensures that product is not duplicated in the list by co-ordinating with the GetProductContext
			StringCbCopy(g_rgProductContext[g_cProductCacheCount].rgchProductSQUID, sizeof(g_rgProductContext[g_cProductCacheCount].rgchProductSQUID), m_rgchProductSQUID);
			g_rgProductContext[g_cProductCacheCount].iaaContext = iaaContext;
			g_cProductCacheCount++;
			DEBUGMSGLX2(TEXT("Setting cached product context: %s for product: %s"), iaaContext == iaaUserAssign ? TEXT("User assigned"): iaaContext == iaaUserAssignNonManaged ? TEXT("User non-assigned") : TEXT("machine assigned"), m_rgchProductSQUID);
			return true;
		}
		else
			return false;
	}

	// static fns to initialize and reset the global state for the CProductContextCache
	// DONT call these except in CMsiUIMessageContext::Initialize and CMsiUIMessageContext::Terminate
	static void Initialize()
	{
		// reset product context cache before every installation session
		Assert(g_scServerContext == scService && IsThreadSafeForSessionImpersonation());
		WIN::InitializeCriticalSection(&g_csCacheCriticalSection);
		g_rgProductContext.Destroy();
		g_cProductCacheCount = 0;
#ifdef DEBUG
		g_fInitialized = true;
#endif
	}
	
	static void Reset()
	{
		// reset product context cache after every installation session
		Assert(g_scServerContext == scService && IsThreadSafeForSessionImpersonation());
		WIN::DeleteCriticalSection(&g_csCacheCriticalSection);
		g_rgProductContext.Destroy();
		g_cProductCacheCount = 0;
#ifdef DEBUG
		g_fInitialized = false;
#endif

	}	
	static CRITICAL_SECTION g_csCacheCriticalSection;
	static CAPITempBuffer<sProductContext ,20> g_rgProductContext;
	static int g_cProductCacheCount;
#ifdef DEBUG
	static bool g_fInitialized;
#endif
private:
	bool m_fUseCache;
	ICHAR m_rgchProductSQUID[cchProductCodePacked+1];
};


//____________________________________________________________________________
//
// IMsiCustomActionLocalConfig - additional functions only callable from the
// local process
//____________________________________________________________________________


class IMsiCustomActionLocalConfig : public IMsiCustomAction
{
public:

	virtual HRESULT __stdcall SetRemoteAPI(IMsiRemoteAPI* piRemoteAPI) =0;
	virtual HRESULT __stdcall SetCookie(icacCustomActionContext* icacContext, const unsigned char *rgchCookie) =0;
	virtual HRESULT __stdcall SetClientInfo(DWORD dwClientProcess, bool fClientOwned, DWORD dwPrivileges, HANDLE hToken) =0;
	virtual HRESULT __stdcall SetShutdownEvent(HANDLE hEvent) =0;
};

//____________________________________________________________________________
//
// CMsiCustomAction: custom action context when running in the custom action
// server.
//____________________________________________________________________________

class CustomActionData;

class CMsiCustomAction : public IMsiCustomActionLocalConfig
{
 public:
	HRESULT         __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long   __stdcall AddRef();
	unsigned long   __stdcall Release();

	HRESULT         __stdcall PrepareDLLCustomAction(const ICHAR* szActionName, const ICHAR* szPath, const ICHAR* szEntryPoint, MSIHANDLE hInstall, boolean fDebugBreak, 
		boolean fAppCompat, const GUID* pguidAppCompatDB, const GUID* pguidAppCompatID, DWORD* pdwThreadId);
	HRESULT         __stdcall RunDLLCustomAction(DWORD dwThreadId, unsigned long* pulRet);
	HRESULT         __stdcall FinishDLLCustomAction(DWORD dwThreadId);

	HRESULT         __stdcall RunScriptAction(int icaType, IDispatch* piDispatch, const ICHAR* szSource, const ICHAR *szTarget, LANGID iLangId, int* iScriptResult, int *pcb, char **pchRecord);

	HRESULT         __stdcall SetRemoteAPI(IMsiRemoteAPI *piRemoteAPI);
	HRESULT         __stdcall SetCookie(icacCustomActionContext* icacContext, const unsigned char *rgchCookie);
	HRESULT         __stdcall SetClientInfo(DWORD dwClientProcess, bool fClientOwned, DWORD dwPrivileges, HANDLE hToken);
	HRESULT         __stdcall SetShutdownEvent(HANDLE hEvent);

	HRESULT         __stdcall QueryPathOfRegTypeLib(REFGUID guid, unsigned short wVerMajor, unsigned short wVerMinor,
												LCID lcid, OLECHAR *lpszPathName, int cchPath);
	HRESULT         __stdcall ProcessTypeLibrary(const OLECHAR* szLibID, LCID lcidLocale, 
												const OLECHAR* szTypeLib, const OLECHAR* szHelpPath, 
												int fRemove, int *fInfoMismatch);
	HRESULT         __stdcall SQLInstallDriverEx(int cDrvLen, const ICHAR* szDriver,
												const ICHAR* szPathIn, ICHAR* szPathOut,
												WORD cbPathOutMax, WORD* pcbPathOut,
												WORD fRequest, DWORD* pdwUsageCount);
	HRESULT         __stdcall SQLConfigDriver(WORD fRequest,
												const ICHAR* szDriver, const ICHAR* szArgs,
												ICHAR* szMsg, WORD cbMsgMax, WORD* pcbMsgOut);
	HRESULT         __stdcall SQLRemoveDriver(const ICHAR* szDriver, int fRemoveDSN,
												DWORD* pdwUsageCount);
	HRESULT         __stdcall SQLInstallTranslatorEx(int cTransLen, const ICHAR* szTranslator,
												const ICHAR* szPathIn, ICHAR* szPathOut,
												WORD cbPathOutMax, WORD* pcbPathOut,
												WORD fRequest, DWORD* pdwUsageCount);
	HRESULT         __stdcall SQLRemoveTranslator(const ICHAR* szTranslator,
												DWORD* pdwUsageCount);
	HRESULT         __stdcall SQLConfigDataSource(WORD fRequest,
												const ICHAR* szDriver, const ICHAR* szAttributes,
												DWORD /*cbAttrSize*/);
	HRESULT         __stdcall SQLInstallDriverManager(ICHAR* szPath, WORD cbPathMax,
												WORD* pcbPathOut);
	HRESULT         __stdcall SQLRemoveDriverManager(DWORD* pdwUsageCount);
	HRESULT         __stdcall SQLInstallerError(WORD iError, DWORD* pfErrorCode,
												ICHAR* szErrorMsg, WORD cbErrorMsgMax, WORD* pcbErrorMsg);

 public:
	// constructor
	void *operator new(size_t cb) { return AllocSpc(cb); }
	void operator delete(void * pv) { FreeSpc(pv); }
	CMsiCustomAction();

	icacCustomActionContext GetServerContext() const { return m_icacContext; };
	HANDLE GetImpersonationToken() const { return m_hImpersonationToken; };

	// the following are the CA server versions of the RemoteAPI calls. They are
	// responsible for passing across any extra information needed in the call, such
	// as process context, thread id, and cookie.
#define ServerAPICall0(_NAME_ ) \
	inline HRESULT _NAME_() \
	{ \
		PMsiRemoteAPI pAPI = GetAPI(); \
		if (!pAPI) \
			return ERROR_INSTALL_SERVICE_FAILURE; \
		return MSI_HRESULT_TO_WIN32(pAPI->_NAME_(m_icacContext, GetCurrentThreadId(), m_rgchRemoteCookie, iRemoteAPICookieSize)); \
	}
#define ServerAPICall1(_NAME_, _1T_, _1_) \
	inline HRESULT _NAME_(_1T_ _1_) \
	{ \
		PMsiRemoteAPI pAPI = GetAPI(); \
		if (!pAPI) \
			return ERROR_INSTALL_SERVICE_FAILURE; \
		return MSI_HRESULT_TO_WIN32(pAPI->_NAME_(m_icacContext, GetCurrentThreadId(), m_rgchRemoteCookie, iRemoteAPICookieSize, _1_)); \
	}
#define ServerAPICall2(_NAME_, _1T_, _1_, _2T_, _2_) \
	inline HRESULT _NAME_(_1T_ _1_, _2T_ _2_) \
	{ \
		PMsiRemoteAPI pAPI = GetAPI(); \
		if (!pAPI) \
			return ERROR_INSTALL_SERVICE_FAILURE; \
		return MSI_HRESULT_TO_WIN32(pAPI->_NAME_(m_icacContext, GetCurrentThreadId(), m_rgchRemoteCookie, iRemoteAPICookieSize, _1_, _2_)); \
	}
#define ServerAPICall3(_NAME_, _1T_, _1_, _2T_, _2_, _3T_, _3_) \
	inline HRESULT _NAME_(_1T_ _1_, _2T_ _2_, _3T_ _3_) \
	{ \
		PMsiRemoteAPI pAPI = GetAPI(); \
		if (!pAPI) \
			return ERROR_INSTALL_SERVICE_FAILURE; \
		return MSI_HRESULT_TO_WIN32(pAPI->_NAME_(m_icacContext, GetCurrentThreadId(), m_rgchRemoteCookie, iRemoteAPICookieSize, _1_,_2_,_3_)); \
	}
#define ServerAPICall4(_NAME_, _1T_, _1_, _2T_, _2_, _3T_, _3_, _4T_, _4_) \
	inline HRESULT _NAME_(_1T_ _1_, _2T_ _2_, _3T_ _3_, _4T_ _4_) \
	{ \
		PMsiRemoteAPI pAPI = GetAPI(); \
		if (!pAPI) \
			return ERROR_INSTALL_SERVICE_FAILURE; \
		return MSI_HRESULT_TO_WIN32(pAPI->_NAME_(m_icacContext, GetCurrentThreadId(), m_rgchRemoteCookie, iRemoteAPICookieSize, _1_,_2_,_3_,_4_)); \
	}
#define ServerAPICall5(_NAME_, _1T_, _1_, _2T_, _2_, _3T_, _3_, _4T_, _4_, _5T_, _5_ ) \
	inline HRESULT _NAME_(_1T_ _1_, _2T_ _2_, _3T_ _3_, _4T_ _4_, _5T_ _5_) \
	{ \
		PMsiRemoteAPI pAPI = GetAPI(); \
		if (!pAPI) \
			return ERROR_INSTALL_SERVICE_FAILURE; \
		return MSI_HRESULT_TO_WIN32(pAPI->_NAME_(m_icacContext, GetCurrentThreadId(), m_rgchRemoteCookie, iRemoteAPICookieSize, _1_,_2_,_3_,_4_,_5_)); \
	}
#define ServerAPICall6(_NAME_, _1T_, _1_, _2T_, _2_, _3T_, _3_, _4T_, _4_, _5T_, _5_, _6T, _6_) \
	inline HRESULT _NAME_(_1T_ _1_, _2T_ _2_, _3T_ _3_, _4T_ _4_, _5T_ _5_, _6T _6_) \
	{ \
		PMsiRemoteAPI pAPI = GetAPI(); \
		if (!pAPI) \
			return ERROR_INSTALL_SERVICE_FAILURE; \
		return MSI_HRESULT_TO_WIN32(pAPI->_NAME_(m_icacContext, GetCurrentThreadId(), m_rgchRemoteCookie, iRemoteAPICookieSize, _1_,_2_,_3_,_4_,_5_,_6_)); \
	}
#define ServerAPICall7(_NAME_, _1T_, _1_, _2T_, _2_, _3T_, _3_, _4T_, _4_, _5T_, _5_, _6T, _6_, _7T_, _7_) \
	inline HRESULT _NAME_(_1T_ _1_, _2T_ _2_, _3T_ _3_, _4T_ _4_, _5T_ _5_, _6T _6_, _7T_ _7_) \
	{ \
		PMsiRemoteAPI pAPI = GetAPI(); \
		if (!pAPI) \
			return ERROR_INSTALL_SERVICE_FAILURE; \
		return MSI_HRESULT_TO_WIN32(pAPI->_NAME_(m_icacContext, GetCurrentThreadId(), m_rgchRemoteCookie, iRemoteAPICookieSize, _1_,_2_,_3_,_4_,_5_,_6_,_7_)); \
	}
#define ServerAPICall8(_NAME_, _1T_, _1_, _2T_, _2_, _3T_, _3_, _4T_, _4_, _5T_, _5_, _6T, _6_, _7T_, _7_, _8T_, _8_) \
	inline HRESULT _NAME_(_1T_ _1_, _2T_ _2_, _3T_ _3_, _4T_ _4_, _5T_ _5_, _6T _6_, _7T_ _7_, _8T_ _8_) \
	{ \
		PMsiRemoteAPI pAPI = GetAPI(); \
		if (!pAPI) \
			return ERROR_INSTALL_SERVICE_FAILURE; \
		return MSI_HRESULT_TO_WIN32(pAPI->_NAME_(m_icacContext, GetCurrentThreadId(), m_rgchRemoteCookie, iRemoteAPICookieSize, _1_,_2_,_3_,_4_,_5_,_6_,_7_,_8_)); \
	}
#define ServerAPICall9(_NAME_, _1T_, _1_, _2T_, _2_, _3T_, _3_, _4T_, _4_, _5T_, _5_, _6T, _6_, _7T_, _7_, _8T_, _8_, _9T_, _9_) \
	inline HRESULT _NAME_(_1T_ _1_, _2T_ _2_, _3T_ _3_, _4T_ _4_, _5T_ _5_, _6T _6_, _7T_ _7_, _8T_ _8_, _9T_ _9_) \
	{ \
		PMsiRemoteAPI pAPI = GetAPI(); \
		if (!pAPI) \
			return ERROR_INSTALL_SERVICE_FAILURE; \
		return MSI_HRESULT_TO_WIN32(pAPI->_NAME_(m_icacContext, GetCurrentThreadId(), m_rgchRemoteCookie, iRemoteAPICookieSize, _1_,_2_,_3_,_4_,_5_,_6_,_7_,_8_,_9_)); \
	}

	ServerAPICall5( GetProperty, unsigned long,hInstall, const ICHAR*,szName, ICHAR*,szValue, unsigned long,cchValue, unsigned long*,pcchValueRes);
	ServerAPICall2( CreateRecord, unsigned int,cParams, unsigned long*,pHandle);
	ServerAPICall0( CloseAllHandles);
	ServerAPICall1( CloseHandle, unsigned long,hAny);
	ServerAPICall3( DatabaseOpenView,unsigned long, hDatabase, const ichar*,szQuery, unsigned long*,phView);
	ServerAPICall5( ViewGetError,unsigned long,hView, ichar*,szColumnNameBuffer, unsigned long,cchBuf, unsigned long*,pcchBufRes, int*,pMsidbError);
	ServerAPICall2( ViewExecute,unsigned long,hView, unsigned long,hRecord);
	ServerAPICall2( ViewFetch,unsigned long,hView, unsigned long*,phRecord);
	ServerAPICall3( ViewModify,unsigned long,hView, long,eUpdateMode, unsigned long,hRecord);
	ServerAPICall1( ViewClose,unsigned long,hView);
	ServerAPICall3( OpenDatabase,const ichar*,szDatabasePath, const ichar*,szPersist, unsigned long*, phDatabase);
	ServerAPICall1( DatabaseCommit, unsigned long,hDatabase);
	ServerAPICall3( DatabaseGetPrimaryKeys, unsigned long,hDatabase, const ichar*,szTableName, unsigned long *,phRecord);
	ServerAPICall3( RecordIsNull,unsigned long,hRecord, unsigned int,iField, boolean *,pfIsNull);
	ServerAPICall3( RecordDataSize,unsigned long,hRecord, unsigned int,iField, unsigned int*,puiSize);
	ServerAPICall3( RecordSetInteger,unsigned long,hRecord, unsigned int,iField, int,iValue);
	ServerAPICall3( RecordSetString,unsigned long,hRecord,  unsigned int,iField, const ichar*,szValue);
	ServerAPICall3( RecordGetInteger,unsigned long,hRecord, unsigned int,iField, int*,piValue);
	ServerAPICall5( RecordGetString,unsigned long,hRecord, unsigned int,iField, ichar*,szValueBuf, unsigned long,cchValueBuf, unsigned long*,pcchValueRes);
	ServerAPICall2( RecordGetFieldCount,unsigned long,hRecord,unsigned int*,piCount);
	ServerAPICall3( RecordSetStream,unsigned long,hRecord, unsigned int,iField, const ichar*,szFilePath);
	ServerAPICall5( RecordReadStream,unsigned long,hRecord, unsigned int,iField, boolean,fBufferIsNull, char*,szDataBuf, unsigned long*,pcbDataBuf);
	ServerAPICall1( RecordClearData,unsigned long,hRecord);
	ServerAPICall4( GetSummaryInformation,unsigned long,hDatabase, const ichar*,szDatabasePath, unsigned int,uiUpdateCount, unsigned long*,phSummaryInfo);
	ServerAPICall2( SummaryInfoGetPropertyCount,unsigned long,hSummaryInfo, unsigned int*,puiPropertyCount);
	ServerAPICall6( SummaryInfoSetProperty,unsigned long,hSummaryInfo,unsigned int,uiProperty, unsigned int,uiDataType, int,iValue,FILETIME *,pftValue, const ichar*,szValue);
	ServerAPICall8( SummaryInfoGetProperty,unsigned long,hSummaryInfo,unsigned int,uiProperty,unsigned int*,puiDataType, int*,piValue, FILETIME *,pftValue, ichar*,szValueBuf, unsigned long,cchValueBuf, unsigned long *,pcchValueBufRes);
	ServerAPICall1( SummaryInfoPersist,unsigned long,hSummaryInfo);
	ServerAPICall2( GetActiveDatabase,unsigned long,hInstall,unsigned long*,phDatabase);
	ServerAPICall3( SetProperty,unsigned long,hInstall, const ichar*,szName, const ichar*,szValue);
	ServerAPICall2( GetLanguage,unsigned long,hInstall, unsigned short*,pLangId);
	ServerAPICall3( GetMode,unsigned long,hInstall, long,eRunMode, boolean*,pfSet);
	ServerAPICall3( SetMode,unsigned long,hInstall, long,eRunMode, boolean,fState);
	ServerAPICall5( FormatRecord,unsigned long,hInstall, unsigned long,hRecord, ichar*,szResultBuf,unsigned long,cchBuf,unsigned long*,pcchBufRes);
	ServerAPICall2( DoAction,unsigned long,hInstall, const ichar*,szAction);
	ServerAPICall3( Sequence,unsigned long,hInstall, const ichar*,szTable, int,iSequenceMode);
	ServerAPICall4( ProcessMessage,unsigned long,hInstall, long,eMessageType, unsigned long,hRecord, int*,piRes);
	ServerAPICall3( EvaluateCondition,unsigned long,hInstall, const ichar*,szCondition, int*,piCondition);
	ServerAPICall4( GetFeatureState,unsigned long,hInstall, const ichar*,szFeature, long*,piInstalled, long*,piAction);
	ServerAPICall3( SetFeatureState,unsigned long,hInstall, const ichar*,szFeature, long,iState);
	ServerAPICall4( GetComponentState,unsigned long,hInstall, const ichar*,szComponent, long*,piInstalled, long*,piAction);
	ServerAPICall3( SetComponentState,unsigned long,hInstall, const ichar*,szComponent, long,iState);
	ServerAPICall5( GetFeatureCost,unsigned long,hInstall, const ichar*,szFeature, int,iCostTree, long,iState, int *,piCost);
	ServerAPICall2( SetInstallLevel,unsigned long,hInstall, int,iInstallLevel);
	ServerAPICall3( GetFeatureValidStates,unsigned long,hInstall, const ichar*,szFeature,unsigned long*,dwInstallStates);
	ServerAPICall3( DatabaseIsTablePersistent,unsigned long,hDatabase, const ichar*,szTableName, int*,piCondition);
	ServerAPICall3( ViewGetColumnInfo,unsigned long,hView, long,eColumnInfo,unsigned long*,phRecord);
	ServerAPICall1( GetLastErrorRecord,unsigned long*,phRecord);
	ServerAPICall5( GetSourcePath,unsigned long,hInstall, const ichar*,szFolder, ichar*,szPathBuf, unsigned long,cchPathBuf, unsigned long *,pcchPathBufRes);
	ServerAPICall5( GetTargetPath,unsigned long,hInstall, const ichar*,szFolder, ichar*,szPathBuf, unsigned long,cchPathBuf, unsigned long *,pcchPathBufRes);
	ServerAPICall3( SetTargetPath,unsigned long,hInstall, const ichar*,szFolder, const ichar*,szFolderPath);
	ServerAPICall1( VerifyDiskSpace,unsigned long,hInstall);
	ServerAPICall3( SetFeatureAttributes, unsigned long,hInstall, const ichar*,szFeature, long,iAttributes);
	ServerAPICall9( EnumComponentCosts, unsigned long,hInstall, const ichar*,szComponent, unsigned long,iIndex, long,iState, ichar*,szDrive, unsigned long,cchDrive, unsigned long*,pcchDriveSize, int*,piCost, int*,piTempCost);
	ServerAPICall1( GetInstallerObject, IDispatch**,piInstall);

#undef ServerAPICall0
#undef ServerAPICall1
#undef ServerAPICall2
#undef ServerAPICall3
#undef ServerAPICall4
#undef ServerAPICall5
#undef ServerAPICall6
#undef ServerAPICall7
#undef ServerAPICall8
#undef ServerAPICall9
public:
	bool             m_fValid;
protected:
	~CMsiCustomAction();  // protected to prevent creation on stack
private:
	long             m_iRefCnt;
	bool             m_fPostQuitMessage;
	DWORD            m_dwMainThreadId;
	unsigned char    m_rgchRemoteCookie[iRemoteAPICookieSize];
	CRITICAL_SECTION m_csGetInterface;
	HANDLE           m_hEvtReady;
	IGlobalInterfaceTable* m_piGIT;
	DWORD            m_dwGITCookie;
	icacCustomActionContext m_icacContext;
	bool             m_fClientOwned;
	DWORD            m_dwClientProcess;

	HANDLE           m_hShutdownEvent;
	HANDLE           m_hImpersonationToken;

	struct ActionThreadData
	{
		DWORD dwThread;
		HANDLE hThread;
	};
	CRITICAL_SECTION m_csActionList;
	CAPITempBuffer<ActionThreadData ,4> m_rgActionList;
	IMsiRemoteAPI*   GetAPI();

	static DWORD WINAPI CustomActionThread(CustomActionData *pData);
};

class CRFSCachedSourceInfo
{
private:
	mutable int  m_iBusyLock;
	bool         m_fValid;

	unsigned int m_uiDiskID;
	CAPITempBuffer<ICHAR, 1> m_rgchValidatedSource;
	ICHAR m_rgchValidatedProductSQUID[cchProductCodePacked+1];
	
public:
	bool SetCachedSource(const ICHAR *szProductSQUID, int uiDiskID, const ICHAR* const szSource);
	bool RetrieveCachedSource(const ICHAR* szProductSQID, int uiDiskID, CAPITempBufferRef<ICHAR>& rgchPath) const;

	CRFSCachedSourceInfo() : m_fValid(false), m_uiDiskID(0), m_iBusyLock(0) {}
	void Destroy() { m_rgchValidatedSource.Destroy(); }
};

// the non-static version contains a destructor for use on the stack (or in dynamic allocation)
class CRFSCachedSourceInfoNonStatic
{
private:
	 CRFSCachedSourceInfo m_Info;
public:
	CRFSCachedSourceInfoNonStatic() {};
	~CRFSCachedSourceInfoNonStatic() { m_Info.Destroy(); };
	operator CRFSCachedSourceInfo&() { return m_Info; };
};

#endif // __MSIUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\_srcmgmt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       _srcmgmt.h
//
//--------------------------------------------------------------------------

#ifndef __SRCMGMT_H
#define __SRCMGMT_H

#include "_msiutil.h"

enum isfEnum // SourceFormat
{
	isfFullPath,
	isfFullPathWithFile,
	isfNet,
	isfURL,
	isfMedia,
	isfNext,
};

enum isptEnum // SourcePackageType
{
	istInstallPackage,
	istTransform, 
	istPatch,
	istNextEnum,
};

enum isroEnum // bits: Source Resolution Order
{
	isroNetwork = 0x1,
	isroMedia   = 0x2,
	isroURL     = 0x4,
	isroNext    = 0x8,
};

enum psfEnum // bits: Process Source flags 
{
	psfProcessRawLastUsed     = 1<<0,  // process the raw LastUsed source (i.e. the full path)
	psfConnectToSources       = 1<<1,  // attempt connection by creating a path object
	psfProcessMultipleFormats = 1<<2,  // process both UNC and drive-letter sources
	psfReplaceIData           = 1<<3,
	psfOnlyProcessLastUsed    = 1<<4,  // only process last used sources; skip the source lists

	// the following flags should not be passed to ProcessSources. They're to be passed to ProcessGenericSourceList.
	psfRejectInvalidPolicy    = 1<<5,  // explicitly reject sources that don't conform to policy

	psfNext                   = 1<<6,
	
};

enum ivpEnum // bits: Volume Preference
{
	ivpDriveLetter = 0x1,
	ivpUNC         = 0x2,
	ivpNext        = 0x4,
};

enum psEnum // ProcessSource
{
	psStop           = 0x00000001,
	psValidSource    = psStop,
	psContinue       = 0x80000000,
	psFileNotFound   = 0x80000001,
	psInvalidProduct = 0x80000002,
	psCSOS			 = 0x80000003
};

enum insEnum // normalize source
{
	insMoreSources,
	insNoMoreSources,
};

enum imdEnum // media disable policy values 
{
	imdAlwaysDisable,
	imdAlwaysEnable,
	imdOnlyIfSafe,
};

enum icscEnum // Client Side Caching status
{
	cscNoCaching,
	cscConnected, 
	cscDisconnected,
};

const ICHAR chMediaSource = 'm';
const ICHAR chURLSource   = 'u';
const ICHAR chNetSource   = 'n';

typedef psEnum (*PfnProcessSource)(IMsiServices* piServices, const ICHAR* szDisplay, const ICHAR* szPackageFullPath, isfEnum isfSourceFormat, int iSourceIndex, INT_PTR iUserData, bool fAllowDisconnectedCSCSource, bool fValidatePackageCOde, isptEnum isptSourcePackageType);	//--merced: changed int to INT_PTR

class CMsiSourceList
{
public:
	// -- Constructor and destructor --
	CMsiSourceList();
	virtual ~CMsiSourceList();

	// -- Initalization functions --
	UINT OpenSourceList(bool fVerifyOnly, bool fMachine, const ICHAR *szProductCode, const ICHAR *szUserName);

	// -- read-only actions --
	bool GetLastUsedType(isfEnum &isf);

	// -- write actions --
	UINT ClearLastUsed();
	UINT ClearListByType(isrcEnum isrcType) { return CMsiSourceList::ClearListByType(MapIsrcToIsf(isrcType)); };
	UINT ClearListByType(isfEnum isfType);
	UINT AddSource(isrcEnum isrcType, const ICHAR* szSource) { return CMsiSourceList::AddSource(MapIsrcToIsf(isrcType), szSource); };
	UINT AddSource(isfEnum isf, const ICHAR* szSource);
	
private:
	isfEnum MapIsrcToIsf(isrcEnum isrcSource);
	bool NonAdminAllowedToModifyByPolicy(bool bElevated);

	CRegHandle m_hProductKey;
	PMsiRegKey m_pSourceListKey;

	bool m_fCurrentUsersProduct;        // true if modifying the current users per-user install
	bool m_fAllowedToModify;            // true if policy/app elevation allows (or would allow) user to modify list
	bool m_fReadOnly;                   // true if object is read only 
	IMsiServices *m_piServices;
};

DWORD SourceListClearByType(const ICHAR *szProductCode, const ICHAR* szUser, isrcEnum isrcSource);
DWORD SourceListAddSource(const ICHAR *szProductCode, const ICHAR* szUserName, isrcEnum isrcSource, const ICHAR* szSource);
DWORD SourceListClearLastUsed(const ICHAR *szProductCode, const ICHAR* szUserName);

class CResolveSource
{
public:
	CResolveSource(IMsiServices* piServices, bool fPackageRecache);
	virtual ~CResolveSource();
	IMsiRecord* ResolveSource(const ICHAR* szProduct, Bool fPatch, unsigned int uiDisk, const IMsiString*& rpiSource, const IMsiString*& rpiSourceProduct, Bool fSetLastUsedSource, HWND hWnd, bool fAllowDisconnectedCSCSource);
protected:
	IMsiRecord* ProcessGenericSourceList(
									IMsiRegKey* piSourceListKey,      // list to process
									const IMsiString*& rpiSource,     // on success, the last valid source found
									const ICHAR* szPackageName,       // the package name we're looking for
									unsigned int uiRequestedDisk,     // the disk we need; 0 if any disk will do
									isfEnum isfSourceFormat,          // URL, etc.
									PfnProcessSource pfnProcessSource, 
									INT_PTR iData,						//--merced: changed int to INT_PTR
									psfEnum psfFlags,
									bool fSkipLastUsedSource,
                                    bool fOnlyCheckSpecifiedIndex,
									Bool& fSourceListEmpty);           // on success, TRUE if the source list is empty

	IMsiRecord* ProcessSources(IMsiRecord& riProducts, Bool fPatch, const IMsiString*& rpiSource, 
							 const IMsiString*& rpiPackageName,
							 const IMsiString*& rpiSourceProduct,
							 unsigned int uiDisk,
							 PfnProcessSource pfnProcessSource, INT_PTR iData,		//--merced: changed int to INT_PTR
							 Bool &fOnlyMediaSources,
							 psfEnum psfFlags);

	static psEnum ValidateSource(IMsiServices* piServices, const ICHAR* szDisplay, const ICHAR* szPackageFullPath, isfEnum isfSourceFormat, int iSourceIndex, INT_PTR iUserData, bool fAllowDisconnectedCSCSource, bool fValidatePackageCode, isptEnum isptSourcePackageType);		//--merced: changed int to INT_PTR
	bool ConnectToSource(const ICHAR* szUnnormalizedSource, IMsiPath*& rpiPath, const IMsiString*& rpiNormalizedSource, isfEnum isfSourceFormat);
	bool ConnectToMediaSource(const ICHAR* szSource, unsigned int uiDisk, const IMsiString& riRelativePath, CTempBufferRef<IMsiPath*>& rgMediaPaths, int& cMediaPaths);
	IMsiRecord* ProcessLastUsedSource(IMsiRegKey& riSourceListKey, const ICHAR* szPackageName, const IMsiString*& rpiSource, PfnProcessSource pfnProcessSource, INT_PTR iData);		//--merced: changed int to INT_PTR
	IMsiRecord* InitializeProduct(const ICHAR* szProduct, Bool fPatch, const IMsiString*& rpiPackageName);
	IMsiRecord* GetProductsToSearch(const IMsiString& riClient, IMsiRecord*& rpiRecord, Bool fPatch);
	void AddToRecord(IMsiRecord*& rpiRecord, const IMsiString& riString);
	void CResolveSource::ClearObjectCache();

protected:
	Bool m_fSetLastUsedSource;
	imdEnum m_imdMediaDisabled;
	bool m_fMediaDisabled;
	bool m_fIgnoreLastUsedSource;
	IMsiServices* m_piServices;
	Bool m_fLoadedServices;
	PMsiRegKey m_pSourceListKey;
	CRegHandle m_HSourceListKey;
	CAPITempBuffer<ICHAR, 4> m_rgchSearchOrder;
	MsiString m_strLastUsedSourceIndex;
	isfEnum m_isfLastUsedSourceFormat;
	MsiString m_strDiskPromptTemplate;
	ICHAR m_szProduct[cchProductCode+1];
	bool m_fAllowDisconnectedCSCSource;
	isptEnum m_isptSourcePackageType;
	bool m_fValidatePackageCode;
	UINT m_uiMinimumDiskId;
	bool m_fCSOS;
};

class CResolveSourceUI : public CMsiMessageBox,  public CResolveSource
{
public:
	CResolveSourceUI(IMsiServices* piServices, const ICHAR* szUseFeature, UINT iCodepage, LANGID iLangId);
	~CResolveSourceUI();
	Bool ResolveSource(const ICHAR* szProduct, isptEnum istSourceType, bool fNewSourceAllowed, const ICHAR* szPackageName, const IMsiString*& rpiSource, Bool fSetLastUsedSource, UINT uiRequestedDisk, bool fAllowDisconnectedCSCSource, bool fValidatePackageCode, bool fCSOS);
protected: // methods
	void PopulateDropDownWithSources();
	void Browse();
	static psEnum AddSourceToList(IMsiServices* piServices, const ICHAR* szDisplay, const ICHAR* szPackageFullPath, isfEnum isfSourceFormat, int iSourceIndex, INT_PTR iUserData, bool fAllowDisconnectedCSCSource, bool fValidatePackageCode, isptEnum isptSourcePackageType);		//--merced: changed int to INT_PTR
protected: // overridden virtual methods from CMsiMessageBox
 	bool InitSpecial();
	BOOL HandleCommand(UINT idControl);
protected: // data
	bool m_fNewSourceAllowed;
	const ICHAR* m_szPackage;
	const ICHAR* m_szPackageName;
	const ICHAR* m_szProduct;
	const ICHAR* m_szDiskPromptTemplate;
	int m_iListControlId;
	MsiString m_strPath;
	HFONT m_hFont;
	Bool m_fOnlyMediaSources;
	LANGID m_iLangId;
	UINT m_uiRequestedDisk;
};

Bool ConstructNetSourceListEntry(IMsiPath& riPath, const IMsiString*& rpiDriveLetter, const IMsiString*& rpiUNC,
											const IMsiString*& rpiRelativePath);

IMsiRecord* ResolveSource(IMsiServices* piServices, const ICHAR* szProduct, unsigned int uiDisk, const IMsiString*& rpiSource, const IMsiString*& rpiProduct, Bool fSetLastUsedSource, HWND hWnd, bool fPatch=false);
Bool LastUsedSourceIsMedia(IMsiServices& riServices, const ICHAR* szProduct);
bool GetLastUsedSourceType(IMsiServices& riServices, const ICHAR* szProduct, isfEnum &isf);
Bool MapSourceCharToIsf(const ICHAR chSourceType, isfEnum& isf);
IMsiRecord* SetLastUsedSource(const ICHAR* szProductCode, const ICHAR* szPath, Bool fAddToList, bool fPatch);
const IMsiString& GetDiskLabel(IMsiServices& riServices, unsigned int uiDiskId, const ICHAR* szProduct);
imsEnum PromptUserForSource(IMsiRecord& riInfo); 
icscEnum CheckShareCSCStatus(isfEnum isf, const ICHAR *szLastUsedSource);
#endif //__SRCMGMT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\_service.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       _service.h
//
//--------------------------------------------------------------------------

/* _services.h - private header for service implementation
____________________________________________________________________________*/

#include "database.h"
#include "services.h"
#include "_assert.h"
#include "_diagnos.h"

#define SRV // namespace for private globals in this module, for readablility only

// global string objects exposed without implementation
// dummy implementation of IMsiString to allow external global string object refs

// NOTE: implementation required to get around compiler bug that won't allow
// externs to global string object refs.  This is a purely virtual class that mimics
// the CMsiStringBase: public IMsiString declaration.  Additionally, for support on Win64,
// must also include the same data members because on IA64, global variables come
// in 2 different flavors -- near and far -- depending on their size.  Without the data
// members, the global variable is generated as near because it has no data members.
// The linker error (lnk2003) results because the actual variable is far

#if !defined(_ISTRING_CPP)
#if !defined(_ACTION_CPP)
class CMsiStringExternal : public IMsiString
{
 public:
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	const IMsiString&   __stdcall GetMsiStringValue() const;
	const ICHAR*  __stdcall GetString() const;
#ifdef USE_OBJECT_POOL
	unsigned int  __stdcall GetUniqueId() const;
	void          __stdcall SetUniqueId(unsigned int id);
#endif //USE_OBJECT_POOL
	int           __stdcall CopyToBuf(ICHAR* rgch, unsigned int cchMax) const;
	void          __stdcall SetString(const ICHAR* sz, const IMsiString*& rpi) const;
	int           __stdcall GetIntegerValue() const;
	int           __stdcall TextSize() const;
	int           __stdcall CharacterCount() const;
	Bool          __stdcall IsDBCS() const;
	void          __stdcall RefString(const ICHAR* sz, const IMsiString*& rpi) const;
	void          __stdcall RemoveRef(const IMsiString*& rpi) const;
	void          __stdcall SetChar  (ICHAR ch, const IMsiString*& rpi) const;
	void          __stdcall SetInteger(int i,   const IMsiString*& rpi) const;
	void          __stdcall SetBinary(const unsigned char* rgb, unsigned int cb, const IMsiString*& rpi) const;
	void          __stdcall AppendString(const ICHAR* sz, const IMsiString*& rpi) const;
	void          __stdcall AppendMsiString(const IMsiString& pi, const IMsiString*& rpi) const;
	const IMsiString&   __stdcall AddString(const ICHAR* sz) const;
	const IMsiString&   __stdcall AddMsiString(const IMsiString& ri) const;
	const IMsiString&   __stdcall Extract(iseEnum ase, unsigned int iLimit) const;
	Bool          __stdcall Remove(iseEnum ase, unsigned int iLimit, const IMsiString*& rpi) const;
	int           __stdcall Compare(iscEnum asc, const ICHAR* sz) const;
	void          __stdcall UpperCase(const IMsiString*& rpi) const;
	void          __stdcall LowerCase(const IMsiString*& rpi) const;
	ICHAR*        __stdcall AllocateString(unsigned int cb, Bool fDBCS, const IMsiString*& rpi) const;
 protected:  // state data
	int  m_iRefCnt;
	unsigned int  m_cchLen;
};
class CMsiStringNull : public CMsiStringExternal {};
class CMsiStringLive : public CMsiStringExternal {};
#endif
#endif
extern const CMsiStringNull g_MsiStringNull;     // THE only static null string object
extern const CMsiStringLive g_MsiStringDate;     // dynamic global date string object
extern const CMsiStringLive g_MsiStringTime;     // dynamic global time string object
// temporary(?) code to set memory usage properties
extern const CMsiStringLive g_MsiStringAvailPhys;
extern const CMsiStringLive g_MsiStringAvailVirtual;
extern const CMsiStringLive g_MsiStringAvailPageFile;
extern const CMsiStringLive g_MsiStringTotalPhys;
extern const CMsiStringLive g_MsiStringTotalVirtual;
extern const CMsiStringLive g_MsiStringTotalPageFile;


// global platform characteristics set at construction time

extern bool g_fWin9X;   // true if Windows 95 or 98, else false
extern bool g_fWinNT64; // true if 64-bit NT, else false
extern scEnum g_scServerContext;
extern Bool g_fShortFileNames;  // fFalse if long file names supported
extern int  g_iMajorVersion;
extern int  g_iMinorVersion;
extern int  g_iWindowsBuild;
extern Bool g_fDBCSEnabled;  // DBCS enabled OS
extern HINSTANCE g_hInstance;

// class from runapps.cpp for detecting running apps

class CDetectApps{
public:
	// GetFileUsage() assumes file name only
	CDetectApps(IMsiServices& riServices);
	virtual ~CDetectApps(){};
	virtual IMsiRecord* GetFileUsage(const IMsiString& strFile, IEnumMsiRecord*& rpiEnumRecord)=0;
	virtual IMsiRecord* Refresh()=0;
	static HWND GetMainWindow(DWORD dwProcessId);
protected:
	PMsiServices m_piServices;
private:
	struct idaProcessInfo{
							DWORD dwProcessId;
							HWND hwndRet;
						};
	static BOOL CALLBACK EnumWindowsProc(HWND  hwnd, LPARAM  lParam);
};

// local factories exposed from other modules in this DLL

#if !defined(_ACTION_CPP)
inline const IMsiString& CreateString() {return g_MsiStringNull;}
#endif

ICHAR*       AllocateString(unsigned int cbSize, Bool fDBCS, const IMsiString*& rpiStr);
HRESULT      CreateStringEnumerator(const IMsiString **ppstr, unsigned long iSize, IEnumMsiString* &rpaEnumStr);
IMsiRecord&  CreateRecord(unsigned int cParam);
HRESULT      CreateRecordEnumerator(IMsiRecord **ppRecord, unsigned long iSize, IEnumMsiRecord* &rpaEnumRecord);

IMsiRecord*  CreateMsiPath(const ICHAR* astrPath, IMsiServices* piAsvc, IMsiPath*& piPath); // from path.cpp
IMsiRecord*  CreateMsiFilePath(const ICHAR* szPath, IMsiServices* piServices, IMsiPath* &rpiPath, const IMsiString*& rpistrFileName); // from path.cpp
IMsiRecord*  CreateMsiFileCopy(ictEnum ictCopierType, IMsiServices* piAsvc, IMsiStorage* piStorage,
							   IMsiFileCopy*& rpacopy); //from copy.cpp
IMsiRecord*  CreateMsiFilePatch(IMsiServices* piAsvc, IMsiFilePatch*& rpiFilePatch); //from patch.cpp
IMsiRecord*  CreateMsiVolume(const ICHAR* astrPath, IMsiServices* piAsvc, IMsiVolume*& piVol); // from path.cpp
Bool         CreateMsiVolumeFromLabel(const ICHAR* szLabel, idtEnum idtVolType, IMsiServices* piAsvc, 
									 IMsiVolume*& rpiVol);
IEnumMsiVolume& EnumDriveType(idtEnum, IMsiServices& riServices);
void		 InitializeRecordCache();
void 		 KillRecordCache(boolean fFatal);


IMsiRecord*  CreateDatabase(const ICHAR* szDatabase, idoEnum idoOpenMode,
									 IMsiServices&  riService,
									 IMsiDatabase*& rpiDatabase); // from database.cpp
IMsiRecord*  CreateDatabase(IMsiStorage& riStorage, Bool fReadOnly,
									 IMsiServices&  riService,
									 IMsiDatabase*& rpiDatabase); // from database.cpp

IMsiRecord*  GetModuleUsage(const IMsiString& strFile, IEnumMsiRecord*& rpaEnumRecord, IMsiServices& riServices, CDetectApps*& rpDetectApps);
IMsiRegKey&  CreateMsiRegKey(IMsiRegKey& riaParent, const ICHAR* szKey, IMsiServices*  piAsvc );

IMsiRecord* CreateMsiStorage(const ICHAR* szPath, ismEnum ismOpenMode,
									  IMsiStorage*& rpiStorage);
IMsiRecord* CreateMsiStorage(const char* pchMem, unsigned int iSize, IMsiStorage*& rpiStorage);
char*       AllocateMemoryStream(unsigned int cbSize, IMsiStream*& rpiStream);
IMsiStream* CreateStreamOnMemory(const char* pbReadOnly, unsigned int cbSize);
IMsiRecord* CreateFileStream(const ICHAR* szFile, Bool fWrite, IMsiStream*& rpiStream);

class CRootKeyHolder;
CRootKeyHolder* CreateMsiRegRootKeyHolder(IMsiServices*  piAsvc );
void            DeleteRootKeyHolder(CRootKeyHolder* aRootKeyH);
IMsiRegKey&     GetRootKey(CRootKeyHolder* aRootKeyH, rrkEnum rrkRoot, const ibtBinaryType iType);

void  SetUnhandledError(IMsiRecord* piError);
enum aeConvertTypes
{
	aeCnvInt = 0,
	aeCnvIntInc,
	aeCnvIntDec,
	aeCnvBin,
	aeCnvExTxt,
	aeCnvMultiTxt,
	aeCnvMultiTxtAppend,
	aeCnvMultiTxtPrepend,
	aeCnvTxt,
};	

Bool LangIDToLangName(unsigned short wLangID, ICHAR* szLangName, int iBufSize);
Bool ConvertValueToString(CTempBufferRef<char>& rgchInBuffer, const IMsiString*& rpistrValue, aeConvertTypes aeType);
Bool ConvertValueFromString(const IMsiString& ristrValue, CTempBufferRef<char>& rgchOutBuffer, aeConvertTypes& raeType);
bool GetImpersonationFromPath(const ICHAR* szPath);

void SetNoPowerdown();
void ClearNoPowerdown();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\control.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       control.cpp
//
//--------------------------------------------------------------------------

/*
  control.cpp - CMsiControl, CMsiActiveControl implementation
____________________________________________________________________________*/

  
#include "common.h"
#include "engine.h"  
#include "database.h"
#include "_handler.h" 
#include "_control.h"
#include "darwjpeg.h"

ICHAR CMsiControl::m_szControlType[] = TEXT("");

ControlCreateDispatchEntry ControlCreateDispatchTable[] = {
	pcaControlTypePushButton,           CreateMsiPushButton,
	pcaControlTypeText,                 CreateMsiText,
	pcaControlTypeEdit,                 CreateMsiEdit,
	pcaControlTypeRadioButtonGroup,     CreateMsiRadioButtonGroup,
	pcaControlTypeCheckBox,             CreateMsiCheckBox,
	pcaControlTypeBitmap,               CreateMsiBitmap,
	pcaControlTypeListBox,              CreateMsiListBox,
	pcaControlTypeComboBox,             CreateMsiComboBox,
	pcaControlTypeProgressBar,          CreateMsiProgressBar,
	pcaControlTypeGroupBox,             CreateMsiGroupBox,
	pcaControlTypeDirectoryCombo,       CreateMsiDirectoryCombo,
	pcaControlTypeDirectoryList,        CreateMsiDirectoryList,
	pcaControlTypePathEdit,             CreateMsiPathEdit,
	pcaControlTypeVolumeSelectCombo,    CreateMsiVolumeSelectCombo,
	pcaControlTypeScrollableText,       CreateMsiScrollableText,
	pcaControlTypeSelectionTree,        CreateMsiSelectionTree,
	pcaControlTypeIcon,                 CreateMsiIcon,
	pcaControlTypeVolumeCostList,       CreateMsiVolumeCostList,
	pcaControlTypeListView,             CreateMsiListView,
	pcaControlTypeBillboard,            CreateMsiBillboard,
	pcaControlTypeMaskedEdit,           CreateMsiMaskedEdit,
	pcaControlTypeLine,                 CreateMsiLine,
};

int ControlCreateDispatchCount = sizeof(ControlCreateDispatchTable)/sizeof(ControlCreateDispatchEntry);


IMsiControl* CreateMsiControl(const IMsiString& riTypeString, IMsiEvent& riDialog)
{
	ControlCreateDispatchEntry* pEntry = ControlCreateDispatchTable;
	int count;
	for (count = ControlCreateDispatchCount; count--; count)
	{
		if (riTypeString.Compare(iscExact, pEntry->pcaType))
		{
			return (*pEntry->pfCreate)(riDialog);
		}
		pEntry++;
	}
	// here we should check for custom controls
	return 0;
}

//////////////////////////////////////////////////////
// CMsiControl implementation
//////////////////////////////////////////////////////

ControlDispatchEntry CMsiControl::s_ControlDispatchTable[] = {
	pcaControlAttributeText,                 CMsiControl::GetText,                 CMsiControl::SetText,
	pcaControlAttributeVisible,              CMsiControl::GetVisible,              CMsiControl::SetVisible,
	pcaControlAttributeTimeRemaining,        CMsiControl::GetTimeRemaining,        CMsiControl::SetTimeRemaining,
	pcaControlAttributeEnabled,              CMsiControl::GetEnabled,              CMsiControl::SetEnabled,
	pcaControlAttributeDefault,              CMsiControl::GetDefault,              CMsiControl::SetDefault,
	pcaControlAttributeIndirectPropertyName, CMsiControl::GetIndirectPropertyName, CMsiControl::NoWay,
	pcaControlAttributePosition,             CMsiControl::GetPosition,             CMsiControl::SetPosition,
	pcaControlAttributePropertyValue,        CMsiControl::GetPropertyValue,        CMsiControl::SetPropertyValue,
	pcaControlAttributeIndirect,             CMsiControl::GetIndirect,             CMsiControl::NoWay,
	pcaControlAttributeTransparent,          CMsiControl::GetTransparent,          CMsiControl::NoWay,
	pcaControlAttributeProgress,             CMsiControl::GetProgress,             CMsiControl::SetProgress,
	pcaControlAttributeImage,                CMsiControl::GetImage,                CMsiControl::SetImage,
	pcaControlAttributeImageHandle,          CMsiControl::GetImageHandle,          CMsiControl::SetImageHandle,
	pcaControlAttributePropertyName,         CMsiControl::GetPropertyName,         CMsiControl::NoWay,
	pcaControlAttributeBillboardName,        CMsiControl::GetBillboardName,        CMsiControl::SetBillboardName,
	pcaControlAttributeWindowHandle,         CMsiControl::GetpWnd,                 CMsiControl::NoWay,
	pcaControlAttributeIgnoreChange,         CMsiControl::GetIgnoreChange,         CMsiControl::SetIgnoreChange,
	pcaControlAttributeScriptInProgress,     CMsiControl::NoWay,                   CMsiControl::SetScriptInProgress,
	pcaControlAttributeText,                CMsiControl::GetText,                  CMsiControl::SetErrorText, // special for ErrorText on ErrorDialog
#ifdef ATTRIBUTES
	pcaControlAttributeRefCount,             CMsiControl::GetRefCount,             CMsiControl::NoWay,
	pcaControlAttributeKeyInt,               CMsiControl::GetKeyInt,               CMsiControl::NoWay,
	pcaControlAttributeKeyString,            CMsiControl::GetKeyString,            CMsiControl::NoWay,
	pcaControlAttributeX,                    CMsiControl::GetX,                    CMsiControl::NoWay,
	pcaControlAttributeY,                    CMsiControl::GetY,                    CMsiControl::NoWay,
	pcaControlAttributeWidth,                CMsiControl::GetWidth,                CMsiControl::NoWay,
	pcaControlAttributeHeight,               CMsiControl::GetHeight,               CMsiControl::NoWay,
	pcaControlAttributeHelp,                 CMsiControl::GetHelp,                 CMsiControl::NoWay,
	pcaControlAttributeToolTip,              CMsiControl::GetToolTip,              CMsiControl::NoWay,
	pcaControlAttributeContextHelp,          CMsiControl::GetContextHelp,          CMsiControl::NoWay,
	pcaControlAttributeClientRect,           CMsiControl::GetClientRect,           CMsiControl::NoWay,
	pcaControlAttributeOriginalValue,        CMsiControl::GetOriginalValue,        CMsiControl::NoWay,
	pcaControlAttributeInteger,              CMsiControl::GetInteger,              CMsiControl::NoWay,
	pcaControlAttributeLimit,                CMsiControl::GetLimit,                CMsiControl::NoWay,
	pcaControlAttributeItemsCount,  	     CMsiControl::GetItemsCount,           CMsiControl::NoWay,
	pcaControlAttributeItemsValue,		     CMsiControl::GetItemsValue,	       CMsiControl::NoWay,
	pcaControlAttributeItemsHandle,		     CMsiControl::GetItemsHandle,	       CMsiControl::NoWay,
	pcaControlAttributeItemsText,		     CMsiControl::GetItemsText,		       CMsiControl::NoWay,
	pcaControlAttributeItemsX,			     CMsiControl::GetItemsX,		       CMsiControl::NoWay,
	pcaControlAttributeItemsY,			     CMsiControl::GetItemsY,		       CMsiControl::NoWay,
	pcaControlAttributeItemsWidth,		     CMsiControl::GetItemsWidth,	       CMsiControl::NoWay,
	pcaControlAttributeItemsHeight,		     CMsiControl::GetItemsHeight,          CMsiControl::NoWay,
	pcaControlAttributeSunken,               CMsiControl::GetSunken,               CMsiControl::NoWay,
	pcaControlAttributePushLike,             CMsiControl::GetPushLike,             CMsiControl::NoWay,
	pcaControlAttributeBitmap,               CMsiControl::GetBitmap,               CMsiControl::NoWay,
	pcaControlAttributeIcon,                 CMsiControl::GetIcon,                 CMsiControl::NoWay,
	pcaControlAttributeHasBorder,            CMsiControl::GetHasBorder,            CMsiControl::NoWay,
	pcaControlAttributeRTLRO,                CMsiControl::GetRTLRO,                CMsiControl::NoWay,
	pcaControlAttributeRightAligned,         CMsiControl::GetRightAligned,         CMsiControl::NoWay,
	pcaControlAttributeLeftScroll,           CMsiControl::GetLeftScroll,           CMsiControl::NoWay,
#endif // ATTRIBUTES
};

int CMsiControl::s_ControlDispatchCount = sizeof(CMsiControl::s_ControlDispatchTable)/sizeof(ControlDispatchEntry);

MessageDispatchEntry CMsiControl::s_MessageDispatchTable[] = 
{
	WM_KEYDOWN,            CMsiControl::KeyDown,
	WM_CHAR,               CMsiControl::Char,
	WM_COMMAND,            CMsiControl::Command,
	WM_KILLFOCUS,          CMsiControl::KillFocus,
	WM_NCDESTROY,          CMsiControl::NCDestroy,
	WM_PAINT,              CMsiControl::Paint,
	WM_SETFOCUS,           CMsiControl::SetFocus,
	WM_SYSKEYDOWN,         CMsiControl::SysKeyDown,
	WM_SYSKEYUP,           CMsiControl::SysKeyUp,
	WM_DRAWITEM,           CMsiControl::DrawItem,
	WM_MEASUREITEM,        CMsiControl::MeasureItem,
	WM_NOTIFY,             CMsiControl::Notify,
	WM_COMPAREITEM,        CMsiControl::CompareItem,
	WM_LBUTTONDOWN,        CMsiControl::LButtonDown,
	WM_GETDLGCODE,         CMsiControl::GetDlgCode,
	WM_ENABLE,             CMsiControl::Enable,
	WM_SHOWWINDOW,         CMsiControl::ShowWindow,
};

int CMsiControl::s_MessageDispatchCount = sizeof(CMsiControl::s_MessageDispatchTable)/sizeof(MessageDispatchEntry);

CMsiControl::CMsiControl(IMsiEvent& riDialog)
{
	MsiString strNull;
	m_piServices = 0;
	m_iRefCnt = 1;
	m_iKey = 0;
	m_strKey = strNull;
	m_strRawText = strNull;
	m_strText = strNull;
	m_strCurrentStyle = strNull;
	m_strDefaultStyle = strNull;
	m_strHelp = strNull;
	m_strToolTip = strNull;
	m_strContextHelp = strNull;
	m_fVisible = fFalse;          
	m_fEnabled = fFalse;
	m_fDefault = fFalse;
	m_fImageHandle = fFalse;
	m_iX = 0;
	m_iY = 0;
	m_iWidth = 0;
	m_iHeight = 0;
	m_iSize = 0;
	m_fTransparent = fFalse;
	m_fHasToolTip = fFalse;
	m_hRichEd20 = NULL;
	m_piDialog = &riDialog;
	m_piHandler = &m_piDialog->GetHandler();
	m_piHandler->Release();
	m_piEngine = &m_piDialog->GetEngine();
	m_piEngine->Release();
	m_piServices = m_piEngine->GetServices();
	m_piServices->Release();
	m_piDatabase = m_piEngine->GetDatabase();
	m_piDatabase->Release();
	m_strPropertyName = strNull;
	PMsiRecord piNameRecord = &m_piServices->CreateRecord(1);
	AssertRecord(m_piDialog->AttributeEx(fFalse, dabKeyString, *piNameRecord));
	m_strDialogName = piNameRecord->GetMsiString(1);
	m_fSunken = fFalse;
	m_pWndToolTip = 0;
	m_pFunction = 0;  
	m_pWnd = 0;
	m_fLocking = fFalse;
	m_fRTLRO = fFalse;
	m_fRightAligned = fFalse;
	m_fLeftScroll = fFalse;
	m_fUseDbLang = true;
#ifdef USE_OBJECT_POOL
	m_iCacheId = 0;
#endif //USE_OBJECT_POOL
}


void CMsiControl::Refresh()
{
	// Nothing special
}

IMsiRecord* CMsiControl::StartView(const ICHAR* sqlQuery, const IMsiString& riArgumentString, IMsiView*& rpiView)
{

	Ensure(m_piDatabase->OpenView(sqlQuery, ivcFetch, *&rpiView));
	PMsiRecord piQuery = &m_piServices->CreateRecord(1);
	AssertNonZero(piQuery->SetMsiString(1, riArgumentString));
	Ensure(rpiView->Execute(piQuery));
	return 0;
}

IMsiRecord* CMsiControl::CheckInitialized ()
{
	return (m_iKey ? 0 : PostError(Imsg(idbgUninitControl), *m_strDialogName)); 
}

IMsiRecord* CMsiControl::CheckFieldCount (IMsiRecord& riRecord, int iCount, const ICHAR* szMsg)
{
	return (riRecord.GetFieldCount () >= iCount) ? 0 : PostError(Imsg(idbgControlAttributeShort), *MsiString(iCount), *MsiString(szMsg));
}

IMsiRecord* CMsiControl::GetBinaryStream (const IMsiString& riNameString, IMsiStream*& rpiStream)
{
	PMsiView piBinaryView(0);
	Ensure(StartView(sqlBinary, riNameString, *&piBinaryView));
	PMsiRecord piReturn = piBinaryView->Fetch();
	if (!piReturn)
		return PostError(Imsg(idbgViewExecute), *MsiString(*pcaTablePBinary));

	rpiStream = (IMsiStream*) piReturn->GetMsiData(1);
	if (!rpiStream)
		return PostError(Imsg(idbgBinaryData), riNameString);
	Ensure(piBinaryView->Close());

	return (0);
}


void CMsiControl::SetLocation(int Left, int Top, int Width, int Height) 
{
	int idyChar = m_piHandler->GetTextHeight();
	m_iX = Left*idyChar/iDlgUnitSize; 
	m_iY = Top*idyChar/iDlgUnitSize; 
	m_iWidth = Width*idyChar/iDlgUnitSize; 
	m_iHeight = Height*idyChar/iDlgUnitSize;
}

IMsiRecord* CMsiControl::CreatePath(const ICHAR* astrPath, IMsiPath*& rpi)
{
	AssertSz(m_piServices, "Services is not set.");
	return m_piServices->CreatePath(astrPath,rpi);

}

IMsiRecord* CMsiControl::CheckPath(IMsiPath& riPath,
											  const ICHAR* szSubFolder,
											  const ipvtEnum iMode)
{
	Bool fCheckSubFolder = (szSubFolder && *szSubFolder) ? fTrue : fFalse;

	// check file name if passed in
	if(fCheckSubFolder)
		Ensure(m_piServices->ValidateFileName(szSubFolder,riPath.SupportsLFN()));

	Bool fCheck;
	PMsiPath pPath(0);

	if ( iMode >= ipvtExists )
	{
		// check volume existence
		PMsiVolume pVolume(&riPath.GetVolume());
		Ensure(m_piServices->CreatePath(MsiString(pVolume->GetPath()),*&pPath));
		Ensure(pPath->Exists(fCheck));
		if(!fCheck)
			return PostError(Imsg(imsgVolumeDoesNotExist),*MsiString(pPath->GetPath()));
	}

	if ( iMode & ipvtWritable )
	{
		// check path writability
		// if folder name passed in, check path + folder
		Ensure(riPath.ClonePath(*&pPath));
		if(fCheckSubFolder)
			Ensure(pPath->AppendPiece(*MsiString(szSubFolder)));

		Bool fWritable = fTrue;
		PMsiRecord pErrRec(0);
		Bool fRetry;
		do
		{
			fRetry = fFalse;
			pErrRec = m_piEngine->IsPathWritable(*pPath, fWritable);
			if (pErrRec)
			{
				int iErr = pErrRec->GetInteger(1);
				if (iErr == imsgFileErrorCreatingDir || iErr == imsgSystemDeniedAccess)
				{
					if (m_piEngine->Message(imtEnum(imtError + imtRetryCancel), *pErrRec) == imsRetry)			
						fRetry = fTrue;
					else
						pErrRec = PostError(Imsg(imsgInvalidTargetFolder));
				}	
			}
		}while (fRetry);

		if (pErrRec)
		{
			pErrRec->AddRef();
			return pErrRec;
		}
	}
	return 0;
}

IMsiRecord* CMsiControl::CheckPath(const IMsiString &path,
											  const ipvtEnum iMode)
{
	if (m_fPreview)
		return 0;

	PMsiPath pPath(0);
	IMsiRecord* pError = CreatePath(path.GetString (), *&pPath);
	if (pError)
		return pError;

	return CMsiControl::CheckPath(*pPath, NULL, iMode);
}

IMsiRecord* CMsiControl::WindowCreate(IMsiRecord& riRecord)
{
	if (m_iKey)
	{
		return PostErrorDlgKey(Imsg(idbgSecondInitControl));
	}
	m_strKey = riRecord.GetMsiString(itabCOControl);
	m_iKey = m_piDatabase->EncodeString(*m_strKey);
	SetLocation(riRecord.GetInteger(itabCOX), riRecord.GetInteger(itabCOY),
		riRecord.GetInteger(itabCOWidth), riRecord.GetInteger(itabCOHeight));
	PMsiRecord piClientRecord = &m_piServices->CreateRecord(2);
	AssertRecord(m_piDialog->AttributeEx(fFalse, dabPreview, *piClientRecord));
	m_fPreview = ToBool(piClientRecord->GetInteger(1));
	AssertRecord(m_piDialog->AttributeEx(fFalse, dabFullSize, *piClientRecord));
	if (m_iX < 0)
	{
		PMsiRecord piReturn = PostErrorDlgKey(Imsg(idbgControlOutOfDialog), *MsiString(*TEXT("to the left")),  - m_iX);
		m_piEngine->Message(imtInfo, *piReturn);
	}
	if (m_iY < 0)
	{
		PMsiRecord piReturn = PostErrorDlgKey(Imsg(idbgControlOutOfDialog), *MsiString(*TEXT("on the top")),  - m_iY);
		m_piEngine->Message(imtInfo, *piReturn);
	}
	if (m_iX + m_iWidth > piClientRecord->GetInteger(1))
	{
		PMsiRecord piReturn = PostErrorDlgKey(Imsg(idbgControlOutOfDialog), *MsiString(*TEXT("to the right")), m_iX + m_iWidth - piClientRecord->GetInteger(1));
		m_piEngine->Message(imtInfo, *piReturn);
	}
	if (m_iY + m_iHeight > piClientRecord->GetInteger(2))
	{
		PMsiRecord piReturn = PostErrorDlgKey(Imsg(idbgControlOutOfDialog), *MsiString(*TEXT("on the bottom")), m_iY + m_iHeight - piClientRecord->GetInteger(2));
		m_piEngine->Message(imtInfo, *piReturn);
	}
	m_strRawText = riRecord.GetMsiString(itabCOText);
	Ensure(ProcessText());
	PMsiRecord piRecord = &m_piServices->CreateRecord(1);
	Ensure(m_piDialog->AttributeEx(fFalse, dabWindowHandle, *piRecord));
	m_pWndDialog = (WindowRef) piRecord->GetHandle(1);
	Ensure(m_piDialog->AttributeEx(fFalse, dabToolTip, *piRecord));
	m_pWndToolTip = (WindowRef) piRecord->GetHandle(1);

	// do something with attributes
	int iAttributes = riRecord.GetInteger(itabCOAttributes);
	m_fVisible = ToBool(iAttributes & msidbControlAttributesVisible);
	m_fEnabled = ToBool(iAttributes & msidbControlAttributesEnabled);
	m_fSunken = ToBool(iAttributes & msidbControlAttributesSunken);
	m_fImageHandle = ToBool(iAttributes & msidbControlAttributesImageHandle);
	m_fRTLRO = ToBool(iAttributes & msidbControlAttributesRTLRO);
	m_fRightAligned = ToBool(iAttributes & msidbControlAttributesRightAligned);
	m_fLeftScroll = ToBool(iAttributes & msidbControlAttributesLeftScroll);
	m_strHelp = riRecord.GetMsiString(itabCOHelp);
	if (m_strHelp.TextSize())
	{
		if (!m_strHelp.Compare(iscWithin, TEXT("|")))
			return PostError(Imsg(idbgNoHelpSeparator), *m_strDialogName, *m_strKey, *m_strHelp);
		m_strToolTip = m_strHelp.Extract(iseUpto, TEXT('|'));
		m_strContextHelp = m_strHelp.Extract(iseAfter, TEXT('|'));
	}
	m_fHasToolTip = ToBool(m_strToolTip.TextSize());
	m_strPropertyName = riRecord.GetMsiString(itabCOProperty);
	return 0;
}

IMsiRecord* CMsiControl::ProcessText()
{
	return ProcessText(m_strRawText, m_strText, m_strCurrentStyle, m_strDefaultStyle, m_pWnd, /*fFormat =*/true);
}

IMsiRecord* CMsiControl::ProcessText(const MsiString& riRawText, MsiString& riText,
												 MsiString& riCurrentStyle, MsiString& riDefaultStyle,
												 const WindowRef pWnd, bool fFormat)
{
	if (fFormat)
		riText = m_piEngine->FormatText(*riRawText);
	else
		riText = riRawText;

	Bool fDefault = ToBool(riText.Compare(iscStart, TEXT("{&")));
	Bool fCurrent = ToBool(riText.Compare(iscStart, TEXT("{\\")));

	while ( fCurrent || fDefault )
	{
		MsiString strStyle;
		if ( FExtractSubString(riText, 2, TEXT('}'), *&strStyle) )
		{
			AssertNonZero(riText.Remove(iseIncluding, TEXT('}')));
			riCurrentStyle = strStyle;
			if ( fDefault )
				riDefaultStyle = strStyle;
		}
		else
			Assert(fFalse);
		fDefault = ToBool(riText.Compare(iscStart, TEXT("{&")));
		fCurrent = ToBool(riText.Compare(iscStart, TEXT("{\\")));
	}
	if ( !riDefaultStyle.TextSize() )
		riDefaultStyle = GetDBProperty(IPROPNAME_DEFAULTUIFONT);
	if ( !riCurrentStyle.TextSize() )
		riCurrentStyle = riDefaultStyle;

	if (pWnd)
	{
		PAINTSTRUCT ps;
		HDC hdc = WIN::BeginPaint(pWnd, &ps);
		IMsiRecord* piRecord = ChangeFontStyle(hdc);
		WIN::EndPaint(pWnd, &ps);
		return piRecord;
	}
	return 0;
}


IMsiRecord* CMsiControl::WindowFinalize()
{

	Ensure(SetVisible(m_fVisible));
	Ensure(SetEnabled(m_fEnabled));
	if (m_fHasToolTip && m_pWndToolTip)
	{
		TOOLINFO ti;
		int iSize = TOOLINFOsize();
		memset(&ti, 0, iSize);
		ti.cbSize = iSize;
		ti.uFlags = TTF_IDISHWND;
		ti.hwnd = m_pWndDialog;
		ti.uId = (UINT_PTR) m_pWnd;		
		ti.hinst = g_hInstance;
		ti.lpszText = (ICHAR *)(const ICHAR *) m_strToolTip;
		WIN::SendMessage(m_pWndToolTip, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
	}
	PAINTSTRUCT ps;
	HDC hdc = WIN::BeginPaint(m_pWnd, &ps);
	IMsiRecord* piRecord = ChangeFontStyle(hdc);
	WIN::EndPaint(m_pWnd, &ps);
	return piRecord;
}

CMsiControl::~CMsiControl()
{
#ifdef USE_OBJECT_POOL
	m_piDatabase->RemoveObjectData(m_iCacheId);
#endif //USE_OBJECT_POOL
}


IMsiRecord* CMsiControl::Attribute(Bool fSet, const IMsiString& riAttributeString, IMsiRecord& riRecord)
{
	Ensure(CheckInitialized ());

	ControlDispatchEntry* pEntry = s_ControlDispatchTable;
	int count;
	for (count = s_ControlDispatchCount; count--; count)
	{
		if (riAttributeString.Compare(iscExact, pEntry->pcaAttribute))
		{
			if (fSet)
			{
				return (this->*(pEntry->pmfSet))(riRecord);
			}
			else
			{
				return (this->*(pEntry->pmfGet))(riRecord);
			}
		}
		pEntry++;
	}
	MsiString strWord = (fSet ? MsiString(*TEXT("setting")) : MsiString(*TEXT("getting")));
	// we could not find the attribute
	return PostError(Imsg(idbgUnsupportedControlAttrib),
		*m_strDialogName, *m_strKey, *MsiString(riAttributeString), *strWord);
}

IMsiRecord* CMsiControl::AttributeEx(Bool fSet, cabEnum cab, IMsiRecord& riRecord)
{
	Ensure(CheckInitialized ());

	if (cab < s_ControlDispatchCount)
	{
		if (fSet)
		{
			return (this->*(s_ControlDispatchTable[cab].pmfSet))(riRecord);
		}
		else
		{
			return (this->*(s_ControlDispatchTable[cab].pmfGet))(riRecord);
		}
	}
	MsiString strWord = (fSet ? MsiString(*TEXT("setting")) : MsiString(*TEXT("getting")));
	// we could not find the attribute
	return PostError(Imsg(idbgUnsupportedControlAttrib),
		*m_strDialogName, *m_strKey, *MsiString((int)cab), *strWord);
}

IMsiRecord* CMsiControl::WindowMessage(int iMessage, WPARAM wParam, LPARAM lParam)
{
	Ensure(CheckInitialized ());

	MessageDispatchEntry* pEntry = s_MessageDispatchTable;
	int count;
	for (count = s_MessageDispatchCount; count--; count)
	{
		if (iMessage == pEntry->iMessage)
		{
			return  (this->*(pEntry->pmfMessage))(wParam, lParam);
		}
		pEntry++;
	}
	// we could not find the message
	return 0;
}

IMsiRecord* CMsiControl::KeyDown(WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	// Not much goin' on here...
	return 0;
}

IMsiRecord* CMsiControl::SysKeyDown(WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	return 0;
}

IMsiRecord* CMsiControl::SysKeyUp(WPARAM wParam, LPARAM /*lParam*/)
{
	static Bool SystemMenuUp = fFalse;
	WPARAM mywParam = (WPARAM) wParam;
	if (mywParam == VK_MENU)    // just a plain ALT
	{
		SystemMenuUp = SystemMenuUp ? fFalse : fTrue;
		if (SystemMenuUp)
		{
			WIN::SendMessage(m_pWndDialog, WM_SYSCOMMAND, SC_KEYMENU, 0l);
		}
		return PostErrorDlgKey(Imsg(idbgWinMes), 0);
	}
	return 0;
}

IMsiRecord* CMsiControl::SetFocus(WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	PMsiRecord piRecord = &m_piServices->CreateRecord(1);
	AssertNonZero(piRecord->SetMsiString(1, *m_strKey));
	AssertRecord(m_piDialog->AttributeEx(fTrue, dabCurrentControl, *piRecord));
	return 0;
}

IMsiRecord* CMsiControl::NCDestroy(WPARAM, LPARAM)
{
	if ( !g_fFatalExit )
	{
		AssertSz(!m_iRefCnt,"Trying to remove a control, but somebody still holds a reference to it");
		IMsiRecord* riReturn = PostErrorDlgKey(Imsg(idbgWinMes), 0);
		delete this;
		return riReturn;
	}
	else
		return 0;
}

IMsiRecord* CMsiControl::GetDlgCode(WPARAM, LPARAM)
{
	return 0;
}

IMsiRecord* CMsiControl::KillFocus(WPARAM, LPARAM)
{
	return 0;
}

IMsiRecord* CMsiControl::DrawItem(WPARAM, LPARAM)
{
	return 0;
}

IMsiRecord* CMsiControl::MeasureItem(WPARAM, LPARAM)
{
	return 0;
}

IMsiRecord* CMsiControl::Notify(WPARAM, LPARAM)
{
	return 0;
}

IMsiRecord* CMsiControl::CompareItem(WPARAM, LPARAM)
{
	return 0;
}

IMsiRecord* CMsiControl::LButtonDown(WPARAM, LPARAM)
{
	return 0;
}


IMsiRecord* CMsiControl::Char(WPARAM, LPARAM)
{
	return 0;
}

IMsiRecord* CMsiControl::Command(WPARAM, LPARAM)
{
	return 0;
}

IMsiRecord* CMsiControl::Paint(WPARAM, LPARAM)
{
	return 0;
}

IMsiRecord* CMsiControl::Undo()
{
	return (CheckInitialized ());
}

HRESULT CMsiControl::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown) || MsGuidEqual(riid, IID_IMsiControl))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CMsiControl::AddRef()
{
	return ++m_iRefCnt;
} 

unsigned long CMsiControl::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	if (m_pWnd)
	{
		DestroyWindow(m_pWnd);
	}
	else
	{
		delete this;
	}
	return 0;
}

const IMsiString& CMsiControl::GetMsiStringValue() const
{
	const IMsiString& strRet = *m_strKey;
	strRet.AddRef();
	return strRet;
}

int CMsiControl::GetIntegerValue() const
{
	return m_iKey;
}

#ifdef USE_OBJECT_POOL
unsigned int CMsiControl::GetUniqueId() const
{
	return m_iCacheId;
}

void CMsiControl::SetUniqueId(unsigned int id)
{
	Assert(m_iCacheId == 0);
	m_iCacheId = id;
}
#endif //USE_OBJECT_POOL

IMsiRecord* CMsiControl::SetPropertyInDatabase()
{
	return (CheckInitialized ());
}

IMsiRecord* CMsiControl::GetPropertyFromDatabase()
{
	Ensure (CheckInitialized ());
	if (m_strRawText.TextSize()) // if RawText is empty a control can escape this part
	{
		MsiString strOldText = m_strText;
		Ensure(ProcessText());
		if (!m_strText.Compare(iscExact, strOldText))
		{
			WIN::SetWindowText(m_pWnd, m_strText);
			Ensure(SetVisible(m_fVisible));
			AssertNonZero(WIN::InvalidateRect(m_pWnd, 0, fTrue));
		}
	}
	return 0;
}

IMsiRecord* CMsiControl::GetIndirectPropertyFromDatabase()
{
	return (CheckInitialized ());
}

IMsiRecord* CMsiControl::RefreshProperty()
{
	return (CheckInitialized ());
}

Bool CMsiControl::CanTakeFocus()
{
	return fFalse;
}

IMsiRecord* CMsiControl::SetFocus()
{
	Ensure(CheckInitialized ());

	WIN::SetFocus(m_pWnd);
	return 0;
}

IMsiRecord* CMsiControl::HandleEvent(const IMsiString& /*rpiEventNameString*/, const IMsiString& /*rpiArgumentString*/)
{
	return (CheckInitialized ());
}

void CMsiControl::ReportInvalidEntry ()
{

	PMsiRecord piRecord = &m_piServices->CreateRecord(1);
	AssertNonZero(piRecord->SetMsiString(1, *MsiString(*TEXT("Insert validation message here"))));
	m_piEngine->Message(imtError, *piRecord);

}

IMsiRecord* CMsiControl::LockDialog(Bool fLock)
{
	PMsiRecord piRecord = &m_piServices->CreateRecord(1);
	AssertNonZero(piRecord->SetInteger(1, fLock ? m_iKey : 0));
	AssertRecord(m_piDialog->AttributeEx(fTrue, dabLocked, *piRecord));
	if (fLock)
	{
		m_fLocking = fTrue;
		WIN::SendMessage(m_pWnd, WM_SETFOCUS, 0, 0);
		m_fLocking = fFalse;
	}
	return 0;
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetRefCount(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeRefCount));
	riRecord.SetInteger(1, m_iRefCnt);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetKeyInt(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeKeyInt));
	riRecord.SetInteger(1, m_iKey);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetKeyString(IMsiRecord& riRecord)
{

	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeKeyString));
	riRecord.SetMsiString(1, *m_strKey);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetX(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeX));
	riRecord.SetInteger(1, m_iX);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetY(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeY));
	riRecord.SetInteger(1, m_iY);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetWidth(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeWidth));
	riRecord.SetInteger(1, m_iWidth);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetHeight(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeHeight));
	riRecord.SetInteger(1, m_iHeight);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetRTLRO(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeRTLRO));
	riRecord.SetInteger(1, m_fRTLRO);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetRightAligned(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeRightAligned));
	riRecord.SetInteger(1, m_fRightAligned);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetLeftScroll(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeLeftScroll));
	riRecord.SetInteger(1, m_fLeftScroll);
	return 0;
}
#endif // ATTRIBUTES

IMsiRecord* CMsiControl::GetText(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeText));
	riRecord.SetMsiString(1, *m_strText);
	return 0;
}

IMsiRecord* CMsiControl::SetText(IMsiRecord& riRecord)
{
	WIN::SendMessage(m_pWnd, WM_SETREDRAW, fFalse, 0L);
	if ( riRecord.GetFieldCount() )
		m_strRawText = riRecord.IsNull(0) ? riRecord.GetMsiString(1) : riRecord.FormatText(fFalse);
	else
		m_strRawText = TEXT("");
	Ensure(ProcessText());
	WIN::SetWindowText(m_pWnd, m_strText);
	Ensure(SetVisible(m_fVisible));
	WIN::SendMessage(m_pWnd, WM_SETREDRAW, fTrue, 0L);
	AssertNonZero(WIN::InvalidateRect(m_pWnd, 0, fTrue));
	return 0;
}

IMsiRecord* CMsiControl::SetErrorText(IMsiRecord& riRecord)
{
	WIN::SendMessage(m_pWnd, WM_SETREDRAW, fFalse, 0L);
	if ( riRecord.GetFieldCount() )
		m_strRawText = riRecord.IsNull(0) ? riRecord.GetMsiString(1) : riRecord.FormatText(fFalse);
	else
		m_strRawText = TEXT("");
	Ensure(ProcessText(m_strRawText, m_strText, m_strCurrentStyle, m_strDefaultStyle, m_pWnd, /*fFormat = */false));
	WIN::SetWindowText(m_pWnd, m_strText);
	Ensure(SetVisible(m_fVisible));
	WIN::SendMessage(m_pWnd, WM_SETREDRAW, fTrue, 0L);
	AssertNonZero(WIN::InvalidateRect(m_pWnd, 0, fTrue));
	return 0;
}

IMsiRecord* CMsiControl::GetTimeRemaining(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}

IMsiRecord* CMsiControl::SetTimeRemaining(IMsiRecord& riRecord)
{
	AssertNonZero(riRecord.SetMsiString(0, *MsiString(::GetUIText(*MsiString(*pcaEventTimeRemaining)))));
	int iSecsRemaining = riRecord.GetInteger(1);
	iSecsRemaining < 60 ? AssertNonZero(riRecord.SetNull(1)) : AssertNonZero(riRecord.SetInteger(1, iSecsRemaining / 60));
	iSecsRemaining >= 60 ? AssertNonZero(riRecord.SetNull(2)) : AssertNonZero(riRecord.SetInteger(2, iSecsRemaining % 60));
	Ensure(SetText(riRecord));
	return 0;
}


IMsiRecord* CMsiControl::SetScriptInProgress(IMsiRecord& riRecord)
{
	Bool fSet = Bool(riRecord.GetInteger(1));
	AssertNonZero(riRecord.SetMsiString(0, fSet ? *MsiString(::GetUIText(*MsiString(*pcaEventScriptInProgress))) : *MsiString(TEXT(""))));
	Ensure(SetText(riRecord));
	return 0;
}


#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetHelp(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeHelp));
	riRecord.SetMsiString(1, *m_strHelp);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetToolTip(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeToolTip));
	riRecord.SetMsiString(1, *m_strToolTip);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetContextHelp(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeContextHelp));
	riRecord.SetMsiString(1, *m_strContextHelp);
	return 0;
}
#endif // ATTRIBUTES

IMsiRecord* CMsiControl::GetpWnd(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeWindowHandle));
	riRecord.SetHandle(1, (HANDLE)m_pWnd);
	return 0;
}

IMsiRecord* CMsiControl::GetVisible(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeVisible));
	riRecord.SetInteger(1, m_fVisible);
	return 0;
}

IMsiRecord* CMsiControl::SetVisible(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeVisible));
	return SetVisible(ToBool(riRecord.GetInteger(1)));
}

IMsiRecord* CMsiControl::SetVisible(Bool fVisible)
{
	m_fVisible = fVisible;
	WIN::ShowWindow(m_pWnd, m_fVisible ? SW_SHOW : SW_HIDE);
	return 0;
}

IMsiRecord* CMsiControl::ShowWindow(WPARAM wParam, LPARAM /*lParam*/)
{
	m_fVisible = ToBool((BOOL)wParam);
	return 0;
}

IMsiRecord* CMsiControl::SetEnabled(Bool fEnabled)
{
	m_fEnabled = fEnabled;
	if (m_pWnd)
		WIN::EnableWindow(m_pWnd, fEnabled);
	return 0;
}

IMsiRecord* CMsiControl::GetEnabled(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeEnabled));
	riRecord.SetInteger(1, m_fEnabled);
	return 0;
}

IMsiRecord* CMsiControl::SetEnabled(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeEnabled));
	return SetEnabled(ToBool(riRecord.GetInteger(1)));
}

IMsiRecord* CMsiControl::Enable(WPARAM wParam, LPARAM /*lParam*/)
{
	m_fEnabled = ToBool((BOOL)wParam);
	return 0;
}

IMsiRecord* CMsiControl::GetDefault(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeDefault));
	riRecord.SetInteger(1, m_fDefault);
	return 0;
}

IMsiRecord* CMsiControl::SetDefault(IMsiRecord& riRecord)
{	
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeDefault));
	m_fDefault = ToBool(riRecord.GetInteger(1));
	return 0;
}

IMsiRecord* CMsiControl::GetPropertyName(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributePropertyName));
	riRecord.SetMsiString(1, *m_strPropertyName);
	return 0;
}

IMsiRecord* CMsiControl::GetIndirectPropertyName(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeIndirectPropertyName));

	MsiString strNull;
	riRecord.SetMsiString(1, *strNull);
	return 0;
}

IMsiRecord* CMsiControl::GetPosition(IMsiRecord& riRecord)
{

	Ensure(CheckFieldCount (riRecord, 4, pcaControlAttributePosition));

	RECT rect;
	AssertNonZero(WIN::GetClientRect (m_pWnd, &rect));
	WIN::MapWindowPoints (m_pWnd, m_pWndDialog, (LPPOINT) &rect, 2);
	riRecord.SetInteger(1, rect.left);
	riRecord.SetInteger(2, rect.top);
	riRecord.SetInteger(3, rect.right - rect.left);
	riRecord.SetInteger(4, rect.bottom - rect.top);

	return 0;
}


IMsiRecord* CMsiControl::SetPosition(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 4, pcaControlAttributePosition));
	m_iX = riRecord.GetInteger(1);
	m_iY = riRecord.GetInteger(2);
	m_iWidth = riRecord.GetInteger(3);
	m_iHeight = riRecord.GetInteger(4);
	AssertNonZero(WIN::MoveWindow(m_pWnd, m_iX, m_iY, m_iWidth, m_iHeight, fTrue));
	return 0;
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetClientRect(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 4, pcaControlAttributeClientRect));
	RECT rect;
	AssertNonZero(WIN::GetClientRect(m_pWnd, &rect));
	riRecord.SetInteger(1, rect.left);
	riRecord.SetInteger(2, rect.top);
	riRecord.SetInteger(3, rect.right);
	riRecord.SetInteger(4, rect.bottom);
	return 0;
}
#endif // ATTRIBUTES


IMsiRecord* CMsiControl::GetTransparent(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeTransparent));
	riRecord.SetInteger(1, m_fTransparent);
	return 0;
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetSunken(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeSunken));
	riRecord.SetInteger(1, m_fSunken);
	return 0;
}
#endif // ATTRIBUTES

IMsiRecord* CMsiControl::GetIgnoreChange(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}

IMsiRecord* CMsiControl::SetIgnoreChange(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("setting"));
}

IMsiRecord* CMsiControl::NoWay(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}

IMsiRecord* CMsiControl::GetPropertyValue(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}

IMsiRecord* CMsiControl::SetPropertyValue(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("setting"));
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetOriginalValue(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetInteger(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}
#endif // ATTRIBUTES

IMsiRecord* CMsiControl::GetIndirect(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetLimit(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetItemsCount(IMsiRecord& /*riRecord*/)
{												   
	return PostErrorUnsupAttrib(TEXT("getting"));
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetItemsValue(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetItemsHandle(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetItemsText(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetItemsX(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetItemsY(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetItemsWidth(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetItemsHeight(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}
#endif // ATTRIBUTES

IMsiRecord* CMsiControl::GetProgress(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}

IMsiRecord* CMsiControl::SetProgress(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("setting"));
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetPushLike(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetBitmap(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetIcon(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiControl::GetHasBorder(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}
#endif // ATTRIBUTES

IMsiRecord* CMsiControl::GetImage(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}

IMsiRecord* CMsiControl::SetImage(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("setting"));
}

IMsiRecord* CMsiControl::GetImageHandle(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}

IMsiRecord* CMsiControl::SetImageHandle(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("setting"));
}

IMsiRecord* CMsiControl::GetBillboardName(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("getting"));
}

IMsiRecord* CMsiControl::SetBillboardName(IMsiRecord& /*riRecord*/)
{
	return PostErrorUnsupAttrib(TEXT("setting"));
}

INT_PTR CALLBACK CMsiControl::ControlProc(WindowRef pWnd, WORD message,		//--merced: changed return from INT to INT_PTR 
										  WPARAM wParam, LPARAM lParam)
{
	static Bool SystemMenuUp = fFalse;
#ifdef _WIN64	// !merced
	CMsiControl* pControl = (CMsiControl*)WIN::GetWindowLongPtr(pWnd, GWLP_USERDATA);
#else			// win-32. This should be removed with the 64-bit windows.h is #included.
	CMsiControl* pControl = (CMsiControl*)WIN::GetWindowLong(pWnd, GWL_USERDATA);
#endif
	AssertSz(pControl,
		TEXT("Failed to retrieve the control in CMsiControl::ControlProc()"));

	static MsiStringId iJustRejectedKillFocus = 0;    //  bug # 5291 (IME issue on KOR NT4)

	switch (message)
	{
	case WM_PRINTCLIENT:
		if ( lParam == PRF_CLIENT )
		{
			// a child control asks the control to draw it's background (bug #279971)
			HDC hdc = (HDC)wParam;
			RECT rect;
			int iRet = WIN::GetClipBox(hdc, &rect);
			Assert(iRet != ERROR);
			if ( iRet != ERROR && iRet != NULLREGION )
			{
				COLORREF color = WIN::SetBkColor(hdc, WIN::GetSysColor(COLOR_BTNFACE));
				AssertNonZero(ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL));
				WIN::SetBkColor(hdc, color);
			}
		}
		break;									  
	case WM_IME_SETCONTEXT:
		{
			if ( !wParam && iJustRejectedKillFocus == pControl->m_iKey )
			{
				iJustRejectedKillFocus = 0;
				return 0;
			}
		}
		break;
	case WM_CHAR:
	case WM_COMMAND:
	case WM_KILLFOCUS:
	case WM_NCDESTROY:
	case WM_PAINT:
	case WM_SETFOCUS:
	case WM_SYSKEYDOWN:
	case WM_SYSKEYUP:
	case WM_DRAWITEM:
	case WM_MEASUREITEM:
	case WM_NOTIFY:
	case WM_COMPAREITEM:
	case WM_LBUTTONDOWN:
	case WM_GETDLGCODE:
	case WM_ENABLE:
	case WM_SHOWWINDOW:
		{
			PMsiRecord piReturn = pControl->WindowMessage(message, wParam, lParam);
			if (piReturn)
			{
				if (piReturn->GetInteger(1) == idbgWinMes)
				{
					if ( message == WM_KILLFOCUS )
						iJustRejectedKillFocus = pControl->m_iKey;
					return piReturn->GetInteger(4);  // the control wants us to return this number
				}
				// we have an error message
				piReturn->AddRef(); // we want to keep it around
				PMsiEvent piDialog = &pControl->GetDialog();
				piDialog->SetErrorRecord(*piReturn);
				return 0;
			}
		}
		if (message != WM_LBUTTONDOWN)
			break;
		// in case of WM_LBUTTONDOWN intentional fallthrough!
	case WM_MOUSEMOVE:
	case WM_LBUTTONUP:
	case WM_RBUTTONDOWN:
	case WM_RBUTTONUP:
		if (pControl->m_fHasToolTip && pControl->m_pWndToolTip)
		{
			MSG msg;
			msg.lParam = lParam;
			msg.wParam = wParam;
			msg.message = message;
			msg.hwnd = pWnd;
			WIN::SendMessage(pControl->m_pWndToolTip, TTM_RELAYEVENT, 0, (LPARAM)(LPMSG) &msg);
		}
		break;
	case WM_KEYDOWN:
		{
			if (wParam == VK_ESCAPE)
			{
				PMsiEvent piDialog = &pControl->GetDialog();
				PMsiRecord piReturn = piDialog->Escape();
				if (piReturn)
				{
					piReturn->AddRef(); // we want to keep it around
					piDialog->SetErrorRecord(*piReturn);
				}
				return 0;
			}
			PMsiRecord piReturn = pControl->WindowMessage(message, wParam, lParam);
			if (piReturn)
			{
				if (piReturn->GetInteger(1) == idbgWinMes)
				{
					return piReturn->GetInteger(4);  // the control wants us to return this number
				}
				// we have an error message
				piReturn->AddRef(); // we want to keep it around
				PMsiEvent piDialog = &pControl->GetDialog();
				piDialog->SetErrorRecord(*piReturn);
				return 0;
			}

			if (!WIN::CallWindowProc(pControl->GetCallbackFunction(), pWnd, message, wParam, lParam)) // send all unhandled messages to the Dialog
				WIN::SendMessage(pControl->m_pWndDialog, message, wParam, lParam);
			return 0;
		}
		break;
	default:
		break;
	}
	return WIN::CallWindowProc(pControl->GetCallbackFunction(), pWnd, message, wParam, lParam);
}

void CMsiControl::SetCallbackFunction(WNDPROC pFunction)
{
	m_pFunction = pFunction;
}


WNDPROC CMsiControl::GetCallbackFunction()
{
	return m_pFunction;
}

IMsiRecord* CMsiControl::CreateControlWindow(ICHAR *WindowClass, DWORD Style, DWORD ExtendedStyle, const IMsiString& Title, WindowRef ParentWindow, int WindowID)
{
	DWORD dwExStyle = ExtendedStyle;
	dwExStyle |= m_fTransparent ? WS_EX_TRANSPARENT : 0;
	dwExStyle |= m_fSunken ? WS_EX_CLIENTEDGE : 0;
	m_pWnd = WIN::CreateWindowEx(dwExStyle,
						 WindowClass,
						 Title.GetString (),
						 WS_CHILD | WS_GROUP | Style,  // All control windows are created as child windows  
						 // Note that WS_VISIBLE is NOT set!!!
						 m_iX,
						 m_iY,
						 m_iWidth,
						 m_iHeight,
						 ParentWindow,
						 (HMENU)(INT_PTR)WindowID,					//!!merced: Converting PTR to INT.
						 g_hInstance,
						 0);
	if ( NULL == m_pWnd )
		return PostErrorDlgKey(Imsg(idbgCreateControlWindow));
	LONG_PTR RetVal;		//--merced: changed long to LONG_PTR
	// Store the pointer to the default callback function
#ifdef _WIN64	// !merced
	SetCallbackFunction((WNDPROC)WIN::GetWindowLongPtr(m_pWnd, GWLP_WNDPROC));
	// Set the new default callback function
	RetVal = WIN::SetWindowLongPtr(m_pWnd, GWLP_WNDPROC, (LONG_PTR)ControlProc);
	if (RetVal == 0)
	{
		return PostErrorDlgKey(Imsg(idbgCreateControlWindow));
	}
	// Set the this pointer for use in the callback function
	WIN::SetWindowLongPtr(m_pWnd, GWLP_USERDATA, (LONG_PTR)this);
#else			// win-32. This should be removed with the 64-bit windows.h is #included.
	SetCallbackFunction((WNDPROC)WIN::GetWindowLong(m_pWnd, GWL_WNDPROC));
	// Set the new default callback function
	RetVal = WIN::SetWindowLong(m_pWnd, GWL_WNDPROC, (long)ControlProc);
	if (RetVal == 0)
	{
		return PostErrorDlgKey(Imsg(idbgCreateControlWindow));
	}
	// Set the this pointer for use in the callback function
	WIN::SetWindowLong(m_pWnd, GWL_USERDATA, (long)this);
#endif
	return 0;   // no error
}

IMsiRecord* CMsiControl::CreateTable(const ICHAR* szTable, IMsiTable*& riTable)
{
	if ( PMsiRecord(m_piDatabase->CreateTable(*MsiString(m_piDatabase->CreateTempTableName()),
															0, *&riTable)) )
	{
		return PostError(Imsg(idbgTableCreate), *MsiString(szTable));
	}
	return 0;
}


// creates a list (a table of one column) of the volumes of the types specified by the attribute bits. 
// the rest of the control attribute bits is ignored
IMsiRecord* CMsiControl::GetVolumeList(int iAttributes, IMsiTable*& riTable)
{
	Ensure(CreateTable(pcaTableIVolumeList, *&riTable));
	::CreateTemporaryColumn(*riTable, icdObject + icdPrimaryKey, 1);
	PMsiCursor piVolumesCursor(0);
	Ensure(::CursorCreate(*riTable, pcaTableIVolumeList, fFalse, *m_piServices, *&piVolumesCursor)); 
	for (int i = 0; i < 6; i++)
	{
		PEnumMsiVolume peVolumes(0);
		switch (i)
		{
		case 0:
			if (iAttributes & msidbControlAttributesRemovableVolume)
				peVolumes = &m_piServices->EnumDriveType(idtRemovable);
			else
				continue;
			break;
		case 1:
			if (iAttributes & msidbControlAttributesFixedVolume)
				peVolumes = &m_piServices->EnumDriveType(idtFixed);
			else
				continue;
			break;
		case 2:
			if (iAttributes & msidbControlAttributesRemoteVolume)
				peVolumes = &m_piServices->EnumDriveType(idtRemote);
			else
				continue;
			break;
		case 3:
			if (iAttributes & msidbControlAttributesCDROMVolume)
				peVolumes = &m_piServices->EnumDriveType(idtCDROM);
			else
				continue;
			break;
		case 4:
			if (iAttributes & msidbControlAttributesRAMDiskVolume)
				peVolumes = &m_piServices->EnumDriveType(idtRAMDisk);
			else
				continue;
			break;
		case 5:
			if (iAttributes & msidbControlAttributesFloppyVolume)
				peVolumes = &m_piServices->EnumDriveType(idtFloppy);
			else
				continue;
			break;
		}
		PMsiVolume ppiVolume(0);
		unsigned long pcFetched;
		for(;;)
		{
			peVolumes->Next(1, &ppiVolume, &pcFetched);
			if (pcFetched == 0)
			{
				break;
			}
			PMsiVolume piVolume(ppiVolume);
			piVolumesCursor->Reset();
			AssertNonZero(piVolumesCursor->PutMsiData(1, piVolume));
			// put back assert when we distinguish between floppy and removable
			/*AssertNonZero(*/piVolumesCursor->Insert()/*)*/;
		}
	}
	return 0;
}

IMsiRecord* CMsiControl::UnloadRichEdit()
{
	if ( m_hRichEd20 && !WIN::FreeLibrary(m_hRichEd20) )
	{
#ifdef DEBUG
		DWORD dwError = GetLastError();
#endif
		AssertSz(GetLastError() == ERROR_MOD_NOT_FOUND,
					TEXT("FreeLibrary on RichEdit failed"));
	}
	
	m_hRichEd20 = 0;
	
	return 0;
}

IMsiRecord* CMsiControl::LoadRichEdit()
{
	HINSTANCE hInst = NULL;

	if(m_hRichEd20)
		return 0;

	while ( !hInst )
	{
		hInst = WIN::LoadLibrary(TEXT("RICHED20.DLL"));
		if ( hInst )
			break;

		DWORD dwError = GetLastError();
		if ( dwError == ERROR_COMMITMENT_LIMIT ||
			  dwError == ERROR_NO_SYSTEM_RESOURCES ||
			  dwError == ERROR_NOT_ENOUGH_MEMORY )
		{
			int imtFatalOutOfMemory = imtInternalExit + imtOk +
											  imtDefault1 + imtIconWarning;
			m_piEngine->MessageNoRecord(imtEnum(imtFatalOutOfMemory));
		}
		else
		{
			IMsiRecord* piError = PostError(Imsg(idbgRichEdLoad), dwError);
			m_piEngine->Message(imtInfo, *piError);
			return piError;
		}
	}
	m_hRichEd20 = hInst;
	return 0;
}


IMsiRecord* CMsiControl::PostError(IErrorCode iErr)
{
	IMsiRecord* piRec = &m_piServices->CreateRecord(1);
	ISetErrorCode(piRec, iErr);
	return piRec;
}


IMsiRecord* CMsiControl::PostError(IErrorCode iErr, const IMsiString& riString)
{
	IMsiRecord* piRec = &m_piServices->CreateRecord(2);
	ISetErrorCode(piRec, iErr);
	AssertNonZero(piRec->SetMsiString(2, riString));
	return piRec;
}


IMsiRecord* CMsiControl::PostError(IErrorCode iErr, int i)
{
	IMsiRecord* piRec = &m_piServices->CreateRecord(2);
	ISetErrorCode(piRec, iErr);
	AssertNonZero(piRec->SetInteger(2, i));
	return piRec;
}

IMsiRecord* CMsiControl::PostError(IErrorCode iErr, const IMsiString& riString2, const IMsiString& riString3)
{
	IMsiRecord* piRec = &m_piServices->CreateRecord(3);
	ISetErrorCode(piRec, iErr);
	AssertNonZero(piRec->SetMsiString(2, riString2));
	AssertNonZero(piRec->SetMsiString(3, riString3));
	return piRec;
}


IMsiRecord* CMsiControl::PostError(IErrorCode iErr, const IMsiString& riString2, const IMsiString& riString3, const IMsiString& riString4)
{
	IMsiRecord* piRec = &m_piServices->CreateRecord(4);
	ISetErrorCode(piRec, iErr);
	AssertNonZero(piRec->SetMsiString(2, riString2));
	AssertNonZero(piRec->SetMsiString(3, riString3));
	AssertNonZero(piRec->SetMsiString(4, riString4));
	return piRec;
}

IMsiRecord* CMsiControl::PostError(IErrorCode iErr, const IMsiString& riString2, const IMsiString& riString3, const IMsiString& riString4, const IMsiString& riString5)
{
	IMsiRecord* piRec = &m_piServices->CreateRecord(5);
	ISetErrorCode(piRec, iErr);
	AssertNonZero(piRec->SetMsiString(2, riString2));
	AssertNonZero(piRec->SetMsiString(3, riString3));
	AssertNonZero(piRec->SetMsiString(4, riString4));
	AssertNonZero(piRec->SetMsiString(5, riString5));
	return piRec;
}

IMsiRecord* CMsiControl::PostError(IErrorCode iErr, const IMsiString& riString2, const IMsiString& riString3, const IMsiString& riString4, const IMsiString& riString5, const IMsiString& riString6)
{
	IMsiRecord* piRec = &m_piServices->CreateRecord(6);
	ISetErrorCode(piRec, iErr);
	AssertNonZero(piRec->SetMsiString(2, riString2));
	AssertNonZero(piRec->SetMsiString(3, riString3));
	AssertNonZero(piRec->SetMsiString(4, riString4));
	AssertNonZero(piRec->SetMsiString(5, riString5));
	AssertNonZero(piRec->SetMsiString(6, riString6));
	return piRec;
}

//
// We do this quite a bit, locate the code in one place
//
IMsiRecord* CMsiControl::PostErrorUnsupAttrib(const ICHAR *pszType)
{
	IMsiRecord* piRec = &m_piServices->CreateRecord(4);
	ISetErrorCode(piRec, Imsg(idbgUnsupportedControlAttrib));
	AssertNonZero(piRec->SetMsiString(2, *m_strDialogName));
	AssertNonZero(piRec->SetMsiString(3, *m_strKey));
	AssertNonZero(piRec->SetString(4, pszType));
	return piRec;
}


IMsiRecord* CMsiControl::PostErrorDlgKey(IErrorCode iErr, int i1)
{
	IMsiRecord* piRec = &m_piServices->CreateRecord(4);
	ISetErrorCode(piRec, iErr);
	AssertNonZero(piRec->SetMsiString(2, *m_strDialogName));
	AssertNonZero(piRec->SetMsiString(3, *m_strKey));
	AssertNonZero(piRec->SetInteger(4, i1));
	return piRec;
}

IMsiRecord* CMsiControl::PostErrorDlgKey(IErrorCode iErr)
{
	IMsiRecord* piRec = &m_piServices->CreateRecord(3);
	ISetErrorCode(piRec, iErr);
	AssertNonZero(piRec->SetMsiString(2, *m_strDialogName));
	AssertNonZero(piRec->SetMsiString(3, *m_strKey));
	return piRec;
}


IMsiRecord* CMsiControl::PostErrorDlgKey(IErrorCode iErr, const IMsiString &str1, int i1)
{
	IMsiRecord* piRec = &m_piServices->CreateRecord(5);
	ISetErrorCode(piRec, iErr);
	AssertNonZero(piRec->SetMsiString(2, *m_strDialogName));
	AssertNonZero(piRec->SetMsiString(3, *m_strKey));
	AssertNonZero(piRec->SetMsiString(4, str1));
	AssertNonZero(piRec->SetInteger(5, i1));
	return piRec;
}

IMsiRecord* CMsiControl::StretchBitmap(const IMsiString& riNameString, int iWidth, int iHeight, Bool fFixedSize, WindowRef pWnd, HBITMAP& rhBitmap)
{
	HBITMAP hBitmap = 0;
	rhBitmap = 0;

	HDC hdc = WIN::GetDC (pWnd);

	HDC hDCMem = NULL;
	HDC hDCMem2 = NULL;

	hDCMem = WIN::CreateCompatibleDC(hdc);
	hDCMem2 = WIN::CreateCompatibleDC(hdc);

	if ( ! hdc || ! hDCMem || ! hDCMem2 )
		return 0;

	if (m_fImageHandle)
	{
		hBitmap = (HBITMAP)::GetInt64Value(riNameString.GetString(), NULL);
	}
	else
	{
		Ensure(UnpackBitmap(riNameString, *&hBitmap));
	}

	if (!hBitmap)
		return 0;

	BITMAP bitmap;
	POINT bSize, origin;

	HBITMAP hbmSave1 = (HBITMAP) WIN::SelectObject(hDCMem, hBitmap);
	WIN::GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bitmap);
	bSize.x = bitmap.bmWidth;
	bSize.y = bitmap.bmHeight;
	AssertNonZero(WIN::DPtoLP(hDCMem2, &bSize, 1));
	origin.x = origin.y = 0;
	AssertNonZero(WIN::DPtoLP(hDCMem2, &origin, 1));
	rhBitmap = WIN::CreateCompatibleBitmap(hDCMem, iWidth, iHeight);
	HBITMAP hbmSave2 = (HBITMAP) WIN::SelectObject(hDCMem2, rhBitmap);
	// draw bitmap onto device context
	PMsiRecord piPaletteRecord = &m_piServices->CreateRecord(1);
	AssertRecord(m_piDialog->AttributeEx(fFalse, dabPalette, *piPaletteRecord));
	HPALETTE hPalette = (HPALETTE) piPaletteRecord->GetHandle(1);
	HPALETTE hPalSave = 0;
	Bool fInFront = ToBool(WIN::GetParent (m_pWnd) == WIN::GetActiveWindow ());

	if (fFixedSize)
	{
		int iXOriginDest = 0;
		int iYOriginDest = 0;
		int iWidthDest = 0;
		int iHeightDest = 0;
		int iXOriginSrc = 0;
		int iYOriginSrc = 0;
		int iWidthSrc = 0;
		int iHeightSrc = 0;
		if (iWidth > bSize.x)
		{
			iXOriginDest = (iWidth - bSize.x) / 2;
			iWidthDest = bSize.x;
			iXOriginSrc = origin.x;
			iWidthSrc = bSize.x;
		}
		else
		{
			iXOriginDest = 0;
			iWidthDest = iWidth;
			iXOriginSrc = origin.x + (bSize.x - iWidth) / 2;
			iWidthSrc = iWidth;
		}
		if (iHeight > bSize.y)
		{
			iYOriginDest = (iHeight -bSize.y) / 2;
			iHeightDest = bSize.y;
			iYOriginSrc = origin.y;
			iHeightSrc  = bSize.y;
		}
		else
		{
			iYOriginDest = 0;
			iHeightDest = iHeight;
			iYOriginSrc = origin.y + (bSize.y - iHeight) / 2;
			iHeightSrc = iHeight;
		}
		HBRUSH hBrush = WIN::CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
		HBRUSH hBrushSave = (HBRUSH) WIN::SelectObject(hDCMem2, hBrush);
		{
			RECT Rect;
			AssertNonZero(WIN::SetRect(&Rect, 0, 0, iWidth + 1, iHeight + 1));
			AssertNonZero(WIN::FillRect(hDCMem2, &Rect, hBrush));
		}
		WIN::SelectObject(hDCMem2, hBrushSave);
		AssertNonZero(WIN::DeleteObject(hBrush));

		if (hPalette)
		{
			//!! Palette switching should be done only on WM_PALETTE* messages
			//AssertNonZero(hPalSave = WIN::SelectPalette(hDCMem2, hPalette, !fInFront));
			//AssertNonZero (GDI_ERROR != WIN::RealizePalette(hDCMem2));
		}
	//	AssertNonZero(WIN::StretchBlt(hDCMem2, iXOriginDest, iYOriginDest, iWidthDest, iHeightDest, hDCMem, iXOriginSrc, iYOriginSrc, iWidthSrc, iHeightSrc, SRCCOPY));
		AssertNonZero(WIN::BitBlt(hDCMem2, iXOriginDest, iYOriginDest, iWidthDest, iHeightDest, hDCMem, iXOriginSrc, iYOriginSrc, SRCCOPY));
	}
	else
	{
		if (hPalette)
		{
			//!! Palette switching should be done only on WM_PALETTE* messages
			//AssertNonZero(hPalSave = WIN::SelectPalette(hDCMem2, hPalette, !fInFront));
			//AssertNonZero (GDI_ERROR != WIN::RealizePalette(hDCMem2));
		}
		AssertNonZero(WIN::StretchBlt(hDCMem2, 0, 0, iWidth, iHeight, hDCMem, origin.x, origin.y, bSize.x, bSize.y, SRCCOPY));
	}
	// cleanup
	if (hPalSave)
		WIN::SelectPalette (hDCMem2, hPalSave, !fInFront);
	WIN::SelectObject (hDCMem, hbmSave1);
	WIN::SelectObject (hDCMem2, hbmSave2);
	AssertNonZero(WIN::DeleteDC(hDCMem));
	AssertNonZero(WIN::DeleteDC(hDCMem2));
	//AssertNonZero(WIN::DeleteDC(hdc));	
	//WIN::EndPaint(pWnd, &ps);
	WIN::ReleaseDC(pWnd, hdc);
	AssertNonZero(WIN::DeleteObject((HGDIOBJ) hBitmap));  
	return 0;
}

BOOL IsWinDIB (LPBITMAPINFOHEADER pBIH)
{
	if (pBIH-> biSize != sizeof(BITMAPINFOHEADER)) {
		return (FALSE);
	}
	return (TRUE);
}

WORD NumDIBColorEntries (LPBITMAPINFO lpBmpInfo)
{
	LPBITMAPINFOHEADER lpBIH;
	LPBITMAPCOREHEADER lpBCH;
	WORD wColors, wBitCount;

	if (!lpBmpInfo)
		return 0;

	lpBIH = &(lpBmpInfo-> bmiHeader);
	lpBCH = (LPBITMAPCOREHEADER) lpBIH;

	if (IsWinDIB(lpBIH))
		wBitCount = lpBIH-> biBitCount;
	else
		wBitCount = lpBCH-> bcBitCount;

	switch (wBitCount) {
	case 1:
		wColors =2;
		break;
	case 4:
		wColors = 16;
		break;
	case 8:
		wColors = 256;
		break;
	default:
		wColors = 0;
		break;
	}

	if (IsWinDIB(lpBIH)) {
		if (lpBIH-> biClrUsed != 0) {
			wColors = (WORD) lpBIH-> biClrUsed;
		}
	}

	return wColors;

}

HPALETTE CreateDIBPalette (LPBITMAPINFO lpBmpInfo)
{
	LPBITMAPINFOHEADER	lpBmpInfoHdr;
	HANDLE hPalMem;
	LOGPALETTE* pPal;
	HPALETTE hPal;
	LPRGBQUAD lpRGB;
	int iColors;
	int i;

	lpBmpInfoHdr = (LPBITMAPINFOHEADER) lpBmpInfo;
	if (!IsWinDIB(lpBmpInfoHdr)) return NULL;

	lpRGB = (LPRGBQUAD) ((LPSTR) lpBmpInfoHdr + (WORD) lpBmpInfoHdr-> biSize);
	iColors = NumDIBColorEntries (lpBmpInfo);
	if (!iColors) return NULL;

	hPalMem = LocalAlloc (LMEM_MOVEABLE, sizeof(LOGPALETTE) + iColors * sizeof(PALETTEENTRY));
	if (!hPalMem) return NULL;
	pPal = (LOGPALETTE*) LocalLock (hPalMem);
	pPal-> palVersion = 0x300;
	pPal-> palNumEntries = (WORD) iColors; // table size
	for (i = 0; i < iColors; i++) {
		pPal-> palPalEntry [i].peRed = lpRGB[i].rgbRed;
		pPal-> palPalEntry [i].peGreen = lpRGB[i].rgbGreen;
		pPal-> palPalEntry [i].peBlue = lpRGB[i].rgbBlue;
		pPal-> palPalEntry [i].peFlags = 0;
	}

	hPal = CreatePalette (pPal);
	LocalUnlock (hPalMem);
	LocalFree (hPalMem);

	return (hPal);
}

IMsiRecord* CMsiControl::DoUnpackBitmap (const char far *pData, HBITMAP& rhBitmap)
{
	// Retrieve the BITMAPFILEHEADER structure
	BITMAPFILEHEADER* pbmfh = (BITMAPFILEHEADER*) pData;
	const BYTE far *lpBMPData = (const BYTE far *)(pData + sizeof(BITMAPFILEHEADER));
	LPBYTE dataBits;
	LPBITMAPINFOHEADER pbmih;

#ifdef _WIN64
	DWORD dwSize = pbmfh->bfSize - sizeof(BITMAPFILEHEADER);
	CTempBuffer<BYTE, 1024> rgbBitmap;
	rgbBitmap.SetSize(dwSize);
	// this trick is to fix the alignment error
	memcpy(rgbBitmap, lpBMPData, dwSize);

	// Retrieve the BITMAPFILEHEADER structure.
	pbmih = (LPBITMAPINFOHEADER)(LPBYTE)rgbBitmap;

	// get pointer to actual bitmap data
	dataBits = (LPBYTE)((LPBYTE)rgbBitmap + pbmfh->bfOffBits - sizeof(BITMAPFILEHEADER));
#else
	// Retrieve the BITMAPFILEHEADER structure.
	pbmih = (LPBITMAPINFOHEADER)lpBMPData;

	// get pointer to actual bitmap data
	dataBits = (LPBYTE)((LONG_PTR) lpBMPData + (LONG_PTR) pbmfh->bfOffBits - sizeof(BITMAPFILEHEADER));	//--merced: changed LONG to LONG_PTR, twice.
#endif // _WIN64

	// get a screen device context
	HDC hDC = GetDC(0);

	// create the bitmap in the device context
	rhBitmap = CreateDIBitmap(hDC, pbmih, CBM_INIT,
									  (LPVOID)dataBits, (LPBITMAPINFO)pbmih, DIB_RGB_COLORS);

	PMsiRecord piPaletteRecord = &m_piServices->CreateRecord(1);
	AssertRecord(m_piDialog->AttributeEx(fFalse, dabPalette, *piPaletteRecord));
	if (!piPaletteRecord->GetInteger(1))
	{
		piPaletteRecord->SetHandle(1, (HANDLE)CreateDIBPalette ((LPBITMAPINFO) pbmih));
		AssertRecord(m_piDialog->AttributeEx(fTrue, dabPalette, *piPaletteRecord));
	}

	//perform cleanup
	ReleaseDC(0, hDC);

	return rhBitmap ? 0 : PostError(Imsg(idbgNotBitmap), *m_strKey);
}

IMsiRecord* CMsiControl::DoUnpackJPEG (const char far *pData, unsigned int len, HBITMAP& rhBitmap)
{
	// Note that this is a little evil and probably should be cleaned up, but
	// that involves spreading const through the JPEG code.
	CDarwinDatasource dataSource((unsigned char *)pData, len);
	CDarwinDecompressor decompressor;

	HPALETTE hPalette = 0;
	PMsiRecord piPaletteRecord = &m_piServices->CreateRecord(1);
	AssertRecord(m_piDialog->AttributeEx(fFalse, dabUseCustomPalette, *piPaletteRecord));
	Bool fResult = decompressor.Decompress (rhBitmap, hPalette, piPaletteRecord->GetInteger(1) ? fFalse : fTrue, &dataSource);
	AssertRecord(m_piDialog->AttributeEx(fFalse, dabPalette, *piPaletteRecord));
	if (piPaletteRecord->GetInteger(1))
	{
		if (hPalette)
			AssertNonZero(WIN::DeleteObject (hPalette));
	}
	else
	{
		piPaletteRecord->SetHandle(1, (HANDLE) hPalette);
		AssertRecord(m_piDialog->AttributeEx(fTrue, dabPalette, *piPaletteRecord));
	}

	return (fResult ? 0 : PostError(Imsg(idbgNotBitmap), *m_strKey));
}

static inline Bool IsBitmap (const void *p)
{
	return ToBool(((PBITMAPFILEHEADER) p)-> bfType == 0x4d42);	// 'BM'
}

static inline Bool IsJPEG (const void *p)
{
	return ToBool(* (long UNALIGNED *)((char*) p + 6) == 0x4649464a); // 'JFIF';
}

IMsiRecord* CMsiControl::UnpackBitmap(const IMsiString& riNameString, HBITMAP& rhBitmap)
{
	PMsiRecord piErrorRecord(0);
	PMsiStream pStream(0);
	if (piErrorRecord = GetBinaryStream(riNameString, *&pStream))
	{
		m_piEngine->Message(imtInfo, *piErrorRecord);
		rhBitmap = 0;
		return 0;
	}
	PMsiRecord piReturn(0);
	// temp untill the database is fixed
/*	PMsiView piBinaryView(0);
	PMsiStream pStream(0);// MUST be declared AFTER piBinaryView to compensate for the
	// inadequacy of the database to open a stream twice.
	Ensure(StartView(sqlBinary, riNameString, *&piBinaryView));
	PMsiRecord piReturn = piBinaryView->Fetch();
	if (!piReturn)
	{
		piReturn = PostError(Imsg(idbgViewExecute), MsiString(*pcaTablePBinary));
		m_piEngine->Message(imtInfo, *piReturn);
		return 0;
	}

	pStream = (IMsiStream*) piReturn->GetMsiData(1);
	if (!pStream)
	{
		rhBitmap = 0;
		piReturn = PostError(Imsg(idbgNotBitmap), riNameString);
		m_piEngine->Message(imtInfo, *piReturn);
		return 0;
	}*/

#ifdef DEBUG
	ICHAR rgchDebug[256];
	StringCchPrintf(rgchDebug, sizeof(rgchDebug)/sizeof(ICHAR), TEXT("Stream %s is gone."), riNameString.GetString());
	AssertSz(pStream, rgchDebug);
#endif //DEBUG

	unsigned int len = pStream->Remaining();

	CTempBuffer<char, 1024> rgbBuf;
	rgbBuf.SetSize(len);
	pStream->GetData(rgbBuf, len);
	if (IsBitmap(rgbBuf))
		piReturn = DoUnpackBitmap(rgbBuf, rhBitmap);
	else if (IsJPEG (rgbBuf))
		piReturn = DoUnpackJPEG(rgbBuf, len, rhBitmap);
	else
		piReturn = PostError(Imsg(idbgNotBitmap), *m_strKey);

	if (piReturn)
	{
		m_piEngine->Message(imtInfo, *piReturn);
		rhBitmap = 0;
	}
	
	return 0;
}

IMsiRecord* CMsiControl::UnpackIcon(const IMsiString& riNameString, HICON& rhIcon, int iWidth, int iHeight, Bool fFixedSize)
{
	if (m_fImageHandle)
	{
		riNameString.AddRef();
		HICON hIcon = (HICON) ::GetInt64Value((const ICHAR *)MsiString(riNameString), NULL);
		if (!fFixedSize && m_iSize)
			rhIcon = (HICON) WIN::CopyImage(hIcon, IMAGE_ICON, m_iSize, m_iSize, 0);
		return 0;
	}

	PMsiRecord piErrorRecord(0);
	
	// temp untill database is fixed
	//PMsiView piBinaryView(0);
	PMsiStream pStream(0);// MUST be declared AFTER piBinaryView to compensate for the
	// inadequacy of the database to open a stream twice.
/*	Ensure(StartView(sqlBinary, riNameString, *&piBinaryView));
	PMsiRecord piReturn = piBinaryView->Fetch();
	if (!piReturn)
	{
		piReturn = PostError(Imsg(idbgViewExecute), MsiString(*pcaTablePBinary));
		m_piEngine->Message(imtInfo, *piReturn);
		return 0;
	}

	pStream = (IMsiStream*) piReturn->GetMsiData(1);
	if (!pStream)
	{
		rhIcon = 0;
		piReturn = PostError(Imsg(idbgNotIcon), riNameString);
		m_piEngine->Message(imtInfo, *piReturn);
		return 0;
	}*/

	if (piErrorRecord = GetBinaryStream(riNameString, *&pStream))
	{
		m_piEngine->Message(imtInfo, *piErrorRecord);
		rhIcon = 0;
		return 0;
	}
#ifdef DEBUG
	ICHAR rgchDebug[256];
	StringCchPrintf(rgchDebug, sizeof(rgchDebug)/sizeof(ICHAR), TEXT("Stream %s is gone."), riNameString.GetString());
	AssertSz(pStream, rgchDebug);
#endif //DEBUG

	ICONRESOURCE* pIR;
	if (piErrorRecord = ReadIconFromICOFile(riNameString, pStream, *&pIR))
	{
		m_piEngine->Message(imtInfo, *piErrorRecord);
		rhIcon = 0;
		return 0;
	}
	if (pIR == 0)
	{
		rhIcon = 0;
		return 0;
	}
	int iIndex = -1;
	if (m_iSize)
	{
		for (int i = 0; i < pIR->nNumImages; i++)
		{
			if (pIR->IconImages[i].Width == m_iSize && pIR->IconImages[i].Height == m_iSize)   // find the image of the right size
			{
				iIndex = i;
				break;
			}
		}
		if (iIndex < 0)
		{
			PMsiRecord piReturn = PostErrorDlgKey(Imsg(idbgIconWrongSize), riNameString, m_iSize);
			m_piEngine->Message(imtInfo, *piReturn);
			iIndex = 0;
		}
	}
	else
	{
		iIndex = 0;
	}

	LPICONIMAGE lpIcon = &pIR->IconImages[iIndex];
	if (g_fChicago)
	{
		rhIcon = (fFixedSize && m_iSize) ? CreateIconFromResourceEx(lpIcon->lpBits, lpIcon->dwNumBytes, fTrue, 0x00030000, m_iSize, m_iSize, 0)	
			: CreateIconFromResourceEx(lpIcon->lpBits, lpIcon->dwNumBytes, fTrue, 0x00030000, iWidth, iHeight, 0);
	}
	else
	{
        // We would break on NT if we try with a 16bpp image
        if(lpIcon->lpbi->bmiHeader.biBitCount != 16)
        {	
            rhIcon = CreateIconFromResource(lpIcon->lpBits, lpIcon->dwNumBytes, fTrue, 0x00030000);
        }
    }
	for (int i = 0; i < pIR->nNumImages; i++)
    {
		delete[] pIR->IconImages[i].lpBits;
	}
	delete[] pIR;
	return 0;
}

IMsiRecord* CMsiControl::MyDrawIcon(HDC hdc, LPRECT pRect, HICON hIcon, Bool fFixedSize)
{
	int iLeft = pRect->left;
	int iTop = pRect->top;
	int iWidth = pRect->right - pRect->left;
	int iHeight = pRect->bottom - pRect->top;
	if (fFixedSize && m_iSize && iWidth >= m_iSize && iHeight >= m_iSize) // if the icon is larger than the available room, we won't honour the fixedsize flag
	{  
		iLeft += (iWidth - m_iSize)/2;
		iTop += (iHeight - m_iSize)/2;
		iWidth = m_iSize;
		iHeight = m_iSize;
	}
	//AssertNonZero(WIN::DrawIconEx(hdc, iLeft, iTop, hIcon, iWidth, iHeight, 0, 0, DI_NORMAL));
	WIN::DrawIconEx(hdc, iLeft, iTop, hIcon, iWidth, iHeight, 0, 0, DI_NORMAL);
	return 0;
}

void CMsiControl::GetIconSize(int iAttribute)
{
	m_iSize = 0;
	int iSizeBits = iAttribute & msidbControlAttributesIconSize48;
	if(iSizeBits == msidbControlAttributesIconSize16)
		m_iSize = 16;
	else if(iSizeBits == msidbControlAttributesIconSize32)
		m_iSize = 32;
	else if(iSizeBits == msidbControlAttributesIconSize48)
		m_iSize = 48;
}

IMsiRecord* CMsiControl::ChangeFontStyle(HDC hdc)
{
	return ChangeFontStyle(hdc, *m_strCurrentStyle, m_pWnd);
}

int CALLBACK LookForRightFont(ENUMLOGFONTEX* lpelfe,      // pointer to logical-font data
										NEWTEXTMETRIC* /*lpntme*/,  // pointer to physical-font data
										int /*FontType*/,           // type of font
										LPARAM lParam)              // application-defined data
{
	LOGFONT* pLogFont = (LOGFONT*)lParam;
	if ( pLogFont->lfCharSet != DEFAULT_CHARSET &&
		  pLogFont->lfCharSet != lpelfe->elfLogFont.lfCharSet )
		//  wrong character set
		return 1;
	else if ( !(pLogFont->lfFaceName && *pLogFont->lfFaceName) )
		//  the requested font name is empty => any font will do.
		return 0;
	else if ( !IStrCompI(pLogFont->lfFaceName, (const ICHAR*)lpelfe->elfLogFont.lfFaceName) )
		//  the requested font's name matches the found one's name - cool!
		return 0;
	else
		return 1;
}

const IMsiString& CMsiControl::GimmeUserFontStyle(const IMsiString& strStyle)
{
	//  Note: this function shouldn't be overwritten in any descendant control class.

#ifdef DEBUG
	if ( strStyle.Compare(iscEnd, szUserLangTextStyleSuffix) )
	{
		ICHAR rgchDebug[MAX_PATH];
		StringCchPrintf(rgchDebug, sizeof(rgchDebug)/sizeof(ICHAR), 
					TEXT("Unexpected '%s' at the end of '%s' font style in CMsiControl::GimmeUserFontStyle()"),
					szUserLangTextStyleSuffix, strStyle.GetString());
		AssertSz(0, rgchDebug);
	}
#endif  //  DEBUG

	//  WARNING: any changes in the logic in this function, need to be
	//  coordinated with the logic in CMsiControl::ChangeFontStyle() !!!
	if ( !m_fUseDbLang &&
		  (m_piDatabase->GetANSICodePage() != m_piHandler->GetUserCodePage()) )
	{
		MsiString strUserStyle(strStyle); strStyle.AddRef();
		strUserStyle += szUserLangTextStyleSuffix;
		return strUserStyle.Return();
	}
	else
	{
		strStyle.AddRef();
		return strStyle;
	}
}

IMsiRecord* CMsiControl::ChangeFontStyle(HDC hdc, const IMsiString& ristrStyle,
													  const WindowRef pWnd)
{
	HFONT hNewFont = 0;
	PMsiRecord piErrorRecord(0);
	if (ristrStyle.TextSize())
	{
		bool fInsertNew = false;
		PMsiRecord piReturn(0);
		MsiString strFontStyle = GimmeUserFontStyle(ristrStyle);
		bool fSameNames = !IStrComp(strFontStyle, ristrStyle.GetString());
		if ( !fSameNames )
		{
			//  I'm looking first for the user language font (the suffixed name)
			piReturn = m_piHandler->GetTextStyle(strFontStyle);
			if ( !piReturn )
				fInsertNew = true;
		}
		if ( fSameNames || !piReturn )
			piReturn = m_piHandler->GetTextStyle(&ristrStyle);
		if (!piReturn)
		{
			piErrorRecord = PostError(Imsg(idbgViewExecute), *MsiString(*pcaTablePTextStyle));
			m_piEngine->Message(imtInfo, *piErrorRecord);
			return 0;
		}
		int iStyleBits = piReturn->GetInteger(itabTSStyleBits);

		bool fCreateFont = fInsertNew;
		int iAbs = piReturn->GetInteger(itabTSAbsoluteSize);
		if ( iAbs == iMsiStringBadInteger )
		{
			iAbs = Round(MulDiv(piReturn->GetInteger(itabTSSize), WIN::GetDeviceCaps(hdc, LOGPIXELSY), 72) *
							 m_piHandler->GetUIScaling());
			fCreateFont = fTrue;
		}
		if ( fCreateFont )
		{
			ICHAR rgchDebug[256];
			LOGFONT lf;

			//  WARNING: any changes in the logic in the 3 lines below need to be
			//  coordinated with the logic in CMsiControl::GimmeUserFontStyle() !!!
			UINT uCodePage = m_fUseDbLang ? m_piDatabase->GetANSICodePage() :
													  m_piHandler->GetUserCodePage();
			switch ( uCodePage )
			{
			case 0:			//  language neutral database
				lf.lfCharSet = DEFAULT_CHARSET;
				break;
			case 874:
				lf.lfCharSet = THAI_CHARSET;
				break;
			case 932:
				lf.lfCharSet = SHIFTJIS_CHARSET;
				break;
			case 936:
				lf.lfCharSet = GB2312_CHARSET;
				break;
			case 949:		//  Korean
				lf.lfCharSet = HANGEUL_CHARSET;
				break;
			case 950:
				lf.lfCharSet = CHINESEBIG5_CHARSET;
				break;
			case 1250:
				lf.lfCharSet = EASTEUROPE_CHARSET;
				break;
			case 1251:
				lf.lfCharSet = RUSSIAN_CHARSET;
				break;
			case 1252:
				lf.lfCharSet = ANSI_CHARSET;
				break;
			case 1253:
				lf.lfCharSet = GREEK_CHARSET;
				break;
			case 1254:
				lf.lfCharSet = TURKISH_CHARSET;
				break;
			case 1255:
				lf.lfCharSet = HEBREW_CHARSET;
				break;
			case 1256:
				lf.lfCharSet = ARABIC_CHARSET;
				break;
			case 1257:
				lf.lfCharSet = BALTIC_CHARSET;
				break;
			case 1258:
				lf.lfCharSet = VIETNAMESE_CHARSET;
				break;
			default:
				{
				lf.lfCharSet = DEFAULT_CHARSET;
				StringCchPrintf(rgchDebug, sizeof(rgchDebug)/sizeof(ICHAR), 
							TEXT("'%u' is an unknown code page in CMsiControl::ChangeFontStyle()"),
							uCodePage);
				AssertSz(0, rgchDebug);
				}
				break;
			}
			lf.lfWidth = 0;
			lf.lfEscapement = 0;
			lf.lfOrientation = 0;
			lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
			//  0x40 disables font association on FE machines
			lf.lfClipPrecision = CLIP_DEFAULT_PRECIS | 0x40;
			lf.lfQuality = DEFAULT_QUALITY;
			lf.lfPitchAndFamily = DEFAULT_PITCH;
			lf.lfHeight = -iAbs;
			lf.lfWeight = iStyleBits & msidbTextStyleStyleBitsBold ? FW_BOLD : FW_NORMAL;
			lf.lfItalic = (BYTE)ToBool(iStyleBits & msidbTextStyleStyleBitsItalic);
			lf.lfUnderline = (BYTE)ToBool(iStyleBits & msidbTextStyleStyleBitsUnderline);
			lf.lfStrikeOut = (BYTE)ToBool(iStyleBits & msidbTextStyleStyleBitsStrike);
			StringCbCopy(lf.lfFaceName, sizeof(lf.lfFaceName), MsiString(piReturn->GetString(itabTSFaceName)));
			if ( (lf.lfFaceName && *lf.lfFaceName) &&
				  EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC)LookForRightFont,
										   (LPARAM)&lf, 0) )
			{
				//  there is no such font on this machine.  I go
				//  instead for one that supports the current code page.
				bool fFEOs = false;
#ifdef UNICODE
				//  English name = MS PGothic
				static const WCHAR rgchDefaultJapName[] = 
					L"\xFF2D\xFF33\x0020\xFF30\x30B4\x30B7\x30C3\x30AF";
				//  English name = SimSun
				static const WCHAR rgchDefaultSimChinName[] = L"\x5B8B\x4F53";
				//  English name = Gulim
				static const WCHAR rgchDefaultKorName[] = L"\xAD74\xB9BC";
				//  English name = PMingLiU
				static const WCHAR rgchDefaultTradChinName[] = 
					L"\x65B0\x7D30\x660E\x9AD4";
#else
				//  English name = MS PGothic
				static const char rgchDefaultJapName[] = 
					"\x82\x6c\x82\x72\x20\x82\x6f\x83\x53\x83\x56\x83\x62\x83\x4E";
				//  English name = SimSun
				static const char rgchDefaultSimChinName[] = "\xcb\xce\xcc\xe5";
				//  English name = Gulim
				static const char rgchDefaultKorName[] = "\xb1\xbc\xb8\xb2";
				//  English name = PMingLiU
				static const char rgchDefaultTradChinName[] = 
					"\xb7\x73\xb2\xd3\xa9\xfa\xc5\xe9";
#endif
				static const ICHAR rgchDefaultNonFEName[] = TEXT("MS Shell Dlg");  // = system's default dialog font
				ICHAR* szDefaultFont;
				switch ( m_piHandler->GetUserCodePage() )
				{
				case 932:
					{
						fFEOs = true;
						szDefaultFont = (ICHAR*)rgchDefaultJapName;
						break;
					}
				case 936:
					{
						fFEOs = true;
						szDefaultFont = (ICHAR*)rgchDefaultSimChinName;
						break;
					}
				case 949:
					{
						fFEOs = true;
						szDefaultFont = (ICHAR*)rgchDefaultKorName;
						break;
					}
				case 950:
					{
						fFEOs = true;
						szDefaultFont = (ICHAR*)rgchDefaultTradChinName;
						break;
					}
				default:
					{
						szDefaultFont = (ICHAR*)rgchDefaultNonFEName;
						break;
					}
				}
				StringCbCopy(lf.lfFaceName, sizeof(lf.lfFaceName), szDefaultFont);
				if ( fFEOs && piReturn->GetInteger(itabTSSize) == 8 )
					//  8 size fonts look ugly on FE machines so that I enlarge them to 9
					lf.lfHeight	= -Round(MulDiv(9, WIN::GetDeviceCaps(hdc, LOGPIXELSY), 72) *
												m_piHandler->GetUIScaling());

				if ( EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC)LookForRightFont,
												(LPARAM)&lf, 0) )
				{
					StringCbCopy(lf.lfFaceName, sizeof(lf.lfFaceName), TEXT(""));
					if ( EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC)LookForRightFont,
													(LPARAM)&lf, 0) )
					{
						StringCchPrintf(rgchDebug, sizeof(rgchDebug)/sizeof(ICHAR), 
									TEXT("%s%s%s%s size = %d, character set = %d"),
									lf.lfWeight == FW_BOLD ? TEXT(" bold") : TEXT(""),
									lf.lfItalic ? TEXT(" italic") : TEXT(""),
									lf.lfUnderline ? TEXT(" underline") : TEXT(""),
									lf.lfStrikeOut ? TEXT(" strikeout") : TEXT(""),
									lf.lfHeight, lf.lfCharSet);
						piErrorRecord = PostError(Imsg(idbgNoSuchFont), *MsiString(rgchDebug));
						m_piEngine->Message(imtInfo, *piErrorRecord);
					}
				}
			}
			HFONT hFont = WIN::CreateFontIndirect(&lf);
			if (!hFont)
			{
 				piErrorRecord = PostError(Imsg(idbgCannotCreateFont),
 												  *strFontStyle,
 												  *MsiString((int)WIN::GetLastError()));
				m_piEngine->Message(imtInfo, *piErrorRecord);
				return 0;
			}
			//  check what font got actually created
			HDC hDC = WIN::GetDC(m_pWnd);
			WIN::SelectObject(hDC, hFont);
			ICHAR rgchFaceName[LF_FACESIZE];
			AssertNonZero(WIN::GetTextFace(hDC, sizeof(rgchFaceName)/sizeof(rgchFaceName[0]), rgchFaceName));
			StringCchPrintf(rgchDebug, sizeof(rgchDebug)/sizeof(ICHAR),  TEXT("%d"), lf.lfCharSet);
			ICHAR rgchFontSize[33];
			TEXTMETRIC tm;
			WIN::GetTextMetrics(hDC, &tm);
			StringCchPrintf(rgchFontSize, sizeof(rgchFontSize)/sizeof(ICHAR),  TEXT("%ld"), tm.tmHeight);
			WIN::ReleaseDC(m_pWnd, hDC);
			piErrorRecord = PostError(Imsg(idbgCreatedFont), *strFontStyle,
											  *MsiString(rgchFaceName), *MsiString(rgchDebug),
											  *MsiString(rgchFontSize));
			m_piEngine->Message(imtInfo, *piErrorRecord);
			AssertNonZero(m_piHandler->RecordHandle(CWINHND(hFont, iwhtGDIObject)) != -1);
			hNewFont = hFont;
			PMsiView piTextStyleUpdateView(0);
			piErrorRecord =
				m_piDatabase->OpenView(fInsertNew ? sqlTextStyleInsert : sqlTextStyleUpdate,
											  fInsertNew ? ivcInsert : ivcModify, *&piTextStyleUpdateView);
			if (piErrorRecord)
			{
				m_piEngine->Message(imtInfo, *piErrorRecord);
				return 0;
			}
			PMsiRecord piQuery = &m_piServices->CreateRecord(fInsertNew ? 7 : 3);
			if ( fInsertNew )
			{
				AssertNonZero(piQuery->SetMsiString(itabTSTTextStyle, *strFontStyle));
				AssertNonZero(piQuery->SetMsiString(itabTSTFaceName,
																*MsiString(piReturn->GetMsiString(itabTSFaceName))));
				AssertNonZero(piQuery->SetInteger(itabTSTSize,
															 piReturn->GetInteger(itabTSSize)));
				AssertNonZero(piQuery->SetInteger(itabTSTColor,
															 piReturn->GetInteger(itabTSColor)));
				AssertNonZero(piQuery->SetInteger(itabTSTStyleBits,
															 piReturn->GetInteger(itabTSStyleBits)));
				AssertNonZero(piQuery->SetInteger(itabTSTAbsoluteSize, iAbs));
				AssertNonZero(PutHandleDataRecord(piQuery, itabTSTFontHandle, (UINT_PTR)hNewFont));
			}
			else
			{
				AssertNonZero(piQuery->SetInteger(1, iAbs));
				AssertNonZero(PutHandleDataRecord(piQuery, 2, (UINT_PTR)hNewFont));
				AssertNonZero(piQuery->SetMsiString(3, ristrStyle));
			}
			piErrorRecord = piTextStyleUpdateView->Execute(piQuery);
			if (piErrorRecord)
			{
				m_piEngine->Message(imtInfo, *piErrorRecord);
				return 0;
			}
		}
		else
		{
			hNewFont = (HFONT)GetHandleDataRecord(piReturn, itabTSFontHandle);
			Assert(hNewFont);
		}
	}
	else // current style is empty
	{
		hNewFont = 0;
	}
	WIN::SendMessage(pWnd, WM_SETFONT, (WPARAM) hNewFont, MAKELPARAM(fTrue, 0));
	return 0;
}

// decides if volume should be hidden
bool CMsiControl::ShouldHideVolume(int iVolumeID)
{
	if ( !g_fNT4 )
		// not on Win9x
		return false;

	if ( iVolumeID < 1 )
	{
		// should never happen
		Assert(0);
		return true;
	}
	int iBinVolumeID = 1 << (iVolumeID-1);

	// caching the registry value for optimization: since the handler has a limited
	// lifespan it is OK for it not to be sensitive to value changes while it is
	// running; Notepad, IE do cache this value as well.
	static int iHiddenVolumes = -1;
	if ( iHiddenVolumes == -1 )
	{
		PMsiRegKey pRoot = &m_piServices->GetRootKey(rrkCurrentUser, ibtCommon);
		PMsiRegKey pPolicies = &pRoot->CreateChild(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"));
		MsiString strNoDrives;
		PMsiRecord pErr = pPolicies->GetValue(TEXT("NoDrives"), *&strNoDrives);
		if( !pErr && strNoDrives.TextSize() && 
			 strNoDrives.Compare(iscStart, TEXT("#")) )
		{
			// the regkey object prefaces DWORD values with #
			strNoDrives = strNoDrives.Extract(iseAfter, TEXT('#'));
			iHiddenVolumes = strNoDrives;
		}
		else
			// non-existent or non-numeric value
			iHiddenVolumes = 0;
	}
	return (iHiddenVolumes & iBinVolumeID) == iBinVolumeID;
}


//////////////////////////////////////////////////////
// CMsiActiveControl implementation
//////////////////////////////////////////////////////

CMsiActiveControl::CMsiActiveControl(IMsiEvent& riDialog) : CMsiControl(riDialog), m_piPropertiesTable(0)
{
	MsiString strNull;
	m_strIndirectPropertyName = strNull;
	m_strPropertyValue = strNull;
	m_strOriginalValue = strNull;
	m_fInteger = fFalse;
	m_fIndirect = fFalse;
	m_fRefreshProp = fFalse;
}

CMsiActiveControl::~CMsiActiveControl()
{
}

IMsiRecord* CMsiActiveControl::SetPropertyInDatabase()   
{
	Ensure(CheckInitialized ());

	return (SetDBProperty(*m_strPropertyName, *m_strPropertyValue) ? 
			0 : 
			PostError(Imsg(idbgSettingPropertyFailed), *m_strPropertyName));
}

IMsiRecord* CMsiActiveControl::Undo()
{
	Ensure(CheckInitialized ());
	if (m_fIndirect)
	{
		if (!m_piPropertiesTable)
			return 0; // should this ever happen?
		PMsiCursor piPropertiesCursor(0);
		Ensure(::CursorCreate(*m_piPropertiesTable, pcaTableIProperties, fFalse, *m_piServices, *&piPropertiesCursor)); 
		while (piPropertiesCursor->Next())
		{
			if (!SetDBProperty(*MsiString(piPropertiesCursor->GetString(itabPRProperty)), *MsiString(piPropertiesCursor->GetString(itabPRValue))))
				return PostError(Imsg(idbgSettingPropertyFailed), *MsiString(piPropertiesCursor->GetString(itabPRProperty)));
		}
	}
	else
	{
		if (!SetDBProperty(*m_strPropertyName, *m_strOriginalValue))
			return PostError(Imsg(idbgSettingPropertyFailed), *m_strPropertyName);
	}
	return 0;
}

IMsiRecord* CMsiActiveControl::GetPropertyFromDatabase()    
{
	Ensure(CMsiControl::GetPropertyFromDatabase ());
	return (SetPropertyValue (*MsiString(GetDBProperty(m_strPropertyName)), fFalse));
}

IMsiRecord* CMsiActiveControl::GetIndirectPropertyFromDatabase()    
{
	Ensure(CMsiControl::GetIndirectPropertyFromDatabase ());
	if (!m_fIndirect)
		return 0;
	return (SetIndirectPropertyValue (*MsiString(GetDBProperty(m_strIndirectPropertyName))));
}

IMsiRecord* CMsiActiveControl::RefreshProperty ()
{
	m_fRefreshProp = fTrue;
	PMsiRecord piRecord = SetPropertyValue(*MsiString(GetPropertyValue()), fTrue);
	m_fRefreshProp = fFalse;
	if (piRecord)
	{
		piRecord-> AddRef ();
	}

	return (piRecord);
}

IMsiRecord* CMsiActiveControl::WindowCreate(IMsiRecord& riRecord)
{
	Ensure(CMsiControl::WindowCreate(riRecord));
	if (m_fPreview)
		return 0;
	int iAttributes = riRecord.GetInteger(itabCOAttributes);
	m_fInteger = ToBool(iAttributes & msidbControlAttributesInteger);
	m_fIndirect = ToBool(iAttributes & msidbControlAttributesIndirect);
	MsiString strRawPropertyName = riRecord.GetMsiString(itabCOProperty);
	strRawPropertyName = m_piEngine->FormatText(*strRawPropertyName);
	if (m_fIndirect)
	{
		m_strIndirectPropertyName = strRawPropertyName;
		m_strPropertyName = GetDBProperty(m_strIndirectPropertyName);
	}
	else
	{
		m_strPropertyName = strRawPropertyName;
	}
	if (m_strPropertyName.TextSize() == 0)
	{
		return PostErrorDlgKey(Imsg(idbgNoControlProperty));
	}
	
	m_strPropertyValue = GetDBProperty(m_strPropertyName);
	m_strOriginalValue = m_strPropertyValue;
	if (m_fIndirect)
	{
		Ensure(CreateTable(pcaTableIProperties, *&m_piPropertiesTable));
		::CreateTemporaryColumn(*m_piPropertiesTable, icdString + icdPrimaryKey, itabPRProperty);
		::CreateTemporaryColumn(*m_piPropertiesTable, icdString + icdNullable, itabPRValue);
		PMsiCursor piPropertiesCursor(0);
		Ensure(::CursorCreate(*m_piPropertiesTable, pcaTableIProperties, fFalse, *m_piServices, *&piPropertiesCursor)); 
		AssertNonZero(piPropertiesCursor->PutString(itabPRProperty, *m_strPropertyName));
		AssertNonZero(piPropertiesCursor->PutString(itabPRValue, *m_strPropertyValue));
		AssertNonZero(piPropertiesCursor->Insert());
	}
	Ensure(ValidateProperty(*m_strPropertyValue));
	return 0;
}


IMsiRecord* CMsiActiveControl::GetIndirectPropertyName(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeIndirectPropertyName));
	riRecord.SetMsiString(1, *m_strIndirectPropertyName);
	return 0;
}

IMsiRecord* CMsiActiveControl::GetPropertyValue(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributePropertyValue));
	riRecord.SetMsiString(1, *m_strPropertyValue);

	return 0;
}

IMsiRecord* CMsiActiveControl::SetPropertyValue(IMsiRecord& riRecord)
{	
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributePropertyValue));
	Ensure(SetPropertyValue (*MsiString(riRecord.GetMsiString(1)), fTrue));
	return 0;
}

IMsiRecord* CMsiActiveControl::SetPropertyValue(const IMsiString& riValueString, Bool fCallPropChanged)
{

	if (m_fRefreshProp ||
		(!ToBool(m_strPropertyValue.Compare (iscExact, riValueString.GetString ()))))
	{
		Ensure (ValidateProperty (riValueString));
		riValueString.AddRef();
		m_strPropertyValue = riValueString;
		if (fCallPropChanged)
			Ensure(PropertyChanged ());
	}

	return (0);
}

IMsiRecord* CMsiActiveControl::SetOriginalValue(const IMsiString& riValueString)
{
	riValueString.AddRef();
	m_strOriginalValue = riValueString;
	return 0;
}

IMsiRecord* CMsiActiveControl::SetIndirectPropertyValue(const IMsiString& riValueString)
{
	MsiString strNewPropertyValue = GetDBProperty(riValueString.GetString());
	if (m_fRefreshProp ||
		(!ToBool(m_strPropertyName.Compare (iscExact, riValueString.GetString ()))) ||
		(!ToBool(m_strPropertyValue.Compare (iscExact, strNewPropertyValue))))
	{
		Ensure (ValidateProperty (*strNewPropertyValue));
		riValueString.AddRef();
		m_strPropertyName = riValueString;
		Ensure(SetPropertyValue(*strNewPropertyValue, fFalse));
		Assert(m_piPropertiesTable);
		PMsiCursor piPropertiesCursor(0);
		Ensure(::CursorCreate(*m_piPropertiesTable, pcaTableIProperties, fFalse, *m_piServices, *&piPropertiesCursor)); 
		piPropertiesCursor->SetFilter(iColumnBit(itabPRProperty));
		AssertNonZero(piPropertiesCursor->PutString(itabPRProperty, *m_strPropertyName));
		if (!piPropertiesCursor->Next())
		{								// the property is not in the table yet
			piPropertiesCursor->Reset();
			AssertNonZero(piPropertiesCursor->PutString(itabPRProperty, *m_strPropertyName));
			AssertNonZero(piPropertiesCursor->PutString(itabPRValue, *m_strPropertyValue));
			AssertNonZero(piPropertiesCursor->Insert());
		}

	}

	return (0);
}


IMsiRecord* CMsiActiveControl::ValidateProperty (const IMsiString &text)
{
	if (m_fInteger)
	{
		MsiString valueStr(text.GetString ());
		if (valueStr.TextSize () && (iMsiStringBadInteger == (int) valueStr))
			return (PostError(Imsg(idbgIntegerOnlyControl), *m_strKey, text));
	}

	return (0);
}


IMsiRecord* CMsiActiveControl::PropertyChanged ()
{
	if (!m_fRefreshProp)
	{
		Ensure(SetPropertyInDatabase());
		Ensure(m_piDialog->PropertyChanged(*m_strPropertyName, *m_strKey));
	}

	return (0);
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiActiveControl::GetOriginalValue(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeOriginalValue));
	riRecord.SetMsiString(1, *m_strOriginalValue);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiActiveControl::GetInteger(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeInteger));
	riRecord.SetInteger(1, m_fInteger);
	return 0;
}
#endif // ATTRIBUTES

IMsiRecord* CMsiActiveControl::GetIndirect(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeIndirect));
	riRecord.SetInteger(1, m_fIndirect);
	return 0;
}

int CMsiActiveControl::GetOwnerDrawnComboListHeight()
{
	HDC hDC = WIN::GetDC(m_pWnd);
	Assert(hDC);
	MsiString strFontStyle = GimmeUserFontStyle(*m_strCurrentStyle);
	PMsiRecord piReturn = m_piHandler->GetTextStyle(strFontStyle);
	if (piReturn)
		WIN::SelectObject(hDC, (HFONT) GetHandleDataRecord(piReturn, itabTSFontHandle));
	else
		Assert(false);
	TEXTMETRIC tm;
	memset(&tm, 0, sizeof(TEXTMETRIC));
	WIN::GetTextMetrics(hDC, &tm);
	AssertNonZero(WIN::ReleaseDC(m_pWnd, hDC));
	return max(tm.tmHeight, g_iSelIconY) + 2;
}


#define WIDTHBYTES(bits)      ((((bits) + 31)>>5)<<2)

DWORD BytesPerLine(LPBITMAPINFOHEADER lpBMIH)
{
    return WIDTHBYTES(lpBMIH->biWidth * lpBMIH->biPlanes * lpBMIH->biBitCount);
}

WORD DIBNumColors(LPSTR lpbi)
{
    WORD wBitCount;
    DWORD dwClrUsed;

    dwClrUsed = ((LPBITMAPINFOHEADER) lpbi)->biClrUsed;

    if (dwClrUsed)
        return (WORD) dwClrUsed;

    wBitCount = ((LPBITMAPINFOHEADER) lpbi)->biBitCount;

    switch (wBitCount)
    {
        case 1: return 2;
        case 4: return 16;
        case 8:	return 256;
        default:return 0;
    }
    return 0;
}
WORD PaletteSize(LPSTR lpbi)
{
    return (WORD) ( DIBNumColors(lpbi) * sizeof(RGBQUAD));
}
unsigned char * FindDIBBits(LPSTR lpbi)
{
   return (unsigned char *)(lpbi + *(LPDWORD)lpbi + PaletteSize(lpbi));
}

Bool AdjustIconImagePointers(LPICONIMAGE lpImage)
{
    // Sanity check
    if (lpImage==0)
        return fFalse;
    // BITMAPINFO is at beginning of bits
    lpImage->lpbi = (LPBITMAPINFO)lpImage->lpBits;
    // Width - simple enough
    lpImage->Width = lpImage->lpbi->bmiHeader.biWidth;
    // Icons are stored in funky format where height is doubled - account for it
    lpImage->Height = (lpImage->lpbi->bmiHeader.biHeight)/2;
    // How many colors?
    lpImage->Colors = lpImage->lpbi->bmiHeader.biPlanes * lpImage->lpbi->bmiHeader.biBitCount;
    // XOR bits follow the header and color table
    lpImage->lpXOR = FindDIBBits((LPSTR)lpImage->lpbi);
    // AND bits follow the XOR bits
    lpImage->lpAND = lpImage->lpXOR + (lpImage->Height*BytesPerLine((LPBITMAPINFOHEADER)(lpImage->lpbi)));
    return fTrue;
}


IMsiRecord* CMsiControl::ReadIconFromICOFile(const IMsiString& riNameString, IMsiStream* piStream, ICONRESOURCE*& lpIR)
{
	WORD Input;
	piStream->GetData(&Input, sizeof(WORD));
	if (Input != 0)
	{
		PMsiRecord piReturn = PostError(Imsg(idbgNotIcon), riNameString);
		m_piEngine->Message(imtInfo, *piReturn);
		lpIR = 0;
		return 0;
	}
	piStream->GetData(&Input, sizeof(WORD));
	if (Input != 1)
	{
		PMsiRecord piReturn = PostError(Imsg(idbgNotIcon), riNameString);
		m_piEngine->Message(imtInfo, *piReturn);
		lpIR = 0;
		return 0;
	}
	piStream->GetData(&Input, sizeof(WORD));
	lpIR = (LPICONRESOURCE) new char[sizeof(ICONRESOURCE) + ((Input-1) * sizeof(ICONIMAGE))];
	if (lpIR == 0)
	{
		return PostError(Imsg(imsgOutOfMemoryUI));
	}
	lpIR->nNumImages = Input;
    // Allocate enough memory for the icon directory entries
	LPICONDIRENTRY lpIDE = (LPICONDIRENTRY) new char[lpIR->nNumImages * sizeof(ICONDIRENTRY)];
	if (lpIDE == 0)
	{
		delete[] lpIR;
		lpIR = 0;
		return PostError(Imsg(imsgOutOfMemoryUI));
	}
    // Read in the icon directory entries
	piStream->GetData(lpIDE, lpIR->nNumImages * sizeof(ICONDIRENTRY));
    // Loop through and read in each image
    for (int i = 0; i < lpIR->nNumImages; i++)
    {
        // Allocate memory for the resource
		lpIR->IconImages[i].lpBits = new unsigned char[lpIDE[i].dwBytesInRes];
		if (lpIR->IconImages[i].lpBits == 0)
		{
			for (int j = 0; j < i; j++)
			{
				delete lpIR->IconImages[j].lpBits;
			}
			delete[] lpIR;
			lpIR = 0;
			delete[] lpIDE;
			return PostError(Imsg(imsgOutOfMemoryUI));
		}
        lpIR->IconImages[i].dwNumBytes = lpIDE[i].dwBytesInRes;
        // Seek to beginning of this image
		piStream->Reset();
		// temp until we can skip in streams
		char* temp = new char[lpIDE[i].dwImageOffset];
		piStream->GetData(temp, lpIDE[i].dwImageOffset);
		delete[] temp;
        // Read it in
		piStream->GetData(lpIR->IconImages[i].lpBits, lpIDE[i].dwBytesInRes);
        if(!AdjustIconImagePointers(&(lpIR->IconImages[i])))
        {
			for (int j = 0; j <= i; j++)
			{
				delete[] lpIR->IconImages[j].lpBits;
			}
			delete[] lpIR;
			lpIR = 0;
			delete[] lpIDE;
			PMsiRecord piReturn = PostError(Imsg(idbgNotIcon), riNameString);
			m_piEngine->Message(imtInfo, *piReturn);
			return 0;
        }
    }
    // Clean up	
	delete[] lpIDE;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\sources.inc ===
TARGETNAME=MsiHnd
!INCLUDE ..\..\MsiMake.inc


!if "$(MSI_BROWSER_INFO)"=="1"
BROWSER_INFO=1
!endif

JPEG_DIR=..\jpeg
JPEG_OBJDIR=$(JPEG_DIR)\$(MSI_SUBDIR)\$(O)
JPEG_INCDIR=..\jpeginc

ICON_DIR=..\Icon

TARGETTYPE=DYNLINK
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\msihnd.def

USE_LIBCMT=1

TARGETLIBS=\
        $(SDK_LIB_PATH)\kernel32.lib \
!if "$(MSI_BUILD_UNICODE)"=="1"
        $(SDK_LIB_PATH)\ntdll.lib \
!endif
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
        $(SDK_LIB_PATH)\gdi32.lib \
        $(SDK_LIB_PATH)\comctl32.lib \
        $(SDK_LIB_PATH)\imm32.lib \
        $(SDK_LIB_PATH)\shell32.lib \
        $(SDK_LIB_PATH)\strsafe.lib \
        $(JPEG_OBJDIR)\darwjpeg.obj \
        $(JPEG_OBJDIR)\jpegdata.obj \
        $(JPEG_OBJDIR)\jpegdeco.obj \
        $(JPEG_OBJDIR)\jdapimin.obj \
        $(JPEG_OBJDIR)\jdapistd.obj \
        $(JPEG_OBJDIR)\jcomapi.obj \
        $(JPEG_OBJDIR)\jcparam.obj \
        $(JPEG_OBJDIR)\jdmaster.obj \
        $(JPEG_OBJDIR)\jdinput.obj \
        $(JPEG_OBJDIR)\jdmainct.obj \
        $(JPEG_OBJDIR)\jdcoefct.obj \
        $(JPEG_OBJDIR)\jdpostct.obj \
        $(JPEG_OBJDIR)\jdmarker.obj \
        $(JPEG_OBJDIR)\jdhuff.obj \
        $(JPEG_OBJDIR)\jdphuff.obj \
        $(JPEG_OBJDIR)\jddctmgr.obj \
        $(JPEG_OBJDIR)\jidctint.obj \
        $(JPEG_OBJDIR)\jidctfst.obj \
        $(JPEG_OBJDIR)\jidctflt.obj \
        $(JPEG_OBJDIR)\jidctred.obj \
        $(JPEG_OBJDIR)\jdsample.obj \
        $(JPEG_OBJDIR)\jdcolor.obj \
        $(JPEG_OBJDIR)\jdmerge.obj \
        $(JPEG_OBJDIR)\jquant1.obj \
        $(JPEG_OBJDIR)\jquant2.obj \
        $(JPEG_OBJDIR)\jerror.obj \
        $(JPEG_OBJDIR)\dmemmgr.obj \
        $(JPEG_OBJDIR)\jutils.obj \
        $(JPEG_OBJDIR)\jmemwin.obj

USE_NOLIBS=1
IDL_TYPE=rpc    

INCLUDES=$(INCLUDES);$(INC_DIR);$(JPEG_INCDIR);$(IDL_OBJDIR);$(RES_OBJDIR);$(ICON_DIR);$(TOOLS_INC_DIR);$(BUILD_COMMONDIR)

SOURCES=..\handler.cpp \
        ..\dialog.cpp \
        ..\control.cpp \
        ..\controls.cpp \
        ..\handler.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\controls.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       control.cpp
//
//--------------------------------------------------------------------------
/*
  controls.cpp - particular control implementation
____________________________________________________________________________*/

#include "common.h"
#include "engine.h"  
#include "database.h"
#include "_handler.h" 
#include "_control.h"
#include <imm.h>
#include <shellapi.h>
#include "clibs.h"

#define FINAL

#ifdef UNICODE
#define _ui64tot    _ui64tow
#define _tcstoui64  _wcstoui64
#define _i64tot     _i64tow
#define _ttoi64     _wtoi64
#else
#define _ui64tot    _ui64toa
#define _tcstoui64  _strtoui64
#define _i64tot     _i64toa
#define _ttoi64     _atoi64
#endif // UNICODE

/////////////////////////////////////////////
// CMsiPushButton  definition
/////////////////////////////////////////////

class CMsiPushButton:public CMsiControl
{
public:
	CMsiPushButton(IMsiEvent& riDialog);
	~CMsiPushButton();
	virtual IMsiRecord*     __stdcall WindowCreate(IMsiRecord& riRecord);
	virtual Bool            __stdcall CanTakeFocus() { return ToBool(m_fEnabled && m_fVisible); }
	virtual const ICHAR*    __stdcall GetControlType() const { return m_szControlType; }

protected:
#ifdef ATTRIBUTES
	IMsiRecord*             GetBitmap(IMsiRecord& riRecord);
	IMsiRecord*             GetIcon(IMsiRecord& riRecord);
#endif // ATTRIBUTES
	virtual IMsiRecord*     SetFocus(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*     KillFocus(WPARAM wParam, LPARAM lParam);
	
private:
	IMsiRecord*             GetDefault(IMsiRecord& riRecord);
	IMsiRecord*             SetDefault(IMsiRecord& riRecord);
	IMsiRecord*             SetDefault(Bool fDefault);
	Bool                    m_fDefault;
	Bool                    m_fBitmap;
	Bool                    m_fIcon;
	Bool                    m_fFixedSize;
	HANDLE                  m_hBinary;
	static const ICHAR*     m_szControlType;
};

/////////////////////////////////////////////////
// CMsiPushButton  implementation
/////////////////////////////////////////////////

const ICHAR* CMsiPushButton::m_szControlType = g_szPushButtonType;

CMsiPushButton::CMsiPushButton(IMsiEvent& riDialog) : CMsiControl(riDialog)
{
	m_fDefault = fFalse;
	m_fBitmap = fFalse;
	m_fIcon = fFalse;
	m_fFixedSize = fFalse;
	m_hBinary = 0;
}

CMsiPushButton::~CMsiPushButton()
{
	if (m_hBinary)
		AssertNonZero(m_piHandler->DestroyHandle((HANDLE)m_hBinary) != -1);
}

IMsiRecord* CMsiPushButton::SetFocus(WPARAM wParam, LPARAM lParam)
{
	WIN::SendMessage(m_pWndDialog, WM_SETDEFAULTPUSHBUTTON, (WPARAM)m_iKey, 0);
	return CMsiControl::SetFocus(wParam, lParam);
}

IMsiRecord* CMsiPushButton::KillFocus(WPARAM wParam, LPARAM lParam)
{
	WIN::SendMessage(m_pWndDialog, WM_SETDEFAULTPUSHBUTTON, 0, 0);
	return CMsiControl::KillFocus(wParam, lParam);
}

IMsiRecord* CMsiPushButton::WindowCreate(IMsiRecord& riRecord)
{
	int iAttributes = riRecord.GetInteger(itabCOAttributes);
	m_fBitmap = ToBool(iAttributes & msidbControlAttributesBitmap);
	m_fIcon = ToBool(iAttributes & msidbControlAttributesIcon);
	m_fFixedSize = ToBool(iAttributes & msidbControlAttributesFixedSize);
	Ensure(CMsiControl::WindowCreate(riRecord));
	DWORD dwStyle = 0;
	if (g_fChicago)
	{
		dwStyle |= m_fBitmap ? BS_BITMAP : 0;
		dwStyle |= m_fIcon ? BS_ICON : 0;
	}
	Ensure(CreateControlWindow(TEXT("BUTTON"), BS_MULTILINE|WS_TABSTOP|dwStyle, m_fRTLRO ? WS_EX_RTLREADING : 0, (m_fBitmap || m_fIcon) ? *m_strToolTip : *m_strText, m_pWndDialog, m_iKey));
	Ensure(WindowFinalize());
	if (m_fBitmap)
	{
		HBITMAP hBitmap = 0;
		Ensure(StretchBitmap(*m_strText, m_iWidth - 2, m_iHeight - 2, m_fFixedSize, m_pWnd, *&hBitmap));
		WIN::SendMessage(m_pWnd, BM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) (HANDLE) hBitmap);
		m_hBinary = hBitmap;
		AssertNonZero(m_piHandler->RecordHandle(CWINHND(hBitmap, iwhtGDIObject)) != -1);
	}
	if (m_fIcon)
	{	
		HICON hIcon = 0;
		GetIconSize(iAttributes);
		Ensure(UnpackIcon(*m_strText, *&hIcon, m_iWidth - 2, m_iHeight - 2, m_fFixedSize));
		WIN::SendMessage(m_pWnd, BM_SETIMAGE, (WPARAM) IMAGE_ICON, (LPARAM) (HANDLE) hIcon);
		m_hBinary = hIcon; 
		AssertNonZero(m_piHandler->RecordHandle(CWINHND(hIcon, iwhtIcon)) != -1);
	}
	return 0;
}

IMsiRecord* CMsiPushButton::GetDefault(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeDefault));
	riRecord.SetInteger(1, m_fDefault);
	return 0;
}

IMsiRecord* CMsiPushButton::SetDefault(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeDefault));
	return SetDefault(ToBool(riRecord.GetInteger(1)));
}

IMsiRecord* CMsiPushButton::SetDefault(Bool fDefault)
{
	if ( m_fDefault != fDefault )
	{
#ifdef DEBUG
		LONG liStyle = GetWindowLong(m_pWnd, GWL_STYLE);
#endif
		::ChangeWindowStyle(m_pWnd,
								  m_fDefault ? BS_DEFPUSHBUTTON : BS_PUSHBUTTON, 
								  fDefault ? BS_DEFPUSHBUTTON : BS_PUSHBUTTON,
								  fFalse);
		m_fDefault = fDefault;
#ifdef DEBUG
		liStyle = GetWindowLong(m_pWnd, GWL_STYLE);
#endif
		AssertNonZero(WIN::InvalidateRect(m_pWnd, 0, fTrue));
	}
	return 0;
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiPushButton::GetBitmap(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeBitmap));
	riRecord.SetInteger(1, m_fBitmap);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiPushButton::GetIcon(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeIcon));
	riRecord.SetInteger(1, m_fIcon);
	return 0;
}
#endif // ATTRIBUTES


IMsiControl* CreateMsiPushButton(IMsiEvent& riDialog)
{
	return new CMsiPushButton(riDialog);
}

/////////////////////////////////////////////
// CMsiText  definition
/////////////////////////////////////////////

class CMsiText:public CMsiControl
{
public:
	CMsiText(IMsiEvent& riDialog);
	IMsiRecord*			   __stdcall WindowCreate(IMsiRecord& riRecord);
	void                   __stdcall Refresh();
	IMsiRecord*            Paint(WPARAM wParam, LPARAM lParam);

protected:
	virtual IMsiRecord*    SetText(IMsiRecord& riRecord);
	Bool                   m_fNoPrefix;
	Bool                   m_fNoWrap;
	Bool                   m_fFormatSize;
	bool                   m_fDynamicProperty;
	BOOL                   m_fRefitText;
	
private:
	IMsiRecord*            PrepareHDC(HDC hdc);
	static Bool            DoesTextFitInRect(const HDC& hdc,
														  const ICHAR* szText,
														  const UINT uStyle,
														  const RECT& rect);
	IMsiRecord*            FitText(const HDC& hdc, const RECT& rect);
	Bool                   m_fTextChecked;
	UINT                   m_uStyle;
};

/////////////////////////////////////////////////
// CMsiText  implementation
/////////////////////////////////////////////////


CMsiText::CMsiText(IMsiEvent& riDialog) : CMsiControl(riDialog), m_fTextChecked(fFalse)
{
}


IMsiRecord* CMsiText::WindowCreate(IMsiRecord& riRecord)
{
	int iAttrib = riRecord.GetInteger(itabCOAttributes);
	m_fTransparent = ToBool(iAttrib & msidbControlAttributesTransparent);
	m_fNoPrefix = ToBool(iAttrib & msidbControlAttributesNoPrefix);
	m_fNoWrap = ToBool(iAttrib & msidbControlAttributesNoWrap);
	m_fFormatSize = ToBool(iAttrib & msidbControlAttributesFormatSize);
	m_fUseDbLang = !(iAttrib & msidbControlAttributesUsersLanguage);
	m_fDynamicProperty = (bool) -1;
	m_fRefitText = (BOOL) -1;
	Ensure(CMsiControl::WindowCreate(riRecord));
	MsiString strNull;
	Ensure(CreateControlWindow(TEXT("STATIC"),
				m_fRightAligned ? SS_RIGHT : SS_LEFT,
				m_fRTLRO ? WS_EX_RTLREADING : 0, *m_strText, m_pWndDialog, m_iKey));
	Ensure(WindowFinalize());
	return 0;
}

void CMsiText::Refresh()
{
	if (m_fDynamicProperty == (bool) -1)
		m_fDynamicProperty = m_strRawText.Compare(iscStart,TEXT("[")) && m_strRawText.Compare(iscEnd,TEXT("]"));

	if (m_fDynamicProperty)
	{
		MsiString strText = m_piEngine->FormatText(*m_strRawText);
		if (!strText.Compare(iscExact, m_strText))
		{
			m_strText = strText;
			AssertNonZero(WIN::InvalidateRect(m_pWnd, 0, fTrue));
		}
	}
}

IMsiRecord* CMsiText::Paint(WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	PAINTSTRUCT ps;
	HBRUSH hbrush=WIN::CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
	if ( ! hbrush )
		return PostError(Imsg(idbgPaintError), *m_strDialogName);
	HDC hdc = WIN::BeginPaint(m_pWnd, &ps);
	AssertNonZero(CLR_INVALID != WIN::SetTextColor(hdc, 
				GetSysColor(m_fEnabled ? COLOR_WINDOWTEXT : COLOR_GRAYTEXT)));

	RECT rect;
	AssertNonZero(WIN::GetClientRect(m_pWnd, &rect));
	if (!m_fTransparent)
	{
		AssertNonZero(WIN::FillRect(hdc, &rect, hbrush));
		AssertNonZero(CLR_INVALID != WIN::SetBkColor(hdc, GetSysColor(COLOR_BTNFACE)));
	}
	else 
		AssertNonZero(WIN::SetBkMode(hdc, TRANSPARENT));
	if ( m_strText.TextSize() == 0 )
	{
		AssertNonZero(WIN::DeleteObject(hbrush));
		WIN::EndPaint(m_pWnd, &ps);
		return 0;
	}
	PMsiRecord precError = PrepareHDC(hdc);
	if ( m_fRefitText == (BOOL)-1)
	{
		// check to see if it contains a property
		int iPos = m_strRawText.Compare(iscWithin, TEXT("["));
		if (iPos)
		{
			MsiString strRemain(m_strRawText.Extract(iseAfter,'['));
			iPos = strRemain.Compare(iscWithin, TEXT("]"));
		}

		m_fRefitText = iPos ? TRUE : FALSE;
	}
	if ( m_fRefitText )
		m_fTextChecked = fFalse; // any static text that is a dynamic property is always fitted on paint
	if ( !m_fTextChecked )
		FitText(hdc, rect);

	if (m_fFormatSize)
	{
		INT64 iSize = _ttoi64((const ICHAR*)m_strText);
		MsiString strSize = FormatSize(iSize, fFalse);
		AssertNonZero(WIN::DrawText(hdc, strSize, -1, &rect, m_uStyle));
		WIN::SetWindowText(m_pWnd, strSize);
	}
	else
		AssertNonZero(WIN::DrawText(hdc, m_strText, -1, &rect, m_uStyle));

	AssertNonZero(WIN::DeleteObject(hbrush));
	WIN::EndPaint(m_pWnd, &ps);
	if (precError)
	{
		precError->AddRef();
		return precError;
	}
	else
	{
		return PostErrorDlgKey(Imsg(idbgWinMes), 0);
 	}
	return 0;
}

IMsiRecord* CMsiText::PrepareHDC(HDC hdc)
{
	PMsiRecord piErrorRecord(0);
	if (m_strCurrentStyle.TextSize())
	{
		PMsiView piTextStyleUpdateView(0);
		MsiString strFontStyle = GimmeUserFontStyle(*m_strCurrentStyle);
		PMsiRecord piReturn = m_piHandler->GetTextStyle(strFontStyle);
		if (!piReturn)
		{
			piErrorRecord = PostError(Imsg(idbgViewExecute), *MsiString(*pcaTablePTextStyle));
			m_piEngine->Message(imtInfo, *piErrorRecord);
			return 0;
		}
		HFONT hFont = (HFONT) GetHandleDataRecord(piReturn, itabTSFontHandle);
		HFONT hNewFont = (HFONT) WIN::SelectObject(hdc, hFont);
		if (!hNewFont)
		{
			piErrorRecord = PostError(Imsg(idbgFontChange), *m_strCurrentStyle);
			m_piEngine->Message(imtInfo, *piErrorRecord);
			return 0;
		}
		if (!piReturn->IsNull(itabTSColor))
		{
			COLORREF rgb = (COLORREF) piReturn->GetInteger(itabTSColor);
			COLORREF rgbBack = WIN::GetSysColor(COLOR_BTNFACE);
			int iRed = rgb & 0xFF;
			int iRedBack = rgbBack &0xFF;
			int iGreen = (rgb & 0xFF00) >> 8;
			int iGreenBack = (rgbBack & 0xFF00) >> 8;
			int iBlue = (rgb & 0xFF0000) >> 16;
			int iBlueBack = (rgbBack & 0xFF0000) >> 16;
			int iDifference = 0;
			iDifference += abs(iRed - iRedBack);
			iDifference += abs(iGreen - iGreenBack);
			iDifference += abs(iBlue - iBlueBack);
			if (iDifference < 30)    // the color is too close to the background color
				rgb = WIN::GetSysColor(COLOR_BTNTEXT);
			Assert(rgb != CLR_INVALID);
			if (CLR_INVALID == WIN::SetTextColor(hdc, rgb))
			{
				piErrorRecord = PostError(Imsg(idbgFontChangeColor), *MsiString((int)rgb));
				m_piEngine->Message(imtInfo, *piErrorRecord);
				return 0;
			}
		}
	}
	return 0;
}


IMsiRecord* CMsiText::SetText(IMsiRecord& riRecord)
{
	MsiString strPrevRawText = m_strRawText;
	Ensure(CMsiControl::SetText(riRecord));
	if ( IStrComp(m_strRawText, strPrevRawText) )
		m_fTextChecked = fFalse;
	return 0;
}

const ICHAR szEllipses[] = TEXT(" ...");
const iEllipsesLen = sizeof(szEllipses)/sizeof(ICHAR);
const ICHAR chBlank = TEXT(' ');
const ICHAR chNull = TEXT('\0');
const ICHAR chJockey = TEXT('\x01');
inline INT_PTR LengthThatFitsBetween(const ICHAR* pchRight, const ICHAR* pchLeft)		//--merced: changed int to INT_PTR
	{ Assert(pchRight >= pchLeft); return pchRight-pchLeft-1; }

IMsiRecord* CMsiText::FitText(const HDC& hdc, const RECT& rect)
{
	if ( m_fTextChecked )
		return 0;

	m_fTextChecked = fTrue;
	m_uStyle = (m_fRightAligned ? DT_RIGHT : DT_LEFT) |
				  (m_fRTLRO ? DT_RTLREADING : 0) |
				  (m_fNoPrefix ? DT_NOPREFIX : 0) |
				  (m_fNoWrap ? DT_SINGLELINE : DT_WORDBREAK) | /* single line or line */
																			  /* breaks between words */
				  DT_EDITCONTROL;  /* no partially displayed bottom lines */
	if ( DoesTextFitInRect(hdc, m_strText, m_uStyle, rect) )
		//  the text fits into the rectangle
		return 0;

	//  the text does not fit as it is

	if ( !IStrChr(m_strText, chDirSep) &&
		  !IStrChr(m_strText, chRegSep) )
	{
		//  the text doesn't contain a registry key or a path: I do not modify
		//  it, but I let the user know that the displayed string is truncated.
		m_uStyle |= DT_END_ELLIPSIS;
		return 0;
	}

	//  I may have to format the string (I assume it contains either a 
	//  registry key or a path)
	TEXTMETRIC tm;
	AssertNonZero(WIN::GetTextMetrics(hdc, &tm));
	int iLines = (rect.bottom - rect.top) / tm.tmHeight;
	if ( m_fNoWrap || iLines == 1 )						// !merced: warning C4805: '|' : unsafe mix of type 'enum Bool' and type 'bool' in operation
	{
		//  single-line control.  The style below is fit for displaying
		//  a path in a single-line control.  No formatting is needed.
		m_uStyle |= DT_PATH_ELLIPSIS;
		return 0;
	}

	//  I have to format the string.  I leave the substring that follows
	//  the rightmost chSep untouched and I replace substrings enclosed
	//  between chSep to its left with szEllipses, as long as the so modified
	//  text do not fit into the rectangle.

	DWORD cchText = m_strText.TextSize()+1;
	ICHAR* szText = new ICHAR[cchText];
	AssertNonZero(SUCCEEDED(StringCchCopy(szText, cchText, m_strText)));

	ICHAR chSep = chDirSep;
	ICHAR* szFirstSep = IStrChr(szText, chSep);
	if ( !szFirstSep )
	{
		chSep = chRegSep;
		szFirstSep = IStrChr(szText, chSep);
	}
	Assert(szFirstSep);
	if ( *(szFirstSep+1) == chSep && *(szFirstSep+2) )
	{
		//  we're dealing with a network drive
		if ( !IStrChr(szFirstSep++, chSep) )
		{
			//  the string cannot be formatted - there is no chSep after the
			//  first two consecutive chSep characters.
			m_uStyle |= DT_END_ELLIPSIS;
			delete [] szText;
			return 0;
		}
	}

	ICHAR* szLastSep = IStrRChr(szText, chSep);
	Bool fTrailingSep = fFalse;
	if ( !*(szLastSep+1) || *(szLastSep+1) == chBlank )
	{
		//  nothing meaningful follows the last chSep - I go one more
		//  chSep backwards.
		fTrailingSep = fTrue;
		if ( !*(szLastSep+1) )
			*szLastSep = chNull;
		else
			*szLastSep = chJockey;
		szLastSep = IStrRChr(szText, chSep);;
	}
	//  one more check before starting to format.
	Bool fToFormat = fFalse;
	if ( szLastSep > szFirstSep )
	{
		*szFirstSep = chNull;
		ICHAR* pch = IStrRChr(szText, chBlank);
		*szFirstSep = chSep;
		if ( !pch )
			pch = szText;
		if ( LengthThatFitsBetween(szLastSep, pch) > iEllipsesLen )
			fToFormat = fTrue;
	}
	if ( !fToFormat )
	{
		//  the string cannot/should not be formatted
		m_uStyle |= DT_END_ELLIPSIS;
		delete [] szText;
		return 0;
	}

	Bool fStringFits = fFalse;
	while ( !fStringFits )
	{
		//  I look for the last but one chSep.
		*szLastSep = chNull;
		ICHAR* szLastButOneSep = IStrRChr(szText, chSep);
		*szLastSep = chSep;
		while ( szLastButOneSep >= szFirstSep &&
				  LengthThatFitsBetween(szLastSep, szLastButOneSep) < iEllipsesLen )
		{
			//  the string between the rightmost two chSep is shorter than
			//  szEllipses - I look for one more chSep back.
			*szLastButOneSep = chNull;
			ICHAR* szTempSep = IStrRChr(szText, chSep);
			*szLastButOneSep = chSep;
			szLastButOneSep = szTempSep;
		}
		if ( szLastButOneSep >= szFirstSep )
		{
			//  I replace the string between the two right-most chSep
			//  with szEllipses and check if the resulting string fits
			//  into the rectangle.
			AssertNonZero(SUCCEEDED(StringCchCopy(szLastButOneSep+1, cchText - (szLastButOneSep+1 - szText), szEllipses)));
			AssertNonZero(SUCCEEDED(StringCchCat(szText, cchText, szLastSep)));
			if ( DoesTextFitInRect(hdc, szText, m_uStyle, rect) )
				fStringFits = fTrue;
			else
			{
				//  the text still doesn't fit - I go one more chSep back.
				*szLastButOneSep = chBlank;   //  I don't want to find this chSep
														//  again in the same spot.
				szLastSep = IStrRChr(szText, chSep);
				Assert(szLastSep);
			}
		}
		else
			//  no more replacements are possible (there is no fit chSep
			//  to the left of szLastSep)
			break;
	}
	if ( !fStringFits )
	{
		//  I replace the path up to the last chSep with ellipses.
		//  I eliminate all chSep located to the left of szFirstSep
		ICHAR* pch = szFirstSep;
		do
		{
			*pch = chNull;
			pch = IStrRChr(szText, chSep);
		}
		while (pch);
		//  I look for the preceding blank.
		ICHAR* pchBlank = IStrRChr(szText, chBlank);
		if ( pchBlank )
		{
			//  there is one
			if ( LengthThatFitsBetween(szLastSep, pchBlank) >= iEllipsesLen )
			{
				//  the path before szLastSep is longer than szEllipses - I
				//  can replace it in place
				AssertNonZero(SUCCEEDED(StringCchCopy(pchBlank, cchText - (pchBlank - szText), szEllipses)));
				AssertNonZero(SUCCEEDED(StringCchCat(szText, cchText, szLastSep)));
			}
			else
			{
				//  the remaining path is shorter than szEllipses - I need
				//  to use a temporary MsiString for the operations.
				*pchBlank = chNull;
				MsiString strTemp = szText;
				strTemp += szEllipses;
				strTemp += szLastSep;
				AssertNonZero(SUCCEEDED(StringCchCopy(szText, cchText, strTemp)));
			}
		}
		else
		{
			//  there is no blank preceding szFirstSep - I replace the entire
			//  string to the left of the last chSep with szEllipses
			MsiString strTemp = szEllipses;
			strTemp += szLastSep;
			AssertNonZero(SUCCEEDED(StringCchCopy(szText, cchText, strTemp)));
		}
		if ( !DoesTextFitInRect(hdc, szText, m_uStyle, rect) )
			//  the text still doesn't fit into the rectangle.
			//  I let the user know that the displayed string is truncated.
			m_uStyle |= DT_END_ELLIPSIS;
	}
	if ( fTrailingSep )
	{
		ICHAR* pch = IStrChr(szText, chJockey);
		if ( !pch )
		{
			pch = szText + IStrLen(szText);
			Assert(pch);
			*(pch+1) = chNull;
		}
		*pch = chSep;
	}

	m_strText = szText;
	delete [] szText;

	return 0;
}

Bool CMsiText::DoesTextFitInRect(const HDC& hdc,
											const ICHAR* szText,
											const UINT uArgStyle,
											const RECT& rectArg)
{
	//  checks if the text fits into the rectangle
	RECT rectCalc = rectArg;
	AssertNonZero(WIN::DrawText(hdc, szText, -1, &rectCalc, uArgStyle | DT_CALCRECT));

	return ToBool(rectCalc.bottom <= rectArg.bottom &&
					  rectCalc.right <= rectArg.right);
}


IMsiControl* CreateMsiText(IMsiEvent& riDialog)
{
	return new CMsiText(riDialog);
}

///////////////////////////////////////////////////////////////////////////
// CMsiEdit definition
///////////////////////////////////////////////////////////////////////////

// A tiny class I wrote to encapsulate the plumbing needed to switch to
// an English keyboard on Far East, Arabic, Hebrew and Farsi OS-es.
//
// Intended usage: to call SwitchToEnglishKbd in SetFocus and to call
//                 SwitchToOriginalKbd in KillFocus.
//
//!!FUTURE: to use an instance of this class in CMsiMaskedEdit as well and
//          clean up the existing functionality that's scattered all over
//          the place.

enum ieWhenToSwitchKbd
{
	ieOnFEMachines = 1,
	ieOnRTLMachines = 2,
	ieAllways = ieOnFEMachines | ieOnRTLMachines,
};

class CMsiSwitchKeyboard
{
protected:
	// data members that concern machines that have IME
	HIMC   m_hIMC;
	bool   m_fIsIMEOpen;
	
	// data members that concern Arabic/Hebrew machines
	bool   m_fSwitchLang;  // do we need to switch languages?
	HKL    m_hklEnglishKbd;
	HKL    m_hklOriginalKbd;

	int    m_cCalls;
	HWND   m_hWnd;
	ieWhenToSwitchKbd  m_ieWhen;

public:
	~CMsiSwitchKeyboard() {
		AssertSz(m_cCalls == 0, TEXT("Methods of CMsiSwitchKeyboard should ")
										TEXT("be called in pairs."));
	}

	CMsiSwitchKeyboard(ieWhenToSwitchKbd ieWhen) : m_fSwitchLang(false),
								  m_hIMC(NULL), m_fIsIMEOpen(false),
								  m_hklEnglishKbd(NULL), m_hklOriginalKbd(NULL),
								  m_cCalls(0), m_hWnd(NULL), m_ieWhen(ieWhen)
	{
		if ( m_ieWhen & ieOnRTLMachines)
		{
			LANGID lID = WIN::GetUserDefaultLangID();
			if ( PRIMARYLANGID(lID) == LANG_ARABIC ||
				  PRIMARYLANGID(lID) == LANG_HEBREW ||
				  PRIMARYLANGID(lID) == LANG_FARSI  )
				m_fSwitchLang = fTrue;
			if ( m_fSwitchLang )
			{
				AssertNonZero(m_hklOriginalKbd = WIN::GetKeyboardLayout(0));
				if ( PRIMARYLANGID(LOWORD(m_hklOriginalKbd)) == LANG_ENGLISH )
					m_hklEnglishKbd = m_hklOriginalKbd;
				else
				{
					//  the default keyboard is not English.  I make sure there is
					//  an English keyboard loaded.
					CTempBuffer<HKL, MAX_PATH> rgdwKbds;
					int cKbds = WIN::GetKeyboardLayoutList(0, NULL);
					Assert(cKbds > 0);
					if ( cKbds > MAX_PATH )
						rgdwKbds.SetSize(cKbds);
					AssertNonZero(WIN::GetKeyboardLayoutList(cKbds, rgdwKbds) > 0);
					for ( cKbds--; 
							cKbds >= 0 && PRIMARYLANGID(LOWORD(rgdwKbds[cKbds])) != LANG_ENGLISH;
							cKbds-- )
						;
					if ( cKbds >= 0 )
						m_hklEnglishKbd = rgdwKbds[cKbds];
					else
						m_hklEnglishKbd = WIN::LoadKeyboardLayout(TEXT("00000409"),
																		KLF_REPLACELANG | KLF_SUBSTITUTE_OK);
					Assert(m_hklEnglishKbd);
				}
			}
		}
	}

	bool  SwitchToEnglishKbd(HWND hWnd){
		if ( m_cCalls != 0 )
		{
			AssertSz(0, TEXT("CMsiSwitchKeyboard::SwitchToEnglishKbd should ")
						   TEXT(" be called first (once per window)."));
			return false;
		}
		m_cCalls++;
		bool fReturn = true;
		if ( (m_ieWhen & ieOnRTLMachines) && m_fSwitchLang )
		{
			if ( m_hklEnglishKbd )
				WIN::ActivateKeyboardLayout(m_hklEnglishKbd, 0);
			else
			{
				Assert(0);
				fReturn = false;
			}
		}
		else if ( m_ieWhen & ieOnFEMachines )
		{
			if (!hWnd || !IsWindow(hWnd))
			{
				AssertSz(0, TEXT("CMsiSwitchKeyboard::SwitchToEnglishKbd called ")
								TEXT("with an invalid HWND parameter!"));
				fReturn = false;
			}
			else
			{
				if ( m_hWnd != hWnd )
					m_hWnd = hWnd;
				HIMC hIMC = WIN::ImmGetContext(hWnd);
				if ( hIMC )
				{
					//  I disable IME for this window
					WIN::ImmReleaseContext(hWnd, hIMC);
					m_fIsIMEOpen = Tobool(WIN::ImmSetOpenStatus(hIMC, FALSE));
					m_hIMC = WIN::ImmAssociateContext(hWnd, NULL);
				}
			}
		}
		return fReturn;
	}

	bool  SwitchToOriginalKbd(HWND hWnd){
		if ( m_cCalls != 1 )
		{
			AssertSz(0, TEXT("CMsiSwitchKeyboard::SwitchToOriginalKbd should ")
						   TEXT(" be called second (once per window)."));
			return false;
		}
		m_cCalls--;
		bool fReturn = true;
		if ( (m_ieWhen & ieOnRTLMachines) && m_fSwitchLang )
			//  I set back the keyboard to the user's
			WIN::ActivateKeyboardLayout(m_hklOriginalKbd, 0);
		else if ( m_ieWhen & ieOnFEMachines )
		{
			if (!hWnd || !IsWindow(hWnd))
			{
				AssertSz(0, TEXT("CMsiSwitchKeyboard::SwitchToOriginalKbd called ")
								TEXT("with an invalid HWND parameter!"));
				fReturn = false;
			}
			else if ( m_hWnd != hWnd )
			{
				AssertSz(0, TEXT("CMsiSwitchKeyboard::SwitchToOriginalKbd called ")
								TEXT("with a different HWND parameter from the previous call!"));
				fReturn = false;
			}
			if ( fReturn && m_hIMC )
			{
				// I enable IME
				WIN::ImmAssociateContext(hWnd, m_hIMC);
				WIN::ImmSetOpenStatus(m_hIMC, m_fIsIMEOpen);
				m_hIMC = NULL;
				m_fIsIMEOpen = false;
			}
		}
		return fReturn;
	}
};

class CMsiEdit:public CMsiActiveControl
{
public:
	CMsiEdit(IMsiEvent& riDialog);
	virtual IMsiRecord*    __stdcall WindowCreate(IMsiRecord& riRecord);
	virtual IMsiRecord*    __stdcall GetPropertyFromDatabase();
	virtual unsigned long  __stdcall Release();

protected:
	virtual ~CMsiEdit();

	virtual IMsiRecord*    PropertyChanged();
	virtual IMsiRecord*    KillFocus(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*    KeyDown(WPARAM wParam, LPARAM lParam);
	int                    m_iLimit;            // The maximum number of characters the text can have
	virtual void           SetWindowText (const IMsiString &text);
	const IMsiString&      GetWindowText ();
	virtual IMsiRecord*    SetFocus(WPARAM wParam, LPARAM lParam);
 	inline BOOL            HasBeenChanged(void)
 										{ return (BOOL)WIN::SendMessage(m_pWnd, EM_GETMODIFY, 0, 0); }

	bool                   m_fNoMultiLine;
	bool                   m_fNoPassword;
	CMsiSwitchKeyboard*    m_pSwitchKbd;

private:
#ifdef ATTRIBUTES
	IMsiRecord*            GetLimit(IMsiRecord& riRecord);
#endif // ATTRIBUTES
};

///////////////////////////////////////////////////////////////////////////
// CMsiEdit implementation
///////////////////////////////////////////////////////////////////////////

CMsiEdit::CMsiEdit(IMsiEvent& riDialog)	: CMsiActiveControl(riDialog)
{
	m_iLimit = 0;
	m_fNoMultiLine = false;
	m_fUseDbLang = false;
	m_fNoPassword = false;
	m_pSwitchKbd = NULL;
}


CMsiEdit::~CMsiEdit()
{
	delete m_pSwitchKbd;
}

unsigned long CMsiEdit::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	if (m_pWnd)
		DestroyWindow(m_pWnd);
	else
		delete this;
	
	return 0;
}


IMsiRecord* CMsiEdit::WindowCreate(IMsiRecord& riRecord)
/*----------------------------------------------------------------------------
------------------------------------------------------------------------------*/
{
	Ensure(CMsiActiveControl::WindowCreate(riRecord));
	Bool fMultiline;
	if ( m_fNoMultiLine )
		//  some child control wants to make sure that it will not be created
		//  as a multiline control.
		fMultiline = fFalse;
	else
		fMultiline = ToBool(riRecord.GetInteger(itabCOAttributes) &
								  msidbControlAttributesMultiline);
	Bool fPassword;
	if ( m_fNoPassword )
		//  some child control wants to make sure that it will not be created
		//  as a password input edit control.
		fPassword = fFalse;
	else
		fPassword = ToBool(riRecord.GetInteger(itabCOAttributes) &
								 msidbControlAttributesPasswordInput);
	if ( fPassword )
		// it is OK to type in middle-East passwords, it's only in Far East
		// where the keyboards are switched out of IME.
		m_pSwitchKbd = new CMsiSwitchKeyboard(ieOnFEMachines);
	
	m_iLimit = 0;
 	if (((const ICHAR *) m_strText)[0] == TEXT('{'))
	{
		// FUTURE davidmck - there are better ways to get this integer out
		m_strText.Remove(iseIncluding, TEXT('{'));
		m_iLimit = (int)MsiString(m_strText.Extract(iseUpto, TEXT('}')));

		if (iMsiStringBadInteger == m_iLimit || m_iLimit < 0) // lets not get carried away
			return PostError(Imsg(idbgInvalidLimit), *m_strDialogName, *m_strKey, *m_strText);
		else if ( m_iLimit > (fMultiline ? 0xFFFFFFFF : 0x7FFFFFFE) )
			//  the limit is too large
			return PostError(Imsg(idbgInvalidLimit), *m_strDialogName, *m_strKey, *m_strText);
		m_strText.Remove(iseIncluding, TEXT('}'));
	}
	if (0 == m_iLimit)
		m_iLimit = EDIT_DEFAULT_TEXT_LIMIT;
	MsiString strNull;
	m_strRawText = strNull;
	bool fDoRichEdit = false;
	DWORD dwStyle = WS_BORDER | WS_TABSTOP | ES_AUTOHSCROLL |
						 (IsIntegerOnly () ? ES_NUMBER : 0) |
						 (fPassword ? ES_PASSWORD : 0) |
						 (fMultiline ? ES_MULTILINE | ES_AUTOVSCROLL | WS_VSCROLL : 0);
	DWORD dwExStyle = (m_fRTLRO ? WS_EX_RTLREADING : 0) |
							(m_fLeftScroll ? WS_EX_LEFTSCROLLBAR : 0) |
							(m_fRightAligned ? WS_EX_RIGHT : 0);
#ifdef FINAL
	Ensure(LoadRichEdit());
	fDoRichEdit = true;
#else
	if (!PMsiRecord(LoadRichEdit()))
		fDoRichEdit = true;
#endif
	if ( fDoRichEdit )
	{
		Ensure(CreateControlWindow(TEXT("RichEdit20W"),
											dwStyle | ES_NOOLEDRAGDROP, dwExStyle,
											*strNull, m_pWndDialog, m_iKey));
		WIN::SendMessage(m_pWnd, EM_SETTEXTMODE, TM_PLAINTEXT, fTrue);
		WIN::SendMessage(m_pWnd, EM_SETEDITSTYLE,
							  SES_BEEPONMAXTEXT, SES_BEEPONMAXTEXT);
	}
	else
		Ensure(CreateControlWindow(TEXT("Edit"), dwStyle, dwExStyle,
											*m_strText, m_pWndDialog, m_iKey))
	Ensure(WindowFinalize());
	WIN::SendMessage(m_pWnd, EM_LIMITTEXT, m_iLimit, 0);
	SetWindowText (*MsiString(GetPropertyValue ()));

	return 0;
}

IMsiRecord* CMsiEdit::GetPropertyFromDatabase()    
{
	if (m_fPreview)
		return 0;
	Ensure(CMsiActiveControl::GetPropertyFromDatabase ());
	MsiString strPropertyValue = GetPropertyValue();
	if (strPropertyValue.CharacterCount() > m_iLimit)
	{
		PMsiRecord precError = PostErrorDlgKey(Imsg(idbgOverLimit), *strPropertyValue, m_iLimit);	
		m_piEngine->Message(imtWarning, *precError);
		strPropertyValue = strPropertyValue.Extract(iseFirst, m_iLimit);
		Ensure(SetPropertyValue(*strPropertyValue, fFalse));
	}
	if ( !HasBeenChanged() )
		SetWindowText(*strPropertyValue);

	return 0;
}


IMsiRecord* CMsiEdit::PropertyChanged ()
{
	if (m_fPreview)
		return 0;

	Ensure(CMsiActiveControl::PropertyChanged());
	if ( !HasBeenChanged() )
		SetWindowText (*MsiString(GetPropertyValue()));

	return 0;
}


/*----------------------------------------------------------------------------
Set the text in the control to the passed value
------------------------------------------------------------------------------*/
void CMsiEdit::SetWindowText(const IMsiString &text)
{
	if (m_pWnd) 
	{
		//  I get the window's current text.  If it is the same as "text", I return.
		MsiString strPrevText = GetWindowText();
		if ( text.Compare(iscExact, strPrevText) )
			return;

		WCHAR *Buffer = new WCHAR[m_iLimit+1];
		if ( ! Buffer )
			return;
#ifdef UNICODE
		IStrCopyLen(Buffer, const_cast<ICHAR*>(text.GetString()), m_iLimit);
#else
		MsiString strNewText;
		if ( text.CharacterCount() > m_iLimit )
			strNewText = text.Extract(iseFirst, m_iLimit);
		else
		{
			strNewText = text;
			text.AddRef();
		}
		WIN::MultiByteToWideChar(WIN::GetACP(), 0, strNewText, -1, Buffer, m_iLimit+1);
#endif
		if (g_fNT4)
			WIN::SendMessageW(m_pWnd, WM_SETTEXT, 0, (LPARAM) Buffer);
		else
			WIN::SendMessageA(m_pWnd, WM_SETTEXT, 0, (LPARAM) Buffer);

		delete[] Buffer;
	}
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiEdit::GetLimit(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeLimit));
	riRecord.SetInteger(1, m_iLimit);
	return 0;
}
#endif // ATTRIBUTES

IMsiRecord* CMsiEdit::KillFocus(WPARAM wParam, LPARAM lParam)
/*----------------------------------------------------------------------------
------------------------------------------------------------------------------*/
{
	if ( !wParam ||
		  (WIN::GetWindowThreadProcessId(m_pWnd, NULL) !=
		   WIN::GetWindowThreadProcessId((HWND)wParam, NULL)) )   /* bug # 5879 */
	{
		//  the focus moved to a window in another thread.  There is no point in
		//  validating in this case.
		Ensure(LockDialog(fFalse));
		if ( m_pSwitchKbd )
			m_pSwitchKbd->SwitchToOriginalKbd(m_pWnd);
		return (CMsiActiveControl::KillFocus (wParam, lParam));
	}

	PMsiRecord piRecord = SetPropertyValue(*MsiString(GetWindowText ()), fTrue);
	if (piRecord)
	{
		Ensure(LockDialog(fTrue));
		m_piEngine->Message(imtWarning, *piRecord);
		//  I don't want to enter the control's default window procedure
		return PostErrorDlgKey(Imsg(idbgWinMes), 0);
	}
	else
	{
		Ensure(LockDialog(fFalse));
		if ( m_pSwitchKbd )
			m_pSwitchKbd->SwitchToOriginalKbd(m_pWnd);
		return (CMsiActiveControl::KillFocus (wParam, lParam));
	}
}

IMsiRecord* CMsiEdit::KeyDown(WPARAM wParam, LPARAM /*lParam*/)
{
	// RichEdit eats the TABs so we have to do the tabbing ourself -- yuck!!!
	bool fMoveFocus = false;
#ifdef FINAL
	if (wParam == VK_TAB && WIN::GetKeyState(VK_CONTROL) >= 0) // ignore CTRL-TAB
		fMoveFocus = true;
#else
	if (m_hRichEd20 && wParam == VK_TAB && WIN::GetKeyState(VK_CONTROL) >= 0) // ignore CTRL-TAB
		fMoveFocus = true;
#endif
	if ( fMoveFocus )
		WIN::SetFocus(WIN::GetNextDlgTabItem(m_pWndDialog, m_pWnd,
						  (WIN::GetKeyState(VK_SHIFT) < 0)));
	return 0;
}

IMsiRecord* CMsiEdit::SetFocus(WPARAM wParam, LPARAM lParam)
{
	WIN::SendMessage(m_pWnd, EM_SETSEL, 0, -1);
	if ( m_pSwitchKbd )
		m_pSwitchKbd->SwitchToEnglishKbd(m_pWnd);
	return CMsiActiveControl::SetFocus(wParam, lParam);
}

const IMsiString& CMsiEdit::GetWindowText ()
{
	int iLength = WIN::GetWindowTextLength(m_pWnd);
	MsiString text;
	if ( iLength == 0 )
		return *text;

	ICHAR *Buffer = new ICHAR[iLength + 1];
#ifdef FINAL
	GETTEXTEX gt;
	INT_PTR cch;			//--merced: changed int to INT_PTR
	gt.cb = (iLength + 1)* sizeof(ICHAR);
	gt.flags = GT_USECRLF;
	gt.lpDefaultChar = 0;
	gt.lpUsedDefChar = 0;
#ifdef UNICODE
	gt.codepage = 1200;
#else
	gt.codepage = WIN::GetACP();
#endif // UNICODE
	if (g_fNT4)
		cch = WIN::SendMessageW(m_pWnd, EM_GETTEXTEX, (WPARAM) &gt, (LPARAM)Buffer);
	else
		cch = WIN::SendMessageA(m_pWnd, EM_GETTEXTEX, (WPARAM) &gt, (LPARAM)Buffer);
	text = Buffer;
#else
	if(!m_hRichEd20)
	{
		WIN::GetWindowText(m_pWnd, Buffer, iLength + 1);
		text = Buffer;
	}
	else
	{
		GETTEXTEX gt;
		INT_PTR cch;			//--merced: changed int to INT_PTR
		gt.cb = (iLength + 1)*sizeof(ICHAR);
		gt.flags = GT_USECRLF;
		gt.lpDefaultChar = 0;
		gt.lpUsedDefChar = 0;
#ifdef UNICODE
		gt.codepage = 1200;
#else
		gt.codepage = WIN::GetACP();
#endif // UNICODE
		if (g_fNT4)
			cch = WIN::SendMessageW(m_pWnd, EM_GETTEXTEX, (WPARAM) &gt, (LPARAM)Buffer);
		else
			cch = WIN::SendMessageA(m_pWnd, EM_GETTEXTEX, (WPARAM) &gt, (LPARAM)Buffer);
		text = Buffer;
	}
#endif // FINAL
	const IMsiString *piStr = text;
	piStr->AddRef();
	delete [] Buffer;
	return (*piStr);
}


IMsiControl* CreateMsiEdit(IMsiEvent& riDialog)
{
	return new CMsiEdit(riDialog);
}


///////////////////////////////////////////////////////////////////////////
// CMsiRadioButtonGroup definition
///////////////////////////////////////////////////////////////////////////

class CMsiRadioButtonGroup:public CMsiActiveControl
{
public:

	CMsiRadioButtonGroup (IMsiEvent& riDialog);
	virtual ~CMsiRadioButtonGroup();
	virtual Bool            __stdcall CanTakeFocus();
	virtual IMsiRecord*     __stdcall WindowCreate(IMsiRecord& riRecord);
	virtual IMsiRecord*     __stdcall SetFocus();
	virtual IMsiRecord*     __stdcall GetPropertyFromDatabase();

protected:

	IMsiRecord*             SetVisible(Bool fVisible);
	IMsiRecord*             SetEnabled(Bool fEnabled);
	IMsiRecord*             SetFocus(WPARAM wParam, LPARAM lParam);
	static INT_PTR CALLBACK     ControlProc(WindowRef pWnd, WORD message, WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*     SetIndirectPropertyValue(const IMsiString& riValueString);
	virtual IMsiRecord*     PropertyChanged ();

private:
	IMsiRecord*             CursorCreate(IMsiCursor*& rpiCursor);
#ifdef ATTRIBUTES
	IMsiRecord*             GetItemsCount(IMsiRecord& riRecord);
	IMsiRecord*             GetItemsValue(IMsiRecord& riRecord);
	IMsiRecord*             GetItemsText(IMsiRecord& riRecord);
	IMsiRecord*             GetItemsX(IMsiRecord& riRecord);
	IMsiRecord*             GetItemsY(IMsiRecord& riRecord);
	IMsiRecord*             GetItemsWidth(IMsiRecord& riRecord);
	IMsiRecord*             GetItemsHeight(IMsiRecord& riRecord);
	IMsiRecord*             GetItemsHandle(IMsiRecord& riRecord);
	IMsiRecord*             GetHasBorder(IMsiRecord& riRecord);
	IMsiRecord*             GetPushLike(IMsiRecord& riRecord);
	IMsiRecord*             GetBitmap(IMsiRecord& riRecord);
	IMsiRecord*             GetIcon(IMsiRecord& riRecord);
#endif // ATTRIBUTES
	IMsiRecord*             Command(WPARAM wParam, LPARAM lParam);
	IMsiRecord*             PaintButtons();
	IMsiRecord*             PopulateList();
	PMsiTable               m_piRadioButtonTable; // persistent RadioButton table
	PMsiTable               m_piButtonsTable; // table of radio buttons
	INT_PTR                 m_iFirst;		  //--merced: changed int to INT_PTR
	Bool                    m_fPushLike;
	Bool                    m_fBitmap;
	Bool                    m_fIcon;
	Bool                    m_fFixedSize;
	Bool                    m_fHasBorder;
	Bool                    m_fOneSelected;
};

// Columns of the Buttons table
enum ButtonsColumns
{
	itabBUKey = 1,      //I
	itabBUHandle,       //I
	itabBUText,         //S
	itabBUBinary,       //I
	itabBUContextHelp,  //S
	itabBUToolTip,      //S
};

///////////////////////////////////////////////////////////////////////////
// CMsiRadioButtonGroup implementation
///////////////////////////////////////////////////////////////////////////

CMsiRadioButtonGroup::CMsiRadioButtonGroup(IMsiEvent& riDialog) :
	CMsiActiveControl(riDialog), m_piButtonsTable(0), m_piRadioButtonTable(0)
{
	m_iFirst = 0;
	m_fPushLike = fFalse;
	m_fBitmap = fFalse;
	m_fIcon = fFalse;
	m_fFixedSize = fFalse;
	m_fHasBorder = fFalse;
	m_fOneSelected = fFalse;
}

CMsiRadioButtonGroup::~CMsiRadioButtonGroup()
{
	if (m_piButtonsTable)
	{
		if (m_fBitmap || m_fIcon)
		{
			PMsiCursor piButtonsCursor(0);
			PMsiRecord(CursorCreate(*&piButtonsCursor));
			if ( piButtonsCursor )
				while (piButtonsCursor->Next())
				{
					HANDLE hImage = (HANDLE)GetHandleData(piButtonsCursor, itabBUBinary);
					AssertNonZero(m_piHandler->DestroyHandle(hImage) != -1);
				}
			else
				Assert(false);
		}
	}
	m_piRadioButtonTable = 0;
}

IMsiRecord* CMsiRadioButtonGroup::CursorCreate(IMsiCursor*& rpiCursor)
{
	return ::CursorCreate(*m_piButtonsTable, pcaTableIRadioButton, fFalse, *m_piServices, *&rpiCursor);
}

IMsiRecord* CMsiRadioButtonGroup::WindowCreate(IMsiRecord& riRecord) 
/*----------------------------------------------------------------------------
------------------------------------------------------------------------------*/
{
	int iAttributes = riRecord.GetInteger(itabCOAttributes);
	m_fPushLike = ToBool(iAttributes & msidbControlAttributesPushLike);
	m_fBitmap = ToBool(iAttributes & msidbControlAttributesBitmap);
	m_fIcon = ToBool(iAttributes & msidbControlAttributesIcon);
	m_fFixedSize = ToBool(iAttributes & msidbControlAttributesFixedSize);
	m_fHasBorder = ToBool(iAttributes & msidbControlAttributesHasBorder);
	if (m_fBitmap && m_fIcon)
	{
		return PostErrorDlgKey(Imsg(idbgBitmapIcon));
	}
	Ensure(CMsiActiveControl::WindowCreate(riRecord));
	Assert(!m_piButtonsTable);
	Ensure(m_piDatabase->LoadTable(*MsiString(*pcaTablePRadioButton), 0, *&m_piRadioButtonTable));
	Ensure(CreateTable(pcaTableIRadioButton, *&m_piButtonsTable));
	::CreateTemporaryColumn(*m_piButtonsTable, icdString + icdPrimaryKey, itabBUKey);
	::CreateTemporaryColumn(*m_piButtonsTable, IcdObjectPool() + icdNullable, itabBUHandle);
	::CreateTemporaryColumn(*m_piButtonsTable, icdString + icdNullable, itabBUText);
	::CreateTemporaryColumn(*m_piButtonsTable, IcdObjectPool() + icdNullable, itabBUBinary);
	::CreateTemporaryColumn(*m_piButtonsTable, icdString + icdNullable, itabBUContextHelp);
	::CreateTemporaryColumn(*m_piButtonsTable, icdString + icdNullable, itabBUToolTip);
	Ensure(CreateControlWindow(TEXT("BUTTON"),
				(m_fHasBorder ? BS_GROUPBOX : BS_OWNERDRAW) | WS_CLIPCHILDREN,
				WS_EX_CONTROLPARENT | (m_fRTLRO ? WS_EX_RTLREADING : 0) | (m_fRightAligned ? WS_EX_RIGHT : 0),
				*m_strText,
				m_pWndDialog,
				m_iKey));
	if (m_fIcon)
	{
		GetIconSize(iAttributes);
	}
	Ensure(WindowFinalize());
	Ensure(PopulateList());
	return 0;
}

IMsiRecord* CMsiRadioButtonGroup::GetPropertyFromDatabase()    
{
	if (m_fPreview)
		return 0;

	Ensure(CMsiActiveControl::GetPropertyFromDatabase ());
	Ensure(PaintButtons());
	return 0;
}

IMsiRecord* CMsiRadioButtonGroup::PopulateList()
{
	Assert(m_piButtonsTable);
	PMsiCursor piButtonsCursor(0);
	Ensure(CursorCreate(*&piButtonsCursor)); 
	// clean the old list first

	//  WIN::DestroyWindow sends WM_SHOWWINDOW w/ wParam=0 to visible button windows,
	//  these messages get processed by CMsiRadioButtonGroup and this will change the
	//  value of m_fVisible (bug # 6476).
	Bool fCacheVisible = m_fVisible;
	while (piButtonsCursor->Next())
	{
		if (m_fBitmap || m_fIcon)
		{
			HANDLE hImage = (HANDLE)GetHandleData(piButtonsCursor, itabBUBinary);
			AssertNonZero(m_piHandler->DestroyHandle(hImage) != -1);
		}
		WIN::DestroyWindow((WindowRef)GetHandleData(piButtonsCursor, itabBUHandle));
		AssertNonZero(piButtonsCursor->Delete());
	}
	if ( fCacheVisible )
		SetVisible(fCacheVisible);

	piButtonsCursor->Reset();
	PMsiView piRadioButtonView(0);
	Ensure(StartView(sqlRadioButton, *MsiString(GetPropertyName ()), *&piRadioButtonView));
	PMsiRecord piRecordNew(0);
	MsiString strText;
	MsiString strRawText;
	MsiString strValue;
	INT_PTR iValue;			//--merced: changed int to INT_PTR
	int iX;
	int iY;
	int iWidth;
	int iHeight;
	WindowRef pWnd;
	m_iFirst = 0;
	LONG_PTR RetVal;		//--merced: changed long to LONG_PTR
	RECT Rect;
	AssertNonZero(WIN::GetClientRect(m_pWnd, &Rect));
	DWORD dwStyle = 0;
	Bool fHasToolTip;
	MsiString strHelp;
	MsiString strToolTip;
	MsiString strContextHelp;
	MsiString strNull;
	MsiString strCurrentStyle;
	MsiString strDefaultStyle;
	if (g_fChicago)
	{
		dwStyle |= m_fPushLike ? BS_PUSHLIKE : 0;
		dwStyle |= m_fBitmap ? BS_BITMAP : 0;
		dwStyle |= m_fIcon ? BS_ICON : 0;
	}
	while (piRecordNew = piRadioButtonView->Fetch())
	{
		piButtonsCursor->Reset();
		strValue = piRecordNew->GetMsiString(itabRBValue);
		strValue = m_piEngine->FormatText(*strValue);
		piButtonsCursor->SetFilter(iColumnBit(itabBUKey));
		piButtonsCursor->PutString(itabBUKey, *strValue);
		if (!strValue.TextSize() || piButtonsCursor->Next())
			return PostError(Imsg(idbgValueNotUnique), *m_strDialogName, *m_strKey, *strValue);
		piButtonsCursor->Reset();
		piButtonsCursor->SetFilter(0);

		iX = piRecordNew->GetInteger(itabRBX);
		iY = piRecordNew->GetInteger(itabRBY);
		iWidth = piRecordNew->GetInteger(itabRBWidth);
		iHeight = piRecordNew->GetInteger(itabRBHeight);
		int idyChar = m_piHandler->GetTextHeight();
		iX = iX*idyChar/iDlgUnitSize; 
		iY = iY*idyChar/iDlgUnitSize; 
		iWidth = iWidth*idyChar/iDlgUnitSize; 
		iHeight = iHeight*idyChar/iDlgUnitSize;
		strRawText = piRecordNew->GetMsiString(itabRBText);
		strRawText = m_piEngine->FormatText(*strRawText);
		strCurrentStyle = strNull;
		strDefaultStyle = strNull;
		Ensure(ProcessText(strRawText, strText, strCurrentStyle, strDefaultStyle, 0, /*fFormat = */true));
		strToolTip = strNull;
		strContextHelp = strNull;
		strHelp = piRecordNew->GetMsiString(itabRBHelp);
		if (strHelp.TextSize())
		{
			if (!strHelp.Compare(iscWithin, TEXT("|")))
				return PostError(Imsg(idbgNoHelpSeparator), *m_strDialogName, *m_strKey, *strHelp);
			strToolTip = strHelp.Extract(iseUpto, TEXT('|'));
			strContextHelp = strHelp.Extract(iseAfter, TEXT('|'));
		}
		fHasToolTip = ToBool(strToolTip.TextSize());

		if (iX < Rect.left)
		{
			PMsiRecord piReturn = PostError(Imsg(idbgRadioButtonOff), *m_strDialogName, *m_strKey, *strText, *MsiString(*TEXT("to the left")), *MsiString(Rect.left - iX));
			m_piEngine->Message(imtInfo, *piReturn);
		}
		if (iY < Rect.top)
		{
			PMsiRecord piReturn = PostError(Imsg(idbgRadioButtonOff), *m_strDialogName, *m_strKey, *strText, *MsiString(*TEXT("on the top")), *MsiString(Rect.top - iY));
			m_piEngine->Message(imtInfo, *piReturn);
		}
		if (iX + iWidth > Rect.right)
		{
			PMsiRecord piReturn = PostError(Imsg(idbgRadioButtonOff), *m_strDialogName, *m_strKey, *strText, *MsiString(*TEXT("to the right")), *MsiString(int(iX + iWidth - Rect.right)));
			m_piEngine->Message(imtInfo, *piReturn);
		}
		if (iY + iHeight > Rect.bottom)
		{
			PMsiRecord piReturn = PostError(Imsg(idbgRadioButtonOff), *m_strDialogName, *m_strKey, *strText, *MsiString(*TEXT("on the bottom")), *MsiString(int(iY + iHeight - Rect.bottom)));
			m_piEngine->Message(imtInfo, *piReturn);
		}
		AssertNonZero(piButtonsCursor->PutString(itabBUKey, *strValue));
		iValue = m_piDatabase->EncodeString(*strValue);
		pWnd = WIN::CreateWindowEx((m_fRTLRO ? WS_EX_RTLREADING : 0) | (m_fRightAligned ? WS_EX_RIGHT : 0),
											TEXT("BUTTON"),
											(m_fBitmap || m_fIcon) ? strToolTip : strText,
											WS_CHILD | BS_RADIOBUTTON | dwStyle | BS_MULTILINE,
											iX, iY, iWidth, iHeight, m_pWnd,
											(HMENU)iValue, g_hInstance, 0);
		if (!pWnd)
			return PostErrorDlgKey(Imsg(idbgCreateControlWindow));
#ifdef _WIN64	// !merced
		SetCallbackFunction((WNDPROC)WIN::GetWindowLongPtr(pWnd, GWLP_WNDPROC));
		RetVal = WIN::SetWindowLongPtr(pWnd, GWLP_WNDPROC, (LONG_PTR)ControlProc);
		if (RetVal == 0)
		{
			return PostErrorDlgKey(Imsg(idbgCreateControlWindow));
		}
		WIN::SetWindowLongPtr(pWnd, GWLP_USERDATA, (LONG_PTR)this);
#else			// win-32. This should be removed with the 64-bit windows.h is #included.
		SetCallbackFunction((WNDPROC)WIN::GetWindowLong(pWnd, GWL_WNDPROC));
		RetVal = WIN::SetWindowLong(pWnd, GWL_WNDPROC, (long)ControlProc);
		if (RetVal == 0)
		{
			return PostErrorDlgKey(Imsg(idbgCreateControlWindow));
		}
		WIN::SetWindowLong(pWnd, GWL_USERDATA, (long)this);
#endif
		AssertNonZero(PutHandleData(piButtonsCursor, itabBUHandle, (UINT_PTR)pWnd));
		AssertNonZero(piButtonsCursor->PutString(itabBUText, *strText));
		AssertNonZero(piButtonsCursor->PutString(itabBUContextHelp, *strContextHelp));
		AssertNonZero(piButtonsCursor->PutString(itabBUToolTip, *strToolTip));
		if (m_fBitmap)
		{
			HBITMAP hBitmap = 0;
			Ensure(StretchBitmap(*strText, iWidth - 2 - (m_fPushLike ? 0 : 19), iHeight - 2, m_fFixedSize, pWnd, *&hBitmap));
			WIN::SendMessage(pWnd, BM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) (HANDLE) hBitmap);
			AssertNonZero(PutHandleData(piButtonsCursor, itabBUBinary, (UINT_PTR)hBitmap));
			AssertNonZero(m_piHandler->RecordHandle(CWINHND(hBitmap, iwhtGDIObject)) != -1);
		}
		if (m_fIcon)
		{
			HICON hIcon = 0;
			Ensure(UnpackIcon(*strText, *&hIcon, iWidth - 2 - (m_fPushLike ? 0 : 19), iHeight - 2, m_fFixedSize));
			WIN::SendMessage(pWnd, BM_SETIMAGE, (WPARAM) IMAGE_ICON, (LPARAM) (HANDLE) hIcon);
			AssertNonZero(PutHandleData(piButtonsCursor, itabBUBinary, (UINT_PTR)hIcon));
			AssertNonZero(m_piHandler->RecordHandle(CWINHND(hIcon, iwhtIcon)) != -1);
		}
		AssertNonZero(piButtonsCursor->Insert());
		if (fHasToolTip && m_pWndToolTip)
		{
			TOOLINFO ti;
			int iSize = TOOLINFOsize();
			memset(&ti, 0, iSize);
			ti.cbSize = iSize;
			ti.uFlags = TTF_IDISHWND;
			ti.hwnd = m_pWnd;
			ti.uId = (UINT_PTR) pWnd;	
			ti.hinst = g_hInstance;
			ti.lpszText = (ICHAR *)(const ICHAR *) MsiString(piButtonsCursor->GetString(itabBUToolTip));
			WIN::SendMessage(m_pWndToolTip, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
		}
		PAINTSTRUCT ps;
		HDC hdc = WIN::BeginPaint(pWnd, &ps);
		IMsiRecord* piRecord = ChangeFontStyle(hdc, *strCurrentStyle, pWnd);
		WIN::EndPaint(pWnd, &ps);


		WIN::ShowWindow(pWnd, m_fVisible ? SW_SHOW : SW_HIDE);
		
		if (!m_iFirst)
		{
			m_iFirst = iValue;
			WIN::ChangeWindowStyle(pWnd, 0, WS_GROUP, fFalse);
		}
	}
	if (m_fPreview)
		return 0;
	int iCount = m_piButtonsTable->GetRowCount();
	if ( iCount < 2)
	{
		return PostErrorDlgKey(Imsg(idbgRBNoButtons));
	}
	Ensure(piRadioButtonView->Close());
	AssertNonZero(WIN::InvalidateRect(m_pWndDialog, 0, fTrue));
	Ensure(PaintButtons());
	return 0;
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiRadioButtonGroup::GetHasBorder(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeHasBorder));
	riRecord.SetInteger(1, m_fHasBorder);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiRadioButtonGroup::GetPushLike(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributePushLike));
	riRecord.SetInteger(1, m_fPushLike);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiRadioButtonGroup::GetBitmap(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeBitmap));
	riRecord.SetInteger(1, m_fBitmap);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiRadioButtonGroup::GetIcon(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeIcon));
	riRecord.SetInteger(1, m_fIcon);
	return 0;
}
#endif // ATTRIBUTES


IMsiRecord* CMsiRadioButtonGroup::PropertyChanged ()
{
	if (m_fPreview)
		return 0;
	Ensure(CMsiActiveControl::PropertyChanged ());
	Ensure(PaintButtons());
	return 0;
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiRadioButtonGroup::GetItemsCount(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeItemsCount));
	riRecord.SetInteger(1, m_piButtonsTable->GetRowCount());
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiRadioButtonGroup::GetItemsValue(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, m_piButtonsTable->GetRowCount(), pcaControlAttributeItemsValue));
	PMsiCursor piButtonsCursor(0);
	Ensure(CursorCreate(*&piButtonsCursor)); 
	int count = 0;
	while (piButtonsCursor->Next())
	{   
		riRecord.SetMsiString(++count, *MsiString(piButtonsCursor->GetString(itabBUKey)));
	}
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiRadioButtonGroup::GetItemsHandle(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, m_piButtonsTable->GetRowCount(), pcaControlAttributeItemsHandle));
	PMsiCursor piButtonsCursor(0);
	Ensure(CursorCreate(*&piButtonsCursor)); 
	int count = 0;
	while (piButtonsCursor->Next())
	{   
		riRecord.SetInteger(++count, piButtonsCursor->GetInteger(itabBUHandle));
	}
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiRadioButtonGroup::GetItemsText(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, m_piButtonsTable->GetRowCount(), pcaControlAttributeItemsText));
	PMsiCursor piButtonsCursor(0);
	Ensure(CursorCreate(*&piButtonsCursor)); 
	int count = 0;
	while (piButtonsCursor->Next())
	{   
		riRecord.SetMsiString(++count, *MsiString(piButtonsCursor->GetString(itabBUText)));
	}
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiRadioButtonGroup::GetItemsX(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, m_piButtonsTable->GetRowCount(), pcaControlAttributeItemsX));
	PMsiCursor piButtonsCursor(0);
	Ensure(CursorCreate(*&piButtonsCursor)); 
	int count = 0;
	while (piButtonsCursor->Next())
	{   
		RECT rect;
		AssertNonZero(WIN::GetWindowRect((WindowRef) GetHandleData(piButtonsCursor, itabBUHandle), &rect));
		riRecord.SetInteger(++count, rect.left);
	}
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiRadioButtonGroup::GetItemsY(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, m_piButtonsTable->GetRowCount(), pcaControlAttributeItemsY));
	PMsiCursor piButtonsCursor(0);
	PMsiRecord(CursorCreate(*&piButtonsCursor)); 
	int count = 0;
	while (piButtonsCursor->Next())
	{   
		RECT rect;
		AssertNonZero(WIN::GetWindowRect((WindowRef) GetHandleData(piButtonsCursor, itabBUHandle), &rect));
		riRecord.SetInteger(++count, rect.top);
	}
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiRadioButtonGroup::GetItemsWidth(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, m_piButtonsTable->GetRowCount(), pcaControlAttributeItemsWidth));
	PMsiCursor piButtonsCursor(0);
	Ensure(CursorCreate(*&piButtonsCursor)); 
	int count = 0;
	while (piButtonsCursor->Next())
	{   
		RECT rect;
		AssertNonZero(WIN::GetWindowRect((WindowRef) GetHandleData(piButtonsCursor, itabBUHandle), &rect));
		riRecord.SetInteger(++count, rect.right - rect.left);
	}
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiRadioButtonGroup::GetItemsHeight(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, m_piButtonsTable->GetRowCount(), pcaControlAttributeItemsHeight));

	PMsiCursor piButtonsCursor(0);
	Ensure(CursorCreate(*&piButtonsCursor)); 
	int count = 0;
	while (piButtonsCursor->Next())
	{   
		RECT rect;
		AssertNonZero(WIN::GetWindowRect((WindowRef) GetHandleData(piButtonsCursor, itabBUHandle), &rect));
		riRecord.SetInteger(++count, rect.bottom - rect.top);
	}
	return 0;
}
#endif // ATTRIBUTES

IMsiRecord* CMsiRadioButtonGroup::SetVisible(Bool fVisible)
{
	m_fVisible = fVisible;
	WIN::ShowWindow(m_pWnd, m_fVisible ? SW_SHOW : SW_HIDE);
	PMsiCursor piButtonsCursor(0);
	Ensure(CursorCreate(*&piButtonsCursor)); 
	WindowRef pwnd;
	while (piButtonsCursor->Next())
	{
		pwnd = (WindowRef) GetHandleData(piButtonsCursor, itabBUHandle);
		WIN::ShowWindow(pwnd, m_fVisible ? SW_SHOW : SW_HIDE);
	}
	return 0;
}

IMsiRecord* CMsiRadioButtonGroup::SetEnabled(Bool fEnabled)
{
	m_fEnabled = fEnabled;
	WIN::EnableWindow(m_pWnd, fEnabled);
	PMsiCursor piButtonsCursor(0);
	Ensure(CursorCreate(*&piButtonsCursor)); 
	WindowRef pwnd;
	while (piButtonsCursor->Next())
	{
		pwnd = (WindowRef)GetHandleData(piButtonsCursor, itabBUHandle);
		WIN::EnableWindow(pwnd, m_fEnabled);
	}
	return 0;
}

Bool CMsiRadioButtonGroup::CanTakeFocus()
{
	return m_fOneSelected ? CMsiActiveControl::CanTakeFocus() : fFalse;
}



IMsiRecord* CMsiRadioButtonGroup::PaintButtons()
/*----------------------------------------------------------------------------
------------------------------------------------------------------------------*/
{
	Ensure(CheckInitialized());

	PMsiCursor piButtonsCursor(0);
	Ensure(CursorCreate(*&piButtonsCursor));
	MsiStringId nPropertyValueId = m_piDatabase->EncodeString(*MsiString(GetPropertyValue()));
	m_fOneSelected = fFalse;
	while (piButtonsCursor->Next())
	{
		bool fSelected;

		WindowRef pwnd = (WindowRef)GetHandleData(piButtonsCursor, itabBUHandle);
		fSelected = (piButtonsCursor->GetInteger(itabBUKey) == nPropertyValueId);
		if ( fSelected )
		{
			m_fOneSelected = fTrue;
			WIN::SendMessage(pwnd, BM_SETCHECK, BST_CHECKED, 0L);
		}
		else
			WIN::SendMessage(pwnd, BM_SETCHECK, BST_UNCHECKED, 0L);
	}
	return 0;
}

IMsiRecord* CMsiRadioButtonGroup::SetIndirectPropertyValue(const IMsiString& riValueString)
{
	Ensure(CMsiActiveControl::SetIndirectPropertyValue(riValueString));
	Ensure(PopulateList());
	return 0;
}

IMsiRecord* CMsiRadioButtonGroup::Command(WPARAM /*wParam*/, LPARAM lParam)
{
	Ensure(CheckInitialized());

	HWND hWnd = (HWND)lParam;
	if (hWnd == m_pWnd)	  // the user clicked the group, outside of any button
	{
		Ensure(SetFocus());
		return 0;
	}
	PMsiCursor piButtonsCursor(0);
	Ensure(CursorCreate(*&piButtonsCursor)); 
	piButtonsCursor->SetFilter(iColumnBit(itabBUHandle));
	piButtonsCursor->Reset();
	AssertNonZero(PutHandleData(piButtonsCursor, itabBUHandle, (INT_PTR)hWnd));
	AssertNonZero(piButtonsCursor->Next());
	Ensure(SetPropertyValue (*MsiString(piButtonsCursor->GetString(itabBUKey)), fTrue));
	// fixes bug 146251.
	Ensure(m_piDialog->SetFocus(*m_strKey));
	return 0;
}

IMsiRecord* CMsiRadioButtonGroup::SetFocus(WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	// overwrite the base class
	return 0;
}




IMsiRecord* CMsiRadioButtonGroup::SetFocus()
/*----------------------------------------------------------------------------
------------------------------------------------------------------------------*/
{
	Ensure(CheckInitialized());

	PMsiCursor piButtonsCursor(0);
	Ensure(CursorCreate(*&piButtonsCursor)); 
	piButtonsCursor->SetFilter(iColumnBit(itabBUKey));
	piButtonsCursor->Reset();
	MsiString strPropVal = GetPropertyValue();
	if (strPropVal.TextSize())
	{
		AssertNonZero(piButtonsCursor->PutString(itabBUKey, *strPropVal));
		AssertNonZero(piButtonsCursor->Next());
		WIN::SetFocus((WindowRef) GetHandleData(piButtonsCursor, itabBUHandle));
	}
	return 0;
}


INT_PTR CALLBACK CMsiRadioButtonGroup::ControlProc(WindowRef pWnd, WORD message, WPARAM wParam, LPARAM lParam)
/*----------------------------------------------------------------------------
------------------------------------------------------------------------------*/
{
#ifdef _WIN64	// !merced
	CMsiRadioButtonGroup* pControl = (CMsiRadioButtonGroup*)WIN::GetWindowLongPtr(pWnd, GWLP_USERDATA);
#else	// win-32. This should be removed with the 64-bit windows.h is #included.
	CMsiRadioButtonGroup* pControl = (CMsiRadioButtonGroup*)WIN::GetWindowLong(pWnd, GWL_USERDATA);
#endif
	Bool fKilling = fFalse;
	switch (message)
	{
		case WM_NCDESTROY:
			return 0;
			break;
		case WM_CHAR:
		case WM_COMMAND:
		case WM_SYSKEYUP:
			{
 				PMsiRecord piReturn = pControl->WindowMessage(message, wParam, lParam);
				if (piReturn)
				{
					if (piReturn->GetInteger(1) == idbgWinMes)
					{
						return piReturn->GetInteger(4);  // the control wants us to return this number
					}
					// we have an error message
					piReturn->AddRef(); // we want to keep it around
					PMsiEvent piDialog = &pControl->GetDialog();
					piDialog->SetErrorRecord(*piReturn);
					return 0;
				}
				break;
			}
		case WM_MOUSEMOVE:
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_RBUTTONDOWN:
		case WM_RBUTTONUP:
			if (pControl->m_pWndToolTip)
			{
				MSG msg;
				msg.lParam = lParam;
				msg.wParam = wParam;
				msg.message = message;
				msg.hwnd = pWnd;
				WIN::SendMessage(pControl->m_pWndToolTip, TTM_RELAYEVENT, 0, (LPARAM)(LPMSG) &msg);
			}
			break;
	}	
	return WIN::CallWindowProc((WNDPROC)CMsiControl::ControlProc, pWnd, message, wParam, lParam);
}

IMsiControl* CreateMsiRadioButtonGroup(IMsiEvent& riDialog)
{
	return new CMsiRadioButtonGroup(riDialog);
}


/////////////////////////////////////////////
// CMsiCheckBox  definition
/////////////////////////////////////////////

class CMsiCheckBox:public CMsiActiveControl
{
public:
	CMsiCheckBox(IMsiEvent& riDialog);
	virtual ~CMsiCheckBox();
	virtual IMsiRecord*			__stdcall WindowCreate(IMsiRecord& riRecord);
	virtual IMsiRecord*        __stdcall GetPropertyFromDatabase();

	
protected:

	virtual IMsiRecord* PropertyChanged ();
#ifdef ATTRIBUTES
	IMsiRecord*             GetPushLike(IMsiRecord& riRecord);
	IMsiRecord*             GetBitmap(IMsiRecord& riRecord);
	IMsiRecord*             GetIcon(IMsiRecord& riRecord);
#endif // ATTRIBUTES

private:
	IMsiRecord*			Command(WPARAM wParam, LPARAM lParam);

	Bool       m_fPushLike;
	Bool       m_fBitmap;
	Bool       m_fIcon;
	Bool       m_fFixedSize;
	HANDLE     m_hBinary;
	MsiString  m_strOnValue;
};

/////////////////////////////////////////////////
// CMsiCheckBox  implementation
/////////////////////////////////////////////////

CMsiCheckBox::CMsiCheckBox(IMsiEvent& riDialog) : CMsiActiveControl(riDialog)
{
	m_fPushLike = fFalse;
	m_fBitmap = fFalse;
	m_fIcon = fFalse;
	m_fFixedSize = fFalse;
	m_hBinary = 0;
	MsiString strNull;
	m_strOnValue = strNull;
}

CMsiCheckBox::~CMsiCheckBox()
{
	if (m_hBinary)
		AssertNonZero(m_piHandler->DestroyHandle((HANDLE)m_hBinary) != -1);
}

IMsiRecord* CMsiCheckBox::WindowCreate(IMsiRecord& riRecord)
{
	int iAttributes = riRecord.GetInteger(itabCOAttributes);
	m_fPushLike = ToBool(iAttributes & msidbControlAttributesPushLike);
	m_fBitmap = ToBool(iAttributes & msidbControlAttributesBitmap);
	m_fIcon = ToBool(iAttributes & msidbControlAttributesIcon);
	m_fFixedSize = ToBool(iAttributes & msidbControlAttributesFixedSize);
	Ensure(CMsiActiveControl::WindowCreate(riRecord));
	DWORD dwStyle = 0;
	if (g_fChicago)
	{
	dwStyle |= m_fPushLike ? BS_PUSHLIKE : 0;
	dwStyle |= m_fBitmap ? BS_BITMAP : 0;
	dwStyle |= m_fIcon ? BS_ICON : 0;
	}
	Ensure(CreateControlWindow(TEXT("BUTTON"),
		BS_CHECKBOX | dwStyle | BS_MULTILINE | WS_TABSTOP, 
		(m_fRTLRO ? WS_EX_RTLREADING : 0) | (m_fRightAligned ? WS_EX_RIGHT : 0),
		(m_fBitmap || m_fIcon) ? *m_strToolTip : *m_strText, m_pWndDialog, m_iKey));
	Ensure(WindowFinalize());
	if (m_fBitmap)
	{
		HBITMAP hBitmap = 0;
		Ensure(StretchBitmap(*m_strText, m_iWidth - 2 - (m_fPushLike ? 0 : 20), m_iHeight - 2, m_fFixedSize, m_pWnd, *&hBitmap));
		WIN::SendMessage(m_pWnd, BM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) (HANDLE) hBitmap);
		m_hBinary = hBitmap;
		AssertNonZero(m_piHandler->RecordHandle(CWINHND(hBitmap, iwhtGDIObject)) != -1);
	}
	if (m_fIcon)
	{
		HICON hIcon = 0;
		GetIconSize(iAttributes);
		Ensure(UnpackIcon(*m_strText, *&hIcon, m_iWidth - 2 - (m_fPushLike ? 0 : 20), m_iHeight - 2, m_fFixedSize));
		WIN::SendMessage(m_pWnd, BM_SETIMAGE, (WPARAM) IMAGE_ICON, (LPARAM) (HANDLE) hIcon);
		m_hBinary = hIcon;
		AssertNonZero(m_piHandler->RecordHandle(CWINHND(hIcon, iwhtIcon)) != -1);
	}
	return 0;
}

IMsiRecord* CMsiCheckBox::GetPropertyFromDatabase()    
{
	if (m_fPreview)
		return 0;

	Ensure(CMsiActiveControl::GetPropertyFromDatabase ());
	MsiString valueStr(GetPropertyValue());
	if (!m_strOnValue.TextSize())
	{
		m_strOnValue = MsiString(*TEXT("1"));
		itsEnum its = m_piDatabase->FindTable(*MsiString(*pcaTablePCheckBox));
		if (its == itsUnknown)
		{
			if (valueStr.TextSize())
				m_strOnValue = valueStr;
		}
		else 
		{
			PMsiView piView(0);
			Ensure(CMsiControl::StartView(sqlCheckBox, *MsiString(GetPropertyName ()), *&piView)); 
			PMsiRecord piRecordNew(0);
			while (piRecordNew = piView->Fetch())
			{
				m_strOnValue = piRecordNew->GetMsiString(1);
				m_strOnValue = m_piEngine->FormatText(*m_strOnValue);
			}
			Ensure(piView->Close());
		}
		if (valueStr.TextSize())
		{
			Ensure(SetOriginalValue(*m_strOnValue));
			Ensure(SetPropertyValue(*m_strOnValue, fFalse));
		}
	}
	WIN::SendMessage(m_pWnd, BM_SETCHECK, ToBool(valueStr.TextSize()), 0L);

	return 0;
}

IMsiRecord* CMsiCheckBox::Command(WPARAM, LPARAM)
{
	MsiString valueStr(GetPropertyValue());
	if (valueStr.TextSize()) // if it was on
	{
		Ensure(SetPropertyValue(*MsiString(), fTrue));
	}
	else
	{
		Ensure(SetPropertyValue(*m_strOnValue, fTrue));
	}
	return 0;
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiCheckBox::GetPushLike(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributePushLike));
	riRecord.SetInteger(1, m_fPushLike);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiCheckBox::GetBitmap(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeBitmap));
	riRecord.SetInteger(1, m_fBitmap);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiCheckBox::GetIcon(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeIcon));
	riRecord.SetInteger(1, m_fIcon);
	return 0;
}
#endif // ATTRIBUTES


IMsiRecord* CMsiCheckBox::PropertyChanged ()
{
	if (m_fPreview)
		return 0;
	Ensure(CMsiActiveControl::PropertyChanged ());
	MsiString valueStr(GetPropertyValue());
	WIN::SendMessage(m_pWnd, BM_SETCHECK, ToBool(valueStr.TextSize()), 0L);
	return (0);
}

IMsiControl* CreateMsiCheckBox(IMsiEvent& riDialog)
{
	return new CMsiCheckBox(riDialog);
}

/////////////////////////////////////////////
// CMsiBitmap  definition
/////////////////////////////////////////////

class CMsiBitmap:public CMsiControl
{
public:
	CMsiBitmap(IMsiEvent& riDialog);
	~CMsiBitmap();
	IMsiRecord*            __stdcall WindowCreate(IMsiRecord& riRecord);
protected:
	IMsiRecord*            GetImage(IMsiRecord& riRecord);
	IMsiRecord*            SetImage(IMsiRecord& riRecord);
	IMsiRecord*            GetImageHandle(IMsiRecord& riRecord);
	IMsiRecord*            SetImageHandle(IMsiRecord& riRecord);
private:
	IMsiRecord*            SetImage();
	Bool                   m_fFixedSize;
	IMsiRecord*            Paint(WPARAM wParam, LPARAM lParam);
	void                   SetImage(HBITMAP hBitmap);
	HBITMAP                m_hBitmap;
};

/////////////////////////////////////////////////
// CMsiBitmap  implementation
/////////////////////////////////////////////////

CMsiBitmap::CMsiBitmap(IMsiEvent& riDialog) : CMsiControl(riDialog)
{
	m_fFixedSize = fFalse;
	m_hBitmap = 0;
}

CMsiBitmap::~CMsiBitmap()
{
	if (m_hBitmap)
		AssertNonZero(m_piHandler->DestroyHandle(m_hBitmap) != -1);
}



IMsiRecord* CMsiBitmap::WindowCreate(IMsiRecord& riRecord)
{
	Ensure(CMsiControl::WindowCreate(riRecord));
	int iAttributes = riRecord.GetInteger(itabCOAttributes);
	m_fFixedSize = ToBool(iAttributes & msidbControlAttributesFixedSize);
	Ensure(CreateControlWindow(TEXT("STATIC"),
				SS_BITMAP | SS_CENTERIMAGE, 0,
				m_fHasToolTip ? *m_strToolTip : *m_strText, m_pWndDialog, m_iKey));
	if ( m_fSunken )
	{
		//  the sizes need to be adjusted
		RECT strSize;
		AssertNonZero(WIN::GetClientRect(m_pWnd, &strSize));
		m_iWidth = strSize.right - strSize.left;
		m_iHeight = strSize.bottom - strSize.top;
	}
	m_fEnabled = fFalse; // a bitmap is a button, but should be disabled, so we can't click on it
	AssertNonZero(WIN::SetWindowPos(m_pWnd, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE));
	Ensure(SetImage());
	Ensure(WindowFinalize());
	return 0;
}

IMsiRecord* CMsiBitmap::SetImage()
{
	HBITMAP hBitmap = 0;
	Ensure(StretchBitmap(*m_strText, m_iWidth, m_iHeight, m_fFixedSize, m_pWnd, *&hBitmap));
	SetImage(hBitmap);
	return 0;
}

void CMsiBitmap::SetImage(HBITMAP hBitmap)
{
	if ( hBitmap == m_hBitmap )
		return;

	if (g_fChicago)
		WIN::SendMessage(m_pWnd, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) (HANDLE) hBitmap);

	if (m_hBitmap && m_hBitmap != hBitmap)
		AssertNonZero(m_piHandler->DestroyHandle((HANDLE)m_hBitmap) != -1);
	m_hBitmap = hBitmap;
	AssertNonZero(m_piHandler->RecordHandle(CWINHND((HANDLE)hBitmap, iwhtGDIObject)) != -1);
	AssertNonZero(WIN::InvalidateRect(m_pWnd, 0, fTrue));
}

IMsiRecord* CMsiBitmap::GetImage(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeImage));
	riRecord.SetMsiString(1, *m_strText);
	return 0;
}

IMsiRecord* CMsiBitmap::SetImage(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeImage));
	m_strText = riRecord.GetMsiString(1);
	return SetImage();
}

IMsiRecord* CMsiBitmap::GetImageHandle(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeImageHandle));
	riRecord.SetHandle(1, (HANDLE) m_hBitmap);
	return 0;
}

IMsiRecord* CMsiBitmap::SetImageHandle(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeImageHandle));
	SetImage((HBITMAP) riRecord.GetHandle(1));
	return 0;
}
	
IMsiRecord* CMsiBitmap::Paint(WPARAM, LPARAM)
{
	if (g_fChicago) // on Win95 the system knows how to paint the bitmap
		return 0;

	//Painting without palettes
	PAINTSTRUCT ps;
	BITMAP bitmap;
	POINT bSize, origin;
	HDC hDCWin;
	HDC hDCMem = NULL;

	hDCWin = WIN::BeginPaint(m_pWnd, &ps);
	if ( hDCWin )
	{
		// create a compatible memory dc to place bitmap in
		hDCMem = WIN::CreateCompatibleDC(hDCWin);
	}

	if ( ! hDCWin || ! hDCMem )
		return PostError(Imsg(idbgPaintError), *m_strDialogName);

	// select bitmap into memory
	WIN::SelectObject(hDCMem, m_hBitmap);
	// get statistics of bitmap
	WIN::GetObject(m_hBitmap, sizeof(BITMAP), (LPSTR)&bitmap);
	// convert size and origin
	bSize.x = bitmap.bmWidth;
	bSize.y = bitmap.bmHeight;
	AssertNonZero(WIN::DPtoLP(hDCWin, &bSize, 1));
	origin.x = origin.y = 0;
	AssertNonZero(WIN::DPtoLP(hDCWin, &origin, 1));
	// draw bitmap onto device context
	PMsiRecord piPaletteRecord = &m_piServices->CreateRecord(1);
	AssertRecord(m_piDialog->AttributeEx(fFalse, dabPalette, *piPaletteRecord));
	HPALETTE hPalette = (HPALETTE) piPaletteRecord->GetHandle(1);
	HPALETTE hPalSave = 0;
	Bool fInFront = ToBool(WIN::GetParent (m_pWnd) == WIN::GetActiveWindow ());
	if (hPalette)
	{
		//!! Palette switching should be done only on WM_PALETTE* messages
		//AssertNonZero(hPalSave = WIN::SelectPalette(hDCWin, hPalette, !fInFront));
		//AssertNonZero (GDI_ERROR != WIN::RealizePalette(hDCWin));
	}
	WIN::StretchBlt(hDCWin, 0, 0, m_iWidth, m_iHeight, hDCMem, origin.x, origin.y, bSize.x, bSize.y, SRCCOPY);
	// cleanup
	if (hPalSave)
		WIN::SelectPalette(hDCWin, hPalSave, !fInFront);
	AssertNonZero(WIN::DeleteDC(hDCMem));
	WIN::EndPaint(m_pWnd, &ps); 
	return 0;
}

IMsiControl* CreateMsiBitmap(IMsiEvent& riDialog)
{
	return new CMsiBitmap(riDialog);
}

/////////////////////////////////////////////
// CMsiIcon  definition
/////////////////////////////////////////////

class CMsiIcon:public CMsiControl
{
public:

	CMsiIcon(IMsiEvent& riDialog);
	virtual ~CMsiIcon ();
	virtual IMsiRecord*    __stdcall WindowCreate(IMsiRecord& riRecord);
	virtual const ICHAR*   __stdcall GetControlType() const { return m_szControlType; }

protected:

	IMsiRecord*            GetImage(IMsiRecord& riRecord);
	IMsiRecord*            SetImage(IMsiRecord& riRecord);
	IMsiRecord*            GetImageHandle(IMsiRecord& riRecord);
	IMsiRecord*            SetImageHandle(IMsiRecord& riRecord);
private:

	IMsiRecord*            SetImage();
	Bool                   m_fFixedSize;
	IMsiRecord*            Paint(WPARAM wParam, LPARAM lParam);
	void                   SetImage(HICON hIcon);
	HICON                  m_hIcon;
	Bool                   m_fLetSystemDraw;
	static const ICHAR*    m_szControlType;
};

/////////////////////////////////////////////////
// CMsiIcon  implementation
/////////////////////////////////////////////////

const ICHAR* CMsiIcon::m_szControlType = g_szIconType;

CMsiIcon::CMsiIcon(IMsiEvent& riDialog) : CMsiControl(riDialog)
{
	m_fFixedSize = fFalse;
	m_hIcon = 0;
	m_fLetSystemDraw = g_fNT4;
}

CMsiIcon::~CMsiIcon()
{
	if (m_hIcon)
		AssertNonZero(m_piHandler->DestroyHandle((HANDLE)m_hIcon) != -1);
}

IMsiRecord* CMsiIcon::WindowCreate(IMsiRecord& riRecord)
{
	Ensure(CMsiControl::WindowCreate(riRecord));
	int iAttributes = riRecord.GetInteger(itabCOAttributes);
	m_fFixedSize = ToBool(iAttributes & msidbControlAttributesFixedSize);
	if (!m_fLetSystemDraw)
		m_fEnabled = fFalse; // an icon is a button, but should be disabled, so we can't click on it
	if (m_fLetSystemDraw)
	{
		Ensure(CreateControlWindow(TEXT("STATIC"), SS_ICON | SS_CENTERIMAGE, 0, m_fHasToolTip ? *m_strToolTip : *m_strText, m_pWndDialog, m_iKey));
	}
	else
	{
		Ensure(CreateControlWindow(TEXT("BUTTON"), BS_OWNERDRAW, 0, m_fHasToolTip ? *m_strToolTip : *m_strText, m_pWndDialog, m_iKey));
	}
	GetIconSize(iAttributes);
	AssertNonZero(WIN::SetWindowPos(m_pWnd, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE));
	Ensure(SetImage());
	Ensure(WindowFinalize());
	return 0;
}


IMsiRecord* CMsiIcon::SetImage()
{
	HICON hIcon = 0;
	Ensure(UnpackIcon(*m_strText, *&hIcon, m_iWidth, m_iHeight, m_fFixedSize));
	SetImage(hIcon);
	return 0;
}


void CMsiIcon::SetImage(HICON hIcon)
{
	if ( hIcon == m_hIcon )
		return;

	if (m_fLetSystemDraw)
		WIN::SendMessage(m_pWnd, STM_SETIMAGE, (WPARAM) IMAGE_ICON, (LPARAM) (HANDLE) hIcon); 
	if (m_hIcon && m_hIcon != hIcon)
		AssertNonZero(m_piHandler->DestroyHandle((HANDLE) m_hIcon) != -1);
	m_hIcon = hIcon;
	AssertNonZero(m_piHandler->RecordHandle(CWINHND((HANDLE) hIcon, iwhtIcon)) != -1);
	AssertNonZero(WIN::InvalidateRect(m_pWnd, 0, fTrue));
}

IMsiRecord* CMsiIcon::GetImage(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeImage));
	riRecord.SetMsiString(1, *m_strText);
	return 0;
}

IMsiRecord* CMsiIcon::SetImage(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeImage));
	m_strRawText = riRecord.GetMsiString(1);
	m_strText = m_piEngine->FormatText(*m_strRawText);
	return SetImage();
}

IMsiRecord* CMsiIcon::GetImageHandle(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeImageHandle));
	riRecord.SetHandle(1, (HANDLE)m_hIcon);
	return 0;
}

IMsiRecord* CMsiIcon::SetImageHandle(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeImageHandle));
	SetImage((HICON) riRecord.GetHandle(1));
	return 0;
}

IMsiRecord* CMsiIcon::Paint(WPARAM, LPARAM)
{
	if (m_fLetSystemDraw)	// on Win95 the system knows how to paint the icon
		return 0;
	PAINTSTRUCT ps;
	HDC hDC = WIN::BeginPaint(m_pWnd, &ps);
	RECT Rect;
	Rect.left = 0; 
	Rect.top = 0;
	Rect.right = m_iWidth;
	Rect.bottom = m_iHeight;
	Ensure(MyDrawIcon(hDC, &Rect, m_hIcon, m_fFixedSize));
	WIN::EndPaint(m_pWnd, &ps); 
	return 0;
}				   

IMsiControl* CreateMsiIcon(IMsiEvent& riDialog)
{
	return new CMsiIcon(riDialog);
}

///////////////////////////////////////////////////////////////////////////
// CMsiListoid definition
///////////////////////////////////////////////////////////////////////////

class CMsiListoid:public CMsiActiveControl
{
public:
	CMsiListoid(IMsiEvent& riDialog);
	virtual ~CMsiListoid();
	virtual IMsiRecord*    __stdcall WindowCreate(IMsiRecord& riRecord);
	virtual IMsiRecord*    __stdcall GetPropertyFromDatabase();
	virtual void           ClearSelection() = 0;
	virtual void           SelectString(const ICHAR* str) = 0;
protected:
	virtual IMsiRecord*    PropertyChanged();
	virtual IMsiRecord*    SetIndirectPropertyValue(const IMsiString& riValueString);
	virtual IMsiRecord*    PaintSelected();
	virtual IMsiRecord*    CreateValuesTable();
	virtual IMsiRecord*    PopulateList();
	virtual IMsiRecord*    DoCreateWindow(IMsiRecord& riRecord) = 0;
	virtual IMsiRecord*    IsTextPresent(Bool *fPresent) = 0;
	virtual IMsiRecord*    LoadTable(IMsiTable*& piTable) = 0;
	virtual IMsiRecord*    StartView(Bool fPresent, IMsiView*& piView) = 0;
#ifdef ATTRIBUTES
	virtual IMsiRecord*    GetItemsCount(IMsiRecord& riRecord);
	virtual IMsiRecord*	   GetItemsValue(IMsiRecord& riRecord);
	virtual IMsiRecord*	   GetItemsText(IMsiRecord& riRecord);
#endif // ATTRIBUTES
	virtual void           ResetContent() = 0;
	virtual void           SetItemData(LONG_PTR pText, long Value) = 0;


	PMsiTable              m_piValuesTable; 
	Bool                   m_fSorted;
	bool                   m_fListBox;
	virtual IMsiRecord*    Command(WPARAM wParam, LPARAM lParam) = 0;
private:
};

///////////////////////////////////////////////////////////////////////////
// CMsiListoid implementation
///////////////////////////////////////////////////////////////////////////

CMsiListoid::CMsiListoid(IMsiEvent& riDialog) : CMsiActiveControl(riDialog), m_piValuesTable(0)
{
	m_fSorted = fFalse;
	m_fListBox = false;
}

CMsiListoid::~CMsiListoid()
{
}

IMsiRecord* CMsiListoid::WindowCreate(IMsiRecord& riRecord)
{
	Ensure(CMsiActiveControl::WindowCreate(riRecord));
	int iAttrib = riRecord.GetInteger(itabCOAttributes);
	m_fSorted = ToBool(iAttrib & msidbControlAttributesSorted);
 	m_fUseDbLang = !(iAttrib & msidbControlAttributesUsersLanguage);
	Ensure(DoCreateWindow(riRecord));
	Ensure(WindowFinalize());
	Ensure(CreateValuesTable());
	Ensure(PopulateList());
	return 0;
}


IMsiRecord* CMsiListoid::CreateValuesTable()
{
	Assert(!m_piValuesTable);
	Ensure(CreateTable(pcaTableIValues, *&m_piValuesTable));
	::CreateTemporaryColumn(*m_piValuesTable, icdString + icdPrimaryKey  + icdNullable, itabVAValue);
	::CreateTemporaryColumn(*m_piValuesTable, icdString + icdNullable, itabVAText);
	return 0;
}

IMsiRecord* CMsiListoid::PopulateList()
{
	if (m_fPreview)
		return 0;
	// first remove all old entries
	ResetContent();
	PMsiCursor piValuesCursor(0);
	Ensure(::CursorCreate(*m_piValuesTable, pcaTableIValues, fFalse, *m_piServices, *&piValuesCursor)); 
	while (piValuesCursor->Next())
	{
		AssertNonZero(piValuesCursor->Delete());
	}
	PMsiRecord piErrorRecord(0);
	Bool fPresent = fFalse;
	Ensure(IsTextPresent(&fPresent));

	// temp until the database is fixed
	PMsiTable piTable(0);
	Ensure(LoadTable(*&piTable));

	PMsiView piListView(0);
	Ensure(StartView(fPresent, *&piListView));
	PMsiRecord piRecordNew(0);
	MsiString strValue;
	MsiString strText;

	// variables & logic used for computing listbox's strings extents
	WPARAM      dwMaxExtent = 0;
	HDC         hDCListBox = 0;
	HFONT       hFontOld = 0, hFontNew;
	TEXTMETRIC  tm;
	memset(&tm, 0, sizeof(tm));
	if ( m_fListBox )
	{
		hDCListBox = WIN::GetDC(m_pWnd);
		AssertNonZero(WIN::GetTextMetrics(hDCListBox, (LPTEXTMETRIC)&tm));
		hFontNew = (HFONT)WIN::SendMessage(m_pWnd, WM_GETFONT, NULL, NULL);
		Assert(hFontNew);
		hFontOld = (HFONT)WIN::SelectObject(hDCListBox, hFontNew);
		Assert(hFontOld);
	}

	WIN::SendMessage(m_pWnd, WM_SETREDRAW, false, 0L);
	while (piRecordNew = piListView->Fetch())
	{
		piValuesCursor->Reset();
		strValue = piRecordNew->GetMsiString(1);
		strValue = m_piEngine->FormatText(*strValue);
		piValuesCursor->SetFilter(iColumnBit(itabVAValue));
		piValuesCursor->PutString(itabVAValue, *strValue);
		if (!strValue.TextSize() || piValuesCursor->Next())
			return PostError(Imsg(idbgValueNotUnique), *m_strDialogName, *m_strKey, *strValue);
		piValuesCursor->Reset();
		piValuesCursor->SetFilter(0);
		// ToDo: integer only validation!
		AssertNonZero(piValuesCursor->PutString(itabVAValue, *strValue));

		strText = piRecordNew->GetMsiString(2);
		strText = m_piEngine->FormatText(*strText);
		if (strText.TextSize() == 0)  // if the text is missing, we use the value
			strText = strValue;
		AssertNonZero(piValuesCursor->PutString(itabVAText, *strText));
		SetItemData((LONG_PTR) (LPSTR) (const ICHAR*) strText, m_piDatabase->EncodeString(*strValue));
		AssertNonZero(piValuesCursor->Insert());
		if ( m_fListBox )
		{
			SIZE size;
			size.cx = size.cy = 0;
			AssertNonZero(WIN::GetTextExtentPoint32(hDCListBox, (const ICHAR*)strText,
																 strText.TextSize(), &size));
			if ( size.cx + tm.tmAveCharWidth > dwMaxExtent )
				dwMaxExtent = size.cx + tm.tmAveCharWidth;
		}
	}
	if ( m_fListBox )
	{
		WIN::SendMessage(m_pWnd, LB_SETHORIZONTALEXTENT, dwMaxExtent, 0L);
		WIN::SelectObject(hDCListBox, hFontOld);
		WIN::ReleaseDC(m_pWnd, hDCListBox);
	}
	WIN::SendMessage(m_pWnd, WM_SETREDRAW, true, 0L);
	AssertNonZero(WIN::InvalidateRect(m_pWnd, 0, true));

	AssertRecord(PaintSelected());
	return 0;
}

IMsiRecord* CMsiListoid::SetIndirectPropertyValue(const IMsiString& riValueString)
{
	Ensure(CMsiActiveControl::SetIndirectPropertyValue(riValueString));
	Ensure(PopulateList());
	return 0;
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiListoid::GetItemsCount(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeItemsCount));

	riRecord.SetInteger(1, m_piValuesTable->GetRowCount());
	return 0;
}
#endif // ATTRIBUTES

IMsiRecord* CMsiListoid::GetPropertyFromDatabase()    
{
	if (m_fPreview)
		return 0;

	Ensure(CMsiActiveControl::GetPropertyFromDatabase ());
	Ensure(PaintSelected());
	return 0;
}

IMsiRecord* CMsiListoid::PropertyChanged ()
{
	if (m_fPreview)
		return 0;
	Ensure(CMsiActiveControl::PropertyChanged ());
	Ensure(PaintSelected());
	return (0);
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiListoid::GetItemsValue(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, m_piValuesTable->GetRowCount(), pcaControlAttributeItemsValue));

	PMsiCursor piValuesCursor(0);
	Ensure(::CursorCreate(*m_piValuesTable, pcaTableIValues, fFalse, *m_piServices, *&piValuesCursor)); 
	int count = 0;
	while (piValuesCursor->Next())
	{   
		riRecord.SetMsiString(++count, *MsiString(piValuesCursor->GetString(itabVAValue)));
	}
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiListoid::GetItemsText(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, m_piValuesTable->GetRowCount(), pcaControlAttributeItemsText));

	PMsiCursor piValuesCursor(0);
	Ensure(::CursorCreate(*m_piValuesTable, pcaTableIValues, fFalse, *m_piServices, *&piValuesCursor)); 
	int count = 0;
	while (piValuesCursor->Next())
	{   
		riRecord.SetMsiString(++count, *MsiString(piValuesCursor->GetString(itabVAText)));
	}
	return 0;
}
#endif // ATTRIBUTES

IMsiRecord* CMsiListoid::PaintSelected()
{
	PMsiCursor piValuesCursor(0);
	Ensure(::CursorCreate(*m_piValuesTable, pcaTableIValues, fFalse, *m_piServices, *&piValuesCursor)); 
	piValuesCursor->SetFilter(iColumnBit(itabVAValue));
	piValuesCursor->Reset();	
	AssertNonZero(piValuesCursor->PutString(itabVAValue, *MsiString(GetPropertyValue())));

	if(piValuesCursor->Next())
	{
		const IMsiString* piTempString = &piValuesCursor->GetString(itabVAText);
		SelectString ((const ICHAR*) piTempString->GetString());
		piTempString->Release();
	}
	else
	{
		ClearSelection ();
	}

	return 0;
}


///////////////////////////////////////////////////////////////////////////
// CMsiListBox definition
///////////////////////////////////////////////////////////////////////////

class CMsiListBox:public CMsiListoid
{
public:
	CMsiListBox(IMsiEvent& riDialog);
	~CMsiListBox ();
	IMsiRecord*             DoCreate(IMsiRecord& riRecord);

	void			        ClearSelection ();
	void		        	SelectString (const ICHAR* str);
protected:
    IMsiRecord*             LoadTable(IMsiTable*& piTable);
	IMsiRecord*             StartView(Bool fPresent, IMsiView*& piView);
	IMsiRecord*             DoCreateWindow(IMsiRecord& riRecord);
	IMsiRecord*             IsTextPresent(Bool *fPresent);
	IMsiRecord*	        	Command(WPARAM wParam, LPARAM lParam);
	void                    ResetContent();
	void                    SetItemData(LONG_PTR pText, long Value);
	bool                    GetItemText(CTempBufferRef<ICHAR>& rgchItemText, int iPos);
private:
};


///////////////////////////////////////////////////////////////////////////
// CMsiListBox implementation
///////////////////////////////////////////////////////////////////////////

CMsiListBox::CMsiListBox(IMsiEvent& riDialog) : CMsiListoid(riDialog)
{
	m_fListBox = true;
}

CMsiListBox::~CMsiListBox()
{
}

IMsiRecord* CMsiListBox::DoCreateWindow(IMsiRecord& /*riRecord*/)
{
	Ensure(CreateControlWindow(TEXT("LISTBOX"), WS_HSCROLL | (m_fSorted ? LBS_NOTIFY |  WS_VSCROLL | WS_BORDER : LBS_STANDARD) | WS_TABSTOP, (m_fRTLRO ? WS_EX_RTLREADING : 0) | (m_fRightAligned ? WS_EX_RIGHT : 0) | (m_fLeftScroll ? WS_EX_LEFTSCROLLBAR : 0), *m_strText, m_pWndDialog, m_iKey));
	return 0;
}


void CMsiListBox::ResetContent()
{
	// taking care of removing the eventual horizontal scrollbar.
	WIN::SendMessage(m_pWnd, LB_SETHORIZONTALEXTENT, 0, 0L);
	WIN::SendMessage(m_pWnd, WM_HSCROLL, SB_TOP, 0L); // (scrolls the listbox horizontally to the left)
	WIN::SendMessage(m_pWnd, LB_DELETESTRING, 0, 0L); // (removes the scrollbar)
	// deleting the listbox's content.
	WIN::SendMessage(m_pWnd, LB_RESETCONTENT, 0, 0);
}

IMsiRecord* CMsiListBox::IsTextPresent(Bool *fPresent)
{
	Ensure(IsColumnPresent(*m_piDatabase, *MsiString(*pcaTablePListBox), *MsiString(*pcaTableColumnPListBoxText), fPresent));
	return 0;
}

IMsiRecord* CMsiListBox::LoadTable(IMsiTable*& piTable)
{
	Ensure(m_piDatabase->LoadTable(*MsiString(*pcaTablePListBox), 0, *&piTable));
	return 0;
}

IMsiRecord* CMsiListBox::StartView(Bool fPresent, IMsiView*& piView)
{
	Ensure(CMsiControl::StartView((fPresent ? sqlListBox : sqlListBoxShort), *MsiString(GetPropertyName ()), *&piView)); 
	return 0;
}

void CMsiListBox::SetItemData(LONG_PTR pText, long Value)	
{
	WIN::SendMessage(m_pWnd, LB_SETITEMDATA, WIN::SendMessage(m_pWnd,LB_ADDSTRING,0, pText),Value);		
}

void CMsiListBox::ClearSelection ()
{
	WIN::SendMessage(m_pWnd, LB_SETCURSEL, (WPARAM)-1, 0);
}

bool CMsiListBox::GetItemText(CTempBufferRef<ICHAR>& rgchItemText, int iPos)
{
	int iLen = (int)WIN::SendMessage(m_pWnd, LB_GETTEXTLEN, (WPARAM)iPos, 0);
	if ( iLen == LB_ERR )
	{
		Assert(0);
		return false;
	}
	if ( rgchItemText.GetSize() < iLen + 1 )
		rgchItemText.SetSize(iLen+1);
	iLen = (int)WIN::SendMessage(m_pWnd, LB_GETTEXT, (WPARAM)iPos,
										  (LPARAM)(LPCTSTR)rgchItemText);
	if ( iLen == LB_ERR )
	{
		Assert(0);
		return false;
	}
	return true;
}

//FUTURE: It would be way more accurate to move the selection based on the
//        value of the property (its string ID is stored in the item's data
//        field) than on the item's string.

void CMsiListBox::SelectString (const ICHAR* str)
{
	Assert(str);
	int iPos = -1;
	CTempBuffer<ICHAR, MAX_PATH> rgchBuffer;

	while ( (iPos = (int)WIN::SendMessage(m_pWnd, LB_SELECTSTRING,
													  (WPARAM)iPos,
													  (LPARAM)(LPSTR)str)) != LB_ERR )
	{
		// LB_SELECTSTRING looks only for strings that start in 'str', so
		// there's a chance it will stop on a different item if it happens
		// that the string in that item starts in 'str'.
		if ( GetItemText(rgchBuffer, iPos) && !IStrCompI(rgchBuffer, str) )
			// OK, we're on the exact same string
			break;
	}
}

IMsiRecord* CMsiListBox::Command(WPARAM wParam, LPARAM /*lParam*/)
{
	LPARAM mylParam = (LPARAM) wParam;
	int iHiword = HIWORD(mylParam);
	if (iHiword == LBN_SELCHANGE)
	{
		MsiStringId iValue = (MsiStringId) WIN::SendMessage(m_pWnd, LB_GETITEMDATA, WIN::SendMessage(m_pWnd, LB_GETCURSEL, 0, 0L), 0L);		//!!merced: Converting PTR to INT
		Ensure(SetPropertyValue(*MsiString(m_piDatabase->DecodeString(iValue)), fTrue));
		return PostErrorDlgKey(Imsg(idbgWinMes), 0);
	}
	return 0;
}


IMsiControl* CreateMsiListBox(IMsiEvent& riDialog)
{
	return new CMsiListBox(riDialog);
}
	  
///////////////////////////////////////////////////////////////////////////
// CMsiComboBox definition
///////////////////////////////////////////////////////////////////////////

class CMsiComboBox:public CMsiListoid
{
public:
	CMsiComboBox(IMsiEvent& riDialog);
	virtual ~CMsiComboBox ();
	IMsiRecord*                DoCreateWindow(IMsiRecord& riRecord);

	virtual void			   ClearSelection ();
	virtual void			   SelectString (const ICHAR* str);
	virtual IMsiRecord*    __stdcall GetPropertyFromDatabase();

protected:
	virtual IMsiRecord*        PropertyChanged ();
	IMsiRecord*                LoadTable(IMsiTable*& piTable);
	IMsiRecord*                StartView(Bool fPresent, IMsiView*& piView);
	IMsiRecord*                IsTextPresent(Bool *fPresent);
	void                       ResetContent();
	void                       SetItemData(LONG_PTR pText, long Value);
	static INT_PTR CALLBACK EditWindowProc(WindowRef pWnd, WORD message, WPARAM wParam, LPARAM lParam);			//--merced: changed int to INT_PTR
private:
	IMsiRecord*                PaintSelected();
	IMsiRecord*                KillFocus(WPARAM wParam, LPARAM lParam);
#ifdef ATTRIBUTES
	IMsiRecord*                GetLimit(IMsiRecord& riRecord);
#endif // ATTRIBUTES
	int	                       m_iLimit;            // The maximum number of characters the user can type
	IMsiRecord*                Command(WPARAM wParam, LPARAM lParam);
	WNDPROC				       m_pEditWindowProc;
};


///////////////////////////////////////////////////////////////////////////
// CMsiComboBox implementation
///////////////////////////////////////////////////////////////////////////

CMsiComboBox::CMsiComboBox(IMsiEvent& riDialog)	: CMsiListoid(riDialog)
{
	m_iLimit = 0;
	m_pEditWindowProc = 0;
}

CMsiComboBox::~CMsiComboBox()
{
}

IMsiRecord* CMsiComboBox::DoCreateWindow(IMsiRecord& riRecord)
{
	Bool fList = ToBool(riRecord.GetInteger(itabCOAttributes) & msidbControlAttributesComboList);

 	if (((const ICHAR *) m_strText)[0] == TEXT('{'))
	{
		// FUTURE davidmck - better ways to do this
		m_strText.Remove(iseIncluding, TEXT('{'));
		m_iLimit = (int)MsiString(m_strText.Extract(iseUpto, TEXT('}')));

		if (iMsiStringBadInteger == m_iLimit || m_iLimit < 0) // lets not get carried away
			return PostError(Imsg(idbgInvalidLimit), *m_strDialogName, *m_strKey, *m_strText);	
		else if (0 == m_iLimit)
			m_iLimit = 0x7FFFFFFE; // This is what Windows uses when EM_LIMITTEXT is set to 0

		m_strText.Remove(iseIncluding, TEXT('}'));
	}
	else // no limit specified; use the maximum possible
	{ 
		m_iLimit = 0x7FFFFFFE; // This is what Windows uses when EM_LIMITTEXT is set to 0
	} 

	MsiString strNull;
	m_strRawText = strNull;
	Ensure(CreateControlWindow(TEXT("COMBOBOX"), WS_VSCROLL|CBS_AUTOHSCROLL|(fList ? CBS_DROPDOWNLIST : CBS_DROPDOWN)| (m_fSorted ? 0 : CBS_SORT)|WS_TABSTOP, (m_fRTLRO ? WS_EX_RTLREADING : 0) | (m_fRightAligned ? WS_EX_RIGHT : 0) | (m_fLeftScroll ? WS_EX_LEFTSCROLLBAR : 0), *m_strText, m_pWndDialog, m_iKey));
	if (!fList)
	{
		WindowRef pwndEdit = ::GetWindow(m_pWnd, GW_CHILD);	 // handle of the edit field window
		if ( ! pwndEdit )
			return PostError(Imsg(idbgControlNotFound), *m_strKey, *m_strDialogName);	
#ifdef _WIN64	// !merced
		m_pEditWindowProc = (WNDPROC)WIN::SetWindowLongPtr(pwndEdit, GWLP_WNDPROC, (ULONG_PTR) CMsiComboBox::EditWindowProc);
		WIN::SetWindowLongPtr(pwndEdit, GWLP_USERDATA, (LONG_PTR) this);
#else			// win-32. This should be removed with the 64-bit windows.h is #included.
		m_pEditWindowProc = (WNDPROC)WIN::SetWindowLong(pwndEdit, GWL_WNDPROC, (DWORD) CMsiComboBox::EditWindowProc);
		WIN::SetWindowLong(pwndEdit, GWL_USERDATA, (long) this);
#endif
	}
	WIN::SendMessage(m_pWnd, CB_LIMITTEXT, m_iLimit, 0);
	return 0;
}

IMsiRecord* CMsiComboBox::GetPropertyFromDatabase()    
{
	if (m_fPreview)
		return 0;
	Ensure(CMsiActiveControl::GetPropertyFromDatabase ());
	MsiString strPropertyValue = GetPropertyValue();
	if (strPropertyValue.CharacterCount() > m_iLimit)
	{
		PMsiRecord precError = PostErrorDlgKey(Imsg(idbgOverLimit), *strPropertyValue, m_iLimit);	
		m_piEngine->Message(imtWarning, *precError);
		strPropertyValue = strPropertyValue.Extract(iseFirst, m_iLimit);
		Ensure(SetPropertyValue(*strPropertyValue, fFalse));
	}
	Ensure(PaintSelected());
	return 0;
}

void CMsiComboBox::ResetContent()
{
	WIN::SendMessage(m_pWnd, CB_RESETCONTENT, 0, 0);
}

IMsiRecord* CMsiComboBox::IsTextPresent(Bool *fPresent)
{
	Ensure(IsColumnPresent(*m_piDatabase, *MsiString(*pcaTablePComboBox), *MsiString(*pcaTableColumnPComboBoxText), fPresent));
	return 0;
}

IMsiRecord* CMsiComboBox::LoadTable(IMsiTable*& piTable)
{
	Ensure(m_piDatabase->LoadTable(*MsiString(*pcaTablePComboBox), 0, *&piTable));
	return 0;
}

IMsiRecord* CMsiComboBox::StartView(Bool fPresent, IMsiView*& piView)
{
	Ensure(CMsiControl::StartView((fPresent ? sqlComboBox : sqlComboBoxShort), *MsiString(GetPropertyName ()), *&piView)); 
	return 0;
}

void CMsiComboBox::SetItemData(LONG_PTR pText, long Value)
{
	WIN::SendMessage(m_pWnd, CB_SETITEMDATA, WIN::SendMessage(m_pWnd,CB_ADDSTRING,0, pText),Value);
}


void CMsiComboBox::ClearSelection ()
{
	WIN::SendMessage(m_pWnd, CB_SETCURSEL, (WPARAM)-1, 0);
}

void CMsiComboBox::SelectString (const ICHAR* str)
{
	Assert(str);
	WIN::SendMessage(m_pWnd, CB_SELECTSTRING, (WPARAM)-1, (LONG_PTR) (LPSTR) str);	//!!merced: Converting PTR to LONG
}

IMsiRecord* CMsiComboBox::PaintSelected()
{
	Ensure(CMsiListoid::PaintSelected());
	WIN::SetWindowText(m_pWnd, MsiString(GetPropertyValue()));
	return 0;
}


IMsiRecord* CMsiComboBox::PropertyChanged ()
{
	if (m_fPreview)
		return 0;
	Ensure(CMsiListoid::PropertyChanged());
	if (m_pWnd)
	{
		WIN::SetWindowText(m_pWnd, MsiString(GetPropertyValue ()));
	}
	return 0;
}


INT_PTR CALLBACK CMsiComboBox::EditWindowProc(WindowRef pWnd, WORD message, WPARAM wParam, LPARAM lParam)
{
#ifdef _WIN64	// !merced
	CMsiComboBox* pCB = (CMsiComboBox*)WIN::GetWindowLongPtr(pWnd, GWLP_USERDATA);
#else			// win-32. This should be removed with the 64-bit windows.h is #included.
	CMsiComboBox* pCB = (CMsiComboBox*)WIN::GetWindowLong(pWnd, GWL_USERDATA);
#endif
	switch (message)
	{
		case WM_CHAR:
			// The following "if" is used to suppress WM_CHAR to (edit) controls (which produces a beep)
			if ((wParam==VK_TAB) || (wParam==VK_RETURN))
				return(0);
			break;
		case WM_SETFOCUS:
			WIN::SendMessage(pCB->m_pWnd, message, wParam, lParam);
			break;
		case WM_KILLFOCUS:
			WIN::SendMessage(pCB->m_pWnd, message, wParam, lParam);
			break;
		case WM_KEYDOWN:
		if (wParam == VK_ESCAPE)
		{
			PMsiEvent piDialog = &pCB->GetDialog();
			PMsiRecord piReturn = piDialog->Escape();
			if (piReturn)
			{
				piReturn->AddRef(); // we want to keep it around
				piDialog->SetErrorRecord(*piReturn);
			}
			return 0;
		}
		break;
	}
	return WIN::CallWindowProc(pCB->m_pEditWindowProc, pWnd, message, wParam, lParam);
}

IMsiRecord* CMsiComboBox::KillFocus(WPARAM wParam, LPARAM lParam)
{ 
	if ( !wParam )
	{
		//  the focus moved to a window in another thread.  There is no point in
		//  validating in this case.
		Ensure(LockDialog(fFalse));
		return (CMsiActiveControl::KillFocus (wParam, lParam));
	}

	int iLength = WIN::GetWindowTextLength(m_pWnd);
	ICHAR *Buffer = new ICHAR[iLength + 1];
	if ( ! Buffer )
		return PostError(Imsg(imsgOutOfMemoryUI));
	WIN::GetWindowText(m_pWnd, Buffer, iLength + 1);
	MsiString strText(Buffer);
	delete[] Buffer;	 
	PMsiCursor piValuesCursor(0);
	Ensure(::CursorCreate(*m_piValuesTable, pcaTableIValues, fFalse, *m_piServices, *&piValuesCursor));
	piValuesCursor->SetFilter(iColumnBit(itabVAText));
	AssertNonZero(piValuesCursor->PutString(itabVAText, *strText));
	if (piValuesCursor->Next())  // if this text is in the table, use the corresponding value
		strText = piValuesCursor->GetString(itabVAValue);
	PMsiRecord piRecord = SetPropertyValue (*strText, fTrue);
	Ensure(LockDialog(ToBool(piRecord != 0)));
	if (piRecord)
	{
		m_piEngine->Message(imtWarning, *piRecord);
		return PostErrorDlgKey(Imsg(idbgWinMes), 0);
	}
	else
		return (CMsiActiveControl::KillFocus (wParam, lParam));
}

IMsiRecord* CMsiComboBox::Command(WPARAM wParam, LPARAM /*lParam*/)
{
	LPARAM mylParam = (LPARAM) wParam;
	int iHiword = HIWORD(mylParam);
	if (iHiword == CBN_SELCHANGE)
	{
		INT_PTR iItem = WIN::SendMessage(m_pWnd, CB_GETCURSEL, 0, 0L);			//--merced: changed int to INT_PTR
		if (iItem > -1)
		{
			MsiStringId iValue = (MsiStringId) WIN::SendMessage(m_pWnd, CB_GETITEMDATA, iItem, 0L);		//!!merced: Converting PTR to INT
			MsiString strPropertyValue = m_piDatabase->DecodeString(iValue);
			if (strPropertyValue.CharacterCount() > m_iLimit)
			{
				PMsiRecord precError = PostErrorDlgKey(Imsg(idbgOverLimit), *strPropertyValue, m_iLimit);	
				m_piEngine->Message(imtWarning, *precError);
				strPropertyValue = strPropertyValue.Extract(iseFirst, m_iLimit);
			}
			Ensure(SetPropertyValue(*strPropertyValue, fTrue));
			WIN::SetWindowText(m_pWnd, strPropertyValue);
		}
		WIN::SendMessage(m_pWnd, CB_SHOWDROPDOWN, fFalse, 0L);
		return PostErrorDlgKey(Imsg(idbgWinMes), 0);
	}
	return 0;
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiComboBox::GetLimit(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeLimit));
	riRecord.SetInteger(1, m_iLimit);
	return 0;
}
#endif // ATTRIBUTES

IMsiControl* CreateMsiComboBox(IMsiEvent& riDialog)
{
	return new CMsiComboBox(riDialog);
}

/////////////////////////////////////////////
// CMsiProgress  definition
/////////////////////////////////////////////

class CMsiProgress:public CMsiControl
{
public:
	CMsiProgress(IMsiEvent& riDialog);
	virtual ~CMsiProgress();
	virtual IMsiRecord*       __stdcall WindowCreate(IMsiRecord& riRecord);
	virtual IMsiRecord*       GetProgress(IMsiRecord& riRecord);
	virtual IMsiRecord*       SetProgress(IMsiRecord& riRecord);
protected:
	virtual IMsiRecord*		  SetProgress(int iProgress, int iRange, const IMsiString& riActionString);
	int				          m_iProgress;
	int				          m_iRange;
	int				          m_iProgressShort;		// the above two numbers scaled down to fit in a short unsigned int
	int				          m_iRangeShort;
	MsiString                 m_strLastAction;
private:
};

/////////////////////////////////////////////////
// CMsiProgress  implementation
/////////////////////////////////////////////////

CMsiProgress::CMsiProgress(IMsiEvent& riDialog) : CMsiControl(riDialog)
{
	m_iProgress = 0;
	m_iRange = 0;
	m_iProgressShort = m_iProgress;
	m_iRangeShort = m_iRange;
	MsiString strNull;
	m_strLastAction = strNull;
}

CMsiProgress::~CMsiProgress()
{
}

IMsiRecord* CMsiProgress::WindowCreate(IMsiRecord& riRecord)
{
	Ensure(CMsiControl::WindowCreate(riRecord));
	return 0;
}

IMsiRecord* CMsiProgress::GetProgress(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 3, pcaControlAttributeProgress));
	riRecord.SetInteger(1, m_iProgress);
	riRecord.SetInteger(2, m_iRange);
	riRecord.SetMsiString(3, *m_strLastAction);
	return 0;
}

IMsiRecord* CMsiProgress::SetProgress(IMsiRecord& riRecord)
{

	Ensure(CheckFieldCount (riRecord, 3, pcaControlAttributeProgress));
	int iProgress = riRecord.IsInteger(1) ? riRecord.GetInteger(1) : (int) MsiString(riRecord.GetMsiString(1));
	int iRange = riRecord.IsInteger(2) ? riRecord.GetInteger(2) : (int) MsiString(riRecord.GetMsiString(2));
	MsiString strAction = riRecord.GetMsiString(3);
	iProgress = max (0, iProgress);
	iRange = max (0, iRange);
	return SetProgress(iProgress, iRange, *strAction);
}

IMsiRecord* CMsiProgress::SetProgress(int iProgress, int iRange, const IMsiString& riActionString)
{
	if (iRange)
		m_iRange = iRange;
	m_iProgress = min(m_iRange, iProgress);
	// if Range is larger than an unsigned short, scale back both numbers
	m_iRangeShort = m_iRange;
	m_iProgressShort = m_iProgress;
	while (m_iRangeShort > 0xFFFF)
	{
		m_iRangeShort /= 2;
		m_iProgressShort /= 2;
	}
	if (!m_strLastAction.Compare(iscExact, riActionString.GetString()))
	{
		riActionString.AddRef();
		m_strLastAction = riActionString;
	}

	return 0;
}


/////////////////////////////////////////////
// CMsiProgressBar  definition
/////////////////////////////////////////////

class CMsiProgressBar:public CMsiProgress
{
public:
	CMsiProgressBar(IMsiEvent& riDialog);
	~CMsiProgressBar();
	IMsiRecord*       __stdcall WindowCreate(IMsiRecord& riRecord);
protected:
private:
	IMsiRecord*		  SetProgress(int iProgress, int iRange, const IMsiString& riActionString);
	Bool              m_f95Style;
	IMsiRecord*       Paint(WPARAM wParam, LPARAM lParam);
};

/////////////////////////////////////////////////
// CMsiProgressBar  implementation
/////////////////////////////////////////////////

CMsiProgressBar::CMsiProgressBar(IMsiEvent& riDialog) : CMsiProgress(riDialog)
{
	m_f95Style = fFalse;
}

CMsiProgressBar::~CMsiProgressBar()
{
}

IMsiRecord* CMsiProgressBar::WindowCreate(IMsiRecord& riRecord)
{
	int iAttributes = riRecord.GetInteger(itabCOAttributes);
	m_f95Style = ToBool(iAttributes & msidbControlAttributesProgress95);
	Ensure(CMsiProgress::WindowCreate(riRecord));
	m_fEnabled = fFalse; // a progressbar is a button, but should be disabled, so we can't click on it
	Ensure(CreateControlWindow(PROGRESS_CLASS, 0, m_fRTLRO ? WS_EX_RTLREADING : 0, *m_strText, m_pWndDialog, m_iKey));
	WIN::SendMessage(m_pWnd, PBM_SETRANGE, 0, MAKELPARAM(0, m_iRangeShort)); 
	Ensure(WindowFinalize());
	return 0;
}

IMsiRecord* CMsiProgressBar::SetProgress(int iProgress, int iRange, const IMsiString& riActionString)
{
	Ensure(CMsiProgress::SetProgress(iProgress, iRange, riActionString));
	WIN::SendMessage(m_pWnd, PBM_SETRANGE, 0, MAKELPARAM(0, m_iRangeShort)); 
	WIN::SendMessage(m_pWnd, PBM_SETPOS, m_iProgressShort, 0);
	if (!m_f95Style)
	{		 
		AssertNonZero(WIN::InvalidateRect(m_pWnd, 0, fTrue));
	}
	return 0;
}

IMsiRecord* CMsiProgressBar::Paint(WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	if (m_f95Style || m_iRangeShort == 0)
	{
		return 0;
	}
	PAINTSTRUCT ps;
	RECT rect;
	HBRUSH hbrushFrame=WIN::CreateSolidBrush(GetSysColor(COLOR_WINDOWFRAME));
	HBRUSH hbrushBar=WIN::CreateSolidBrush(GetSysColor(COLOR_ACTIVECAPTION));
	HBRUSH hbrushBack=WIN::CreateSolidBrush(GetSysColor(COLOR_WINDOW));
	if ( ! hbrushFrame || ! hbrushBar || ! hbrushBack )
		return PostError(Imsg(idbgPaintError), *m_strDialogName);
	HDC hdc = WIN::BeginPaint(m_pWnd, &ps);
	// Draw the frame of the progress bar
	AssertNonZero(WIN::SetRect(&rect, 0, 0, m_iWidth, m_iHeight));
	WIN::FrameRect(hdc, &rect, hbrushFrame);
	// draw the bar
	AssertNonZero(WIN::SetRect(&rect, 1, 1, ((m_iWidth - 1) * m_iProgressShort) / m_iRangeShort, m_iHeight - 1));
	AssertNonZero(WIN::FillRect(hdc, &rect, hbrushBar));
	if (m_iProgressShort < m_iRangeShort)
	{
		// if there is background left, draw it
		rect.left = 1 + rect.right;
		rect.right = m_iWidth - 1;
		AssertNonZero(WIN::FillRect(hdc, &rect, hbrushBack));
	}
	AssertNonZero(WIN::DeleteObject(hbrushFrame));
	AssertNonZero(WIN::DeleteObject(hbrushBar));
	AssertNonZero(WIN::DeleteObject(hbrushBack));
	WIN::EndPaint(m_pWnd, &ps);
#ifdef DEBUG
	//WIN::Sleep(100);
#endif // DEBUG
	return 0;
}

IMsiControl* CreateMsiProgressBar(IMsiEvent& riDialog)
{
	return new CMsiProgressBar(riDialog);
}

/////////////////////////////////////////////
// CMsiBillboard  definition
/////////////////////////////////////////////

class CMsiBillboard:public CMsiProgress
{
public:
	CMsiBillboard(IMsiEvent& riDialog);
	~CMsiBillboard();
	IMsiRecord*            __stdcall WindowCreate(IMsiRecord& riRecord);
protected:
private:
	IMsiRecord*		       SetProgress(int iProgress, int iRange, const IMsiString& riActionString);
	IMsiRecord*            SetBillboardName(IMsiRecord& riRecord);
	IMsiRecord*            GetBillboardName(IMsiRecord& riRecord);
	IMsiRecord*            CountBillboards();
	IMsiRecord*            ShowBillboard();
	IMsiRecord*            ShowNextBillboard();
	int                    m_cBillboard;
	int                    m_iPresentBillboard;
	MsiString              m_strPresentBillboard;
	PMsiView               m_piView;
	PMsiTable              m_piBBControlsTable;
	int                    m_iDelX;
	int                    m_iDelY;
};



/////////////////////////////////////////////////
// CMsiBillboard  implementation
/////////////////////////////////////////////////

CMsiBillboard::CMsiBillboard(IMsiEvent& riDialog) : CMsiProgress(riDialog), m_piView(0), m_piBBControlsTable(0) 
{
	m_cBillboard = 0;
	m_iPresentBillboard = 0;
	m_iDelX = 0;
	m_iDelY = 0;
	MsiString strNull;
	m_strPresentBillboard = strNull;
}

CMsiBillboard::~CMsiBillboard()
{
	if (m_piBBControlsTable)
	{
		PMsiCursor piControlsCursor(0);
		AssertRecord(::CursorCreate(*m_piBBControlsTable, pcaTableIBBControls, fFalse, *m_piServices, *&piControlsCursor)); 
		while (piControlsCursor->Next())
		{
			AssertNonZero(piControlsCursor->Delete());
		}
	}
}

IMsiRecord* CMsiBillboard::WindowCreate(IMsiRecord& riRecord)
{
	m_iDelX = riRecord.GetInteger(itabCOX);
	m_iDelY = riRecord.GetInteger(itabCOY);
	Ensure(CMsiProgress::WindowCreate(riRecord));
	Assert(!m_piBBControlsTable);
	Ensure(CreateTable(pcaTableIBBControls, *&m_piBBControlsTable));
	::CreateTemporaryColumn(*m_piBBControlsTable, icdString + icdPrimaryKey, itabBBName);
	::CreateTemporaryColumn(*m_piBBControlsTable, icdObject, itabBBObject);
	return 0;
}


IMsiRecord* CMsiBillboard::SetProgress(int iProgress, int iRange, const IMsiString& riActionString)
{
	Bool fNewAction = ToBool(!m_strLastAction.Compare(iscExact, riActionString.GetString()));
	Ensure(CMsiProgress::SetProgress(iProgress, iRange, riActionString));
	if (fNewAction)
	{
		riActionString.AddRef();
		m_strLastAction = riActionString;
		// find number of billboards and show first
		Ensure(CountBillboards());
		if (m_cBillboard)
		{
			m_iPresentBillboard = 1;
			Ensure(ShowNextBillboard());
		}
	}
	else
	{
		// check if it is time for next billboard
		if (m_cBillboard && m_iProgressShort * m_cBillboard > m_iRangeShort * m_iPresentBillboard)
		{
			m_iPresentBillboard++;
			Assert (m_iPresentBillboard <= m_cBillboard);
			Ensure(ShowNextBillboard());
		}
	}
	return 0;
}

IMsiRecord* CMsiBillboard::GetBillboardName(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeBillboardName));
	riRecord.SetMsiString(1, *m_strPresentBillboard);
	return 0;
}

IMsiRecord* CMsiBillboard::SetBillboardName(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeBillboardName));
	m_strPresentBillboard = riRecord.GetMsiString(1);
	Ensure(ShowBillboard());
	return 0;
}

IMsiRecord* CMsiBillboard::CountBillboards()
{
	Ensure(CMsiControl::StartView(sqlBillboardView, *m_strLastAction, *&m_piView));
	m_cBillboard = 0;
	while (PMsiRecord(m_piView->Fetch()))
	{
		m_cBillboard++;
	}
	// reset it for future Fetches
	if (m_cBillboard)
	{
		Ensure(CMsiControl::StartView(sqlBillboardSortedView, *m_strLastAction, *&m_piView));
	}
	return 0;
}

IMsiRecord* CMsiBillboard::ShowNextBillboard()
{
	Assert(m_piView);
	PMsiRecord piRecord = m_piView->Fetch();
	Assert(piRecord);
	m_strPresentBillboard = piRecord->GetMsiString(1);
	Ensure(ShowBillboard());
	return 0;
}


IMsiRecord* CMsiBillboard::ShowBillboard()
{
	Assert(m_piBBControlsTable);
	PMsiControl piControl(0);
	PMsiCursor piControlsCursor(0);
	Ensure(::CursorCreate(*m_piBBControlsTable, pcaTableIBBControls, fFalse, *m_piServices, *&piControlsCursor)); 
	// first remove controls of the old billboard
	WIN::SendMessage(m_pWndDialog, WM_SETREDRAW, fFalse, 0L);
	while (piControlsCursor->Next())
	{
		piControl = (IMsiControl*) piControlsCursor->GetMsiData(itabBBObject);
		Ensure(m_piDialog->RemoveControl(piControl));
		AssertNonZero(piControlsCursor->Delete());
	}
	if (!m_strPresentBillboard.TextSize())
	{
		WIN::SendMessage(m_pWndDialog, WM_SETREDRAW, fTrue, 0L);
		RECT rect;
		AssertNonZero(WIN::SetRect(&rect, m_iX, m_iY, m_iX + m_iWidth, m_iY + m_iHeight));
		AssertNonZero(WIN::InvalidateRect(m_pWndDialog, &rect, fTrue));
		return 0;
	}

	PMsiView piControlsView(0);
	Ensure(CMsiControl::StartView(sqlBillboardControl, *m_strPresentBillboard, *&piControlsView));
	PMsiRecord piReturn(0);
	MsiString strControlName;
	while (piReturn = piControlsView->Fetch())
	{
		strControlName = MsiString(*TEXT("Billboard_"));
		strControlName += m_strPresentBillboard;
		strControlName += MsiString(*TEXT("_Control_"));
		MsiString strShortControlName = piReturn->GetMsiString(itabCOControl);
		strControlName += strShortControlName;
		AssertNonZero(piReturn->SetMsiString(itabCOControl, *strControlName));
		piControlsCursor->Reset();
		AssertNonZero(piControlsCursor->PutString(itabBBName, *strControlName));
		
		piControl = m_piDialog->ControlCreate(*MsiString(piReturn->GetMsiString(itabCOType)));
		if (!piControl)
		{
			return PostError(Imsg(idbgControlCreate), *m_strDialogName, *strControlName);
		}
		AssertNonZero(piReturn->SetMsiString(itabCOHelp, *m_strHelp));
		// shift controls to right position relative to the billboard
		AssertNonZero(piReturn->SetInteger(itabCOX, m_iDelX + piReturn->GetInteger(itabCOX)));
		AssertNonZero(piReturn->SetInteger(itabCOY, m_iDelY + piReturn->GetInteger(itabCOY)));
 		Ensure(m_piDialog->AddControl(piControl, *piReturn));
		// warn if control is off the billboard
		PMsiRecord piControlPos = &m_piServices->CreateRecord(4);
		AssertRecord(piControl->AttributeEx(fFalse, cabPosition, *piControlPos));
		int iCtrlX = piControlPos->GetInteger(1);
		int iCtrlY = piControlPos->GetInteger(2);
		int iCtrlWidth = piControlPos->GetInteger(3);
		int iCtrlHeight = piControlPos->GetInteger(4);
		bool fCorrectedSize = false;
		bool fWayOut = false;
		if (iCtrlX < m_iX)
		{
			PMsiRecord piReturn = PostError(Imsg(idbgControlOutOfBillboard),
													  *m_strPresentBillboard, *strShortControlName,
													  *MsiString(*TEXT("to the left")),
													  *MsiString(m_iX - iCtrlX));
			m_piEngine->Message(imtInfo, *piReturn);
		}
		else if (iCtrlX > m_iX + m_iWidth)
		{
			fWayOut = true;
			PMsiRecord piReturn = PostError(Imsg(idbgControlOutOfBillboard),
													  *m_strPresentBillboard, *strShortControlName,
													  *MsiString(*TEXT("to the right")),
													  *MsiString(iCtrlX - m_iX));
			m_piEngine->Message(imtInfo, *piReturn);
		}
		else if (iCtrlX + iCtrlWidth > m_iX + m_iWidth)
		{
			PMsiRecord piReturn = PostError(Imsg(idbgControlOutOfBillboard),
													  *m_strPresentBillboard, *strShortControlName,
													  *MsiString(*TEXT("to the right")),
													  *MsiString(iCtrlX + iCtrlWidth - m_iX - m_iWidth));
			m_piEngine->Message(imtInfo, *piReturn);
			// the width can be corrected to get the control within billboard
			// limits (we know from above that iCtrlX < m_iX + m_iWidth)
			fCorrectedSize = true;
			piControlPos->SetInteger(3, m_iX + m_iWidth - iCtrlX);
		}
		if (iCtrlY < m_iY)
		{
			PMsiRecord piReturn = PostError(Imsg(idbgControlOutOfBillboard),
													  *m_strPresentBillboard, *strShortControlName,
													  *MsiString(*TEXT("on the top")),
													  *MsiString(m_iY - iCtrlY));
			m_piEngine->Message(imtInfo, *piReturn);
		}
		else if (iCtrlY > m_iY + m_iHeight)
		{
			fWayOut = true;
			PMsiRecord piReturn = PostError(Imsg(idbgControlOutOfBillboard),
													  *m_strPresentBillboard, *strShortControlName,
													  *MsiString(*TEXT("on the bottom")),
													  *MsiString(iCtrlY - m_iY));
			m_piEngine->Message(imtInfo, *piReturn);
		}
		else if (iCtrlY + iCtrlHeight > m_iY + m_iHeight)
		{
			PMsiRecord piReturn = PostError(Imsg(idbgControlOutOfBillboard),
													  *m_strPresentBillboard, *strShortControlName,
													  *MsiString(*TEXT("on the bottom")),
													  *MsiString(iCtrlY + iCtrlHeight - m_iY - m_iHeight));
			m_piEngine->Message(imtInfo, *piReturn);
			// the height can be corrected to get the control within billboard
			// limits (we know from above that iCtrlY < m_iY + m_iHeight)
			fCorrectedSize = true;
			piControlPos->SetInteger(4, m_iY + m_iHeight - iCtrlY);
		}
		if ( fCorrectedSize && !fWayOut )
			AssertRecord(piControl->AttributeEx(fTrue, cabPosition, *piControlPos));
		AssertNonZero(piControlsCursor->PutMsiData(itabBBObject, piControl));
		AssertNonZero(piControlsCursor->Insert());
	}
	//Ensure(m_piDialog->FinishCreate());
	WIN::SendMessage(m_pWndDialog, WM_SETREDRAW, fTrue, 0L);
	RECT rect;
	AssertNonZero(WIN::SetRect(&rect, m_iX, m_iY, m_iX + m_iWidth, m_iY + m_iHeight));
	AssertNonZero(WIN::InvalidateRect(m_pWndDialog, &rect, fTrue));
	return 0;
}

IMsiControl* CreateMsiBillboard(IMsiEvent& riDialog)
{
	return new CMsiBillboard(riDialog);
}


/////////////////////////////////////////////
// CMsiGroupBox  definition
/////////////////////////////////////////////

class CMsiGroupBox:public CMsiControl
{
public:
	CMsiGroupBox(IMsiEvent& riDialog);
	IMsiRecord*            __stdcall WindowCreate(IMsiRecord& riRecord);
protected:
};



/////////////////////////////////////////////////
// CMsiGroupBox  implementation
/////////////////////////////////////////////////

CMsiGroupBox::CMsiGroupBox(IMsiEvent& riDialog) : CMsiControl(riDialog)
{
}


IMsiRecord* CMsiGroupBox::WindowCreate(IMsiRecord& riRecord)
{
	Ensure(CMsiControl::WindowCreate(riRecord));
	Ensure(CreateControlWindow(TEXT("BUTTON"), BS_GROUPBOX | (m_fRightAligned ? BS_RIGHT : 0), m_fRTLRO ? WS_EX_RTLREADING : 0, *m_strText, m_pWndDialog, m_iKey));
	Ensure(WindowFinalize());
	AssertNonZero(WIN::SetWindowPos(m_pWnd, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE));
	return 0;
}

IMsiControl* CreateMsiGroupBox(IMsiEvent& riDialog)
{
	return new CMsiGroupBox(riDialog);
}

/////////////////////////////////////////////
// CMsiLine  definition
/////////////////////////////////////////////

class CMsiLine:public CMsiControl
{
public:
	CMsiLine(IMsiEvent& riDialog);
	IMsiRecord*            __stdcall WindowCreate(IMsiRecord& riRecord);
protected:
};



/////////////////////////////////////////////////
// CMsiLine  implementation
/////////////////////////////////////////////////

CMsiLine::CMsiLine(IMsiEvent& riDialog) : CMsiControl(riDialog)
{
}


IMsiRecord* CMsiLine::WindowCreate(IMsiRecord& riRecord)
{
	Ensure(CMsiControl::WindowCreate(riRecord));
	m_iHeight = 1; 
	Ensure(CreateControlWindow(TEXT("STATIC"), SS_ETCHEDHORZ | SS_SUNKEN, 0, *m_strText, m_pWndDialog, m_iKey));
	Ensure(WindowFinalize());
	AssertNonZero(WIN::SetWindowPos(m_pWnd, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE));
	return 0;
}

IMsiControl* CreateMsiLine(IMsiEvent& riDialog)
{
	return new CMsiLine(riDialog);
}

/////////////////////////////////////////////
// CMsiDirectoryCombo  definition
/////////////////////////////////////////////

class CMsiDirectoryCombo:public CMsiActiveControl
{
public:
	CMsiDirectoryCombo(IMsiEvent& riDialog);
	virtual ~CMsiDirectoryCombo();
	virtual IMsiRecord*       __stdcall WindowCreate(IMsiRecord& riRecord);
	virtual IMsiRecord*       __stdcall GetPropertyFromDatabase();

protected:
	virtual IMsiRecord*        PropertyChanged ();

private:
	IMsiRecord*                Redraw();
	IMsiRecord*                DrawItem(WPARAM wParam, LPARAM lParam);
	IMsiRecord*                Command(WPARAM wParam, LPARAM lParam);
	IMsiRecord*                Bisect();
	IMsiRecord*                NCDestroy(WPARAM wParam, LPARAM lParam);
	IMsiRecord*                CompareItem(WPARAM wParam, LPARAM lParam);
	IMsiRecord*                GetIgnoreChange(IMsiRecord& riRecord);
	IMsiRecord*                SetIgnoreChange(IMsiRecord& riRecord);
	PMsiTable                  m_piValuesTable;
	MsiString                  m_strBody;
	Bool                       m_fFirstTime;
	Bool                       m_fIgnoreChange;
	ICHAR                      m_rgchPrevSelection[MAX_PATH];
};

enum DirectoryComboColumns
{
	itabDCPath = 1,      //S
	itabDCParent,        //S
	itabDCText,          //S
	itabDCDisplay,       //S
	itabDCImage,         //I
	itabDCShow,          //I
	itabDCPropPath       //S
};

/////////////////////////////////////////////////
// CMsiDirectoryCombo  implementation
/////////////////////////////////////////////////

CMsiDirectoryCombo::CMsiDirectoryCombo(IMsiEvent& riDialog) : CMsiActiveControl(riDialog), m_piValuesTable(0)
{
	m_fFirstTime = fTrue;
	m_fIgnoreChange = fFalse;
	m_fUseDbLang = false;
}

CMsiDirectoryCombo::~CMsiDirectoryCombo()
{
}

IMsiRecord* CMsiDirectoryCombo::WindowCreate(IMsiRecord& riRecord)
{
	Ensure(CMsiActiveControl::WindowCreate(riRecord));
	if (IsIntegerOnly ())
	{
		return PostErrorDlgKey(Imsg(idbgNoInteger));
	}
	PMsiRecord piRecord = &m_piServices->CreateRecord(1);

	Ensure(CreateControlWindow(TEXT("COMBOBOX"),
										CBS_DROPDOWNLIST | CBS_OWNERDRAWFIXED | CBS_HASSTRINGS |
											WS_VSCROLL | CBS_SORT | WS_TABSTOP,
										(m_fRTLRO ? WS_EX_RTLREADING : 0) | (m_fRightAligned ? WS_EX_RIGHT : 0) |
											(m_fLeftScroll ? WS_EX_LEFTSCROLLBAR : 0),
										*m_strText, m_pWndDialog, m_iKey));
	AssertNonZero(WIN::SendMessage(m_pWnd, CB_SETITEMHEIGHT, 0,
					  GetOwnerDrawnComboListHeight()) != CB_ERR);
	ULONG_PTR dwIndex;			//--merced: changed DWORD to ULONG_PTR
	Ensure(WindowFinalize());
	Assert(!m_piValuesTable);
	Ensure(CreateTable(pcaTableIDirectoryCombo, *&m_piValuesTable));
	::CreateTemporaryColumn(*m_piValuesTable, icdString + icdPrimaryKey, itabDCPath);
	::CreateTemporaryColumn(*m_piValuesTable, icdString + icdNullable, itabDCParent);
	::CreateTemporaryColumn(*m_piValuesTable, icdString + icdNullable, itabDCText);
	::CreateTemporaryColumn(*m_piValuesTable, icdString + icdNullable, itabDCDisplay);
	::CreateTemporaryColumn(*m_piValuesTable, icdLong + icdNullable, itabDCImage);
	::CreateTemporaryColumn(*m_piValuesTable, icdLong + icdNullable, itabDCShow);
	::CreateTemporaryColumn(*m_piValuesTable, icdString + icdNullable, itabDCPropPath);
	if (m_fPreview)
		return 0;
	PMsiCursor piValuesCursor(0);
	Ensure(::CursorCreate(*m_piValuesTable, pcaTableIDirectoryCombo, fFalse, *m_piServices, *&piValuesCursor)); 
	int iAttributes = riRecord.GetInteger(itabCOAttributes);
	PMsiTable piVolumesTable(0);
	Ensure(GetVolumeList(iAttributes, *&piVolumesTable));
	PMsiCursor piVolumesCursor(0);
	Ensure(::CursorCreate(*piVolumesTable, pcaTableIVolumeList, fFalse, *m_piServices, *&piVolumesCursor)); 
	PMsiPath piPath(0);
	MsiString strNull;
	while(piVolumesCursor->Next())
	{
		PMsiVolume piVolume = (IMsiVolume *) piVolumesCursor->GetMsiData(1);
		if ( ShouldHideVolume(piVolume->VolumeID()) )
			continue;
		piValuesCursor->Reset();
		AssertRecord(CreatePath(MsiString(piVolume->GetPath()), *&piPath));  // temp???
		MsiString strPath = piPath->GetPath();
		MsiString strUpper = strPath;
		strUpper.UpperCase();
		AssertNonZero(piValuesCursor->PutString(itabDCPath, *strUpper));
		AssertNonZero(piValuesCursor->PutString(itabDCParent, *strNull));
		AssertNonZero(piValuesCursor->PutString(itabDCPropPath, *strPath));
		MsiString strText;
		if(piVolume->DriveType() ==  idtRemote)
			strText = MsiString(*TEXT(" "));
		else
			strText = MsiString(*TEXT("  "));
		strText += strPath; 	// we put a  2 spaces infront of every volume except the remote ones (that get one space) to force the right ordering
		if ( g_fChicago )
		{
			SHFILEINFO sfi;
			SHGetFileInfo((LPCTSTR)(const ICHAR*)strPath, 0,
							  &sfi, sizeof(sfi), SHGFI_DISPLAYNAME);
			strPath = sfi.szDisplayName;
		}
		else
		{
			MsiString strUNC = piVolume->UNCServer();
			if (strUNC.TextSize() > 0)
			{
				strPath += MsiString(*TEXT("  "));
				strPath += strUNC;
			}
		}
		AssertNonZero(piValuesCursor->PutString(itabDCText, *strText));
		AssertNonZero(piValuesCursor->PutString(itabDCDisplay, *strPath));
		AssertNonZero(piValuesCursor->PutInteger(itabDCImage, ::GetVolumeIconIndex(*piVolume)));
		dwIndex = WIN::SendMessage(m_pWnd, CB_ADDSTRING, 0, (LONG_PTR) (LPSTR)(const ICHAR*)strText);	//--merced: changed long to LONG_PTR
		AssertNonZero(piValuesCursor->PutInteger(itabDCShow, fTrue));
		AssertNonZero(piValuesCursor->Insert());
	}
	// we want the volumes sorted, but not the folders
	::ChangeWindowStyle(m_pWnd, CBS_SORT, 0, fFalse);

	// we need to replace all strings in the combobox with the respective keys in the table
	INT_PTR iCount = WIN::SendMessage(m_pWnd, CB_GETCOUNT, 0, 0);		//--merced: changed int to INT_PTR
	if ( iCount )
	{
		piValuesCursor->SetFilter(iColumnBit(itabDCText));
		ICHAR szTemp[MAX_PATH];

		for ( int i=0; i < iCount; i++ )
		{
			AssertNonZero(WIN::SendMessage(m_pWnd, CB_GETLBTEXT,
													 (WPARAM)i, (LPARAM)(LPCSTR)szTemp) != CB_ERR);
			piValuesCursor->Reset();
			AssertNonZero(piValuesCursor->PutString(itabDCText, *MsiString(szTemp)));
			AssertNonZero(piValuesCursor->Next());
			AssertNonZero(WIN::SendMessage(m_pWnd, CB_DELETESTRING ,
													 (WPARAM)i, 0) != CB_ERR);
			AssertNonZero(WIN::SendMessage(m_pWnd, CB_INSERTSTRING,
													 (WPARAM)i,
													 (LPARAM)(LPCTSTR)(const ICHAR*)MsiString(piValuesCursor->GetString(itabDCPath))) == i);
		}
	}

	m_piValuesTable->LinkTree(itabDCParent);

	Ensure(Bisect());
	return 0;
}

IMsiRecord* CMsiDirectoryCombo::Redraw()
{
	if (m_fPreview)
		return 0;
	PMsiCursor piValuesCursorTree(0);
	Ensure(::CursorCreate(*m_piValuesTable, pcaTableIDirectoryCombo, fTrue, *m_piServices, *&piValuesCursorTree)); 
	int iLevel;
	ULONG_PTR dwIndex;		//--merced: changed DWORD to ULONG_PTR
	while ((iLevel = piValuesCursorTree->Next()) != 0)
	{
		// hide everything below the level of drives
		if (iLevel > 1)
		{
			dwIndex = WIN::SendMessage(m_pWnd, CB_FINDSTRING, (WPARAM)-1, (LPARAM)(const ICHAR*)MsiString(piValuesCursorTree->GetString(itabDCPath)));
			WIN::SendMessage(m_pWnd, CB_DELETESTRING, dwIndex, 0);
			AssertNonZero(piValuesCursorTree->PutInteger(itabDCShow, fFalse));
			AssertNonZero(piValuesCursorTree->Update());
		}
	}
	m_piValuesTable->LinkTree(0); // unlink tree
	PMsiCursor piValuesCursor(0);
	Ensure(::CursorCreate(*m_piValuesTable, pcaTableIDirectoryCombo, fFalse, *m_piServices, *&piValuesCursor));
	piValuesCursor->SetFilter(iColumnBit(itabDCPath));
	MsiString strTail;
	MsiString strPath;
	MsiString strUpper;
	PMsiPath piPath(0);
	AssertRecord(CreatePath(m_strBody, *&piPath));
	for(;;)
	{
		piValuesCursor->Reset();
		strTail = piPath->GetEndSubPath();
		strPath = piPath->GetPath();
		PMsiVolume piVolume = &piPath->GetVolume();
		strUpper = strPath;
		strUpper.UpperCase();
		AssertNonZero(piValuesCursor->PutString(itabDCPath, *strUpper));
		if (strTail.TextSize() == 0)  // we have a drive in hand
		{
			if (!piValuesCursor->Next() && !ShouldHideVolume(piVolume->VolumeID()))
			{
				// the volume is not in the list and it can be displayed
				MsiString strNull;
				piValuesCursor->Reset();
				AssertNonZero(piValuesCursor->PutString(itabDCPath, *strUpper));
				AssertNonZero(piValuesCursor->PutString(itabDCParent, *strNull));
				AssertNonZero(piValuesCursor->PutString(itabDCDisplay, *strPath));
				AssertNonZero(piValuesCursor->PutString(itabDCText, *strPath));
				AssertNonZero(piValuesCursor->PutInteger(itabDCImage, ::GetVolumeIconIndex(*piVolume)));
				dwIndex = WIN::SendMessage(m_pWnd, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)(const ICHAR*)strUpper);
				AssertNonZero(piValuesCursor->PutInteger(itabDCShow, fTrue));
				AssertNonZero(piValuesCursor->PutString(itabDCPropPath, *strPath));
				AssertNonZero(piValuesCursor->Insert());
			}
			break;
		}
		Bool fExists;
		Ensure(piPath->Exists(fExists));
		Ensure(piPath->ChopPiece());
		if (piValuesCursor->Next())		// the path is already in the table
		{
			if (ToBool(piValuesCursor->GetInteger(itabDCShow)) == fFalse)
			{
				AssertNonZero(piValuesCursor->PutInteger(itabDCShow, 2 * fTrue));	 // make it visible, has to be added to the control later
				AssertNonZero(piValuesCursor->Update());
			}
		}
		else if ( !ShouldHideVolume(piVolume->VolumeID()) )
		{
			piValuesCursor->Reset();
			AssertNonZero(piValuesCursor->PutString(itabDCPath, *strUpper));
			AssertNonZero(piValuesCursor->PutString(itabDCText, *strTail));
			AssertNonZero(piValuesCursor->PutString(itabDCPropPath, *strPath));
			AssertNonZero(piValuesCursor->PutString(itabDCDisplay, *strTail));
			MsiString strTemp = piPath->GetPath();
			strTemp.UpperCase();
			AssertNonZero(piValuesCursor->PutString(itabDCParent, *strTemp));
			AssertNonZero(piValuesCursor->PutInteger(itabDCImage, (int) (fExists ? g_iIconIndexFolder : g_iIconIndexPhantom)));
			AssertNonZero(piValuesCursor->PutInteger(itabDCShow, 2 * fTrue)); // mark as new, has to be added to the control later
			AssertNonZero(piValuesCursor->Insert());
		}
	}
	m_piValuesTable->LinkTree(itabDCParent);		// relink tree
	piValuesCursorTree->Reset();
	while (piValuesCursorTree->Next())
	{
		if (piValuesCursorTree->GetInteger(itabDCShow) == 2 * fTrue)		// new item, has to be added to the combo box
		{
			AssertNonZero(piValuesCursorTree->PutInteger(itabDCShow, fTrue));
			AssertNonZero(piValuesCursorTree->Update());
			piValuesCursor->SetFilter(iColumnBit(itabDCPath));
			piValuesCursor->Reset();
			int iParent = piValuesCursorTree->GetInteger(itabDCParent);
			AssertNonZero(piValuesCursor->PutInteger(itabDCPath, iParent));
			AssertNonZero(piValuesCursor->Next());
			dwIndex = WIN::SendMessage(m_pWnd, CB_FINDSTRING, (WPARAM)-1,
												(LPARAM)(const ICHAR*)MsiString(piValuesCursor->GetString(itabDCPath)));
			Assert(dwIndex != CB_ERR);
			dwIndex++;
			AssertNonZero(dwIndex == WIN::SendMessage(m_pWnd, CB_INSERTSTRING,
												(WPARAM)dwIndex,
												(LPARAM)(LPCTSTR)(const ICHAR*)MsiString(piValuesCursorTree->GetString(itabDCPath))));
		}
	}
	strUpper = m_strBody;
	strUpper.UpperCase();
	StringCbCopy(m_rgchPrevSelection, sizeof(m_rgchPrevSelection), (const ICHAR*)strUpper);
	WIN::SendMessage(m_pWnd, CB_SELECTSTRING, -1, (LPARAM)(LPCTSTR)m_rgchPrevSelection);
	return 0;
}


IMsiControl* CreateMsiDirectoryCombo(IMsiEvent& riDialog)
{
	return new CMsiDirectoryCombo(riDialog);
}

IMsiRecord* CMsiDirectoryCombo::PropertyChanged ()
{
	if (m_fPreview)
		return 0;
	MsiString strOldBody = m_strBody;
	Ensure(CMsiActiveControl::PropertyChanged ());
	Ensure(Bisect());
	if (!m_strBody.Compare(iscExact, strOldBody) || m_fFirstTime)
	{
		Ensure(Redraw());
		m_fFirstTime = fFalse;
	}
	return (0);
}

IMsiRecord* CMsiDirectoryCombo::Command(WPARAM wParam, LPARAM /*lParam*/)
{
	if (HIWORD(wParam) == CBN_SELENDOK)
	{
		ICHAR achTemp[MAX_PATH];
		WIN::SendMessage(m_pWnd, CB_GETLBTEXT, WIN::SendMessage(m_pWnd, CB_GETCURSEL, 0, 0L), (LPARAM) (LPCSTR) achTemp);
		MsiString strNewBody(achTemp);
		PMsiPath piPath(0);
		AssertRecord(CreatePath(strNewBody, *&piPath));
		//  I check the path first
		PMsiRecord piReturn = CMsiControl::CheckPath(*piPath);
		if ( piReturn )
		{
			//  the path is not OK.  I display an error message and I return.
			m_piEngine->Message(imtEnum(imtError | imtOk), *piReturn);
			//  I set the previous selection back
			AssertNonZero(WIN::SendMessage(m_pWnd, CB_SELECTSTRING, -1, (LPARAM)(LPCTSTR)m_rgchPrevSelection) != CB_ERR);
			return PostErrorDlgKey(Imsg(idbgWinMes), 0);
		}
		PMsiVolume piVolume = &piPath->GetVolume();
		idtEnum iType = piVolume->DriveType();
		if (iType == idtRemovable || iType == idtCDROM || iType == idtFloppy)
		{
			while (piVolume->DiskNotInDrive())
			{
				PMsiRecord piReturn = PostError(Imsg(imsgDiskNotInDrive), *MsiString(piVolume->GetPath()));
				imsEnum iReturn = m_piEngine->Message(imtEnum(imtError | imtRetryCancel | imtDefault2), *piReturn);
				if (iReturn == imsCancel)
				{
					//  I set the previous selection back
					AssertNonZero(WIN::SendMessage(m_pWnd, CB_SELECTSTRING,
								-1, (LPARAM)(LPCTSTR)m_rgchPrevSelection) != CB_ERR);
					Ensure(Redraw());
					return PostErrorDlgKey(Imsg(idbgWinMes), 0);
				}
				Assert(iReturn == imsRetry); // it should be either cancel or retry
			}
		}
		//  retrieving the respective path property from the table.
		PMsiCursor piValuesCursor(0);
		Ensure(::CursorCreate(*m_piValuesTable, pcaTableIDirectoryCombo, fFalse, *m_piServices, *&piValuesCursor));
		piValuesCursor->SetFilter(iColumnBit(itabDCPath));
		AssertNonZero(piValuesCursor->PutString(itabDCPath, *strNewBody));
		AssertNonZero(piValuesCursor->Next());
		MsiString strProp = piValuesCursor->GetString(itabDCPropPath);
		//  setting the path property in the database.
		m_piHandler->ShowWaitCursor();
		PMsiRecord piRec = SetPropertyValue(*strProp, fTrue);
		m_piHandler->RemoveWaitCursor();
		if (piRec)
		{
			m_piEngine->Message(imtError, *piRec);
			Bool fTemp = m_fRefreshProp;
			m_fRefreshProp = fTrue;
			Ensure(GetPropertyFromDatabase());
			m_fRefreshProp = fTemp;
		}
		else
		{
			m_strBody = strNewBody;
			StringCbCopy(m_rgchPrevSelection, sizeof(m_rgchPrevSelection), (const ICHAR*)strNewBody);
		}

		return PostErrorDlgKey(Imsg(idbgWinMes), 0);
	} 
	return 0;
}

IMsiRecord* CMsiDirectoryCombo::GetPropertyFromDatabase()
{
	if (m_fPreview)
		return 0;
	if (m_fIgnoreChange)
	{
		m_fIgnoreChange = fFalse;
		return 0;
	}
	Ensure(CMsiActiveControl::GetPropertyFromDatabase());
	Ensure(Bisect());
	Ensure(Redraw());
	return 0;
}

IMsiRecord* CMsiDirectoryCombo::DrawItem(WPARAM /*wParam*/, LPARAM lParam)
{
	Ensure(CheckInitialized());

	LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT) lParam;
	INT_PTR count = WIN::SendMessage(m_pWnd, CB_GETCOUNT, 0, 0);		//--merced: changed int to INT_PTR
	if (lpdis->itemID == -1)
		return 0;
	int iPath = lpdis->itemID;
	PMsiCursor piValuesCursorTree(0);
	Ensure(::CursorCreate(*m_piValuesTable, pcaTableIDirectoryCombo, fTrue, *m_piServices, *&piValuesCursorTree)); 
	piValuesCursorTree->SetFilter(iColumnBit(itabDCPath));
	ICHAR achTemp[MAX_PATH];
	WIN::SendMessage(m_pWnd, CB_GETLBTEXT, lpdis->itemID, (LPARAM)(LPCSTR)achTemp);
	AssertNonZero(piValuesCursorTree->PutString(itabDCPath, *MsiString(achTemp)));
	int iLevel;
	AssertNonZero(iLevel = piValuesCursorTree->Next());
	int iIndex = piValuesCursorTree->GetInteger(itabDCImage);
	COLORREF clrForeground = WIN::SetTextColor(lpdis->hDC, WIN::GetSysColor(lpdis->itemState & ODS_SELECTED ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT));
	Assert(clrForeground != CLR_INVALID);
	COLORREF clrBackground = WIN::SetBkColor(lpdis->hDC, WIN::GetSysColor(lpdis->itemState & ODS_SELECTED ? COLOR_HIGHLIGHT : COLOR_WINDOW));
	Assert(clrBackground != CLR_INVALID);
	TEXTMETRIC tm;
	AssertNonZero(GetTextMetrics(lpdis->hDC, &tm));
	int y = (lpdis->rcItem.bottom + lpdis->rcItem.top - tm.tmHeight) / 2;
	int x = LOWORD(WIN::GetDialogBaseUnits()) / 4;
	int ix = ((lpdis->itemState & ODS_COMBOBOXEDIT) ? 0 : 12 * (iLevel - 1)) + 26 + 2 * x;
	MsiString strText = piValuesCursorTree->GetString(itabDCDisplay);
	int cChars = strText.TextSize();
	SIZE size;
	WIN::GetTextExtentPoint32(lpdis->hDC, (const ICHAR*)strText, cChars, &size);
	RECT rect;
	AssertNonZero(WIN::SetRect(&rect, ix, y, ix + size.cx, y + tm.tmHeight));
	WIN::ExtTextOut(lpdis->hDC, ix, y, ETO_CLIPPED | ETO_OPAQUE, g_fChicago ? &rect : &lpdis->rcItem, (const ICHAR*)strText, cChars, 0);
	AssertNonZero(CLR_INVALID != WIN::SetTextColor(lpdis->hDC, clrForeground));
	AssertNonZero(CLR_INVALID != WIN::SetBkColor(lpdis->hDC, clrBackground));
	y = (lpdis->rcItem.bottom + lpdis->rcItem.top - 16) / 2;
	ix = ((lpdis->itemState & ODS_COMBOBOXEDIT) ? 0 : 12 * (iLevel - 1)) + 6 + x; 
	AssertNonZero(ImageList_DrawEx(g_hVolumeSmallIconList, iIndex, lpdis->hDC, ix, y, 16, 16, CLR_NONE, CLR_NONE, ILD_TRANSPARENT));
	
	return PostErrorDlgKey(Imsg(idbgWinMes), 1);
}

IMsiRecord* CMsiDirectoryCombo::Bisect()
{
	if (m_fPreview)
		return 0;
	PMsiPath piPath(0);
	Ensure(CreatePath(MsiString(GetPropertyValue ()), *&piPath));
	m_strBody = piPath->GetPath();
	return 0;
}

// the following method is only needed to work around a bug in NT4.0 build 1314
// this bug causes an ownerdraw combobox with non-zero items to receive messages after
// WM_NCDESTROY. To avoid this problem we make sure that there are no items in the combobox
// when the NT4 bug is fixed, this function can be removed
IMsiRecord* CMsiDirectoryCombo::NCDestroy(WPARAM, LPARAM)
{
	AssertSz(!m_iRefCnt,"Trying to remove a control, but somebody still holds a reference to it");
	WIN::SendMessage(m_pWnd, CB_RESETCONTENT, 0, 0);
	IMsiRecord* riReturn = PostErrorDlgKey(Imsg(idbgWinMes), 0);
	delete this;
	return riReturn;
}

IMsiRecord* CMsiDirectoryCombo::CompareItem(WPARAM /*wParam*/, LPARAM lParam)
{
	LPCOMPAREITEMSTRUCT lpcis = (LPCOMPAREITEMSTRUCT) lParam;
	ICHAR* pText1 = (ICHAR*) lpcis->itemData1;
	ICHAR* pText2 = (ICHAR*) lpcis->itemData2;
	if (*pText1 == TEXT('\\') && *pText2 != TEXT('\\'))
		return PostErrorDlgKey(Imsg(idbgWinMes), 1);
	if (*pText1 != TEXT('\\') && *pText2 == TEXT('\\'))
		return PostErrorDlgKey(Imsg(idbgWinMes), -1);
	return 0;
}

IMsiRecord* CMsiDirectoryCombo::GetIgnoreChange(IMsiRecord& riRecord)
{

	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeIgnoreChange));
	riRecord.SetInteger(1, m_fIgnoreChange);
	return 0;
}

IMsiRecord* CMsiDirectoryCombo::SetIgnoreChange(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeIgnoreChange));
	m_fIgnoreChange = ToBool(riRecord.GetInteger(1));
	return 0;
}

/////////////////////////////////////////////
// CMsiDirectoryList  definition
/////////////////////////////////////////////

class CMsiDirectoryList:public CMsiActiveControl
{
public:
	CMsiDirectoryList(IMsiEvent& riDialog);
	virtual ~CMsiDirectoryList();
	virtual IMsiRecord*       __stdcall WindowCreate(IMsiRecord& riRecord);
	virtual IMsiRecord*       __stdcall HandleEvent(const IMsiString& riEventNameString, const IMsiString& riArgumentString);
	virtual IMsiRecord*       __stdcall GetPropertyFromDatabase();

protected:
	virtual IMsiRecord*        PropertyChanged ();
	virtual IMsiRecord*        SetPropertyValue(const IMsiString& riValueString, Bool fCallPropChanged);
	virtual IMsiRecord*        KeyDown(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*        GetDlgCode(WPARAM wParam, LPARAM lParam);

private:
	IMsiRecord*                UpOneLevel(IMsiPath* piPath);
	IMsiRecord*                NewFolder(IMsiPath* piPath);
	IMsiRecord*                Notify(WPARAM wParam, LPARAM lParam);
	IMsiRecord*                StepDown(int iSelected);
	IMsiRecord*                Select(int iSelected);
	IMsiRecord*                Bisect();
	IMsiRecord*                Redraw();
	IMsiRecord*                SilentlySetPropertyValue(IMsiPath&);
	PMsiTable                  m_piValuesTable; 
	MsiString                  m_strBody;
	MsiString                  m_strTail;
	MsiString                  m_strPhantomPath;
	MsiString                  m_strPhantomName;
	MsiString                  m_strNewFolder;
	Bool                       m_fFirstTime;
};

/////////////////////////////////////////////////
// CMsiDirectoryList  implementation
/////////////////////////////////////////////////

CMsiDirectoryList::CMsiDirectoryList(IMsiEvent& riDialog) : CMsiActiveControl(riDialog), m_piValuesTable(0)
{
	MsiString strNull;
	m_strBody = strNull;
	m_strPhantomPath = strNull;
	m_strPhantomName = strNull;
	m_strNewFolder = strNull;
	m_fFirstTime = fTrue;
	m_fUseDbLang = false;
}

CMsiDirectoryList::~CMsiDirectoryList()
{
	PMsiRecord(m_piDialog->RegisterControlEvent(*m_strKey, fFalse, pcaControlEventDirectoryListOpen));
	PMsiRecord(m_piDialog->RegisterControlEvent(*m_strKey, fFalse, pcaControlEventDirectoryListUp));
	PMsiRecord(m_piDialog->RegisterControlEvent(*m_strKey, fFalse, pcaControlEventDirectoryListNew));
}

IMsiRecord* CMsiDirectoryList::WindowCreate(IMsiRecord& riRecord)
{
	int iAttributes = riRecord.GetInteger(itabCOAttributes);
	Ensure(CMsiActiveControl::WindowCreate(riRecord));
	if (IsIntegerOnly ())
	{
		return PostErrorDlgKey(Imsg(idbgNoInteger));
	}
	Assert(!m_piValuesTable);
	Ensure(CreateTable(pcaTableIDirectoryList, *&m_piValuesTable));
	Ensure(m_piDialog->RegisterControlEvent(*m_strKey, fTrue, pcaControlEventDirectoryListUp));
	Ensure(m_piDialog->RegisterControlEvent(*m_strKey, fTrue, pcaControlEventDirectoryListNew));
	Ensure(m_piDialog->RegisterControlEvent(*m_strKey, fTrue, pcaControlEventDirectoryListOpen));
	Ensure(CreateControlWindow(WC_LISTVIEW, LVS_LIST | WS_TABSTOP | LVS_EDITLABELS | WS_VSCROLL | LVS_SHAREIMAGELISTS | LVS_AUTOARRANGE | LVS_SINGLESEL | WS_BORDER | LVS_SORTASCENDING | LVS_SHOWSELALWAYS, (m_fRTLRO ? WS_EX_RTLREADING : 0) | (m_fRightAligned ? WS_EX_RIGHT : 0) | (m_fLeftScroll ? WS_EX_LEFTSCROLLBAR : 0), *m_strText, m_pWndDialog, m_iKey));
	ListView_SetImageList(m_pWnd, g_hVolumeSmallIconList, LVSIL_SMALL);
	Ensure(WindowFinalize());
	Ensure(Bisect ());
	m_strNewFolder = ::GetUIText(*MsiString(*pcaNewFolder));
	// this is a hard wired non-localized default in case we don't find the value in the table
	if (!m_strNewFolder.Compare(iscWithin, TEXT("|")))
		m_strNewFolder = TEXT("Fldr|New Folder");
	return 0;
}

IMsiRecord* CMsiDirectoryList::SetPropertyValue(const IMsiString& riValueString, Bool fCallPropChanged)
{
	if (!fCallPropChanged && riValueString.Compare(iscExact, MsiString(GetPropertyValue()))) // the property has not changed
		return 0; 
	PMsiRecord piRecord = CMsiActiveControl::SetPropertyValue (riValueString, fCallPropChanged);
	if (piRecord)
	{
		m_piEngine->Message(imtError, *piRecord);
		return 0;
	}
	if (fCallPropChanged)
		Ensure(Redraw());
	return (0);
}

IMsiRecord* CMsiDirectoryList::SilentlySetPropertyValue(IMsiPath& pPath)
{
	//  changes the property without causing the view redraw and signaling other
	//  controls to ignore changes.
	m_piHandler->ShowWaitCursor();
	PMsiRecord piRecord = &m_piServices->CreateRecord(1);
	AssertNonZero(piRecord->SetInteger(1, fTrue)); 
	Ensure(m_piDialog->PublishEventSz(pcaControlEventDirectoryListIgnoreChange, *piRecord));

	if (!SetDBProperty(*m_strPropertyName, *MsiString(pPath.GetPath()))) 
		return PostError(Imsg(idbgSettingPropertyFailed), *m_strPropertyName);
	Ensure(m_piDialog->PropertyChanged(*m_strPropertyName, *m_strKey));

	AssertNonZero(piRecord->SetInteger(1, fFalse)); 
	Ensure(m_piDialog->PublishEventSz(pcaControlEventDirectoryListIgnoreChange, *piRecord));
	m_piHandler->RemoveWaitCursor();
	return 0;
}

IMsiControl* CreateMsiDirectoryList(IMsiEvent& riDialog)
{
	return new CMsiDirectoryList(riDialog);
}

IMsiRecord* CMsiDirectoryList::PropertyChanged ()
{
	if (m_fPreview)
		return 0;
	MsiString strOldBody = m_strBody;
	Ensure(CMsiActiveControl::PropertyChanged ());
	Ensure(Bisect());
	if (m_strPhantomPath.TextSize() == 0) // first time setting the property value
	{
		m_strPhantomPath = m_strBody;
	}
	if (!m_strBody.Compare(iscExact, strOldBody) || m_fFirstTime)
	{
	//	Ensure(Redraw());
	}
	m_fFirstTime = fFalse;
	return (0);
}

IMsiRecord* CMsiDirectoryList::GetPropertyFromDatabase()    
{
	if (m_fPreview)
		return 0;
	MsiString strOldBody = m_strBody;
	Ensure(CMsiActiveControl::GetPropertyFromDatabase ());
	PMsiPath piPath(0);
	Ensure(CreatePath(m_strBody, *&piPath));
	MsiString strTail = piPath->GetEndSubPath();
	if (strTail.TextSize() == 0)  // we have a drive in hand
	{
		Ensure(m_piDialog->EventActionSz(pcaControlEventDirectoryListUp, *MsiString(*pcaActionDisable)));
	}
	else
	{
		Ensure(m_piDialog->EventActionSz(pcaControlEventDirectoryListUp, *MsiString(*pcaActionEnable)));
	}
	Ensure(Bisect ());
	if (m_strPhantomPath.TextSize() == 0) // first time setting the property value
	{
		m_strPhantomPath = m_strBody;
	}
	if (!m_strBody.Compare(iscExact, strOldBody) || m_fFirstTime)
	{
		Ensure(Redraw());
	}
	m_fFirstTime = fFalse;
	return 0;
}


IMsiRecord* CMsiDirectoryList::Redraw()
{
	if (m_fPreview)
		return 0;
	MsiString strNull;
	m_strPhantomName = strNull;
	AssertNonZero(ListView_DeleteAllItems(m_pWnd));
	LV_ITEM lvI;
	lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;// | LVIF_PARAM;
	lvI.state = 0;
	lvI.stateMask = 0;
	unsigned long pcFetched;
	int index = 0;
	PMsiPath pPath(0);
	Ensure(CreatePath(m_strBody, *&pPath));
	MsiString strTail = pPath->GetEndSubPath();
	if (strTail.TextSize() == 0)  // we have a drive in hand
	{
		Ensure(m_piDialog->EventActionSz(pcaControlEventDirectoryListUp, *MsiString(*pcaActionDisable)));
	}
	else
	{
		Ensure(m_piDialog->EventActionSz(pcaControlEventDirectoryListUp, *MsiString(*pcaActionEnable)));
	}

	// We use ipvtNone to avoid writability checks at this stage - otherwise, we may not
	// be able to get the browse dialog displayed to give the user a chance to change
	// away from an unwritable location. We'll eventually call SetTargetPath before
	// leaving the browse dialog to do the final checks.
	PMsiRecord pRec = CMsiControl::CheckPath(*pPath, NULL, ipvtNone);
	MsiString strAction;
	if ( !pRec )
		strAction = pcaActionEnable;
	else
		strAction = pcaActionDisable;
	Ensure(m_piDialog->EventActionSz(pcaControlEventDirectoryListNew, *strAction)); 
	Bool fExists;
	Ensure(pPath->Exists(fExists));
	WIN::SendMessage(m_pWnd, WM_SETREDRAW, fFalse, 0L);
	if (fExists)
	{
		PEnumMsiString peFolders(0);
		if(PMsiRecord(pPath->GetSubFolderEnumerator(*&peFolders, /* fExcludeHidden = */ fTrue)))
		{
			PMsiRecord piRec = &m_piServices->CreateRecord(1);
			AssertNonZero(piRec->SetInteger(1, imsgPathNotReadable));
			m_piEngine->Message(imtError, *piRec);
			return 0;
		}
		MsiString ppiFolder(0);
		for(;;)
		{
			peFolders->Next(1, &ppiFolder, &pcFetched);
			if (pcFetched == 0)
			{
				break;
			}
			MsiString strPath = ppiFolder;
			lvI.iItem =  index++;
			lvI.iSubItem = 0;
			lvI.pszText = (ICHAR*)(const ICHAR*) strPath;
			lvI.iImage = 4;
			lvI.lParam = 0; // temp!!!!!!!!!
			AssertNonZero(ListView_InsertItem(m_pWnd, &lvI) != -1); 
		}
	}
	PMsiPath piPhantomPath(0);
	AssertRecord(CreatePath(m_strPhantomPath, *&piPhantomPath));
	ipcEnum iCompare;
	Ensure(pPath->Compare(*piPhantomPath, iCompare));
	if (iCompare == ipcChild)
	{
		MsiString strLast;
		Bool fFound = fFalse;
		for(;;)
		{
			Bool fPhantomExists;
			Ensure(piPhantomPath->Exists(fPhantomExists));
			if (fPhantomExists)
				break;
			strLast = piPhantomPath->GetEndSubPath();
			Ensure(piPhantomPath->ChopPiece());
			Ensure(pPath->Compare(*piPhantomPath, iCompare));
			if (iCompare == ipcEqual)
			{
				fFound = fTrue;
				break;
			}
		}
		if (fFound) // we found a phantom subfolder
		{
			m_strPhantomName = strLast;
			lvI.iItem =  index++;
			lvI.iSubItem = 0;
			lvI.pszText = (ICHAR*)(const ICHAR*) m_strPhantomName;
			lvI.iImage = 6;
			lvI.lParam = 0; // temp!!!!!!!!!
			AssertNonZero(ListView_InsertItem(m_pWnd, &lvI) != -1); 
		}
	}
	ListView_SetItemState(m_pWnd, 0, LVIS_FOCUSED, LVIS_FOCUSED);
	WIN::SendMessage(m_pWnd, WM_SETREDRAW, fTrue, 0L);
	AssertNonZero(WIN::InvalidateRect(m_pWnd, 0, fTrue));
	if ((iCompare == ipcNoRelation || iCompare == ipcParent) && !fExists)
	{
		m_strPhantomPath = m_strBody;
	}
	MsiString strArg;
	if (ListView_GetNextItem(m_pWnd, -1, LVNI_SELECTED) != -1)
	{
		strArg = MsiString(*pcaActionEnable);
	}
	else
	{	
		strArg = MsiString(*pcaActionDisable);	
	}
	Ensure(m_piDialog->EventActionSz(pcaControlEventDirectoryListOpen, *strArg));
	return 0;
}

IMsiRecord* CMsiDirectoryList::HandleEvent(const IMsiString& rpiEventNameString, const IMsiString& /*rpiArgumentString*/)
{
	if (m_fPreview)
		return 0;
	Ensure(CheckInitialized());

	//  I check the path first
	PMsiPath pPath(0);
	AssertRecord(CreatePath(m_strBody, *&pPath));
	PMsiRecord piReturn = CMsiControl::CheckPath(*pPath);
	if ( piReturn )
	{
		m_piEngine->Message(imtEnum(imtError | imtOk), *piReturn);
		return 0;
	}

	if (rpiEventNameString.Compare(iscExact, MsiString(*pcaControlEventDirectoryListUp)))
	{
		Ensure(UpOneLevel(pPath));
	}
	else if (rpiEventNameString.Compare(iscExact, MsiString(*pcaControlEventDirectoryListNew)))
	{
		Ensure(NewFolder(pPath));
	}
	else if(rpiEventNameString.Compare(iscExact, MsiString(*pcaControlEventDirectoryListOpen)))
	{
		int iSelected = ListView_GetNextItem(m_pWnd, -1, LVNI_SELECTED);
		if ( iSelected != -1 )
		{
			PMsiRecord piRec = StepDown(iSelected);
			if (piRec)
				m_piEngine->Message(imtError, *piRec);
		}
	}
	return 0;
}

IMsiRecord* CMsiDirectoryList::UpOneLevel(IMsiPath* piPath)
{
	if (m_fPreview)
		return 0;
	PMsiRecord piRecord = &m_piServices->CreateRecord(1);
	Ensure(piPath->ChopPiece());
	AssertNonZero(piRecord->SetMsiString(1, *MsiString(piPath->GetPath()))); 
	Ensure(AttributeEx(fTrue, cabPropertyValue, *piRecord));
	Ensure(Redraw());
	Ensure(m_piDialog->SetFocus(*m_strKey));
	return 0;
}

IMsiRecord* CMsiDirectoryList::NewFolder(IMsiPath* piPath)
{
	if (m_fPreview)
		return 0;

	PMsiRecord piRec = CMsiControl::CheckPath(*piPath, NULL, ipvtWritable);
	if ( piRec )
	{
		m_piEngine->Message(imtEnum(imtError | imtOk), *piRec);
		return 0;
	}

	Assert(m_strNewFolder.TextSize());
	if (m_strPhantomName.TextSize() == 0)
	{
		Ensure(m_piServices->ExtractFileName(m_strNewFolder, piPath->SupportsLFN(), *&m_strPhantomName));
		LV_ITEM lvI;
		lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;// | LVIF_PARAM;
		lvI.state = 0;
		lvI.stateMask = 0;
		lvI.iItem =  ListView_GetItemCount(m_pWnd);
		lvI.iSubItem = 0;
		lvI.pszText = (ICHAR*)(const ICHAR*) m_strPhantomName;
		lvI.iImage = 6;
		lvI.lParam = 0; // temp!!!!!!!!!
		AssertNonZero(ListView_InsertItem(m_pWnd, &lvI) != -1); 
	}
	Ensure(piPath->AppendPiece(*m_strPhantomName));
	m_strPhantomPath = piPath->GetPath();
	Ensure(m_piDialog->SetFocus(*m_strKey));
	LV_FINDINFO Findinfo;
	Findinfo.flags = LVFI_STRING;
	const ICHAR* szPhantomName = m_strPhantomName;
	Findinfo.psz = szPhantomName;	  
	int iIndex = ListView_FindItem(m_pWnd, -1, &Findinfo);
	AssertNonZero(ListView_EditLabel(m_pWnd, iIndex));	
	return 0;
}

IMsiRecord* CMsiDirectoryList::Notify(WPARAM /*wParam*/, LPARAM lParam)
{
	if (m_fPreview)
		return 0;
	LPNMHDR lpnmhdr = (LPNMHDR)lParam;
	if (lpnmhdr->hwndFrom != m_pWnd)
		return 0;
	switch (lpnmhdr->code)
		{
	case LVN_ITEMCHANGING:
		{
			LPNMLISTVIEW lpMoreInfo = (LPNMLISTVIEW)lParam;
			if ( lpMoreInfo->uChanged & LVIF_STATE &&        // (much better performance)
				  lpMoreInfo->uNewState & LVIS_SELECTED )
			{
				static int iLevelSel = -2;
				static int iReject = 0;
				static ICHAR rgchLevel[MAX_PATH+1];
				if ( IStrCompI(rgchLevel, (const ICHAR*)m_strBody) )
				{
					//  the directory level has changed, we need to update the
					//  info on the current level.
					StringCbCopy(rgchLevel, sizeof(rgchLevel), (const ICHAR*)m_strBody);
					iLevelSel = -2;
				}
				if ( lpMoreInfo->iItem != iLevelSel )             // (if rejected, comes again)
				{
					int iSelected = lpMoreInfo->iItem;
					iLevelSel = iSelected;
					PMsiRecord piRec = Select(iSelected);
					if (piRec)
						//  bad path - I display the error and reject the selection
						m_piEngine->Message(imtError, *piRec);
					MsiString stAction = (iSelected == -1 || piRec) ? 
												MsiString(*pcaActionDisable) : MsiString(*pcaActionEnable);
					Ensure(m_piDialog->EventActionSz(pcaControlEventDirectoryListOpen, *stAction));
					//  if it could not be selected, I reject the selection
					iReject = piRec ? 1 : 0;
				}
				return (PostErrorDlgKey(Imsg(idbgWinMes), iReject)); 
			}
			break;
		}
	case NM_DBLCLK:
	case NM_RETURN:
		{
			MsiString strDummyArg;
			Ensure(HandleEvent(*MsiString(*pcaControlEventDirectoryListOpen), *strDummyArg));
			break;
		}
	case LVN_BEGINLABELEDIT:
		{
			LV_DISPINFO	* pldvi = (LV_DISPINFO *)lParam;
			int iSelected = pldvi->item.iItem;
			if (iSelected == -1)
				return 0;
			LV_FINDINFO Findinfo;
			Findinfo.flags = LVFI_STRING;
			const ICHAR* szPhantomName = m_strPhantomName;
			Findinfo.psz = szPhantomName;
			int iIndex = ListView_FindItem(m_pWnd, -1, &Findinfo); 

			if (iSelected != iIndex)
			{
				MessageBeep(MB_OK);
				return (PostErrorDlgKey(Imsg(idbgWinMes), 1));
			}	 
			WindowRef pwnd = ListView_GetEditControl(m_pWnd);
			WIN::SendMessage(pwnd, EM_LIMITTEXT, MAX_PATH, 0);
			return (PostErrorDlgKey(Imsg(idbgWinMes), 0));
			break;
		}
	case LVN_ENDLABELEDIT:
		{
			LV_DISPINFO	* pldvi = (LV_DISPINFO *)lParam;
			int iRow = pldvi->item.iItem;
			if (iRow == -1 || pldvi->item.pszText == 0 || *pldvi->item.pszText == TEXT('\0'))
				break; // the user cancelled the edit
			//  eliminating any left-most space characters from the new folder name
			for ( ICHAR* pch=pldvi->item.pszText; *pch; pch=INextChar(pch) )
				if ( *pch != TEXT(' ') )
					break;
			if ( !*pch )
				//  the new name is made up only of blank characters
				break;
			if ( pch != pldvi->item.pszText )
				StringCchCopy(pldvi->item.pszText, pldvi->item.cchTextMax, pch);

			ICHAR achTemp[MAX_PATH];
			ListView_GetItemText(m_pWnd, iRow, 0, achTemp, MAX_PATH);
			PMsiPath piPath(0);
			AssertRecord(CreatePath(m_strBody, *&piPath));
			PMsiRecord piRec = CMsiControl::CheckPath(*piPath, pldvi->item.pszText);
			if (!piRec)
			{
				piRec = piPath->AppendPiece(*MsiString(pldvi->item.pszText));				
			}
		
			if (piRec)
			{
				Ensure(m_piDialog->SetFocus(*m_strKey));
				m_piEngine->Message(imtError, *piRec);
//				ListView_SetItemText(m_pWnd, iRow, 0, achTemp);
//				pldvi->item.pszText = achTemp;
//				AssertNonZero(ListView_EditLabel(m_pWnd, iRow));
			}
			else
			{
				m_strPhantomName = pldvi->item.pszText;
				m_strPhantomPath = piPath->GetPath();

				ListView_SetItemText(m_pWnd, iRow, 0, pldvi->item.pszText); 
				Ensure(Redraw());
				LV_FINDINFO Findinfo;
				Findinfo.flags = LVFI_STRING;
				Findinfo.psz = pldvi->item.pszText;
				int iIndex = ListView_FindItem(m_pWnd, -1, &Findinfo);
				AssertNonZero(ListView_EnsureVisible(m_pWnd, iIndex, fFalse));
				//  changing the property without redisplaying the view
				Ensure(SilentlySetPropertyValue(*piPath));
				ListView_SetItemState(m_pWnd, iIndex, LVIS_SELECTED | LVIS_FOCUSED,
											 LVIS_SELECTED | LVIS_FOCUSED);
			}
			return (PostErrorDlgKey(Imsg(idbgWinMes), 0)); 
			break; 
		}
	}
	return 0;
}

IMsiRecord* CMsiDirectoryList::Select(int iSelected)
{
	if (m_fPreview)
		return 0;
	PMsiPath piPath(0);
	//  I check the path first
	IMsiRecord* pRecord = CreatePath(m_strBody, *&piPath);
	if ( !pRecord && iSelected >= 0 )
	{
		//  I add the new piece
		ICHAR achTemp[MAX_PATH];
		ListView_GetItemText(m_pWnd, iSelected, 0, achTemp, MAX_PATH);
		MsiString strTemp = achTemp;
		pRecord = piPath->AppendPiece(*strTemp);
	}
	if ( !pRecord )
		pRecord = CMsiControl::CheckPath(*piPath);
	if ( pRecord )
		//  the path is bad.  I return the error.
		return pRecord;
	Ensure(SilentlySetPropertyValue(*piPath));
	return 0;
}

IMsiRecord* CMsiDirectoryList::StepDown(int iSelected)
{
	if ( m_fPreview || iSelected < 0 )
		return 0;
	PMsiRecord piRecord = &m_piServices->CreateRecord(1);
	ICHAR achTemp[MAX_PATH];
	ListView_GetItemText(m_pWnd, iSelected, 0, achTemp, MAX_PATH);
	PMsiPath piPath(0);
	AssertRecord(CreatePath(m_strBody, *&piPath));
	MsiString strTemp = achTemp;
	Ensure(piPath->AppendPiece(*strTemp));
	AssertNonZero(piRecord->SetMsiString(1, *MsiString(piPath->GetPath())));
	Ensure(AttributeEx(fTrue, cabPropertyValue, *piRecord));
	return 0;
}

IMsiRecord* CMsiDirectoryList::Bisect()
{
	if (m_fPreview)
		return 0;
	PMsiPath piPath(0);
	Ensure(CreatePath(MsiString(GetPropertyValue ()), *&piPath));
	m_strBody = piPath->GetPath();
	return 0;
}

IMsiRecord* CMsiDirectoryList::KeyDown(WPARAM wParam, LPARAM /*lParam*/)
{
	switch (wParam)
	{
		case VK_BACK:
		{
			MsiString strDummyArg;
			Ensure(HandleEvent(*MsiString(*pcaControlEventDirectoryListUp), *strDummyArg));
			break;
		}
		case VK_F2:
		{
			int iFocused = ListView_GetNextItem(m_pWnd, -1, LVNI_FOCUSED);
			if ( iFocused != -1 )
				ListView_EditLabel(m_pWnd, iFocused);
			break;
		}
		case VK_TAB:
		{
			//  DLGC_WANTALLKEYS returned by GetDlgCode eats the TABs =>
			//  I have to do the tabbing myself
			if ( WIN::GetKeyState(VK_CONTROL) >= 0 )    // ignore CTRL-TAB
				WIN::SetFocus(WIN::GetNextDlgTabItem(m_pWndDialog,
																 GetFocus(),
																 (WIN::GetKeyState(VK_SHIFT) < 0)));
		}
	}
	return 0;
}

IMsiRecord* CMsiDirectoryList::GetDlgCode(WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	return (PostErrorDlgKey(Imsg(idbgWinMes), DLGC_WANTALLKEYS));
}


///////////////////////////////////////////////////////////////////////////
// CMsiPathEdit definition
///////////////////////////////////////////////////////////////////////////

class CMsiPathEdit:public CMsiEdit
{
public:

	CMsiPathEdit(IMsiEvent& riDialog);
	IMsiRecord*       __stdcall WindowCreate(IMsiRecord& riRecord);
	IMsiRecord*       __stdcall GetPropertyFromDatabase();

protected:

	virtual ~CMsiPathEdit();
	virtual IMsiRecord*    ValidateProperty (const IMsiString &text);
	virtual IMsiRecord*    PropertyChanged ();
	void                   SetWindowText(const IMsiString &text, bool fForceIt = false);
	static int             s_iPathLimit;      // The maximum number of characters in a path


private:
	IMsiRecord*       KillFocus(WPARAM wParam, LPARAM lParam);
	IMsiRecord*       Bisect();
	MsiString         m_strTail;
	MsiString         m_strGoodTail;
	bool              m_fValidationInProcess;
};

///////////////////////////////////////////////////////////////////////////
// CMsiPathEdit implementation
///////////////////////////////////////////////////////////////////////////

int CMsiPathEdit::s_iPathLimit = 240;  //  please see TracyF or EugenD before
													//  modifying this value!!!

CMsiPathEdit::CMsiPathEdit(IMsiEvent& riDialog)	: CMsiEdit(riDialog)
{
}


CMsiPathEdit::~CMsiPathEdit()
{
}

IMsiRecord* CMsiPathEdit::WindowCreate(IMsiRecord& riRecord)
{
	m_fValidationInProcess = false;
	m_fNoMultiLine = m_fNoPassword = true;
	Ensure(CMsiEdit::WindowCreate(riRecord));
	if ( m_iLimit > s_iPathLimit )
	{
		//  we do not allow the user a path longer than MAX_PATH.
		m_iLimit = s_iPathLimit;
		WIN::SendMessage(m_pWnd, EM_LIMITTEXT, m_iLimit, 0);
	}
	if (m_fPreview)
		return 0;
	if (IsIntegerOnly ())
	{
		return PostErrorDlgKey(Imsg(idbgNoInteger));
	}
	Ensure(Bisect());
	SetWindowText(*m_strTail, true);

	return 0;
}

IMsiRecord* CMsiPathEdit::Bisect()
{
	if (m_fPreview)
		return 0;
	PMsiPath piPath(0);
	AssertRecord(CreatePath(MsiString(GetPropertyValue ()), *&piPath));
	m_strTail = piPath->GetPath();
	m_strGoodTail = m_strTail;
	return 0;
}

IMsiRecord* CMsiPathEdit::KillFocus(WPARAM wParam, LPARAM lParam)
{
	bool fJustReturn = false;
	MsiString strWindowText;

	if ( !wParam ||
		  (WIN::GetWindowThreadProcessId(m_pWnd, NULL) !=
		   WIN::GetWindowThreadProcessId((HWND)wParam, NULL)) )   /* bug # 5879 */
		//  the focus moved to a window in another thread.  There is no point in
		//  validating in this case.
		fJustReturn = true;
	else
	{
		strWindowText = GetWindowText();
		if ( !strWindowText.CharacterCount() )	
			//  empty strings are valid, but I do not update the database property.
			//  Obviously, there is little point in validating an empty path.
			fJustReturn = true;
	}
	if ( fJustReturn )	
	{
		Ensure(LockDialog(fFalse));
		return CMsiActiveControl::KillFocus(wParam, lParam);
	}

	// Bug 7042 - if the Enter key is used to kill focus on our PathEdit control,
	// and we detect a bad path below, our call to m_piEngine->Message below to
	// display an error can result in another KillFocus call to the PathEdit
	// control - the m_fValidationInProcess flag allows us to avoid a crashing
	// recursive message call.
	if (m_fValidationInProcess)
		return PostErrorDlgKey(Imsg(idbgWinMes), 0);

	m_strTail = strWindowText;
	PMsiPath piPath(0);
	PMsiRecord pRec(0);
	m_piHandler->ShowWaitCursor();
	if ((pRec = CreatePath(m_strTail, *&piPath)) != 0)
	{
		if (pRec->GetInteger(1) == idbgUserCancelled)
		{
			SetWindowText(*m_strGoodTail, true);
			m_strTail = m_strGoodTail;
			Ensure(LockDialog(fTrue));
			//  I don't want to enter the control's default window procedure
			m_piHandler->RemoveWaitCursor();
			return PostErrorDlgKey(Imsg(idbgWinMes), 0);
		}
		else
			strWindowText = m_strTail;
	}
	else
		strWindowText = MsiString(piPath->GetPath());

	if ( !pRec )
	{
		//  SetPropertyValue validates the property as well
		pRec = SetPropertyValue(*strWindowText, fTrue);
	}
	m_piHandler->RemoveWaitCursor();
	if (pRec)
	{
		m_fValidationInProcess = true;
		Ensure(LockDialog(fTrue));
		m_piEngine->Message(imtError, *pRec);
		m_fValidationInProcess = false;
		m_strTail = m_strGoodTail;
		SetWindowText (*m_strGoodTail, true);
		//  I don't want to enter the control's default window procedure
		return PostErrorDlgKey(Imsg(idbgWinMes), 0);
	}
	else
	{
		Ensure(LockDialog(fFalse));
		return CMsiActiveControl::KillFocus(wParam, lParam);
	}
}

IMsiRecord* CMsiPathEdit::ValidateProperty (const IMsiString &text)
{
	return CMsiControl::CheckPath(text);
}

IMsiRecord* CMsiPathEdit::PropertyChanged ()
{
	if (m_fPreview)
		return 0;
	Ensure(Bisect());
	Ensure(CMsiActiveControl::PropertyChanged ());
	SetWindowText(*m_strGoodTail);
	return 0;
}

IMsiRecord* CMsiPathEdit::GetPropertyFromDatabase()
{
	if (m_fPreview)
		return 0;
	Ensure(CMsiEdit::GetPropertyFromDatabase());
	Ensure(Bisect());
	SetWindowText(*m_strTail);
	return 0;
}

void CMsiPathEdit::SetWindowText (const IMsiString &text, bool fForceIt)
{
	//  If not forced, I change the text only if it hasn't been modified
	//  or if the focus is not in the current window.
	if ( fForceIt || GetFocus() != m_pWnd || !HasBeenChanged() )
		CMsiEdit::SetWindowText(text);
}



IMsiControl* CreateMsiPathEdit(IMsiEvent& riDialog)
{
	return new CMsiPathEdit(riDialog);
}

/////////////////////////////////////////////
// CMsiVolumeSelectCombo  definition
/////////////////////////////////////////////

class CMsiVolumeSelectCombo:public CMsiActiveControl
{
public:
	CMsiVolumeSelectCombo(IMsiEvent& riDialog);
	virtual ~CMsiVolumeSelectCombo();
	virtual IMsiRecord*       __stdcall WindowCreate(IMsiRecord& riRecord);

protected:
	virtual IMsiRecord*        PropertyChanged ();

private:
	IMsiRecord*                Redraw();
	IMsiRecord*                DrawItem(WPARAM wParam, LPARAM lParam);
	IMsiRecord*                Command(WPARAM wParam, LPARAM lParam);
	IMsiRecord*                NCDestroy(WPARAM wParam, LPARAM lParam);
	PMsiTable                  m_piValuesTable;
};

enum VolumeSelectComboColumns
{
	itabVSCPath = 1,      //S
	itabVSCText,          //S
	itabVSCImage,         //I
};

/////////////////////////////////////////////////
// CMsiVolumeSelectCombo  implementation
/////////////////////////////////////////////////

CMsiVolumeSelectCombo::CMsiVolumeSelectCombo(IMsiEvent& riDialog) : CMsiActiveControl(riDialog), m_piValuesTable(0)
{
}

CMsiVolumeSelectCombo::~CMsiVolumeSelectCombo()
{
}

IMsiRecord* CMsiVolumeSelectCombo::WindowCreate(IMsiRecord& riRecord)
{
	Ensure(CMsiActiveControl::WindowCreate(riRecord));
	if (IsIntegerOnly ())
	{
		return PostErrorDlgKey(Imsg(idbgNoInteger));
	}
	Ensure(CreateControlWindow(TEXT("COMBOBOX"), CBS_DROPDOWNLIST|CBS_OWNERDRAWFIXED|CBS_HASSTRINGS|WS_VSCROLL|CBS_SORT|WS_TABSTOP, (m_fRTLRO ? WS_EX_RTLREADING : 0) | (m_fRightAligned ? WS_EX_RIGHT : 0) | (m_fLeftScroll ? WS_EX_LEFTSCROLLBAR : 0), *m_strText, m_pWndDialog, m_iKey));
	AssertNonZero(WIN::SendMessage(m_pWnd, CB_SETITEMHEIGHT, 0,
					  GetOwnerDrawnComboListHeight()) != CB_ERR);
	ULONG_PTR dwIndex;		//--merced: changed DWORD to ULONG_PTR
	Ensure(WindowFinalize());
	Assert(!m_piValuesTable);
	Ensure(CreateTable(pcaTableIVolumeSelectCombo, *&m_piValuesTable));
	::CreateTemporaryColumn(*m_piValuesTable, icdString + icdPrimaryKey, itabVSCPath);
	::CreateTemporaryColumn(*m_piValuesTable, icdString + icdNullable, itabVSCText);
	::CreateTemporaryColumn(*m_piValuesTable, icdLong + icdNullable, itabVSCImage);
	PMsiCursor piValuesCursor(0);
	Ensure(::CursorCreate(*m_piValuesTable, pcaTableIVolumeSelectCombo, fFalse, *m_piServices, *&piValuesCursor)); 
	int iAttributes = riRecord.GetInteger(itabCOAttributes);
	PMsiTable piVolumesTable(0);
	Ensure(GetVolumeList(iAttributes, *&piVolumesTable));
	PMsiCursor piVolumesCursor(0);
	Ensure(::CursorCreate(*piVolumesTable, pcaTableIVolumeList, fFalse, *m_piServices, *&piVolumesCursor)); 
	PMsiPath piPath(0);
	MsiString strNull;
	while (piVolumesCursor->Next())
	{
		PMsiVolume piVolume = (IMsiVolume *) piVolumesCursor->GetMsiData(1);
		if ( ShouldHideVolume(piVolume->VolumeID()) )
			continue;
		piValuesCursor->Reset();
		AssertRecord(CreatePath(MsiString(piVolume->GetPath()), *&piPath));  // temp???
		MsiString strPath = piPath->GetPath();
		MsiString strUpper = strPath;
		strUpper.UpperCase();
		AssertNonZero(piValuesCursor->PutString(itabDCPath, *strUpper));
		AssertNonZero(piValuesCursor->PutString(itabDCParent, *strNull));
		MsiString strText = (piVolume->DriveType() ==  idtRemote ? strNull : MsiString(MsiChar(TEXT(' ')))) + strPath; 	// we put a space infront of every volume except the remote ones to force the right ordering			
		AssertNonZero(piValuesCursor->PutString(itabVSCPath, *strPath));
		AssertNonZero(piValuesCursor->PutString(itabVSCText, *strText));
		AssertNonZero(piValuesCursor->PutInteger(itabVSCImage, ::GetVolumeIconIndex(*piVolume)));
		dwIndex = WIN::SendMessage(m_pWnd, CB_ADDSTRING, 0, (LONG_PTR) (LPSTR) (const ICHAR*) strText);			//--merced: changed long to LONG_PTR
		AssertNonZero(piValuesCursor->Insert());
	}
	Ensure(Redraw());
	return 0;
}

IMsiRecord* CMsiVolumeSelectCombo::Redraw()
{
	if (m_fPreview)
		return 0;
	PMsiCursor piValuesCursor(0);
	Ensure(::CursorCreate(*m_piValuesTable, pcaTableIVolumeSelectCombo, fFalse, *m_piServices, *&piValuesCursor)); 
  	piValuesCursor->SetFilter(iColumnBit(itabVSCPath));
  	piValuesCursor->Reset();
  	piValuesCursor->PutString(itabVSCPath, *MsiString(GetPropertyValue ()));
  	if (piValuesCursor->Next())
	{
		WIN::SendMessage(m_pWnd, CB_SETCURSEL, WIN::SendMessage(m_pWnd, CB_FINDSTRING, (WPARAM)-1, (LPARAM)(const ICHAR*) MsiString(piValuesCursor->GetString(itabVSCText))), 0);
	}
	else
	{
		WIN::SendMessage(m_pWnd, CB_SETCURSEL, (WPARAM)-1, 0);
	}
	return 0;
}

IMsiControl* CreateMsiVolumeSelectCombo(IMsiEvent& riDialog)
{
	return new CMsiVolumeSelectCombo(riDialog);
}

IMsiRecord*  CMsiVolumeSelectCombo::PropertyChanged ()
{
	if (m_fPreview)
		return 0;
	Ensure (CMsiActiveControl::PropertyChanged ());
	Ensure (Redraw ());

	return (0);
}

IMsiRecord* CMsiVolumeSelectCombo::Command(WPARAM wParam, LPARAM /*lParam*/)
{
	if (HIWORD(wParam) == CBN_SELENDOK)
	{
		MsiString valueStr;

		INT_PTR iIndex = WIN::SendMessage(m_pWnd, CB_GETCURSEL, 0, 0L);		//--merced: changed int to INT_PTR
		if (iIndex == CB_ERR)
		{
			MsiString strNull;
			valueStr = strNull;
		}
		else
		{
			ICHAR achTemp[MAX_PATH];
			WIN::SendMessage(m_pWnd, CB_GETLBTEXT, iIndex, (LPARAM) (LPCSTR) achTemp);
			PMsiCursor piValuesCursor(0);
			Ensure(::CursorCreate(*m_piValuesTable, pcaTableIVolumeSelectCombo, fFalse, *m_piServices, *&piValuesCursor)); 
  			piValuesCursor->SetFilter(iColumnBit(itabVSCText));
  			piValuesCursor->Reset();
			MsiString strTemp = achTemp;
  			AssertNonZero(piValuesCursor->PutString(itabVSCText, *strTemp));
  			AssertNonZero(piValuesCursor->Next());
  			valueStr = piValuesCursor->GetString(itabVSCPath);
		}
		PMsiRecord(SetPropertyValue (*valueStr, fTrue));

		return PostErrorDlgKey(Imsg(idbgWinMes), 0);
	}
	return 0;
}

IMsiRecord* CMsiVolumeSelectCombo::DrawItem(WPARAM /*wParam*/, LPARAM lParam)
{

	Ensure(CheckInitialized());

	LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT) lParam;
	INT_PTR count = WIN::SendMessage(m_pWnd, CB_GETCOUNT, 0, 0);		//--merced: changed int to INT_PTR
	if (lpdis->itemID == -1)
		return 0;
	int iPath = lpdis->itemID;
	PMsiCursor piValuesCursorTree(0);
	Ensure(::CursorCreate(*m_piValuesTable, pcaTableIDirectoryCombo, fTrue, *m_piServices, *&piValuesCursorTree)); 
	piValuesCursorTree->SetFilter(iColumnBit(itabVSCText));
	ICHAR achTemp[MAX_PATH];
	WIN::SendMessage(m_pWnd, CB_GETLBTEXT, lpdis->itemID, (LPARAM) (LPCSTR) achTemp);
	AssertNonZero(piValuesCursorTree->PutString(itabVSCText, *MsiString(achTemp)));
	int iLevel;
	AssertNonZero(iLevel = piValuesCursorTree->Next());
	int iIndex = piValuesCursorTree->GetInteger(itabVSCImage);
	COLORREF clrForeground = WIN::SetTextColor(lpdis->hDC, WIN::GetSysColor(lpdis->itemState & ODS_SELECTED ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT));
	Assert(clrForeground != CLR_INVALID);
	COLORREF clrBackground = WIN::SetBkColor(lpdis->hDC, WIN::GetSysColor(lpdis->itemState & ODS_SELECTED ? COLOR_HIGHLIGHT : COLOR_WINDOW));
	Assert(clrBackground != CLR_INVALID);
	TEXTMETRIC tm;
	AssertNonZero(GetTextMetrics(lpdis->hDC, &tm));
	int y = (lpdis->rcItem.bottom + lpdis->rcItem.top - tm.tmHeight) / 2;
	int x = LOWORD(WIN::GetDialogBaseUnits()) / 4;
	MsiString strText = piValuesCursorTree->GetString(itabVSCPath);
	SIZE size;
	WIN::GetTextExtentPoint32(lpdis->hDC, (const ICHAR*)strText,
									  strText.TextSize(), &size);
	RECT rect;
	AssertNonZero(WIN::SetRect(&rect, 28, y, 28 + size.cx, y + tm.tmHeight));
	WIN::ExtTextOut(lpdis->hDC, 28, y, ETO_CLIPPED | ETO_OPAQUE,
						 g_fChicago ? &rect : &lpdis->rcItem, (const ICHAR*)strText,
						 strText.TextSize(), 0);
	AssertNonZero(CLR_INVALID != WIN::SetTextColor(lpdis->hDC, clrForeground));
	AssertNonZero(CLR_INVALID != WIN::SetBkColor(lpdis->hDC, clrBackground));
	y = (lpdis->rcItem.bottom + lpdis->rcItem.top - 16) / 2;
	AssertNonZero(ImageList_DrawEx(g_hVolumeSmallIconList, iIndex, lpdis->hDC, 4, y, 16, 16, CLR_NONE, CLR_NONE, ILD_TRANSPARENT));
	return PostErrorDlgKey(Imsg(idbgWinMes), 1);
}

// the following method is only needed to work around a bug in NT4.0 build 1314
// this bug causes an ownerdraw combobox with non-zero items to receive messages after
// WM_NCDESTROY. To avoid this problem we make sure that there are no items in the combobox
// when the NT4 bug is fixed, this function can be removed
IMsiRecord* CMsiVolumeSelectCombo::NCDestroy(WPARAM, LPARAM)
{
	AssertSz(!m_iRefCnt, "Trying to remove a control, but somebody still holds a reference to it");
	WIN::SendMessage(m_pWnd, CB_RESETCONTENT, 0, 0);
	IMsiRecord* riReturn = PostErrorDlgKey(Imsg(idbgWinMes), 0);
	delete this;
	return riReturn;
}

/////////////////////////////////////////////
// CMsiScrollableText  definition
/////////////////////////////////////////////

class CMsiScrollableText:public CMsiControl
{
public:
	CMsiScrollableText(IMsiEvent& riDialog);
	IMsiRecord*				  __stdcall WindowCreate(IMsiRecord& riRecord);
	virtual IMsiRecord*    ProcessText();
	virtual Bool           __stdcall CanTakeFocus() { return ToBool(m_fEnabled && m_fVisible); }
	virtual unsigned long  __stdcall Release();
	
protected:
	virtual IMsiRecord*    KillFocus(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*    SetFocus(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*    ChangeFontStyle(HDC hdc);

private:
	IMsiRecord*            GetDlgCode(WPARAM wParam, LPARAM lParam);
	static DWORD CALLBACK  EditStreamCallback(ULONG_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG FAR *pcb); 
	int             		  m_iPosition;
	HIMC                   m_hIMC;
};


/////////////////////////////////////////////////
// CMsiScrollableText  implementation
/////////////////////////////////////////////////


CMsiScrollableText::CMsiScrollableText(IMsiEvent& riDialog)	: CMsiControl(riDialog)
{
}

unsigned long CMsiScrollableText::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	if (m_pWnd)
		DestroyWindow(m_pWnd);
	else
		delete this;
	
	return 0;
}

IMsiRecord* CMsiScrollableText::WindowCreate(IMsiRecord& riRecord)
{
	m_fTransparent = ToBool(riRecord.GetInteger(itabCOAttributes) & msidbControlAttributesTransparent);
	Ensure(CMsiControl::WindowCreate(riRecord));
	MsiString strNull;
#ifdef FINAL
	Ensure(LoadRichEdit());
	Ensure(CreateControlWindow(TEXT("RichEdit20W"),
		ES_MULTILINE | WS_VSCROLL | ES_READONLY | WS_TABSTOP |
			ES_AUTOVSCROLL | ES_NOOLEDRAGDROP,
		(m_fRTLRO ? WS_EX_RTLREADING : 0) | (m_fLeftScroll ? WS_EX_LEFTSCROLLBAR : 0) |
			(m_fRightAligned ? WS_EX_RIGHT : 0),
		*strNull, m_pWndDialog, m_iKey));
#else
	if (PMsiRecord(LoadRichEdit()))
	{
		Ensure(CreateControlWindow(TEXT("STATIC"), 0, 0, *MsiString(*TEXT("We can't create this control without riched20.dll.")), m_pWndDialog, m_iKey));
	}
	else
	{
		Ensure(CreateControlWindow(TEXT("RichEdit20W"),
			ES_MULTILINE | WS_VSCROLL | ES_READONLY | WS_TABSTOP |
				ES_AUTOVSCROLL | ES_NOOLEDRAGDROP,
			(m_fRTLRO ? WS_EX_RTLREADING : 0) | (m_fLeftScroll ? WS_EX_LEFTSCROLLBAR : 0) |
				(m_fRightAligned ? WS_EX_RIGHT : 0),
			*strNull, m_pWndDialog, m_iKey));
	}
#endif
	m_iPosition = 0;
	m_hIMC = NULL;
	EDITSTREAM eStream;
	eStream.dwCookie = (INT_PTR) this;		
	eStream.pfnCallback = CMsiScrollableText::EditStreamCallback;
	eStream.dwError = 0;
	if ( m_strText.TextSize()+1 > WIN::SendMessage(m_pWnd, EM_GETLIMITTEXT, 0, 0L) )
		WIN::SendMessage(m_pWnd, EM_EXLIMITTEXT, 0, (LPARAM)(m_strText.TextSize()+1));
	WIN::SendMessage(m_pWnd, EM_STREAMIN, SF_RTF, (LPARAM)&eStream);  // use bytes even for Unicode, until SF_RTF | ST_UNICODE supported
	Ensure(WindowFinalize());
	return 0;
}

DWORD CALLBACK CMsiScrollableText::EditStreamCallback(ULONG_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG FAR* pcb)
{
	CMsiScrollableText* piControl = (CMsiScrollableText *) dwCookie;
	int iSize = piControl->m_strText.TextSize();  // bytes if ANSI, shorts if Unicode
	if (piControl->m_iPosition >= iSize)
		return 1;
	const ICHAR *pch = (const ICHAR *)(piControl->m_strText) + piControl->m_iPosition;
#ifdef UNICODE //!! RichEd currently doesn't support SF_RTF | ST_UNICODE, so we convert to ASCII and escape Unicode
	unsigned char* pb = pbBuff;
	unsigned char* pbEnd = pbBuff + cb;
	unsigned int ch;
	while (pb < pbEnd)
	{
		if ((ch = *pch++) <= 0x7f)  // ASCII character, no problem
			*pb++ = (unsigned char)ch;
		else if ((pbEnd - pb) < 9)  // needed room for escape sequence below, up to 5 digits and the terminating NULL.
			break;  // not enough room for escape, wait for next call
		else
		{
			StringCchPrintfA((char*)pb, (pbEnd-pb), "\\u%i?", ch);
			size_t i;
			StringCchLengthA((char*)pb, (pbEnd-pb), &i);
			pb += i;
		}
		if (++piControl->m_iPosition >= iSize)
			break;
	}
	*pcb = (LONG)(pb - pbBuff);
#else
	if (iSize - piControl->m_iPosition < cb)
		cb = iSize - piControl->m_iPosition;
	::memcpy(pbBuff, (const char *)pch, cb);
	piControl->m_iPosition += cb;
	*pcb = cb;
#endif
	return (DWORD) 0;
}

IMsiRecord* CMsiScrollableText::GetDlgCode(WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	return (PostErrorDlgKey(Imsg(idbgWinMes), DLGC_WANTARROWS));
}

IMsiRecord* CMsiScrollableText::ProcessText()
{
	// We don't want to process any of the text
	// this control is an exception, we don't want to do the usual text processing.	
	m_strText = m_strRawText; 
	return 0;

}

IMsiRecord* CMsiScrollableText::ChangeFontStyle(HDC /*hdc*/)
{
	//  Darwin shouldn't change the font of the rich text.
	return 0;
}

IMsiRecord* CMsiScrollableText::SetFocus(WPARAM wParam, LPARAM lParam)
{
	//  I disable IME
	m_hIMC = WIN::ImmAssociateContext(m_pWnd, NULL);
	return CMsiControl::SetFocus(wParam, lParam);
}

IMsiRecord* CMsiScrollableText::KillFocus(WPARAM wParam, LPARAM lParam)
{
	if ( m_hIMC )
		//  I enable IME
		WIN::ImmAssociateContext(m_pWnd, m_hIMC);
	return CMsiControl::KillFocus (wParam, lParam);
}

IMsiControl* CreateMsiScrollableText(IMsiEvent& riDialog)
{
	return new CMsiScrollableText(riDialog);
}

/////////////////////////////////////////////
// CMsiVolumeCostList  definition
/////////////////////////////////////////////

const int g_cVolumeCostListColumns = 5;

class CMsiVolumeCostList:public CMsiControl
{
public:
	CMsiVolumeCostList(IMsiEvent& riDialog);
	virtual ~CMsiVolumeCostList();
	virtual IMsiRecord*       __stdcall WindowCreate(IMsiRecord& riRecord);
	virtual Bool              __stdcall CanTakeFocus() { return ToBool(m_fEnabled && m_fVisible); }

private:
	IMsiRecord*           PopulateList(int iAttributes);
	IMsiRecord*           CreateEmptyVolumeCostTable();
	IMsiRecord*           CreateValuesTable();
	void                  GetVolumeCostColumns();
	IMsiRecord*           AddVolume(IMsiVolume& riVolume, int iRequired, int iIndex);
	void                  InsertColumn(int fmt, int cx, const ICHAR * szName, int iIndex);
	static INT_PTR CALLBACK   CompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);		//--merced: changed int to INT_PTR
	IMsiRecord*           Notify(WPARAM wParam, LPARAM lParam);
	IMsiSelectionManager* m_piSelectionManager;
	PMsiTable             m_piVolumeCostTable; 
	PMsiTable             m_piValuesTable;
	int					  m_colVolumeObject;
	int                   m_colVolumeCost;
	int                   m_colNoRbVolumeCost;
	int                   m_iClicked;
	int                   m_rgiColmWidths[g_cVolumeCostListColumns];
};

enum VolumeCostColumns
{
	itabVCKey = 1,      //O
	itabVCText,         //S
	itabVCSizeI,        //S (uint64 that IMsiCursor does not know how to handle yet)
	itabVCSizeS,        //S
	itabVCAvailableI,   //S (uint64 that IMsiCursor does not know how to handle yet)
	itabVCAvailableS,   //S
	itabVCRequiredI,    //I
	itabVCRequiredS,    //S
	itabVCDifferenceI,  //S (int64 that IMsiCursor does not know how to handle yet)
	itabVCDifferenceS,  //S
	itabVCRecord,       //I
};


/////////////////////////////////////////////
// CMsiVolumeCostList  implementation
/////////////////////////////////////////////

IMsiControl* CreateMsiVolumeCostList(IMsiEvent& riDialog)
{
	return new CMsiVolumeCostList(riDialog);
}

CMsiVolumeCostList::CMsiVolumeCostList(IMsiEvent& riDialog)	: CMsiControl(riDialog), m_piVolumeCostTable(0), m_piValuesTable(0)
{
	m_colVolumeObject = 0;
	m_colVolumeCost = 0;
	m_iClicked = 0;
	m_piSelectionManager = 0;
	memset(&m_rgiColmWidths, 0, g_cVolumeCostListColumns * sizeof(int));
}

CMsiVolumeCostList::~CMsiVolumeCostList()
{
	// temp, we have to release the records in the table.
	// when records become MsiData, this will be done automaticaly
	if (m_piValuesTable)
	{
		PMsiCursor piValuesCursor(0);
		PMsiRecord(::CursorCreate(*m_piValuesTable, pcaTableIVolumeCost, fFalse, *m_piServices, *&piValuesCursor));
		while (piValuesCursor->Next())
		{
			IMsiRecord* piRecord = (IMsiRecord *)GetHandleData(piValuesCursor, itabVCRecord);
			piRecord->Release();
		}
	}
}

IMsiRecord* CMsiVolumeCostList::WindowCreate(IMsiRecord& riRecord)
{
	int iAttributes = riRecord.GetInteger(itabCOAttributes);
	Ensure(CMsiControl::WindowCreate(riRecord));

	//  setting the column widths
	int iOffset=0, iColm=0;
	if ( m_strText.CharacterCount() &&
		  ((const ICHAR *)m_strText)[0] == TEXT('{') )
	{
		// m_strText may contain column width specifications
		CTempBuffer<ICHAR, MAX_PATH> rgchText;
		if ( m_strText.TextSize()+1 > rgchText.GetSize() )
			rgchText.Resize(m_strText.TextSize()+1);
		StringCchCopy(rgchText, rgchText.GetSize(), m_strText);
		ICHAR* pSep;
 		while ( iColm < g_cVolumeCostListColumns  &&
				  rgchText[iOffset] == TEXT('{')  &&
				  (pSep = IStrChr((const ICHAR *)&rgchText[iOffset], TEXT('}'))) != NULL )
		{
//			Assert((pSep - &rgchText[iOffset] + 1) <= INT_MAX);		//--merced: 64-bit ptr subtraction may theoretically lead to values too big for iWidth.
			int iWidth = (int)(pSep - &rgchText[iOffset] + 1);
			if ( iWidth == 2 )
			{
				//  zero length column specification - "{}"
				m_rgiColmWidths[iColm++] = 0;
				iOffset += 2;
				continue;
			}
			*pSep = 0;
			int iColmWidth = ::GetIntegerValue(&rgchText[iOffset+1], 0);
			if ( iColmWidth == iMsiStringBadInteger ||
				  iColmWidth < 0 )
				break;
			else
			{
				m_rgiColmWidths[iColm++] = 
					iColmWidth * m_piHandler->GetTextHeight() / iDlgUnitSize;
				iOffset += iWidth;
			}
		}
	}
	if ( iColm )
		//  the column widths have beens specified
		m_strText.Remove(iseFirst, iOffset);
	else
	{
		//  setting default column widths
		m_rgiColmWidths[0] = m_iWidth*3/8;
		m_rgiColmWidths[1] = m_rgiColmWidths[2] = 
		m_rgiColmWidths[3] = m_rgiColmWidths[4] = m_iWidth/8;
	}
	Ensure(CreateControlWindow(WC_LISTVIEW, LVS_REPORT |  WS_VSCROLL | WS_HSCROLL | LVS_SHAREIMAGELISTS | LVS_AUTOARRANGE | WS_BORDER | WS_TABSTOP, (m_fRTLRO ? WS_EX_RTLREADING : 0) | (m_fRightAligned ? WS_EX_RIGHT : 0) | (m_fLeftScroll ? WS_EX_LEFTSCROLLBAR : 0), *m_strText, m_pWndDialog, m_iKey));
	ListView_SetImageList(m_pWnd, g_hVolumeSmallIconList, LVSIL_SMALL);
	const GUID IID_IMsiSelectionManager = GUID_IID_IMsiSelectionManager;
	PMsiSelectionManager pSelectionManager(*m_piEngine, IID_IMsiSelectionManager);
	m_piSelectionManager = pSelectionManager;
	m_piVolumeCostTable = m_piSelectionManager->GetVolumeCostTable();
	if (!m_piVolumeCostTable)
		Ensure(CreateEmptyVolumeCostTable());
	GetVolumeCostColumns();
	Ensure(CreateValuesTable());
	Ensure(PopulateList(iAttributes));
	Ensure(WindowFinalize());
	return 0;
}

IMsiRecord* CMsiVolumeCostList::CreateValuesTable()
{
	Ensure(CreateTable(pcaTablePVolumeCost, *&m_piValuesTable));
	::CreateTemporaryColumn(*m_piValuesTable, icdObject + icdPrimaryKey, itabVCKey);
	::CreateTemporaryColumn(*m_piValuesTable, icdString + icdNullable, itabVCText);
	// uint64 that IMsiCursor does not know how to handle yet
	::CreateTemporaryColumn(*m_piValuesTable, icdString + icdNullable, itabVCSizeI);
	::CreateTemporaryColumn(*m_piValuesTable, icdString + icdNullable, itabVCSizeS);
	// uint64 that IMsiCursor does not know how to handle yet
	::CreateTemporaryColumn(*m_piValuesTable, icdString + icdNullable, itabVCAvailableI);
	::CreateTemporaryColumn(*m_piValuesTable, icdString + icdNullable, itabVCAvailableS);
	::CreateTemporaryColumn(*m_piValuesTable, icdLong + icdNullable, itabVCRequiredI);
	::CreateTemporaryColumn(*m_piValuesTable, icdString + icdNullable, itabVCRequiredS);
	// int64 that IMsiCursor does not know how to handle yet
	::CreateTemporaryColumn(*m_piValuesTable, icdString + icdNullable, itabVCDifferenceI);
	::CreateTemporaryColumn(*m_piValuesTable, icdString + icdNullable, itabVCDifferenceS);
	::CreateTemporaryColumn(*m_piValuesTable, IcdObjectPool() + icdNullable, itabVCRecord);
	return 0;
}

void CMsiVolumeCostList::InsertColumn(int fmt, int cx, const ICHAR * szName, int iIndex)
{
	LV_COLUMN lvC;
	lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvC.fmt = fmt;
	lvC.cx = cx;
	lvC.pszText = (ICHAR *)(const ICHAR *) MsiString(::GetUIText(*MsiString(szName)));
	lvC.cchTextMax = IStrLen(lvC.pszText);
	lvC.iSubItem = iIndex;
	AssertNonZero(iIndex == ListView_InsertColumn(m_pWnd, iIndex, &lvC));
}


IMsiRecord* CMsiVolumeCostList::AddVolume(IMsiVolume& riVolume, int iRequired, int iIndex)
{
	PMsiCursor piValuesCursor(0);
	Ensure(::CursorCreate(*m_piValuesTable, pcaTableIVolumeCost, fFalse, *m_piServices, *&piValuesCursor));
	AssertNonZero(piValuesCursor->PutMsiData(itabVCKey, &riVolume));
	AssertNonZero(piValuesCursor->PutString(itabVCText, *MsiString(riVolume.GetPath())));
	UINT64 iSize = riVolume.TotalSpace(); 
	//!! FUTURE: IMsiCursor->PutInteger64 and GetInteger64 are needed
	ICHAR rgchBuffer[24]; // _UI64_MAX = 18,446,744,073,709,551,615
	AssertNonZero(piValuesCursor->PutString(itabVCSizeI,
														 *MsiString(_ui64tot(iSize, rgchBuffer, 10)))); 
	Bool fLeftUnit = ToBool(MsiString(GetDBProperty(IPROPNAME_LEFTUNIT)).TextSize());
	AssertNonZero(piValuesCursor->PutString(itabVCSizeS, *MsiString(::FormatSize(iSize, fLeftUnit))));
	UINT64 iAvailable = riVolume.FreeSpace();
	AssertNonZero(piValuesCursor->PutString(itabVCAvailableI,
														 *MsiString(_ui64tot(iAvailable, rgchBuffer, 10)))); 
	AssertNonZero(piValuesCursor->PutString(itabVCAvailableS, *MsiString(::FormatSize(iAvailable, fLeftUnit))));
	AssertNonZero(piValuesCursor->PutInteger(itabVCRequiredI, iRequired)); 
	AssertNonZero(piValuesCursor->PutString(itabVCRequiredS, *MsiString(::FormatSize(iRequired, fLeftUnit))));
	INT64 iDifference = iAvailable - iRequired;
	AssertNonZero(piValuesCursor->PutString(itabVCDifferenceI,
														 *MsiString(_i64tot(iDifference, rgchBuffer, 10))));
	AssertNonZero(piValuesCursor->PutString(itabVCDifferenceS, *MsiString(::FormatSize(iDifference, fLeftUnit))));
	PMsiRecord piRecord = &m_piServices->CreateRecord(2);

	AssertNonZero(piRecord->SetHandle(1, &riVolume));
	AssertNonZero(piRecord->SetHandle(2, this));
	AssertNonZero(PutHandleData(piValuesCursor, itabVCRecord, (UINT_PTR)(IMsiRecord *)piRecord));

	piRecord->AddRef(); // temp, because we put it in the table
	AssertNonZero(piValuesCursor->Insert());
	iIndex;
	LV_ITEM lvI;
	lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
	lvI.state = 0;
	lvI.stateMask = 0;
	lvI.iItem = iIndex;
	lvI.iSubItem = 0;
	lvI.lParam = (LPARAM) (IMsiRecord *) piRecord;
	lvI.iImage = ::GetVolumeIconIndex(riVolume);
	lvI.pszText = (ICHAR *)(const ICHAR *) MsiString(piValuesCursor->GetString(itabVCText));
	lvI.cchTextMax = IStrLen(lvI.pszText);
	AssertZero(ListView_InsertItem(m_pWnd, &lvI) == -1);
	ListView_SetItemText(m_pWnd, iIndex, 1, (ICHAR *)(const ICHAR *) MsiString(piValuesCursor->GetString(itabVCSizeS)));
	ListView_SetItemText(m_pWnd, iIndex, 2, (ICHAR *)(const ICHAR *) MsiString(piValuesCursor->GetString(itabVCAvailableS)));
	ListView_SetItemText(m_pWnd, iIndex, 3, (ICHAR *)(const ICHAR *) MsiString(piValuesCursor->GetString(itabVCRequiredS)));
	ListView_SetItemText(m_pWnd, iIndex, 4, (ICHAR *)(const ICHAR *) MsiString(piValuesCursor->GetString(itabVCDifferenceS)));
	if (iDifference < 0)
		ListView_SetItemState(m_pWnd, iIndex, LVIS_DROPHILITED, LVIS_DROPHILITED);
	return 0;
}

IMsiRecord* CMsiVolumeCostList::PopulateList(int iAttributes)
{
	if (m_fPreview)
		return 0;
	InsertColumn(LVCFMT_LEFT, m_rgiColmWidths[0], pcaVolumeCostVolume, 0);
	InsertColumn(LVCFMT_RIGHT, m_rgiColmWidths[1], pcaVolumeCostSize, 1);
	InsertColumn(LVCFMT_RIGHT, m_rgiColmWidths[2], pcaVolumeCostAvailable, 2);
	InsertColumn(LVCFMT_RIGHT, m_rgiColmWidths[3], pcaVolumeCostRequired, 3);
	InsertColumn(LVCFMT_RIGHT, m_rgiColmWidths[4], pcaVolumeCostDifference, 4);
	int iIndex = 0;
	PMsiCursor piVolumeCostCursor(0);
	Ensure(::CursorCreate(*m_piVolumeCostTable, pcaTablePVolumeCost, fFalse, *m_piServices, *&piVolumeCostCursor));
	PMsiVolume piVolume(0);
	int iColVolumeCost = 0;
	MsiString strRollbackPrompt = m_piEngine->GetPropertyFromSz(IPROPNAME_PROMPTROLLBACKCOST);
	if ( strRollbackPrompt.Compare(iscExactI,IPROPVALUE_RBCOST_SILENT) )
		iColVolumeCost = m_colNoRbVolumeCost;
	else if ( !strRollbackPrompt.TextSize() ||
				 strRollbackPrompt.Compare(iscExactI,IPROPVALUE_RBCOST_FAIL) )
		iColVolumeCost = m_colVolumeCost;
	else if ( strRollbackPrompt.Compare(iscExactI,IPROPVALUE_RBCOST_PROMPT) )
		iColVolumeCost = iAttributes & msidbControlShowRollbackCost ?
							  m_colVolumeCost : m_colNoRbVolumeCost;
	else
	{
		//  this is quite impossible
		iColVolumeCost = m_colVolumeCost;
#ifdef DEBUG
		ICHAR rgchDebug[MAX_PATH];
		StringCchPrintf(rgchDebug, sizeof(rgchDebug)/sizeof(ICHAR), 
					TEXT("'%s' is an unexpected value for PROMPTROLLBACKCOST property."),
					(const ICHAR*)strRollbackPrompt);
		AssertSz(0, rgchDebug);
#endif
	}
	while (piVolumeCostCursor->Next())
	{
		piVolume = (IMsiVolume *) piVolumeCostCursor->GetMsiData(m_colVolumeObject);
		if ( ShouldHideVolume(piVolume->VolumeID()) )
			continue;
		Ensure(AddVolume(*piVolume, piVolumeCostCursor->GetInteger(iColVolumeCost), iIndex));
		iIndex++;
	}
	PMsiTable piVolumesTable(0);
	Ensure(GetVolumeList(iAttributes, *&piVolumesTable));
	PMsiCursor piVolumesCursor(0);
	Ensure(::CursorCreate(*piVolumesTable, pcaTableIVolumeList, fFalse, *m_piServices, *&piVolumesCursor));
	PMsiCursor piValuesCursor(0);
	Ensure(::CursorCreate(*m_piValuesTable, pcaTableIVolumeCost, fFalse, *m_piServices, *&piValuesCursor));
	piValuesCursor->SetFilter(iColumnBit(itabVCText));
	while (piVolumesCursor->Next())
	{
		piVolume = (IMsiVolume *) piVolumesCursor->GetMsiData(1);
		MsiString strText = piVolume->GetPath();
		piValuesCursor->Reset();
		AssertNonZero(piValuesCursor->PutString(itabVCText, *strText));
		if (piValuesCursor->Next()) // this volume is already in the table
			continue;
		Ensure(AddVolume(*piVolume, 0, iIndex));
		iIndex++;
	}
 	ListView_SortItems(m_pWnd, CMsiVolumeCostList::CompareProc, 1);
	ListView_SetItemState(m_pWnd, 0, LVIS_FOCUSED, LVIS_FOCUSED);
	m_iClicked = 1;
	return 0;
}

#ifndef DEBUG
inline
#endif // DEBUG
int CompareStringSizesUI64(const IMsiString& riSizeString1, const IMsiString& riSizeString2)
{
	UINT64 uiSize1 = _tcstoui64(riSizeString1.GetString(), NULL, 10);
	UINT64 uiSize2 = _tcstoui64(riSizeString2.GetString(), NULL, 10);
	return uiSize1 == uiSize2 ? 0 : (uiSize1 > uiSize2 ? 1 : -1);
}

#ifndef DEBUG
inline
#endif // DEBUG
int CompareStringSizesI64(const IMsiString& riSizeString1, const IMsiString& riSizeString2)
{
	INT64 iSize1 = _ttoi64(riSizeString1.GetString());
	INT64 iSize2 = _ttoi64(riSizeString2.GetString());
	return iSize1 == iSize2 ? 0 : (iSize1 > iSize2 ? 1 : -1);
}

INT_PTR CALLBACK CMsiVolumeCostList::CompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)		//--merced: changed return from int to INT_PTR
{
	IMsiRecord* piRecord1 = (IMsiRecord *) lParam1;
	IMsiRecord* piRecord2 = (IMsiRecord *) lParam2;
	Assert(piRecord1->GetHandle(2) == piRecord2->GetHandle(2)); // the two records point to the same object
	CMsiVolumeCostList * piControl = (CMsiVolumeCostList *) piRecord1->GetHandle(2);
	PMsiCursor piValuesCursor1(0);
	AssertRecord(::CursorCreate(*piControl->m_piValuesTable, pcaTableIVolumeCost, fFalse, *piControl->m_piServices, *&piValuesCursor1));
	PMsiCursor piValuesCursor2(0);
	AssertRecord(::CursorCreate(*piControl->m_piValuesTable, pcaTableIVolumeCost, fFalse, *piControl->m_piServices, *&piValuesCursor2));
	piValuesCursor1->SetFilter(iColumnBit(itabVCKey));
	piValuesCursor2->SetFilter(iColumnBit(itabVCKey));
	AssertNonZero(piValuesCursor1->PutMsiData(itabVCKey, (IMsiVolume *)piRecord1->GetHandle(1)));
	AssertNonZero(piValuesCursor2->PutMsiData(itabVCKey, (IMsiVolume *)piRecord2->GetHandle(1)));
	AssertNonZero(piValuesCursor1->Next());
	AssertNonZero(piValuesCursor2->Next());
	int iResult = 0;
	int iReverse = 0;
	if (lParamSort > 0)
	{
		iReverse = 1;
	}
	else
	{
		iReverse = -1;
		lParamSort *= -1;
	}
	switch (lParamSort)
	{
	case 1: // name
		{
			IMsiVolume * piVolume1 = (IMsiVolume *) piRecord1->GetHandle(1);
			IMsiVolume * piVolume2 = (IMsiVolume *) piRecord2->GetHandle(1);
			idtEnum iType1 = piVolume1->DriveType();
			idtEnum iType2 = piVolume2->DriveType();
			if (iType1 == idtRemote && iType2 != idtRemote)
				iResult = 1;
			else if (iType1 != idtRemote && iType2 == idtRemote)
				iResult = -1;
			else 
			{
				MsiString str1 = piValuesCursor1->GetString(itabVCText);
				MsiString str2 = piValuesCursor2->GetString(itabVCText);
				iResult = IStrCompI((const ICHAR *) str1, (const ICHAR *) str2);
			}
		}
		break;
	case 2: // disk size
		iResult = CompareStringSizesUI64(piValuesCursor1->GetString(itabVCSizeI),
													piValuesCursor2->GetString(itabVCSizeI));
		break;
	case 3: // available
		iResult = CompareStringSizesUI64(piValuesCursor1->GetString(itabVCAvailableI),
													piValuesCursor2->GetString(itabVCAvailableI));
		break;
	case 4: // required
		iResult = piValuesCursor1->GetInteger(itabVCRequiredI) - piValuesCursor2->GetInteger(itabVCRequiredI);
		break;
	case 5: // required
		iResult = CompareStringSizesI64(piValuesCursor1->GetString(itabVCDifferenceI),
												  piValuesCursor2->GetString(itabVCDifferenceI));
		break;
	default:
		Assert(fFalse); // should never happen
		break;
	}
	return iResult * iReverse;
}

IMsiRecord* CMsiVolumeCostList::CreateEmptyVolumeCostTable()
{
	Ensure(CreateTable(pcaTablePVolumeCost, *&m_piVolumeCostTable));
	MsiString strNull;
	AssertNonZero(m_piVolumeCostTable->CreateColumn(icdLong + icdPrimaryKey + icdTemporary, *MsiString(*szColVolumeObject)));
	AssertNonZero(m_piVolumeCostTable->CreateColumn(icdLong + icdNullable + icdTemporary, *MsiString(*szColVolumeCost)));
	AssertNonZero(m_piVolumeCostTable->CreateColumn(icdLong + icdNullable + icdTemporary, *MsiString(*szColNoRbVolumeCost)));
	return 0;
}

void CMsiVolumeCostList::GetVolumeCostColumns()
{
	AssertNonZero(m_colVolumeObject = m_piVolumeCostTable->GetColumnIndex(m_piDatabase->EncodeStringSz(szColVolumeObject)));
	AssertNonZero(m_colVolumeCost = m_piVolumeCostTable->GetColumnIndex(m_piDatabase->EncodeStringSz(szColVolumeCost)));
	AssertNonZero(m_colNoRbVolumeCost = m_piVolumeCostTable->GetColumnIndex(m_piDatabase->EncodeStringSz(szColNoRbVolumeCost)));
}

IMsiRecord* CMsiVolumeCostList::Notify(WPARAM /*wParam*/, LPARAM lParam)
{
	LV_DISPINFO *pLvdi = (LV_DISPINFO *) lParam;
	NM_LISTVIEW *pNm = (NM_LISTVIEW *) lParam;
	IMsiVolume* piVolume = (IMsiVolume *) pLvdi->item.lParam; // no AddRef, since we do not keep the volume
	switch (pLvdi->hdr.code)
	{
	case LVN_COLUMNCLICK:
		{
			// the user clicked one of the column headings, we want to sort by this column
			int iColumn = 1 + pNm->iSubItem;
			if (pNm->iSubItem + 1 == m_iClicked)
			{
				iColumn *= -1;
				m_iClicked = 0;
			}
			else
			{
				m_iClicked = pNm->iSubItem + 1;
			}
			ListView_SortItems(m_pWnd, CMsiVolumeCostList::CompareProc, (LPARAM) iColumn);
			return (PostErrorDlgKey(Imsg(idbgWinMes), 0));
			break;
		}
	case LVN_ITEMCHANGING:
		{
			if (pNm->uNewState & LVIS_SELECTED)
			{
				if (pNm->uNewState & LVIS_FOCUSED && pNm->iItem != -1)
					ListView_SetItemState(m_pWnd, pNm->iItem, LVIS_FOCUSED, LVIS_FOCUSED);
				return (PostErrorDlgKey(Imsg(idbgWinMes), 1));
			}
			break;
		}
	default:
		break;
	}
	return 0;
}



/////////////////////////////////////////////
// CMsiSelectionTree  definition
/////////////////////////////////////////////

class CMsiSelectionTree:public CMsiActiveControl
{
public:
	CMsiSelectionTree(IMsiEvent& riDialog);
	virtual ~CMsiSelectionTree();
	virtual IMsiRecord*           __stdcall WindowCreate(IMsiRecord& riRecord);
	virtual IMsiRecord*           __stdcall HandleEvent(const IMsiString& riEventNameString, const IMsiString& riArgumentString);
	virtual IMsiRecord*           __stdcall GetPropertyFromDatabase();
	virtual IMsiRecord*           __stdcall Undo();
	virtual IMsiRecord*           __stdcall RefreshProperty();

protected:
	IMsiRecord*           LButtonDown(WPARAM wParam, LPARAM lParam);
	IMsiRecord*           Command(WPARAM wParam, LPARAM lParam);
	IMsiRecord*           MeasureItem(WPARAM wParam, LPARAM lParam);
	IMsiRecord*           DrawItem(WPARAM wParam, LPARAM lParam);
//	IMsiRecord*           MeasureItem(WPARAM wParam, LPARAM lParam);
//	IMsiRecord*           DrawItem(WPARAM wParam, LPARAM lParam);
	IMsiRecord*           KeyDown(WPARAM wParam, LPARAM lParam);
	IMsiRecord*           SysKeyDown(WPARAM wParam, LPARAM lParam);
	IMsiRecord*           Char(WPARAM wParam, LPARAM lParam);
	IMsiRecord*           Notify(WPARAM wParam, LPARAM lParam);
	IMsiRecord*           KillFocus(WPARAM wParam, LPARAM lParam);

private:
	void                  GetFeatureColumns();
	IMsiRecord*           RegisterEvents();
	void                  UnregisterEvents();
	IMsiRecord*           PopulateTree();
	IMsiRecord*           CreateMenuTable();
	IMsiRecord*           IsAbsent(const IMsiString& riKeyString, Bool* fAbsent);
	IMsiRecord*           CreateEmptyFeatureTable();
	void                  FindIcons(int iInstalled, int iAction, bool fIsGray, int* piIcon, Bool* pfChange);
	IMsiRecord*           PopulateMenu(HMENU hMenu, HTREEITEM hItem);
	IMsiRecord*           RedrawChildren(HTREEITEM hItem);
	IMsiRecord*           OpenMenu(HTREEITEM hItem);
	IMsiRecord*           DoMenu(void);
	const IMsiString&     FindText(int iIcon, const IMsiString& riBaseText);
	HIMAGELIST            m_hImageList;
	unsigned int          m_uiLastCloseTime;
	IMsiSelectionManager* m_piSelectionManager;
	IMsiDirectoryManager* m_piDirectoryManager;
	PMsiTable             m_piFeatureTable; 
	PMsiTable             m_piMenuTable;
	int                   m_colFeatureKey;
	int                   m_colFeatureParent;
	int                   m_colFeatureDesc;
	int                   m_colFeatureDisplay;
	int                   m_colFeatureLevel;
	int                   m_colFeatureAction;
	int                   m_colFeatureInstalled;
	int                   m_colFeatureHandle;
	Bool                  m_fUninitialized;
	Bool                  m_fCD;
	Bool                  m_fInstalled;
	Bool                  m_fScreenReader;
	Bool                  m_fWorking;
	HTREEITEM             m_hOpenedMenu;
};

enum MenuColumns
{
	itabSMKey = 1,      //I
	itabSMText,         //S
	itabSMIcon,         //I
	itabSMSelection,    //I
};



/////////////////////////////////////////////////
// CMsiSelectionTree  implementation
/////////////////////////////////////////////////


CMsiSelectionTree::CMsiSelectionTree(IMsiEvent& riDialog)	: CMsiActiveControl(riDialog), m_piFeatureTable(0), m_piMenuTable(0)
{
	m_colFeatureKey = 0;
	m_colFeatureParent = 0;
	m_colFeatureDesc = 0;
	m_colFeatureDisplay = 0;
	m_colFeatureLevel = 0;
	m_colFeatureAction = 0;
	m_colFeatureInstalled = 0;
	m_colFeatureHandle = 0;
	m_fUninitialized = fFalse;
	m_fCD = fTrue;
	m_fInstalled = fFalse;
	m_fScreenReader = fFalse;
	m_fWorking = fFalse;
	m_hImageList = 0;
	m_uiLastCloseTime = 0;
	m_piSelectionManager = 0;
	m_piDirectoryManager = 0;
	m_hOpenedMenu = 0;
}

CMsiSelectionTree::~CMsiSelectionTree()
{
	UnregisterEvents();
	if (m_hImageList)
		AssertNonZero(m_piHandler->DestroyHandle((HANDLE)m_hImageList) != -1);
}

const int iGrayIconOffset  = 5;
const int iArrowIconOffset = 8;

IMsiRecord* CMsiSelectionTree::WindowCreate(IMsiRecord& riRecord)
{
	int iAttributes = riRecord.GetInteger(itabCOAttributes);
	Ensure(CMsiActiveControl::WindowCreate(riRecord));
	Ensure(RegisterEvents());
	if (!WIN::SystemParametersInfo(SPI_GETSCREENREADER, 0, &m_fScreenReader, 0))
		m_fScreenReader = fFalse;
	Ensure(CreateControlWindow(WC_TREEVIEW, WS_BORDER | TVS_HASLINES | TVS_HASBUTTONS | TVS_LINESATROOT | TVS_DISABLEDRAGDROP | TVS_SHOWSELALWAYS | WS_TABSTOP, (m_fRTLRO ? WS_EX_RTLREADING : 0) | (m_fRightAligned ? WS_EX_RIGHT : 0) | (m_fLeftScroll ? WS_EX_LEFTSCROLLBAR : 0), *m_strText, m_pWndDialog, m_iKey));
	m_hImageList = ImageList_Create(g_iSelIconX, g_iSelIconY, ILC_MASK, 12, 20);
	int rgiIconIDs[] = {101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 200};
	for ( int i = 0; i < sizeof rgiIconIDs/sizeof rgiIconIDs[0]; i++ )
	{
		HICON hTemp = (HICON)WIN::LoadImage(g_hInstance, MAKEINTRESOURCE(rgiIconIDs[i]), IMAGE_ICON, g_iSelIconX, g_iSelIconY, LR_DEFAULTCOLOR);
		Assert(hTemp);
		if (hTemp)
		{
			AssertNonZero(WIN::ImageList_AddIcon(m_hImageList, hTemp) != -1);
			AssertNonZero(WIN::DestroyIcon(hTemp));
		}
	}
	ImageList_SetOverlayImage(m_hImageList, 18, 1);
	TreeView_SetImageList(m_pWnd, m_hImageList, TVSIL_NORMAL);
	AssertNonZero(m_piHandler->RecordHandle(CWINHND((HANDLE)m_hImageList, iwhtImageList)) != -1);

	Ensure(WindowFinalize());
	if (m_fPreview)
		return 0;
	const GUID IID_IMsiSelectionManager = GUID_IID_IMsiSelectionManager;
	const GUID IID_IMsiDirectoryManager = GUID_IID_IMsiDirectoryManager;
	PMsiSelectionManager pSelectionManager(*m_piEngine, IID_IMsiSelectionManager);
	PMsiDirectoryManager pDirectoryManager(*m_piEngine, IID_IMsiDirectoryManager);
	m_piSelectionManager = pSelectionManager;
	m_piDirectoryManager = pDirectoryManager;
	m_piFeatureTable = m_piSelectionManager->GetFeatureTable();
	if (!m_piFeatureTable)
	{
		Ensure(CreateEmptyFeatureTable());
	}
	if (m_piFeatureTable->GetRowCount() == 0)
		m_fUninitialized = fTrue;
	GetFeatureColumns();
	PMsiPath piPath(0);
	
	MsiString strMediaSource = GetDBProperty(IPROPNAME_MEDIASOURCEDIR);
	m_fCD = ToBool(strMediaSource.TextSize());

	MsiString strInstalled = GetDBProperty(TEXT("Installed"));
	m_fInstalled = ToBool(strInstalled.TextSize());
	Ensure(PopulateTree());
	Ensure(CreateMenuTable());
	return 0;
}

IMsiRecord* CMsiSelectionTree::Undo()
{
	if (m_fPreview)
		return 0;
	Ensure(CMsiControl::Undo());
	Ensure(m_piSelectionManager->SetInstallLevel(0));
	Ensure(PopulateTree());
	return 0;
}

IMsiRecord* CMsiSelectionTree::CreateMenuTable()
{
	Ensure(CreateTable(pcaTableISelMenu, *&m_piMenuTable));
	::CreateTemporaryColumn(*m_piMenuTable, icdLong + icdPrimaryKey, itabSMKey);
	::CreateTemporaryColumn(*m_piMenuTable, icdString + icdNullable, itabSMText);
	::CreateTemporaryColumn(*m_piMenuTable, icdLong + icdNullable, itabSMIcon);
	::CreateTemporaryColumn(*m_piMenuTable, icdLong + icdNullable, itabSMSelection);
	return 0;
}

IMsiRecord* CMsiSelectionTree::CreateEmptyFeatureTable()
{
	Ensure(CreateTable(pcaTablePFeature, *&m_piFeatureTable));
	MsiString strNull;
	AssertNonZero(m_piFeatureTable->CreateColumn(icdString + icdPrimaryKey + icdTemporary, *MsiString(*szFeatureKey)));
	AssertNonZero(m_piFeatureTable->CreateColumn(icdString + icdNullable + icdTemporary, *MsiString(*szFeatureParent)));
	AssertNonZero(m_piFeatureTable->CreateColumn(icdString + icdNullable + icdTemporary, *MsiString(*szFeatureTitle)));
	AssertNonZero(m_piFeatureTable->CreateColumn(icdString + icdNullable + icdTemporary, *MsiString(*szFeatureDescription)));
	AssertNonZero(m_piFeatureTable->CreateColumn(icdLong + icdNullable + icdTemporary, *MsiString(*szFeatureDisplay)));	  
	AssertNonZero(m_piFeatureTable->CreateColumn(icdLong + icdNullable + icdTemporary, *MsiString(*szFeatureLevel)));
	AssertNonZero(m_piFeatureTable->CreateColumn(icdString + icdNullable + icdTemporary, *MsiString(*szFeatureDirectory)));
	AssertNonZero(m_piFeatureTable->CreateColumn(icdLong + icdNullable + icdTemporary, *MsiString(*szFeatureAttributes)));
	AssertNonZero(m_piFeatureTable->CreateColumn(icdLong + icdNullable + icdTemporary, *MsiString(*szFeatureSelect)));
	AssertNonZero(m_piFeatureTable->CreateColumn(icdLong + icdNullable + icdTemporary, *MsiString(*szFeatureAction)));
	AssertNonZero(m_piFeatureTable->CreateColumn(icdLong + icdNullable + icdTemporary, *MsiString(*szFeatureInstalled)));
	AssertNonZero(m_piFeatureTable->CreateColumn(IcdObjectPool() + icdNullable + icdTemporary, *MsiString(*szFeatureHandle)));
	m_piFeatureTable->LinkTree(2);
	return 0;
}

IMsiRecord* CMsiSelectionTree::PopulateTree()
{
	if (m_fPreview)
		return 0;
	PMsiCursor piFeatureCursor(0);
	Ensure(::CursorCreate(*m_piFeatureTable, pcaTablePFeature, fTrue, *m_piServices, *&piFeatureCursor)); 
	PMsiCursor piFeatureCursorParent(0);
	Ensure(::CursorCreate(*m_piFeatureTable, pcaTablePFeature, fFalse, *m_piServices, *&piFeatureCursorParent)); 
	AssertNonZero(TreeView_DeleteAllItems(m_pWnd));
	while (piFeatureCursorParent->Next())		 // wipe the Handle column
	{
		AssertNonZero(m_piSelectionManager->SetFeatureHandle(*MsiString(piFeatureCursorParent->GetString(m_colFeatureKey)), 0));
		if (piFeatureCursorParent->GetInteger(m_colFeatureKey) == piFeatureCursorParent->GetInteger(m_colFeatureParent))
			return PostError(Imsg(idbgSelSelfParent), *MsiString(piFeatureCursorParent->GetString(m_colFeatureKey)));
	}
	piFeatureCursorParent->Reset();
	piFeatureCursorParent->SetFilter(iColumnBit(m_colFeatureKey));

	PMsiView piFeatureView(0);
	Ensure(m_piDatabase->OpenView(sqlFeature, ivcFetch, *&piFeatureView));
	PMsiRecord piQuery = &m_piServices->CreateRecord(1);
	MsiString strParent;
	PMsiRecord piRecordNew(0);
	int iDisplay;
	int iLevel;
	int iIcon;
	Bool fChange;
	HTREEITEM hInsertAfter;
	HTREEITEM hFirstItem = 0;
	HTREEITEM hParent;
	TV_ITEM tvI;
	TV_INSERTSTRUCT tvIns;
	int iTreeLevel;
	int iHideLevel = 0;
	while ((iTreeLevel = piFeatureCursor->Next()) > 0)
	{
		if (iHideLevel > 0)
		{
			if (iTreeLevel > iHideLevel)
				continue;
			else
				iHideLevel = 0;
		}

#ifdef DEBUG
		MsiString strFeature = piFeatureCursor->GetString(m_colFeatureKey);
		const ICHAR* szFeature = strFeature;
#endif
		iDisplay = piFeatureCursor->GetInteger(m_colFeatureDisplay);
		if (iDisplay == 0 || iDisplay == iMsiNullInteger)  // if display is 0 or empty, do not show
		{
			iHideLevel = iTreeLevel;
			continue;
		}
		iLevel = piFeatureCursor->GetInteger(m_colFeatureLevel);
		if (iLevel <= 0 || iLevel == iMsiNullInteger)	   // level must be positive 
			continue;
		if (piFeatureCursor->GetInteger(m_colFeatureHandle) != 0)	   // this item is already in the list
			continue;
		strParent = piFeatureCursor->GetString(m_colFeatureParent);
		AssertNonZero(piQuery->SetMsiString(1, *strParent));
		Ensure(piFeatureView->Execute(piQuery));
		if (strParent.TextSize() && !strParent.Compare(iscExact, MsiString(piFeatureCursor->GetString(m_colFeatureKey))))
		{
			piFeatureCursorParent->Reset();
			AssertNonZero(piFeatureCursorParent->PutString(m_colFeatureKey, *strParent));
			AssertNonZero(piFeatureCursorParent->Next());
			hParent = (HTREEITEM) GetHandleData(piFeatureCursorParent, m_colFeatureHandle);   // get the parent's handle
		}
		else
		{
			hParent = (HTREEITEM) TVI_ROOT;
		}
		hInsertAfter = (HTREEITEM) TVI_FIRST;
		while (piRecordNew = piFeatureView->Fetch())
		{
			Assert(0 == GetHandleDataRecord(piRecordNew, itabFEHandle));
			iDisplay = piRecordNew->GetInteger(itabFEDisplay);
			if (piRecordNew->IsNull(itabFEDisplay) || (iDisplay  == 0))
				continue;
			if (piRecordNew->IsNull(itabFELevel) || piRecordNew->GetInteger(itabFELevel) <= 0)
				continue;
			tvI.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;

			bool fIsGray;
			IMsiRecord* piError = m_piSelectionManager->CheckFeatureTreeGrayState(*MsiString(piRecordNew->GetMsiString(itabFEFeature)), fIsGray);
			if (piError)
				return piError;

			FindIcons(piRecordNew->GetInteger(itabFEInstalled), piRecordNew->GetInteger(itabFEAction), fIsGray, &iIcon, &fChange);
			tvI.iImage =  iIcon + iArrowIconOffset;
			tvI.iSelectedImage = tvI.iImage;
			MsiString strText;
			if (m_fScreenReader)
			{
				strText = FindText(iIcon + iArrowIconOffset, *MsiString(piRecordNew->GetString(itabFETitle)));
			}
			else
			{
				strText = piRecordNew->GetString(itabFETitle);
			}
			tvI.pszText = (ICHAR *)(const ICHAR *) strText;
			tvI.cchTextMax = IStrLen (tvI.pszText);
			tvI.lParam = 0;
			tvIns.item =  tvI;
			tvIns.hInsertAfter = hInsertAfter;
			tvIns.hParent = hParent;
			hInsertAfter = (HTREEITEM) TreeView_InsertItem(m_pWnd, &tvIns);
			if (hFirstItem == 0)
				hFirstItem = hInsertAfter;
			AssertNonZero(m_piSelectionManager->SetFeatureHandle(*MsiString(piRecordNew->GetMsiString(itabFEFeature)), (INT_PTR) hInsertAfter));
		}
		Ensure(piFeatureView->Close());
	}
	// expand the visible items whose Display is odd and not absent
	piFeatureCursorParent->SetFilter(0);
	piFeatureCursorParent->Reset();
	//Bool fAbsent;
	while (piFeatureCursorParent->Next())
	{
		//Ensure(IsAbsent(MsiString(piFeatureCursorParent->GetString(m_colFeatureKey)), &fAbsent));
		if (GetHandleData(piFeatureCursorParent, m_colFeatureHandle) && piFeatureCursorParent->GetInteger(m_colFeatureDisplay) % 2)
		{
			TreeView_Expand(m_pWnd, (HTREEITEM) GetHandleData(piFeatureCursorParent, m_colFeatureHandle), TVE_EXPAND);

		}
		// if absent hide the + sign
		/*
		if (fAbsent)
		{
			HTREEITEM hItemToClose = (HTREEITEM) piFeatureCursorParent->GetInteger(m_colFeatureHandle);
			TV_ITEM tvItem;
			tvItem.hItem = hItemToClose;
			tvItem.mask = TVIF_STATE;
			tvItem.stateMask = TVIS_EXPANDED;
			AssertNonZero(TreeView_GetItem(m_pWnd, &tvItem));
			int iParam = tvItem.state & TVIS_EXPANDED;
			TreeView_Expand(m_pWnd, hItemToClose, TVE_COLLAPSE);
			tvItem.hItem = hItemToClose;
			tvItem.mask = TVIF_CHILDREN | TVIF_PARAM;
			tvItem.lParam = iParam ? 1 : 0;
			tvItem.cChildren = 0;
			AssertNonZero(-1 != TreeView_SetItem(m_pWnd, &tvItem));
		}*/
	}
	AssertNonZero(TreeView_SelectItem(m_pWnd, 0));
	AssertNonZero(TreeView_SelectItem(m_pWnd, hFirstItem));
	return 0;
}

void CMsiSelectionTree::FindIcons(int iInstalled, int iAction, bool fIsGray, int* piIcon, Bool* pfChange)
{
	if (iAction == iisReinstall)
		iAction = iInstalled;
	switch (iAction)
	{
	case iMsiNullInteger:
		// no change
		*pfChange = fFalse;
		switch (iInstalled)
		{
		case iisAbsent:
		case iMsiNullInteger:
			*piIcon = 0; // delete
			break;
		case iisLocal:
			*piIcon = 1; // drive
			break;
		case iisSource:
			*piIcon = m_fCD ? 2 : 3; // cd or server
			break;
		case iisAdvertise:
			*piIcon = 4;
			break;
		default:
			Assert(fFalse); // should never happen
			break;
		}
		break;
	case iisAbsent:
		*piIcon = 0; // delete
		*pfChange = ToBool(iInstalled != iisAbsent && iInstalled != iMsiNullInteger);
		break;
	case iisLocal:
		*piIcon = 1; // drive
		*pfChange = ToBool(iInstalled != iisLocal);
		break;
	case iisSource:
		*piIcon = m_fCD ? 2 : 3; // cd or server
		*pfChange = ToBool(iInstalled != iisSource);
		break;
	case iisAdvertise:
		*piIcon = 4; // advertise
		*pfChange = ToBool(iInstalled != iisAdvertise);
		break;
	default:
		Assert(fFalse);	 // should never happen
		break;
	}

	if (fIsGray)
	{
		*piIcon = *piIcon + iGrayIconOffset;
	}
}

const IMsiString& CMsiSelectionTree::FindText(int iIcon, const IMsiString& riBaseText)
{
	MsiString strDescription;
	switch (iIcon)
	{
	case 0+iArrowIconOffset:
		strDescription = MsiString(::GetUIText(*MsiString(*pcaMenuAbsent)));
		break;
	case 1+iArrowIconOffset:
		strDescription = MsiString(::GetUIText(*MsiString(*pcaMenuAllLocal)));
		break;
	case 2+iArrowIconOffset:
		strDescription = MsiString(::GetUIText(*MsiString(*pcaMenuAllCD)));
		break;
	case 3+iArrowIconOffset:
		strDescription = MsiString(::GetUIText(*MsiString(*pcaMenuAllNetwork)));
		break;
	case 4+iArrowIconOffset:
		strDescription = MsiString(::GetUIText(*MsiString(*pcaMenuAdvertise)));
		break;
	case 5+iArrowIconOffset:
		strDescription = MsiString(::GetUIText(*MsiString(*pcaMenuAbsent)));
		break;
	case 6+iArrowIconOffset:
		strDescription = MsiString(::GetUIText(*MsiString(*pcaMenuLocal)));
		break;
	case 7+iArrowIconOffset:
		strDescription = MsiString(::GetUIText(*MsiString(*pcaMenuCD)));
		break;
	case 8+iArrowIconOffset:
		strDescription = MsiString(::GetUIText(*MsiString(*pcaMenuNetwork)));
		break;
	case 9+iArrowIconOffset:
		strDescription = MsiString(::GetUIText(*MsiString(*pcaMenuAdvertise)));
		break;
	default:
		Assert(fFalse); // should never happen
		break;
	}
	if (m_fRTLRO)
	{
		strDescription += MsiString(*TEXT(" - "));
		strDescription += riBaseText;
	}
	else
	{
		riBaseText.AddRef();
		MsiString strTemp = riBaseText;
		strTemp += MsiString(*TEXT(" - "));
		strTemp += strDescription;
		strDescription = strTemp;
	}
	return strDescription.Return();
}

void CMsiSelectionTree::GetFeatureColumns()
{
	AssertNonZero(0!=(m_colFeatureKey      = m_piFeatureTable->GetColumnIndex(m_piDatabase->EncodeStringSz(szFeatureKey))));
	AssertNonZero(0!=(m_colFeatureParent   = m_piFeatureTable->GetColumnIndex(m_piDatabase->EncodeStringSz(szFeatureParent))));
	AssertNonZero(0!=(m_colFeatureDesc     = m_piFeatureTable->GetColumnIndex(m_piDatabase->EncodeStringSz(szFeatureDescription))));
	AssertNonZero(0!=(m_colFeatureDisplay  = m_piFeatureTable->GetColumnIndex(m_piDatabase->EncodeStringSz(szFeatureDisplay))));
	AssertNonZero(0!=(m_colFeatureLevel    = m_piFeatureTable->GetColumnIndex(m_piDatabase->EncodeStringSz(szFeatureLevel))));
	AssertNonZero(0!=(m_colFeatureAction   = m_piFeatureTable->GetColumnIndex(m_piDatabase->EncodeStringSz(szFeatureAction))));
	AssertNonZero(0!=(m_colFeatureInstalled   = m_piFeatureTable->GetColumnIndex(m_piDatabase->EncodeStringSz(szFeatureInstalled))));
	AssertNonZero(0!=(m_colFeatureHandle = m_piFeatureTable->GetColumnIndex(m_piDatabase->EncodeStringSz(szFeatureHandle))));
}

IMsiRecord* CMsiSelectionTree::RegisterEvents()
{
	Ensure(m_piDialog->RegisterControlEvent(*m_strKey, fTrue, pcaControlEventSelectionDescription));
	Ensure(m_piDialog->RegisterControlEvent(*m_strKey, fTrue, pcaControlEventSelectionSize));
	Ensure(m_piDialog->RegisterControlEvent(*m_strKey, fTrue, pcaControlEventSelectionPath));
	Ensure(m_piDialog->RegisterControlEvent(*m_strKey, fTrue, pcaControlEventSelectionPathOn));
	Ensure(m_piDialog->RegisterControlEvent(*m_strKey, fTrue, pcaControlEventSelectionBrowse));
	Ensure(m_piDialog->RegisterControlEvent(*m_strKey, fTrue, pcaControlEventSelectionIcon));
	Ensure(m_piDialog->RegisterControlEvent(*m_strKey, fTrue, pcaControlEventSelectionAction));
	Ensure(m_piDialog->RegisterControlEvent(*m_strKey, fTrue, pcaControlEventSelectionNoItems));
	return 0;
}

void CMsiSelectionTree::UnregisterEvents()
{
	PMsiRecord(m_piDialog->RegisterControlEvent(*m_strKey, fFalse, pcaControlEventSelectionDescription));
	PMsiRecord(m_piDialog->RegisterControlEvent(*m_strKey, fFalse, pcaControlEventSelectionSize));
	PMsiRecord(m_piDialog->RegisterControlEvent(*m_strKey, fFalse, pcaControlEventSelectionPath));
	PMsiRecord(m_piDialog->RegisterControlEvent(*m_strKey, fFalse, pcaControlEventSelectionPathOn));
	PMsiRecord(m_piDialog->RegisterControlEvent(*m_strKey, fFalse, pcaControlEventSelectionBrowse));
	PMsiRecord(m_piDialog->RegisterControlEvent(*m_strKey, fFalse, pcaControlEventSelectionIcon));
	PMsiRecord(m_piDialog->RegisterControlEvent(*m_strKey, fFalse, pcaControlEventSelectionAction));
	PMsiRecord(m_piDialog->RegisterControlEvent(*m_strKey, fFalse, pcaControlEventSelectionNoItems));
}

IMsiRecord* CMsiSelectionTree::Command(WPARAM wParam, LPARAM lParam)
{
	int wNotifyCode = HIWORD(wParam);
	if ( wNotifyCode != 0 || lParam || m_fWorking )
		return 0;
	int iIndex = LOWORD(wParam);
	if (iIndex == 0)
		return 0;
	PMsiCursor piMenuCursor(0);
	Ensure(::CursorCreate(*m_piMenuTable, pcaTableISelMenu, fFalse, *m_piServices, *&piMenuCursor)); 
	PMsiCursor piFeatureCursor(0);
	Ensure(::CursorCreate(*m_piFeatureTable, pcaTablePFeature, fFalse, *m_piServices, *&piFeatureCursor)); 
	piMenuCursor->SetFilter(iColumnBit(itabSMKey));
	AssertNonZero(piMenuCursor->PutInteger(itabSMKey, iIndex));
	AssertNonZero(piMenuCursor->Next());
	int iSel = piMenuCursor->GetInteger(itabSMSelection);

	HTREEITEM hItem = m_hOpenedMenu;
	if ( !hItem )
	{
		Assert(0);
		hItem = TreeView_GetSelection(m_pWnd);
	}
	Assert(hItem);
	piFeatureCursor->SetFilter(iColumnBit(m_colFeatureHandle));
	AssertNonZero(PutHandleData(piFeatureCursor, m_colFeatureHandle, (UINT_PTR)hItem));
	AssertNonZero(piFeatureCursor->Next());
	int iOrig = piFeatureCursor->GetInteger(m_colFeatureInstalled); 
	MsiString strKey = piFeatureCursor->GetString(m_colFeatureKey);
	int iAction = piFeatureCursor->GetInteger(m_colFeatureAction);
	if (iSel !=  iAction)
	{
		m_piHandler->ShowWaitCursor();
		m_fWorking = fTrue;
		AssertRecord(m_piSelectionManager->ConfigureFeature(*strKey, (iisEnum) iSel));
		m_piHandler->RemoveWaitCursor();
		m_fWorking = fFalse;
		Ensure(RedrawChildren(0)); 
		// quick fix, normally we want to redraw the children
		// we redraw the parents only if they were off
		//Ensure(RedrawChildren(hItem));

		// if a parent is absent, do not show the children
		/*
		Bool fAbsent;
		Ensure(IsAbsent(strKey, &fAbsent))
		if (fAbsent)
		{
			TV_ITEM tvItem;
			tvItem.hItem = hItem;
			tvItem.mask = TVIF_STATE;
			tvItem.stateMask = TVIS_EXPANDED;
			AssertNonZero(TreeView_GetItem(m_pWnd, &tvItem));
			int iParam = tvItem.state & TVIS_EXPANDED;
			TreeView_Expand(m_pWnd, hItem, TVE_COLLAPSE);
			tvItem.hItem = hItem;
			tvItem.mask = TVIF_CHILDREN | TVIF_PARAM;
			tvItem.lParam = iParam ? 1 : 0;
			tvItem.cChildren = 0;
			AssertNonZero(-1 != TreeView_SetItem(m_pWnd, &tvItem));
		}*/
	}
	//Bool fAbsent;
	//Ensure(IsAbsent(MsiString(piFeatureCursor->GetString(m_colFeatureKey)), &fAbsent));
	if (iSel != iAction /*&& !fAbsent*/) 
	{
		int cChildren = 0;
		piFeatureCursor->Reset();
		piFeatureCursor->SetFilter(iColumnBit(m_colFeatureParent));
		AssertNonZero(piFeatureCursor->PutString(m_colFeatureParent, *strKey));
		while (piFeatureCursor->Next())
		{
			if (GetHandleData(piFeatureCursor, m_colFeatureHandle))
				cChildren++;
		}
		if (cChildren)
		{
			TV_ITEM tvItem;
			tvItem.hItem = hItem;
			tvItem.mask = TVIF_PARAM;
			AssertNonZero(TreeView_GetItem(m_pWnd, &tvItem));
			LPARAM iParam  = tvItem.lParam;			//--merced: Converted int to LPARAM
			tvItem.mask = TVIF_CHILDREN | TVIF_PARAM;
			tvItem.cChildren = cChildren;
			tvItem.lParam = 0;
			AssertNonZero(-1 != TreeView_SetItem(m_pWnd, &tvItem));
			if (iParam)
				TreeView_Expand(m_pWnd, hItem, TVE_EXPAND);
		}
	}
	AssertNonZero(TreeView_SelectItem(m_pWnd, 0));
	AssertNonZero(TreeView_SelectItem(m_pWnd, hItem));
	return 0;
}

IMsiRecord* CMsiSelectionTree::GetPropertyFromDatabase()    
{
	if (m_fPreview)
		return 0;
	Ensure(CMsiActiveControl::GetPropertyFromDatabase ());
	if (m_fUninitialized)
		return 0;
	HTREEITEM hItem = TreeView_GetSelection(m_pWnd);
	if (hItem)
	{
		AssertNonZero(TreeView_SelectItem(m_pWnd, 0));
		AssertNonZero(TreeView_SelectItem(m_pWnd, hItem));
	}
	return 0;
}

IMsiRecord* CMsiSelectionTree::RefreshProperty()
{
	HTREEITEM hItem = TreeView_GetSelection(m_pWnd);
	AssertNonZero(TreeView_SelectItem(m_pWnd, 0));
	AssertNonZero(TreeView_SelectItem(m_pWnd, hItem));
	Ensure(CMsiActiveControl::RefreshProperty());
	return 0;
}

IMsiRecord* CMsiSelectionTree::IsAbsent(const IMsiString& riKeyString, Bool* fAbsent)
{
	PMsiCursor piFeatureCursor(0);
	Ensure(::CursorCreate(*m_piFeatureTable, pcaTablePFeature, fFalse, *m_piServices, *&piFeatureCursor)); 
	piFeatureCursor->SetFilter(iColumnBit(m_colFeatureKey));
	AssertNonZero(piFeatureCursor->PutString(m_colFeatureKey, riKeyString));
	AssertNonZero(piFeatureCursor->Next());
	int iInstalled = piFeatureCursor->GetInteger(m_colFeatureInstalled);
	int iAction = piFeatureCursor->GetInteger(m_colFeatureAction);
	*fAbsent = ToBool(iAction == iisAbsent || ((iInstalled == iisAbsent || iInstalled == iMsiNullInteger) && iAction == iMsiNullInteger));
	return 0;
}

IMsiRecord* CMsiSelectionTree::RedrawChildren(HTREEITEM hItem)
{
	if (m_fPreview)
		return 0;
	PMsiCursor piFeatureCursor(0);
	Ensure(::CursorCreate(*m_piFeatureTable, pcaTablePFeature, fTrue, *m_piServices, *&piFeatureCursor)); 
	TV_ITEM tvItem;
	int iLevel;
	int iIcon;
	Bool fChange;
	if (hItem)
	{
		piFeatureCursor->SetFilter(iColumnBit(m_colFeatureHandle));
		AssertNonZero(PutHandleData(piFeatureCursor, m_colFeatureHandle, (UINT_PTR)hItem));
		AssertNonZero(iLevel = piFeatureCursor->Next());
	}
	else
	{
		// if hItem == 0 redraw the entire tree
		piFeatureCursor->Next();
		iLevel = 0;
	}
	piFeatureCursor->SetFilter(0);
	do 
	{
		HTREEITEM hItem = (HTREEITEM) GetHandleData(piFeatureCursor, m_colFeatureHandle);
		MsiString strText;
		if (hItem == 0)  // item is not visible
			continue;
		tvItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | (m_fScreenReader ? TVIF_TEXT : 0);
		tvItem.hItem = hItem;
		
		bool fIsGray;
		IMsiRecord* piError = m_piSelectionManager->CheckFeatureTreeGrayState(*MsiString(piFeatureCursor->GetString(m_colFeatureKey)), fIsGray);
		if (piError)
			return piError;

		FindIcons(piFeatureCursor->GetInteger(m_colFeatureInstalled), piFeatureCursor->GetInteger(m_colFeatureAction), fIsGray, &iIcon, &fChange);
		tvItem.iImage =  iIcon + iArrowIconOffset;
		tvItem.iSelectedImage = tvItem.iImage;
		if (m_fScreenReader)
		{
			strText = FindText(iIcon + iArrowIconOffset, *MsiString(piFeatureCursor->GetString(itabFETitle)));
			tvItem.pszText = (ICHAR *)(const ICHAR *) strText;
			tvItem.cchTextMax = IStrLen (tvItem.pszText);
		}
		AssertNonZero(-1 != TreeView_SetItem(m_pWnd, &tvItem));
	} while (iLevel < piFeatureCursor->Next());

	return 0;
}


IMsiRecord* CMsiSelectionTree::LButtonDown(WPARAM wParam, LPARAM lParam)
{
	if (!(wParam & MK_LBUTTON))
		return 0;
	if (WIN::GetTickCount() - m_uiLastCloseTime < 50)
		return 0;
	int xPos = LOWORD(lParam);  // horizontal position of cursor 
	int yPos = HIWORD(lParam);  // vertical position of cursor 
	TV_HITTESTINFO htInfo;
	htInfo.pt.x = xPos;
	htInfo.pt.y = yPos;
	HTREEITEM hItem = TreeView_HitTest(m_pWnd, &htInfo);
	if (hItem == 0)
		return 0;
	if (!(htInfo.flags & TVHT_ONITEMICON))
		return 0;
	// the following test is needed to fix bug 665
	// without this when a user clicks a partialy wisible item the system will scroll it into full view, but it causes hittest to identify the wrong item
	RECT Rect;
	if (!TreeView_GetItemRect(m_pWnd, hItem, &Rect, fFalse) || Rect.bottom > m_iHeight)  // not visible or not entirely visible
		return 0;
	TreeView_SelectItem(m_pWnd, hItem);
	Ensure(OpenMenu(hItem));
	return 0;
}

IMsiRecord* CMsiSelectionTree::OpenMenu(HTREEITEM hItem)
{
	m_hOpenedMenu = 0;
	if ( m_fWorking )
		return 0;

	RECT Rect;
	AssertNonZero(TreeView_GetItemRect(m_pWnd, hItem, &Rect, fTrue));

	HMENU hMenu = CreatePopupMenu();
	Assert(hMenu);
	if ( ! hMenu )
		return 0;
	m_hOpenedMenu = hItem;
	Ensure(PopulateMenu(hMenu, hItem));
	Rect.top = Rect.bottom;
	WIN::MapWindowPoints (m_pWnd, HWND_DESKTOP, (LPPOINT) &Rect, 2);
	AssertNonZero(TrackPopupMenu(hMenu, TPM_LEFTALIGN | TPM_LEFTBUTTON, Rect.left - 4 - g_iSelIconX, Rect.top, 0, m_pWnd, 0));
	AssertNonZero(DestroyMenu(hMenu));
	m_uiLastCloseTime = WIN::GetTickCount();
	return 0;
}

IMsiRecord* CMsiSelectionTree::Char(WPARAM wParam, LPARAM /*lParam*/)
{
	if ( wParam == VK_SPACE )
	{
		Ensure(DoMenu());
		return PostErrorDlgKey(Imsg(idbgWinMes), 0); // we want to eat the message!
	}
	return 0;
}

IMsiRecord* CMsiSelectionTree::KeyDown(WPARAM wParam, LPARAM /*lParam*/)
{
	if (wParam == VK_F4)
		return DoMenu();

	return 0;
}

IMsiRecord* CMsiSelectionTree::SysKeyDown(WPARAM wParam, LPARAM /*lParam*/)
{
	if (wParam == VK_UP || wParam == VK_DOWN)
	{
		Ensure(DoMenu());
		return PostErrorDlgKey(Imsg(idbgWinMes), 0); // we want to eat the message!
	}
	return 0;
}

IMsiRecord* CMsiSelectionTree::DoMenu(void)
{
	HTREEITEM hItem = TreeView_GetSelection(m_pWnd);
	if (!hItem)
		return 0;
	return OpenMenu(hItem);
}

IMsiRecord* CMsiSelectionTree::MeasureItem(WPARAM /*wParam*/, LPARAM lParam)
{
	LPMEASUREITEMSTRUCT lpmis = (LPMEASUREITEMSTRUCT) lParam;
	if (lpmis->CtlType != ODT_MENU)
		return 0;
	int iIndex = lpmis->itemID;
	PMsiCursor piMenuCursor(0);
	Ensure(::CursorCreate(*m_piMenuTable, pcaTableISelMenu, fFalse, *m_piServices, *&piMenuCursor)); 
	piMenuCursor->SetFilter(iColumnBit(itabSMKey));
	AssertNonZero(piMenuCursor->PutInteger(itabSMKey, iIndex));
	AssertNonZero(piMenuCursor->Next());
	MsiString strText = piMenuCursor->GetString(itabSMText);
	PAINTSTRUCT ps;
	HDC hdc = WIN::BeginPaint(m_pWnd, &ps);
	//  I retrieve and set the Windows menu font
	NONCLIENTMETRICS ncMetrics;
	ncMetrics.cbSize = sizeof(NONCLIENTMETRICS);
	AssertNonZero(WIN::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncMetrics, 0));
	HFONT hfntOld = NULL;
	HFONT hfntMenu = WIN::CreateFontIndirect(&ncMetrics.lfMenuFont);
	if ( hfntMenu )
		hfntOld = (HFONT)WIN::SelectObject(hdc, hfntMenu);
	Assert(hfntMenu && hfntOld);
	if ( ! hfntOld )
	{
		if ( hfntMenu )
			WIN::DeleteObject((HGDIOBJ)hfntMenu);
		WIN::EndPaint(m_pWnd, &ps);
		return 0;
	}
	//  get the text's size
	SIZE size;
	WIN::GetTextExtentPoint32(hdc, (const ICHAR*)strText, strText.TextSize(), &size);
	//  restore the old font
	WIN::SelectObject(hdc, hfntOld);
	AssertNonZero(WIN::DeleteObject((HGDIOBJ)hfntMenu));
	size.cx += g_iSelIconX + 4;
	size.cy += 4;
	if (size.cy < g_iSelIconY + 4)
		size.cy = g_iSelIconY + 4;
	lpmis->itemHeight = size.cy;
	lpmis->itemWidth = size.cx;
	WIN::EndPaint(m_pWnd, &ps);
	return PostErrorDlgKey(Imsg(idbgWinMes), 1);
}

IMsiRecord* CMsiSelectionTree::DrawItem(WPARAM /*wParam*/, LPARAM lParam)
{													 
	LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT) lParam;
	if ( lpdis->CtlID != 0 || lpdis->CtlType != ODT_MENU )
		return 0;
	int iIndex = lpdis->itemID;
	PMsiCursor piMenuCursor(0);
	Ensure(CursorCreate(*m_piMenuTable, pcaTableISelMenu, fFalse, *m_piServices, *&piMenuCursor)); 
	piMenuCursor->SetFilter(iColumnBit(itabSMKey));
	AssertNonZero(piMenuCursor->PutInteger(itabSMKey, iIndex));
	AssertNonZero(piMenuCursor->Next());
	MsiString strText = piMenuCursor->GetString(itabSMText);
	int iIcon =  piMenuCursor->GetInteger(itabSMIcon);
	COLORREF clrForeground = WIN::SetTextColor(lpdis->hDC, WIN::GetSysColor(lpdis->itemState & ODS_SELECTED ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT));
	Assert(clrForeground != CLR_INVALID);
	COLORREF clrBackground = WIN::SetBkColor(lpdis->hDC, WIN::GetSysColor(lpdis->itemState & ODS_SELECTED ? COLOR_HIGHLIGHT : COLOR_MENU));
	Assert(clrBackground != CLR_INVALID);
	TEXTMETRIC tm;
	AssertNonZero(GetTextMetrics(lpdis->hDC, &tm));
	int y = (lpdis->rcItem.bottom + lpdis->rcItem.top - tm.tmHeight) / 2;
#ifdef DEBUG
	SIZE size;
	WIN::GetTextExtentPoint32(lpdis->hDC, (const ICHAR*)strText, strText.TextSize(), &size);
	size.cx += g_iSelIconX + 4;
	Assert(size.cx <= lpdis->rcItem.right - lpdis->rcItem.left);
#endif  //  DEBUG
	WIN::ExtTextOut(lpdis->hDC, g_iSelIconX + 4, y, ETO_CLIPPED | ETO_OPAQUE,
						 &lpdis->rcItem, (const ICHAR*)strText, strText.TextSize(), 0);
	AssertNonZero(CLR_INVALID != WIN::SetTextColor(lpdis->hDC, clrForeground));
	AssertNonZero(CLR_INVALID != WIN::SetBkColor(lpdis->hDC, clrBackground));
	y = (lpdis->rcItem.bottom + lpdis->rcItem.top - g_iSelIconY) / 2;
	ImageList_Draw(m_hImageList, iIcon, lpdis->hDC, 2, y, ILD_TRANSPARENT); 

	
	return PostErrorDlgKey(Imsg(idbgWinMes), 1);
}

IMsiRecord* CMsiSelectionTree::PopulateMenu(HMENU hMenu, HTREEITEM hItem)
{
	if (m_fPreview)
		return 0;
	PMsiCursor piMenuCursor(0);
	Ensure(::CursorCreate(*m_piMenuTable, pcaTableISelMenu, fFalse, *m_piServices, *&piMenuCursor)); 
	while (piMenuCursor->Next())
	{
		AssertNonZero(piMenuCursor->Delete());
	}
	PMsiCursor piFeatureCursor(0);
	Ensure(::CursorCreate(*m_piFeatureTable, pcaTablePFeature, fFalse, *m_piServices, *&piFeatureCursor)); 
	piFeatureCursor->SetFilter(iColumnBit(m_colFeatureHandle));
	AssertNonZero(PutHandleData(piFeatureCursor, m_colFeatureHandle, (UINT_PTR)hItem));
	AssertNonZero(piFeatureCursor->Next());
	int iOrig = piFeatureCursor->GetInteger(m_colFeatureInstalled);
	int iSel = piFeatureCursor->GetInteger(m_colFeatureAction);
	MsiStringId idFeature = piFeatureCursor->GetInteger(m_colFeatureKey);
	int iValidStates;
	Ensure(m_piSelectionManager->GetFeatureValidStates(idFeature, iValidStates));
	int iIndex = 0;
	MsiString strParent = piFeatureCursor->GetString(m_colFeatureParent);
	int iParentSel = 0;
	if (strParent.TextSize())
	{
		piFeatureCursor->Reset();
		piFeatureCursor->SetFilter(iColumnBit(m_colFeatureKey));
		AssertNonZero(piFeatureCursor->PutString(m_colFeatureKey, *strParent));
		AssertNonZero(piFeatureCursor->Next());
		iParentSel = piFeatureCursor->GetInteger(m_colFeatureAction);
		if (iParentSel == iMsiNullInteger)
			iParentSel = piFeatureCursor->GetInteger(m_colFeatureInstalled);
	}

	// adding the local option
	piMenuCursor->Reset();
	if (iValidStates & icaBitLocal)
	{
		for (int c=0; c<2; c++)
		{
			if (c == 0)
			{
				AssertNonZero(piMenuCursor->PutInteger(itabSMKey, ++iIndex));
				AssertNonZero(piMenuCursor->PutString(itabSMText, *MsiString(::GetUIText(*MsiString(*pcaMenuLocal)))));
				AssertNonZero(piMenuCursor->PutInteger(itabSMSelection, iOrig == iisLocal ? iMsiNullInteger : iisLocal));
				AssertNonZero(piMenuCursor->PutInteger(itabSMIcon, 1));
			}
			else
			{
				AssertNonZero(piMenuCursor->PutInteger(itabSMKey, ++iIndex));
				AssertNonZero(piMenuCursor->PutString(itabSMText, *MsiString(::GetUIText(*MsiString(*pcaMenuAllLocal)))));
				AssertNonZero(piMenuCursor->PutInteger(itabSMSelection, iisLocalAll));
				AssertNonZero(piMenuCursor->PutInteger(itabSMIcon, 5));			
			}
			/*
			switch(iOrig)
			{
			case iMsiNullInteger:
			case iisAbsent:
				AssertNonZero(piMenuCursor->PutString(itabSMText, MsiString(::GetUIText(MsiString(*pcaMenuAbsentLocal)))));
				AssertNonZero(piMenuCursor->PutInteger(itabSMSelection, iisLocal));
				AssertNonZero(piMenuCursor->PutInteger(itabSMIcon, 1));
				break;
			case iisLocal:
				AssertNonZero(piMenuCursor->PutString(itabSMText, MsiString(::GetUIText(MsiString(*pcaMenuLocalLocal)))));
				AssertNonZero(piMenuCursor->PutInteger(itabSMSelection, iMsiNullInteger));
				AssertNonZero(piMenuCursor->PutInteger(itabSMIcon, 4));
				break;
			case iisSource:
				AssertNonZero(piMenuCursor->PutString(itabSMText, MsiString(::GetUIText(MsiString(*pcaMenuSourceLocal)))));
				AssertNonZero(piMenuCursor->PutInteger(itabSMSelection, iisLocal));
				AssertNonZero(piMenuCursor->PutInteger(itabSMIcon, 7));
				break;
			default:
				Assert(fFalse);
				break;
			}*/
			AssertNonZero(piMenuCursor->Insert());
			if (m_fScreenReader)
			{
				AssertNonZero(WIN::AppendMenu(hMenu, MF_STRING, iIndex, (ICHAR *)(const ICHAR *)MsiString(piMenuCursor->GetString(itabSMText))));
			}
			else
			{
				AssertNonZero(WIN::AppendMenu(hMenu, MF_OWNERDRAW, iIndex, 0));
			}
		}
		
	}

	// adding the source option
	piMenuCursor->Reset();
	if (iValidStates & icaBitSource)
	{
		if (iValidStates & icaBitLocal)
			AssertNonZero(WIN::AppendMenu(hMenu, MF_SEPARATOR, 0, 0));

		for (int c=0; c<2; c++)
		{
			if (c==0)
			{
				AssertNonZero(piMenuCursor->PutInteger(itabSMKey, ++iIndex));
				AssertNonZero(piMenuCursor->PutString(itabSMText, *MsiString(::GetUIText(*MsiString(m_fCD ? pcaMenuCD : pcaMenuNetwork)))));
				AssertNonZero(piMenuCursor->PutInteger(itabSMSelection, iOrig == iisSource ? iMsiNullInteger : iisSource));
				AssertNonZero(piMenuCursor->PutInteger(itabSMIcon, m_fCD ? 2 : 3));
			}
			else
			{
				AssertNonZero(piMenuCursor->PutInteger(itabSMKey, ++iIndex));
				AssertNonZero(piMenuCursor->PutString(itabSMText, *MsiString(::GetUIText(*MsiString(m_fCD ? pcaMenuAllCD : pcaMenuAllNetwork)))));
				AssertNonZero(piMenuCursor->PutInteger(itabSMSelection, iisSourceAll));
				AssertNonZero(piMenuCursor->PutInteger(itabSMIcon, m_fCD ? 6 : 7));
			}

			/*
			switch(iOrig)
			{
			case iMsiNullInteger:
			case iisAbsent:
				AssertNonZero(piMenuCursor->PutString(itabSMText, MsiString(::GetUIText(MsiString(*pcaMenuAbsentSource)))));
				AssertNonZero(piMenuCursor->PutInteger(itabSMSelection, iisSource));
				AssertNonZero(piMenuCursor->PutInteger(itabSMIcon, 2));
				break;
			case iisLocal:
				AssertNonZero(piMenuCursor->PutString(itabSMText, MsiString(::GetUIText(MsiString(*pcaMenuLocalSource)))));
				AssertNonZero(piMenuCursor->PutInteger(itabSMSelection, iisSource));
				AssertNonZero(piMenuCursor->PutInteger(itabSMIcon, 5));
				break;
			case iisSource:
				AssertNonZero(piMenuCursor->PutString(itabSMText, MsiString(::GetUIText(MsiString(*pcaMenuSourceSource)))));
				AssertNonZero(piMenuCursor->PutInteger(itabSMSelection, iMsiNullInteger));
				AssertNonZero(piMenuCursor->PutInteger(itabSMIcon, 8));
				break;
			default:
				Assert(fFalse);
				break;
			}*/
			AssertNonZero(piMenuCursor->Insert());
			if (m_fScreenReader)
			{
				AssertNonZero(WIN::AppendMenu(hMenu, MF_STRING, iIndex, (ICHAR *)(const ICHAR *)MsiString(piMenuCursor->GetString(itabSMText))));
			}
			else
			{
				AssertNonZero(WIN::AppendMenu(hMenu, MF_OWNERDRAW, iIndex, 0));
			}
		}
	}

	// adding the advertise option
	piMenuCursor->Reset();
	if (iValidStates & icaBitAdvertise)
	{
		if ((iValidStates & icaBitLocal) || (iValidStates & icaBitSource))
			AssertNonZero(WIN::AppendMenu(hMenu, MF_SEPARATOR, 0, 0));

		AssertNonZero(piMenuCursor->PutInteger(itabSMKey, ++iIndex));
		AssertNonZero(piMenuCursor->PutString(itabSMText, *MsiString(::GetUIText(*MsiString(*pcaMenuAdvertise)))));
		AssertNonZero(piMenuCursor->PutInteger(itabSMSelection, iOrig == iisAdvertise ? iMsiNullInteger : iisAdvertise));
		AssertNonZero(piMenuCursor->PutInteger(itabSMIcon, 4));
/*
		switch(iOrig)
		{
		case iMsiNullInteger:
		case iisAbsent:
			AssertNonZero(piMenuCursor->PutString(itabSMText, MsiString(::GetUIText(MsiString(*pcaMenuAbsentSource)))));
			AssertNonZero(piMenuCursor->PutInteger(itabSMSelection, iisSource));
			AssertNonZero(piMenuCursor->PutInteger(itabSMIcon, 2));
			break;
		case iisLocal:
			AssertNonZero(piMenuCursor->PutString(itabSMText, MsiString(::GetUIText(MsiString(*pcaMenuLocalSource)))));
			AssertNonZero(piMenuCursor->PutInteger(itabSMSelection, iisSource));
			AssertNonZero(piMenuCursor->PutInteger(itabSMIcon, 5));
			break;
		case iisSource:
			AssertNonZero(piMenuCursor->PutString(itabSMText, MsiString(::GetUIText(MsiString(*pcaMenuSourceSource)))));
			AssertNonZero(piMenuCursor->PutInteger(itabSMSelection, iMsiNullInteger));
			AssertNonZero(piMenuCursor->PutInteger(itabSMIcon, 8));
			break;
		default:
			Assert(fFalse);
			break;
		}*/
		AssertNonZero(piMenuCursor->Insert());
		if (m_fScreenReader)
		{
			AssertNonZero(WIN::AppendMenu(hMenu, MF_STRING, iIndex, (ICHAR *)(const ICHAR *)MsiString(piMenuCursor->GetString(itabSMText))));
		}
		else
		{
			AssertNonZero(WIN::AppendMenu(hMenu, MF_OWNERDRAW, iIndex, 0));
		}
	}

	// adding the absent option
	piMenuCursor->Reset();
	if (iValidStates & icaBitAbsent)
	{
		if ((iValidStates & icaBitLocal) || (iValidStates & icaBitSource) || (iValidStates & icaBitAdvertise))
			AssertNonZero(WIN::AppendMenu(hMenu, MF_SEPARATOR, 0, 0));

		AssertNonZero(piMenuCursor->PutInteger(itabSMKey, ++iIndex));
		AssertNonZero(piMenuCursor->PutString(itabSMText, *MsiString(::GetUIText(*MsiString(*pcaMenuAbsent)))));
		AssertNonZero(piMenuCursor->PutInteger(itabSMSelection, iOrig == iisAbsent ? iMsiNullInteger : iisAbsent));
		AssertNonZero(piMenuCursor->PutInteger(itabSMIcon, 0));
		/*
		switch(iOrig)
		{
		case iMsiNullInteger:
		case iisAbsent:
			AssertNonZero(piMenuCursor->PutString(itabSMText, MsiString(::GetUIText(MsiString(*pcaMenuAbsentAbsent)))));
			AssertNonZero(piMenuCursor->PutInteger(itabSMSelection, iMsiNullInteger));
			AssertNonZero(piMenuCursor->PutInteger(itabSMIcon, 0));
			break;
		case iisLocal:
			AssertNonZero(piMenuCursor->PutString(itabSMText, MsiString(::GetUIText(MsiString(*pcaMenuLocalAbsent)))));
			AssertNonZero(piMenuCursor->PutInteger(itabSMSelection, iisAbsent));
			AssertNonZero(piMenuCursor->PutInteger(itabSMIcon, 3));
			break;
		case iisSource:
			AssertNonZero(piMenuCursor->PutString(itabSMText, MsiString(::GetUIText(MsiString(*pcaMenuSourceAbsent)))));
			AssertNonZero(piMenuCursor->PutInteger(itabSMSelection, iisAbsent));
			AssertNonZero(piMenuCursor->PutInteger(itabSMIcon, 6));
			break;
		default:
			Assert(fFalse);
			break;
		}*/
		AssertNonZero(piMenuCursor->Insert());
		if (m_fScreenReader)
		{
			AssertNonZero(WIN::AppendMenu(hMenu, MF_STRING, iIndex, (ICHAR *)(const ICHAR *)MsiString(piMenuCursor->GetString(itabSMText))));
		}
		else
		{
			AssertNonZero(WIN::AppendMenu(hMenu, MF_OWNERDRAW, iIndex, 0));
		}
	}
	return 0;
}


IMsiRecord* CMsiSelectionTree::KillFocus(WPARAM wParam, LPARAM lParam)
{
	if ( m_fWorking )
	{
		//  I don't allow it to lose focus
		WIN::SetFocus(m_pWnd);
		Ensure(LockDialog(fTrue));
		//  I don't want to enter the control's default window procedure
		return PostErrorDlgKey(Imsg(idbgWinMes), 0);
	}
	else
	{
		Ensure(LockDialog(fFalse));
		return CMsiActiveControl::KillFocus(wParam, lParam);
	}
}

IMsiRecord* CMsiSelectionTree::Notify(WPARAM /*wParam*/, LPARAM lParam)
{
	NM_TREEVIEW * pnmtv = (NM_TREEVIEW *) lParam;
	switch (pnmtv->hdr.code)
		{
	case TVN_SELCHANGING:
		{
			if ( m_fWorking )
			{
				//  if it is "working", I reject the selection change
				MessageBeep(MB_OK);
				return (PostErrorDlgKey(Imsg(idbgWinMes), 1));
			}
			else
				return (PostErrorDlgKey(Imsg(idbgWinMes), 0));
		}
		break;
	case TVN_SELCHANGED:
		{
			TV_ITEM tviOld = pnmtv->itemOld;
			TV_ITEM tvi;
			if (tviOld.hItem)
			{
				tvi.hItem = tviOld.hItem;
				tvi.mask = TVIF_STATE;
				tvi.stateMask = TVIS_OVERLAYMASK;
				tvi.state = 0;
				AssertNonZero(-1 != TreeView_SetItem(m_pWnd, &tvi));
			}
			Bool fLeftUnit = ToBool(MsiString(GetDBProperty(IPROPNAME_LEFTUNIT)).TextSize());
			TV_ITEM tviNew = pnmtv->itemNew;
			HTREEITEM hItem = tviNew.hItem;
			if (hItem == 0)
				return 0;
			tvi.hItem = hItem;
			tvi.mask = TVIF_STATE;
			tvi.stateMask = TVIS_OVERLAYMASK;
			tvi.state = INDEXTOOVERLAYMASK(1);
			AssertNonZero(-1 != TreeView_SetItem(m_pWnd, &tvi));
			PMsiCursor piFeatureCursor(0);
			Ensure(::CursorCreate(*m_piFeatureTable, pcaTablePFeature, fFalse, *m_piServices, *&piFeatureCursor)); 
			piFeatureCursor->SetFilter(iColumnBit(m_colFeatureHandle));
			AssertNonZero(PutHandleData(piFeatureCursor, m_colFeatureHandle, (UINT_PTR)hItem));
			AssertNonZero(piFeatureCursor->Next());
			PMsiRecord piRecord = &m_piServices->CreateRecord(4);
			AssertNonZero(piRecord->SetMsiString(1, *MsiString(piFeatureCursor->GetString(m_colFeatureDesc))));
			Ensure(m_piDialog->PublishEventSz(pcaControlEventSelectionDescription, *piRecord));
			MsiString strPath = ::GetUIText(*MsiString(*pcaAbsentPath));
			MsiString strFeature = piFeatureCursor->GetString(m_colFeatureKey);
			MsiString strDir;
			Ensure(m_piSelectionManager->GetFeatureConfigurableDirectory(*strFeature, *&strDir));
			MsiString strAction;
			MsiString strActionArg;
			Bool fBrowse = fFalse;
			int iOrig = piFeatureCursor->GetInteger(m_colFeatureInstalled);
			int iCurrent = piFeatureCursor->GetInteger(m_colFeatureAction);
			if ( iCurrent == iisReinstall )
				iCurrent = iOrig;
			switch (iCurrent)
			{
			case iMsiNullInteger:
				switch (iOrig)
				{
				case iMsiNullInteger:
				case iisAbsent:
					strActionArg = pcaSelAbsentAbsent;
					break;
				case iisSource:
					{
						strActionArg = m_fCD ? pcaSelCDCD : pcaSelNetworkNetwork;
					}
					break;
				case iisLocal:
					{
						if (strDir.TextSize())
						{
							PMsiPath piPath(0);
							Ensure(m_piDirectoryManager->GetTargetPath(*strDir, *&piPath));
							strPath = piPath->GetPath();
							fBrowse = fTrue;  // we want to browse if the directory is configurable, select is local, installed is not local
						}
						strActionArg = pcaSelLocalLocal;
					}
					break;
				case iisAdvertise:
					strActionArg = pcaSelAdvertiseAdvertise;
					break;
				default:
					Assert(fFalse); // should not happen
					break;
				}
				break;
			case iisAbsent:
				switch (iOrig)
				{
				case iMsiNullInteger:
				case iisAbsent:
					strActionArg = pcaSelAbsentAbsent;
					break;
				case iisSource:
					strActionArg = m_fCD ? pcaSelCDAbsent : pcaSelNetworkAbsent;
					break;
				case iisLocal:
					strActionArg = pcaSelLocalAbsent;
					break;
				case iisAdvertise:
					strActionArg = pcaSelAdvertiseAbsent;
					break;
				default:
					Assert(fFalse); 
					break; // should never happen
				}
				break;
			case iisLocal:
				{
					if (strDir.TextSize() && piFeatureCursor->GetInteger(m_colFeatureInstalled) != iisLocal)
					{
						fBrowse = fTrue;  // we want to browse if the directory is configurable, select is local, installed is not local
						PMsiPath piPath(0);
						Ensure(m_piDirectoryManager->GetTargetPath(*strDir, *&piPath));
						if (!piPath)
							return PostError(Imsg(idbgSelectionPathMissing), *strDir);
						strPath = piPath->GetPath();
					}
					switch (iOrig)
					{
					case iMsiNullInteger:
					case iisAbsent:
						strActionArg = pcaSelAbsentLocal;
						break;
					case iisSource:
						strActionArg = m_fCD ? pcaSelCDLocal : pcaSelNetworkLocal;
						break;
					case iisLocal:
						strActionArg = pcaSelLocalLocal;
						break;
					case iisAdvertise:
						strActionArg = pcaSelAdvertiseLocal;
						break;
					default:
						Assert(fFalse);	// should never happen
						break;
					}
					break;
				}
			case iisSource:
				{
					switch (iOrig)
					{
					case iMsiNullInteger:
					case iisAbsent:
						strActionArg = m_fCD ? pcaSelAbsentCD : pcaSelAbsentNetwork;
						break;
					case iisLocal:
						strActionArg = m_fCD ? pcaSelLocalCD : pcaSelLocalNetwork;
						break;
					case iisSource:
						strActionArg = m_fCD ? pcaSelCDCD : pcaSelNetworkNetwork;
						break;
					case iisAdvertise:
						strActionArg = m_fCD ? pcaSelAdvertiseCD : pcaSelAdvertiseNetwork;
						break;
					default:
						Assert(fFalse); // should never happen
					}
					break;
				}
			case iisAdvertise:
				switch (iOrig)
				{
				case iMsiNullInteger:
				case iisAbsent:
					strActionArg = pcaSelAbsentAdvertise;
					break;
				case iisSource:
					strActionArg = m_fCD ? pcaSelCDAdvertise : pcaSelNetworkAdvertise;
					break;
				case iisLocal:
					strActionArg = pcaSelLocalAdvertise;
					break;
				case iisAdvertise:
					strActionArg = pcaSelAdvertiseAdvertise;
					break;
				default:
					Assert(fFalse); 
					break; // should never happen
				}
				break;
			default:
				Assert(fFalse); //should never happen
			}
			//AssertNonZero(piRecord->SetInteger(1, (int) hIcon));
			//Ensure(m_piDialog->PublishEvent(MsiString(*pcaControlEventSelectionIcon), piRecord));
			AssertNonZero(piRecord->SetMsiString(1, *MsiString(EscapeAll(*strPath))));
			Ensure(m_piDialog->PublishEventSz(pcaControlEventSelectionPath, *piRecord));
			AssertNonZero(piRecord->SetInteger(1, ToBool(strPath.TextSize())));
			if (!m_fInstalled)
			{
				Ensure(m_piDialog->PublishEventSz(pcaControlEventSelectionPathOn, *piRecord));
				MsiString strAction = fBrowse ? MsiString(*pcaActionEnable) : MsiString(*pcaActionDisable);
				Ensure(m_piDialog->EventActionSz(pcaControlEventSelectionBrowse, *strAction));
			}
			strAction = ::GetUIText(*strActionArg);
			AssertNonZero(piRecord->SetMsiString(1, *strAction));
			Ensure(m_piDialog->PublishEventSz(pcaControlEventSelectionAction, *piRecord));
			// count the children
			MsiString strKey = piFeatureCursor->GetString(m_colFeatureKey);
			int iTotalCost = 0;	
			int iOwnCost = 0;
			int iChildren = 0;
			int iChildrenSel = 0;
			piFeatureCursor->Reset();
			piFeatureCursor->SetFilter(iColumnBit(m_colFeatureParent));
			AssertNonZero(piFeatureCursor->PutString(m_colFeatureParent, *strKey));
			while (piFeatureCursor->Next())
			{
				if (GetHandleData(piFeatureCursor, m_colFeatureHandle))
				{
					iChildren++;
					int iAction = piFeatureCursor->GetInteger(m_colFeatureAction);
					if (iAction != iMsiNullInteger && iAction != iisAbsent)
						iChildrenSel++;
				}
			}
			Ensure(m_piSelectionManager->GetDescendentFeatureCost(*strKey, iisCurrent, iTotalCost));
			if (m_piSelectionManager->IsCostingComplete() == fFalse)
			{
				AssertNonZero(piRecord->SetMsiString(0, *MsiString(::GetUIText(*MsiString(*pcaSelCostPending)))));
			}
			else
			{
				if (iChildren)
				{
					Ensure(m_piSelectionManager->GetFeatureCost(*strKey, iisCurrent, iOwnCost));
					TV_ITEM tvItem;
					tvItem.hItem = hItem;
					tvItem.mask = TVIF_STATE;
					tvItem.stateMask = TVIS_EXPANDED;
					AssertNonZero(TreeView_GetItem(m_pWnd, &tvItem));
					Bool fExpanded = ToBool(tvItem.state & TVIS_EXPANDED);
					AssertNonZero(piRecord->SetInteger(2, iChildrenSel));
					AssertNonZero(piRecord->SetInteger(3, iChildren));
					MsiString strText;
					if (iOwnCost < 0)
					{
						if (iTotalCost - iOwnCost < 0)
						{
							strText = pcaSelParentCostNegNeg;
						}
						else
						{
							strText = pcaSelParentCostNegPos;
						}
					}
					else
					{
						if (iTotalCost - iOwnCost < 0)
						{
							strText = pcaSelParentCostPosNeg;
						}
						else
						{
							strText = pcaSelParentCostPosPos;
						}
					}
					AssertNonZero(piRecord->SetMsiString(0, *MsiString(::GetUIText(*strText))));
					AssertNonZero(piRecord->SetMsiString(1, *MsiString(::FormatSize(abs(iOwnCost), fLeftUnit)))); 
					AssertNonZero(piRecord->SetMsiString(4, *MsiString(::FormatSize(abs(iTotalCost - iOwnCost), fLeftUnit)))); 
				}
				else
				{
					AssertNonZero(piRecord->SetMsiString(0, (iTotalCost >= 0) ? *MsiString(::GetUIText(*MsiString(*pcaSelChildCostPos))) : *MsiString(::GetUIText(*MsiString(*pcaSelChildCostNeg)))));
					AssertNonZero(piRecord->SetMsiString(1, *MsiString(::FormatSize(abs(iTotalCost), fLeftUnit)))); 
				}
			}
			Ensure(m_piDialog->PublishEventSz(pcaControlEventSelectionSize, *piRecord));
		}
		break;
	case NM_SETFOCUS:
		if ( TreeView_GetCount(m_pWnd) == 0 )
		{
			//  there are no items in the selection tree - I delete eventual
			//  garbage text in controls and I disable useless buttons.
			PMsiRecord piRecord = &m_piServices->CreateRecord(4);
			AssertNonZero(piRecord->SetMsiString(0, *MsiString(TEXT(""))));
			AssertNonZero(piRecord->SetMsiString(1, *MsiString(TEXT(""))));
			AssertNonZero(piRecord->SetMsiString(2, *MsiString(TEXT(""))));
			AssertNonZero(piRecord->SetMsiString(3, *MsiString(TEXT(""))));
			Ensure(m_piDialog->PublishEventSz(pcaControlEventSelectionDescription, *piRecord));
			Ensure(m_piDialog->PublishEventSz(pcaControlEventSelectionSize, *piRecord));
			Ensure(m_piDialog->PublishEventSz(pcaControlEventSelectionPath, *piRecord));
			if (!m_fInstalled)
			{
				AssertNonZero(piRecord->SetInteger(1, fFalse));
				Ensure(m_piDialog->PublishEventSz(pcaControlEventSelectionPathOn, *piRecord));
				AssertNonZero(piRecord->SetMsiString(1, *MsiString(TEXT(""))));
				MsiString strAction = MsiString(*pcaActionDisable);
				Ensure(m_piDialog->EventActionSz(pcaControlEventSelectionBrowse, *strAction));
			}
			Ensure(m_piDialog->PublishEventSz(pcaControlEventSelectionAction, *piRecord));
			AssertNonZero(piRecord->SetInteger(1, fFalse));
			Ensure(m_piDialog->PublishEventSz(pcaControlEventSelectionNoItems, *piRecord));
		}
		break;
	}
	return 0;
}

IMsiRecord* CMsiSelectionTree::HandleEvent(const IMsiString& rpiEventNameString, const IMsiString& rpiArgumentString)
{
	Ensure(CheckInitialized());
	if (m_fPreview)
		return 0;

	if (rpiEventNameString.Compare(iscExact, MsiString(*pcaControlEventSelectionBrowse)))
	{
		if (!m_fUninitialized)
		{
			HTREEITEM hItem = TreeView_GetSelection(m_pWnd);
			Assert(hItem);
			PMsiCursor piFeatureCursor(0);
			Ensure(::CursorCreate(*m_piFeatureTable, pcaTablePFeature, fFalse, *m_piServices, *&piFeatureCursor)); 
			piFeatureCursor->SetFilter(iColumnBit(m_colFeatureHandle));
			AssertNonZero(PutHandleData(piFeatureCursor, m_colFeatureHandle, (UINT_PTR)hItem));
			AssertNonZero(piFeatureCursor->Next());
			MsiString strFeature = piFeatureCursor->GetString(m_colFeatureKey);
			MsiString strDir;
			Ensure(m_piSelectionManager->GetFeatureConfigurableDirectory(*strFeature,*&strDir));
			if(!strDir.TextSize())
				return PostErrorDlgKey(Imsg(idbgNoDirCont));
			Ensure(SetPropertyValue(*strDir, fTrue));
		}
		Ensure(m_piDialog->SetFocus(*m_strKey));
		Ensure(m_piDialog->HandleEvent(*MsiString(*pcaEventSpawnDialog), rpiArgumentString)); 
 		Ensure(m_piDialog->SetFocus(*m_strKey));
	}
	return 0;
}

IMsiControl* CreateMsiSelectionTree(IMsiEvent& riDialog)
{
	return new CMsiSelectionTree(riDialog);
}


/////////////////////////////////////////////
// CMsiListView  definition
/////////////////////////////////////////////

class CMsiListView:public CMsiActiveControl
{
public:
	CMsiListView(IMsiEvent& riDialog);
	~CMsiListView();
	IMsiRecord*            __stdcall WindowCreate(IMsiRecord& riRecord);
	IMsiRecord*            __stdcall GetPropertyFromDatabase();
protected:
	IMsiRecord*            PropertyChanged();
	IMsiRecord*            PaintSelected();
	IMsiRecord*            SetIndirectPropertyValue(const IMsiString& riValueString);
#ifdef ATTRIBUTES
	IMsiRecord*            GetItemsCount(IMsiRecord& riRecord);
	IMsiRecord*	           GetItemsValue(IMsiRecord& riRecord);
	IMsiRecord*	           GetItemsText(IMsiRecord& riRecord);
#endif // ATTRIBUTES
private:
	IMsiRecord*           CreateValuesTable();
	IMsiRecord*           PopulateList();
	PMsiTable             m_piValuesTable;
	Bool                  m_fSorted;
	IMsiRecord*           Notify(WPARAM wParam, LPARAM lParam);
	HIMAGELIST            m_hImageList;

};

/////////////////////////////////////////////////
// CMsiListView  implementation
/////////////////////////////////////////////////

CMsiListView::CMsiListView(IMsiEvent& riDialog) : CMsiActiveControl(riDialog), m_piValuesTable(0)
{
	m_fSorted = fFalse;
	m_hImageList = 0;
}

CMsiListView::~CMsiListView()
{
	if (m_hImageList)
		AssertNonZero(m_piHandler->DestroyHandle((HANDLE)m_hImageList) != -1);
}

IMsiRecord* CMsiListView::WindowCreate(IMsiRecord& riRecord)
{
	int iAttributes = riRecord.GetInteger(itabCOAttributes);
	m_fSorted = ToBool(iAttributes & msidbControlAttributesSorted);
	GetIconSize(iAttributes);
	Ensure(CMsiActiveControl::WindowCreate(riRecord));
	if (m_iSize == 0)
	{
		PMsiRecord piReturn = PostErrorDlgKey(Imsg(idbgNoIconSize));
		m_piEngine->Message(imtInfo, *piReturn);
		m_iSize = 16;
	}
	Ensure(CreateControlWindow(WC_LISTVIEW, LVS_REPORT | LVS_NOCOLUMNHEADER | WS_VSCROLL | WS_HSCROLL | LVS_SHAREIMAGELISTS | LVS_SINGLESEL | LVS_SHOWSELALWAYS | WS_BORDER | WS_TABSTOP | (m_fSorted ? 0 : LVS_SORTASCENDING), (m_fRTLRO ? WS_EX_RTLREADING : 0) | (m_fRightAligned ? WS_EX_RIGHT : 0) | (m_fLeftScroll ? WS_EX_LEFTSCROLLBAR : 0), *m_strText, m_pWndDialog, m_iKey));
	m_hImageList = ImageList_Create(m_iSize, m_iSize, ILC_MASK, 12, 20);
	AssertNonZero(m_piHandler->RecordHandle(CWINHND((HANDLE)m_hImageList, iwhtImageList)) != -1);
	LV_COLUMN lvC;
	lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM;
	lvC.fmt = LVCFMT_LEFT;
	lvC.iSubItem = 0;
	lvC.cx = m_iWidth;
	AssertNonZero(0 == ListView_InsertColumn(m_pWnd, 0, &lvC));
	Ensure(CreateValuesTable());
	Ensure(PopulateList());
	Ensure(WindowFinalize());
	return 0;
}

IMsiRecord* CMsiListView::PropertyChanged ()
{
	if (m_fPreview)
		return 0;
	Ensure(CMsiActiveControl::PropertyChanged ());
	Ensure(PaintSelected());
	return 0;
}

IMsiRecord* CMsiListView::GetPropertyFromDatabase()    
{
	if (m_fPreview)
		return 0;

	Ensure(CMsiActiveControl::GetPropertyFromDatabase ());
	Ensure(PaintSelected());
	return 0;
}


IMsiRecord* CMsiListView::SetIndirectPropertyValue(const IMsiString& riValueString)
{
	Ensure(CMsiActiveControl::SetIndirectPropertyValue(riValueString));
	Ensure(PopulateList());
	return 0;
}

IMsiRecord* CMsiListView::PaintSelected()
{
	PMsiCursor piValuesCursor(0);
	Ensure(::CursorCreate(*m_piValuesTable, pcaTableIValues, fFalse, *m_piServices, *&piValuesCursor)); 
	piValuesCursor->SetFilter(iColumnBit(itabVAValue));
	piValuesCursor->Reset();	
	AssertNonZero(piValuesCursor->PutString(itabVAValue, *MsiString(GetPropertyValue())));
	if(piValuesCursor->Next())
	{
		const IMsiString* piTempString = &piValuesCursor->GetString(itabVAText);
		LV_FINDINFO lvf;
		lvf.flags = LVFI_STRING;
		lvf.psz = (const ICHAR*) piTempString->GetString();
		int iIndex = ListView_FindItem(m_pWnd, -1, &lvf); 
		Assert(iIndex >= 0);
		ListView_SetItemState(m_pWnd, iIndex, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
		piTempString->Release();
	}
	else
	{
		int iSelected = ListView_GetNextItem(m_pWnd, -1, LVNI_SELECTED);
		if (iSelected == -1)
		{
			ListView_SetItemState(m_pWnd, 0, LVIS_FOCUSED, LVIS_FOCUSED);
		}
		else
		{
			ListView_SetItemState(m_pWnd, iSelected, 0, LVIS_SELECTED);
		}
	}
	return 0;
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiListView::GetItemsCount(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaControlAttributeItemsCount));

	riRecord.SetInteger(1, m_piValuesTable->GetRowCount());
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiListView::GetItemsValue(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, m_piValuesTable->GetRowCount(), pcaControlAttributeItemsValue));

	PMsiCursor piValuesCursor(0);
	Ensure(::CursorCreate(*m_piValuesTable, pcaTableIValues, fFalse, *m_piServices, *&piValuesCursor)); 
	int count = 0;
	while (piValuesCursor->Next())
	{   
		riRecord.SetMsiString(++count, *MsiString(piValuesCursor->GetString(itabVAValue)));
	}
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiListView::GetItemsText(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, m_piValuesTable->GetRowCount(), pcaControlAttributeItemsText));

	PMsiCursor piValuesCursor(0);
	Ensure(::CursorCreate(*m_piValuesTable, pcaTableIValues, fFalse, *m_piServices, *&piValuesCursor)); 
	int count = 0;
	while (piValuesCursor->Next())
	{   
		riRecord.SetMsiString(++count, *MsiString(piValuesCursor->GetString(itabVAText)));
	}
	return 0;
}
#endif // ATTRIBUTES


IMsiRecord* CMsiListView::CreateValuesTable()
{
	Assert(!m_piValuesTable);
	Ensure(CreateTable(pcaTableIValues, *&m_piValuesTable));
	::CreateTemporaryColumn(*m_piValuesTable, icdString + icdPrimaryKey  + icdNullable, itabVAValue);
	::CreateTemporaryColumn(*m_piValuesTable, icdString + icdNullable, itabVAText);
	return 0;
}

IMsiRecord* CMsiListView::PopulateList()
{
	if (m_fPreview)
		return 0;
	// first remove all old entries
	AssertNonZero(ListView_DeleteAllItems(m_pWnd));
	LV_ITEM lvI;
	lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;
	lvI.state = 0;
	lvI.stateMask = 0;
	HICON hIcon = 0;
	PMsiCursor piValuesCursor(0);
	Ensure(::CursorCreate(*m_piValuesTable, pcaTableIValues, fFalse, *m_piServices, *&piValuesCursor)); 
	while (piValuesCursor->Next())
	{
		AssertNonZero(piValuesCursor->Delete());
	}
	PMsiRecord piErrorRecord(0);
	Bool fPresent = fFalse;
	Ensure(IsColumnPresent(*m_piDatabase, *MsiString(*pcaTablePListView), *MsiString(*pcaTableColumnPListViewText), &fPresent));
	// temp until the database is fixed
	PMsiTable piTable(0);
	Ensure(m_piDatabase->LoadTable(*MsiString(*pcaTablePListView), 0, *&piTable));

	PMsiView piView(0);
	Ensure(CMsiControl::StartView((fPresent ? sqlListView : sqlListViewShort), *MsiString(GetPropertyName ()), *&piView)); 
	PMsiRecord piRecordNew(0);
	MsiString strImage;
	while (piRecordNew = piView->Fetch())
	{
		strImage = piRecordNew->GetMsiString(itabLVImage);
		Ensure(UnpackIcon(*strImage, *&hIcon, m_iSize, m_iSize, fFalse));
		if (hIcon)
		{
			ImageList_AddIcon(m_hImageList, hIcon);
			AssertNonZero(WIN::DestroyIcon(hIcon));
		}
	}
	ListView_SetImageList(m_pWnd, m_hImageList, LVSIL_SMALL);
	Ensure(piView->Close());
	Ensure(CMsiControl::StartView((fPresent ? sqlListView : sqlListViewShort), *MsiString(GetPropertyName ()), *&piView)); 
	MsiString strValue;
	MsiString strText;
	int iIndex = 0;
	while (piRecordNew = piView->Fetch())
	{
		piValuesCursor->Reset();
		strValue = piRecordNew->GetMsiString(itabLVValue);
		strValue = m_piEngine->FormatText(*strValue);
		piValuesCursor->SetFilter(iColumnBit(itabLVValue));
		piValuesCursor->PutString(itabLVValue, *strValue);
		if (!strValue.TextSize() || piValuesCursor->Next())
			return PostError(Imsg(idbgValueNotUnique), *m_strDialogName, *m_strKey, *strValue);
		piValuesCursor->Reset();
		piValuesCursor->SetFilter(0);
		// ToDo: integer only validation!
		AssertNonZero(piValuesCursor->PutString(itabVAValue, *strValue));

		strText = piRecordNew->GetMsiString(itabLVText);
		strText = m_piEngine->FormatText(*strText);
		if (strText.TextSize() == 0)  // if the text is missing, we use the value
			strText = strValue;
		AssertNonZero(piValuesCursor->PutString(itabVAText, *strText));
		AssertNonZero(piValuesCursor->Insert());
		lvI.iImage = iIndex;
		lvI.iItem =  iIndex++;
		lvI.iSubItem = 0;
		lvI.pszText = (ICHAR*)(const ICHAR*) strText;
		lvI.cchTextMax = IStrLen(lvI.pszText);
		AssertNonZero(ListView_InsertItem(m_pWnd, &lvI) != -1); 
	}
	Ensure(PaintSelected());
	return 0;
}

IMsiRecord* CMsiListView::Notify(WPARAM /*wParam*/, LPARAM lParam)
{
	LPNMHDR lpnmhdr = (LPNMHDR)lParam;
	if (lpnmhdr->hwndFrom != m_pWnd)
		return 0;
	switch (lpnmhdr->code)
	{
		case LVN_ITEMCHANGED:
		{
			int iSelected = ListView_GetNextItem(m_pWnd, -1, LVNI_SELECTED);
			if (iSelected != -1)
			{
				ICHAR *achTemp = new ICHAR[MAX_PATH];
				ListView_GetItemText(m_pWnd, iSelected, 0, achTemp, MAX_PATH);
				PMsiCursor piValuesCursor(0);
				Ensure(::CursorCreate(*m_piValuesTable, pcaTableIValues, fFalse, *m_piServices, *&piValuesCursor)); 
				piValuesCursor->SetFilter(iColumnBit(itabVAText));
				piValuesCursor->Reset();	
				AssertNonZero(piValuesCursor->PutString(itabVAText, *MsiString(achTemp)));
				AssertNonZero(piValuesCursor->Next());
				Ensure(SetPropertyValue(*MsiString(piValuesCursor->GetString(itabVAValue)), fTrue));
				delete[] achTemp;
				return PostErrorDlgKey(Imsg(idbgWinMes), 0);
			}
		}
	}
	return 0;
}


IMsiControl* CreateMsiListView(IMsiEvent& riDialog)
{
	return new CMsiListView(riDialog);
}

/////////////////////////////////////////////
// CMsiMaskedEdit  definition
/////////////////////////////////////////////

enum iftFields
{
	iftNone,
	iftNumeric,
	iftText,
	iftLiteral,
	iftSegSep,
};

class SegInfo // MaskedEdit helper class
{
public:
	WindowRef	  m_winrSegment;
	WNDPROC 	  m_pfBaseWinProc;	// control base class window proc
	int 		  m_iLength;		// Seg length (in characters)
	iftFields	  m_ift;			// Seg type

	SegInfo();

	void SetSegInfo(
		WindowRef	  winrSegment,
		WNDPROC 	  pfBaseWinProc,
		int 		  iLength,
		iftFields	  ift);

};
typedef SegInfo *PSegInfo;

SegInfo::SegInfo() :
	m_winrSegment(NULL),
	m_pfBaseWinProc(NULL),
	m_iLength(0),
	m_ift(iftNone)
{
}

void SegInfo::SetSegInfo(
	WindowRef	  winrSegment,
	WNDPROC 	  pfBaseWinProc,
	int 		  iLength,
	iftFields	  ift)
{

	m_winrSegment = winrSegment;
	m_pfBaseWinProc = pfBaseWinProc;
	m_iLength = iLength;
	m_ift = ift;
}

class CMsiMaskedEdit:public CMsiActiveControl
{
public:
	CMsiMaskedEdit(IMsiEvent& riDialog);
	~CMsiMaskedEdit();
	IMsiRecord* __stdcall WindowCreate(IMsiRecord& riRecord);
	IMsiRecord* __stdcall RefreshProperty();
	HKL inline    GetEnglishKbd() { return m_hklEnglishKbd; };
	Bool inline   IsIMEonMachine() { return m_fIMEIsAround; };
	Bool inline   SwitchLang() { return m_fSwitchLang; };

protected:
	static INT_PTR CALLBACK ControlProc(WindowRef pWnd, WORD message, WPARAM wParam, LPARAM lParam);		//--merced: changed int to INT_PTR
	iftFields GetIftFromStr(MsiString strCurrentChar);

	IMsiRecord*       Command(WPARAM wParam, LPARAM lParam);
	IMsiRecord*       SetFocus(WPARAM wParam, LPARAM lParam);

private:
	IMsiRecord*   __stdcall Undo();
	IMsiRecord*   Repaint();
	IMsiRecord*   SetVisible(Bool fVisible);
	IMsiRecord*   SetEnabled(Bool fEnabled);
	void		  Clear();

	INT_PTR		  m_cSegments;		//--merced: changed int to INT_PTR
	PSegInfo	  m_pSegInfo;
	HKL        m_hklEnglishKbd;
	Bool       m_fKbdLoaded;
	Bool       m_fIMEIsAround;
	Bool       m_fSwitchLang;
	bool       m_fScreenReader;
};

/////////////////////////////////////////////////
// CMsiMaskedEdit  implementation
/////////////////////////////////////////////////


CMsiMaskedEdit::CMsiMaskedEdit(IMsiEvent& riDialog) : CMsiActiveControl(riDialog)
{
	m_cSegments = 0;
	m_pSegInfo = NULL;
	m_fScreenReader = false;
}

void CMsiMaskedEdit::Clear()
{

	if (NULL != m_pSegInfo)
	{
		delete [] m_pSegInfo;
		m_pSegInfo = NULL;
	}
}

CMsiMaskedEdit::~CMsiMaskedEdit()
{
	Clear();
	if ( m_fKbdLoaded && m_hklEnglishKbd )
		AssertNonZero(WIN::UnloadKeyboardLayout(m_hklEnglishKbd));
}

IMsiRecord* CMsiMaskedEdit::WindowCreate(IMsiRecord& riRecord)
{
	Ensure(CMsiActiveControl::WindowCreate(riRecord));
	MsiString strNull;
	Ensure(CreateControlWindow(TEXT("STATIC"), SS_LEFT, WS_EX_CONTROLPARENT, *strNull, m_pWndDialog, m_iKey));
	m_fIMEIsAround = ToBool(WIN::ImmGetContext(m_pWnd) != 0);
	m_fKbdLoaded = m_fSwitchLang = fFalse;
	m_hklEnglishKbd = NULL;
	if ( m_fIMEIsAround )
		m_fSwitchLang = fTrue;
	else
	{
		LANGID lID = WIN::GetUserDefaultLangID();
		if ( PRIMARYLANGID(lID) == LANG_ARABIC ||
			  PRIMARYLANGID(lID) == LANG_HEBREW ||
			  PRIMARYLANGID(lID) == LANG_FARSI  )
			m_fSwitchLang = fTrue;
	}
	if ( m_fSwitchLang && !m_fIMEIsAround )
	{
		//  there is no point to load an English keyboard onto a machine that has IME
		AssertNonZero(m_hklEnglishKbd = WIN::GetKeyboardLayout(0));
		if ( PRIMARYLANGID(LOWORD(m_hklEnglishKbd)) != LANG_ENGLISH )
		{
			//  the default keyboard is not English.  I make sure there is an English
			//  keyboard loaded.
			CTempBuffer<HKL, MAX_PATH> rgdwKbds;
			int cKbds = WIN::GetKeyboardLayoutList(0, NULL);
			Assert(cKbds > 0);
			if ( cKbds > MAX_PATH )
				rgdwKbds.SetSize(cKbds);
			AssertNonZero(WIN::GetKeyboardLayoutList(cKbds, rgdwKbds) > 0);
			for ( cKbds--; 
					cKbds >= 0 && PRIMARYLANGID(LOWORD(rgdwKbds[cKbds])) != LANG_ENGLISH;
					cKbds-- )
				;
			if ( cKbds >= 0 )
				m_hklEnglishKbd = rgdwKbds[cKbds];
			else
			{
				m_hklEnglishKbd = WIN::LoadKeyboardLayout(TEXT("00000409"),
																KLF_REPLACELANG | KLF_SUBSTITUTE_OK);
				m_fKbdLoaded = ToBool(m_hklEnglishKbd != NULL);
			}
			Assert(m_hklEnglishKbd);
		}
	}
	if ( !WIN::SystemParametersInfo(SPI_GETSCREENREADER, 0, &m_fScreenReader, 0) )
		m_fScreenReader = false;
	Ensure(Repaint());
	Ensure(WindowFinalize());
	return 0;
}

iftFields CMsiMaskedEdit::GetIftFromStr(MsiString strCurrentChar)
{
	iftFields iftRet;

	MsiString strNumbers(*TEXT("#%"));
	MsiString strAlpha(*TEXT("^?&`"));
	MsiString strSegSep(*TEXT("="));

	if (strAlpha.Compare(iscWithin, strCurrentChar))
	{
		iftRet = iftText;
	}
	else if (strNumbers.Compare(iscWithin, strCurrentChar))
	{
		iftRet = iftNumeric;
	}
	else if (strSegSep.Compare(iscWithin, strCurrentChar))
	{
		iftRet = iftSegSep;
	}
	else
	{
		iftRet = iftLiteral;
	}

	return iftRet;
}

IMsiRecord* CMsiMaskedEdit::RefreshProperty()
{
	Ensure(CMsiActiveControl::RefreshProperty());
	Ensure(Repaint());
	return 0;
}

IMsiRecord* CMsiMaskedEdit::Repaint()
{
	int i;

	for (i = 0; i < m_cSegments; i++)
		WIN::DestroyWindow(m_pSegInfo[i].m_winrSegment);
	Clear();

	if ( m_fScreenReader )
	{
		//  destroying all the dummy screen reader windows
		HWND hChildWnd;
		while ( (hChildWnd = WIN::GetWindow(m_pWnd, GW_CHILD)) != NULL )
			WIN::DestroyWindow(hChildWnd);

		//  grabbing the preceding Text control's caption to be passed later on to the screen readers
		CTempBuffer<ICHAR, 128> rgchBuffer;
		HWND hPrevWnd = WIN::GetWindow(m_pWnd,	GW_HWNDPREV);
		AssertSz(hPrevWnd, TEXT("Couldn't get handle to previous window in CMsiMaskedEdit::Repaint()"));
		if ( hPrevWnd && hPrevWnd != m_pWnd &&
			  WIN::GetClassName(hPrevWnd, rgchBuffer, rgchBuffer.GetSize()-1) &&
			  !IStrCompI(rgchBuffer, TEXT("STATIC")) )
		{
			AssertNonZero(WIN::GetWindowText(hPrevWnd, rgchBuffer, rgchBuffer.GetSize()-1));
			int iLen = IStrLen(rgchBuffer);
			if ( rgchBuffer[iLen-1] != TEXT(':') && iLen < rgchBuffer.GetSize() )
				// this is so according to the standard Windows UI Style Guide (actually it is
				// required by some screen readers).
				StringCchCat(rgchBuffer, rgchBuffer.GetSize(), TEXT(":"));
			m_strToolTip = (const ICHAR*)rgchBuffer;
		}
		else
			m_strToolTip = TEXT("");
	}

	m_cSegments = 0;

	MsiString strMask = m_strText;
	strMask.Remove(iseIncluding, TEXT('<'));
	strMask.Remove(iseFrom, TEXT('>'));
	if (strMask.TextSize() == 0)
		return 0;
	MsiString strValue = GetPropertyValue();
	MsiString strValueSegment;
	int cChars = strMask.CharacterCount();

	m_pSegInfo = new SegInfo[cChars];

	// parse the mask
	int iLeft  = 0;
	PAINTSTRUCT ps;
	HDC hdc = WIN::BeginPaint(m_pWnd, &ps);
	IMsiRecord* piRecord = ChangeFontStyle(hdc, *m_strCurrentStyle, m_pWnd);
	RECT rect;
	WindowRef pWndSeg;
	MsiString strNull;
	MsiString strTest;
	int iHeight;
	LONG_PTR RetVal;			//--merced: changed long to LONG_PTR

	MsiString strExclude(*TEXT("<>@"));

	iftFields iftCurrent = iftNone;
	iftFields iftPrevious = iftNone;
	MsiString strLiteral;

	MsiString strFontStyle = GimmeUserFontStyle(*m_strCurrentStyle);
	PMsiRecord piReturn = m_piHandler->GetTextStyle(strFontStyle);
	if (piReturn)
	{
		WIN::SelectObject(hdc, (HFONT) GetHandleDataRecord(piReturn, itabTSFontHandle));
	}

	while (0 < strMask.TextSize())
	{
		int iSegLen = 0;
		BOOL fSegEnd = FALSE;
		pWndSeg = NULL;
		strLiteral = strNull;

		MsiString strCurrentChar = strMask.Extract(iseFirst, 1);
		iftCurrent = GetIftFromStr(strCurrentChar);
		iftPrevious = iftCurrent;

		//	This loop scans for the end of a segment marked by one of:
		//
		//		1.	Empty strMask.	We delete chars from the front of strMask as we
		//			process them.  We're done when there's no more left.
		//
		//		2.	The current field type is different than the previous field type.
		//			This means we've scanned one past previous field.
		//
		//		3.	We hit a segment separator.  This is a special case.  These should
		//			only be used to mark the end of a text or numeric segment, but
		//			if a SegSep follows a SegSep, each one terminates the current segment.


		while (0 < strMask.TextSize() && iftPrevious == iftCurrent &&
			(iftCurrent != iftSegSep || iSegLen < 1))
		{
			++iSegLen;

			if (strExclude.Compare(iscWithin, strCurrentChar))
			{
				return PostError(Imsg(idbgInvalidMask), *m_strDialogName, *m_strKey, *m_strText);
			}
			AssertNonZero(strMask.Remove(iseFirst, 1));

			if (iftLiteral == iftCurrent)
			{
				strLiteral += strCurrentChar;
			}

			iftPrevious = iftCurrent;

			strCurrentChar = strMask.Extract(iseFirst, 1);
			iftCurrent = GetIftFromStr(strCurrentChar);
		}

		// we are at the end of a segment

		if (iftSegSep == iftCurrent && 1 < iSegLen)
		{
			++iSegLen; // include the separator in the num or char count
		}

		switch (iftPrevious)
		{
		case iftNumeric:
		case iftText:
			{
				strTest = strNull;
				MsiString strTestChar(
					 *((iftNumeric == iftPrevious) ? TEXT("9") : TEXT("W")));

				for (i = 0; i < iSegLen; i++)
				{
					strTest += strTestChar;
				}
			}
			break;

		case iftSegSep:
				strLiteral = MsiString(*TEXT("-"));
				// fall through

		case iftLiteral:
				strTest = strLiteral;
			break;


		default:
			return PostErrorDlgKey(Imsg(idbgCreateControlWindow));
			break;
		}

		rect.left = rect.top = 0;
		rect.right = rect.bottom = 10000;

		iHeight = WIN::DrawText(hdc, strTest, -1, &rect, DT_LEFT | DT_SINGLELINE | DT_TOP | DT_EXTERNALLEADING | DT_CALCRECT);

		if (iftLiteral == iftPrevious || iftSegSep == iftPrevious)
		{
			pWndSeg = WIN::CreateWindowEx(
				WS_EX_TRANSPARENT,
				TEXT("STATIC"),
				strLiteral,
				SS_LEFT | WS_CHILD | WS_VISIBLE,
				iLeft,
				(m_iHeight - iHeight)/2,
				rect.right,
				m_iHeight,
				m_pWnd,
				(HMENU)m_cSegments,
				g_hInstance,
				0);
		}
		else
		{
			DWORD dwWinStyle = WS_CHILD | WS_BORDER | WS_TABSTOP | ES_AUTOHSCROLL | ES_LEFT | WS_VISIBLE;

			if (iftNumeric == iftPrevious)
			{
				dwWinStyle |= ES_NUMBER;
			}

			if ( m_fScreenReader && m_strToolTip.TextSize() )
			{
				//  dummy, invisible window needed to "display" text read by screen readers.
				AssertNonZero(WIN::CreateWindow(TEXT("STATIC"), m_strToolTip, dwWinStyle & ~WS_VISIBLE,
								  iLeft, 0, rect.right, m_iHeight, m_pWnd, NULL, g_hInstance, 0));
			}
			// reserve some room for the control frame.
			//// JIMH BUGBUG - is there any way to be sure how big this needs to be?
			rect.right += 8;
			pWndSeg = WIN::CreateWindow(
				TEXT("EDIT"),
				strNull,
				dwWinStyle,
				iLeft,
				0,
				rect.right,
				m_iHeight,
				m_pWnd,
				(HMENU)m_cSegments,
				g_hInstance,
				0);
		}

#ifdef _WIN64	// !merced
		m_pSegInfo[m_cSegments].SetSegInfo(
			pWndSeg,
			(WNDPROC)WIN::GetWindowLongPtr(pWndSeg, GWLP_WNDPROC),
			iSegLen,
			iftPrevious);

		RetVal = WIN::SetWindowLongPtr(pWndSeg, GWLP_WNDPROC, (LONG_PTR)ControlProc);
		if (RetVal == 0)
		{
			return PostErrorDlgKey(Imsg(idbgCreateControlWindow));
		}

		WIN::SetWindowLongPtr(pWndSeg, GWLP_USERDATA, (LONG_PTR)this);
#else			// win-32. This should be removed with the 64-bit windows.h is #included.
		m_pSegInfo[m_cSegments].SetSegInfo(
			pWndSeg,
			(WNDPROC)WIN::GetWindowLong(pWndSeg, GWL_WNDPROC),
			iSegLen,
			iftPrevious);

		RetVal = WIN::SetWindowLong(pWndSeg, GWL_WNDPROC, (long)ControlProc);
		if (RetVal == 0)
		{
			return PostErrorDlgKey(Imsg(idbgCreateControlWindow));
		}

		WIN::SetWindowLong(pWndSeg, GWL_USERDATA, (long)this);
#endif

		if (iftLiteral != iftPrevious && iftSegSep != iftPrevious)
		{
			WIN::SendMessage(pWndSeg, EM_LIMITTEXT, iSegLen, 0);
			strValueSegment = strValue.Extract(iseTrim, iSegLen);
			if (iftNumeric == iftPrevious && iMsiNullInteger == (int) strValueSegment)
			{
				strValue = strNull;
			}
			else if ( strValueSegment.TextSize() )
			{
				WIN::SetWindowText (pWndSeg, strValueSegment);
			}
		}

		if (iftCurrent == iftSegSep && 1 < iSegLen)
		{
			// We inc'ed iSegLen so the SegSep would be included in the
			// character count, but we don't want to delete the SegSep char yet.
			// Next time throught the loop we'll handle adding the '-' literal

			--iSegLen; // force the seg include the separator in the segment char count
		}

		strValue.Remove(iseFirst, iSegLen);

		iLeft += rect.right + 2;
		++m_cSegments;

		// work-around Windows 95 bug (problem).
		//
		// "After you change the font in an edit control in Windows 95,
		// the left and right margins are unusually large."
		//
		// For more information see KB Article ID: Q138419
		ULONG_PTR dwMargins = WIN::SendMessage(pWndSeg, EM_GETMARGINS, 0, 0);		//--merced: changed DWORD to ULONG_PTR
		if (pWndSeg)
		{
			PAINTSTRUCT psSeg;
			HDC hdcSeg = WIN::BeginPaint(pWndSeg, &psSeg);
			IMsiRecord* piRecordSeg = ChangeFontStyle(hdcSeg, *m_strCurrentStyle, pWndSeg);
			WIN::EndPaint(pWndSeg, &psSeg);
		}
		WIN::SendMessage(pWndSeg, EM_SETMARGINS, 
							  EC_LEFTMARGIN | EC_RIGHTMARGIN,
							  MAKELPARAM(LOWORD(dwMargins), HIWORD(dwMargins)));
	}

	WIN::EndPaint(m_pWnd, &ps);
	return 0;
}

IMsiRecord* CMsiMaskedEdit::Undo()
{
	Ensure(CMsiActiveControl::Undo());
	Ensure(Repaint());
	Ensure(SetVisible(m_fVisible));
	Ensure(SetEnabled(m_fEnabled));
	return 0;
}

IMsiRecord* CMsiMaskedEdit::SetVisible(Bool fVisible)
{
	m_fVisible = fVisible;
	WIN::ShowWindow(m_pWnd, m_fVisible ? SW_SHOW : SW_HIDE);
	int i;
	for (i = 0; i < m_cSegments; i++)
		WIN::ShowWindow(m_pSegInfo[i].m_winrSegment, m_fVisible ? SW_SHOW : SW_HIDE);
	return 0;
}

IMsiRecord* CMsiMaskedEdit::SetEnabled(Bool fEnabled)
{
	m_fEnabled = fEnabled;
	WIN::EnableWindow(m_pWnd, fEnabled);
	int i;
	for (i = 0; i < m_cSegments; i++)
		WIN::EnableWindow(m_pSegInfo[i].m_winrSegment, fEnabled);
	return 0;
}

IMsiRecord* CMsiMaskedEdit::SetFocus(WPARAM wParam, LPARAM lParam)
{
	if ( m_cSegments > 0 )
	{
		//  I set the focus to the first edit window.
		for ( int i=0; i < m_cSegments; i++ )
			if ( m_pSegInfo[i].m_ift == iftNumeric ||
				  m_pSegInfo[i].m_ift == iftText )
			{
				WIN::SetFocus(m_pSegInfo[i].m_winrSegment);
				break;
			}
	}
	return CMsiActiveControl::SetFocus(wParam, lParam);
}

INT_PTR CALLBACK CMsiMaskedEdit::ControlProc(WindowRef pWnd, WORD message, WPARAM wParam, LPARAM lParam)	//--merced: changed return from int to INT_PTR
{
#ifdef _WIN64	// !merced
	CMsiMaskedEdit* pControl = (CMsiMaskedEdit*)WIN::GetWindowLongPtr(pWnd, GWLP_USERDATA);
	LONG_PTR iID = WIN::GetWindowLongPtr(pWnd, GWLP_ID);
#else		// win-32. This should be removed with the 64-bit windows.h is #included.
	CMsiMaskedEdit* pControl = (CMsiMaskedEdit*)WIN::GetWindowLong(pWnd, GWL_USERDATA);
	long iID = WIN::GetWindowLong(pWnd, GWL_ID);
#endif
	static HKL hklLocalKbd;
	static HIMC hIMC = NULL;
	static Bool fIsIMEOpen;

	switch (message)
	{
	case WM_KILLFOCUS:
		{
			if ( pControl->SwitchLang() )
			{
				if ( !pControl->IsIMEonMachine() )
					//  I set back the keyboard to the user's
					WIN::ActivateKeyboardLayout(hklLocalKbd, 0);
				else if ( hIMC )
				{
					//  I enable IME
					WIN::ImmAssociateContext(pWnd, hIMC);
					WIN::ImmSetOpenStatus(hIMC, fIsIMEOpen);
				}
			}


			// v-jhark 01-16-98
			//
			// This is how the old (PID 2.0) version of the code managed
			// the Property value.	It would seem to make more sense to
			// overide:
			//
			//	   GetPropertyValue()
			//	   SetPropertyValue()
			//
			// and while your at it also:
			//
			//	   GetText()
			//	   SetText()
			//
			// On slow machines there can be a delay the first time the user
			// moves from the first segment to the second segment. At that
			// time we get a WM_KILLFOCUS message as focus leaves the first
			// segment.  The current organization caused or contributes to
			// this dealy.

			MsiString strValue;
			int iSegment = 0;
			for (iSegment = 0; iSegment < pControl->m_cSegments; iSegment++)
			{
				// v-jhark 01-15-98
				// The old version of this code (the one that supported PID 2.0)
				// used to delete the '-' used for the segment separator.  This
				// new version was originally written to leave them in, and
				// changes were made so ValidateProductID() expected the
				// segment separators to be marked with a '-'. But this
				// created an inter-dependency between ValidateProductID
				// (implemented in engine\engine.cpp) and this code. So
				// we're back to leaving out the '-'

				if (iftSegSep != pControl->m_pSegInfo[iSegment].m_ift)
				{
					int iLength = WIN::GetWindowTextLength(pControl->m_pSegInfo[iSegment].m_winrSegment);
					ICHAR *Buffer = new ICHAR[iLength + 1];
					if ( ! Buffer )
						return 0;
					WIN::GetWindowText(pControl->m_pSegInfo[iSegment].m_winrSegment, Buffer, iLength + 1);
					MsiString text(Buffer);
					delete[] Buffer;
					strValue += text;
					for (int i = iLength; i < pControl->m_pSegInfo[iSegment].m_iLength; i++)
					{
						strValue += MsiString(*TEXT(" ")); // pad the string with spaces so the segment has the required length
					}
				}
			}
			if (PMsiRecord(pControl->SetPropertyValue(*strValue, fTrue)))
			{
				PMsiEvent piDialog = &pControl->GetDialog();
				piDialog->SetErrorRecord(*pControl->PostError(Imsg(idbgSettingPropertyFailed), *pControl->m_strPropertyName));
				return 0;
			}
		}
		break;

	case WM_KEYDOWN:

		// v-jhark 01-15-97
		// This is what the old (PID 2.0) version of the code did.
		// But if we are going to support using back-space to
		// automatically jump between segments, then shouldn't we
		// also support the left-arrow and right-arrrow?  For
		// the right-arrow we should only skip if number of characters
		// in the segment equals the segment length.

		if (wParam == VK_BACK)
		{
			if (WIN::GetWindowTextLength(pControl->m_pSegInfo[iID].m_winrSegment) > 1)
				break;
			for (INT_PTR iSegment = iID - 1; iSegment >= 0; iSegment--)		//--merced: changed int to INT_PTR
			{
				if (iftNumeric == pControl->m_pSegInfo[iSegment].m_ift ||
					iftText == pControl->m_pSegInfo[iSegment].m_ift)
				{
					// we found a previous edit field
					WIN::SetFocus(WIN::GetNextDlgTabItem(pControl->m_pWndDialog, pControl->m_pSegInfo[iID].m_winrSegment, fTrue));; // jump to previous edit field
					break;
				}
			}
		}
		break;

	case WM_SETFOCUS:
		{
			if ( pControl->SwitchLang() )
			{
				if ( !pControl->IsIMEonMachine() )
				{
					//  since this field can get only ANSI chars, I set the
					//  keyboard to "English".
					AssertNonZero(hklLocalKbd = WIN::GetKeyboardLayout(0));
					HKL hklEngKbd = pControl->GetEnglishKbd();
					if ( hklEngKbd )
						WIN::ActivateKeyboardLayout(hklEngKbd, 0);
				}
				else
				{
					hIMC = WIN::ImmGetContext(pWnd);
					fIsIMEOpen = ToBool(WIN::ImmSetOpenStatus(hIMC, fFalse));
					WIN::ImmReleaseContext(pWnd, hIMC);
					//  I disable IME for this window
					hIMC = WIN::ImmAssociateContext(pWnd, NULL);
				}
			}

			//	 (the default window procedure doesn't always do this)
			WIN::SendMessage(pWnd, EM_SETSEL, 0, -1);
		}
		break;
	}

	return WIN::CallWindowProc((WNDPROC)pControl->m_pSegInfo[iID].m_pfBaseWinProc, pWnd, message, wParam, lParam);
}

IMsiRecord* CMsiMaskedEdit::Command(WPARAM wParam, LPARAM lParam)
{
	if (HIWORD(wParam) != EN_CHANGE)
		return 0;

	// the control changed

	int idEditCtrl = (int) LOWORD(wParam);
	WindowRef winrEditCtrl = (WindowRef) lParam;
	int iLength = WIN::GetWindowTextLength(winrEditCtrl);

	if (iLength < m_pSegInfo[idEditCtrl].m_iLength)
		return 0;

	// user filled in the length of the segemnt, it's time to jump to the next segment

	// scan segemnts following the current segment
	for (int iSegment = idEditCtrl + 1; iSegment < m_cSegments; iSegment++)
	{
		// search for a user input segment
		if (iftNumeric == m_pSegInfo[iSegment].m_ift ||
			iftText == m_pSegInfo[iSegment].m_ift)
		{
			// set the focus the the next user input segment
			WIN::SetFocus(WIN::GetNextDlgTabItem(m_pWndDialog, winrEditCtrl, fFalse));; // jump to next edit field
			return 0;
		}
	}
	return 0;
}




IMsiControl* CreateMsiMaskedEdit(IMsiEvent& riDialog)
{
	return new CMsiMaskedEdit(riDialog);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\darwjpeg.cpp ===
#ifdef JPEGTEST
    #include "stdafx.h"
#endif

#include "DarwJPEG.h"

#ifndef JPEGTEST
#undef  ASSERT
#define ASSERT Assert
#endif

extern "C"{
#include "jerror.h"
}

// dummy implementation. just shoves all the data at once.
// the thing to do is to get the bimap drawing code working
// first and then come back and do buffered reads from the
// stream after we know the bitmap code works.
CDarwinDatasource::CDarwinDatasource (LPBYTE pData, unsigned int len) :
    m_buffer ((JOCTET*) pData),
    m_dataLen (len)
{
}

CDarwinDatasource::~CDarwinDatasource ()
{
}

void CDarwinDatasource::InitSource (j_decompress_ptr /*cinfo*/)
{
    m_fStartOfFile = fTrue;
}

boolean CDarwinDatasource::FillInputBuffer (j_decompress_ptr cinfo)
{
    if (m_fStartOfFile)
    {
        if (0 == m_dataLen)
            ERREXIT(cinfo, JERR_INPUT_EMPTY);
        cinfo->src->next_input_byte = m_buffer;
        cinfo->src->bytes_in_buffer = m_dataLen;
    }
    else
    {
        WARNMS(cinfo, JWRN_JPEG_EOF);
        // insert a fake EOI marker
        static JOCTET eoiBuf [2] = {0xFF, JPEG_EOI};
        cinfo->src->next_input_byte = eoiBuf;
        cinfo->src->bytes_in_buffer = 2;
    }

    m_fStartOfFile = fFalse;
    return (fTrue);
}

void CDarwinDatasource::SkipInputData (j_decompress_ptr cinfo, long num_bytes)
{
    cinfo->src->next_input_byte += (size_t) num_bytes;
    cinfo->src->bytes_in_buffer -= (size_t) num_bytes;

}

void CDarwinDatasource::TermSource (j_decompress_ptr /*cinfo*/)
{
}

CDarwinDecompressor::CDarwinDecompressor ()
{
    m_fUseDefaultPalette = fTrue;
    m_hBitmap = 0;
    m_hPalette = 0;
    m_pBits = 0;
    m_rowBytes = 0;
    HDC hdc = GetDC (0);
    m_depth = GetDeviceCaps (hdc, BITSPIXEL);
    // note: the jpeg library can't do 4 color mode, so
    // we do monochrome instead.
    if (2 == m_depth)
        m_depth = 1;
    ReleaseDC (0, hdc);
}

CDarwinDecompressor::~CDarwinDecompressor ()
{
    // normally this is deleted at the end of EndDecompression,
    // but if we error out prematurely it will need to be
    // taken care of here.

    if (m_pBits)
        delete[] m_pBits;
}

Bool CDarwinDecompressor::Decompress (HBITMAP& rhBitmap,
    HPALETTE& rhPalette, Bool fUseDefaultPalette, CDarwinDatasource* dataSource)
{

    m_fUseDefaultPalette = fUseDefaultPalette;
    Bool result = ToBool(CJPEGDecompressor::Decompress (dataSource));
    if (!result)
    {
        if (m_hBitmap)
        {
            WIN::DeleteObject (m_hBitmap);
            m_hBitmap = 0;
        }
        if (m_hPalette)
        {
            WIN::DeleteObject (m_hPalette);
            m_hPalette = 0;
        }
    }

    rhBitmap = m_hBitmap;
    rhPalette = m_hPalette;
    return result;
}

void CDarwinDecompressor::BeginDecompression ()
{
    m_rowBytes = ((((m_archive.cinfo.output_width * m_depth) + 31) & ~31) >> 3);
    unsigned long imageSize =  m_rowBytes * m_archive.cinfo.output_height;

    m_pBits = new BYTE [imageSize];
    if (0 == m_pBits)
        ERREXIT(&m_archive.cinfo, JERR_OUT_OF_MEMORY);
}

void CDarwinDecompressor::StoreScanline (void* buffer, int row)
{
    int i;
    BYTE* src = (BYTE*) buffer;
    BYTE* dest = m_pBits + m_rowBytes * (row - 1);

    switch (m_depth)
    {
    case 1:
        for (i = 0; i < (int) m_archive.cinfo.output_width / 8; i++)
        {
            *dest++ = (BYTE)(((int)(src [0]) << 7) |
                            ((int)(src [1]) << 6) |
                            ((int)(src [2]) << 5) |
                            ((int)(src [3]) << 4) |
                            ((int)(src [4]) << 3) |
                            ((int)(src [5]) << 2) |
                            ((int)(src [6]) << 1) |
                            (int)(src [7]));
            src += 8;
        }
        break;
    case 2:
        ASSERT(fFalse); // we don't do this mode; it was supposed to be set to 1
        break;
    case 4:
        for (i = 0; i < (int) m_archive.cinfo.output_width / 2; i++)
        {
            *dest++ = (BYTE)(((int)(src [0]) << 4) | src [1]);
            src += 2;
        }
        break;
    case 8:
        for (i = 0; i < (int) m_archive.cinfo.output_width; i++)
            *dest++ = *src++;
        break;

    case 16:
        {
        WORD* pwDest = (WORD*) dest;
        if (m_archive.cinfo.out_color_space == JCS_GRAYSCALE)
        {
            for (i = 0; i < (int) m_archive.cinfo.output_width; i++)
            {
                int c = ((int)(*src++ * 0x1F) / 0xFF);
                *pwDest++ = (WORD)((c << 10) | (c << 5) | c);
            }
        }
        else
        {
            for (i = 0; i < (int) m_archive.cinfo.output_width; i++)
            {
                *pwDest++ = (WORD)((((int)(src [0] * 0x1F) / 0xFF) << 10) |
                                    (((int)(src [1] * 0x1F) / 0xFF) << 5) |
                                    ((int)(src [2] * 0x1F) / 0xFF));
                src += 3;
            }
        }
        }
        break;

    case 24:
    case 32:

        if (m_archive.cinfo.out_color_space == JCS_GRAYSCALE)
        {
            for (i = 0; i < (int) m_archive.cinfo.output_width; i++)
            {
                *dest++ = *src;     // grayscale means R == G == B
                *dest++ = *src;
                *dest++ = *src++;
                if (m_depth == 32)
                    *dest++ = 0;
            }
        }
        else
        {
            for (i = 0; i < (int) m_archive.cinfo.output_width; i++)
            {
                *dest++ = src [2];  // 2 B  note: mac uses A,R,G,B,
                *dest++ = src [1];  // 1 G  so for the mac case you
                *dest++ = src [0];  // 0 R  can just write:
                if( m_depth == 32)  // n A      *dest++ = *src++;
                    *dest++ = 0;

                src += 3;
            }
        }
        break;
    default:
        ASSERT(fFalse);
        break;
    }

}


static HPALETTE BuildPalette (RGBQUAD* rgbEntries, int nEntries)
{

    HANDLE hPalMem;
    LOGPALETTE* pPal;
    HPALETTE hPal;

    hPalMem = LocalAlloc (LMEM_MOVEABLE, sizeof(LOGPALETTE) + nEntries * sizeof(PALETTEENTRY));
    if (!hPalMem) return NULL;
    pPal = (LOGPALETTE*) LocalLock (hPalMem);
    pPal-> palVersion = 0x300;
    pPal-> palNumEntries = (WORD) nEntries; // table size
    for (int i = 0; i < nEntries; i++) {
        pPal-> palPalEntry [i].peRed = rgbEntries[i].rgbRed;
        pPal-> palPalEntry [i].peGreen = rgbEntries[i].rgbGreen;
        pPal-> palPalEntry [i].peBlue = rgbEntries[i].rgbBlue;
        pPal-> palPalEntry [i].peFlags = 0;

        // useful for debugging tool: take a look at the palette
        // coming out of the jpeg decompressor.
//#define DUMP_PALETTE
#ifdef DUMP_PALETTE
        char buffer [256];
        wsprintf (buffer, "{%#4.2x, %#4.2x, %#4.2x},\n",
            (int)rgbEntries[i].rgbRed, (int)rgbEntries[i].rgbGreen, (int)rgbEntries[i].rgbBlue);
        OutputDebugString (buffer);
#endif
    }

    hPal = CreatePalette (pPal);
    LocalUnlock (hPalMem);
    LocalFree (hPalMem);

    return hPal;
}

void CDarwinDecompressor::EndDecompression ()
{
    switch (m_depth)
    {
    case 2:
        ASSERT(fFalse); // we don't do this mode; it was supposed to be set to 1
        break;
    case 1:
    case 4:
    case 8:
        {
            HPALETTE hPalSave = 0;
            HDC hdc = GetDC (0);
            if (0 == hdc)
                ERREXIT(&m_archive.cinfo, JERR_OUT_OF_MEMORY);

            // ToDo: allocate this at the appropriate size.
            // it is too big to be on the stack.
            typedef struct BitmapData
            {
                BITMAPINFOHEADER    bmiHeader;
                RGBQUAD rgbColors [256];
            } BitmapData, *BitmapPtr;

            BitmapData bmd;
            memset(&bmd, 0, sizeof(bmd));

            //!! ToDo: this is a problem, if we are set to use the
            // default palette.
            if (m_archive.cinfo.out_color_space == JCS_GRAYSCALE) // grayscale image
            {
                for (int i = 0; i < m_archive.cinfo.actual_number_of_colors; i++)
                {
                    bmd.rgbColors [i].rgbRed =
                    bmd.rgbColors [i].rgbGreen =
                    bmd.rgbColors [i].rgbBlue = m_archive.cinfo.colormap [0][i];
                }
            }
            else
            {

                for (int i = 0; i < m_archive.cinfo.actual_number_of_colors; i++)
                {
                    bmd.rgbColors [i].rgbRed = m_archive.cinfo.colormap [0][i];
                    bmd.rgbColors [i].rgbGreen = m_archive.cinfo.colormap [1][i];
                    bmd.rgbColors [i].rgbBlue = m_archive.cinfo.colormap [2][i];
                }
            }

            m_hPalette = BuildPalette (bmd.rgbColors, m_archive.cinfo.actual_number_of_colors);

            if (m_hPalette)
            {
                hPalSave = SelectPalette (hdc, m_hPalette, fFalse);
                RealizePalette (hdc);
            }
            m_hBitmap = CreateCompatibleBitmap(hdc,
                m_archive.cinfo.output_width,
                m_archive.cinfo.output_height);

            int result;
            DWORD err;
            if (m_hBitmap)
            {
                bmd.bmiHeader.biSize = sizeof(bmd.bmiHeader);
                bmd.bmiHeader.biWidth = m_archive.cinfo.output_width;
                bmd.bmiHeader.biHeight = -1 * m_archive.cinfo.output_height;
                bmd.bmiHeader.biPlanes = 1;
                bmd.bmiHeader.biBitCount = (WORD) m_depth;
                bmd.bmiHeader.biCompression = BI_RGB;
                bmd.bmiHeader.biClrUsed = m_archive.cinfo.actual_number_of_colors;

                result = SetDIBits (hdc, m_hBitmap, 0,
                    m_archive.cinfo.output_height, m_pBits,
                    (BITMAPINFO*) &bmd, DIB_RGB_COLORS);
                if (!result)
                    err = GetLastError ();
            }

            if (hPalSave)
                SelectPalette (hdc, hPalSave, fFalse);
            ReleaseDC (0,hdc);
            break;
        }

    case 16:
    case 24:
    case 32:
        {
            HDC hdc = GetDC (0);
            if (0 == hdc)
                ERREXIT(&m_archive.cinfo, JERR_OUT_OF_MEMORY);

            //!! ToDo: dont need RGBQUADs here
            typedef struct BitmapData
            {
                BITMAPINFOHEADER    bmiHeader;
                RGBQUAD rgbColors [256];
            } BitmapData, *BitmapPtr;

            BitmapData bmd;
            memset(&bmd, 0, sizeof(bmd));

            m_hBitmap = CreateCompatibleBitmap(hdc,
                m_archive.cinfo.output_width,
                m_archive.cinfo.output_height);

            int result;
            DWORD err;
            if (m_hBitmap)
            {
                bmd.bmiHeader.biSize = sizeof(bmd.bmiHeader);
                bmd.bmiHeader.biWidth = m_archive.cinfo.output_width;
                bmd.bmiHeader.biHeight = -1 * m_archive.cinfo.output_height;
                bmd.bmiHeader.biPlanes = 1;
                bmd.bmiHeader.biBitCount = (WORD) m_depth;
                bmd.bmiHeader.biCompression = BI_RGB;

                result = SetDIBits (hdc, m_hBitmap, 0,
                    m_archive.cinfo.output_height, m_pBits,
                    (BITMAPINFO*) &bmd, DIB_RGB_COLORS);
                if (!result)
                    err = GetLastError ();
            }

            ReleaseDC (0,hdc);
            break;
        }
    }

    if (m_pBits)
    {
        delete[] m_pBits;
        m_pBits = 0;
    }

    if (0 == m_hBitmap)
        ERREXIT(&m_archive.cinfo, JERR_OUT_OF_MEMORY);
}

// Error API

void CDarwinDecompressor::ErrorExit ()
{
#ifdef DEBUG
    DebugBreak();
#endif
}

void CDarwinDecompressor::EmitMessage (int /*msg_level*/)
{
}

void CDarwinDecompressor::OutputMessage ()
{
}

void CDarwinDecompressor::FormatMessage (char* /*buffer*/)
{
}

void CDarwinDecompressor::ResetErrorManager ()
{
}

void CDarwinDecompressor::BuildColorMap ()
{
    switch (m_depth)
    {
    case 2:
        ASSERT(fFalse); // we don't do this mode; it was supposed to be set to 1
        break;
    case 1:
        // the jpeg library can't dither to fewer than
        // 8 colors. so we will use grayscale dithering
        // in 2 and 4 color mode.
        m_archive.cinfo.out_color_space = JCS_GRAYSCALE;
        m_archive.cinfo.quantize_colors = fTrue;
        m_archive.cinfo.desired_number_of_colors = 1 << m_depth;
        m_archive.cinfo.dither_mode = JDITHER_FS;
        m_archive.cinfo.two_pass_quantize = fFalse;
        break;
    case 4:
        m_archive.cinfo.quantize_colors = fTrue;
        m_archive.cinfo.desired_number_of_colors = 1 << m_depth;
        m_archive.cinfo.two_pass_quantize = fTrue;
        m_archive.cinfo.dither_mode = JDITHER_FS;
        break;
    case 8:
        if (m_fUseDefaultPalette)
        {
            // note: we don't free the colorMap because the jpeg allocator
            // frees all the memory allocated by it when it is done.
            JSAMPARRAY colorMap = 0;
            int nEntries = CreateDefaultColorMap (colorMap);
            if (!nEntries)
                break;
            m_archive.cinfo.quantize_colors = fTrue;
            m_archive.cinfo.actual_number_of_colors = nEntries;
            m_archive.cinfo.dither_mode = JDITHER_FS;
            m_archive.cinfo.colormap = colorMap;
        }
        else
        {
            m_archive.cinfo.quantize_colors = fTrue;
            m_archive.cinfo.desired_number_of_colors = 1 << m_depth;
            m_archive.cinfo.two_pass_quantize = fTrue;
            m_archive.cinfo.dither_mode = JDITHER_FS;
        }
        break;

    case 16:
    case 24:
    case 32:
    default:
        break;
    }
}

typedef struct PaletteRecord
{
    unsigned char red;
    unsigned char green;
    unsigned char blue;
} PaletteRecord, *PalettePtr;

PaletteRecord default8BitPalette [256] = {
    {  0x17,   0x1d,   0x16},
    {  0x18,   0x86,   0xa8},
    {  0x95,   0x0a,   0x0e},
    {  0x24,   0x4c,   0x2a},
    {  0x87,   0x47,   0x2b},
    {  0x91,   0x84,   0x4c},
    {  0xd0,   0x45,   0x2f},
    {  0x4f,   0x50,   0x36},
    {  0x9e,   0xc4,   0xc5},
    {  0x98,   0x65,   0x27},
    {  0x54,   0x1c,   0x0e},
    {  0x59,   0x68,   0x41},
    {  0x63,   0x83,   0x6a},
    {  0xce,   0x0b,   0x1e},
    {  0xd0,   0x85,   0x34},
    {  0x5f,   0xa8,   0xc1},
    {  0x88,   0x68,   0x5f},
    {  0x48,   0x32,   0x21},
    {  0x99,   0xa2,   0x77},
    {  0x43,   0x67,   0x3f},
    {  0xa8,   0x47,   0x38},
    {  0x87,   0x29,   0x1d},
    {  0x5a,   0x88,   0x97},
    {  0x4e,   0x70,   0x70},
    {  0x57,   0x53,   0x4f},
    {  0xdb,   0xc8,   0xae},
    {  0x68,   0x33,   0x1f},
    {  0xc4,   0x6e,   0x18},
    {  0x8f,   0x88,   0x89},
    {  0x14,   0x31,   0x23},
    {  0xa8,   0x29,   0x1f},
    {  0x38,   0x4e,   0x28},
    {  0xa8,   0x68,   0x67},
    {  0xa8,   0x67,   0x1f},
    {  0x88,   0x49,   0x41},
    {  0x31,   0x52,   0x58},
    {  0xc8,   0x29,   0x22},
    {  0x76,   0x51,   0x1f},
    {  0xd1,   0xe6,   0xf0},
    {  0x74,   0x69,   0x40},
    {  0x57,   0x9b,   0xaf},
    {  0x2a,   0x6b,   0x7a},
    {  0xb0,   0x4f,   0x50},
    {  0x31,   0x36,   0x27},
    {  0x70,   0x97,   0x88},
    {  0xb0,   0x86,   0x44},
    {  0xe6,   0x48,   0x33},
    {  0xaf,   0xa4,   0x83},
    {  0x4b,   0x9a,   0xac},
    {  0x73,   0xbb,   0xd8},
    {  0xce,   0xa6,   0x84},
    {  0x6f,   0x40,   0x1f},
    {  0xe4,   0x28,   0x2c},
    {  0x67,   0x1d,   0x11},
    {  0x4f,   0x41,   0x26},
    {  0x72,   0x6d,   0x70},
    {  0x88,   0x36,   0x21},
    {  0x7a,   0x85,   0x66},
    {  0x33,   0x5c,   0x41},
    {  0xce,   0x68,   0x63},
    {  0x3e,   0x6d,   0x75},
    {  0xb7,   0x76,   0x28},
    {  0xa8,   0x38,   0x2d},
    {  0xa8,   0x78,   0x67},
    {  0x73,   0x53,   0x50},
    {  0x7d,   0xa9,   0xaf},
    {  0xf9,   0xe7,   0xd2},
    {  0xb0,   0x87,   0x89},
    {  0x8d,   0x78,   0x60},
    {  0xd1,   0x38,   0x26},
    {  0x47,   0x84,   0x8e},
    {  0xce,   0x56,   0x3e},
    {  0xaf,   0x0f,   0x14},
    {  0x55,   0x5e,   0x3e},
    {  0x88,   0x57,   0x28},
    {  0xa4,   0xdb,   0xf0},
    {  0x7a,   0x9d,   0x9e},
    {  0x27,   0x1d,   0x16},
    {  0x88,   0x75,   0x44},
    {  0x88,   0x58,   0x48},
    {  0x90,   0xac,   0xb0},
    {  0xa7,   0x58,   0x37},
    {  0x58,   0x78,   0x61},
    {  0x33,   0x38,   0x35},
    {  0xd0,   0x89,   0x7e},
    {  0x42,   0x88,   0xa1},
    {  0x55,   0x7b,   0x75},
    {  0xb2,   0xc6,   0xcb},
    {  0x74,   0x5e,   0x36},
    {  0x41,   0x78,   0x7d},
    {  0x73,   0x79,   0x5d},
    {  0xaf,   0x96,   0x62},
    {  0x39,   0x50,   0x3d},
    {  0x71,   0x27,   0x19},
    {  0x50,   0x36,   0x2f},
    {  0xea,   0x66,   0x4d},
    {  0x5f,   0x86,   0x80},
    {  0x8f,   0x39,   0x30},
    {  0x32,   0x5e,   0x61},
    {  0x70,   0x36,   0x2e},
    {  0x53,   0x5f,   0x54},
    {  0x28,   0x27,   0x1f},
    {  0x91,   0xb5,   0xbc},
    {  0x9c,   0x93,   0x66},
    {  0x70,   0x42,   0x33},
    {  0x51,   0x6c,   0x59},
    {  0x94,   0x99,   0x8f},
    {  0x58,   0xa1,   0xbe},
    {  0x60,   0x50,   0x36},
    {  0xac,   0x69,   0x34},
    {  0xf6,   0xf8,   0xf8},
    {  0x77,   0x8f,   0x97},
    {  0xb8,   0x38,   0x2c},
    {  0x8d,   0x79,   0x7c},
    {  0xf7,   0xc7,   0xb3},
    {  0xc8,   0x7b,   0x29},
    {  0x98,   0x57,   0x4a},
    {  0x46,   0x92,   0xaa},
    {  0x8e,   0x68,   0x3f},
    {  0x48,   0x28,   0x1d},
    {  0x50,   0x43,   0x39},
    {  0xd0,   0x3a,   0x36},
    {  0x23,   0x41,   0x2f},
    {  0xae,   0x5a,   0x57},
    {  0xb3,   0x78,   0x85},
    {  0xb6,   0x68,   0x6a},
    {  0x77,   0xb1,   0xcb},
    {  0xd1,   0x48,   0x3f},
    {  0x30,   0x41,   0x2a},
    {  0xf5,   0xa7,   0x8e},
    {  0xea,   0x6e,   0x5d},
    {  0xf0,   0x8a,   0x76},
    {  0xb8,   0xa9,   0xab},
    {  0x20,   0x52,   0x5b},
    {  0xd1,   0xa9,   0xa0},
    {  0xd9,   0xcf,   0xd1},
    {  0xe8,   0x83,   0x64},
    {  0xda,   0x97,   0x7c},
    {  0xe7,   0x55,   0x42},
    {  0xcf,   0x78,   0x67},
    {  0xcb,   0x19,   0x21},
    {  0xf5,   0xd9,   0xc6},
    {  0xf8,   0xb6,   0xa3},
    {  0xaf,   0x99,   0x90},
    {  0xb0,   0xba,   0xba},
    {  0xd0,   0x93,   0x43},
    {  0x88,   0x1b,   0x13},
    {  0xd0,   0xb7,   0xa2},
    {  0x14,   0x7d,   0x97},
    {  0x42,   0x68,   0x5b},
    {  0xb1,   0xcc,   0xde},
    {  0x23,   0x5d,   0x66},
    {  0xc0,   0xdd,   0xeb},
    {  0xe5,   0x39,   0x2d},
    {  0xf3,   0x97,   0x7b},
    {  0xe2,   0xf3,   0xf7},
    {  0xa0,   0xd0,   0xe4},
    {  0x94,   0xaf,   0xa2},
    {  0xb5,   0x89,   0x65},
    {  0x5f,   0xab,   0xcd},
    {  0x73,   0x5e,   0x55},
    {  0xb0,   0x1b,   0x1a},
    {  0x2c,   0x90,   0xac},
    {  0xd7,   0xb1,   0x87},
    {  0x24,   0x5a,   0x47},
    {  0x49,   0x9d,   0xbb},
    {  0x97,   0x88,   0x67},
    {  0xce,   0x67,   0x4b},
    {  0x94,   0x99,   0xa8},
    {  0xcb,   0x7a,   0x45},
    {  0xd4,   0x98,   0xa2},
    {  0x1a,   0x27,   0x1e},
    {  0xd0,   0x89,   0x4d},
    {  0xde,   0xcf,   0xb8},
    {  0xd1,   0xdc,   0xe5},
    {  0x76,   0x8d,   0x82},
    {  0x71,   0x7b,   0x76},
    {  0x32,   0x43,   0x37},
    {  0xb7,   0xd0,   0xcf},
    {  0xb9,   0xaf,   0x95},
    {  0xb1,   0x79,   0x3a},
    {  0xcc,   0x58,   0x50},
    {  0xcb,   0x7a,   0x85},
    {  0x43,   0x73,   0x62},
    {  0xf1,   0xec,   0xef},
    {  0xec,   0xae,   0xbc},
    {  0xdd,   0x1b,   0x23},
    {  0x60,   0x90,   0x9c},
    {  0x49,   0x8f,   0x93},
    {  0xe4,   0x72,   0x51},
    {  0xea,   0x7b,   0x63},
    {  0x99,   0xc6,   0xdd},
    {  0x8e,   0xa6,   0x9e},
    {  0x4f,   0x7d,   0x8e},
    {  0x7e,   0x99,   0x88},
    {  0x98,   0x47,   0x2e},
    {  0x98,   0x67,   0x5d},
    {  0x98,   0x29,   0x1f},
    {  0xb8,   0x29,   0x21},
    {  0xd7,   0x29,   0x27},
    {  0x7f,   0xbc,   0xd6},
    {  0xb7,   0x57,   0x3d},
    {  0xe0,   0x88,   0x76},
    {  0xbf,   0x95,   0x5a},
    {  0x9e,   0xb9,   0xbb},
    {  0xf5,   0x57,   0x40},
    {  0xc0,   0x99,   0x8b},
    {  0xbf,   0xb8,   0xae},
    {  0x22,   0x44,   0x49},
    {  0x6b,   0xb2,   0xc4},
    {  0x74,   0x4f,   0x39},
    {  0x73,   0x6c,   0x58},
    {  0x5f,   0x6d,   0x70},
    {  0x22,   0x35,   0x28},
    {  0xe0,   0xea,   0xf0},
    {  0xbf,   0x88,   0x8f},
    {  0x98,   0x59,   0x25},
    {  0xde,   0xa9,   0xa5},
    {  0x98,   0x1a,   0x17},
    {  0xdd,   0xb9,   0x9f},
    {  0x2a,   0x85,   0xa0},
    {  0x64,   0x8e,   0x69},
    {  0xc1,   0xa5,   0x8a},
    {  0xdf,   0xa5,   0x89},
    {  0x41,   0x5d,   0x46},
    {  0x67,   0x8f,   0x88},
    {  0x40,   0x5f,   0x5b},
    {  0x38,   0x27,   0x1d},
    {  0x58,   0x27,   0x1a},
    {  0x2b,   0x7a,   0x93},
    {  0xb6,   0xd4,   0xe5},
    {  0x69,   0xb3,   0xd1},
    {  0x4c,   0xa6,   0xc5},
    {  0x7e,   0xb2,   0xb9},
    {  0xe4,   0x90,   0x50},
    {  0x23,   0x4c,   0x3d},
    {  0x3e,   0x7b,   0x90},
    {  0xa0,   0x86,   0x4a},
    {  0x58,   0x32,   0x1f},
    {  0xb8,   0x47,   0x38},
    {  0x78,   0x32,   0x20},
    {  0xdc,   0x64,   0x34},
    {  0xa0,   0x8a,   0x83},
    {  0xb6,   0x6c,   0x1e},
    {  0x97,   0x49,   0x41},
    {  0x3f,   0x54,   0x57},
    {  0x69,   0x9a,   0xa4},
    {  0x29,   0x70,   0x8f},
    {  0xc0,   0x85,   0x3d},
    {  0x79,   0x1c,   0x11},
    {  0x97,   0x36,   0x21},
    {  0x3b,   0x71,   0x8d},
    {  0xb8,   0x77,   0x63},
    {  0x76,   0xa2,   0xb6},
    {  0x38,   0x1c,   0x15},
    {  0x99,   0x78,   0x41}
    };

int CDarwinDecompressor::CreateDefaultColorMap (JSAMPARRAY& colorMap)
{
    const int nEntries = 256;

    // note: we don't check this allocation because the jpeg allocator
    // calls ERREXIT when it fails
    colorMap = (*m_archive.cinfo.mem->alloc_sarray)((j_common_ptr)
        &m_archive.cinfo, JPOOL_IMAGE, 3, nEntries);

    for (int i = 0; i < nEntries; i++)
    {
        colorMap [0][i] = default8BitPalette [i].red;
        colorMap [1][i] = default8BitPalette [i].green;
        colorMap [2][i] = default8BitPalette [i].blue;
    }

    return (nEntries);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\_control.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       control.h
//
//--------------------------------------------------------------------------

/*
  control.h - CMsiControl, CMsiActiveControl definitions
____________________________________________________________________________*/

#ifndef __CCONTROL
#define __CCONTROL

#include "handler.h"
#include <commctrl.h>
//#include <richedit.h>

struct ControlDispatchEntry;
struct MessageDispatchEntry;

// These next two structs represent how the icon information is stored
// in an ICO file.
typedef struct
{
	BYTE	bWidth;               // Width of the image
	BYTE	bHeight;              // Height of the image (times 2)
	BYTE	bColorCount;          // Number of colors in image (0 if >=8bpp)
	BYTE	bReserved;            // Reserved
	WORD	wPlanes;              // Color Planes
	WORD	wBitCount;            // Bits per pixel
	DWORD	dwBytesInRes;         // how many bytes in this resource?
	DWORD	dwImageOffset;        // where in the file is this image
} ICONDIRENTRY, *LPICONDIRENTRY;

// The following two structs are for the use of this program in
// manipulating icons. They are more closely tied to the operation
// of this program than the structures listed above. One of the
// main differences is that they provide a pointer to the DIB
// information of the masks.
typedef struct
{
	UINT			Width, Height, Colors; // Width, Height and bpp
	LPBYTE			lpBits;                // ptr to DIB bits
	DWORD			dwNumBytes;            // how many bytes?
	LPBITMAPINFO	lpbi;                  // ptr to header
	LPBYTE			lpXOR;                 // ptr to XOR image bits
	LPBYTE			lpAND;                 // ptr to AND image bits
} ICONIMAGE, *LPICONIMAGE;
typedef struct
{
	UINT		nNumImages;                      // How many images?
	ICONIMAGE	IconImages[1];                   // Image entries
} ICONRESOURCE, *LPICONRESOURCE;

// Resource Position info - size and offset of a resource in a file
typedef struct
{
    DWORD	dwBytes;
    DWORD	dwOffset;
} RESOURCEPOSINFO, *LPRESOURCEPOSINFO;


class CMsiControl:public IMsiControl
{   
public:
	CMsiControl(IMsiEvent& riDialog);
	virtual IMsiRecord*   __stdcall WindowCreate(IMsiRecord& riRecord);
	IMsiRecord*           __stdcall Attribute(Bool fSet, const IMsiString& riAttributeString, IMsiRecord& riRecord);
	IMsiRecord*           __stdcall AttributeEx(Bool fSet, cabEnum cab, IMsiRecord& riRecord);
	virtual Bool          __stdcall CanTakeFocus();
	virtual IMsiRecord*   __stdcall HandleEvent(const IMsiString& rpiEventNameString, const IMsiString& rpiArgumentString);
	virtual IMsiRecord*   __stdcall Undo();       
	HRESULT               __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long         __stdcall AddRef();
	virtual unsigned long __stdcall Release();
	const IMsiString&     __stdcall GetMsiStringValue() const;
	int                   __stdcall GetIntegerValue() const;
#ifdef USE_OBJECT_POOL
	unsigned int  __stdcall GetUniqueId() const;
	void          __stdcall SetUniqueId(unsigned int id);
#endif //USE_OBJECT_POOL
	virtual IMsiRecord*   __stdcall SetPropertyInDatabase();
	virtual IMsiRecord*   __stdcall GetPropertyFromDatabase();
	virtual IMsiRecord*   __stdcall GetIndirectPropertyFromDatabase();
	virtual IMsiRecord*   __stdcall RefreshProperty ();
	virtual IMsiRecord*   __stdcall SetFocus();
	inline IMsiEvent&     __stdcall GetDialog() {m_piDialog->AddRef(); return *m_piDialog;}
	IMsiRecord*           __stdcall WindowMessage(int iMessage, WPARAM wParam, LPARAM lParam);
	void                  SetLocation(int Left, int Top, int Width, int Height);
	IMsiRecord*           CreatePath(const ICHAR* astrPath, IMsiPath*& rpi);
	inline void           GetLocation(int &Left, int &Top, int &Width, int &Height) {Left = m_iX; Top = m_iY; Width = m_iWidth; Height = m_iHeight;}

	IMsiRecord*           CreateControlWindow(ICHAR *WindowClass, DWORD Style, DWORD ExtendedStyle, const IMsiString& Title, WindowRef ParentWindow, int WindowID);
	void                  SetCallbackFunction(WNDPROC pFunction);
	WNDPROC               GetCallbackFunction();
	virtual void          __stdcall Refresh();
	virtual const ICHAR*  __stdcall GetControlType() const { return m_szControlType; }

protected:
	virtual ~CMsiControl();
 	inline int             GetDBPropertyInt (const IMsiString& riPropertyString)
	                          {return m_piEngine-> GetPropertyInt(riPropertyString);}
	inline const IMsiString&     GetDBProperty(const ICHAR* szPropertyString)
		                      {return m_piEngine-> GetPropertyFromSz(szPropertyString);}
	inline Bool            SetDBProperty(const IMsiString& riPropertyString, const IMsiString& riDataString)
	                          {return m_piEngine-> SetProperty(riPropertyString, riDataString);}
	inline Bool            SetDBPropertyInt(const IMsiString& riPropertyString, int iData)
	                          {return m_piEngine-> SetPropertyInt(riPropertyString, iData);}
	virtual IMsiRecord*	   GetBinaryStream (const IMsiString& riNameString, IMsiStream*& rpiStream);

	virtual IMsiRecord*    SetVisible(Bool fVisible);
	virtual IMsiRecord*    SetEnabled(Bool fEnabled);
	virtual IMsiRecord*    WindowFinalize();
	virtual void           ReportInvalidEntry ();
	IMsiRecord*            GetVolumeList(int iAttributes, IMsiTable*& riTable);


	IMsiRecord*            CheckInitialized ();
	IMsiRecord*            CheckFieldCount (IMsiRecord& riRecord, int iCount, const ICHAR* szMsg);
	IMsiRecord*            PostError(IErrorCode iErr);
	IMsiRecord*            PostError(IErrorCode iErr, const IMsiString &str);
	IMsiRecord*            PostError(IErrorCode iErr, int);
	IMsiRecord*            PostError(IErrorCode iErr, const IMsiString &str2, const IMsiString &str3);
	IMsiRecord*            PostError(IErrorCode iErr, const IMsiString &str2, const IMsiString &str3, const IMsiString &str4);
	IMsiRecord*            PostError(IErrorCode iErr, const IMsiString &str2, const IMsiString &str3, const IMsiString &str4, const IMsiString &str5);
	IMsiRecord*            PostError(IErrorCode iErr, const IMsiString &str2, const IMsiString &str3, const IMsiString &str4, const IMsiString &str5, const IMsiString &str6);
	IMsiRecord*            PostErrorUnsupAttrib(const ICHAR *pszType);
	IMsiRecord*            PostErrorDlgKey(IErrorCode iErr);
	IMsiRecord*            PostErrorDlgKey(IErrorCode iErr, int i1);
	IMsiRecord*            PostErrorDlgKey(IErrorCode iErr, const IMsiString &str1, int i1);
	void                   GetIconSize(int iAttribute);
	IMsiRecord*            StartView(const ICHAR* sqlQuery, const IMsiString& riArgumentString, IMsiView*& rpiView);
	virtual IMsiRecord*    ChangeFontStyle(HDC hdc);
	IMsiRecord*            ChangeFontStyle(HDC hdc, const IMsiString& ristrStyle, const WindowRef pWnd);
	virtual IMsiRecord*    ProcessText();
	IMsiRecord*            ProcessText(const MsiString& riRawText, MsiString& riText, MsiString& riCurrentStyle, MsiString& riDefaultStyle, const WindowRef pWnd, bool fFormat);

	WNDPROC                m_pFunction;         // Pointer to callback function
	//IMsiRecord*            CreateControlWindow(ICHAR *WindowClass, DWORD Style, DWORD ExtendedStyle, const IMsiString& riTitleString, WindowRef ParentWindow);
	static INT_PTR CALLBACK    ControlProc(WindowRef pWnd, WORD message, WPARAM wParam, LPARAM lParam);		//--merced: changed int to INT_PTR
	IMsiRecord*            DoUnpackBitmap (const char far * pData, HBITMAP& rhBitmap);
	IMsiRecord*            DoUnpackJPEG (const char far *pData, unsigned int len, HBITMAP& rhBitmap);
	IMsiRecord*            UnpackBitmap(const IMsiString& riNameString, HBITMAP& rhBitmap);
	IMsiRecord*            StretchBitmap(const IMsiString& riNameString, int iWidth, int iHeight, Bool fFixedSize, WindowRef pWnd, HBITMAP& rhBitmap);
	IMsiRecord*            UnpackIcon(const IMsiString& riNameString, HICON& rhIcon, int iWidth, int iHeight, Bool fFixedSize);
	IMsiRecord*            DrawBitmap(HDC hdc, LPRECT pRect, HBITMAP hBitmap);
	IMsiRecord*            ReadIconFromICOFile(const IMsiString& riNameString, IMsiStream* piStream, ICONRESOURCE *&lpIR);
	IMsiRecord*            MyDrawIcon(HDC hdc, LPRECT pRect, HICON hIcon, Bool fFixedSize);
	IMsiRecord*            LockDialog(Bool fLock);
	IMsiRecord*            LoadRichEdit();
	IMsiRecord*            UnloadRichEdit();
	IMsiRecord*            CheckPath(IMsiPath& riPath,
												const ICHAR* szSubFolder = NULL,
												const ipvtEnum iMode = ipvtExists);
	IMsiRecord*            CheckPath(const IMsiString &path,
												const ipvtEnum iMode = ipvtExists);
	const IMsiString&      GimmeUserFontStyle(const IMsiString&);
	bool                   ShouldHideVolume(int iVolumeID);
	
	// WindowMessage functions
	virtual IMsiRecord*           Char(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*           Command(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*           KillFocus(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*           NCDestroy(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*           Paint(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*           SysKeyDown(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*           SysKeyUp(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*           DrawItem(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*           MeasureItem(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*           Notify(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*           CompareItem(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*           LButtonDown(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*           GetDlgCode(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*           KeyDown(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*           SetFocus(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*           Enable(WPARAM wParam, LPARAM lParam);
	virtual IMsiRecord*           ShowWindow(WPARAM wParam, LPARAM lParam);

	IMsiRecord*                   CreateTable(const ICHAR* szTable, IMsiTable*& riTable);

	// Attribute functions
	IMsiRecord*                   NoWay(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetText(IMsiRecord& riRecord);
	virtual IMsiRecord*           SetText(IMsiRecord& riRecord);
	virtual IMsiRecord*           SetErrorText(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetVisible(IMsiRecord& riRecord);
	virtual IMsiRecord*           SetVisible(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetEnabled(IMsiRecord& riRecord);
	virtual IMsiRecord*           SetEnabled(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetDefault(IMsiRecord& riRecord);
	virtual IMsiRecord*           SetDefault(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetPropertyName(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetIndirectPropertyName(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetPosition(IMsiRecord& riRecord);
	virtual IMsiRecord*           SetPosition(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetPropertyValue(IMsiRecord& riRecord);
	virtual IMsiRecord*           SetPropertyValue(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetIndirect(IMsiRecord& riRecord);
 	virtual IMsiRecord*           GetProgress(IMsiRecord& riRecord);
	virtual IMsiRecord*           SetProgress(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetImage(IMsiRecord& riRecord);
	virtual IMsiRecord*           SetImage(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetImageHandle(IMsiRecord& riRecord);
	virtual IMsiRecord*           SetImageHandle(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetBillboardName(IMsiRecord& riRecord);
	virtual IMsiRecord*           SetBillboardName(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetIgnoreChange(IMsiRecord& riRecord);
	virtual IMsiRecord*           SetIgnoreChange(IMsiRecord& riRecord);
	virtual IMsiRecord*           SetTimeRemaining(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetTimeRemaining(IMsiRecord& riRecord);
	virtual IMsiRecord*           SetScriptInProgress(IMsiRecord& riRecord);
#ifdef ATTRIBUTES
	virtual IMsiRecord*           GetRefCount(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetKeyInt(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetKeyString(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetX(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetY(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetWidth(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetHeight(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetHelp(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetToolTip(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetContextHelp(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetClientRect(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetOriginalValue(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetInteger(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetLimit(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetItemsCount(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetItemsValue(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetItemsHandle(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetItemsText(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetItemsX(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetItemsY(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetItemsWidth(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetItemsHeight(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetSunken(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetHasBorder(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetPushLike(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetBitmap(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetIcon(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetRTLRO(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetRightAligned(IMsiRecord& riRecord);
	virtual IMsiRecord*           GetLeftScroll(IMsiRecord& riRecord);
#endif // ATTRIBUTES

	MsiStringId            m_iKey;
	MsiString              m_strKey;
	MsiString              m_strRawText;
	MsiString              m_strText;
	MsiString              m_strCurrentStyle;
	MsiString              m_strDefaultStyle;
	MsiString              m_strHelp;
	MsiString              m_strToolTip;
	MsiString              m_strContextHelp;
	IMsiDialogHandler*     m_piHandler;
	IMsiEvent*             m_piDialog;
	IMsiEngine*            m_piEngine;
	IMsiServices*          m_piServices;
	IMsiDatabase*          m_piDatabase;
	Bool                   m_fVisible;           
	Bool                   m_fEnabled;
	Bool                   m_fDefault;
	int                    m_iX;
	int                    m_iY;
	int                    m_iWidth;
	int                    m_iHeight;
	int                    m_iRefCnt;
	Bool                   m_fTransparent;
	MsiString              m_strDialogName;
	Bool                   m_fSunken;
	int                    m_iSize;
	MsiString              m_strPropertyName;
	WindowRef              m_pWnd;
	WindowRef              m_pWndDialog;
	Bool                   m_fImageHandle;
	Bool                   m_fHasToolTip;
	WindowRef              m_pWndToolTip;
	Bool                   m_fPreview;
	Bool                   m_fLocking;
	Bool                   m_fRTLRO;
	Bool                   m_fRightAligned;
	Bool                   m_fLeftScroll;
	static HINSTANCE       s_hRichEd20;
	bool                   m_fUseDbLang;
#ifdef USE_OBJECT_POOL
	unsigned int           m_iCacheId;
#endif //USE_OBJECT_POOL

private:
	static ControlDispatchEntry s_ControlDispatchTable[];
	static int             s_ControlDispatchCount;

	IMsiRecord*            GetTransparent(IMsiRecord& riRecord);
	IMsiRecord*            GetpWnd(IMsiRecord& riRecord);

	static MessageDispatchEntry s_MessageDispatchTable[];
	static int             s_MessageDispatchCount;

	static ICHAR           m_szControlType[];
	HINSTANCE m_hRichEd20;
};

struct ControlDispatchEntry
{
	const ICHAR* pcaAttribute;
	IMsiRecord* (CMsiControl::*pmfGet)(IMsiRecord& riRecord);
	IMsiRecord* (CMsiControl::*pmfSet)(IMsiRecord& riRecord);
};

struct MessageDispatchEntry
{
	int iMessage;
	IMsiRecord* (CMsiControl::*pmfMessage)(WPARAM wParam, LPARAM lParam);
};

// Control AttriButes - This Table MUST be in sync with the text strings in 
// control.cpp
enum cabEnum	{ 
	cabText = 0,
	cabVisible,
	cabTimeRemaining,
	cabEnabled,
	cabDefault,
	cabIndirectPropertyName,
	cabPosition,
	cabPropertyValue,
	cabIndirect,
	cabTransparent,
	cabProgress,
	cabImage,
	cabImageHandle,
	cabPropertyName,
	cabBillboardName,
	cabWindowHandle,
	cabIgnoreChange,
	cabScriptInProgress,
	cabErrorString,
#ifdef ATTRIBUTES
	cabRefCount,
	cabKeyInt,
	cabKeyString,
	cabX,
	cabY,
	cabWidth,
	cabHeight,
	cabHelp,
	cabToolTip,
	cabContextHelp,
	cabClientRect,
	cabOriginalValue,
	cabInteger,
	cabLimit,
	cabItemsCount,
	cabItemsValue,
	cabItemsHandle,
	cabItemsText,
	cabItemsX,
	cabItemsY,
	cabItemsWidth,
	cabItemsHeight,
	cabSunken,
	cabPushLike,
	cabBitmap,
	cabIcon,
	cabHasBorder,
	cabRTLRO,
	cabRightAligned,
	cabLeftScroll,
#endif //Attributes
};

//////////////////////////////////////////////////////
// CMsiActiveControl
//////////////////////////////////////////////////////


class CMsiActiveControl:public CMsiControl
{
public:
	CMsiActiveControl(IMsiEvent& riDialog);
	inline const IMsiString&             GetIndirectPropertyName()                  {return m_strIndirectPropertyName.Return ();}
	inline const IMsiString&             GetPropertyName()                          {return m_strPropertyName.Return ();}
	inline const IMsiString&             GetPropertyValue()                         {return m_strPropertyValue.Return ();}
	virtual IMsiRecord*            SetPropertyValue (const IMsiString& riValueString, Bool fCallPropChanged);
	virtual IMsiRecord*            SetOriginalValue (const IMsiString& riValueString);
	virtual IMsiRecord*            SetIndirectPropertyValue (const IMsiString& riValueString);
	virtual IMsiRecord*            __stdcall WindowCreate(IMsiRecord& riRecord);
	virtual IMsiRecord*            __stdcall GetPropertyFromDatabase();
	virtual IMsiRecord*            __stdcall GetIndirectPropertyFromDatabase();
	virtual IMsiRecord*            __stdcall SetPropertyInDatabase();
	virtual IMsiRecord*            __stdcall RefreshProperty ();
	virtual IMsiRecord*            __stdcall Undo();
	virtual Bool                   __stdcall CanTakeFocus() { return ToBool(m_fEnabled && m_fVisible); }

protected:
	virtual ~CMsiActiveControl();
	virtual IMsiRecord*            ValidateProperty (const IMsiString &text);
	virtual IMsiRecord*            PropertyChanged ();
	inline const IMsiString&             GetOriginalValue() {return m_strOriginalValue.Return ();}
	// attribute functions
	virtual IMsiRecord*            GetIndirectPropertyName(IMsiRecord& riRecord);
	virtual IMsiRecord*            GetPropertyValue(IMsiRecord& riRecord);
	virtual IMsiRecord*            SetPropertyValue(IMsiRecord& riRecord);
	virtual IMsiRecord*            GetIndirect(IMsiRecord& riRecord);
	inline Bool                    IsIntegerOnly() {return (m_fInteger);}
	int                            GetOwnerDrawnComboListHeight();
#ifdef ATTRIBUTES
	virtual IMsiRecord*            GetOriginalValue(IMsiRecord& riRecord);
	virtual IMsiRecord*            GetInteger(IMsiRecord& riRecord);
#endif // ATTRIBUTES
	Bool                           m_fRefreshProp;


private:
	PMsiTable                      m_piPropertiesTable;
	MsiString                      m_strIndirectPropertyName;
	MsiString                      m_strPropertyValue;
	MsiString                      m_strOriginalValue;
	Bool                           m_fInteger;
	Bool                           m_fIndirect;
};


/////////////////////////////////////////////////////////////////////////////////////////

IMsiControl* CreateMsiPushButton(IMsiEvent& riDialog);
IMsiControl* CreateMsiText(IMsiEvent& riDialog);
IMsiControl* CreateMsiEdit(IMsiEvent& riDialog);
IMsiControl* CreateMsiRadioButtonGroup(IMsiEvent& riDialog);
IMsiControl* CreateMsiCheckBox(IMsiEvent& riDialog);
IMsiControl* CreateMsiBitmap(IMsiEvent& riDialog);
IMsiControl* CreateMsiListBox(IMsiEvent& riDialog);
IMsiControl* CreateMsiComboBox(IMsiEvent& riDialog);
IMsiControl* CreateMsiProgressBar(IMsiEvent& riDialog);
IMsiControl* CreateMsiGroupBox(IMsiEvent& riDialog);
IMsiControl* CreateMsiDirectoryCombo(IMsiEvent& riDialog);
IMsiControl* CreateMsiDirectoryList(IMsiEvent& riDialog);
IMsiControl* CreateMsiPathEdit(IMsiEvent& riDialog);
IMsiControl* CreateMsiVolumeSelectCombo(IMsiEvent& riDialog);
IMsiControl* CreateMsiScrollableText(IMsiEvent& riDialog);
IMsiControl* CreateMsiSelectionTree(IMsiEvent& riDialog);
IMsiControl* CreateMsiIcon(IMsiEvent& riDialog);
IMsiControl* CreateMsiVolumeCostList(IMsiEvent& riDialog);
IMsiControl* CreateMsiListView(IMsiEvent& riDialog);
IMsiControl* CreateMsiBillboard(IMsiEvent& riDialog);
IMsiControl* CreateMsiMaskedEdit(IMsiEvent& riDialog);
IMsiControl* CreateMsiLine(IMsiEvent& riDialog);

struct ControlCreateDispatchEntry
{
	const ICHAR* pcaType;
	IMsiControl* (*pfCreate)(IMsiEvent& riDialog);
};
extern ControlCreateDispatchEntry ControlCreateDispatchTable[];

extern int ControlCreateDispatchCount;


#endif //__CCONTROL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\dialog.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dialog.cpp
//
//--------------------------------------------------------------------------

/*  dialog.cpp - CMsiDialog definition and implementation
____________________________________________________________________________*/
#include "common.h"
#include "engine.h"  
#include "_handler.h" 
#include "_control.h"
#include "imemory.h"
#include "string.h"

//////////////////////////////////////////////////////////////////////////////
// CMsiDialog definition
//////////////////////////////////////////////////////////////////////////////

struct DialogDispatchEntry;

const int iDlgUnitSize = 12;
const int kiCostingPeriod = 60;
const int kiCostingSlice = 50;
const int kiDiskSpacePeriod = 500;

enum itpEnum
{
	itpSet = 0,
	itpCheck = 1,
	itpCheckExisting = 2,
};

class CMsiDialog : public IMsiDialog, public IMsiEvent
{
protected:
	virtual ~CMsiDialog();  // protected to prevent creation on stack
public:
	CMsiDialog(IMsiDialogHandler& riHandler, IMsiEngine& riEngine, WindowRef pwndParent);   
	IMsiRecord*               __stdcall PropertyChanged(const IMsiString& riPropertyString, const IMsiString& riControlString);
	virtual IMsiRecord*       __stdcall ControlActivated(const IMsiString& riControlString);
	IMsiRecord*               __stdcall RegisterControlEvent(const IMsiString& riControlString, Bool fRegister, const ICHAR * szEventString);
	HRESULT                   __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long             __stdcall AddRef();
	unsigned long             __stdcall Release();
	virtual IMsiRecord*       __stdcall WindowCreate(IMsiRecord& riRecord, IMsiDialog* piParent, IMsiTable* piControlEventTable,
		IMsiTable* piControlConditionTable, IMsiTable* piEventMappingTable);    
	virtual IMsiRecord*       __stdcall WindowShow(Bool fShow);
	virtual IMsiControl*      __stdcall ControlCreate(const IMsiString& riTypeString);
	IMsiRecord*               __stdcall Attribute(Bool fSet, const IMsiString& riAttributeString, IMsiRecord& riRecord);
	IMsiRecord*               __stdcall AttributeEx(Bool fSet, dabEnum dab, IMsiRecord& riRecord);
	virtual IMsiRecord*       __stdcall GetControl(const IMsiString& riControlString, IMsiControl*& rpiControl);
	virtual IMsiRecord*       __stdcall GetControlFromWindow(const HWND hControl, IMsiControl*& rpiControl);
	virtual IMsiRecord*       __stdcall SetFocus(const IMsiString& riControlString);
	virtual IMsiRecord*       __stdcall AddControl(IMsiControl* piControl, IMsiRecord& riRecord);
	virtual IMsiRecord*       __stdcall FinishCreate();
	IMsiRecord*               __stdcall RemoveControl(IMsiControl* piControl);
	virtual IMsiRecord*       __stdcall DestroyControls();
	virtual IMsiRecord*       __stdcall RemoveWindow();
	const IMsiString&         __stdcall GetMsiStringValue() const;
	int                       __stdcall GetIntegerValue() const;
#ifdef USE_OBJECT_POOL
	unsigned int              __stdcall GetUniqueId() const;
	void                      __stdcall SetUniqueId(unsigned int id);
#endif //USE_OBJECT_POOL
	virtual IMsiRecord*       __stdcall Execute();
	IMsiRecord*               __stdcall Reset();
	IMsiDialogHandler&        __stdcall GetHandler();
	IMsiEngine&               __stdcall GetEngine();
	IMsiRecord*               __stdcall PublishEvent(MsiStringId idEventString, IMsiRecord& riArgument);
	IMsiRecord*               __stdcall PublishEventSz(const ICHAR* szEventString, IMsiRecord& riArgument);
	IMsiRecord*               __stdcall EventAction(MsiStringId idEventString, const IMsiString& riActionString);
	IMsiRecord*               __stdcall EventActionSz(const ICHAR * szEventStringName, const IMsiString& riActionString);
	void                      __stdcall SetErrorRecord(IMsiRecord& riRecord);
	IMsiRecord*               __stdcall HandleEvent(const IMsiString& riEventStringName, const IMsiString& riArgumentString);
	virtual IMsiRecord*       __stdcall Escape();
	bool                      __stdcall SetCancelAvailable(bool fAvailable);

	IMsiRecord*               HandleWaitDialogEvent(const IMsiString& riDialogString, const IMsiString& riConditionString);
	static INT_PTR CALLBACK WindowProc(WindowRef pWnd, WORD message, WPARAM wParam, LPARAM lParam);
	IMsiRecord*               GetpWnd(IMsiRecord& riRecord);
	IMsiRecord*               GetToolTip(IMsiRecord& riRecord);
	IMsiRecord*               GetPalette(IMsiRecord& riRecord);
	IMsiRecord*               SetPalette(IMsiRecord& riRecord);


protected:
	inline int                GetDBPropertyInt (const IMsiString& riPropertyString)
	                               {return m_piEngine-> GetPropertyInt(riPropertyString);}
	inline const IMsiString&        GetDBProperty(const IMsiString& riPropertyString)
		                           {return m_piEngine-> GetProperty(riPropertyString);}
	inline Bool               SetDBProperty(const IMsiString& riPropertyString, const IMsiString& rData)
	                               {return m_piEngine-> SetProperty(riPropertyString, rData);}
	inline Bool               SetDBPropertyInt(const IMsiString& riPropertyString, int iData)
	                               {return m_piEngine-> SetPropertyInt(riPropertyString, iData);}
	IMsiRecord*               PostError(IErrorCode iErr);
	IMsiRecord*               PostError(IErrorCode iErr, const IMsiString& str);
	IMsiRecord*               PostError(IErrorCode iErr, const IMsiString& str2, const IMsiString& str3);
	IMsiRecord*               PostError(IErrorCode iErr, const IMsiString& str2, const IMsiString& str3, const IMsiString& str4);
	IMsiRecord*               PostError(IErrorCode iErr, const IMsiString& str2, const IMsiString& str3, const IMsiString& str4, const IMsiString& str5);
	IMsiRecord*               PostError(IErrorCode iErr, const IMsiString& str2, const IMsiString& str3, const IMsiString& str4, const IMsiString& str5, const IMsiString& str6);
	inline void               SetCurrentControl(int iCur) {m_iControlCurrent = iCur;}
	inline int                GetCurrentControl() {return m_iControlCurrent;}
	IMsiRecord*               SetDefaultButton(int iButton);
	void                      SetLocation(int left, int top, int width, int height);
	void                      GetLocation(int &left, int &top, int &width, int &height);
	void                      SetWindowTitle (const IMsiString& riText);
	inline void               SetDialogModality (icmdEnum iModal) {m_dialogModality = iModal;}
	inline icmdEnum           GetDialogModality () {return (m_dialogModality);}
	IMsiRecord*               ControlsSetProperties(); // tells all the controls to set their values to respective properties
	void                      Refresh ();
	Bool                      HandlePaletteChanged();
	Bool                      HandleQueryNewPalette();
	virtual Bool              DoCreateWindow(Bool fDialogCanBeMinimized, IMsiDialog* piParent);
	IMsiRecord*               CheckFieldCount (IMsiRecord& riRecord, int iCount, const ICHAR* szMsg);
	IMsiRecord*              HandleAction(IMsiControl* piControl, const IMsiString& riActionString);
	IMsiRecord*              NewDialogEvent(const IMsiString& riDialogString);
	IMsiRecord*              SpawnDialogEvent(const IMsiString& riDialogString);
	IMsiRecord*              SpawnCostingDialogEvent(const IMsiString& riDialogString);
	IMsiRecord*              EndDialogEvent(const IMsiString& riArgumentString);
	IMsiRecord*              TargetPathEvent(const IMsiString& riArgumentString, itpEnum itp);
	IMsiRecord*              ConfigureFeatureEvent(const IMsiString& riArgumentString,iisEnum iis);
	IMsiRecord*              ReinstallModeEvent(const IMsiString& riArgumentString);
	IMsiRecord*              ValidateProductIDEvent();
	IMsiRecord*              DoActionEvent(const IMsiString& riArgumentString);
	IMsiRecord*              GetControl(MsiStringId iControl, IMsiControl*& rpiControl); 
	IMsiRecord*              NoWay(IMsiRecord& riRecord);
	IMsiRecord*              GetKeyInt(IMsiRecord& riRecord);
	IMsiRecord*              GetKeyString(IMsiRecord& riRecord);
	IMsiRecord*              GetText(IMsiRecord& riRecord);
	IMsiRecord*              SetText(IMsiRecord& riRecord);
	IMsiRecord*              GetCurrentControl(IMsiRecord& riRecord);
	IMsiRecord*              SetCurrentControl(IMsiRecord& riRecord);
	IMsiRecord*              GetDefaultBorder(IMsiRecord& riRecord);
	IMsiRecord*              GetShowing(IMsiRecord& riRecord);
	IMsiRecord*              SetShowing(IMsiRecord& riRecord);
	IMsiRecord*              GetRunning(IMsiRecord& riRecord);
	IMsiRecord*              SetRunning(IMsiRecord& riRecord);
	IMsiRecord*              GetModal(IMsiRecord& riRecord);
	IMsiRecord*              GetError(IMsiRecord& riRecord);
	IMsiRecord*              GetUseCustomPalette(IMsiRecord& riRecord);
	IMsiRecord*              SetModal(IMsiRecord& riRecord);
	IMsiRecord*              GetFullSize(IMsiRecord& riRecord);
	IMsiRecord*              GetPosition(IMsiRecord& riRecord);
	IMsiRecord*              SetPosition(IMsiRecord& riRecord);
	IMsiRecord*              GetEventInt(IMsiRecord& riRecord);	
	IMsiRecord*              SetEventInt(IMsiRecord& riRecord);	
	IMsiRecord*              GetArgument(IMsiRecord& riRecord);	
	IMsiRecord*              GetKeepModeless(IMsiRecord& riRecord);
	IMsiRecord*              GetPreview(IMsiRecord& riRecord);
	IMsiRecord*              GetAddingControls(IMsiRecord& riRecord);
	IMsiRecord*              SetAddingControls(IMsiRecord& riRecord);
	IMsiRecord*              GetLocked(IMsiRecord& riRecord);
	IMsiRecord*              SetLocked(IMsiRecord& riRecord);
	IMsiRecord*              GetInPlace(IMsiRecord& riRecord);
	IMsiRecord*              SetInPlace(IMsiRecord& riRecord);
	IMsiRecord*              GetCancelButton(IMsiRecord& riRecord);
#ifdef ATTRIBUTES
	IMsiRecord*              GetX(IMsiRecord& riRecord);
	IMsiRecord*              GetY(IMsiRecord& riRecord);
	IMsiRecord*              GetWidth(IMsiRecord& riRecord);
	IMsiRecord*              GetHeight(IMsiRecord& riRecord);
	IMsiRecord*              GetRefCount(IMsiRecord& riRecord);
	IMsiRecord*              GetDefaultButton(IMsiRecord& riRecord);
	IMsiRecord*              SetDefaultButton(IMsiRecord& riRecord);
	IMsiRecord*              GetEventString(IMsiRecord& riRecord);
	IMsiRecord*              GetControlsCount(IMsiRecord& riRecord);
	IMsiRecord*              GetControlsKeyInt(IMsiRecord& riRecord);
	IMsiRecord*              GetControlsKeyString(IMsiRecord& riRecord);
	IMsiRecord*              GetControlsProperty(IMsiRecord& riRecord);
	IMsiRecord*              GetControlsNext(IMsiRecord& riRecord);
	IMsiRecord*              GetControlsPrev(IMsiRecord& riRecord);
	IMsiRecord*              GetHasControls(IMsiRecord& riRecord);
	IMsiRecord*              GetClientRect(IMsiRecord& riRecord);
	IMsiRecord*              GetRTLRO(IMsiRecord& riRecord);
	IMsiRecord*              GetRightAligned(IMsiRecord& riRecord);
	IMsiRecord*              GetLeftScroll(IMsiRecord& riRecord);
#endif // ATTRIBUTES
	void                     SetRelativeLocation(int irelX, int irelY, int iWidth, int iHeight);
	IMsiRecord*              CreateControlsTable();
	IMsiRecord*              CreateEventRegTable();
	virtual IMsiRecord*      SetFocus(MsiStringId iNewControlWithFocus);
	IMsiRecord*              GetFocus(IMsiControl*& rpiControl);
	virtual IMsiRecord*      EnableControl (IMsiControl& riControl, Bool fEnable);
	IMsiRecord*              ControlsCursorCreate(IMsiCursor*& piCursor);
	IMsiRecord*              CreateTable(const ICHAR* szTable, IMsiTable*& riTable);
	void                     ProcessingCommand(HWND hArg) { m_hProcessingBtnCmd = hArg; }
	HWND                     ProcessingCommand(void) const { return m_hProcessingBtnCmd; }
	MsiString         m_strRawText;
	MsiString         m_strText;
	MsiString         m_strFirstControl;
	MsiString         m_strDefaultButton;
	MsiString         m_strCancelButton;
	icmdEnum          m_dialogModality;
	IMsiDialogHandler* m_piHandler;
	IMsiEngine*        m_piEngine;
	IMsiServices*     m_piServices;
	IMsiDatabase*     m_piDatabase;
	PMsiTable         m_piControlsTable;      // table of controls on present dialog
	PMsiCursor		  m_piControlsCursor;
	PMsiTable         m_piEventRegTable;      // table of events and controls registered with that event
	PMsiTable         m_piControlEventTable;
	PMsiTable         m_piControlConditionTable;
	PMsiTable         m_piEventMappingTable;
	PMsiCursor		  m_piEventMappingCursor;
	IMsiSelectionManager* m_piSelectionManager;
	PMsiRecord        m_piErrorRecord;
	MsiStringId       m_iEvent;
	MsiString         m_strArg;
	MsiString         m_strKey;
	Bool              m_fAddingControls;
	static DialogDispatchEntry s_DialogDispatchTable[];
	static int        s_DialogDispatchCount;
	HBRUSH            m_hbrTransparent;
	int               m_iRefCnt;
	// Variables from here down get 0ed at creation time
	Bool              m_fHasControls;
	Bool              m_fErrorDialog;
	Bool              m_fKeepModeless;
	Bool              m_fTrackDiskSpace;
	Bool              m_fUseCustomPalette;
	MsiStringId       m_iLocked;
	WindowRef         m_pWnd;
	WindowRef         m_pToolTip;
	HPALETTE          m_hPalette;
	Bool              m_fPreview;
	Bool              m_fInPlace;
	Bool              m_fRTLRO;
	Bool              m_fRightAligned;
	Bool              m_fLeftScroll;
	WindowRef         m_pWndCostingTimer;
	WindowRef         m_pWndDiskSpaceTimer;
	MsiStringId       m_iKey;       // identifier of the dialog
	int               m_iX;      // Left
	int               m_iY;      // Top
	int               m_iWidth;      // Width of visible window
	int               m_iHeight;     // Height of visible window
	int               m_iFullWidth;   // width of entire window
	int               m_iFullHeight;  // height of entire window 
	int               m_iClientWidth; // width of client area
	int               m_iClientHeight;// height of client area
	int               m_iScreenX;
	int               m_iScreenY;
	int               m_iScreenWidth;
	int               m_iScreenHeight;
	int               m_iVScrollPos;
	int               m_iHScrollPos;
	MsiStringId       m_iControlCurrent;
	MsiStringId       m_iDefaultButton;
	MsiStringId       m_iCurrentButton;
	MsiStringId       m_iCancelButton;
	Bool              m_fDialogIsShowing;    // Internal use only
	Bool              m_fDialogIsRunning;    // Internal use only
	HWND              m_hProcessingBtnCmd;   // Internal use only

	bool              m_fCancelAvailable;
#ifdef USE_OBJECT_POOL
	unsigned int      m_iCacheId;
#endif //USE_OBJECT_POOL
	// these do not get cleared at Creation time
	int               m_idyChar;
	WindowRef         m_pwndParent; // window handle of the calling process, not necesseraly the parent of this window
};

typedef CComPointer<CMsiDialog> PCMsiDialog;

struct DialogDispatchEntry
{
	const ICHAR* pcaAttribute;
	IMsiRecord* (CMsiDialog::*pmfGet)(IMsiRecord& riRecord);
	IMsiRecord* (CMsiDialog::*pmfSet)(IMsiRecord& riRecord);
};


DialogDispatchEntry CMsiDialog::s_DialogDispatchTable[] = {
	pcaDialogAttributeText,                 CMsiDialog::GetText,              CMsiDialog::SetText,
	pcaDialogAttributeCurrentControl,       CMsiDialog::GetCurrentControl,    CMsiDialog::SetCurrentControl,
	pcaDialogAttributeShowing,              CMsiDialog::GetShowing,           CMsiDialog::SetShowing,
	pcaDialogAttributeRunning,              CMsiDialog::GetRunning,           CMsiDialog::SetRunning,
	pcaDialogAttributePosition,             CMsiDialog::GetPosition,          CMsiDialog::SetPosition,
	pcaDialogAttributePalette,              CMsiDialog::GetPalette,           CMsiDialog::SetPalette,
	pcaDialogAttributeEventInt,             CMsiDialog::GetEventInt,          CMsiDialog::SetEventInt,
	pcaDialogAttributeArgument,             CMsiDialog::GetArgument,          CMsiDialog::NoWay,
	pcaDialogAttributeWindowHandle,         CMsiDialog::GetpWnd,              CMsiDialog::NoWay,
	pcaDialogAttributeToolTip,              CMsiDialog::GetToolTip,           CMsiDialog::NoWay,
	pcaDialogAttributeFullSize,             CMsiDialog::GetFullSize,          CMsiDialog::NoWay,
	pcaDialogAttributeKeyInt,               CMsiDialog::GetKeyInt,            CMsiDialog::NoWay,
	pcaDialogAttributeKeyString,            CMsiDialog::GetKeyString,         CMsiDialog::NoWay,
	pcaDialogAttributeError,                CMsiDialog::GetError,             CMsiDialog::NoWay,
	pcaDialogAttributeKeepModeless,         CMsiDialog::GetKeepModeless,      CMsiDialog::NoWay,
	pcaDialogAttributeUseCustomPalette,     CMsiDialog::GetUseCustomPalette,  CMsiDialog::NoWay,
	pcaDialogAttributePreview,              CMsiDialog::GetPreview,           CMsiDialog::NoWay,
	pcaDialogAttributeAddingControls,       CMsiDialog::GetAddingControls,    CMsiDialog::SetAddingControls,
	pcaDialogAttributeLocked,               CMsiDialog::GetLocked,            CMsiDialog::SetLocked,
	pcaDialogAttributeInPlace,              CMsiDialog::GetInPlace,           CMsiDialog::SetInPlace,
	pcaDialogAttributeModal,                CMsiDialog::GetModal,             CMsiDialog::SetModal,
	pcaDialogAttributeCancelButton,         CMsiDialog::GetCancelButton,      CMsiDialog::NoWay,
#ifdef ATTRIBUTES
	pcaDialogAttributeX,                    CMsiDialog::GetX,                 CMsiDialog::NoWay,
	pcaDialogAttributeY,                    CMsiDialog::GetY,                 CMsiDialog::NoWay,
	pcaDialogAttributeWidth,                CMsiDialog::GetWidth,             CMsiDialog::NoWay,
	pcaDialogAttributeHeight,               CMsiDialog::GetHeight,            CMsiDialog::NoWay,
	pcaDialogAttributeRefCount,             CMsiDialog::GetRefCount,          CMsiDialog::NoWay,
	pcaDialogAttributeEventString,          CMsiDialog::GetEventString,       CMsiDialog::NoWay,
	pcaDialogAttributeControlsCount,		CMsiDialog::GetControlsCount,	  CMsiDialog::NoWay,
	pcaDialogAttributeControlsKeyInt,		CMsiDialog::GetControlsKeyInt,	  CMsiDialog::NoWay,
	pcaDialogAttributeControlsKeyString,	CMsiDialog::GetControlsKeyString, CMsiDialog::NoWay,
	pcaDialogAttributeControlsProperty,		CMsiDialog::GetControlsProperty,  CMsiDialog::NoWay,
	pcaDialogAttributeControlsNext,			CMsiDialog::GetControlsNext,	  CMsiDialog::NoWay,
	pcaDialogAttributeControlsPrev,			CMsiDialog::GetControlsPrev,	  CMsiDialog::NoWay,
	pcaDialogAttributeHasControls,          CMsiDialog::GetHasControls,       CMsiDialog::NoWay,
	pcaDialogAttributeClientRect,           CMsiDialog::GetClientRect,        CMsiDialog::NoWay,
	pcaDialogAttributeDefaultButton,        CMsiDialog::GetDefaultButton,     CMsiDialog::SetDefaultButton,
	pcaDialogAttributeRTLRO,                CMsiDialog::GetRTLRO,             CMsiDialog::NoWay,
	pcaDialogAttributeRightAligned,         CMsiDialog::GetRightAligned,      CMsiDialog::NoWay,
	pcaDialogAttributeLeftScroll,           CMsiDialog::GetLeftScroll,        CMsiDialog::NoWay,
#endif // ATTRIBUTES
};

int CMsiDialog::s_DialogDispatchCount = sizeof(CMsiDialog::s_DialogDispatchTable)/sizeof(DialogDispatchEntry);
WNDPROC pWindowProc = (WNDPROC)CMsiDialog::WindowProc;

#define MAX_WAIT_EXPRESSION_SIZE 256
static ICHAR s_szWaitCondition[MAX_WAIT_EXPRESSION_SIZE] = TEXT("");



///////////////////////////////////////////////////////////////
// CMsiDialog implementation
///////////////////////////////////////////////////////////////


IMsiControl* CMsiDialog::ControlCreate(const IMsiString& riTypeString)
{
	return CreateMsiControl(riTypeString, *this);
}

CMsiDialog::CMsiDialog(IMsiDialogHandler& riHandler, IMsiEngine& riEngine, WindowRef pwndParent) : m_piErrorRecord(0), m_piControlsTable(0), 
						m_piEventRegTable(0), m_piControlEventTable(0), m_piControlConditionTable(0), m_piEventMappingTable(0), m_piControlsCursor(0),
						m_piEventMappingCursor(0)
{
	MsiString strNull;
	m_iRefCnt = 1;
	
	// Set everything to zero except refcnt
	INT_PTR cbSize = ((char *)&(this->m_idyChar)) - ((char *)&(this->m_fHasControls));		//--merced: changed int to INT_PTR
	Assert(cbSize > 0);
	memset(&(this->m_fHasControls), 0, (unsigned int)cbSize);				//--merced: added typecast.

	Assert(m_fHasControls == fFalse);
	Assert(m_fErrorDialog == fFalse);
	Assert(m_fKeepModeless == fFalse);
	Assert(m_fTrackDiskSpace == fFalse);
	Assert(m_fUseCustomPalette == fFalse);
	Assert(m_iLocked == 0);
	Assert(m_pWnd == 0);       // The Windows handle that corresponds to this CMsiWindow
	Assert(m_pToolTip == 0);
	Assert(m_hPalette == 0);
	Assert(m_fPreview == fFalse);
	Assert(m_fInPlace == fFalse);
	Assert(m_fRTLRO == fFalse);
	Assert(m_fRightAligned == fFalse);
	Assert(m_fLeftScroll == fFalse);
	Assert(m_pWndCostingTimer == 0);
	Assert(m_pWndDiskSpaceTimer == 0);
	Assert(m_iKey == 0);
	Assert(m_iX == 0);
	Assert(m_iY == 0);
	Assert(m_iWidth == 0);
	Assert(m_iHeight == 0);
	Assert(m_iFullWidth == 0);
	Assert(m_iFullHeight == 0);
	Assert(m_iClientWidth == 0);
	Assert(m_iClientHeight == 0);
	Assert(m_iScreenX == 0);
	Assert(m_iScreenY == 0);
	Assert(m_iScreenWidth == 0);
	Assert(m_iScreenHeight == 0);
	Assert(m_iVScrollPos == 0);
	Assert(m_iHScrollPos == 0);
	Assert(m_iControlCurrent == 0);
	Assert(m_iDefaultButton == 0);
	Assert(m_iCurrentButton == 0);
	Assert(m_iCancelButton == 0);
	Assert(m_fDialogIsShowing == fFalse);  // Internal use only
	Assert(m_fDialogIsRunning == fFalse);  // Internal use only
	Assert(m_hProcessingBtnCmd == 0);  // Internal use only
	m_pwndParent = pwndParent;
	m_strKey = strNull;
	m_strRawText = strNull;
	m_strText = strNull;
	m_strFirstControl = strNull;
	m_strDefaultButton = strNull;
	m_strCancelButton = strNull;
	m_dialogModality = icmdModeless; 
	m_iEvent = idreNone;
	m_strArg = strNull;
	m_fAddingControls = fTrue;
	m_piHandler = (IMsiDialogHandler *)&riHandler;
	m_piEngine = (IMsiEngine *)&riEngine;
	m_piServices = m_piEngine->GetServices();
	m_piServices->Release();
	m_piDatabase = m_piEngine->GetDatabase();
	m_piDatabase->Release();
	m_idyChar = m_piHandler->GetTextHeight();
	m_piSelectionManager = 0;
	
	m_fCancelAvailable = true; // The default state is to let the dialog handle it normally.

	const GUID IID_IMsiSelectionManager = GUID_IID_IMsiSelectionManager;
	PMsiSelectionManager pSelectionManager(*m_piEngine, IID_IMsiSelectionManager);
	m_piSelectionManager = pSelectionManager;
	LOGBRUSH lb; 
	lb.lbStyle = BS_NULL;
	m_hbrTransparent = CreateBrushIndirect(&lb); 
	AddRefAllocator();
}

Bool CMsiDialog::DoCreateWindow (Bool fDialogCanBeMinimized, IMsiDialog* piParent)
{
	// Create the dialog box w/out being visible
	WindowRef pwndParent = 0;
	if (piParent)
	{
		PMsiRecord piRecord = &m_piServices->CreateRecord(1);
		AssertRecord(piParent->Attribute(fFalse, *MsiString(pcaDialogAttributeWindowHandle), *piRecord));
		pwndParent = (WindowRef) piRecord->GetHandle(1);
	}
	else
	{
		pwndParent = m_pwndParent;
	}
	m_pwndParent = pwndParent;
	DWORD dwStyle = WS_SYSMENU | WS_CAPTION | WS_DLGFRAME |
						 (pwndParent ? WS_POPUP : WS_OVERLAPPED) |
						 (m_iClientWidth < m_iFullWidth ? WS_HSCROLL : 0) |
						 (m_iClientHeight < m_iFullHeight ? WS_VSCROLL : 0);  
	if (fDialogCanBeMinimized)
		dwStyle |= WS_MINIMIZEBOX;
	DWORD dwExStyle = (pwndParent ? 0 : WS_EX_APPWINDOW) | (m_fRTLRO ? WS_EX_RTLREADING: 0) | (m_fRightAligned ? WS_EX_RIGHT : 0) | ((m_fLeftScroll && (m_iClientHeight < m_iFullHeight))? WS_EX_LEFTSCROLLBAR : 0);
	m_pWnd = WIN::CreateWindowEx(dwExStyle, m_strCancelButton.TextSize() ? MsiDialogCloseClassName : MsiDialogNoCloseClassName,
						m_strText,   
						dwStyle,                // Style
						m_iX,                   // horizontal position
						m_iY,                   // vertical position
						m_iWidth,               // window width
						m_iHeight,              // window height
						pwndParent,                           
						0,                      // hmenu
						g_hInstance,            // hinst
						0                       // lpvParam
						);
	if (m_pWnd == 0)
	{
		return (fFalse);
	}
	AssertNonZero(m_piHandler->RecordHandle(CWINHND((HANDLE)m_pWnd, iwhtWindow)) != -1);
#ifdef _WIN64	// !merced
	WIN::SetWindowLongPtr(m_pWnd, GWLP_USERDATA, (LONG_PTR)this);
#else			// win-32. This should be removed with the 64-bit windows.h is #included.
	WIN::SetWindowLong(m_pWnd, GWL_USERDATA, (long)this);
#endif
	m_pToolTip = WIN::CreateWindowEx(WS_EX_TOOLWINDOW, TOOLTIPS_CLASS, 0, TTS_ALWAYSTIP, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, m_pWnd, 0, g_hInstance, 0);
	if (m_pToolTip == 0)
	{
		return fFalse;
	}
	return (fTrue);
}

IMsiRecord* CMsiDialog::WindowCreate(IMsiRecord& riRecord, IMsiDialog* piParent, IMsiTable* piControlEventTable,
		IMsiTable* piControlConditionTable, IMsiTable* piEventMappingTable)
{
	if (m_iKey)
	{
		return PostError(Imsg(idbgSecondInitDialog), *m_strKey);
	}
	m_strKey = riRecord.GetMsiString(itabDIName);
	m_iKey = m_piDatabase->EncodeString(*m_strKey);
	m_fPreview = ToBool(!piControlEventTable && !piEventMappingTable);
	int attr = riRecord.GetInteger(itabDIAttributes);
	if (attr & msidbDialogAttributesSysModal)
		m_dialogModality = icmdSysModal;
	else if (attr & msidbDialogAttributesModal)
		m_dialogModality = icmdAppModal;
	else
		m_dialogModality = icmdModeless;
	m_fErrorDialog      = ToBool(attr & msidbDialogAttributesError);
	m_fTrackDiskSpace   = ToBool(attr & msidbDialogAttributesTrackDiskSpace);
	m_fUseCustomPalette = ToBool(attr & msidbDialogAttributesUseCustomPalette);
	
	int iAttributes     = riRecord.GetInteger(itabDIAttributes);
	m_fDialogIsShowing  = ToBool(iAttributes & msidbDialogAttributesVisible);
	m_fKeepModeless     = ToBool(iAttributes & msidbDialogAttributesKeepModeless);
	Bool fDialogCanBeMinimized = ToBool(iAttributes & msidbDialogAttributesMinimize);
	m_fRTLRO        = ToBool(iAttributes & msidbDialogAttributesRTLRO);
	m_fRightAligned = ToBool(iAttributes & msidbDialogAttributesRightAligned);
	m_fLeftScroll   = ToBool(iAttributes & msidbDialogAttributesLeftScroll);
	m_strRawText    = riRecord.GetMsiString(itabDITitle);
	m_strText       = m_piEngine->FormatText(*m_strRawText);
	m_strFirstControl  = riRecord.GetMsiString(itabDIFirstControl);
	m_strDefaultButton = riRecord.GetMsiString(itabDIDefButton);
	m_strCancelButton  = riRecord.GetMsiString(itabDICancelButton);
	SetRelativeLocation(riRecord.GetInteger(itabDIHCentering), riRecord.GetInteger(itabDIVCentering),
		riRecord.GetInteger(itabDIdX), riRecord.GetInteger(itabDIdY));

	if (!DoCreateWindow (fDialogCanBeMinimized, piParent))
	{
		return PostError(Imsg(idbgDialogWindow), m_piDatabase->DecodeString(m_iKey));
	}
	RECT rect;
	AssertNonZero(WIN::GetClientRect(m_pWnd, &rect));
	int iWidthDefect = m_iClientWidth - (rect.right - rect.left);
	int iHeightDefect = m_iClientHeight - (rect.bottom - rect.top);
	if (iWidthDefect || iHeightDefect)
	{
		m_iWidth += iWidthDefect;
		m_iHeight += iHeightDefect;
		m_iX = max(m_iScreenX, m_iX - iWidthDefect/2);
		m_iY = max(m_iScreenY, m_iY - iHeightDefect/2);
		AssertNonZero(WIN::MoveWindow(m_pWnd, m_iX, m_iY, m_iWidth, m_iHeight, fTrue));
#ifdef DEBUG
		AssertNonZero(WIN::GetClientRect(m_pWnd, &rect));
		Assert(m_iClientWidth == rect.right - rect.left);
		Assert(m_iClientHeight == rect.bottom - rect.top);
#endif // DEBUG
	}

	// set the scrollbar ranges
	SCROLLINFO SInfo;
	SInfo.cbSize = sizeof(SCROLLINFO);
	SInfo.fMask = g_fNT4 ? SIF_ALL : SIF_POS | SIF_RANGE;
	SInfo.nMin = 0;
	SInfo.nPos = 0;
	if (m_iClientWidth < m_iFullWidth)
	{
		SInfo.nMax = m_iFullWidth - (g_fNT4 ? 0 : m_iClientWidth);
		SInfo.nPage = m_iClientWidth;
		WIN::SetScrollInfo(m_pWnd, SB_HORZ, &SInfo, fTrue);
	}
	if (m_iClientHeight < m_iFullHeight)
	{
		SInfo.nMax = m_iFullHeight - (g_fNT4 ? 0 : m_iClientHeight);
		SInfo.nPage = m_iClientHeight;
		WIN::SetScrollInfo(m_pWnd, SB_VERT, &SInfo, fTrue);
	}
	//create internal tables
	PMsiRecord piReturn = CreateControlsTable();
	if (piReturn)
	{
		goto RETURNWITHERROR;
	}
	piReturn = CreateEventRegTable();
	if (piReturn)
	{
		goto RETURNWITHERROR;
	}
	if (piControlEventTable)
	{
		m_piControlEventTable = piControlEventTable;
		m_piControlEventTable->AddRef();
	}
	else
	{
		piReturn = CreateTable(pcaTablePControlEvent, *&m_piControlEventTable);
		if (piReturn)
			goto RETURNWITHERROR;
		::CreateTemporaryColumn(*m_piControlEventTable, icdString + icdPrimaryKey, itabCEDialog);
		::CreateTemporaryColumn(*m_piControlEventTable, icdString + icdPrimaryKey, itabCEControl);
		::CreateTemporaryColumn(*m_piControlEventTable, icdString + icdPrimaryKey, itabCEEvent);
		::CreateTemporaryColumn(*m_piControlEventTable, icdString + icdPrimaryKey, itabCEArgument);
		::CreateTemporaryColumn(*m_piControlEventTable, icdString + icdPrimaryKey, itabCECondition);
		::CreateTemporaryColumn(*m_piControlEventTable, icdLong + icdNullable, itabCEOrdering);
	}

	if (piControlConditionTable)
	{
		m_piControlConditionTable = piControlConditionTable;
		m_piControlConditionTable->AddRef();
	}
	else
	{
		piReturn = CreateTable(pcaTablePControlCondition, *&m_piControlConditionTable);
		if (piReturn)
			goto RETURNWITHERROR;
		::CreateTemporaryColumn(*m_piControlConditionTable, icdString + icdPrimaryKey, itabCCDialog);
		::CreateTemporaryColumn(*m_piControlConditionTable, icdString + icdPrimaryKey, itabCCControl);
		::CreateTemporaryColumn(*m_piControlConditionTable, icdString + icdPrimaryKey, itabCCAction);
		::CreateTemporaryColumn(*m_piControlConditionTable, icdString + icdPrimaryKey, itabCCCondition);
	}

	if (piEventMappingTable)
	{
		m_piEventMappingTable = piEventMappingTable;
		m_piEventMappingTable->AddRef();
	}
	else
	{
		piReturn = CreateTable(pcaTablePEventMapping, *&m_piEventMappingTable);
		if (piReturn)
			goto RETURNWITHERROR;
		::CreateTemporaryColumn(*m_piEventMappingTable, icdString + icdPrimaryKey, itabEMDialog);
		::CreateTemporaryColumn(*m_piEventMappingTable, icdString + icdPrimaryKey, itabEMControl);
		::CreateTemporaryColumn(*m_piEventMappingTable, icdString + icdPrimaryKey, itabEMEvent);
		::CreateTemporaryColumn(*m_piEventMappingTable, icdString + icdNullable, itabEMAttribute);
	}
	Ensure(::CursorCreate(*m_piEventMappingTable, pcaTablePEventMapping, fFalse, *m_piServices, *&m_piEventMappingCursor));

	return 0;

RETURNWITHERROR:
	if (m_pWnd)
	{
		AssertNonZero(WIN::DestroyWindow(m_pWnd));
		m_pWnd = 0;
	}
	return piReturn;
}


IMsiRecord* CMsiDialog::CreateControlsTable()
{
	Assert(!m_piControlsTable);
	Ensure(CreateTable(pcaTableIControls, *&m_piControlsTable));
	::CreateTemporaryColumn(*m_piControlsTable, icdString + icdPrimaryKey, itabCSKey);
	::CreateTemporaryColumn(*m_piControlsTable, IcdObjectPool(), itabCSWindow);
	::CreateTemporaryColumn(*m_piControlsTable, icdString + icdNullable, itabCSIndirectProperty);
	::CreateTemporaryColumn(*m_piControlsTable, icdString + icdNullable, itabCSProperty);
	::CreateTemporaryColumn(*m_piControlsTable, icdObject + icdNullable, itabCSPointer);
	::CreateTemporaryColumn(*m_piControlsTable, icdString + icdNullable, itabCSNext);
	::CreateTemporaryColumn(*m_piControlsTable, icdString + icdNullable, itabCSPrev);
	return 0;
}


IMsiRecord* CMsiDialog::CreateEventRegTable()
{
	Assert(!m_piEventRegTable);
	Ensure(CreateTable(pcaTableIEventRegister, *&m_piEventRegTable));
	::CreateTemporaryColumn(*m_piEventRegTable, icdString + icdPrimaryKey, itabEREvent);
	::CreateTemporaryColumn(*m_piEventRegTable, icdString + icdPrimaryKey, itabERPublisher);
	return 0;
}

void CMsiDialog::SetErrorRecord(IMsiRecord& riRecord)
{
	Assert(m_iKey);
	m_piErrorRecord = &riRecord;
}

HRESULT CMsiDialog::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown) || MsGuidEqual(riid, IID_IMsiDialog) || MsGuidEqual(riid, IID_IMsiData))
		*ppvObj = (IMsiDialog*)this;
	else if (MsGuidEqual(riid, IID_IMsiEvent))
		*ppvObj = (IMsiEvent*)this;
	else
		return (*ppvObj = 0, E_NOINTERFACE);
	AddRef();
	return NOERROR;
}

unsigned long CMsiDialog::AddRef()
{
	return ++m_iRefCnt;
} 

unsigned long CMsiDialog::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	if (m_pWnd)
	{
		AssertNonZero(WIN::DestroyWindow(m_pWnd));
		m_pWnd = 0;
	}
	
	PMsiServices pServices(m_piServices); // Release after memory freed
	m_piServices->AddRef();
	delete this;
	ReleaseAllocator();
	return 0;
}

#ifdef USE_OBJECT_POOL
unsigned int CMsiDialog::GetUniqueId() const
{
	return m_iCacheId;
}

void CMsiDialog::SetUniqueId(unsigned int id)
{
	Assert(m_iCacheId == 0);
	m_iCacheId = id;
}
#endif //USE_OBJECT_POOL

IMsiRecord* CMsiDialog::ControlsCursorCreate(IMsiCursor*& piCursor)
{
	return ::CursorCreate(*m_piControlsTable, pcaTableIControls, fFalse, *m_piServices, *&piCursor);
}


IMsiRecord* CMsiDialog::EventActionSz(const ICHAR * szEventString, const IMsiString& riActionString)
{
	MsiStringId idEvent = m_piDatabase->EncodeStringSz(szEventString);

	// No one handles this event
	if (idEvent == 0)
		return 0;

	return EventAction(idEvent, riActionString);
}
		
IMsiRecord* CMsiDialog::EventAction(MsiStringId idEvent, const IMsiString& riActionString)
{
		
	if (!m_iKey)
	{
		return PostError(Imsg(idbgUninitDialog));
	} 
	if (m_fAddingControls)
	{
		return PostError(Imsg(idbgAddingControls), *m_strKey);
	}
	int iControl;
	PMsiControl piControl(0);
	AssertSz(m_piEventMappingCursor->GetInteger(itabDSKey) == 0, "Cursor not reset");
	m_piEventMappingCursor->SetFilter(iColumnBit(itabEMEvent) | iColumnBit(itabEMDialog));
	m_piEventMappingCursor->Reset();
	AssertNonZero(m_piEventMappingCursor->PutInteger(itabEMEvent, idEvent));
	AssertNonZero(m_piEventMappingCursor->PutInteger(itabEMDialog, m_iKey));
	PMsiRecord piReturn(0);
	while (m_piEventMappingCursor->Next())
	{
		iControl = m_piEventMappingCursor->GetInteger(itabEMControl);
		piReturn = GetControl(iControl, *&piControl);
		if (piControl)
		{
			Ensure(HandleAction(piControl, riActionString));
		}
	}
	m_piEventMappingCursor->Reset();
	PMsiCursor piControlEventCursor(0);
	Ensure(::CursorCreate(*m_piControlEventTable, pcaTablePControlEvent, fFalse, *m_piServices, *&piControlEventCursor));
	piControlEventCursor->SetFilter(iColumnBit(itabCEEvent) | iColumnBit(itabCEDialog));
	piControlEventCursor->Reset();
	AssertNonZero(piControlEventCursor->PutInteger(itabCEEvent, idEvent));
	AssertNonZero(piControlEventCursor->PutInteger(itabCEDialog, m_iKey));
	while (piControlEventCursor->Next())
	{
		iControl = piControlEventCursor->GetInteger(itabEMControl);
		piReturn = GetControl(iControl, *&piControl);
		if (piControl)
		{
			Ensure(HandleAction(piControl, riActionString));
		}
	}

	return 0;
}


IMsiRecord* CMsiDialog::PropertyChanged(const IMsiString& riPropertyString, const IMsiString& riControlString)
{
	//some control has signaled changing a property value
	//we have to scan Control Condition table 
	//if we find some condition that is true, we perform the 
	//associated action
	if (!m_iKey)
	{
		return PostError(Imsg(idbgUninitDialog));
	}  
	if (m_fAddingControls)
	{
		return PostError(Imsg(idbgAddingControls), *m_strKey);
	}
	// check if caption has to be changed
	MsiString strNewText = m_piEngine->FormatText(*m_strRawText);
	if (!m_strText.Compare(iscExact, strNewText))
	{
		m_strText = strNewText;
		SetWindowTitle (*m_strText);
	}

	MsiString strCond;
	MsiString strAction;
	PMsiCursor piControlConditionCursor(0);
	Ensure(::CursorCreate(*m_piControlConditionTable, pcaTablePControlCondition, fFalse, *m_piServices, *&piControlConditionCursor));
	piControlConditionCursor->SetFilter(iColumnBit(itabCCDialog));
	piControlConditionCursor->Reset();
	AssertNonZero(piControlConditionCursor->PutInteger(itabCCDialog, m_iKey));
	iecEnum expResult;
	PMsiControl piControl(0); 
	while (piControlConditionCursor->Next())
	{
		if ((piControlConditionCursor->GetInteger(itabCCCondition)) == iTableNullString)
		{
			return PostError(Imsg(idbgCCMissingCond), *m_strKey);
		}
		else
		{
			strCond = MsiString(piControlConditionCursor->GetString(itabCCCondition));
			expResult = m_piEngine->EvaluateCondition(strCond);
		}
		if (expResult == iecError)
		{
			return PostError(Imsg(idbgCCEval), *m_strKey, *strCond);
		}
		if (expResult == iecTrue)  
		{
			Ensure(GetControl(piControlConditionCursor->GetInteger(itabCCControl), *&piControl));
			strAction = piControlConditionCursor->GetString(itabCCAction);
			Ensure(HandleAction(piControl, *strAction));
		}
	} 
	PMsiCursor piControlsCursor(0);
	Ensure(ControlsCursorCreate(*&piControlsCursor));
	if (riPropertyString.TextSize())  // if there is a property we want to notify the controls that tied to it
	{							   // otherwise we want to notify all the controls that have some property
		piControlsCursor->SetFilter(iColumnBit(itabCSProperty));
		AssertNonZero(piControlsCursor->PutString(itabCSProperty, riPropertyString));
	}
	else
	{
		piControlsCursor->SetFilter(0);
	}
	MsiStringId iControl = m_piDatabase->EncodeString(riControlString);
	while (piControlsCursor->Next())
	{
		if (piControlsCursor->GetInteger(itabCSKey) != iControl)
		{
			if (piControlsCursor->GetInteger(itabCSProperty) != iTableNullString) // if there is a property tied to this control
			{
				piControl = (IMsiControl *)piControlsCursor->GetMsiData(itabCSPointer);
				Assert(piControl);
				if (iControl != piControl->GetIntegerValue())
				{
					Ensure(piControl->GetPropertyFromDatabase());
				}
			}
		}
	}	   
 	piControlsCursor->Reset();
	if (riPropertyString.TextSize())  // if there is a property we want to notify the controls that tied to it
	{							   // otherwise we want to notify all the controls that have some property
		piControlsCursor->SetFilter(iColumnBit(itabCSIndirectProperty));
		AssertNonZero(piControlsCursor->PutString(itabCSIndirectProperty, riPropertyString));
		MsiString strNewValue = GetDBProperty(riPropertyString);
		while (piControlsCursor->Next())
		{
			if (piControlsCursor->GetInteger(itabCSKey) != iControl)
			{
				piControl = (IMsiControl *)piControlsCursor->GetMsiData(itabCSPointer);
				Assert(piControl);
				Ensure(piControl->GetIndirectPropertyFromDatabase());
				AssertNonZero(piControlsCursor->PutString(itabCSProperty, *strNewValue));	 // we have to update the property name
				AssertNonZero(piControlsCursor->Update()); 
			}  
		} 	 
	}
	else
	{
		piControlsCursor->SetFilter(0);
		while (piControlsCursor->Next())
		{
			if (piControlsCursor->GetInteger(itabCSKey) != iControl)
			{
				if (piControlsCursor->GetInteger(itabCSIndirectProperty) != iTableNullString) // if there is an indirect property tied to this control
				{
					piControl = (IMsiControl *)piControlsCursor->GetMsiData(itabCSPointer);
					Assert(piControl);
					Ensure(piControl->GetIndirectPropertyFromDatabase());
				}
			}
		} 
	}  
	PMsiCursor piEventRegCursor(0);
	Ensure(::CursorCreate(*m_piEventRegTable, pcaTableIEventRegister, fFalse, *m_piServices, *&piEventRegCursor));
	CTempBuffer<MsiStringId, 5> rgControls;
	int iControls = 0;
	MsiStringId iControlCall;
	rgControls.SetSize(0);
	
	while (piEventRegCursor->Next())
	{
		if ((iControlCall = piEventRegCursor->GetInteger(itabERPublisher)) != iControl)
		{
			if (!FInBuffer(rgControls, iControlCall))
			{
				Ensure(GetControl(iControlCall, *&piControl));
				Assert(piControl);
				Ensure(piControl->RefreshProperty ());
				rgControls.Resize(++iControls);
				rgControls[iControls-1] = iControlCall;
			}
		}
	}
	if (m_fDialogIsShowing && m_fInPlace)
	{
		WIN::SendMessage(m_pWnd, WM_SETREDRAW, fTrue, 0L);
		//Refresh ();
//		AssertNonZero(WIN::BringWindowToTop(m_pWnd));
		WIN::ShowWindow(m_pWnd, SW_SHOW);
	}
	return 0;
}

IMsiRecord* CMsiDialog::HandleAction(IMsiControl* piControl, const IMsiString& riActionString)
{
	if (!m_iKey)
	{
		return PostError(Imsg(idbgUninitDialog));
	} 
	PMsiRecord piRecord = &m_piServices->CreateRecord(1);
	if (riActionString.Compare(iscExact, pcaActionDefault))
	{
		SetDefaultButton(piControl->GetIntegerValue());
		return 0;
	}
	if (riActionString.Compare(iscExact, pcaActionUndefault))
	{
		SetDefaultButton(0);
		return 0;
	}
	if (riActionString.Compare(iscExact, pcaActionDisable))
	{
		AssertNonZero(piRecord->SetInteger(1, fFalse));
		Ensure(piControl->AttributeEx(fTrue, cabEnabled, *piRecord));
		if (piControl->GetIntegerValue() == m_iControlCurrent) // we just disabled the control with the focus
		{
			WIN::SetFocus(WIN::GetNextDlgTabItem(m_pWnd, 0, fFalse));
		}
		return 0;
	}
	if (riActionString.Compare(iscExact, pcaActionEnable))
	{
		AssertNonZero(piRecord->SetInteger(1, fTrue));
		Ensure(piControl->AttributeEx(fTrue, cabEnabled, *piRecord));
		return 0;
	}
	if (riActionString.Compare(iscExact, pcaActionHide))
	{
		AssertNonZero(piRecord->SetInteger(1, fFalse));
		Ensure(piControl->AttributeEx(fTrue, cabVisible, *piRecord));
		if (piControl->GetIntegerValue() == m_iControlCurrent) // we just hidden the control with the focus
		{
			WIN::SetFocus(WIN::GetNextDlgTabItem(m_pWnd, 0, fFalse));
		}
		return 0;
	}
	if (riActionString.Compare(iscExact, pcaActionShow))
	{
		AssertNonZero(piRecord->SetInteger(1, fTrue));
		Ensure(piControl->AttributeEx(fTrue, cabVisible, *piRecord));
		return 0;
	}
	return PostError(Imsg(idbgCCActionUnknown), riActionString);
}

IMsiRecord* CMsiDialog::ControlActivated(const IMsiString& riControlString)
{
	// some control has been clicked.
	// we scan the Control Event table to see if some event must be performed.
	// we evaluate all the conditions sorted by the Ordering column 
	// if we find a row with a blank condition, we save the information from 
	// this line as a default. If no conditional row is found to be true, then
	// this default event will be triggered.
	if (!m_iKey)
	{
		return PostError(Imsg(idbgUninitDialog));
	}  
	if (m_fAddingControls)
	{
		return PostError(Imsg(idbgAddingControls), *m_strKey);
	}
	Bool fFound = fFalse;
	Bool fDefFound = fFalse;
	MsiString strEvent;
	MsiString strDefEvent;
	MsiString strArg;
	MsiString strDefArg;
	MsiStringId iControl = m_piDatabase->EncodeString(riControlString);

	PMsiRecord pErrorRecord(0);
	PMsiView pControlEventView(0);
	pErrorRecord = m_piDatabase->OpenView(sqlControlEvent, ivcFetch, *&pControlEventView);
	if (pErrorRecord)
	{
		pErrorRecord->AddRef();
		return pErrorRecord;
	}
	PMsiRecord pQueryRec = &m_piServices->CreateRecord(2);
	AssertNonZero(pQueryRec->SetMsiString(1, *m_strKey));
	AssertNonZero(pQueryRec->SetMsiString(2, riControlString));
	Ensure(pControlEventView->Execute(pQueryRec));
	PMsiRecord pRecordNew(0);
	MsiString strCondition, strNull;
	while (pRecordNew = pControlEventView->Fetch())
	{
		strCondition = pRecordNew->GetMsiString(3);
		if (strCondition.TextSize()) 
		{
			strEvent = pRecordNew->GetMsiString(1);
			strArg = m_piEngine->FormatText(*MsiString(pRecordNew->GetMsiString(2)));
			if (strEvent.Compare(iscExact, pcaEventSpawnWaitDialog))
			{
				pErrorRecord = HandleWaitDialogEvent(*strArg, *strCondition);
				if (pErrorRecord)
				{
					if (pErrorRecord->GetInteger(1) == idbgStopControlEvents)
					{
						//  refresh properties
						Ensure(PropertyChanged(*strNull, *strNull));
						//  do not perform the remaining control events
						return 0;
					}
					else if (pErrorRecord->GetInteger(1) == idbgWaitCEEval)
					{
						return PostError(Imsg(idbgCEEval), *m_strKey, *MsiString(m_piDatabase->DecodeString(iControl)), *strCondition);
					}
					pErrorRecord->AddRef();
					return pErrorRecord;
				}
			}
			else
			{
				iecEnum expResult = m_piEngine->EvaluateCondition(strCondition);
				if (expResult == iecError)
				{
					return PostError(Imsg(idbgCEEval), *m_strKey, *MsiString(m_piDatabase->DecodeString(iControl)), *strCondition);
				}
				if (expResult == iecTrue)  
				{
					fFound = fTrue;
					// Have to do some checking to see if two events are not contradicting!!!!!!!!!!!!
					pErrorRecord = HandleEvent(*strEvent, *strArg);
					if (pErrorRecord)
					{
						if (pErrorRecord->GetInteger(1) == idbgStopControlEvents)
						{
							//  refresh properties
							Ensure(PropertyChanged(*strNull, *strNull));
							//  do not perform the remaining control events
							return 0;
						}
						pErrorRecord->AddRef();
						return pErrorRecord;
					}
				}
			}
		}
		else
		{
			fDefFound = fTrue;
			strDefEvent = pRecordNew->GetMsiString(1);
			strDefArg = m_piEngine->FormatText(*MsiString(pRecordNew->GetMsiString(2)));
		}
	}
	Ensure(pControlEventView->Close());
	if (!fFound && fDefFound)
	{
		Ensure(HandleEvent(*strDefEvent, *strDefArg));
	}
	return 0;           
}


IMsiRecord* CMsiDialog::RegisterControlEvent(const IMsiString& riControlString, Bool fRegister, const ICHAR * szEventString)
{
	//this function registers/unregisters the publishers of events 
	if (!m_iKey)
	{
		return PostError(Imsg(idbgUninitDialog));
	}  
	MsiStringId iControl = m_piDatabase->EncodeString(riControlString);
	MsiStringId iEvent = m_piDatabase->EncodeStringSz(szEventString);
	//MsiString strControlOld;
	//first let's find the event in the table.
	//if it is not found and we are registering a control
	//then the event is added to the table
	//if the event is not found and we are unregistering 
	//a control, then something went wrong!
	PMsiCursor piEventRegCursor(0);
	Ensure(::CursorCreate(*m_piEventRegTable, pcaTableIEventRegister, fFalse, *m_piServices, *&piEventRegCursor));
/*	piEventRegCursor->SetFilter(iColumnBit(itabEREvent));
	piEventRegCursor->Reset();
	AssertNonZero(piEventRegCursor->PutString(itabEREvent, riEventString)); 
	if (!piEventRegCursor->Next())
	{
		Assert(fRegister);
		AssertNonZero(piEventRegCursor->PutString(itabEREvent, riEventString));
	}*/
	//the table is updated according to the arguments
	//only one control can be registered as a publisher 
	//If we try to register
	//a second one, an error is generated
	//if we try to unregister a control that is not registered
	//then something went wrong!
	piEventRegCursor->SetFilter(iColumnBit(itabEREvent) + iColumnBit(itabERPublisher));
	AssertNonZero(piEventRegCursor->PutString(itabERPublisher, riControlString));
	AssertNonZero(piEventRegCursor->PutString(itabEREvent, *MsiString(szEventString)));
	if (fRegister)
	{	/*
		strControlOld = piEventRegCursor->GetString(itabERPublisher);
		if(strControlOld.TextSize())
		{
			return PostError(Imsg(idbgERSecondPublisher), m_strKey, strControlOld, riControlString, riEventString);
		}*/
		AssertNonZero(piEventRegCursor->Insert());
	}
	else //unregistering
	{
		if(piEventRegCursor->Next())
			AssertNonZero(piEventRegCursor->Delete());
	}
	return 0;
}


IMsiRecord* CMsiDialog::HandleWaitDialogEvent(const IMsiString& riDialogString, const IMsiString& riConditionString)
{
	iecEnum expResult = m_piEngine->EvaluateCondition(riConditionString.GetString());
	if (expResult == iecError)
	{
		return PostError(Imsg(idbgWaitCEEval));
	}
	else if (expResult == iecFalse)  
	{
		riConditionString.CopyToBuf(s_szWaitCondition, MAX_WAIT_EXPRESSION_SIZE - 1);
		idreEnum idreReturn = 
			m_piHandler->DoModalDialog(m_piDatabase->EncodeString(riDialogString),
												m_iKey);
		s_szWaitCondition[0] = 0;

		if ( idreReturn == idreExit )
			return PostError(Imsg(idbgStopControlEvents));
	}
	return 0;

}


IMsiRecord* CMsiDialog::HandleEvent(const IMsiString& riEventStringName, const IMsiString& riArgumentString)
{
	if (!m_iKey)
	{
		return PostError(Imsg(idbgUninitDialog));
	}  
	// [property_name] means that we are setting a property
	riEventStringName.AddRef();
	MsiString strPropertyName = riEventStringName;
	if (strPropertyName.Compare(iscStart, TEXT("[")))
	{
		AssertNonZero(strPropertyName.Remove(iseIncluding, TEXT('[')));
		if (strPropertyName.Remove(iseFrom, TEXT(']')))
		{
			riArgumentString.AddRef();
			MsiString strPropertyValue = riArgumentString;
			MsiString strNull;
			if (strPropertyValue.Compare(iscExact, TEXT("{}")))
			{
				strPropertyValue = strNull;
			}
			SetDBProperty(*strPropertyName, *strPropertyValue);
			return PropertyChanged(*strPropertyName, *strNull);
		}
	}
	// first check if the event is one of the basic ones, that the DLL handles
	if (riEventStringName.Compare(iscExact, pcaEventNewDialog))
	{
		return NewDialogEvent(riArgumentString);
	}
	if (riEventStringName.Compare(iscExact, pcaEventSpawnDialog))
	{
		return SpawnDialogEvent(riArgumentString);
	}
	if (riEventStringName.Compare(iscExact, pcaEventEndDialog))
	{
		return EndDialogEvent(riArgumentString);
	}
	if (riEventStringName.Compare(iscExact, pcaEventReset))
	{
		return Reset();
	}
	if (riEventStringName.Compare(iscExact, pcaEventValidateProductID))
	{
		return ValidateProductIDEvent();
	}
	if (riEventStringName.Compare(iscExact, pcaEventEnableRollback))
	{
		m_piSelectionManager->EnableRollback(riArgumentString.Compare(iscExactI,TEXT("False")) != 0 ? fFalse : fTrue);
		return 0;
	}
	if (riEventStringName.Compare(iscExact, pcaEventSetInstallLevel))
	{
		riArgumentString.AddRef();
		int iInstallLevel = MsiString(riArgumentString);
		return m_piSelectionManager->SetInstallLevel(iInstallLevel);
	}
	if (riEventStringName.Compare(iscExact, pcaEventAddLocal))
	{
		return ConfigureFeatureEvent(riArgumentString,iisLocal);
	}
	if (riEventStringName.Compare(iscExact, pcaEventAddSource))
	{
		return ConfigureFeatureEvent(riArgumentString, iisSource);
	}
	if (riEventStringName.Compare(iscExact, pcaEventRemove))
	{
		return ConfigureFeatureEvent(riArgumentString, iisAbsent);
	}
	if (riEventStringName.Compare(iscExact, pcaEventReinstall))
	{
		return ConfigureFeatureEvent(riArgumentString, iisReinstall);
	}
	if (riEventStringName.Compare(iscExact, pcaEventReinstallMode))
	{
		return ReinstallModeEvent(riArgumentString);
	}
	if (riEventStringName.Compare(iscExact, pcaEventCheckTargetPath))
	{
		return TargetPathEvent(riArgumentString , itpCheck);
	}
	if (riEventStringName.Compare(iscExact, pcaEventSetTargetPath))
	{
		return TargetPathEvent(riArgumentString, itpSet);
	}
	if (riEventStringName.Compare(iscExact, pcaEventCheckExistingTargetPath))
	{
		return TargetPathEvent(riArgumentString, itpCheckExisting);
	}
	if (riEventStringName.Compare(iscExact, pcaEventDoAction))
	{
		return DoActionEvent(riArgumentString);
	}

	// it is not a basic event, let's find the control that publishes it
	PMsiCursor piEventRegCursor(0);
	Ensure(::CursorCreate(*m_piEventRegTable, pcaTableIEventRegister, fFalse, *m_piServices, *&piEventRegCursor));
	piEventRegCursor->SetFilter(iColumnBit(itabEREvent));
	piEventRegCursor->Reset();
	AssertNonZero(piEventRegCursor->PutString(itabEREvent, riEventStringName));
	MsiStringId iControl;
	Bool fFoundPublisher = fFalse;
	while (piEventRegCursor->Next())
	{
		iControl = piEventRegCursor->GetInteger(itabERPublisher);
		if (iControl)
		{   
			PMsiControl piControl(0);
			Ensure(GetControl(iControl, *&piControl));
			piEventRegCursor->Reset();
			Ensure(piControl->HandleEvent(riEventStringName, riArgumentString));
			fFoundPublisher = fTrue;
		}
		else
		{
			return PostError(Imsg(idbgEventNoPublisher), riEventStringName);
		}
	}
	if (fFoundPublisher)
	{
		return 0;
	}
	else
	{
		return PostError(Imsg(idbgEventNotFound), riEventStringName);
	}
}

IMsiRecord* CMsiDialog::NewDialogEvent(const IMsiString& riDialogString)
{
	m_fDialogIsRunning = fFalse;
	m_iEvent = idreNew;
	riDialogString.AddRef();
	m_strArg = riDialogString;
	return 0;
}

IMsiRecord* CMsiDialog::SpawnDialogEvent(const IMsiString& riDialogString)
{
	if (m_dialogModality != icmdModeless || m_fDialogIsRunning == fTrue)
	{
		m_fDialogIsRunning = fFalse;
		m_iEvent = idreSpawn;
		riDialogString.AddRef();
		m_strArg = riDialogString;
	}
	return 0;
}


IMsiRecord* CMsiDialog::ValidateProductIDEvent()
{
	if (!m_piEngine->ValidateProductID(true))
	{
		PMsiRecord piErrorRec = PostError(Imsg(imsgInvalidPID), *MsiString(GetDBProperty(*MsiString(*IPROPNAME_PIDKEY))));
		m_piEngine->Message (imtError, *piErrorRec);
	}
	return 0;
}

IMsiRecord* CMsiDialog::ConfigureFeatureEvent(const IMsiString& riArgumentString,iisEnum iis)
{
	IMsiRecord *piRec;

	m_piHandler->ShowWaitCursor();
	piRec = m_piSelectionManager->ConfigureFeature(riArgumentString,iis);
	m_piHandler->RemoveWaitCursor();

	return piRec;
}

IMsiRecord* CMsiDialog::DoActionEvent(const IMsiString& riArgumentString)
{
	iesEnum iesStat = m_piEngine->DoAction(riArgumentString.GetString());
	if (iesStat == iesFailure)
	{
		IMsiRecord* piError = PostError(Imsg(idbgActionFailed), riArgumentString);
		m_piEngine->Message(imtInfo, *piError);
		return piError;
	}
	
	return 0;
}

IMsiRecord* CMsiDialog::ReinstallModeEvent(const IMsiString& riArgumentString)
{
	return m_piSelectionManager->SetReinstallMode(riArgumentString);
}

struct Event
{
	const ICHAR* pcaArgument;
	int idre;
	Bool fError;
};

Event evDialogEvents[] =        {
								{ pcaEventArgumentReturn,      idreReturn,      fFalse },
								{ pcaEventArgumentExit,        idreExit,        fFalse },
								{ pcaEventArgumentRetry,       idreRetry,       fFalse },
								{ pcaEventArgumentIgnore,      idreIgnore,      fFalse },
								{ pcaEventArgumentErrorOk,     idreErrorOk,     fTrue  },
								{ pcaEventArgumentErrorCancel, idreErrorCancel, fTrue  },
								{ pcaEventArgumentErrorAbort,  idreErrorAbort,  fTrue  },
								{ pcaEventArgumentErrorRetry,  idreErrorRetry,  fTrue  },
								{ pcaEventArgumentErrorIgnore, idreErrorIgnore, fTrue  },
								{ pcaEventArgumentErrorYes,    idreErrorYes,    fTrue  },
								{ pcaEventArgumentErrorNo,     idreErrorNo,     fTrue  },
								{ 0,                           0,               fFalse },
								};

IMsiRecord* CMsiDialog::EndDialogEvent(const IMsiString& riArgumentString)
{
	m_fDialogIsRunning = fFalse;

	for (Event* ev = evDialogEvents; ev->pcaArgument; ev++)
	{
		if (riArgumentString.Compare(iscExact, ev->pcaArgument))
		{
			m_iEvent = ev->idre;
			return (m_fErrorDialog == ev->fError) ?  0 : 
						PostError(Imsg(idbgEventNotAllowed), *m_strKey, *MsiString(*(ev->pcaArgument)));
		}
	}

	//if we get here, EndDialog has an unrecognized argument
	return PostError(Imsg(idbgEndDialogArg), riArgumentString);
}

IMsiRecord* CMsiDialog::TargetPathEvent(const IMsiString& riArgumentString, itpEnum itp)
{
	riArgumentString.AddRef();
	MsiString strProperty = riArgumentString;
	if (strProperty.TextSize() == 0)
	{
		return PostError(Imsg(idbgCheckPathArgument), *m_strKey);
	}
	if (strProperty.Compare(iscWithin, TEXT("[")))
	{
		MsiString strIndirect = strProperty.Extract(iseAfter, TEXT('['));
		if (!strIndirect.Remove(iseFrom, TEXT(']')))
		{
			return PostError(Imsg(idbgCheckPathArgument), *m_strKey);
		}
		strProperty = GetDBProperty(*strIndirect);
		if (strProperty.TextSize() == 0)
		{
			return PostError(Imsg(idbgCheckPathArgument), *m_strKey);
		}
	}
	MsiString strPath = GetDBProperty(*strProperty);
	if (strPath.TextSize() == 0)
	{
		return PostError(Imsg(idbgCheckPathArgument), *m_strKey);
	}
	PMsiPath piPath(0);
	if (PMsiRecord(m_piServices->CreatePath(strPath,*&piPath)))
	{
		PMsiRecord piReturn = &m_piServices->CreateRecord(2);
		ISetErrorCode(piReturn, Imsg(imsgNotAValidPath));
		AssertNonZero(piReturn->SetMsiString(2, *strPath));
		m_piEngine->Message(imtError, *piReturn);
		return PostError(Imsg(idbgStopControlEvents));
	}
	PMsiVolume piVolume = &piPath->GetVolume();
	Bool fMissing = ToBool(piVolume->DiskNotInDrive());
	while (fMissing)
	{
		PMsiRecord piReturn = &m_piServices->CreateRecord(2);
		ISetErrorCode(piReturn, Imsg(imsgVolumeMissing));
		MsiString strVolume = piVolume->GetPath();
		AssertNonZero(piReturn->SetMsiString(2, *strVolume));
		imsEnum iReturn = m_piEngine->Message(imtEnum(imtError | imtRetryCancel | imtDefault2), *piReturn);
		if (iReturn == imsCancel)
		{
			return PostError(Imsg(idbgStopControlEvents));
		}
		Assert(iReturn == imsRetry);
		fMissing = ToBool(piVolume->DiskNotInDrive());
	}
	Assert(!fMissing);

	if (itp == itpCheckExisting)
	{
		Bool fExists;
		piPath->Exists(fExists);
		if (!fExists)
		{
			PMsiRecord piReturn = &m_piServices->CreateRecord(2);
			ISetErrorCode(piReturn, Imsg(imsgPathDoesNotExist));
			AssertNonZero(piReturn->SetMsiString(2, *strPath));
			m_piEngine->Message(imtError, *piReturn);
			return PostError(Imsg(idbgStopControlEvents));
		}
	}
	if (itp == itpSet)
	{
		m_piHandler->ShowWaitCursor();
		const GUID IID_IMsiDirectoryManager = GUID_IID_IMsiDirectoryManager;
		PMsiDirectoryManager pDirectoryManager(*m_piEngine, IID_IMsiDirectoryManager);
		PMsiRecord piSet = pDirectoryManager->SetTargetPath(*strProperty, strPath, fTrue);
		m_piHandler->RemoveWaitCursor();
		if (piSet)
		{
			m_piEngine->Message(imtError, *piSet);
			return PostError(Imsg(idbgStopControlEvents));
		}
	}
	return 0;
}

IMsiRecord* CMsiDialog::PublishEventSz(const ICHAR* szEventString, IMsiRecord& riRecord)
{
	MsiStringId idEvent = m_piDatabase->EncodeStringSz(szEventString);

	// This event is not subscribed to
	if (idEvent == 0)
		return 0;
		
	return PublishEvent(idEvent, riRecord);

}

IMsiRecord* CMsiDialog::PublishEvent(MsiStringId idEventString, IMsiRecord& riRecord)
{
	if (!m_iKey)
	{
		return PostError(Imsg(idbgUninitDialog));
	} 
	if (m_fAddingControls)
	{
		MsiString strEvent(m_piDatabase->DecodeString(idEventString));
		
		if (strEvent.Compare(iscExact, pcaEventActionData)  || strEvent.Compare(iscExact, pcaEventActionText))
		{
			return 0;
		}
		else
		{
		// don't post error messages for those three events because they come during the destruction of an aborted dialog
			return PostError(Imsg(idbgAddingControls), *m_strKey);
		}
	}
	PMsiControl piControl(0);
	MsiStringId iControl;
	MsiString strAttributeName;
	AssertSz(m_piEventMappingCursor->GetInteger(itabDSKey) == 0, "Cursor not reset");
	m_piEventMappingCursor->SetFilter(iColumnBit(itabEMDialog)|iColumnBit(itabEMEvent));
	m_piEventMappingCursor->Reset();
	AssertNonZero(m_piEventMappingCursor->PutInteger(itabEMDialog, m_iKey));
	AssertNonZero(m_piEventMappingCursor->PutInteger(itabEMEvent, idEventString));
	PMsiRecord piReturn(0);
	while (m_piEventMappingCursor->Next())
	{
		if (m_piEventMappingCursor->GetInteger(itabEMAttribute) != iTableNullString)
		{
			iControl = m_piEventMappingCursor->GetInteger(itabEMControl);
			piReturn = GetControl(iControl, *&piControl);
			if (!piControl)
			{
				m_piEventMappingCursor->Reset();
				return PostError(Imsg(idbgEMInvalidControl), *m_strKey, *MsiString(m_piDatabase->DecodeString(idEventString)), *MsiString(m_piDatabase->DecodeString(iControl)));
			}
			strAttributeName = m_piEventMappingCursor->GetString(itabEMAttribute);
			if(piReturn = piControl->Attribute(fTrue, *strAttributeName, riRecord))
			{
				piReturn->AddRef();
				m_piEventMappingCursor->Reset();
				return piReturn;
				//return PostError(Imsg(idbgEMAttribute), riEventString, m_strKey, MsiString(m_piDatabase->DecodeString(iControl)));
			} 
		}
	}
	m_piEventMappingCursor->Reset();
	return 0;
}


const IMsiString& CMsiDialog::GetMsiStringValue() const
{
	const IMsiString &strRet = *m_strKey;
	strRet.AddRef();
	return strRet;
}

int CMsiDialog::GetIntegerValue() const
{
	return m_iKey;
}

CMsiDialog::~CMsiDialog()
{
	if (m_hbrTransparent)
		AssertNonZero(WIN::DeleteObject(m_hbrTransparent));
	if (m_hPalette)
		AssertNonZero(WIN::DeleteObject(m_hPalette));
	if ( m_pWnd && WIN::IsWindow(m_pWnd) )
	{
		AssertSz(false, TEXT("Please call eugend regarding bug # 6849 if you see this."));
		AssertNonZero(m_piHandler->DestroyHandle((HANDLE)m_pWnd) != -1);
	}
#ifdef USE_OBJECT_POOL
	m_piDatabase->RemoveObjectData(m_iCacheId);
#endif //USE_OBJECT_POOL
}

IMsiRecord* CMsiDialog::GetControlFromWindow(const WindowRef hControl,
															IMsiControl*& rpiControl)
{
	rpiControl = 0;
	if (!m_iKey)
		return PostError(Imsg(idbgUninitDialog));

	static ICHAR rgchHandle[20];
	if ( hControl == 0 )
	{
		ASSERT_IF_FAILED(StringCchPrintf(rgchHandle, sizeof(rgchHandle)/sizeof(ICHAR), TEXT("%#08x"), hControl));
		return PostError(Imsg(idbgControlNotFound), *MsiString(rgchHandle), *m_strKey);
	}

	if (m_piControlsCursor == 0)
		m_piControlsCursor = m_piControlsTable->CreateCursor(fFalse);
	if (!m_piControlsCursor)
		return PostError(Imsg(idbgCursorCreate), *MsiString(*pcaTableIControls));

	PMsiRecord piRecord = &m_piServices->CreateRecord(1);
	IMsiRecord* pReturn = 0;

	m_piControlsCursor->SetFilter(iColumnBit(itabCSWindow));
	m_piControlsCursor->Reset();

	AssertNonZero(PutHandleData(m_piControlsCursor, itabCSWindow, (UINT_PTR)hControl));
	if ( m_piControlsCursor->Next() )
	{
		rpiControl = (IMsiControl *)(m_piControlsCursor->GetMsiData(itabCSPointer));
		Assert(rpiControl);
	}
	m_piControlsCursor->Reset();
	if ( !rpiControl )
	{
		ASSERT_IF_FAILED(StringCchPrintf(rgchHandle, sizeof(rgchHandle)/sizeof(ICHAR), TEXT("%#08x"), hControl));
		pReturn = PostError(Imsg(idbgControlNotFound), *MsiString(rgchHandle), *m_strKey);
	}

	return pReturn;
}

IMsiRecord* CMsiDialog::GetControl(MsiStringId iControl, IMsiControl*& rpiControl)
{
	if (!m_iKey)
	{
		rpiControl = 0;
		return PostError(Imsg(idbgUninitDialog));
	}
	if (iControl == 0)
	{
		rpiControl = 0;
		return PostError(Imsg(idbgControlNotFound), *MsiString((int)iControl), *m_strKey); 
	}
	if (m_piControlsCursor == 0)
		m_piControlsCursor = m_piControlsTable->CreateCursor(fFalse);
	if (!m_piControlsCursor)
	{
		rpiControl = 0;
		return PostError(Imsg(idbgCursorCreate), *MsiString(*pcaTableIControls));
	}
	m_piControlsCursor->SetFilter(iColumnBit(itabCSKey));
	m_piControlsCursor->Reset();
	AssertNonZero(m_piControlsCursor->PutInteger(itabCSKey, iControl));
	if (m_piControlsCursor->Next())
	{
		rpiControl = (IMsiControl *)(m_piControlsCursor->GetMsiData(itabCSPointer));
		Assert(rpiControl);
		m_piControlsCursor->Reset();
		return 0; 
	}
	else 
	{
		m_piControlsCursor->Reset();
		rpiControl = 0;
		return PostError(Imsg(idbgControlNotFound), *MsiString((int)iControl), *m_strKey); 
	}
}

IMsiRecord* CMsiDialog::GetControl(const IMsiString& riControlString, IMsiControl*& rpiControl)
{   
	if (PMsiRecord(GetControl(m_piDatabase->EncodeString(riControlString), rpiControl)))
	{
		rpiControl = 0;
		return PostError(Imsg(idbgControlNotFound), riControlString, *m_strKey);
	}
	else 
	{
		return 0;
	}
}

IMsiRecord* CMsiDialog::EnableControl (IMsiControl& riControl, Bool fEnable)
{
	PMsiRecord piRecord = &m_piServices-> CreateRecord (1);
	AssertNonZero(piRecord-> SetInteger (1, fEnable));
	return (riControl.Attribute (fTrue, *MsiString(*pcaControlAttributeEnabled), *piRecord));
}

IMsiRecord* CMsiDialog::SetFocus(const IMsiString& riControlString)
{
	return SetFocus(m_piDatabase->EncodeString(riControlString));
}

void CMsiDialog::SetLocation(int Left, int Top, int Width, int Height)
{
	m_iX = Left;
	m_iY = Top;
	m_iWidth = Width;
	m_iHeight = Height;
}

void CMsiDialog::SetRelativeLocation(int irelX, int irelY, int iWidth, int iHeight)
{
	int iCaptionHeight = GetDBPropertyInt(*MsiString(*IPROPNAME_CAPTIONHEIGHT));
	RECT WorkArea;
	AssertNonZero(WIN::SystemParametersInfo(SPI_GETWORKAREA, 0, &WorkArea, 0));
	m_iScreenX = WorkArea.left;
	m_iScreenY = WorkArea.top;
	m_iScreenWidth = WorkArea.right - WorkArea.left;
	m_iScreenHeight = WorkArea.bottom - WorkArea.top;
	int iBorderWidth = GetSystemMetrics(g_fChicago ? SM_CXEDGE : SM_CXBORDER);
	int iBorderHeight = GetSystemMetrics(g_fChicago ? SM_CYEDGE : SM_CYBORDER);
	int iHorPadding = 2 * iBorderWidth + (g_fChicago ? 2 : 0);
	int iVertPadding = iBorderHeight + iCaptionHeight + (g_fChicago ? 2 + iBorderHeight : 0);
	m_iFullWidth = iWidth * m_idyChar / iDlgUnitSize;
	m_iFullHeight = iHeight * m_idyChar / iDlgUnitSize;
	Bool fTooWide = fFalse;
	Bool fTooHigh = fFalse;
	if (m_iFullWidth + iHorPadding > m_iScreenWidth)
	{
		iVertPadding += GetSystemMetrics(SM_CYHSCROLL);
		fTooWide = fTrue;
	}
	if (m_iFullHeight + iVertPadding > m_iScreenHeight)
	{
		iHorPadding += GetSystemMetrics(SM_CXVSCROLL);
		fTooHigh = fTrue;
	}
	// this is so much fun, we want to repeat it once more!
	// actually it can happen that it fits originaly, but after adding a scroll bar it does not fit anymore
	if (m_iFullWidth + iHorPadding  > m_iScreenWidth)
	{
		if (!fTooWide) // avoid padding twice
			iVertPadding += GetSystemMetrics(SM_CYHSCROLL);
		m_iWidth = m_iScreenWidth;
		m_iClientWidth = m_iWidth - iHorPadding;
	}
	else
	{
		m_iWidth = m_iFullWidth + iHorPadding;
		m_iClientWidth = m_iFullWidth;
	}
	if (m_iFullHeight + iVertPadding > m_iScreenHeight)
	{
		if (!fTooHigh) // avoid padding twice
			iHorPadding += GetSystemMetrics(SM_CXVSCROLL);
		m_iHeight = m_iScreenHeight;
		m_iClientHeight = m_iHeight - iVertPadding;
	}
	else
	{
		m_iHeight = m_iFullHeight + iVertPadding;
		m_iClientHeight = m_iFullHeight;
	}
	m_iX = m_iScreenX + (int)((irelX * (m_iScreenWidth - m_iWidth)) / 100);
	m_iY = m_iScreenY + (int)((irelY * (m_iScreenHeight - m_iHeight)) / 100);
}


void CMsiDialog::GetLocation(int &Left, int &Top, int &Width, int &Height)
{
	Left = m_iX;
	Top = m_iY;
	Width = m_iWidth;
	Height = m_iHeight;
}

IMsiRecord* CMsiDialog::CheckFieldCount (IMsiRecord& riRecord, int iCount, const ICHAR* szMsg)
{
	return (riRecord.GetFieldCount () >= iCount) ? 0 : PostError(Imsg(idbgDialogAttributeShort), *MsiString(iCount), *MsiString(szMsg));
}


IMsiRecord* CMsiDialog::GetpWnd(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeWindowHandle));
	riRecord.SetHandle(1, (HANDLE)m_pWnd);
	return 0;
}

IMsiRecord* CMsiDialog::GetPalette(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributePalette));
	riRecord.SetHandle(1, (HANDLE)m_hPalette);
	return 0;
}

IMsiRecord* CMsiDialog::SetPalette(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributePalette));
	m_hPalette = (HPALETTE)riRecord.GetHandle(1);
	HandleQueryNewPalette();
	return 0;
}

IMsiRecord* CMsiDialog::GetUseCustomPalette(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeUseCustomPalette));
	riRecord.SetInteger(1, (int)m_fUseCustomPalette);
	return 0;
}

IMsiRecord* CMsiDialog::GetToolTip(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeToolTip));
	riRecord.SetHandle(1, (HANDLE)m_pToolTip);
	return 0;
}

void CMsiDialog::Refresh ()
{
	if (m_pWnd)
		AssertNonZero(WIN::InvalidateRect(m_pWnd, 0, fTrue));
}

IMsiRecord* CMsiDialog::SetFocus(MsiStringId iNewControlWithFocus)
{
	PMsiControl piControl(0);
	Ensure(GetControl(iNewControlWithFocus, *&piControl));
	Assert(piControl);
	if (piControl->CanTakeFocus() == fFalse)
	{
		return PostError(Imsg(idbgControlCantTakeFocus), *m_strKey, *MsiString(piControl->GetMsiStringValue()));
	}
	else
	{
		Ensure(piControl->SetFocus());
		m_iControlCurrent = iNewControlWithFocus;
	}
	return 0;
}


IMsiRecord* CMsiDialog::GetFocus(IMsiControl*& rpiControl)
{
	return GetControl(m_iControlCurrent, rpiControl);
}



IMsiRecord* CMsiDialog::ControlsSetProperties()
{
	PMsiCursor piControlsCursor(0);
	Ensure(ControlsCursorCreate(*&piControlsCursor));
	PMsiControl piControl(0);
	while (piControlsCursor->Next())
	{
		piControl = (IMsiControl *)(piControlsCursor->GetMsiData(itabCSPointer));
		Assert(piControl);
		Ensure(piControl->SetPropertyInDatabase());
	}
	return 0;
}

IMsiRecord* CMsiDialog::AddControl(IMsiControl* piControl, IMsiRecord& riRecord)
{
	if (!m_iKey)
	{
		return PostError(Imsg(idbgUninitDialog));
	} 
	PMsiCursor piControlsCursor(0);
	Ensure(ControlsCursorCreate(*&piControlsCursor));
	piControlsCursor->SetFilter(0);
	piControlsCursor->Reset();
	if (piControl)
	{
		AssertNonZero(piControlsCursor->PutString(itabCSKey, *MsiString(riRecord.GetMsiString(itabCOControl))));
		Ensure(piControl->WindowCreate(riRecord));
		PMsiRecord piProperty = &m_piServices->CreateRecord(1);
		Ensure(piControl->AttributeEx(fFalse, cabWindowHandle, *piProperty));

		AssertNonZero(PutHandleDataNonNull(piControlsCursor, itabCSWindow, (UINT_PTR)piProperty->GetHandle(1)));
		Ensure(piControl->AttributeEx(fFalse, cabPropertyName, *piProperty));
		AssertNonZero(piControlsCursor->PutString(itabCSProperty, *MsiString(piProperty->GetMsiString(1))));
		AssertNonZero(piProperty->SetNull(1));
		Ensure(piControl->AttributeEx(fFalse, cabIndirectPropertyName, *piProperty));
		AssertNonZero(piControlsCursor->PutString(itabCSIndirectProperty, *MsiString(piProperty->GetMsiString(1))));
		AssertNonZero(piControlsCursor->PutMsiData(itabCSPointer, piControl));	
		AssertNonZero(piControlsCursor->PutString(itabCSNext, *MsiString(riRecord.GetMsiString(itabCONext))));
		AssertNonZero(piControlsCursor->Insert());
		if (!m_fAddingControls)				  // we are done with the initial addition cycle, this is a new control
		{
			int iNext = piControlsCursor->GetInteger(itabCSNext);
			if (iNext)
			{
				int iThis = piControlsCursor->GetInteger(itabCSKey);
				piControlsCursor->SetFilter(iColumnBit(itabCSKey));
				piControlsCursor->Reset();
				AssertNonZero(piControlsCursor->PutInteger(itabCSKey, iNext));
				if (!piControlsCursor->Next())
				{
					return PostError(Imsg(idbgControlLoopOpen), *m_strKey, *MsiString(m_piDatabase->DecodeString(iThis)), *MsiString(m_piDatabase->DecodeString(iNext)));   
				}
				int iPrev = piControlsCursor->GetInteger(itabCSPrev);
				AssertNonZero(piControlsCursor->PutInteger(itabCSPrev, iThis));
				AssertNonZero(piControlsCursor->Update());
				piControlsCursor->Reset();
				AssertNonZero(piControlsCursor->PutInteger(itabCSKey, iPrev));
				AssertNonZero(piControlsCursor->Next());
				AssertNonZero(piControlsCursor->PutInteger(itabCSNext, iThis));
				AssertNonZero(piControlsCursor->Update());
				piControlsCursor->Reset();
				AssertNonZero(piControlsCursor->PutInteger(itabCSKey, iThis));
				AssertNonZero(piControlsCursor->Next());
				AssertNonZero(piControlsCursor->PutInteger(itabCSPrev, iPrev));
				AssertNonZero(piControlsCursor->Update());

			}
		}
	}
	// A NULL control indicates the end of the AddControl phase - initialize time
	else
	{
		Ensure(FinishCreate());
	}
	return 0;
}

IMsiRecord* CMsiDialog::FinishCreate()
{
	// Now that all controls have been added, we can resolve special control names
	// into database StringID values
	if (!m_iKey)
	{
		return PostError(Imsg(idbgUninitDialog));
	} 
	PMsiCursor piControlsCursor(0);
	Ensure(ControlsCursorCreate(*&piControlsCursor));
	piControlsCursor->SetFilter(0);

	piControlsCursor->Reset();

	if (!piControlsCursor->Next())	// we should have at least one control
	{
		return PostError(Imsg(idbgNoControl), *m_strKey);
	}
	PMsiControl piCtl(0);
	PMsiRecord piReturn(0);
	m_iControlCurrent = m_piDatabase->EncodeString(*m_strFirstControl);
	m_iDefaultButton = m_piDatabase->EncodeString(*m_strDefaultButton);
	m_iCancelButton = m_piDatabase->EncodeString(*m_strCancelButton);

	if (m_iControlCurrent)
	{
		piReturn = GetControl(m_iControlCurrent, *&piCtl);
		if (piReturn)
		{
			return PostError(Imsg(idbgFirstControlDef), *m_strKey, *MsiString(m_piDatabase->DecodeString(m_iControlCurrent)));
		}
	}
	else	  // make sure that some control is designated as first
	{
		m_iControlCurrent = piControlsCursor->GetInteger(itabCSKey);
	}
	piControlsCursor->Reset();
	piCtl = 0;

	// create previous pointers
	PMsiCursor piCursor2(0);
	Ensure(ControlsCursorCreate(*&piCursor2));
	piCursor2->SetFilter(iColumnBit(itabCSKey));
	piControlsCursor->Reset();
	MsiStringId iNext;
	MsiStringId iPresent;
	int iNextCount = 0;
	while (piControlsCursor->Next())
	{
		iPresent = piControlsCursor->GetInteger(itabCSKey);
		iNext = piControlsCursor->GetInteger(itabCSNext);
		if (iNext == 0 || iNext == iMsiNullInteger)
			continue;
		iNextCount++;
		piCursor2->Reset();
		AssertNonZero(piCursor2->PutInteger(itabCSKey, iNext));
		if (piCursor2->Next())
		{
			if (piCursor2->GetInteger(itabCSNext) == 0)
			{
				return PostError(Imsg(idbgControlLoopOpen), *m_strKey, *MsiString(m_piDatabase->DecodeString(iPresent)), *MsiString(m_piDatabase->DecodeString(iNext)));   // just a warning, life goes on
			}
			if (piCursor2->GetInteger(itabCSPrev) != 0)
			{
				return PostError(Imsg(idbgControlLoopTail), *m_strKey, *MsiString(m_piDatabase->DecodeString(iPresent)), *MsiString(m_piDatabase->DecodeString(iNext)), *MsiString(m_piDatabase->DecodeString(piCursor2->GetInteger(itabCSPrev))));     // just a warning, life goes on
			}
			AssertNonZero(piCursor2->PutInteger(itabCSPrev, iPresent));
			AssertNonZero(piCursor2->Update());
		}
		else
		{
			return PostError(Imsg(idbgNoNext), *m_strKey, *MsiString(m_piDatabase->DecodeString(iPresent)), *MsiString(m_piDatabase->DecodeString(iNext)));
		}
	}
	// reorder the controls in Z-order, to get the desired tab-order

	PMsiRecord piRecord = &m_piServices->CreateRecord(1);
	WindowRef pWindow;
	WindowRef pPrevWindow = 0;
	iNext = m_iControlCurrent;
	for (;;)
	{
		piCursor2->Reset();
		AssertNonZero(piCursor2->PutInteger(itabCSKey, iNext));
		AssertNonZero(piCursor2->Next());
		pWindow = (WindowRef)GetHandleData(piCursor2, itabCSWindow);
		Assert(pWindow);
		if (iNext == m_iControlCurrent)
		{
			AssertNonZero(WIN::SetWindowPos(pWindow, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE));
		}
		else
		{
			AssertNonZero(WIN::SetWindowPos(pWindow, pPrevWindow, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE));
		}
		pPrevWindow = pWindow;
		iNext = piCursor2->GetInteger(itabCSNext);
		if (iNext == 0 || iNext == iMsiNullInteger)
			break;
		if (iNext == m_iControlCurrent)
		{
			iNextCount--;                   // we count the first one only if we get back to it in a loop
			break;                          // we have closed the loop
		}
		iNextCount--;
	}
	if (iNextCount != 0)
		return PostError(Imsg(idbgNotSingleLoop), *m_strKey);
	//if there is a default button defined, make sure that it exists
	if (m_iDefaultButton)  // default button defined
	{
		piReturn = GetControl(m_iDefaultButton, *&piCtl);
		if (piReturn)
		{
			return PostError(Imsg(idbgDefaultButtonDef), *m_strKey);
		}
		else
		{
			PMsiRecord piRecordDef = &m_piServices->CreateRecord(1);
			AssertNonZero(piRecordDef->SetInteger(1, fTrue));
			Ensure(piCtl->AttributeEx(fTrue, cabDefault, *piRecordDef));
		}
	}
	if (m_iCancelButton)  // cancel button defined
	{
		piReturn = GetControl(m_iCancelButton, *&piCtl);
		if (piReturn)
		{
			return PostError(Imsg(idbgCancelButtonDef), *m_strKey);
		}
	}
	m_fHasControls = fTrue;
	m_fAddingControls = fFalse;
	m_fDialogIsRunning = fTrue;
	MsiString strNull;
	m_pWndCostingTimer = 0;
	m_pWndDiskSpaceTimer = 0;

	if (!m_fPreview && m_dialogModality != icmdModeless)
	{
		AssertNonZero(WIN::SetTimer(m_pWnd, kiCostingPeriod, kiCostingPeriod, 0));
		m_pWndCostingTimer = m_pWnd;
		if (m_fTrackDiskSpace)
		{
			AssertNonZero(WIN::SetTimer(m_pWnd, kiDiskSpacePeriod, kiDiskSpacePeriod, 0));
			m_pWndDiskSpaceTimer = m_pWnd;
		}
	}

	iPresent = m_iControlCurrent;
	piControlsCursor->Reset();
	while (piControlsCursor->Next())
	{
		piCtl = (IMsiControl *) piControlsCursor->GetMsiData(itabCSPointer);
		Ensure(piCtl->RefreshProperty());
	}
	Ensure(PropertyChanged(*strNull, *strNull));
	if ( iPresent != m_iControlCurrent )
	{
		PMsiRecord piError = SetFocus(iPresent);  // sets m_iControlCurrent as well
		if ( piError )
			m_piEngine->Message(imtInfo, *piError);  // let's give authors a bit of enlightenment
	}

	return 0;
}

IMsiRecord* CMsiDialog::Escape()
{
	if (!m_iKey)
	{
		return PostError(Imsg(idbgUninitDialog));
	}
	if (m_fAddingControls)
	{
		return PostError(Imsg(idbgAddingControls), *m_strKey);
	}
	if (m_iCancelButton && m_fCancelAvailable)
	{
		WIN::SendMessage(m_pWnd, WM_COMMAND, m_iCancelButton,
							  (LPARAM)WIN::GetDlgItem(m_pWnd, m_iCancelButton));
	}
	return 0;
}



IMsiRecord* CMsiDialog::RemoveControl(IMsiControl* piControl)
{
	// do we need to unregister a tooltip? probably not

	if (!m_iKey)
	{
		return PostError(Imsg(idbgUninitDialog));
	}
	if (m_fAddingControls)
	{
		return PostError(Imsg(idbgAddingControls), *m_strKey);
	}
	Assert(piControl);
	PMsiCursor piControlsCursor(0);
	Ensure(ControlsCursorCreate(*&piControlsCursor));
	int iThis = piControl->GetIntegerValue();
	Assert(iThis);
	piControlsCursor->SetFilter(iColumnBit(itabCSKey));
	AssertNonZero(piControlsCursor->PutInteger(itabCSKey, iThis));
	if (!piControlsCursor->Next())
	{
		return PostError(Imsg(idbgRemoveNonexControl), *m_strKey, *MsiString(piControl->GetMsiStringValue()));
	}
	int iPrev = piControlsCursor->GetInteger(itabCSPrev);
	int iNext = piControlsCursor->GetInteger(itabCSNext);
	AssertNonZero(piControlsCursor->Delete());
	if (iNext && iNext != iThis)
	{
		piControlsCursor->Reset();
		AssertNonZero(piControlsCursor->PutInteger(itabCSKey, iPrev));
		AssertNonZero(piControlsCursor->Next());
		AssertNonZero(piControlsCursor->PutInteger(itabCSNext, iNext));
		AssertNonZero(piControlsCursor->Update());
		piControlsCursor->Reset();
		AssertNonZero(piControlsCursor->PutInteger(itabCSKey, iNext));
		AssertNonZero(piControlsCursor->Next());
		AssertNonZero(piControlsCursor->PutInteger(itabCSPrev, iPrev));
		AssertNonZero(piControlsCursor->Update());
	}
	if (m_iDefaultButton == iThis) // we just removed the default button
	{
		m_iDefaultButton = 0;
	}
	if (m_iControlCurrent == iThis)	// we just removed the current control
	{
		if (iThis != iNext)
		{
			m_iControlCurrent = iNext;
		}
		else 
		{
			if (m_piControlsTable->GetRowCount())	 // there are some controls left
			{
				piControlsCursor->SetFilter(0);
				piControlsCursor->Reset();
				AssertNonZero(piControlsCursor->Next());
				m_iControlCurrent = piControlsCursor->GetInteger(itabCSKey);
			}
			else  // no controls left on the dialog
			{
				m_fHasControls = fFalse;
				m_fAddingControls = fTrue;
			}
		}
		//  TO DO? to move the focus to m_iControlCurrent, if != 0.
	}
	return 0;
}


IMsiRecord* CMsiDialog::DestroyControls()
{
	if (!m_iKey)
	{
		return PostError(Imsg(idbgUninitDialog));
	}
	m_fHasControls = fFalse;
	PMsiCursor piControlsCursor(0);
	Ensure(ControlsCursorCreate(*&piControlsCursor));
	PMsiControl piControl(0);
	while (piControlsCursor->Next())
	{
		piControl = (IMsiControl *)piControlsCursor->GetMsiData(itabCSPointer);
		Assert(piControl);
		AssertNonZero(piControlsCursor->PutMsiData(itabCSPointer, 0));
		AssertNonZero(piControlsCursor->Update());
	}
	return 0;
}


IMsiRecord* CMsiDialog::RemoveWindow()
{
	if (!m_iKey)
	{
		return PostError(Imsg(idbgUninitDialog));
	}
	IMsiRecord* piReturn = 0;
	if (m_pWnd)
	{
		if (m_pWndCostingTimer)
		{
			AssertNonZero(WIN::KillTimer(m_pWnd, kiCostingPeriod));
		}
		if (m_pWndDiskSpaceTimer)
		{
			AssertNonZero(WIN::KillTimer(m_pWnd, kiDiskSpacePeriod));
		}

		if (m_piHandler->DestroyHandle((HANDLE)m_pWnd) == -1)
			piReturn = PostError(Imsg(idbgFailedToDestroyWindow), *m_strKey);
		m_pWnd = 0;
	}
	return piReturn;
}

IMsiRecord* CMsiDialog::Execute()
{
	if (!m_iKey)
	{
		return PostError(Imsg(idbgUninitDialog));
	}
	if (m_fAddingControls)
	{
		return PostError(Imsg(idbgAddingControls), *m_strKey);
	}
	if (icmdModeless == m_dialogModality)
	{
		return PostError(Imsg(idbgModelessExecute), *m_strKey);
	}
	BOOL fPrevState = FALSE;
	if ( m_pwndParent )
	{
		fPrevState = WIN::IsWindowEnabled(m_pwndParent);
		WIN::EnableWindow(m_pwndParent, FALSE);
	}
	if (!m_fDialogIsShowing)
	{
		Ensure(WindowShow(fTrue));
	}
	MSG msg;
	// Wait here until done...
	while (m_fDialogIsRunning && !m_piErrorRecord && WIN::GetMessage(&msg, 0, 0, 0))
	{
		// If we are in an error dialog, we don't want to do any background costing
		if (m_fErrorDialog && msg.message == WM_TIMER)
			continue;
		if (::IsSpecialMessage(&msg) || !WIN::IsDialogMessage(m_pWnd, &msg))
		{
			WIN::TranslateMessage(&msg);
			WIN::DispatchMessage(&msg);
		}

		if (s_szWaitCondition[0])
		{
			if (m_piEngine->EvaluateCondition(s_szWaitCondition) == iecTrue)
			{
				m_fDialogIsRunning = fFalse;
			}
		}
	}
	if ( m_pwndParent )
		WIN::EnableWindow(m_pwndParent, fPrevState);
	return m_piErrorRecord;
}

IMsiRecord* CMsiDialog::Reset()
// Call all the controls on the dialog and tell them to cancel (undo).
// if any of the undos fail, this function fails
// call first the ones with an indirect property, then the other active controls
{
	if (!m_iKey)
	{
		return PostError(Imsg(idbgUninitDialog));
	}
	if (m_fAddingControls)
	{
		return PostError(Imsg(idbgAddingControls), *m_strKey);
	}

	PMsiCursor piControlsCursor(0);
	Ensure(ControlsCursorCreate(*&piControlsCursor));
	while (piControlsCursor->Next())
	{
		if (piControlsCursor->GetInteger(itabCSIndirectProperty) != iTableNullString)
		{
			Ensure(PMsiControl((IMsiControl *)piControlsCursor->GetMsiData(itabCSPointer))->Undo());
		}
	}
	piControlsCursor->Reset();
	while (piControlsCursor->Next())
	{
		if ((piControlsCursor->GetInteger(itabCSIndirectProperty) == iTableNullString) &&
			(piControlsCursor->GetInteger(itabCSProperty) != iTableNullString))
		{
			Ensure(PMsiControl((IMsiControl *)piControlsCursor->GetMsiData(itabCSPointer))->Undo());
		}
	}
	MsiString strNull;
	Ensure(PropertyChanged(*strNull, *strNull));
	return 0;
}

IMsiRecord* CMsiDialog::WindowShow(Bool fShow)
{
	if (!m_iKey)
	{
		return PostError(Imsg(idbgUninitDialog));
	}
	if (m_fAddingControls)
	{
		return PostError(Imsg(idbgAddingControls), *m_strKey);
	}
	m_fDialogIsShowing = fShow;
	if (fShow)
	{
		m_fDialogIsRunning = fTrue;
		m_iEvent = idreNone;
		MsiString strNull;
		m_strArg = strNull;
		//  The next section ensures that the focus is set onto a control
		//  that can take focus.
		PMsiRecord piRecord = &m_piServices->CreateRecord(1);
		PMsiControl piControl(0);
		WindowRef hSearchFrom = 0;
		if ( GetCurrentControl() )
		{
			Ensure(GetControl(GetCurrentControl(), *&piControl));
			Assert(piControl);
			Ensure(piControl->AttributeEx(fFalse, cabWindowHandle, *piRecord));
			hSearchFrom = (WindowRef)piRecord->GetHandle(1);
		}
		bool fFound = true;
#ifdef DEBUG
		int iCount = 0;
#endif
		while ( !piControl || !piControl->CanTakeFocus() )
		{
#ifdef DEBUG
			//  this loop shouldn't be run several times.  If it does, some
			//  CanTakeFocus() implementation(s) is/are wrong.
			Assert(++iCount <= 1);
#endif
			WindowRef hNew = WIN::GetNextDlgTabItem(m_pWnd, hSearchFrom, fFalse);
			if ( !hNew || hNew == hSearchFrom )
			{
				fFound = false;
				break;
			}
			IMsiRecord* piReturn = GetControlFromWindow(hNew, *&piControl);
			if ( !piControl || piReturn )
			{
				//  hNew may be a child of a control on the dialog. I check hNew's parent (if
				//  any and if different from the dialog itself).
				hNew = WIN::GetParent(hNew);
				while ( hNew && hNew != m_pWnd )
				{
					PMsiRecord(GetControlFromWindow(hNew, *&piControl));
					if ( piControl )
					{
						piReturn->Release(), piReturn = 0;
						break;
					}
					else
						hNew = WIN::GetParent(hNew);
				}
				if ( piReturn )
					return piReturn;
			}
			hSearchFrom = hNew;
		}
		//  the focus is set onto the "current control" in CMsiDialog::WindowProc
		SetCurrentControl(fFound ? piControl->GetIntegerValue() : 0);
		WIN::ShowWindow(m_pWnd, SW_SHOW);
		//  line below fixes NT5 bug that hides "UserExit" dialog behind command prompt.
		WIN::SetForegroundWindow(m_pWnd);
	}
	else
		WIN::ShowWindow(m_pWnd, SW_HIDE);
	return 0;
}


IMsiDialogHandler& CMsiDialog::GetHandler()
{
	Assert(m_piHandler);
	m_piHandler->AddRef();
	return *m_piHandler;
}

IMsiEngine& CMsiDialog::GetEngine()
{
	Assert(m_piEngine);
	m_piEngine->AddRef();
	return *m_piEngine;
}


IMsiRecord* CMsiDialog::Attribute(Bool fSet, const IMsiString& riAttributeString, IMsiRecord& riRecord)
{
	if (!m_iKey)
	{
		return PostError(Imsg(idbgUninitDialog));
	} 
	DialogDispatchEntry* pEntry = s_DialogDispatchTable;
	int count;
	for (count = s_DialogDispatchCount; count--; count)
	{
		if (riAttributeString.Compare(iscExact, pEntry->pcaAttribute))
		{
			if (fSet)
			{
				return (this->*(pEntry->pmfSet))(riRecord);
			}
			else
			{
				return (this->*(pEntry->pmfGet))(riRecord);
			}
		}
		pEntry++;
	}
	// we could not find the attribute
	return PostError(Imsg(idbgUnsupportedDialogAttrib), *m_strKey, *MsiString(riAttributeString));
}

IMsiRecord* CMsiDialog::AttributeEx(Bool fSet, dabEnum dab, IMsiRecord& riRecord)
{
	Assert(dabMax == s_DialogDispatchCount);
	if (!m_iKey)
	{
		return PostError(Imsg(idbgUninitDialog));
	} 
	if (dab < dabMax)
	{
		if (fSet)
		{
			return (this->*(s_DialogDispatchTable[dab].pmfSet))(riRecord);
		}
		else
		{
			return (this->*(s_DialogDispatchTable[dab].pmfGet))(riRecord);
		}
	}
	// attribute out of range
	return PostError(Imsg(idbgUnsupportedDialogAttrib), *m_strKey, *MsiString((int)dab));
}

INT_PTR CALLBACK CMsiDialog::WindowProc(WindowRef pWnd, WORD message, WPARAM wParam, LPARAM lParam)
{
	static Bool fTimerError = fFalse;
	static unsigned int uQueryCancelAutoPlay = 0;

#ifdef _WIN64	// !merced
	CMsiDialog* pDialog = (CMsiDialog*)WIN::GetWindowLongPtr(pWnd, GWLP_USERDATA);
#else			// win-32. This should be removed with the 64-bit windows.h is #included.
	CMsiDialog* pDialog = (CMsiDialog*)WIN::GetWindowLong(pWnd, GWL_USERDATA);
#endif

	PMsiControl piControl(0);
	MsiStringId iControl;
	MsiString strNull;

	if (!uQueryCancelAutoPlay)
		uQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));

	switch (message)
	{
		case WM_PALETTECHANGED:
			if ((WindowRef) wParam != pWnd)
				pDialog->HandlePaletteChanged();
			break;
		case WM_QUERYNEWPALETTE:
			return pDialog->HandleQueryNewPalette();
		case WM_TIMER:
			{
				if (fTimerError)
					return 0;
				IMsiRecord* piReturnRec = 0;
				if (wParam == kiCostingPeriod)
				{
					unsigned int uiStart = GetTickCount();
					bool fCostingEnabled = pDialog->m_piSelectionManager->IsBackgroundCostingEnabled();
					while (fCostingEnabled && (GetTickCount() - uiStart < kiCostingSlice) && piReturnRec == 0)
					{
						piReturnRec = pDialog->m_piSelectionManager->CostOneComponent(*strNull);
						if (piReturnRec)
						{
							if (piReturnRec->GetInteger(1) == idbgSelMgrNotInitialized)
							{
								piReturnRec->Release();
								piReturnRec = 0;
								if (pDialog->m_pWndCostingTimer)
								{
									AssertNonZero(WIN::KillTimer(pDialog->m_pWnd, kiCostingPeriod));
									pDialog->m_pWndCostingTimer = 0;
								}
								break;
							}
						}
						else
						{
							fCostingEnabled = pDialog->m_piSelectionManager->IsBackgroundCostingEnabled();
							if (!fCostingEnabled)
							{
								PMsiRecord(pDialog->PropertyChanged(*strNull, *strNull));
							}
						}
					}
				}

				else if (wParam == kiDiskSpacePeriod &&
							pDialog->m_fDialogIsShowing &&
							pDialog->m_fDialogIsRunning)
				{
					Bool fOld = ToBool(pDialog->GetDBPropertyInt(*MsiString(*IPROPNAME_OUTOFDISKSPACE)));
					Bool fOldNoRb = ToBool(pDialog->GetDBPropertyInt(*MsiString(*IPROPNAME_OUTOFNORBDISKSPACE)));
					Bool fOutOfNoRbDiskSpace;
					Bool fOutOfDiskSpace = pDialog->m_piSelectionManager->DetermineOutOfDiskSpace(&fOutOfNoRbDiskSpace, NULL);
					if (fOld != fOutOfDiskSpace)
						piReturnRec = pDialog->PropertyChanged(*strNull, *MsiString(*IPROPNAME_OUTOFDISKSPACE));

					if (fOldNoRb != fOutOfNoRbDiskSpace)
						piReturnRec = pDialog->PropertyChanged(*strNull, *MsiString(*IPROPNAME_OUTOFNORBDISKSPACE));

					PMsiCursor pControlsCursor(0);
					pDialog->ControlsCursorCreate(*&pControlsCursor);
					if (pControlsCursor)
					{
						PMsiControl pCtl(0);
						while (pControlsCursor->Next())
						{

							pCtl = (IMsiControl *) pControlsCursor->GetMsiData(itabCSPointer);
							pCtl->Refresh();
						}
					}
				}
				
				if (piReturnRec)
				{
					// we have an error message
					piReturnRec->AddRef(); // we want to keep it around
					pDialog->m_piErrorRecord = piReturnRec;
					fTimerError = fTrue; // Error prevents further costing
				}
			}
			return 0;
		case WM_SYSCOLORCHANGE:
			{
#ifdef _WIN64	// !merced
				WIN::SetClassLongPtr(pDialog->m_pWnd, GCLP_HBRBACKGROUND, (LONG_PTR) WIN::CreateSolidBrush(WIN::GetSysColor(COLOR_BTNFACE)));
#else			// win-32. This should be removed with the 64-bit windows.h is #included.
				WIN::SetClassLong(pDialog->m_pWnd, GCL_HBRBACKGROUND, (LONG) WIN::CreateSolidBrush(WIN::GetSysColor(COLOR_BTNFACE)));
#endif
			}
			break;
		case WM_USERBREAK:
			{
				pDialog->m_fDialogIsRunning = fFalse;
				pDialog->m_iEvent = idreBreak;
			}
			return 0;
		case WM_SETFOCUS:
			if (pDialog->m_fHasControls)
			{
				PMsiRecord(pDialog->GetControl(pDialog->GetCurrentControl(), *&piControl));
				if (piControl)
				{
					PMsiRecord piRecord = piControl->SetFocus();
				}
			} 
			return(0);
		case WM_NCDESTROY:
			if ( !g_fFatalExit && pDialog->m_iRefCnt == 0 )
				delete pDialog;
			return(0);
		case WM_COMMAND:
			if (pDialog->m_fHasControls)
			{
				iControl = WIN::GetDlgCtrlID((HWND)lParam);
				if (iControl)
				{
					PMsiRecord(pDialog->GetControl(iControl, *&piControl));
					if (!piControl)
						break;

					//  retrieving the window handle (WM_COMMAND can be sent from
					//  code so that lParam should not be used here - it might be 0)
					PMsiRecord piRec = &pDialog->m_piServices->CreateRecord(1);
					AssertRecord(piControl->AttributeEx(fFalse, cabWindowHandle, *piRec));
					HWND hCtl = (HWND)piRec->GetHandle(1);
					Assert(hCtl);

					//  checking to see if it is a button
					bool fPushButton = false;
					if ( IStrStr(piControl->GetControlType(), g_szPushButtonType) )
						fPushButton = true;

					if ( pDialog->ProcessingCommand() )
					{
						//  I reject further WM_COMMAND messages sent by controls
						//  on the same dialog.
						if ( fPushButton && pDialog->ProcessingCommand() != hCtl )
						{
							//  I set the focus back to the one being processed.
							WIN::SetFocus(pDialog->ProcessingCommand());
							//  I make the processed button look again "pushed"
							WIN::SendMessage(pDialog->ProcessingCommand(),
												  BM_SETSTATE, TRUE, 0);
						}
						return 0;
					}
					if ( fPushButton )
					{
						//  cause current control's eventual KillFocus validation
						//  to happen before going any further.
						PMsiRecord(pDialog->SetFocus(piControl->GetIntegerValue()));
						if (pDialog->m_iLocked)
							//  validation failed.
							return 0;

						//  make the button look "pushed"
						WIN::SendMessage(hCtl, BM_SETSTATE, TRUE, 0);
					}

					pDialog->m_piHandler->ShowWaitCursor();
					pDialog->ProcessingCommand(hCtl);
					PMsiRecord piReturn = piControl->WindowMessage(message, wParam, lParam);
					if ( !piReturn || piReturn->GetInteger(1) == idbgWinMes )
					{
						piRec = pDialog->ControlActivated(*MsiString(pDialog->m_piDatabase->DecodeString(iControl)));
						if ( piRec )
						{
							Assert(false);  // it should be difficult to get here
							piReturn = piRec;
						}
					}
					pDialog->ProcessingCommand(0);
					pDialog->m_piHandler->RemoveWaitCursor();

					if ( fPushButton )
						//  make the button look "released"
						WIN::SendMessage(hCtl, BM_SETSTATE, FALSE, 0);

					if ( !piReturn )
						break;  // the control did nothing and no error occured
					if (piReturn->GetInteger(1) == idbgWinMes)
						return piReturn->GetInteger(4);  // the control wants us to return this number
					else
					{
						// we have an error message
						piReturn->AddRef(); // we want to keep it around
						pDialog->m_piErrorRecord = piReturn;
						return 0;
					}
				}
			} 
			break;
		case WM_MEASUREITEM:
		case WM_COMPAREITEM:
		case WM_DRAWITEM:
		case WM_NOTIFY:
			if (pDialog->m_fHasControls)
			{
				if ( message == WM_NOTIFY )
				{
					//  Tooltip windows send notification messages as well.
					//  These windows do not have the same IDs as the controls.
#ifdef DEBUG
					UINT uCode = ((LPNMHDR)lParam)->code;
					HWND hCtrl = ((LPNMHDR)lParam)->hwndFrom;
					PMsiRecord(pDialog->GetControlFromWindow(hCtrl, *&piControl));
#else
					PMsiRecord(pDialog->GetControlFromWindow(((LPNMHDR)lParam)->hwndFrom,
																		  *&piControl));
#endif
				}
				else
				{
					iControl = (UINT)wParam;
					if ( iControl && iControl != iTableNullString )
						PMsiRecord(pDialog->GetControl(iControl, *&piControl));
					else
						Assert(false);
				}
				if (!piControl)
					break;
				PMsiRecord piReturn = piControl->WindowMessage(message, wParam, lParam);
				if (!piReturn)
				{
					break;  // the control did nothing
				}
				if (piReturn->GetInteger(1) == idbgWinMes)
				{
					return piReturn->GetInteger(4);  // the control wants us to return this number
				}
				// we have an error message
				piReturn->AddRef(); // we want to keep it around
				pDialog->m_piErrorRecord = piReturn;
				return 0;
			} 
			break;
		case WM_CTLCOLORSTATIC:
			if (pDialog->m_fHasControls)
			{
				WindowRef pwndCtl = (WindowRef) lParam;
#ifdef _WIN64	// !merced
				PMsiControl piControl = (IMsiControl*)WIN::GetWindowLongPtr(pwndCtl, GWLP_USERDATA);
#else			// win-32. This should be removed with the 64-bit windows.h is #included.
				PMsiControl piControl = (IMsiControl*)WIN::GetWindowLong(pwndCtl, GWL_USERDATA);
#endif
				if (piControl)
				{
					piControl->AddRef();
					PMsiRecord piRecord = &pDialog->m_piServices->CreateRecord(1);
					AssertRecord(piControl->AttributeEx(fFalse, cabTransparent, *piRecord));
					if (piRecord->GetInteger(1))
					{
						AssertNonZero(WIN::SetBkMode((HDC) wParam, TRANSPARENT));
						return (INT_PTR) pDialog->m_hbrTransparent;
					}
				}
			}
			break;
		case WM_SETDEFAULTPUSHBUTTON:
			if (pDialog->m_fHasControls)
			{
				//  I establish the current default pushbutton (if any).
				MsiStringId iOldDefault = 0;
				if ( pDialog->m_iCurrentButton )
					iOldDefault = pDialog->m_iCurrentButton;
				else
					iOldDefault = pDialog->m_iDefaultButton;

				//  I establish the new default pushbutton (if any).
				MsiStringId iNewDefault = pDialog->m_iCurrentButton = (unsigned int) wParam;			//!!merced: 4244. 4311 ptr to int.
				if ( !iNewDefault )
					iNewDefault = pDialog->m_iDefaultButton;
				if ( iNewDefault != iOldDefault )
				{
					//  the default pushbutton has changed
					PMsiRecord piRec = &pDialog->m_piServices->CreateRecord(1);

					//  I reset the default state of the current default pushbutton.
					if ( iOldDefault )
					{
						PMsiRecord(pDialog->GetControl(iOldDefault, *&piControl));
						if ( piControl )
						{
							AssertNonZero(piRec->SetInteger(1, fFalse));
							PMsiRecord(piControl->AttributeEx(fTrue, cabDefault, *piRec));
						}
						else
							Assert(false);
					}

					//  I set the default state of the new default pushbutton.
					if ( iNewDefault )
					{
						PMsiRecord(pDialog->GetControl(iNewDefault, *&piControl));
						if ( piControl )
						{
							AssertNonZero(piRec->SetInteger(1, fTrue));
							PMsiRecord(piControl->AttributeEx(fTrue, cabDefault, *piRec));
						}
						else
							Assert(false);
					}
				}
				return 0;
			}
			break;
		case DM_GETDEFID:
			{
				if ( pDialog->m_iCurrentButton )
					return MAKELONG(pDialog->m_iCurrentButton, DC_HASDEFID);
				else
					return MAKELONG(pDialog->m_iDefaultButton, DC_HASDEFID);
			}
			break;
		case WM_VSCROLL:
			{
				int iVScrollInc = 0;
				int iVScrollMax = pDialog->m_iFullHeight - pDialog->m_iClientHeight;
				switch (LOWORD(wParam))
				{
				case SB_TOP:
					iVScrollInc = - pDialog->m_iVScrollPos;
					break;
				case SB_BOTTOM:
					iVScrollInc = iVScrollMax - pDialog->m_iVScrollPos;
					break;
				case SB_LINEUP:
					iVScrollInc = - pDialog->m_idyChar;
					break;
				case SB_LINEDOWN:
					iVScrollInc = pDialog->m_idyChar;
					break;
				case SB_PAGEUP:
					iVScrollInc = - pDialog->m_iClientHeight/2;
					break;
				case SB_PAGEDOWN:
					iVScrollInc = pDialog->m_iClientHeight/2;
					break;
				case SB_THUMBTRACK:
					iVScrollInc = HIWORD(wParam) - pDialog->m_iVScrollPos;
					break;
				default:
					iVScrollInc = 0;
					break;
				}
				iVScrollInc = max(-pDialog->m_iVScrollPos, min(iVScrollInc, iVScrollMax - pDialog->m_iVScrollPos));
				if (iVScrollInc != 0)
				{
					pDialog->m_iVScrollPos += iVScrollInc;
					AssertNonZero(WIN::ScrollWindowEx(pDialog->m_pWnd, 0, - iVScrollInc, 0, 0, 0, 0, SW_SCROLLCHILDREN | SW_ERASE | SW_INVALIDATE));
					WIN::SetScrollPos(pDialog->m_pWnd, SB_VERT, pDialog->m_iVScrollPos, fTrue);
					AssertNonZero(WIN::UpdateWindow(pDialog->m_pWnd));
				}
				return 0;
			}
			break;
		case WM_HSCROLL:
			{
				int iHScrollInc = 0;
				int iHScrollMax = pDialog->m_iFullWidth - pDialog->m_iClientWidth;
				switch (LOWORD(wParam))
				{
				case SB_TOP:
					iHScrollInc = - pDialog->m_iHScrollPos;
					break;
				case SB_BOTTOM:
					iHScrollInc = iHScrollMax - pDialog->m_iHScrollPos;
					break;
				case SB_LINEUP:
					iHScrollInc = - pDialog->m_idyChar;
					break;
				case SB_LINEDOWN:
					iHScrollInc = pDialog->m_idyChar;
					break;
				case SB_PAGEUP:
					iHScrollInc = - pDialog->m_iClientWidth/2;
					break;
				case SB_PAGEDOWN:
					iHScrollInc = pDialog->m_iClientWidth/2;
					break;
				case SB_THUMBTRACK:
					iHScrollInc = HIWORD(wParam) - pDialog->m_iHScrollPos;
					break;
				default:
					iHScrollInc = 0;
					break;
				}
				iHScrollInc = max(-pDialog->m_iHScrollPos, min(iHScrollInc, iHScrollMax - pDialog->m_iHScrollPos));
				if (iHScrollInc != 0)
				{
					pDialog->m_iHScrollPos += iHScrollInc;
					AssertNonZero(WIN::ScrollWindowEx(pDialog->m_pWnd, - iHScrollInc, 0, 0, 0, 0, 0, SW_SCROLLCHILDREN | SW_ERASE | SW_INVALIDATE));
					WIN::SetScrollPos(pDialog->m_pWnd, SB_HORZ, pDialog->m_iHScrollPos, fTrue);
					AssertNonZero(WIN::UpdateWindow(pDialog->m_pWnd));
				}
				return 0;
			}
			break;
		case WM_KEYDOWN:
			{
				Bool fShift = ToBool(WIN::GetKeyState(VK_SHIFT) < 0 || WIN::GetKeyState(VK_CONTROL) < 0);
				switch (wParam)
				{
				case VK_HOME:
					WIN::SendMessage(pDialog->m_pWnd, fShift ? WM_HSCROLL : WM_VSCROLL, SB_TOP, 0);
					return 0;
				case VK_END:
					WIN::SendMessage(pDialog->m_pWnd, fShift ? WM_HSCROLL : WM_VSCROLL, SB_BOTTOM, 0);
					return 0;
				case VK_PRIOR:
					WIN::SendMessage(pDialog->m_pWnd, fShift ? WM_HSCROLL : WM_VSCROLL, SB_PAGEUP, 0);
					return 0;
				case VK_NEXT:
					WIN::SendMessage(pDialog->m_pWnd, fShift ? WM_HSCROLL : WM_VSCROLL, SB_PAGEDOWN, 0);
					return 0;
					/*
				case VK_UP:
					WIN::SendMessage(pDialog->m_pWnd, WM_VSCROLL, SB_LINEUP, 0);
					break;
				case VK_DOWN:
					WIN::SendMessage(pDialog->m_pWnd, WM_VSCROLL, SB_LINEDOWN, 0);
					break;
				case VK_LEFT:
					WIN::SendMessage(pDialog->m_pWnd, WM_HSCROLL, SB_PAGEUP, 0);
					break;
				case VK_RIGHT:
					WIN::SendMessage(pDialog->m_pWnd, WM_HSCROLL, SB_PAGEDOWN, 0);
					break;*/
				}
			}

		case WM_SYSCOMMAND:
			{
				if (SC_CLOSE == wParam)
				{
					PMsiRecord piReturn = pDialog->Escape();
					if (piReturn)
					{
						// we have an error message
						piReturn->AddRef(); // we want to keep it around
						pDialog->m_piErrorRecord = piReturn;
					}
					return 0;
				}
				break;
			}
		case WM_SETCURSOR:
			{
				// Returns false if the arrow cursor
				if (!pDialog->m_piHandler->FSetCurrentCursor())
					return DefWindowProc(pWnd, message, wParam, lParam);		
				return TRUE;
			}
			break;
		default:
			{
				if (message && (message == uQueryCancelAutoPlay))
				{
					// cancel AutoPlay
					return TRUE;
				}

			}
			break;
	}        


	return DefWindowProc(pWnd, message, wParam, lParam);
}

Bool CMsiDialog::HandlePaletteChanged()
{
	if (!m_hPalette)
		return fFalse;

	HDC hdc = WIN::GetDC (m_pWnd);
	if (!hdc)
		return fFalse;

	HPALETTE hOldPal = WIN::SelectPalette (hdc, m_hPalette, FALSE);
	WIN::RealizePalette(hdc);
	UpdateColors(hdc);

	if (hOldPal)
		WIN::SelectPalette(hdc,hOldPal,TRUE);

	WIN::ReleaseDC(m_pWnd,hdc);
	return fTrue;
}


Bool CMsiDialog::HandleQueryNewPalette()
{
	if (!m_hPalette)
		return fFalse;

	HDC hdc = WIN::GetDC (m_pWnd);
	if (!hdc)
		return fFalse;

	HPALETTE hOldPal = WIN::SelectPalette (hdc, m_hPalette, FALSE);
	int iMappedCnt = WIN::RealizePalette(hdc);
	if (iMappedCnt)
	{
		WIN::InvalidateRect(m_pWnd,NULL,TRUE);
		UpdateWindow(m_pWnd);
	}

	if (hOldPal)
		WIN::SelectPalette(hdc,hOldPal,TRUE);

	WIN::ReleaseDC(m_pWnd,hdc);
	return fTrue;
}


IMsiRecord* CMsiDialog::SetDefaultButton(int iButton) 
{
	if (m_iDefaultButton == iButton)
	{
		return 0;
	}
	PMsiRecord piRecord = &m_piServices->CreateRecord(1);
	PMsiControl piControl(0);
	if (m_iDefaultButton)
	{
		AssertNonZero(piRecord->SetInteger(1, fFalse));
		Ensure(GetControl(m_iDefaultButton, *&piControl));
		Ensure(piControl->AttributeEx(fTrue, cabDefault, *piRecord));
	}
	if (iButton)
	{
		AssertNonZero(piRecord->SetInteger(1, fTrue));
		Ensure(GetControl(iButton, *&piControl));
		Ensure(piControl->AttributeEx(fTrue, cabDefault, *piRecord));
	}
	m_iDefaultButton = iButton;
	return 0;
}

IMsiRecord* CMsiDialog::NoWay(IMsiRecord& /*riRecord*/)
{
	return PostError(Imsg(idbgUnsupportedDialogAttrib), *m_strKey, *MsiString(*TEXT("")));
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiDialog::GetRefCount(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeRefCount));
	riRecord.SetInteger(1, m_iRefCnt);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiDialog::GetRTLRO(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeRTLRO));
	riRecord.SetInteger(1, m_fRTLRO);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiDialog::GetRightAligned(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeRightAligned));
	riRecord.SetInteger(1, m_fRightAligned);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiDialog::GetLeftScroll(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeLeftScroll));
	riRecord.SetInteger(1, m_fLeftScroll);
	return 0;
}
#endif // ATTRIBUTES


IMsiRecord* CMsiDialog::GetKeyInt(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeKeyInt));
	riRecord.SetInteger(1, m_iKey);
	return 0;
}

IMsiRecord* CMsiDialog::GetKeyString(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeKeyString));
	riRecord.SetMsiString(1, *m_strKey);
	return 0;
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiDialog::GetX(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeX));
	riRecord.SetInteger(1, m_iX);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiDialog::GetY(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeY));
	riRecord.SetInteger(1, m_iY);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiDialog::GetWidth(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeWidth));
	riRecord.SetInteger(1, m_iWidth);
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiDialog::GetHeight(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeHeight));
	riRecord.SetInteger(1, m_iHeight);
	return 0;
}
#endif // ATTRIBUTES


IMsiRecord* CMsiDialog::GetText(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeText));
	riRecord.SetMsiString(1, *m_strText);
	return 0;
}

IMsiRecord* CMsiDialog::SetText(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeText));
	m_strRawText = riRecord.IsNull(0) ? riRecord.GetMsiString(1) : riRecord.FormatText(fFalse);
	m_strText = m_piEngine->FormatText(*m_strRawText);
	SetWindowTitle (*m_strText);
	return 0;
}

void CMsiDialog::SetWindowTitle (const IMsiString& riText)
{
	WIN::SetWindowText (m_pWnd, riText.GetString());
}


IMsiRecord* CMsiDialog::GetCurrentControl(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeCurrentControl));
	riRecord.SetMsiString(1, *MsiString(m_piDatabase->DecodeString(m_iControlCurrent)));
	return 0;
}

IMsiRecord* CMsiDialog::SetCurrentControl(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeCurrentControl));
	MsiStringId iControlCurrent = m_piDatabase->EncodeString(*MsiString(riRecord.GetMsiString(1)));
	if (iControlCurrent != m_iControlCurrent)
	{
		m_iControlCurrent = iControlCurrent;
		PMsiRecord piRecord = SetFocus(m_iControlCurrent);
	}
	return 0;
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiDialog::GetDefaultButton(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeDefaultButton));
	if (m_iDefaultButton)
	{
		riRecord.SetMsiString(1, *MsiString(m_piDatabase->DecodeString(m_iDefaultButton)));
	}
	else 
	{
		riRecord.SetMsiString(1, *MsiString(*TEXT("")));
	}
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiDialog::SetDefaultButton(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeDefaultButton));
	PMsiControl piControl(0);
	PMsiRecord piRecord = GetControl(*MsiString(riRecord.GetMsiString(1)), *&piControl);
	if (!piControl)
	{
		return PostError(Imsg(idbgDefaultDoesNotExist), *m_strKey, *MsiString(riRecord.GetMsiString(1)));
	}
	return SetDefaultButton(m_piDatabase->EncodeString(*MsiString(riRecord.GetMsiString(1))));
}
#endif // ATTRIBUTES

IMsiRecord* CMsiDialog::GetPosition(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 4, pcaDialogAttributePosition));
	RECT rect;
	AssertNonZero(WIN::GetWindowRect(m_pWnd, &rect));

	riRecord.SetInteger(1, rect.left);
	riRecord.SetInteger(2, rect.top);
	riRecord.SetInteger(3, rect.right - rect.left);
	riRecord.SetInteger(4, rect.bottom - rect.top);
	return 0;
}

IMsiRecord* CMsiDialog::GetFullSize(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 2, pcaDialogAttributeFullSize));
	riRecord.SetInteger(1, m_iFullWidth);
	riRecord.SetInteger(2, m_iFullHeight);
	return 0;
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiDialog::GetClientRect(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 4, pcaDialogAttributeClientRect));
	RECT rect;
	AssertNonZero(WIN::GetClientRect(m_pWnd, &rect));
	riRecord.SetInteger(1, rect.left);
	riRecord.SetInteger(2, rect.top);
	riRecord.SetInteger(3, rect.right);
	riRecord.SetInteger(4, rect.bottom);
	return (0);
}
#endif // ATTRIBUTES


IMsiRecord* CMsiDialog::SetPosition(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 4, pcaDialogAttributePosition));
	if (m_pWnd)
	{
		AssertNonZero(WIN::MoveWindow(m_pWnd, riRecord.GetInteger(1), riRecord.GetInteger(2), riRecord.GetInteger(3), riRecord.GetInteger(4), fTrue));
	}
	return 0;
}

IMsiRecord* CMsiDialog::GetKeepModeless(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeKeepModeless));
	riRecord.SetInteger(1, m_fKeepModeless);
	return 0;
}

IMsiRecord* CMsiDialog::GetPreview(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributePreview));
	riRecord.SetInteger(1, m_fPreview);
	return 0;
}

IMsiRecord* CMsiDialog::GetShowing(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeShowing));
	riRecord.SetInteger(1, m_fDialogIsShowing);
	return 0;
}

IMsiRecord* CMsiDialog::SetShowing(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeShowing));
	return WindowShow(ToBool(riRecord.GetInteger(1)));
}

IMsiRecord* CMsiDialog::GetRunning(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeRunning));
	riRecord.SetInteger(1, m_fDialogIsRunning);
	return 0;
}

IMsiRecord* CMsiDialog::SetRunning(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeRunning));
	m_fDialogIsRunning = ToBool(riRecord.GetInteger(1));
	return 0;
}


IMsiRecord* CMsiDialog::GetModal(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeModal));
	riRecord.SetInteger(1, ToBool(icmdModeless != m_dialogModality));
	return 0;
}

IMsiRecord* CMsiDialog::GetError(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeError));
	riRecord.SetInteger(1, m_fErrorDialog);
	return 0;
}

IMsiRecord* CMsiDialog::SetModal(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeModal));
	m_dialogModality = (icmdEnum)riRecord.GetInteger(1);
	return 0;
}

IMsiRecord* CMsiDialog::GetLocked(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeLocked));
	riRecord.SetInteger(1, m_iLocked);
	return 0;
}

IMsiRecord* CMsiDialog::SetLocked(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeLocked));
	m_iLocked = riRecord.GetInteger(1);
	return 0;
}

IMsiRecord* CMsiDialog::GetInPlace(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeInPlace));
	riRecord.SetInteger(1, m_fInPlace);
	return 0;
}

IMsiRecord* CMsiDialog::SetInPlace(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeInPlace));
	m_fInPlace = ToBool(riRecord.GetInteger(1));
	return 0;
}

IMsiRecord* CMsiDialog::PostError(IErrorCode iErr)
{
	IMsiRecord* piRec = &m_piServices->CreateRecord(1);
	ISetErrorCode(piRec, iErr);
	return piRec;
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiDialog::GetHasControls(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeHasControls));
	riRecord.SetInteger(1, m_fHasControls);
	return 0;
}
#endif // ATTRIBUTES

IMsiRecord* CMsiDialog::GetAddingControls(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeAddingControls));
	riRecord.SetInteger(1, m_fAddingControls);
	return 0;
}

IMsiRecord* CMsiDialog::SetAddingControls(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeAddingControls));
	m_fAddingControls = ToBool(riRecord.GetInteger(1));
	return 0;
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiDialog::GetControlsCount(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeControlsCount));
	riRecord.SetInteger(1, m_piControlsTable->GetRowCount());
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiDialog::GetControlsKeyInt(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, m_piControlsTable->GetRowCount(), pcaDialogAttributeControlsKeyInt));
	PMsiCursor piControlsCursor(0);
	Ensure(ControlsCursorCreate(*&piControlsCursor));
	int count = 0;
	while (piControlsCursor->Next())
	{   
		riRecord.SetInteger(++count, piControlsCursor->GetInteger(itabCSKey));
	}
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiDialog::GetControlsKeyString(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, m_piControlsTable->GetRowCount(), pcaDialogAttributeControlsKeyString));
	PMsiCursor piControlsCursor(0);
	Ensure(ControlsCursorCreate(*&piControlsCursor));
	int count = 0;
	while (piControlsCursor->Next())
	{   
		riRecord.SetMsiString(++count, *MsiString(piControlsCursor->GetString(itabCSKey)));
	}
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiDialog::GetControlsProperty(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, m_piControlsTable->GetRowCount(), pcaDialogAttributeControlsProperty));
	PMsiCursor piControlsCursor(0);
	Ensure(ControlsCursorCreate(*&piControlsCursor));
	int count = 0;
	while (piControlsCursor->Next())
	{   
		riRecord.SetMsiString(++count, *MsiString(piControlsCursor->GetString(itabCSProperty)));
	}
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiDialog::GetControlsNext(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, m_piControlsTable->GetRowCount(), pcaDialogAttributeControlsNext));
	PMsiCursor piControlsCursor(0);
	Ensure(ControlsCursorCreate(*&piControlsCursor));
	int count = 0;
	while (piControlsCursor->Next())
	{   
		riRecord.SetMsiString(++count, *MsiString(piControlsCursor->GetString(itabCSNext)));
	}
	return 0;
}
#endif // ATTRIBUTES

#ifdef ATTRIBUTES
IMsiRecord* CMsiDialog::GetControlsPrev(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, m_piControlsTable->GetRowCount(), pcaDialogAttributeControlsPrev));
	PMsiCursor piControlsCursor(0);
	Ensure(ControlsCursorCreate(*&piControlsCursor));
	int count = 0;
	while (piControlsCursor->Next())
	{   
		riRecord.SetMsiString(++count, *MsiString(piControlsCursor->GetString(itabCSPrev)));
	}
	return 0;
}
#endif // ATTRIBUTES

IMsiRecord* CMsiDialog::GetEventInt(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeEventInt));
	riRecord.SetInteger(1, m_iEvent);
	return 0;
}

IMsiRecord* CMsiDialog::SetEventInt(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeEventInt));
	m_iEvent = (idreEnum)riRecord.GetInteger(1);
	return 0;
}

#ifdef ATTRIBUTES
IMsiRecord* CMsiDialog::GetEventString(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeEventString));
	MsiString strEvent;
	switch (m_iEvent)
	{
	case idreNew:
		strEvent = TEXT("New");
		break;
	case idreSpawn:
		strEvent = TEXT("Spawn");
		break;
	case idreExit:
		strEvent = TEXT("Exit");
		break;
	case idreReturn:
		strEvent = TEXT("Return");
		break;
	case idreError:
		strEvent = TEXT("Error");
		break;
	case idreRetry:
		strEvent = TEXT("Retry");
		break;
	case idreIgnore:
		strEvent = TEXT("Ignore");
		break;
	case idreErrorOk:
		strEvent = TEXT("ErrorOk");
		break;
	case idreErrorCancel:
		strEvent = TEXT("ErrorCancel");
		break;
	case idreErrorAbort:
		strEvent = TEXT("ErrorAbort");
		break;
	case idreErrorRetry:
		strEvent = TEXT("ErrorRetry");
		break;
	case idreErrorIgnore:
		strEvent = TEXT("ErrorIgnore");
		break;
	case idreErrorYes:
		strEvent = TEXT("ErrorYes");
		break;
	case idreErrorNo:
		strEvent = TEXT("ErrorNo");
		break;
	case idreBreak:
		strEvent = TEXT("Break");
		break;
	default:
		Assert(fFalse);
		break;
	}
	riRecord.SetMsiString(1, *strEvent);
	return 0;
}
#endif // ATTRIBUTES


IMsiRecord* CMsiDialog::GetArgument(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeArgument));
	riRecord.SetMsiString(1, *m_strArg);
	return 0;
}


IMsiRecord* CMsiDialog::CreateTable(const ICHAR* szTable, IMsiTable*& riTable)
{
	if( PMsiRecord(m_piDatabase->CreateTable(*MsiString(m_piDatabase->CreateTempTableName()),
														  0, *&riTable)) )
	{
		return PostError(Imsg(idbgTableCreate), *MsiString(szTable));
	}
	return 0;
}

IMsiRecord* CMsiDialog::PostError(IErrorCode iErr, const IMsiString& riString)
{
	IMsiRecord* piRec = &m_piServices->CreateRecord(2);
	ISetErrorCode(piRec, iErr);
	AssertNonZero(piRec->SetMsiString(2, riString));
	return piRec;
}

IMsiRecord* CMsiDialog::PostError(IErrorCode iErr, const IMsiString& riString2, const IMsiString& riString3)
{
	IMsiRecord* piRec = &m_piServices->CreateRecord(3);
	ISetErrorCode(piRec, iErr);
	AssertNonZero(piRec->SetMsiString(2, riString2));
	AssertNonZero(piRec->SetMsiString(3, riString3));
	return piRec;
}


IMsiRecord* CMsiDialog::PostError(IErrorCode iErr, const IMsiString& riString2, const IMsiString& riString3, const IMsiString& riString4)
{
	IMsiRecord* piRec = &m_piServices->CreateRecord(4);
	ISetErrorCode(piRec, iErr);
	AssertNonZero(piRec->SetMsiString(2, riString2));
	AssertNonZero(piRec->SetMsiString(3, riString3));
	AssertNonZero(piRec->SetMsiString(4, riString4));
	return piRec;
}

IMsiRecord* CMsiDialog::PostError(IErrorCode iErr, const IMsiString& riString2, const IMsiString& riString3, const IMsiString& riString4, const IMsiString& riString5)
{
	IMsiRecord* piRec = &m_piServices->CreateRecord(5);
	ISetErrorCode(piRec, iErr);
	AssertNonZero(piRec->SetMsiString(2, riString2));
	AssertNonZero(piRec->SetMsiString(3, riString3));
	AssertNonZero(piRec->SetMsiString(4, riString4));
	AssertNonZero(piRec->SetMsiString(5, riString5));
	return piRec;
}

IMsiRecord* CMsiDialog::PostError(IErrorCode iErr, const IMsiString& riString2, const IMsiString& riString3, const IMsiString& riString4, const IMsiString& riString5, const IMsiString& riString6)
{
	IMsiRecord* piRec = &m_piServices->CreateRecord(6);
	ISetErrorCode(piRec, iErr);
	AssertNonZero(piRec->SetMsiString(2, riString2));
	AssertNonZero(piRec->SetMsiString(3, riString3));
	AssertNonZero(piRec->SetMsiString(4, riString4));
	AssertNonZero(piRec->SetMsiString(5, riString5));
	AssertNonZero(piRec->SetMsiString(6, riString6));
	return piRec;
}

IMsiRecord* CMsiDialog::GetCancelButton(IMsiRecord& riRecord)
{
	Ensure(CheckFieldCount (riRecord, 1, pcaDialogAttributeCancelButton));

	if ( m_iCancelButton )
	{
		PMsiControl piControl(0);
		Ensure(GetControl(m_iCancelButton, *&piControl));
		AssertNonZero(riRecord.SetMsiData(1, (const IMsiData*)piControl));
		return 0;
	}
	else
		return PostError(Imsg(idbgCancelButtonDef), *m_strKey);
}

bool CMsiDialog::SetCancelAvailable(bool fAvailable)
{ 
	bool fOld = m_fCancelAvailable; 
	m_fCancelAvailable = fAvailable; 

	return fOld;
}

////////////////////////////////////////////////////////////////////////////////////////

IMsiDialog* CreateMsiDialog(const IMsiString& riTypeString, IMsiDialogHandler& riHandler, IMsiEngine& riEngine, WindowRef pwndParent)
{
	if (riTypeString.Compare(iscExact, pcaDialogTypeStandard))
	{
		return new CMsiDialog(riHandler, riEngine, pwndParent);
	}

	return (0);
}

void ChangeWindowStyle (WindowRef pWnd, DWORD dwRemove, DWORD dwAdd, Bool fExtendedStyles) 
{
	int nOffset = fExtendedStyles ? GWL_EXSTYLE : GWL_STYLE;
	WIN::SetWindowLong(pWnd, nOffset, (WIN::GetWindowLong(pWnd, nOffset) & ~dwRemove) | dwAdd);
	if ( WIN::IsWindowVisible(pWnd) )
		AssertNonZero(WIN::RedrawWindow(pWnd, NULL, NULL,
												  RDW_FRAME | RDW_INVALIDATE));
}

Bool IsSpecialMessage(LPMSG lpMsg)
{
	return ToBool(lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_ESCAPE);
}

IMsiRecord* IsColumnPresent(IMsiDatabase& riDatabase, const IMsiString& riTableNameString, const IMsiString& riColumnNameString, Bool* pfPresent)
{
	*pfPresent = fFalse;
	PMsiTable piTable(0);
	Ensure(riDatabase.LoadTable(riTableNameString, 0, *&piTable));
	*pfPresent = ToBool(piTable->GetColumnIndex(riDatabase.EncodeString(riColumnNameString)));
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\handler.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       handler.cpp
//
//--------------------------------------------------------------------------

/*  handler.cpp - CMsiHandler implementation
____________________________________________________________________________*/

#include "common.h"

// definitions required for module.h, for entry points and regstration
#ifdef DEBUG
# define CLSID_COUNT  2
#else
# define CLSID_COUNT  1
#endif
#define PROFILE_OUTPUT      "msihndd.mea";
#define MAC_MODULE_NAME     MSI_HANDLER_NAME
#define MODULE_CLSIDS       rgCLSID         // array of CLSIDs for module objects
#define MODULE_PROGIDS      rgszProgId      // ProgId array for this module
#define MODULE_DESCRIPTIONS rgszDescription // Regstry description of objects
#define MODULE_FACTORIES    rgFactory       // factory functions for each CLSID
#define DllRegisterServer   DllRegisterServerTest
#define DllUnregisterServer DllUnregisterServerTest
#include "module.h"   // self-reg and assert functions
#undef  DllRegisterServer
#undef  DllUnregisterServer

#define ASSERT_HANDLING  // instantiate assert services once per module
#include "engine.h"  
#include <commctrl.h> 
#include "_handler.h"
#include "imsimem.h"
#include "_control.h"

// percentage by which we allow Windows standard message font to be
// larger/smaller than our standard font
#define NEGLIGIBLE_FONT_SIZE_DEVIATION    20
// default ratio on US machines that have their display properties 
// set to Small fonts (Settings tab, Advanced... button, Font Size
// combo) and appearance to "Windows Standard" (Appearance tab, Scheme
// combo).
#define US_DISPLAY_STANDARD_RATIO         ((float)13 / 16)

typedef CComPointer<const IMsiString> PMsiString;

const GUID IID_IUnknown      = GUID_IID_IUnknown;
const GUID IID_IClassFactory = GUID_IID_IClassFactory;
const GUID IID_IMsiView      = GUID_IID_IMsiView;
const GUID IID_IMsiControl   = GUID_IID_IMsiControl;
const GUID IID_IMsiDialog    = GUID_IID_IMsiDialog;
const GUID IID_IMsiEvent     = GUID_IID_IMsiEvent;
const GUID IID_IMsiData      = GUID_IID_IMsiData;
const GUID IID_IMsiDialogHandler = GUID_IID_IMsiDialogHandler; 

Bool          g_fChicago;  // true if we have a Chicago like UI (95 or NT4 or higher)
Bool          g_fNT4; // true if we have NT4 or higher
ICHAR         MsiDialogCloseClassName[] = TEXT("MsiDialogCloseClass");  // used for the WNDCLASS (the Dialog's)
ICHAR         MsiDialogNoCloseClassName[] = TEXT("MsiDialogNoCloseClass");  // used for the WNDCLASS (the Dialog's)
bool          g_fFatalExit = false;  // true if CMsiHandler::Terminate() called with true argument
bool          g_fWin9X;         // true if Windows 95, 98 or ME, else false
int           g_iMajorVersion;  // OS' major version #
int           g_iMinorVersion;  // OS' minor version #


#if defined(USE_OBJECT_POOL) && !defined(_WIN64)
bool    g_fUseObjectPool = false;
#endif

static IMsiCursor*      g_piUITextCursor = 0;
IMsiRecord*             g_piWndMsgRec = 0;
IMsiRecord*             g_piAttribRec = 0;

HIMAGELIST g_hVolumeSmallIconList;

// handler can't see these in istring.cpp
#if defined (DEBUG) && (!UNICODE)
ICHAR* ICharNext(const ICHAR* pch)
{
	return WIN::CharNext(pch);
}
ICHAR* INextChar(const ICHAR* pch)
{
	return WIN::CharNext(pch); 
}
#endif

//____________________________________________________________________________
//
// COM objects produced by this module's class factories
//____________________________________________________________________________

const GUID rgCLSID[CLSID_COUNT] =
{  GUID_IID_IMsiHandler
#ifdef DEBUG
 , GUID_IID_IMsiHandlerDebug
#endif
};

const ICHAR* rgszProgId[CLSID_COUNT] =
{  SZ_PROGID_IMsiHandler
#ifdef DEBUG
 , SZ_PROGID_IMsiHandlerDebug
#endif
};

const ICHAR* rgszDescription[CLSID_COUNT] =
{  SZ_DESC_IMsiHandler
#ifdef DEBUG
 , SZ_DESC_IMsiHandlerDebug
#endif
};

IUnknown* CreateHandler();

ModuleFactory rgFactory[CLSID_COUNT] = 
{ CreateHandler
#ifdef DEBUG
 , CreateHandler
#endif
};



void CWINHND::Destroy()
{
	AssertSz(m_hHandle,
				TEXT("CWINHWND::Destroy() called on object that has null m_hHandle."));
	switch (m_iType)
	{
		case iwhtWindow:
		{
			if ( WIN::IsWindow((HWND)m_hHandle) )
				AssertNonZero(WIN::DestroyWindow((HWND)m_hHandle));
			break;
		}
		case iwhtGDIObject:
			AssertNonZero(WIN::DeleteObject((HGDIOBJ)m_hHandle));
			break;
		case iwhtIcon:
			AssertNonZero(WIN::DestroyIcon((HICON)m_hHandle));
			break;
		case iwhtImageList:
			AssertNonZero(WIN::ImageList_Destroy((HIMAGELIST)m_hHandle));
			break;
		default:
			AssertSz(fFalse,
						TEXT("CWINHWND::Destroy() called on object that has unknown m_iType."));
	}
#ifdef DEBUG
	DWORD dwError = WIN::GetLastError();
#endif
	m_hHandle = 0;
	m_iType = iwhtNone; 
}



const int C = 25;

class CWINHNDArray
{
protected:
	CWINHND*   m_pBuffer;
	int        m_iSize;
	int        m_cElem;
	void       Allocate(int iSize) { m_iSize = iSize; m_cElem = 0;
							m_pBuffer = (CWINHND*)GlobalAlloc(GPTR, iSize*sizeof(CWINHND)); }
	void       Clear() { GlobalFree(m_pBuffer); m_pBuffer = NULL; m_iSize = m_cElem = 0; }
	BOOL       Resize(int iSize);
	int        IndexOf(const CWINHND& rArg) const;
	int        IndexOf(const HANDLE hArg) const;
	void       KillElement(CWINHND* pArg) { pArg->Destroy(); m_cElem--; }


public:
	CWINHNDArray() { Allocate(C); }
	CWINHNDArray(int iSize) { Allocate(iSize); }
	~CWINHNDArray() { Clear(); }
	int          AddElement(const CWINHND& rArg);
	inline int   DestroyElement(const CWINHND* pArg);
	inline int   DestroyElement(const HANDLE hArg);
	void         DestroyAllElements(iwhtEnum iType=iwhtNone);
	CWINHND*     GetFirstElement(iwhtEnum iType=iwhtNone) const;
	int          GetSize() const { return m_cElem; }
};

BOOL CWINHNDArray::Resize(int iSize)
{
	if ( iSize <= m_iSize )
	{
		//  it doesn't really make sense to shrink it
		Assert(fFalse);
		return FALSE;
	}

	CWINHND* pNew = (CWINHND*)GlobalAlloc(GPTR, iSize*sizeof(CWINHND));
	if ( ! pNew )
		return FALSE;
	for ( int i=0; i < m_iSize; i++ )
		pNew[i] = m_pBuffer[i];
	GlobalFree(m_pBuffer);
	m_pBuffer = pNew;
	m_iSize = iSize;
	return TRUE;
}

int CWINHNDArray::IndexOf(const CWINHND& rArg) const
{
	//  returns index of rArg in the array, -1 if not in the array.

	if ( !m_cElem )
		return -1;

	for ( int i=0; i < m_iSize && m_pBuffer[i] != rArg; i++ )
		;
	return i < m_iSize ? i : -1;
}

int CWINHNDArray::IndexOf(const HANDLE hArg) const
{
	//  returns index of the element that has dwArg handle in the array or -1 if
	//  not in the array.

	if ( !m_cElem )
		return -1;

	for ( int i=0; i < m_iSize && m_pBuffer[i].GetHandle() != hArg; i++ )
		;
	return i < m_iSize ? i : -1;
}

int CWINHNDArray::AddElement(const CWINHND& rArg)
{
	//  returns -1 if rArg is already in the array,
	//  index of the new element otherwise.

	//  I check if the element is already in the array.
	if ( IndexOf(rArg) != -1 )
		//  yes it is
		return -1;

	if ( m_cElem + 1 > m_iSize )
		if ( ! Resize((int)2*m_iSize) )
			return -1;

	//  I look for the first null element in the array - this is where I insert dwElem.
	for ( int i=0; i < m_iSize && !m_pBuffer[i].IsEmpty(); i++)
		;
	Assert(i < m_iSize);

	//  I insert dwElem into the array
	m_pBuffer[i] = rArg;
	m_cElem++;

	return i;
}

int CWINHNDArray::DestroyElement(const HANDLE hArg)
{
	//  returns index of rArg element, -1 if not in the array

	int iIndex = IndexOf(hArg);
	if ( iIndex != -1 )
		//  it is in the array - I destroy it
		KillElement(m_pBuffer + iIndex);

	return iIndex;
}

int CWINHNDArray::DestroyElement(const CWINHND* pArg)
{
	//  returns index of rArg element, -1 if not in the array

	int iIndex = IndexOf(*pArg);
	if ( iIndex != -1 )
		//  it is in the array - I destroy it
		KillElement(m_pBuffer + iIndex);

	return iIndex;
}

void CWINHNDArray::DestroyAllElements(iwhtEnum iType)
{
	//  destroys all elements of iType in the array.  If iType is iwhtNone,
	//  destroys all non-null elements in the array.

	if ( !m_cElem )
		return;

	if ( iType == iwhtNone )
	{
		for ( int i = 0; i < m_iSize; i++ )
			if ( !m_pBuffer[i].IsEmpty() )
				KillElement(&m_pBuffer[i]);
	}
	else
	{
		for ( int i = 0; i < m_iSize; i++ )
			if ( !m_pBuffer[i].IsEmpty() && m_pBuffer[i].GetType() == iType )
				KillElement(&m_pBuffer[i]);
	}
}

CWINHND* CWINHNDArray::GetFirstElement(iwhtEnum iType) const
{
	//  returns the first (non-null) element of iType in the array.  If iType
	//  is iwhtNone, returns the first non-null element in the array.  If no
	//  such element is found, returns NULL.

	if ( !m_cElem )
		return NULL;

	CWINHND* pReturn = NULL;
	int i = 0;
	if ( iType == iwhtNone )
	{
		for ( ; i < m_iSize && m_pBuffer[i].IsEmpty(); i++ )
			;
	}
	else
	{
		for ( ; i < m_iSize; i++ )
			if ( !m_pBuffer[i].IsEmpty() && m_pBuffer[i].GetType() == iType )
				break;
	}
	if ( i < m_iSize )
		pReturn = m_pBuffer + i;

	return pReturn;
}




/////////////////////////////////////////////////////////////////////////////////////
// CMsiHandler definition
/////////////////////////////////////////////////////////////////////////////////////

class CMsiHandler : public IMsiHandler, public IMsiDialogHandler
#ifdef DEBUG
						, public IMsiDebug
#endif //DEBUG
{
protected:
   ~CMsiHandler();  // protected to prevent creation on stack
public:
	CMsiHandler();
	HRESULT         __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long   __stdcall AddRef();
	unsigned long   __stdcall Release();
	Bool            __stdcall Initialize(IMsiEngine& riEngine, iuiEnum iuiLevel, HWND hwndParent, bool& fMissingTables);
	imsEnum         __stdcall Message(imtEnum imt, IMsiRecord& riRecord);
	iesEnum         __stdcall DoAction(const ICHAR* szAction);
	idreEnum        __stdcall DoModalDialog(MsiStringId iName, MsiStringId iParent);
	Bool            __stdcall Break();
	void            __stdcall Terminate(bool fFatalExit=false);
	IMsiDialog*     __stdcall GetDialog(const IMsiString& riDialogString);
	IMsiDialog*     __stdcall GetDialogFromWindow(LONG_PTR window);
	IMsiDialog*     __stdcall DialogCreate(const IMsiString& riTypeString);
	Bool            __stdcall AddDialog(IMsiDialog& riDialog, IMsiDialog* piParent, IMsiRecord& riRecord,
										IMsiTable* piControlEventTable,IMsiTable* piControlConditionTable, 
										IMsiTable* piEventMappingTable);
	Bool            __stdcall RemoveDialog(IMsiDialog* piDialog);
	IMsiRecord*     __stdcall GetTextStyle(const IMsiString *piArgumentString);
	int             __stdcall RecordHandle(const CWINHND& rArg) { return m_rgHANDLEs.AddElement(rArg); }
	int             __stdcall DestroyHandle(const HANDLE hArg) { return m_rgHANDLEs.DestroyElement(hArg); }
	void            __stdcall DestroyAllHandles(iwhtEnum iType=iwhtNone) { m_rgHANDLEs.DestroyAllElements(iType); }
	int             __stdcall GetHandleCount() { return m_rgHANDLEs.GetSize(); }
	int             __stdcall ShowWaitCursor();
	int             __stdcall RemoveWaitCursor();
	bool            __stdcall FSetCurrentCursor();
	HWND            __stdcall GetTopWindow();
	UINT            __stdcall GetUserCodePage() { return m_uUserCodePage; }
	int             __stdcall GetTextHeight() { return m_idyChar; }
	float           __stdcall GetUIScaling() { return m_rUIScalingFactor; }

#ifdef DEBUG
public: // IMsiDebug
	void           __stdcall SetAssertFlag(Bool fShowAsserts);
	void           __stdcall SetDBCSSimulation(char chLeadByte);
	Bool           __stdcall WriteLog(const ICHAR* szText);
	void           __stdcall AssertNoObjects(void);
	void               __stdcall SetRefTracking(long iid, Bool fTrack);

#endif //DEBUG

	static void *operator new(size_t cb) {return AllocSpc(cb);}
	static void operator delete(void * pv) {FreeSpc(pv);}
private:

	inline int           GetDBPropertyInt (const IMsiString& riPropertyString)
				  {return m_piEngine-> GetPropertyInt(riPropertyString);}
	inline const IMsiString&   GetDBProperty(const IMsiString& riPropertyString)
				      {return m_piEngine-> GetProperty(riPropertyString);}
	inline Bool          SetDBProperty(const IMsiString& riPropertyString, const IMsiString& riDataString)
				  {return m_piEngine-> SetProperty(riPropertyString, riDataString);}
	inline Bool          SetDBPropertyInt(const IMsiString& riPropertyString, int iData)
				  {return m_piEngine-> SetPropertyInt(riPropertyString, iData);}
	imsEnum              PostError(IMsiRecord& riRecord);
	imsEnum              PostError(IErrorCode iErr, const IMsiString& riString2 = *(const IMsiString*)0, const IMsiString& riString3 = *(const IMsiString*)0, const IMsiString& riString4 = *(const IMsiString*)0, const IMsiString& riString5 = *(const IMsiString*)0, const IMsiString& riString6 = *(const IMsiString*)0);
	iesEnum              CreateNewDialog(MsiStringId iName, MsiStringId iParent, IMsiDialog*& rpiDialog, Bool fMustFind, const IMsiString& riErrorTextString, const IMsiString& riListString, int iDefault, Bool fFirst, Bool fPreview);
	iesEnum              RunWizard(MsiStringId iDialog);
	Bool                 AddDialogToDialogTable (IMsiDialog *piDialog, MsiStringId iParent);
	IMsiDialog*          GetDialog(MsiStringId iDialog);
	MsiStringId          GetParentDialog(MsiStringId iDialog);
	imsEnum              ActionStart(imtEnum imt, IMsiRecord& riRec);
	MsiStringId          GetTopDialog(IMsiDialog** ppiDialog = 0);
	Bool            RemoveDialog(MsiStringId iDialog);
	Bool            RemoveOtherDialogs(MsiStringId iDialog);
	Bool            RemoveModelessDialog();
	Bool            PublishEvent(MsiStringId idEventString, IMsiRecord& riArgument);
	Bool            PublishEventSz(const ICHAR* szEventString, IMsiRecord& riArgument);
	Bool            EventAction(MsiStringId idEventString, const IMsiString& riActionString);
	Bool            EventActionSz(const ICHAR * szEventString, const IMsiString& riActionString);
	Bool            CreateControls(IMsiDialog* piDialog, const IMsiString& riListString);
	Bool            RearrangeControls(IMsiDialog* piDialog, const IMsiString& riListString);
	void            AdjustDialogPosition(IMsiDialog& riDialog);
	void            ClearMessageQueue();
	Bool            CreateTextStyleTab();
	Bool            DestroyDialogs();
	WindowRef       FindModeless();
	bool            FindModeless(IMsiDialog*&);
	void            SetInPlace(IMsiDialog& riDialog, Bool fInPlace);
	imsEnum         SetProgressGauge(int iProgress, int iProgressTotal);
	bool            SetUIScaling();
	int             m_iRefCnt;
	PMsiEngine      m_piEngine;
	PMsiServices    m_piServices; 
	PMsiDatabase    m_piDatabase; 
	PMsiTable       m_piDialogsTable; // table of existing dialogs
	PMsiCursor      m_piDialogsCursor;
	PMsiCursor      m_piGTDCachedCursor;  // cached for GetTopDialog method's use only
	PMsiCursor      m_piGTDCachedCursor2; // cached for GetTopDialog method's use only
	PMsiTable       m_piControlEventTable;
	PMsiTable       m_piControlConditionTable;
	PMsiTable       m_piEventMappingTable;
	PMsiTable       m_piUITextTable;
	PMsiTable       m_piTextStyleTable;
	PMsiView        m_piDialogView; // Cursor to authored dialogs
	PMsiView        m_piTextStyleView;
	
	// this is weird but we cannot use MsiString since the MsiString::InitializeClass(m_piServices->GetNullString()) 
	// is only called in CMsiHandler::Initialize() (after constructor)
	PMsiString      m_pstrCurrentAction; 

	PMsiRecord      m_pDialogPositionRec;
	PMsiRecord      m_pProgressRec;
	// If you move this member, please update the constructor code
	// Items between here and the end get zeroed at constructor time
	int             m_idyChar;
	int             m_iScreenWidth;
	int             m_iScreenHeight;
	int             m_iBorderWidth;
	int             m_iBorderHeight;
	int             m_iCaptionHeight;
	Bool            m_fCreatingError;
	Bool            m_fProgressByData;
	int             m_iProgress;
	int             m_iProgressTotal;
	int             m_iPerTick;
	unsigned int    m_uiStartTime;
	unsigned int    m_uiLastReportTime;
	Bool            m_fShowWizards;
	WindowRef       m_pwndParent;
	WNDCLASS        m_UIDialogWndClass;
	void CMsiHandler::CreateVolumeImageLists();
	ProgressData::ipdEnum m_ipdDirection;
	ProgressData::ietEnum m_ietEventType;
	WindowRef       m_pwindModelessCache;
	MsiStringId     m_idActionText;
	MsiStringId     m_idActionData;
	MsiStringId     m_idSetProgress;
	int             m_iOldProgressTotal;
	int             m_iOldProgress;
	HCURSOR         m_hCursOld;
	HCURSOR         m_hCursCur;
	int             m_cWait;
	UINT            m_uUserCodePage;
	// If you move this member, please update the constructor code. We expect it to be at the end
	Bool            m_fPreview;

	//  is set in the constructor
	float           m_rUIScalingFactor;

	//  this one must not be set to null in the constructor!!!
	CWINHNDArray    m_rgHANDLEs;
};


/////////////////////////////////////////////////////////////////////////////
// CMsiHandler implementation
/////////////////////////////////////////////////////////////////////////////

HRESULT __stdcall DllRegisterServer()
{
	return GetTestFlag('R') ? DllRegisterServerTest() : S_OK;
}

HRESULT __stdcall DllUnregisterServer()
{
	return GetTestFlag('R') ? DllUnregisterServerTest() : S_OK;
}

IUnknown* CreateHandler()
{
	return (IMsiHandler*)new CMsiHandler();
}

CMsiHandler::CMsiHandler() : m_piEventMappingTable(0), m_piControlConditionTable(0), m_piControlEventTable(0), m_piDialogsTable(0), m_piTextStyleTable(0),
	m_piEngine(0), m_piServices(0), m_piDatabase(0), m_piUITextTable(0), m_pstrCurrentAction(0), m_pDialogPositionRec(0),
	m_piDialogsCursor(0), m_piTextStyleView(0), m_piDialogView(0), m_pProgressRec(0), m_piGTDCachedCursor(0), m_piGTDCachedCursor2(0)
{
	// Set everything to zero except refcnt
	INT_PTR cbSize = ((char *)&(this->m_fPreview)) - ((char *)&(this->m_idyChar));                  //--merced: changed int to INT_PTR
	Assert(cbSize > 0);
	memset(&(this->m_idyChar), 0, (unsigned int)cbSize);            //--merced: added typecast
	
	m_iRefCnt = 1;
	g_cInstances++;
	m_rUIScalingFactor = 1.;
	Assert(m_idyChar == 0);
	Assert(m_iScreenWidth == 0);
	Assert(m_iScreenHeight == 0);
	Assert(m_iBorderWidth == 0);
	Assert(m_iBorderHeight == 0);
	Assert(m_iCaptionHeight == 0);
	Assert(m_fCreatingError == fFalse);
	Assert(m_fProgressByData == fFalse);
	Assert(m_iProgressTotal == 0);
	Assert(m_iProgress == 0);
	Assert(m_pwndParent == 0);
	Assert(m_fPreview == fFalse);
	Assert(m_uiStartTime == 0);
	Assert(m_uiLastReportTime == 0);
	Assert(m_idActionText == 0);
	Assert(m_idActionData == 0);
	Assert(m_idSetProgress == 0);
	Assert(m_iOldProgressTotal == 0);
	Assert(m_iOldProgress == 0);
	Assert(m_cWait == 0);
	Assert(m_hCursOld == 0);
	Assert(m_hCursCur == 0);
	Assert(m_uUserCodePage == 0);

#if !defined(_WIN64) && defined(DEBUG)
	g_fUseObjectPool = GetTestFlag('O');
#endif
}

CMsiHandler::~CMsiHandler()
{
	if (m_piEngine)
		Terminate();
	g_cInstances--;
	m_pstrCurrentAction = 0;

}

HRESULT CMsiHandler::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IMsiDialogHandler))
		*ppvObj = (IMsiDialogHandler* )this;
	else if (MsGuidEqual(riid, IID_IUnknown) 
#ifdef DEBUG
	 || MsGuidEqual(riid, rgCLSID[1])
#endif
	 || MsGuidEqual(riid, rgCLSID[0]))
		*ppvObj = (IMsiHandler* )this;
#ifdef DEBUG
	else if (MsGuidEqual(riid, IID_IMsiDebug))
		*ppvObj = (IMsiDebug*)this;
#endif // DEBUG
	else
		return (*ppvObj = 0, E_NOINTERFACE);
	AddRef();
	return NOERROR;
}

CMsiStringNullCopy MsiString::s_NullString;  // initialized by InitializeClass below

Bool CMsiHandler::Initialize(IMsiEngine& riEngine, iuiEnum iuiLevel, HWND hwndParent, bool& fMissingTables)
{
	fMissingTables = false;

	if (m_piEngine)
	{
		PostError(Imsg(idbgHandlerSecondInit));
		return fFalse;
	}
	Assert(!m_piEngine);
	WIN::InitCommonControls();
	m_pwndParent = hwndParent;
	m_piEngine = &riEngine;
	m_piEngine->AddRef();   // we're keeping a private pointer
	AssertNonZero(m_piServices = m_piEngine->GetServices());  // engine did AddRef()
	SetAllocator(m_piServices);
	MsiString::InitializeClass(m_piServices->GetNullString());
	InitializeAssert(m_piServices); // Give assert the services pointer to log the assertions!
	// set the handler version
	ICHAR rgchVersion[20];
	StringCchPrintf(rgchVersion, sizeof(rgchVersion)/sizeof(ICHAR),  MSI_VERSION_TEMPLATE, rmj, rmm, rup, rin);
	SetDBProperty(*MsiString(*IPROPNAME_VERSIONHANDLER), *MsiString(rgchVersion));

	Assert(!m_piDatabase); // check if it has been initialized before
	m_piDatabase = m_piEngine->GetDatabase();
	if (m_piDatabase == 0)
	{
		Terminate();
		return fFalse;
	}
	m_fShowWizards = ToBool(iuiLevel == iuiFull);
	PMsiRecord piErrorRecord = m_piDatabase->CreateTable(*MsiString(m_piDatabase->CreateTempTableName()), 0, *&m_piDialogsTable);
	
	if (piErrorRecord)
	{
LInitFailed:
		if (!fMissingTables)
			PostError(Imsg(idbgHandlerInit));
		Terminate();
		return fFalse;
	} 
	::CreateTemporaryColumn(*m_piDialogsTable, icdString + icdPrimaryKey, itabDSKey);
	::CreateTemporaryColumn(*m_piDialogsTable, icdObject + icdNoNulls, itabDSPointer);
	::CreateTemporaryColumn(*m_piDialogsTable, icdString + icdNullable, itabDSParent);
	::CreateTemporaryColumn(*m_piDialogsTable, IcdObjectPool() + icdNullable, itabDSWindow);
	::CreateTemporaryColumn(*m_piDialogsTable, icdLong + icdNullable, itabDSModal);
	m_piDialogsCursor = m_piDialogsTable->CreateCursor(fFalse);
	m_piGTDCachedCursor = m_piDialogsTable->CreateCursor(fFalse);
	m_piGTDCachedCursor2 = m_piDialogsTable->CreateCursor(fFalse);
	if (!m_piDialogsCursor || !m_piGTDCachedCursor || !m_piGTDCachedCursor2)
	{
		goto LInitFailed;
	} 
	
	AssertNonZero(SetUIScaling());
	m_idyChar        = Round(GetDBPropertyInt(*MsiString(*IPROPNAME_TEXTHEIGHT)) *
									 GetUIScaling());
	m_iScreenWidth   = GetDBPropertyInt(*MsiString(*IPROPNAME_SCREENX));
	m_iScreenHeight  = GetDBPropertyInt(*MsiString(*IPROPNAME_SCREENY));
	m_iBorderWidth   = GetDBPropertyInt(*MsiString(*IPROPNAME_BORDERSIDE));
	m_iBorderHeight  = GetDBPropertyInt(*MsiString(*IPROPNAME_BORDERTOP));
	m_iCaptionHeight = GetDBPropertyInt(*MsiString(*IPROPNAME_CAPTIONHEIGHT));

	// We have a Chicago like UI if the system is 95 or NT4 or above
	g_fChicago = ToBool(GetDBPropertyInt(*MsiString(*IPROPNAME_VERSIONNT)) >= 400 || GetDBPropertyInt(*MsiString(*IPROPNAME_VERSION9X)) != iMsiNullInteger);
	g_fNT4 = ToBool(GetDBPropertyInt(*MsiString(*IPROPNAME_VERSIONNT)) >= 400);
	OSVERSIONINFO osviVersion;
	osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if ( WIN::GetVersionEx(&osviVersion) )
	{
		g_iMajorVersion = osviVersion.dwMajorVersion;
		g_iMinorVersion = osviVersion.dwMinorVersion;
		g_fWin9X = (osviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
	}
	else
	{
		// if GetVersionEx fails is no big issue at this point: it is only
		// tooltips that will not get displayed.  If in the future the
		// handler will start relying more on the OS version numbers, we'll
		// have to return fFalse in this case.
		Assert(0); 
		g_iMajorVersion = g_iMinorVersion = 0;
		g_fWin9X = GetDBPropertyInt(*MsiString(*IPROPNAME_VERSION9X)) != iMsiNullInteger;
	}

	PMsiRecord(m_piDatabase->LoadTable(*MsiString(*pcaTablePControlEvent), 0, *&m_piControlEventTable));
	PMsiRecord(m_piDatabase->LoadTable(*MsiString(*pcaTablePControlCondition), 0, *&m_piControlConditionTable));
	PMsiRecord(m_piDatabase->LoadTable(*MsiString(*pcaTablePEventMapping), 0, *&m_piEventMappingTable));
	PMsiRecord(m_piDatabase->LoadTable(*MsiString(*pcaTablePUIText), 0, *&m_piUITextTable));
	if (PMsiRecord(m_piDatabase->LoadTable(*MsiString(*pcaTablePTextStyle), 0, *&m_piTextStyleTable)))
	{
		if (!CreateTextStyleTab())
		{
			Terminate();
			return fFalse;
		}
	}
	
	AssertNonZero(m_piTextStyleTable->CreateColumn(icdLong + icdTemporary, *MsiString(szColTextStyleAbsoluteSize)) == itabTSTAbsoluteSize);
	AssertNonZero(m_piTextStyleTable->CreateColumn(IcdObjectPool() + icdTemporary, *MsiString(szColTextStyleFontHandle)) == itabTSTFontHandle);

	if (m_piUITextTable)
	{
		g_piUITextCursor = m_piUITextTable->CreateCursor(fFalse);
	}
	m_UIDialogWndClass.style       = CS_DBLCLKS;             
	m_UIDialogWndClass.lpfnWndProc = pWindowProc;     
	m_UIDialogWndClass.cbClsExtra  = 0;                                
	m_UIDialogWndClass.cbWndExtra  = 0;                                
	m_UIDialogWndClass.hInstance   = g_hInstance;
	
	if (g_fChicago)
	{
		m_UIDialogWndClass.hIcon = (HICON) LoadImage(g_hInstance, MAKEINTRESOURCE(10), IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR);
	}
	else
	{
		m_UIDialogWndClass.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(10));
	}

	m_UIDialogWndClass.hCursor       = WIN::LoadCursor(0, MAKEINTRESOURCE(IDC_ARROW));
	m_UIDialogWndClass.hbrBackground = WIN::CreateSolidBrush(WIN::GetSysColor(COLOR_BTNFACE));
	m_UIDialogWndClass.lpszMenuName  = 0;                      
	m_UIDialogWndClass.lpszClassName = MsiDialogCloseClassName;
	if (RegisterClass(&m_UIDialogWndClass) == 0)
	{
		PostError(Imsg(idbgWindowClassRegFailed));
		Terminate();
		return fFalse;
	}

	m_UIDialogWndClass.lpszClassName = MsiDialogNoCloseClassName;
	m_UIDialogWndClass.style         = CS_DBLCLKS|CS_NOCLOSE;  
	if (RegisterClass(&m_UIDialogWndClass) == 0)
	{
		PostError(Imsg(idbgWindowClassRegFailed));
		Terminate();
		return fFalse;
	}
	
	CreateVolumeImageLists();
	m_pDialogPositionRec = &m_piServices->CreateRecord(4);
	AssertNonZero(m_pDialogPositionRec->SetInteger(1, 0));
	AssertNonZero(m_pDialogPositionRec->SetInteger(2, 0));
	AssertNonZero(m_pDialogPositionRec->SetInteger(3, 0));
	AssertNonZero(m_pDialogPositionRec->SetInteger(4, 0));

	Bool fPresent = fFalse;
	piErrorRecord = IsColumnPresent(*m_piDatabase, *MsiString(*pcaTablePDialog), *MsiString(*pcaTableColumnPDialogCancel), &fPresent);
	if (piErrorRecord)
	{
		if (m_piDatabase->FindTable(*MsiString(*pcaTablePDialog)) == itsUnknown)
			fMissingTables = true;
		
		goto LInitFailed;
	}
	piErrorRecord = m_piDatabase->OpenView(fPresent ? sqlDialog : sqlDialogShort, ivcFetch, *&m_piDialogView);
	if (piErrorRecord)
	{
		goto LInitFailed;
	}

	m_idActionText = m_piDatabase->EncodeStringSz(pcaEventActionText);
	m_idActionData = m_piDatabase->EncodeStringSz(pcaEventActionData);
	m_idSetProgress = m_piDatabase->EncodeStringSz(pcaEventSetProgress);

	m_uUserCodePage = 0;
#ifdef UNICODE
	HINSTANCE hLib = WIN::LoadLibrary(TEXT("KERNEL32"));
	FARPROC pfUILang = WIN::GetProcAddress(hLib,
														"GetUserDefaultUILanguage");  // NT5 only
	LANGID lID = pfUILang ? (LANGID)(*pfUILang)() : WIN::GetUserDefaultLangID();
	if ( PRIMARYLANGID(lID) != LANG_ENGLISH )
	{
		// If primary language is English, we use system codepage (it accomodates more characters)
		ICHAR rgchBuf[7];
		int iRes = WIN::GetLocaleInfo(lID, LOCALE_IDEFAULTANSICODEPAGE,
												rgchBuf, sizeof(rgchBuf)/sizeof(*rgchBuf));
		Assert(iRes > 0);
		// WARNING: cheap implementation of strtoul() follows!
		m_uUserCodePage = 0;
		ICHAR* pStr = rgchBuf;
		while ( *pStr )
		{
			if ( *pStr < TEXT('0') || *pStr > TEXT('9') )   //  a cheap !iswdigit()
			{
				ICHAR rgchDebug[MAX_PATH];
				StringCchPrintf(rgchDebug, sizeof(rgchDebug)/sizeof(ICHAR), 
							TEXT("'%c' is a non-digit character in CMsiHandler::Initialize()"),
							*pStr);
				AssertSz(0, rgchDebug);
				break;
			}
			else
			{
				m_uUserCodePage *= 10;
				m_uUserCodePage += *pStr - TEXT('0');
			}
			pStr++;
		}
		if ( !IsValidCodePage(m_uUserCodePage) )
		{
			ICHAR rgchBuffer[100];
			StringCchPrintf(rgchBuffer, sizeof(rgchBuffer)/sizeof(ICHAR), 
						TEXT("'%s' is an incorrect code page in CMsiHandler::Initialize()"),
						rgchBuf);
			AssertSz(0, rgchBuffer);
			m_uUserCodePage = 0;
		}
	}
#endif
	if ( !m_uUserCodePage )
		m_uUserCodePage = WIN::GetACP();
	AssertSz(m_uUserCodePage,
				TEXT("User's code page detected to be NULL in CMsiHandler::Initialize()"));

	return fTrue;
}

void CMsiHandler::Terminate(bool fFatalExit)
{
	if ( fFatalExit )
	{
		//  there is no engine, no database,... - we need to clean up all allocated resouces.
		g_fFatalExit = true;

		//  I destroy the windows first
		DestroyAllHandles(iwhtWindow);
		//  I destroy all other GDI objects.
		DestroyAllHandles();
		Assert(GetHandleCount() == 0);

		if (g_hVolumeSmallIconList)
			ImageList_Destroy(g_hVolumeSmallIconList);
		if (m_UIDialogWndClass.hbrBackground)
			AssertNonZero(WIN::DeleteObject(m_UIDialogWndClass.hbrBackground));
		UnregisterClass(MsiDialogCloseClassName, g_hInstance);
		UnregisterClass(MsiDialogNoCloseClassName, g_hInstance);
		return;
	}

	if ( !m_piEngine )   //  already terminated
		return;

	// remove window and clean up, Release() will be called later
	m_idyChar = 0;
	m_iScreenWidth = 0;
	m_iScreenHeight = 0;
	m_iBorderWidth = 0;
	m_iBorderHeight = 0;
	m_iCaptionHeight = 0;
	m_fCreatingError = fFalse;
	m_fPreview = fFalse;

	// 
	// Release the dialogs cursor before the dialog table
	//
	if (m_piDialogsCursor)
	{
		AssertNonZero(DestroyDialogs());
		m_piDialogsCursor = 0;
	}
	if (m_piGTDCachedCursor)
		m_piGTDCachedCursor = 0;
	if (m_piGTDCachedCursor2)
		m_piGTDCachedCursor2 = 0;

	// Release the Dialogs table
	if (m_piDialogsTable)
		m_piDialogsTable = 0;

	m_pDialogPositionRec = 0;
	m_piTextStyleView = 0;
	if (m_piTextStyleTable)
	{
		PMsiCursor piTextStyleCursor = m_piTextStyleTable->CreateCursor(fFalse);
		if (piTextStyleCursor)
		{
			HANDLE hFont;
			while (piTextStyleCursor->Next())
			{       
				hFont = (HANDLE)GetHandleData(piTextStyleCursor, itabTSTFontHandle);
				if (hFont && hFont != (HANDLE)((INT_PTR)iMsiStringBadInteger))
				{
					AssertNonZero(DestroyHandle(hFont) != -1);
				}
			}
		}

	}
	m_piTextStyleTable        = 0;

	m_piControlEventTable     = 0;
	m_piControlConditionTable = 0;
	m_piEventMappingTable     = 0;

	if (g_piUITextCursor)
	{
		g_piUITextCursor->Release();
		g_piUITextCursor = 0;
	}
	
	m_piUITextTable     = 0;
	m_pstrCurrentAction = 0;
	m_piDatabase        = 0;
	m_piServices        = 0;
	m_piEngine          = 0;
	m_fProgressByData   = fFalse;
	m_iProgressTotal    = 0;
	m_iProgress         = 0;
	m_pwndParent        = 0;
	m_piDialogView      = 0;

	if (g_hVolumeSmallIconList)
		ImageList_Destroy(g_hVolumeSmallIconList);
	if (m_UIDialogWndClass.hbrBackground)
		AssertNonZero(WIN::DeleteObject(m_UIDialogWndClass.hbrBackground));
	UnregisterClass(MsiDialogCloseClassName, g_hInstance);
	UnregisterClass(MsiDialogNoCloseClassName, g_hInstance);
	ReleaseAllocator();
	Assert(GetHandleCount() == 0);
}

unsigned long CMsiHandler::AddRef()
{
	return ++m_iRefCnt;
} 

unsigned long CMsiHandler::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	if (!m_piDialogsTable || m_piDialogsTable->GetRowCount() == 0)
		delete this;
	return 0;
}

void AddIconToList(const HIMAGELIST hList, const int iResIndex, const int iIconIndex)
{
	HICON hTemp = (HICON)WIN::LoadImage(g_hInstance, MAKEINTRESOURCE(iResIndex), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
	Assert(hTemp);
	if ( hTemp )
	{
		AssertNonZero(iIconIndex == WIN::ImageList_AddIcon(hList, hTemp));
		AssertNonZero(WIN::DestroyIcon(hTemp));
	}
}


struct VolumeIcon
{
	int iResIndex;
	int iIconIndex;
};

static const VolumeIcon g_VolumeIconList[] = 
	{
	{1, g_iIconIndexMyComputer},
	{2, g_iIconIndexRemovable },
	{3, g_iIconIndexFixed     },
	{4, g_iIconIndexRemote    },
	{5, g_iIconIndexFolder    },
	{6, g_iIconIndexCDROM     },
	{7, g_iIconIndexPhantom   },
	{0, 0                     },
	};

void CMsiHandler::CreateVolumeImageLists()
{
	g_hVolumeSmallIconList = ImageList_Create(16, 16, ILC_MASK, 3, 0);

	for (const VolumeIcon* pVI = g_VolumeIconList; pVI->iResIndex; pVI++)
	{
		AddIconToList(g_hVolumeSmallIconList, pVI->iResIndex, pVI->iIconIndex);
	}
}


imsEnum CMsiHandler::SetProgressGauge(int iProgress, int iProgressTotal)
{
	int cDiff;
	if ((cDiff = iProgress - m_iOldProgress) < 0)
		cDiff = -cDiff;

	//
	// Only update if it's a significant change
	//
	if (m_iOldProgressTotal == iProgressTotal && cDiff <= iProgressTotal/0x100)
		return imsOk;

	m_iOldProgressTotal = iProgressTotal;
	m_iOldProgress = iProgress;
	
	// Report progress to progress bars
	if (m_pProgressRec == 0)
		m_pProgressRec = &m_piServices->CreateRecord(3);

	AssertNonZero(m_pProgressRec->SetInteger(1, iProgress));
	AssertNonZero(m_pProgressRec->SetInteger(2, iProgressTotal));
	if(m_pstrCurrentAction)
		AssertNonZero(m_pProgressRec->SetMsiString(3, *m_pstrCurrentAction));
	else
		AssertNonZero(m_pProgressRec->SetNull(3));

	const ICHAR* szAction = pcaActionEnable;
	if (iProgressTotal > iProgress)
		szAction = pcaActionDisable;

	if (m_idSetProgress != 0)
	{
		if (!PublishEvent(m_idSetProgress, *m_pProgressRec) ||
			!EventAction(m_idSetProgress, *MsiString(*szAction)))
		{
			return imsError;
		}
	}
	else if (!PublishEventSz(pcaEventSetProgress, *m_pProgressRec) ||
		!EventActionSz(pcaEventSetProgress, *MsiString(*szAction)))
	{
		return imsError;
	}
	return imsOk;
}


imsEnum CMsiHandler::Message(imtEnum imt, IMsiRecord& riRec)
{
	if (!m_piEngine)
	{
		AssertSz(fFalse, "Uninitialized Handler Object");
		return imsError;
	}
	imsEnum imsReturn = imsOk;
	PMsiRecord piReturn(0);

	switch (imt & imtTypeMask)
	{
		case imtCommonData:   // language ID, dialog caption, or cancel button enable/disable
			if ( riRec.GetInteger(1) == (int)icmtCancelShow )
			{
				PMsiDialog piDialog(0);
				PMsiRecord piRecord = &m_piServices->CreateRecord(1);

				bool fCancelVisible = riRec.GetInteger(2) != 0;
				if ( FindModeless(*&piDialog) && 
					  !PMsiRecord(piDialog->AttributeEx(fFalse, dabCancelButton, *piRecord)) &&
					  !PMsiRecord(PMsiControl(((IMsiControl *)(piRecord->GetMsiData(1))))->
													AttributeEx(fFalse, cabWindowHandle, *piRecord)) )
				{
					WIN::ShowWindow((WindowRef)piRecord->GetHandle(1),
							fCancelVisible ? SW_SHOW : SW_HIDE);

					// disable the response to the cancel
					//FUTURE: All the hiding and unhiding should go into the dialog itself
					piDialog->SetCancelAvailable(fCancelVisible);
				}
			}
			return imsOk;
		case imtInfo:         // informative message, no action should be taken
			return imsOk;
		case imtActionStart:  // [1] is action name, [2] is action description
		{
			m_pstrCurrentAction = &riRec.GetMsiString(1);
			MsiString strActionDescription = riRec.GetMsiString(2);
			if (strActionDescription.Compare(iscExact, pcaDialogCreated)) // this message is generated by the UI, skip it
				return imsOk;

			PMsiRecord piRecord = &m_piServices->CreateRecord(1);
			AssertNonZero(piRecord->SetMsiString(1, *strActionDescription));
			// If we have the string id cached, use it
			if (m_idActionText != 0)
			{
				if (!PublishEvent(m_idActionText, *piRecord))
					return imsError;
			}
			else if (!PublishEventSz(pcaEventActionText, *piRecord))
				return imsError;

			if (m_idActionData != 0)
			{
				if (!EventAction(m_idActionData, *MsiString(*pcaActionHide)))
					return imsError;
			}
			else if (!EventActionSz(pcaEventActionData, *MsiString(*pcaActionHide)))
			{
				return imsError;
			}
			
			imsReturn = imsOk;
			break;
		}
		case imtActionData:   // action data, fields are action-specific
			if (m_fPreview)
			{
				m_piDialogsCursor->Reset();
				PMsiDialog piDialog(0);
				PMsiRecord piReturn(0);
				if (m_piDialogsCursor->Next())
				{
					piDialog = (IMsiDialog *)(m_piDialogsCursor->GetMsiData(itabDSPointer));
					MsiString strControl = riRec.GetMsiString(1);
					MsiString strBillboard = riRec.GetMsiString(2);
					PMsiControl piControl(0);
					piReturn = piDialog->GetControl(*strControl, *&piControl);
					if (!piReturn)
					{
						PMsiRecord piBBRecord = &m_piServices->CreateRecord(1);
						AssertNonZero(piBBRecord->SetMsiString(1, *strBillboard));

						piReturn = piControl->AttributeEx(fTrue, cabBillboardName, *piBBRecord);
					}
					//
					// This checks the error for either return call
					//
					if (piReturn)
					{
						m_piDialogsCursor->Reset();
						return imsError;
					}
					m_piDialogsCursor->Reset();
					return imsOk;
				}
				else  // there is no dialog showing
				{
					m_piDialogsCursor->Reset();
					return imsError;
				}
			}

			if (m_idActionData != 0)
			{
				if (!PublishEvent(m_idActionData, riRec) ||
					!EventAction(m_idActionData, *MsiString(*pcaActionShow)))
				{
					return imsError;
				}
			}
			else if (!PublishEventSz(pcaEventActionData, riRec) ||
				!EventActionSz(pcaEventActionData, *MsiString(*pcaActionShow)))
			{
				return imsError;
			}
			imsReturn = imsOk;
			break;
		case imtProgress:
		{
			using namespace ProgressData;
			switch (riRec.GetInteger(imdSubclass))
			{
			case iMsiNullInteger:  // no progess, used to keep UI alive when running in other thread/process
				break;
			case iscMasterReset: // Master reset
			{
				m_iProgressTotal = riRec.GetInteger(imdProgressTotal);
				m_ipdDirection = (ipdEnum) riRec.GetInteger(imdDirection);
				m_iProgress = m_ipdDirection == ipdForward ? 0 : m_iProgressTotal;
				m_uiStartTime = 0;
				m_uiLastReportTime = 0;
				m_fProgressByData = fFalse;

				// If previous event type was ScriptInProgress, finish off the 
				// progress bar; otherwise, reset it.
				imsEnum imsReturn;
				if (m_ietEventType == ietScriptInProgress)
					imsReturn = SetProgressGauge(m_iProgressTotal, m_iProgressTotal);
				else
					imsReturn = SetProgressGauge(m_iProgress, m_iProgressTotal);

				// If the new event type is ScriptInProgress, kick off the 
				// ScriptInProgress ControlEvent.
				m_ietEventType = (ietEnum) riRec.GetInteger(imdEventType);
				if (m_ietEventType == ietScriptInProgress)
				{
					// Set ScriptInProgress string
					// cgouge: create private copy
					PMsiRecord piPrivateRec = &m_piServices->CreateRecord(1);
					piPrivateRec->SetInteger(1, fTrue);
					if (!PublishEventSz(pcaEventScriptInProgress, *piPrivateRec))
						return imsError;
				}
				return imsReturn;
			}
			case iscActionInfo: // Action init
				m_iPerTick = riRec.GetInteger(imdPerTick);
				m_fProgressByData = riRec.GetInteger(imdType) == 0 ? fFalse : fTrue;
				break;
			case iscProgressReport: // Reporting actual progress
				{
					if (m_iProgressTotal == 0 || m_pstrCurrentAction == 0 || m_pstrCurrentAction->TextSize() == 0)
					{
						imsReturn = imsOk;
						break;
					}
					// Report time remaining (in seconds)
					if (m_uiStartTime == 0)
					{
						m_uiStartTime = GetTickCount();
						m_uiLastReportTime = m_uiStartTime;
						if (m_ietEventType != ietScriptInProgress)
						{
							// Clear ScriptInProgress string
							// cgouge: create private copy
							PMsiRecord piPrivateRec = &m_piServices->CreateRecord(1);
							piPrivateRec->SetInteger(1, fFalse);
							if (!PublishEventSz(pcaEventScriptInProgress, *piPrivateRec))
								return imsError;
						}
						break;
					}
					
					int iSign = m_ipdDirection == ipdForward ? 1 : -1;
					if (m_fProgressByData)
						m_iProgress += m_iPerTick * iSign;
					else
						m_iProgress += riRec.GetInteger(imdIncrement) * iSign;

					// Report progress to progress bars
					SetProgressGauge(m_iProgress, m_iProgressTotal);

					if (m_ietEventType == ietTimeRemaining)
					{
						int iBytesSoFar = m_ipdDirection == ipdForward ? m_iProgress : m_iProgressTotal - m_iProgress;
						int iBytesRemaining = m_iProgressTotal - iBytesSoFar;
						if (iBytesRemaining < 0) iBytesRemaining = 0;
						int iBytesPerSec = MulDiv(iBytesSoFar, 1000, GetTickCount() - m_uiStartTime);
						if (iBytesPerSec == 0) iBytesPerSec = 1;
						int iSecsRemaining = iBytesRemaining / iBytesPerSec;

						int iReportInterval = iSecsRemaining > 60 ? 15000 : 1000;
						if (iBytesSoFar > 0 && ((GetTickCount() - m_uiLastReportTime) > iReportInterval))
						{
							m_uiLastReportTime = GetTickCount();
							AssertNonZero(m_pProgressRec->SetInteger(1, iSecsRemaining));
							if (!PublishEventSz(pcaEventTimeRemaining, *m_pProgressRec))
								return imsError;
						}
					}
					imsReturn = imsOk;
					break;
				}
			default:
				break;
			}
		}
			break;
		case imtFatalExit:    // only happens when sent from server to engine client
		case imtError:        // error message
		case imtWarning:      // warning message
		case imtUser:         // user request
		case imtOutOfDiskSpace:
		{
			//  If you modify this array, make sure you update CreateNewDialog() method
			//  as well.  In there we're looking for 'C' and "O" for establishing which
			//  is the dialog's Cancel button - eugend
			static const ICHAR * ppch[6] = {TEXT("O"),TEXT("OC"),TEXT("ARI"),TEXT("YNC"),TEXT("YN"),TEXT("RC")};
			if (m_fCreatingError)   // if we are in the middle of creating the error dialog, we just log the error, but do not show it
			{
				return imsNone;
			}
			m_fCreatingError =  fTrue;
			MsiString strErrorDialog = GetDBProperty(*MsiString(*pcaPropertyErrorDialog));
			if (!strErrorDialog.TextSize())
			{
				PMsiRecord piErrorRecord = &m_piServices->CreateRecord(1);
				ISetErrorCode(piErrorRecord, Imsg(idbgNoErrorProperty));
				m_piEngine->Message(imtInfo, *piErrorRecord);
				return imsNone;
			}

			MsiString strMsg(riRec.FormatText(fFalse));
			MsiString strHeader;
			//!! need to determine buttons from imt parameter!!
			int iStyle = imt & 7;

			MsiString strList = ppch[iStyle];
			int iDefault = 0;
			switch (imt & 7<<8)
			{
			case imtDefault1:
				iDefault = 1;
				break;
			case imtDefault2:
				iDefault = 2;
				break;
			case imtDefault3:
				iDefault = 3;
				break;
			default:
				PostError(Imsg(idbgUnknownMessageType), *MsiString((int)imt));
				return imsNone;
				break;
			}
			Assert(strList.TextSize() >= iDefault);
			PMsiDialog piErrorDialog(0);
			MsiStringId iOwner = GetTopDialog();
			if (iesSuccess != CreateNewDialog(m_piDatabase->EncodeString(*strErrorDialog), iOwner, *&piErrorDialog, fTrue, *strMsg, *strList, iDefault, fFalse, fFalse))
			{           
				return imsError;
			}
			if (strHeader.TextSize())  // set the dialog title
			{
				PMsiRecord piHeaderRecord = &m_piServices->CreateRecord(1);
				AssertNonZero(piHeaderRecord->SetMsiString(1, *strHeader));
				PMsiRecord(piErrorDialog->AttributeEx(fTrue, dabText, *piHeaderRecord));
			}
			PMsiControl piIconCtrl(0);
			PMsiRecord piReturn = piErrorDialog->GetControl(*MsiString(*pcaErrorIcon),
																			*&piIconCtrl);
			if ( piIconCtrl &&
				  !IStrComp(piIconCtrl->GetControlType(), g_szIconType) )
			{
				HICON hIcon = NULL;
				if (imt & MB_ICONMASK)
				{
					// icon specified in message type
					switch (imt & MB_ICONMASK)
					{
						case MB_ICONSTOP: // MB_ICONSTOP, MB_ICONERROR, MB_ICONHAND
							hIcon = WIN::LoadIcon(NULL, IDI_HAND);
							WIN::MessageBeep(MB_ICONHAND);
							break;
						case MB_ICONQUESTION: // MB_ICONQUESTION
							hIcon = WIN::LoadIcon(NULL, IDI_QUESTION);
							WIN::MessageBeep(MB_ICONQUESTION);
							break;
						case MB_ICONEXCLAMATION: // MB_ICONEXCLAMATION, MB_ICONWARNING
							hIcon = WIN::LoadIcon(NULL, IDI_EXCLAMATION);
							WIN::MessageBeep(MB_ICONEXCLAMATION);
							break;
						case MB_ICONINFORMATION: // MB_ICONINFORMATION, MB_ICONASTERISK
							hIcon = WIN::LoadIcon(NULL, IDI_ASTERISK);
							WIN::MessageBeep(MB_ICONASTERISK);
							break;
					}
				}
				else
				{
					// no icon specified, use our defaults
					switch ( imt & imtTypeMask )
					{
						case imtFatalExit:
						{
							hIcon = WIN::LoadIcon(NULL, IDI_HAND);
							WIN::MessageBeep(MB_ICONHAND);
							break;
						}
						case imtError:
						case imtWarning:
						{
							hIcon = WIN::LoadIcon(NULL, IDI_EXCLAMATION);
							WIN::MessageBeep(MB_ICONEXCLAMATION);
							break;
						}
						case imtOutOfDiskSpace:
						case imtUser:
						{
							hIcon = WIN::LoadIcon(NULL, IDI_ASTERISK);
							WIN::MessageBeep(MB_ICONASTERISK);
							break;
						}
						default:
							Assert(false);
							break;
					}
				}
				if ( hIcon )
				{
					hIcon = WIN::CopyIcon(hIcon);    //  bug # 6264: on Win95
					//  we cannot call DestroyIcon on system ones.
					PMsiRecord piRec = &m_piServices->CreateRecord(1);
					AssertNonZero(piRec->SetHandle(1, (HANDLE)hIcon));
					piRec = piIconCtrl->AttributeEx(fTrue, cabImageHandle, *piRec);
					if ( piRec )
					{
						m_piEngine->Message(imtInfo, *piRec);
						AssertNonZero(WIN::DestroyIcon(hIcon));
					}
				}
				piIconCtrl = 0;   //  we're done with it.
			}
			else
				m_piEngine->Message(imtInfo, *piReturn);

			SetInPlace(*piErrorDialog, fTrue);
			piReturn = piErrorDialog->WindowShow(fTrue);
			if(piReturn)
			{
				m_piEngine->Message(imtError, *piReturn);
				RemoveDialog(piErrorDialog);
				return imsError;
			}
			PMsiRecord piRec = &m_piServices->CreateRecord(1);
/* taken care of in Dialog::Execute()
			WindowRef pOwner = 0;
			PMsiRecord piRec = &m_piServices->CreateRecord(1);
			if (iOwner)
			{
				PMsiDialog piOwner = GetDialog(iOwner);
				Assert(piOwner);
				PMsiRecord(piOwner->AttributeEx(fFalse, dabWindowHandle, *piRec));
#ifdef _WIN64   // !merced
				pOwner = (WindowRef) piRec->GetHandle(1);
#else
				pOwner = (WindowRef) piRec->GetInteger(1);
#endif
				WIN::EnableWindow(pOwner, fFalse);
			}
*/
			//  dropping the (modal) error dialog's eventual minimize button.
			AssertRecord(piErrorDialog->AttributeEx(fFalse, dabWindowHandle,
																 *piRec));
			::ChangeWindowStyle((WindowRef)piRec->GetHandle(1),
									  WS_MINIMIZEBOX, 0, fFalse);
			int iBreakStartTime = GetTickCount();
			PMsiRecord pReturnRecord = piErrorDialog->Execute();
			m_uiStartTime += GetTickCount() - iBreakStartTime;
			m_fCreatingError = fFalse;
/* taken care of in Dialog::Execute()
			if (pOwner)
			{
				WIN::EnableWindow(pOwner, fTrue);
			}
*/
			if (pReturnRecord)
			{
				RemoveDialog(piErrorDialog);
				if (pReturnRecord->GetInteger(1) != idbgActionFailed) // assume that actions launched via the DoAction ControlEvent display their own errors
					m_piEngine->Message(imtError, *pReturnRecord);
				return imsError;
			}
			else 
			{
				PMsiRecord piResultRecord = &m_piServices->CreateRecord(1);
				AssertRecord(piErrorDialog->AttributeEx(fFalse, dabEventInt, *piResultRecord));
				RemoveDialog(piErrorDialog);
				int iRet = piResultRecord->GetInteger(1);
				Assert(iRet > 8 && iRet < 16);
				return (imsEnum) (iRet - 8);
			}
		}
		case imtFilesInUse:
		{
			const ICHAR szFileInUseProcessProperty[] = TEXT("FileInUseProcess");
			PMsiTable pListBoxTable(0);
			PMsiRecord pError = m_piDatabase->LoadTable(*MsiString(*pcaControlTypeListBox),
																	  0, *&pListBoxTable);
			if ( pError )
			{
				m_piEngine->Message(imtInfo, *pError);
				return imsError;
			}
			int iColProperty = pListBoxTable->GetColumnIndex(m_piDatabase->EncodeStringSz(TEXT("Property")));
			int iColValue = pListBoxTable->GetColumnIndex(m_piDatabase->EncodeStringSz(TEXT("Value")));
			int iColText = pListBoxTable->GetColumnIndex(m_piDatabase->EncodeStringSz(TEXT("Text")));
			int iColOrder = pListBoxTable->GetColumnIndex(m_piDatabase->EncodeStringSz(TEXT("Order")));
			Assert(iColProperty > 0 && iColValue > 0 && iColText > 0 && iColOrder > 0);
			PMsiCursor pListBoxCursor = pListBoxTable->CreateCursor(fFalse);
			Assert(pListBoxCursor);
			int iProcessIndex = 1;
			int iFieldIndex = 1;
			while (!riRec.IsNull(iFieldIndex))
			{
				pListBoxCursor->Reset();
				pListBoxCursor->SetFilter(iColumnBit(iColProperty) | iColumnBit(iColValue));
				AssertNonZero(pListBoxCursor->PutString(iColProperty,*MsiString(szFileInUseProcessProperty)));
				MsiString strProcessName(riRec.GetMsiString(iFieldIndex++));
				AssertNonZero(pListBoxCursor->PutString(iColValue,*strProcessName));
				if (!pListBoxCursor->Next())
				{
					MsiString strProcessTitle(riRec.GetMsiString(iFieldIndex));
					pListBoxCursor->SetFilter(0);
					pListBoxCursor->Reset();
					AssertNonZero(pListBoxCursor->PutString(iColProperty,*MsiString(szFileInUseProcessProperty)));
					AssertNonZero(pListBoxCursor->PutString(iColValue,*strProcessName));
					AssertNonZero(pListBoxCursor->PutString(iColText,*strProcessTitle));
					AssertNonZero(pListBoxCursor->PutInteger(iColOrder,iProcessIndex++));
					AssertNonZero(pListBoxCursor->InsertTemporary());
				}
				iFieldIndex++;
			}

			imsEnum imsReturn = imsOk;
			if (iProcessIndex > 1)
			{
				MsiStringId iParent = GetTopDialog();
				MsiStringId iDialog = 
					m_piDatabase->EncodeStringSz(TEXT("FilesInUse"));
				Assert(iParent && iDialog);
				idreEnum idreResult = DoModalDialog(iDialog, iParent);
				if ( idreResult == idreRetry )
					imsReturn = imsRetry;
				else if ( idreResult == idreExit )
					imsReturn = imsCancel;
				pListBoxCursor->Reset();
				pListBoxCursor->SetFilter(iColumnBit(iColProperty));
				AssertNonZero(pListBoxCursor->PutString(iColProperty,*MsiString(szFileInUseProcessProperty)));
				while (pListBoxCursor->Next())
					pListBoxCursor->Delete();
			}
			return imsReturn;
		}
		case imtResolveSource:
		{
			//!! Should do something like: DoAction(TEXT("ResolveSource"));
			return imsNone;
		}
		default:
		{
			PostError(Imsg(idbgUnknownMessageType), *MsiString(imt >> imtShiftCount));
			return imsNone;
			break;
		}
	}
	ClearMessageQueue();
	PMsiDialog piDialog(0);
	MsiStringId iDialog = 0;
	MsiStringId iTopDialog = 0;
	MsiStringId iBottomDialog = 0;
	
	m_piDialogsCursor->Reset();
	PMsiRecord piRecord = &m_piServices->CreateRecord(1);
	while (m_piDialogsCursor->Next())
	{
		piDialog = (IMsiDialog *)m_piDialogsCursor->GetMsiData(itabDSPointer);
		AssertRecord(piDialog->AttributeEx(fFalse, dabRunning, *piRecord));
		if ((m_piDialogsCursor->GetInteger(itabDSModal) ==  icmdModeless) && !piRecord->GetInteger(1))  // we found a stopped modeless dialog
		{
			iDialog = piDialog->GetIntegerValue();
			break;
		}
	}
	m_piDialogsCursor->Reset();
	if (!iDialog)
		return imsReturn;

	unsigned int uiBreakStartTime = GetTickCount();
	iesEnum iesReturn = RunWizard(iDialog);
	m_uiStartTime += GetTickCount() - uiBreakStartTime;

	switch (iesReturn)
	{
	case iesNoAction:
		return imsReturn;
	case iesSuccess:
		return imsOk;
	case iesFailure:
		return imsError;
	case iesUserExit:
		//!! should clear text on modeless dialog??
/*
		if(!RemoveOtherDialogs(iDialog))
			return imsError;
		if (!RemoveDialog(iDialog))
			return imsError;
*/
		return imsCancel;
	case iesSuspend:
		return imsRetry;
	case iesFinished:
		return imsIgnore;
	default:                           // should not happen
		Assert(fFalse);
		return imsError;
	}
	// should never get here
	return imsReturn;   
}

MsiStringId CMsiHandler::GetTopDialog(IMsiDialog** ppiDialog/* = 0*/)
{
	if (!m_piEngine)
	{
		return fFalse;
	}
	if (!m_piGTDCachedCursor || !m_piGTDCachedCursor2)
	{
		PostError(Imsg(idbgCursorCreate), *MsiString(*pcaTableIDialogs));
		return 0;
	}

	MsiStringId iTop = 0;
	PMsiRecord piRecord = &m_piServices->CreateRecord(1);
	PMsiDialog piDialog(0);

	m_piGTDCachedCursor->Reset();
	m_piGTDCachedCursor2->SetFilter(iColumnBit(itabDSParent));
	MsiStringId iErrorDlg = m_piDatabase->EncodeStringSz(pcaErrorDialog);
	while (m_piGTDCachedCursor->Next())
	{
		MsiString strName = m_piGTDCachedCursor->GetString(itabDSKey);
		MsiStringId iName = m_piGTDCachedCursor->GetInteger(itabDSKey);
		if ( iName == iErrorDlg )
			continue;
		piDialog = (IMsiDialog *)m_piGTDCachedCursor->GetMsiData(itabDSPointer);
		AssertRecord(piDialog->AttributeEx(fFalse, dabShowing, *piRecord));
		if (piRecord->GetInteger(1) == fFalse)
			continue;
		if (m_piGTDCachedCursor->GetInteger(itabDSModal) == icmdModeless) // this is modeless and we have no modal yet
		{
			if (!iTop)
				iTop = iName;
			continue;
		}
		m_piGTDCachedCursor2->Reset();
		m_piGTDCachedCursor2->PutInteger(itabDSParent, iName);
		if (!m_piGTDCachedCursor2->Next()) // this dialog is nobody's parent
		{
			iTop = iName;
			break;
		}
	}
	if (iTop && ppiDialog)
	{
		piDialog->AddRef();
		*ppiDialog = piDialog;
	}
	return iTop;
}


Bool CMsiHandler::Break()
{
	if (!m_piEngine)
	{
		AssertSz(fFalse, "Uninitialized Handler Object");
		return fFalse;
	}
	PMsiDialog pDialog = GetDialog(GetTopDialog());
	PMsiRecord piHandleRecord = &m_piServices->CreateRecord(1);
	AssertRecord(pDialog->AttributeEx(fFalse, dabWindowHandle, *piHandleRecord));
	AssertNonZero(WIN::PostMessage((WindowRef)piHandleRecord->GetHandle(1), WM_USERBREAK, 0, 0));
	return fTrue;
}

iesEnum CMsiHandler::DoAction(const ICHAR* szAction)
{
	//!! no actions currently in the standard UI
	// would normally search the local table for the requested action
	if (!m_piEngine)
	{
		AssertSz(fFalse, "Uninitialized Handler Object");
		return iesFailure;
	}
	MsiString strDialog(szAction);
	if (strDialog.Compare(iscExact, TEXT("!")))
	{
		m_fPreview = fTrue;
		return iesSuccess;
	}
	if (m_fPreview)
	{
		if (!DestroyDialogs())
			return iesFailure;
		if (strDialog.TextSize() == 0)
			return iesSuccess;
	}
	MsiStringId iDialog = m_piDatabase->EncodeString(*strDialog);
	if (!iDialog)
	{
		return iesNoAction;
	}
	//first should check if it is a custom action
	
	IMsiDialog* piDialog = 0;
	MsiString strNull;

	// find if there is a modeless dialog around and store its position
	PMsiDialog piModelessDialog(0);

	// Assured that we are at the start
	Assert(m_piDialogsCursor->GetInteger(itabDSKey) == 0);
	while (m_piDialogsCursor->Next())
	{
		piModelessDialog = (IMsiDialog *)m_piDialogsCursor->GetMsiData(itabDSPointer);
		if (icmdModeless == m_piDialogsCursor->GetInteger(itabDSModal))
		{
			PMsiRecord piOldPositionRecord= &m_piServices->CreateRecord(4);
			AssertRecord(piModelessDialog->AttributeEx(fFalse, dabPosition, *piOldPositionRecord));         // get the position of the old dialog
			if (piOldPositionRecord->GetInteger(1) < 0XFFFF0000)
				m_pDialogPositionRec = piOldPositionRecord;
			break;
		}
	}
	m_piDialogsCursor->Reset();
	
	iesEnum iesRet = CreateNewDialog(iDialog, 0, *&piDialog,
												fFalse, *strNull, *strNull, 0, fTrue,
												m_fPreview);
	if (iesRet != iesSuccess)
		return iesRet;

	piDialog->Release(); // we don't keep a reference to the dialog in this function

	PMsiRecord pActionStart = &m_piServices->CreateRecord(2);
	AssertNonZero(pActionStart->SetMsiString(1, *strDialog));
	AssertNonZero(pActionStart->SetMsiString(2, *MsiString(*pcaDialogCreated)));
	if ( m_piEngine->Message(imtActionStart, *pActionStart) == imsCancel )
		return iesUserExit;

	PMsiRecord piRecord = &m_piServices->CreateRecord(1);
	if (m_fPreview)
	{
		AssertNonZero(piRecord->SetInteger(1, icmdModeless));
		AssertRecord(piDialog->AttributeEx(fTrue, dabModal, *piRecord));
	}
	AssertRecord(piDialog->AttributeEx(fFalse, dabModal, *piRecord));
	Bool fModal = ToBool(icmdModeless != piRecord->GetInteger (1));
	AdjustDialogPosition(*piDialog); 
	SetInPlace(*piDialog, fTrue);
	PMsiRecord piReturn = piDialog->WindowShow(fTrue);
	if(piReturn)
	{
		m_piEngine->Message(imtError, *piReturn);
		return iesFailure;
	}
	if (!RemoveOtherDialogs(iDialog))
	{
		return iesFailure;
	}
	if (fModal && !m_fPreview)        // if modal and we are not in preview mode
	{
		piReturn = piDialog->Execute();
		if (piReturn)
		{
			if (piReturn->GetInteger(1) != idbgActionFailed) // assume that actions launched via the DoAction ControlEvent display their own errors
				m_piEngine->Message(imtError, *piReturn);
			return iesFailure;
		}
		return RunWizard(iDialog); 
	}
	else // if modeless or we are in preview
	{
		ClearMessageQueue();
		return iesSuccess;      
	} 
}

Bool CMsiHandler::RemoveOtherDialogs(MsiStringId iDialog)
{
	PMsiDialog piDialog = GetDialog(iDialog);
	PMsiRecord pReturnRecord = &m_piServices->CreateRecord(1);
	AssertRecord(piDialog->AttributeEx(fFalse, dabKeepModeless, *pReturnRecord)); 
	if (pReturnRecord->GetInteger(1))   // if bit is set, skip the rest of this method
		return fTrue;

	//
	// Use our own here because we call RemoveDialog which uses m_piDialogsTable
	PMsiCursor piDialogsCursor = m_piDialogsTable->CreateCursor(fFalse);
	if (!piDialogsCursor)
	{
		PostError(Imsg(idbgCursorCreate), *MsiString(*pcaTableIDialogs));
		return fFalse;
	}
	MsiStringId iThisDialog = 0;
	while (piDialogsCursor->Next())
	{
		iThisDialog = piDialogsCursor->GetInteger(itabDSKey);
		if (iThisDialog != iDialog)
		{
			RemoveDialog(iThisDialog);
		}
	}
	return fTrue;
}

Bool CMsiHandler::RemoveModelessDialog()
{
	// Assert that the cursor is reset
	Assert(m_piDialogsCursor->GetInteger(itabDSKey) == 0);
	
	while (m_piDialogsCursor->Next())
	{
		if (m_piDialogsCursor->GetInteger(itabDSModal) == icmdModeless)
		{
			MsiStringId iDialog;
			iDialog = m_piDialogsCursor->GetInteger(itabDSKey);
			m_piDialogsCursor->Reset();
			RemoveDialog(iDialog); //there can be only one modeless dialog
			break;
		}
	}

	m_piDialogsCursor->Reset();
	return fTrue;
}

void CMsiHandler::AdjustDialogPosition(IMsiDialog& riDialog)
{
	int x, y, dx, dy;
	
	x = m_pDialogPositionRec->GetInteger(1);
	y = m_pDialogPositionRec->GetInteger(2);
	dx = m_pDialogPositionRec->GetInteger(3);
	dy = m_pDialogPositionRec->GetInteger(4);
	
	if (x == 0 && y == 0 && dx == 0 && dy == 0)
		return;

	PMsiRecord piPositionRecord = &m_piServices->CreateRecord(4);
	AssertRecord(riDialog.AttributeEx(fFalse, dabPosition, *piPositionRecord));             // get the position of the dialog
	RECT WorkArea;
	AssertNonZero(WIN::SystemParametersInfo(SPI_GETWORKAREA, 0, &WorkArea, 0));
	int iScreenX = WorkArea.left;
	int iScreenY = WorkArea.top;
	int iScreenWidth = WorkArea.right - WorkArea.left;
	int iScreenHeight = WorkArea.bottom - WorkArea.top;
	int xNew, yNew;
	// move new dialog so its center is at the same point as the center of the old one
	xNew = x + dx/2 - piPositionRecord->GetInteger(3)/2;
	yNew = y + dy/2 - piPositionRecord->GetInteger(4)/2;
	// make sure that at least part of the dialog is visible
	xNew = max(xNew, iScreenX + 60 - piPositionRecord->GetInteger(3));
	AssertNonZero(piPositionRecord->SetInteger(1, min(xNew, iScreenX + iScreenWidth - 60)));
	yNew = max(yNew, iScreenY);
	AssertNonZero(piPositionRecord->SetInteger(2, min(yNew, iScreenY + iScreenHeight - 20)));
	AssertRecord(riDialog.AttributeEx(fTrue, dabPosition, *piPositionRecord));      // set the position of the new dialog
}



iesEnum CMsiHandler::RunWizard(MsiStringId iDialog)
{
	PMsiDialog piDialog = GetDialog(iDialog);
	Assert(piDialog);
	PMsiDialog piNewDialog(0);
	int iNew;
	PMsiRecord pReturnRecord = &m_piServices->CreateRecord(1);
	idreEnum idreCode;
	iesEnum iesRet;
	MsiString strArg;
	MsiString strNull;
	for (;;)
	{
		AssertRecord(piDialog->AttributeEx(fFalse, dabEventInt, *pReturnRecord)); 
		idreCode = (idreEnum)pReturnRecord->GetInteger(1);
		AssertRecord(piDialog->AttributeEx(fFalse, dabArgument, *pReturnRecord));
		strArg = pReturnRecord->GetMsiString(1);
		//  I better remove the last event here
		AssertNonZero(pReturnRecord->SetInteger(1, idreNone));
		AssertRecord(piDialog->AttributeEx(fTrue, dabEventInt, *pReturnRecord));

		switch (idreCode)
		{
		case idreBreak:
		case idreError:
			return iesFailure;
			break;
		case idreNew:
			{
				iNew = m_piDatabase->EncodeString(*strArg);
				Assert(iNew);
				iesRet = CreateNewDialog(iNew, 0, *&piNewDialog, fTrue, *strNull, *strNull, 0, fFalse, fFalse);
				if (iesRet != iesSuccess)
				{
					return iesFailure;
				}

				PMsiRecord pActionStart = &m_piServices->CreateRecord(2);
				AssertNonZero(pActionStart->SetMsiString(1, *strArg));
				AssertNonZero(pActionStart->SetMsiString(2, *MsiString(*pcaDialogCreated)));
				if ( m_piEngine->Message(imtActionStart, *pActionStart) == imsCancel )
					return iesUserExit;

				PMsiRecord piOldPositionRecord= &m_piServices->CreateRecord(4);
				AssertRecord(piDialog->AttributeEx(fFalse, dabPosition, *piOldPositionRecord));         // get the position of the old dialog
				if (piOldPositionRecord->GetInteger(1) < 0XFFFF0000)
					m_pDialogPositionRec = piOldPositionRecord;
				AdjustDialogPosition(*piNewDialog); 
				SetInPlace(*piNewDialog, fTrue);
				PMsiRecord piReturn = piNewDialog->WindowShow(fTrue);
				if(piReturn)
				{
					m_piEngine->Message(imtError, *piReturn);
					return iesFailure;
				}
				if(!RemoveDialog(iDialog))
				{
					return iesFailure;
				}
				piDialog = piNewDialog;
				iDialog = iNew;
			}
			break;
		case idreSpawn:
			{
				iNew = m_piDatabase->EncodeString(*strArg);
				Assert(iNew);
				iesRet = CreateNewDialog(iNew, iDialog, *&piNewDialog, fTrue, *strNull, *strNull, 0, fFalse, fFalse);
				if (iesRet != iesSuccess)
				{
					RemoveDialog(iDialog);
					return iesFailure;
				}

				PMsiRecord pActionStart = &m_piServices->CreateRecord(2);
				AssertNonZero(pActionStart->SetMsiString(1, *strArg));
				AssertNonZero(pActionStart->SetMsiString(2, *MsiString(*pcaDialogCreated)));
				if ( m_piEngine->Message(imtActionStart, *pActionStart) == imsCancel )
					return iesUserExit;

				SetInPlace(*piNewDialog, fTrue);
				PMsiRecord piReturn = piNewDialog->WindowShow(fTrue);
				if(piReturn)
				{
					m_piEngine->Message(imtError, *piReturn);
					return iesFailure;
				}
				PMsiRecord piHandleRecord = &m_piServices->CreateRecord(1);
				AssertRecord(piNewDialog->AttributeEx(fFalse, dabModal, *piHandleRecord));
				if ( piHandleRecord->GetInteger(1) )
				{
					//  the new dialog is modal => I drop its eventual minimize button.
					AssertRecord(piNewDialog->AttributeEx(fFalse, dabWindowHandle,
																	  *piHandleRecord));
					::ChangeWindowStyle((WindowRef)piHandleRecord->GetHandle(1),
											  WS_MINIMIZEBOX, 0, fFalse);
				}
				piDialog = piNewDialog;
				iDialog = iNew;
			}
			break;
		case idreExit:
			if(!RemoveDialog(iDialog))
			{
				return iesFailure;
			}
			if (GetParentDialog(iDialog))
			{
				PostError(Imsg(idbgExitButParent), *MsiString(*TEXT("Exit")));
				return iesFailure;
			}
			return iesUserExit; 
			break;
		case idreRetry:
			if(!RemoveDialog(iDialog))
			{
				return iesFailure;
			}
			if (GetParentDialog(iDialog))
			{
				PostError(Imsg(idbgExitButParent), *MsiString(*TEXT("Retry")));
				return iesFailure;
			}
			return iesSuspend; 
			break;
		case idreIgnore:
			if(!RemoveDialog(iDialog))
			{
				return iesFailure;
			}
			if (GetParentDialog(iDialog))
			{
				PostError(Imsg(idbgExitButParent), *MsiString(*TEXT("Ignore")));
				return iesFailure;
			}
			return iesSuccess; 
			break;
		case idreReturn:
			int iNew;
			if ((iNew = GetParentDialog(iDialog)) == 0)
			{
				if(!RemoveDialog(iDialog))
				{
					return iesFailure;
				}
				return iesSuccess;
			}
			else
			{
				piNewDialog = GetDialog(iNew);
				Assert(piNewDialog);
				if(!RemoveDialog(iDialog))
				{
					return iesFailure;
				}
				MsiString strNull;
				PMsiRecord piReturn = piNewDialog->PropertyChanged(*strNull, *strNull);
				if (!piReturn)
					piReturn = piNewDialog->WindowShow(fTrue);
				if(piReturn)
				{
					m_piEngine->Message(imtError, *piReturn);
					return iesFailure;
				}
				piDialog = piNewDialog;
				iDialog = iNew;
			}
			break;
		default:
			// Unknown event!!!
			Assert(fTrue);
			break;
		}
		AssertRecord(piDialog->AttributeEx(fFalse, dabModal, *pReturnRecord));
		if (icmdModeless != pReturnRecord->GetInteger(1)) // if modal
		{
			PMsiRecord piReturn = piDialog->Execute();
			if(piReturn)
			{
				if (piReturn->GetInteger(1) != idbgActionFailed) // assume that actions launched via the DoAction ControlEvent display their own errors
					m_piEngine->Message(imtError, *piReturn);
				return iesFailure;
			}
		}
		else // if modeless
		{
			return iesNoAction;
		}
	}
	// we should never reach this point, the following return is here just to please the compiler
	AssertSz(false, TEXT("We should never reach this point in CMsiHandler::RunWizard()"));
	return iesSuccess;
}

void CMsiHandler::SetInPlace(IMsiDialog& riDialog, Bool fInPlace)
{
	PMsiRecord piInPlaceRecord= &m_piServices->CreateRecord(1);
	AssertNonZero(piInPlaceRecord->SetInteger(1, fInPlace));
	AssertRecord(riDialog.AttributeEx(fTrue, dabInPlace, *piInPlaceRecord)); 
}


Bool CMsiHandler::DestroyDialogs()
{
	MsiStringId iDialog;
	
	while (m_piDialogsCursor->Next())
	{
		iDialog = m_piDialogsCursor->GetInteger(itabDSKey);
		m_piDialogsCursor->Reset();
		AssertNonZero(RemoveDialog(iDialog));
	}
	m_piDialogsCursor->Reset();
	return fTrue;
}


IMsiDialog* CMsiHandler::GetDialog(const IMsiString& riDialogString)
{
	if (!m_piEngine)
	{
		AssertSz(fFalse, "Uninitialized Handler Object");
		return 0;
	}
	return GetDialog(m_piDatabase->EncodeString(riDialogString));
}


IMsiDialog* CMsiHandler::GetDialog(MsiStringId iDialog)
{
	if ( iDialog == 0 )
		return 0;

	// Assert that the cursor is reset
	Assert(m_piDialogsCursor->GetInteger(itabDSKey) == 0);
	m_piDialogsCursor->SetFilter(iColumnBit(itabDSKey));
	m_piDialogsCursor->Reset();
	AssertNonZero(m_piDialogsCursor->PutInteger(itabDSKey, iDialog));
	if(m_piDialogsCursor->Next())
	{
		PMsiDialog piDialog = (IMsiDialog *)m_piDialogsCursor->GetMsiData(itabDSPointer);
		piDialog->AddRef();
		m_piDialogsCursor->SetFilter(0);
		m_piDialogsCursor->Reset();
		return piDialog;
	}
	
	m_piDialogsCursor->SetFilter(0);
	m_piDialogsCursor->Reset();
	return 0;
}

IMsiDialog* CMsiHandler::GetDialogFromWindow (LONG_PTR window)
{

	// Assert that the cursor is reset
	Assert(m_piDialogsCursor->GetInteger(itabDSKey) == 0);
	m_piDialogsCursor->SetFilter(iColumnBit(itabDSWindow));
	m_piDialogsCursor->Reset();
	AssertNonZero(PutHandleData(m_piDialogsCursor, itabDSWindow, window));
	if(m_piDialogsCursor->Next())
	{
		PMsiDialog piDialog = (IMsiDialog *)m_piDialogsCursor->GetMsiData(itabDSPointer);
		piDialog->AddRef();
		m_piDialogsCursor->SetFilter(0);
		m_piDialogsCursor->Reset();
		return piDialog;
	}

	m_piDialogsCursor->SetFilter(0);
	m_piDialogsCursor->Reset();
	return 0;

}

MsiStringId CMsiHandler::GetParentDialog(MsiStringId iDialog)
{
	// Assert that the cursor is reset
	Assert(m_piDialogsCursor->GetInteger(itabDSKey) == 0);
	m_piDialogsCursor->SetFilter(iColumnBit(itabDSKey));
	m_piDialogsCursor->Reset();
	AssertNonZero(m_piDialogsCursor->PutInteger(itabDSKey, iDialog));
	MsiStringId iReturn = 0;
	if(m_piDialogsCursor->Next())
	{
		iReturn = m_piDialogsCursor->GetInteger(itabDSParent);
	}
	m_piDialogsCursor->SetFilter(0);
	m_piDialogsCursor->Reset();
	return iReturn;
}


imsEnum CMsiHandler::ActionStart(imtEnum /*imt*/, IMsiRecord& /*riRec*/)
{
	return imsOk;
}

IMsiDialog* CMsiHandler::DialogCreate(const IMsiString& riTypeString)
{
	if (!m_piEngine)
	{
		AssertSz(fFalse, "Uninitialized Handler Object");
		return 0;
	}
	IMsiDialog* piDialog = CreateMsiDialog(riTypeString, *this, *m_piEngine, m_pwndParent);
	if (!piDialog)
	{
		PostError(Imsg(idbgDialogCreate));
		return 0;
	}
	return piDialog;
}

Bool CMsiHandler::AddDialogToDialogTable (IMsiDialog *piDialog, MsiStringId iParent)
{

	PMsiRecord piReturn(0);

	AssertSz(piDialog, "NULL Dialog passed to AddDialogToDialogTable");

	// save the name of the dialog
	PMsiRecord piNameRecord = &m_piServices->CreateRecord(1);
	piReturn = piDialog-> AttributeEx(fFalse, dabKeyString, *piNameRecord);
	if (piReturn)
		return (fFalse);

	m_pwindModelessCache = 0;
	// Assert that the cursor is reset
	Assert(m_piDialogsCursor->GetInteger(itabDSKey) == 0);
	//AssertNonZero(piDialogsCursor->PutString(itabDSKey, piNameRecord-> GetMsiString(1)));
	MsiString nameStr = piNameRecord-> GetMsiString (1);
	AssertNonZero(m_piDialogsCursor->PutString(itabDSKey, *nameStr));

	// add a pointer to the dialog
	AssertNonZero(m_piDialogsCursor->PutMsiData(itabDSPointer, piDialog));

	// save the index of it's parent
	AssertNonZero(m_piDialogsCursor->PutInteger(itabDSParent, iParent));

	// add a reference to the window handle
	PMsiRecord piPwndRecord = &m_piServices->CreateRecord(1);
	piReturn = piDialog-> AttributeEx(fFalse, dabWindowHandle, *piPwndRecord);
	if (piReturn)
	{
LError:
		m_piDialogsCursor->Reset();
		return (fFalse);
	}

	AssertNonZero(PutHandleData(m_piDialogsCursor, itabDSWindow, (UINT_PTR)piPwndRecord->GetHandle(1)));
	piReturn = piDialog-> AttributeEx(fFalse, dabModal, *piPwndRecord);
	if (piReturn)
		goto LError;
		
	AssertNonZero(m_piDialogsCursor->PutInteger(itabDSModal, piPwndRecord->GetInteger(1)));
	AssertNonZero(m_piDialogsCursor->Insert());

	m_piDialogsCursor->Reset();
	return (fTrue);
}

Bool CMsiHandler::AddDialog(IMsiDialog& riDialog, IMsiDialog* piParent, IMsiRecord& riRecord,IMsiTable* piControlEventTable,
		IMsiTable* piControlConditionTable, IMsiTable* piEventMappingTable)
{
	if (!m_piEngine)
	{
		AssertSz(fFalse, "Uninitialized Handler Object");
		return fFalse;
	}
	MsiString strName = riRecord.GetMsiString(itabDIName);
	// Assert that the cursor is reset
	Assert(m_piDialogsCursor->GetInteger(itabDSKey) == 0);
	AssertNonZero(m_piDialogsCursor->PutString(itabDSKey, *strName));
	m_piDialogsCursor->Reset();
	PMsiRecord piReturn = riDialog.WindowCreate(riRecord, piParent, 
		piControlEventTable ? piControlEventTable : (IMsiTable*) m_piControlEventTable, 
		piControlConditionTable ? piControlConditionTable : (IMsiTable*) m_piControlConditionTable, 
		piEventMappingTable ? piEventMappingTable : (IMsiTable*) m_piEventMappingTable);
	
	if (piReturn)
	{
		m_piEngine->Message(imtError, *piReturn);
		return fFalse;
	}

	Bool fResult = AddDialogToDialogTable (&riDialog, piParent ? piParent->GetIntegerValue () : 0);
	if (!fResult)
	{
		PostError(Imsg(idbgCreateDialog), *MsiString(riRecord.GetMsiString (itabDIName)));
		riDialog.RemoveWindow ();
	}

	return (fResult);
}

iesEnum CMsiHandler::CreateNewDialog(MsiStringId iName, MsiStringId iParent, IMsiDialog*& rpiDialog, Bool fMustFind, 
									 const IMsiString& riErrorTextString, const IMsiString& riListString, int iDefault, 
									 Bool fFirst, Bool fPreview)
{

	PMsiDialog piDialog(0);

	Assert(iName);
	Bool fErrorDialog = ToBool(riErrorTextString.TextSize());
	// Assert that the cursor is reset
	Assert(m_piDialogsCursor->GetInteger(itabDSKey) == 0);
	m_piDialogsCursor->SetFilter(iColumnBit(itabDSKey));
	AssertNonZero(m_piDialogsCursor->PutInteger(itabDSKey, iName));
	if (m_piDialogsCursor->Next())                          // check if there is already a dialog by the same name
	{
		m_piDialogsCursor->SetFilter(0);
		m_piDialogsCursor->Reset();
		PostError(Imsg(idbgSecondDialog), *MsiString(m_piDatabase->DecodeString(iName)));
		return iesFailure;
	}
	m_piDialogsCursor->SetFilter(0);
	m_piDialogsCursor->Reset();
	
	PMsiRecord piErrorRecord(0);
	PMsiRecord piQuery = &m_piServices->CreateRecord(1);
	MsiString strDialogName = m_piDatabase->DecodeString(iName);
	AssertNonZero(piQuery->SetMsiString(1, *strDialogName));
	piErrorRecord = m_piDialogView->Execute(piQuery);
	if (piErrorRecord)
	{
		PostError(*piErrorRecord);
		return iesFailure;
	}
	
	PMsiRecord piRecordNewProperties = m_piDialogView->Fetch();
	
	if (piRecordNewProperties)
	{
		int iStyle = piRecordNewProperties->GetInteger (itabDIAttributes);
		if (fFirst && !m_fShowWizards && (iStyle & msidbDialogAttributesModal)) // this is the first modal dialog in a wizard sequence, but we are not showing them
		{
			return iesNoAction;
		}
		AssertNonZero(m_piDialogsCursor->PutInteger(itabDSKey, iName));
		m_piDialogsCursor->Reset();
		
		MsiString styleStr = pcaDialogTypeStandard;
		if (fErrorDialog && !(iStyle & msidbDialogAttributesError))
		{
			PMsiRecord piErrorRecord = &m_piServices->CreateRecord(2);
			ISetErrorCode(piErrorRecord, Imsg(idbgErrorNoStyle));
			AssertNonZero(piErrorRecord->SetMsiString(2, *strDialogName));
			m_piEngine->Message(imtError, *piErrorRecord);
			return iesFailure;
		}
		if (!fErrorDialog && (iStyle & msidbDialogAttributesError) && !m_fPreview)
		{
			PMsiRecord piErrorRecord = &m_piServices->CreateRecord(2);
			ISetErrorCode(piErrorRecord, Imsg(idbgStyleNoError));
			AssertNonZero(piErrorRecord->SetMsiString(2, *strDialogName));
			m_piEngine->Message(imtError, *piErrorRecord);
			return iesFailure;
		}
		if (fErrorDialog)
		{
			// setting the default button
			Assert(riListString.TextSize() >= iDefault && iDefault > 0);
			riListString.AddRef();
			MsiString strDefaultButton(riListString);
			strDefaultButton.Remove(iseFirst, iDefault - 1);
			strDefaultButton.Remove(iseLast, strDefaultButton.CharacterCount() - 1);
			AssertNonZero(piRecordNewProperties->SetMsiString(itabDIDefButton, *strDefaultButton));
			AssertNonZero(piRecordNewProperties->SetMsiString(itabDIFirstControl, *strDefaultButton));
			// setting the cancel button
			MsiString strCancelButton;
			const MsiString strC(*TEXT("C"));
			const MsiString strO(*TEXT("O"));
			if ( IStrChr(riListString.GetString(), TEXT('C')) )
				strCancelButton = strC;
			else if ( !IStrComp(riListString.GetString(), TEXT("O")) )
				strCancelButton = strO;
			AssertNonZero(piRecordNewProperties->SetMsiString(itabDICancelButton, *strCancelButton));
		}

		piDialog = DialogCreate(*styleStr);
		if (!piDialog)
		{
			return iesFailure;
		}
		PMsiDialog piParent(0);
		if (iParent)
		{
			piParent = GetDialog(iParent);
		}
		PMsiRecord piReturn = piDialog->WindowCreate(*piRecordNewProperties, piParent, 
			fPreview ? (IMsiTable*) 0 : m_piControlEventTable, 
			m_piControlConditionTable, 
			fPreview ? (IMsiTable*) 0 : m_piEventMappingTable);
		if(piReturn)
		{
			m_piEngine->Message(imtError, *piReturn);
			return iesFailure;
		}

		if (!AddDialogToDialogTable (piDialog, iParent))
		{
			PostError(Imsg(idbgCreateDialog), *MsiString(m_piDatabase->DecodeString(iName)));
			piDialog->RemoveWindow();
			return iesFailure;
		}
	}
	else  //Fetch didn't find this dialog in the table
	{
		if (fMustFind)
		{
			PostError(Imsg(idbgFetchDialogViewFailed), *MsiString(m_piDatabase->DecodeString(iName)));
			return iesFailure;
		}
		else
		{
			return iesNoAction;
		}
	}   
	if (CreateControls(piDialog, riListString))
	{
		piDialog->AddRef(); // for the returned pointer
		rpiDialog = piDialog;
	}
	else
	{
		RemoveDialog(piDialog);
		return iesFailure;
	}
	if (fErrorDialog)
	{
		PMsiControl piTextControl(0);
		PMsiRecord(piDialog->GetControl(*MsiString(*pcaErrorText), *&piTextControl));
		if (!piTextControl)
		{
			PMsiRecord piErrorRecord = &m_piServices->CreateRecord(1);
			ISetErrorCode(piErrorRecord, Imsg(idbgNoTextOnError));
			m_piEngine->Message(imtError, *piErrorRecord);
			RemoveDialog(piDialog);
			return iesFailure;
		}
		PMsiRecord piTextRecord = &m_piServices->CreateRecord(1);
		AssertNonZero(piTextRecord->SetMsiString(1, riErrorTextString));
		AssertRecord(piTextControl->AttributeEx(fTrue,  cabErrorString, *piTextRecord));
	}
	return iesSuccess;
}

Bool CMsiHandler::RemoveDialog(IMsiDialog* piDialog)
{
	if (!m_piEngine)
	{
		AssertSz(fFalse, "Uninitialized Handler Object");
		return fFalse;
	}
	if (!piDialog)
	{
		return fFalse;
	}
	return RemoveDialog(piDialog->GetIntegerValue());
}

Bool CMsiHandler::RemoveDialog(MsiStringId iDialog)
{
#ifdef DEBUG
	MsiString strDebug = m_piDatabase->DecodeString(iDialog);
#endif //DEBUG
	
	// Assert that the cursor is reset
	Assert(m_piDialogsCursor->GetInteger(itabDSKey) == 0);
	m_piDialogsCursor->SetFilter(iColumnBit(itabDSKey));
	m_piDialogsCursor->Reset();
	m_pwindModelessCache = 0;
	AssertNonZero(m_piDialogsCursor->PutInteger(itabDSKey, iDialog));
	if (m_piDialogsCursor->Next())    //make sure that the dialog is found in the table
	{
		PMsiDialog piDialog = (IMsiDialog *)m_piDialogsCursor->GetMsiData(itabDSPointer);
		if (m_piDialogsCursor->GetInteger(itabDSParent) == 0)
		{
			PMsiRecord piOldPositionRecord= &m_piServices->CreateRecord(4);
			AssertRecord(piDialog->AttributeEx(fFalse, dabPosition, *piOldPositionRecord));         // get the position of the old dialog
			if (piOldPositionRecord->GetInteger(1) < 0XFFFF0000)
				m_pDialogPositionRec = piOldPositionRecord;
		}
		PMsiRecord piAddingControlsRecord = &m_piServices->CreateRecord(1);
		AssertNonZero(piAddingControlsRecord->SetInteger(1, fFalse));
		AssertRecord(piDialog->AttributeEx(fTrue, dabAddingControls, *piAddingControlsRecord));
		AssertRecord(piDialog->WindowShow(fFalse));
		AssertRecord(piDialog->DestroyControls());

		// We want to remove the dialog window, even though the
		// dialog object itself might still be alive due to 
		// outstanding refcounted pointers.
		PMsiRecord piRecord = piDialog->RemoveWindow();
		AssertNonZero(m_piDialogsCursor->Delete());
		m_piDialogsCursor->SetFilter(0);
		m_piDialogsCursor->Reset();
		if (m_piDialogsTable->GetRowCount() == 0 && m_iRefCnt == 0)
			delete this;
		return fTrue;
	}

	m_piDialogsCursor->SetFilter(0);
	m_piDialogsCursor->Reset();     
	return fFalse;
}

Bool CMsiHandler::PublishEventSz(const ICHAR* szEventString, IMsiRecord& riArgument)
{
	MsiStringId idEvent = m_piDatabase->EncodeStringSz(szEventString);

	// This event is not subscribed to
	if (idEvent == 0)
		return fTrue;
		
	return PublishEvent(idEvent, riArgument);
}

Bool CMsiHandler::PublishEvent(MsiStringId idEventString, IMsiRecord& riArgument)
{
	// Assert that the cursor is reset
	Assert(m_piDialogsCursor->GetInteger(itabDSKey) == 0);
	PMsiDialog piDialog(0);
	PMsiRecord piReturn(0);
	while (m_piDialogsCursor->Next())
	{
		piDialog = (IMsiDialog *)m_piDialogsCursor->GetMsiData(itabDSPointer);
		piReturn = piDialog->PublishEvent(idEventString, riArgument);
		if (piReturn)
		{
			m_piDialogsCursor->Reset();
			m_piEngine->Message(imtError, *piReturn);
			return fFalse;
		}       
	}

	m_piDialogsCursor->Reset();
	return fTrue;
}

Bool CMsiHandler::EventActionSz(const ICHAR * szEventString, const IMsiString& riActionString)
{
	MsiStringId idEvent = m_piDatabase->EncodeStringSz(szEventString);

	// No one handles this event
	if (idEvent == 0)
		return fTrue;

	return EventAction(idEvent, riActionString);
}

Bool CMsiHandler::EventAction(MsiStringId idEvent, const IMsiString& riActionString)
{
	// Assert that the cursor is reset
	Assert(m_piDialogsCursor->GetInteger(itabDSKey) == 0);
	m_piDialogsCursor->SetFilter(0);
	m_piDialogsCursor->Reset();
	PMsiDialog piDialog(0);
	PMsiRecord piReturn(0);
	while (m_piDialogsCursor->Next())
	{
		piDialog = (IMsiDialog *)m_piDialogsCursor->GetMsiData(itabDSPointer);
		piReturn = piDialog->EventAction(idEvent, riActionString);
		if (piReturn)
		{
			m_piEngine->Message(imtError, *piReturn);
			m_piDialogsCursor->Reset();
			return fFalse;
		}
	}
	m_piDialogsCursor->Reset();
	return fTrue;
}

Bool CMsiHandler::CreateControls(IMsiDialog* piDialog, const IMsiString& riListString)
{
	Bool fErrorDialog = ToBool(riListString.TextSize());
	PMsiRecord piErrorRecord(0);
	PMsiView piControlView(0);
	piErrorRecord = m_piDatabase->OpenView(sqlControl, ivcFetch, *&piControlView);
	if (piErrorRecord)
	{
		PostError(*piErrorRecord);
		return fFalse;
	}
	PMsiRecord piQuery = &m_piServices->CreateRecord(1);
	AssertNonZero(piQuery->SetMsiString(1, *MsiString(piDialog->GetMsiStringValue())));
	piErrorRecord = piControlView->Execute(piQuery);
	if (piErrorRecord)
	{
		PostError(*piErrorRecord);
		return fFalse;
	}
	PMsiRecord piRecordNew(0);
	PMsiControl piControl(0);
	PMsiRecord piReturn(0);
	
	while (piRecordNew = piControlView->Fetch())
	{
		if (fErrorDialog)
		{
			MsiString strControlName = piRecordNew->GetMsiString(itabCOControl);
			if (MsiString(piRecordNew->GetMsiString(itabCOType)).Compare(iscExact, MsiString(pcaControlTypePushButton)) && !riListString.Compare(iscWithinI, strControlName)) // button is not in the list, skip it
				continue;
		}
		piControl = piDialog->ControlCreate(*MsiString(piRecordNew->GetMsiString(itabCOType)));
		if (!piControl)
		{
			PostError(Imsg(idbgControlCreate), *MsiString(piDialog->GetMsiStringValue()), *MsiString(piRecordNew->GetMsiString(itabCOControl)));
			return fFalse;
		}
		
		piReturn = piDialog->AddControl(piControl, *piRecordNew);
		if (piReturn)
		{
			m_piEngine->Message(imtError, *piReturn);
			return fFalse;
		}

	}
	PMsiRecord piNull = &m_piServices->CreateRecord(0);
	piReturn = piDialog->FinishCreate();
	if (piReturn)  // signal the dialog, that we are done with adding controls
	{
		m_piEngine->Message(imtError, *piReturn);
		return fFalse;
	}
	if (fErrorDialog)
		return RearrangeControls(piDialog, riListString);
	else
		return fTrue;
}

Bool CMsiHandler::RearrangeControls(IMsiDialog* piDialog, const IMsiString& riListString)
{
	riListString.AddRef();
	MsiString strWorkList = riListString;
	int cButtons = strWorkList.TextSize();
	PMsiRecord piPositionRecord = &m_piServices->CreateRecord(4);
	PMsiRecord(piDialog->AttributeEx(fFalse, dabPosition, *piPositionRecord));
	int iWidth = piPositionRecord->GetInteger(3);
	PMsiControl piControl(0);
	MsiString strCode;
	ICHAR szCode[2];
	while (strWorkList.TextSize())
	{
		strCode = strWorkList.Extract(iseFirst, 1);
		strCode.CopyToBuf(szCode, 2);
		strWorkList.Remove(iseFirst, 1);
		IStrUpper(szCode);
		strCode = szCode;
		PMsiRecord(piDialog->GetControl(*strCode, *&piControl));
		if (!piControl)
			return fFalse;
		PMsiRecord(piControl->AttributeEx(fFalse, cabPosition, *piPositionRecord));
		iWidth -= piPositionRecord->GetInteger(3);
	}
	riListString.AddRef();
	strWorkList = riListString;
	int iGap = iWidth/(cButtons + 1);
	int iPos = iGap;
	WindowRef pWindow;
	WindowRef pPrevWindow = HWND_TOP;
	while (strWorkList.TextSize())
	{
		strCode = strWorkList.Extract(iseFirst, 1);
		strCode.CopyToBuf(szCode, 2);
		strWorkList.Remove(iseFirst, 1);
		IStrUpper(szCode);
		strCode = szCode;
		PMsiRecord(piDialog->GetControl(*strCode, *&piControl));
		if (!piControl)
			return fFalse;
		PMsiRecord(piControl->AttributeEx(fFalse, cabPosition, *piPositionRecord));
		AssertNonZero(piPositionRecord->SetInteger(1, iPos));
		PMsiRecord(piControl->AttributeEx(fTrue, cabPosition, *piPositionRecord));
		iPos += piPositionRecord->GetInteger(3) + iGap;
		// rearrange the Z-order, so the tabbing works right
		PMsiRecord(piControl->AttributeEx(fFalse, cabWindowHandle, *piPositionRecord));
		pWindow = (WindowRef)piPositionRecord->GetHandle(1);
		AssertNonZero(WIN::SetWindowPos(pWindow, pPrevWindow, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE));
		pPrevWindow = pWindow;
	}
	return fTrue;
}

void CMsiHandler::ClearMessageQueue()
{
	// Clear the message pump
	WindowRef pWndModeless = FindModeless();
	MSG msg;
	while (WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
	{
		if (!pWndModeless || ::IsSpecialMessage(&msg) || !WIN::IsDialogMessage(pWndModeless, &msg))
		{
			WIN::TranslateMessage(&msg);
			WIN::DispatchMessage(&msg);
		}
	}
}

WindowRef CMsiHandler::FindModeless()
{
	PMsiDialog piDialog(0);
	// Assert that the cursor is reset
	Assert(m_piDialogsCursor->GetInteger(itabDSKey) == 0);

	if (m_pwindModelessCache != 0)
	{
#ifdef DEBUG
		WindowRef pwindCur = m_pwindModelessCache;
		m_pwindModelessCache = 0;
		Assert(pwindCur == FindModeless());
		return pwindCur;
#else
		return m_pwindModelessCache;
#endif //DEBUG
	}
	else
	{       
		while (m_piDialogsCursor->Next())
		{
			WindowRef pwind;
			
			piDialog = (IMsiDialog *)m_piDialogsCursor->GetMsiData(itabDSPointer);
			if (icmdModeless == m_piDialogsCursor->GetInteger(itabDSModal))
			{
				pwind = (WindowRef) GetHandleData(m_piDialogsCursor, itabDSWindow); // there can be only one modeless dialog    
				m_piDialogsCursor->Reset();
				m_pwindModelessCache = pwind;
				return pwind;
			}
		}
	}
	m_piDialogsCursor->Reset();
	return 0; // we did not find any modeless dialogs
}

bool CMsiHandler::FindModeless(IMsiDialog*& rpiDialog)
{
	bool fReturn = false;

	rpiDialog = 0;
	// Assert that the cursor is reset
	Assert(m_piDialogsCursor->GetInteger(itabDSKey) == 0);
	while (m_piDialogsCursor->Next())
	{
		if (icmdModeless == m_piDialogsCursor->GetInteger(itabDSModal))
		{
			rpiDialog = (IMsiDialog *)m_piDialogsCursor->GetMsiData(itabDSPointer);
			fReturn = true;
			break;
		}
	}
	m_piDialogsCursor->Reset();

	return fReturn;
}

imsEnum CMsiHandler::PostError(IMsiRecord& riRecord)
{
	return m_piEngine->Message(imtError, riRecord);
}

imsEnum CMsiHandler::PostError(IErrorCode iErr, const IMsiString& riString1, const IMsiString& riString2, const IMsiString& riString3, const IMsiString& riString4, const IMsiString& riString5)
{
	PMsiRecord piRec = &m_piServices->CreateRecord(6);
	ISetErrorCode(piRec, iErr);
	if (&riString1)
		AssertNonZero(piRec->SetMsiString(2, riString1));
	if (&riString2)
		AssertNonZero(piRec->SetMsiString(3, riString2));
	if (&riString3)
		AssertNonZero(piRec->SetMsiString(4, riString3));
	if (&riString4)
		AssertNonZero(piRec->SetMsiString(5, riString4));
	if (&riString5)
		AssertNonZero(piRec->SetMsiString(6, riString5));
	return m_piEngine->Message(imtError, *piRec);
}

Bool CMsiHandler::CreateTextStyleTab()
{
	if (PMsiRecord(m_piDatabase->CreateTable(*MsiString(m_piDatabase->CreateTempTableName()), 0, *&m_piTextStyleTable)))
	{
		PostError(Imsg(idbgTableCreate), *MsiString(*pcaTablePTextStyle));
		return fFalse;
	}
	AssertNonZero(m_piTextStyleTable->CreateColumn(icdString + icdPrimaryKey + icdTemporary, *MsiString(szColTextStyleTextStyle)) == itabTSTTextStyle);
	AssertNonZero(m_piTextStyleTable->CreateColumn(icdString + icdTemporary, *MsiString(szColTextStyleFaceName)) == itabTSTFaceName);
	AssertNonZero(m_piTextStyleTable->CreateColumn(icdLong + icdNoNulls + icdTemporary, *MsiString(szColTextStyleSize)) == itabTSTSize);
	AssertNonZero(m_piTextStyleTable->CreateColumn(icdString + icdTemporary, *MsiString(szColTextStyleColor)) == itabTSTColor);
	AssertNonZero(m_piTextStyleTable->CreateColumn(icdLong + icdTemporary, *MsiString(szColTextStyleStyleBits)) == itabTSTStyleBits);
	return fTrue;
}


IMsiRecord* CMsiHandler::GetTextStyle(const IMsiString* piArgumentString)
{
	Assert(piArgumentString);
	if (m_piTextStyleView == 0)
	{
		Ensure(m_piDatabase->OpenView(sqlTextStyle, ivcFetch, *&m_piTextStyleView));
	}
	PMsiRecord piQuery = &m_piServices->CreateRecord(1);
	AssertNonZero(piQuery->SetMsiString(1, *piArgumentString));
	Ensure(m_piTextStyleView->Execute(piQuery));
	IMsiRecord* pRecord;
	
	pRecord = m_piTextStyleView->Fetch();
	m_piTextStyleView->Close();
	return pRecord;

}


idreEnum CMsiHandler::DoModalDialog(MsiStringId iName, MsiStringId iParent)
{
	PMsiRecord      pReturn(0);
	PMsiDialog      pDialog(0);

	MsiString strNull;
	iesEnum iRet = CreateNewDialog(iName, iParent, *&pDialog, fTrue, *strNull, *strNull, 0, fFalse, fFalse);
	if (iesSuccess != iRet)
		return idreError;
	SetInPlace(*pDialog, fTrue);
	pReturn = pDialog->WindowShow(fTrue);
	PMsiDialog pParent = GetDialog(iParent);
	if ( pReturn || !pParent )
	{
		Assert(false);
		return idreError;
	}

	//  disabling parent window
	PMsiRecord pRecord = &m_piServices->CreateRecord(1);
	AssertRecord(pParent->AttributeEx(fFalse, dabWindowHandle, *pRecord));
	WindowRef pParentWnd = (WindowRef)pRecord->GetHandle(1);
	Assert(pParentWnd);
	BOOL fPrevState = IsWindowEnabled(pParentWnd);
	WIN::EnableWindow(pParentWnd, FALSE);
	//  dropping the modal pDialog's eventual minimize button.
	AssertRecord(pDialog->AttributeEx(fFalse, dabWindowHandle, *pRecord));
	::ChangeWindowStyle((WindowRef)pRecord->GetHandle(1),
							  WS_MINIMIZEBOX, 0, fFalse);

	pReturn = pDialog->Execute();

	//  restoring the state of parent window
	WIN::EnableWindow(pParentWnd, fPrevState);

	AssertRecord(pDialog->AttributeEx(fFalse, dabEventInt, *pRecord)); 
	idreEnum idreCode = (idreEnum)pRecord->GetInteger(1);

	RemoveDialog (pDialog);

	return pReturn ? idreError : idreCode;
}


int CMsiHandler::ShowWaitCursor()
{
	HCURSOR hCurs;

	if (m_cWait == 0)
	{
		AssertSz(m_hCursOld == 0, "Cursor cache not cleared");
		m_hCursOld = GetCursor();
		hCurs = LoadCursor(0, MAKEINTRESOURCE(IDC_WAIT));
		m_hCursCur = hCurs;
		if (hCurs == 0)
		{
			AssertSz(fFalse, "Could not load wait cursor");
			return 0;
		}
		SetCursor(hCurs);
		::ShowCursor(TRUE);
	}

	m_cWait++;
	return m_cWait;
}


int     CMsiHandler::RemoveWaitCursor()
{

	if (m_cWait <= 0)
	{
		AssertSz(fFalse, "RemoveWaitCursor called more than ShowWaitCursor");
		return 0;
	}

	m_cWait--;

	if (m_cWait == 0)
	{
		SetCursor(m_hCursOld);
		m_hCursCur = m_hCursOld;
		m_hCursOld = 0;
	}

	return m_cWait;

}

//
// returns false if we're just setting the arrow cursor
//
bool CMsiHandler::FSetCurrentCursor()
{

	if (m_cWait)
	{
		SetCursor(m_hCursCur);
		return true;
	}

	return false;

}

//  Exposes the handler's internal GetTopDialog functionality to grab
//  the current top window
HWND CMsiHandler::GetTopWindow()
{       
	PMsiDialog pDialog(0);
	if (!GetTopDialog(&pDialog))
		return m_pwndParent;

	PMsiRecord piHandleRecord = &m_piServices->CreateRecord(1);
	AssertRecord(pDialog->AttributeEx(fFalse, dabWindowHandle, *piHandleRecord));
	return (HWND)piHandleRecord->GetHandle(1);
}

bool CMsiHandler::SetUIScaling()
{
	bool fError = false;
	int iOurFontHeight = GetDBPropertyInt(*MsiString(*IPROPNAME_TEXTHEIGHT));
	int iMessageFontHeight = 0;
	NONCLIENTMETRICS ncm;
	memset(&ncm, 0, sizeof(NONCLIENTMETRICS));
	ncm.cbSize = sizeof(NONCLIENTMETRICS);

	m_rUIScalingFactor = 1.;
	if ( WIN::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0) )
	{
		HFONT hFont = WIN::CreateFontIndirect(&ncm.lfMessageFont);
		HDC hDC = WIN::GetDC(NULL);
		if ( hDC && hFont )
		{
			HFONT hOldFont = (HFONT)WIN::SelectObject(hDC, hFont);
			TEXTMETRIC tm;
			memset(&tm, 0, sizeof(TEXTMETRIC));
			WIN::GetTextMetrics(hDC, &tm);
			iMessageFontHeight = tm.tmHeight;
			WIN::SelectObject(hDC, hOldFont);
		}
		else
		{
			Assert(false);
			fError = true;
		}
		if ( hFont )
			WIN::DeleteObject(hFont);
		if ( hDC )
			WIN::ReleaseDC(NULL, hDC);

	}
	else
	{
		Assert(false);
		fError = true;
	}
	CTempBuffer<ICHAR, 20> rgchProperty;
	*rgchProperty = NULL;
	if ( iMessageFontHeight )
	{
		float rRatio = (float)iMessageFontHeight / iOurFontHeight;
		float rCorrection = rRatio / US_DISPLAY_STANDARD_RATIO;
		if ( rRatio < 0 || rCorrection < 0 ||
			  rCorrection >= 10. || rCorrection <= .1 )
		{
			// we've screwed this up somehow
			Assert(false);
			fError = true;
		}
		else
		{
			float rStandard = US_DISPLAY_STANDARD_RATIO;  // easier to debug
			int iDelta = NEGLIGIBLE_FONT_SIZE_DEVIATION;  // easier to debug
			if ( rRatio > rStandard * (1.+(float)iDelta/100) ||
				  rRatio < rStandard * (1.-(float)iDelta/100) )
			{
				// isn't it nice that StringCchPrintf doesn't handle %f?
				int uUnits = Round(rCorrection);
				if ( rCorrection < Round(rCorrection) )
					uUnits--;
				double rRemainder = rCorrection - uUnits;
				// four decimals will suffice for debugging
				StringCchPrintf(rgchProperty, rgchProperty.GetSize(),  TEXT("%d.%d"), uUnits, int(10000 * rRemainder));
				m_rUIScalingFactor = rCorrection;
			}
		}
	}
	SetDBProperty(*MsiString(*IPROPNAME_TEXTHEIGHT_CORRECTION),
					  *MsiString((ICHAR*)rgchProperty));
	return !fError;
}

// global function to format disk size into string
const IMsiString& FormatSize(INT64 iSize, Bool fLeftUnit)
{
	MsiString strTemp;
	if (iSize < 0)
	{
		strTemp += MsiString(*TEXT("-"));
		iSize *= -1;
	}
	if (iSize == 1)
	{
		strTemp += fLeftUnit ? MsiString(MsiString(::GetUIText(*MsiString(*pcaBytes))) + MsiString(TEXT("512"))) : MsiString(MsiString(*TEXT("512")) + MsiString(::GetUIText(*MsiString(*pcaBytes))));
	}
	else 
	{
		// iSize comes in in multiples of 512
		// let's convert it to KBs
		iSize /= 2;
		if (iSize < 1024 * 10)
		{
			strTemp += fLeftUnit ? MsiString(MsiString(::GetUIText(*MsiString(*pcaKB))) + MsiString(MsiString((int)iSize))) : MsiString(MsiString((int)iSize) + MsiString(::GetUIText(*MsiString(*pcaKB))));
		}
		else
		{
			//!! FUTURE: we'll need to handle TB (terrabyte) - and above - as well
			iSize /= 1024;
			if (iSize < 1024 * 10)
			{
				strTemp += fLeftUnit ? MsiString(MsiString(::GetUIText(*MsiString(*pcaMB))) + MsiString(MsiString((int)iSize))) : MsiString(MsiString((int)iSize) + MsiString(::GetUIText(*MsiString(*pcaMB))));
			}
			else
			{
				iSize /= 1024;
				strTemp += fLeftUnit ? MsiString(MsiString(::GetUIText(*MsiString(*pcaGB))) + MsiString(MsiString((int)iSize))) : MsiString(MsiString((int)iSize) + MsiString(::GetUIText(*MsiString(*pcaGB))));
			}
		}
	}
	const IMsiString& strRet = *strTemp;
	strRet.AddRef(); 
	return strRet;
}


/* global function to create a column in a temporary table */

void CreateTemporaryColumn(IMsiTable& rpiTable, int iAttributes, int iIndex)
{
	MsiString strNull;
	AssertNonZero(rpiTable.CreateColumn(iAttributes + icdTemporary, *strNull) == iIndex);
}

/* global function used by the dialogs and controls to create a cursor */

IMsiRecord* CursorCreate(IMsiTable& riTable, const ICHAR* szTable, Bool fTree, IMsiServices& riServices, IMsiCursor*& riCursor)
{
	riCursor = riTable.CreateCursor(fTree);
	if (!riCursor)
	{
		riCursor = 0;
		IMsiRecord* piRec = &riServices.CreateRecord(2);
		ISetErrorCode(piRec, Imsg(idbgCursorCreate));
		AssertNonZero(piRec->SetString(2, szTable));
		return piRec;
	}
	return 0;
}

/* global function used by controls to access the UIText table */

const IMsiString& GetUIText(const IMsiString& riPropertyString)
{
	MsiString strStr;
	if (g_piUITextCursor)
	{
		g_piUITextCursor->Reset();
		g_piUITextCursor->SetFilter(iColumnBit(itabUIKey));
		AssertNonZero(g_piUITextCursor->PutString(itabUIKey, riPropertyString));
		if (g_piUITextCursor->Next())
		{
			strStr = g_piUITextCursor->GetString(itabUIText);
		}
		else
		{
			strStr = MsiString(*TEXT("!!"));
			strStr += riPropertyString;
			strStr += MsiString(*TEXT(" is missing from the UIText Table!!"));
		}
	}
	else
	{
		strStr = MsiString(*TEXT("!!UIText Table Missing!!"));
	}
	return strStr.Return();
}

int GetVolumeIconIndex(IMsiVolume& riVolume)
{
	return GetVolumeIconIndex(riVolume.DriveType());
}

int GetVolumeIconIndex(idtEnum iDriveType)
{
	switch (iDriveType)
	{
	case idtRemovable:
		return g_iIconIndexRemovable;
	case idtFixed:
		return g_iIconIndexFixed;
	case idtRemote:
		return g_iIconIndexRemote;
	case idtCDROM:
		return g_iIconIndexCDROM;
	case idtRAMDisk:
		return g_iIconIndexFixed;  // temp until we get an icon for RAMDisk
	default:
		AssertSz(fFalse, "Unknown volume type");
		return g_iIconIndexMyComputer;
	}
}

const IMsiString& EscapeAll(const IMsiString& riIn)
// Escapes every character in the string
{
	MsiString strOut;
	riIn.AddRef();
	MsiString str(riIn);
	while (str.TextSize())
	{
		strOut += MsiString(*TEXT("[\\"));
		strOut += MsiString(str.Extract(iseFirst, 1));
		AssertNonZero(str.Remove(iseFirst, 1));
		strOut += MsiString(*TEXT("]"));
	}
	return strOut.Return();
}

boolean FExtractSubString(MsiString& riIn, int ichStart, const ICHAR ch, const IMsiString*& rpiReturn)
{
	MsiString strRet;
	const ICHAR *pchStart = ((const ICHAR *)riIn) + ichStart;
	const ICHAR *pch;
	INT_PTR cch = 0, ich = -1;                              //--merced: changed from int to INT_PTR
	
	pch = pchStart;
	while (*pch)
	{
		if (*pch == ch)
		{
			ich = pch - pchStart;
			break;
		}
		pch = INextChar(pch);
		cch++;
	}
	if (ich == -1)
		return false;
		
	memcpy(strRet.AllocateString((unsigned int)ich, ToBool(ich != cch)), pchStart, (unsigned int)ich * sizeof(ICHAR));              //--merced: added typecast.

	strRet.ReturnArg(rpiReturn);
	
	return true;
}

// rounds rArg to int
int Round(double rArg)
{
	int iSign = 1;
	if ( rArg < 0 )
	{
		iSign = -1;
		rArg = -rArg;
	}

	if ( rArg - int(rArg) < 0.5f )
		return iSign * int(rArg);
	else
		return iSign * (int(rArg) + 1);
}

//____________________________________________________________________________
//
// IMsiDebug implementation
//____________________________________________________________________________

#ifdef DEBUG
void CMsiHandler::SetAssertFlag(Bool fShowAsserts)
{
	g_fNoAsserts = fShowAsserts;
}

void CMsiHandler::SetDBCSSimulation(char /*chLeadByte*/)
{
}

Bool CMsiHandler::WriteLog(const ICHAR* )
{
	return fFalse;
}

void CMsiHandler::AssertNoObjects()
{
}

void  CMsiHandler::SetRefTracking(long /* iid */, Bool /* fTrack */)
{
}


#endif //DEBUG

#ifdef _X86_
#ifndef DEBUG
//
// So we don't need this from the c-runtimes
// Should never be called.
int __cdecl _purecall(
	void
	)
{
	return 0;
}
#endif //DEBUG
#endif

// 
// Searches the buffer for the string id
boolean FInBuffer(CTempBufferRef<MsiStringId>& rgControls, MsiStringId idString)
{

	int i = rgControls.GetSize();

	while (i > 0)
	{
		if (rgControls[--i] == idString)
			return true;
	}

	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\_handler.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       _handler.h
//
//--------------------------------------------------------------------------

#ifndef __HANDLER_SHARED
#define __HANDLER_SHARED

#include "handler.h"
#include "_assert.h"
#include <stdlib.h>
#include <commctrl.h>
#include <richedit.h>

#define Ensure(function) {	\
						IMsiRecord* piEnsureReturn = function;	\
						if (piEnsureReturn) \
							return piEnsureReturn; \
						}

typedef int ControlType; 
typedef HWND WindowRef;

#define WM_USERBREAK (WM_USER + 96)
#define WM_SETDEFAULTPUSHBUTTON    WM_APP
#define EDIT_DEFAULT_TEXT_LIMIT    512

const int g_iSelOrigSIconX = 16;
const int g_iSelOrigSIconY = 16;
const int g_iSelSelMIconX = 32;
const int g_iSelSelMIconY = 32;
const int g_iSelSelSIconX = 16;
const int g_iSelSelSIconY = 16;
const int g_iSelIconX = 32;
const int g_iSelIconY = 16;


extern HINSTANCE        g_hInstance;     // Global:  Instance of DLL
extern ICHAR            MsiDialogCloseClassName[];   // used for the WNDCLASS (the Dialog's)
extern ICHAR            MsiDialogNoCloseClassName[];   // used for the WNDCLASS (the Dialog's)
extern Bool             g_fChicago;  // true if we have a Chicago like UI (95 or NT4 or higher)
extern Bool             g_fNT4;  // true if the system is NT4 or higher
extern bool             g_fFatalExit;  // true if CMsiHandler::Terminate() has been called with true argument
extern bool             g_fWin9X;         // true if Windows 95, 98 or ME, else false
extern int              g_iMajorVersion;  // OS' major version #
extern int              g_iMinorVersion;  // OS' minor version #

const int g_iIconIndexMyComputer = 0;
const int g_iIconIndexRemovable = 1;
const int g_iIconIndexFixed = 2;
const int g_iIconIndexRemote = 3;
const int g_iIconIndexFolder = 4;
const int g_iIconIndexCDROM = 5;
const int g_iIconIndexPhantom = 6;

extern HIMAGELIST g_hVolumeSmallIconList;

// This is the window class for the UIDialogProc

const ICHAR pcaDialogCreated[] = TEXT("Dialog created");

// reserved names of the error dialog

const ICHAR pcaErrorDialog[] = TEXT("ErrorDialog");
const ICHAR pcaErrorReturnEvent[] = TEXT("ErrorReturn");
const ICHAR pcaErrorText[] = TEXT("ErrorText");
const ICHAR pcaErrorIcon[] = TEXT("ErrorIcon");

// names of the strings in the UIText table
const ICHAR pcaBytes[] = TEXT("bytes");
const ICHAR pcaKB[] = TEXT("KB");
const ICHAR pcaMB[] = TEXT("MB");
const ICHAR pcaGB[] = TEXT("GB");
const ICHAR pcaNewFolder[] = TEXT("NewFolder");
const ICHAR pcaAbsentPath[] = TEXT("AbsentPath");
const ICHAR pcaSelAbsentAbsent[] = TEXT("SelAbsentAbsent");
const ICHAR pcaSelAbsentCD[] = TEXT("SelAbsentCD");
const ICHAR pcaSelAbsentNetwork[] = TEXT("SelAbsentNetwork");
const ICHAR pcaSelAbsentLocal[] = TEXT("SelAbsentLocal");
const ICHAR pcaSelAbsentAdvertise[] = TEXT("SelAbsentAdvertise");
const ICHAR pcaSelCDAbsent[] = TEXT("SelCDAbsent");
const ICHAR pcaSelNetworkAbsent[] = TEXT("SelNetworkAbsent");
const ICHAR pcaSelCDCD[] = TEXT("SelCDCD");
const ICHAR pcaSelNetworkNetwork[] = TEXT("SelNetworkNetwork");
const ICHAR pcaSelCDLocal[] = TEXT("SelCDLocal");
const ICHAR pcaSelNetworkLocal[] = TEXT("SelNetworkLocal");
const ICHAR pcaSelCDAdvertise[] = TEXT("SelCDAdvertise");
const ICHAR pcaSelNetworkAdvertise[] = TEXT("SelNetworkAdvertise");
const ICHAR pcaSelLocalAbsent[] = TEXT("SelLocalAbsent");
const ICHAR pcaSelLocalCD[] = TEXT("SelLocalCD");
const ICHAR pcaSelLocalNetwork[] = TEXT("SelLocalNetwork");
const ICHAR pcaSelLocalLocal[] = TEXT("SelLocalLocal");
const ICHAR pcaSelLocalAdvertise[] = TEXT("SelLocalAdvertise");
const ICHAR pcaSelAdvertiseAbsent[] = TEXT("SelAdvertiseAbsent");
const ICHAR pcaSelAdvertiseCD[] = TEXT("SelAdvertiseCD");
const ICHAR pcaSelAdvertiseNetwork[] = TEXT("SelAdvertiseNetwork");
const ICHAR pcaSelAdvertiseLocal[] = TEXT("SelAdvertiseLocal");
const ICHAR pcaSelAdvertiseAdvertise[] = TEXT("SelAdvertiseAdvertise");
const ICHAR pcaSelParentCostPosPos[] = TEXT("SelParentCostPosPos");
const ICHAR pcaSelParentCostPosNeg[] = TEXT("SelParentCostPosNeg");
const ICHAR pcaSelParentCostNegPos[] = TEXT("SelParentCostNegPos");
const ICHAR pcaSelParentCostNegNeg[] = TEXT("SelParentCostNegNeg");
const ICHAR pcaSelChildCostPos[] = TEXT("SelChildCostPos");
const ICHAR pcaSelChildCostNeg[] = TEXT("SelChildCostNeg");
const ICHAR pcaMenuAbsent[] = TEXT("MenuAbsent");
const ICHAR pcaMenuLocal[] = TEXT("MenuLocal");
const ICHAR pcaMenuCD[] = TEXT("MenuCD");
const ICHAR pcaMenuNetwork[] = TEXT("MenuNetwork");
const ICHAR pcaMenuAdvertise[] = TEXT("MenuAdvertise");
const ICHAR pcaMenuAllLocal[] = TEXT("MenuAllLocal");
const ICHAR pcaMenuAllCD[] = TEXT("MenuAllCD");
const ICHAR pcaMenuAllNetwork[] = TEXT("MenuAllNetwork");
const ICHAR pcaVolumeCostVolume[] = TEXT("VolumeCostVolume");
const ICHAR pcaVolumeCostSize[] = TEXT("VolumeCostSize");
const ICHAR pcaVolumeCostAvailable[] = TEXT("VolumeCostAvailable");
const ICHAR pcaVolumeCostRequired[] = TEXT("VolumeCostRequired");
const ICHAR pcaVolumeCostDifference[] = TEXT("VolumeCostDifference");
const ICHAR pcaTimeRemainingTemplate[] = TEXT("TimeRemaining");
const ICHAR pcaSelCostPending[] = TEXT("SelCostPending");

// SQL queries

const ICHAR sqlDialog[] = TEXT("SELECT `Dialog`, `HCentering`, `VCentering`, `Width`, `Height`,  `Attributes`, `Title`, `Control_First`, `Control_Default`, `Control_Cancel`, 0, 0, 0, 0 FROM `Dialog`  WHERE `Dialog`=?");
const ICHAR sqlDialogShort[] = TEXT("SELECT `Dialog`, `HCentering`, `VCentering`, `Width`, `Height`,  `Attributes`, `Title`, `Control_First`, `Control_Default`, NULL, `Help`, 0, 0, 0, 0 FROM `Dialog`  WHERE `Dialog`=?");
const ICHAR sqlControl[] = TEXT("SELECT `Control`, `Type`, `X`, `Y`, `Width`, `Height`, `Attributes`, `Property`, `Text`, `Control_Next`, `Help` FROM `Control` WHERE `Dialog_`=?");
const ICHAR sqlRadioButton[] = TEXT("SELECT `Value`, `X`, `Y`, `Width`, `Height`, `Text`, `Help` FROM `RadioButton` WHERE `Property`=? ORDER BY `Order`");
const ICHAR sqlBinary[] = TEXT("SELECT `Data` FROM `Binary` WHERE `Name`=?");
const ICHAR sqlListBox[] = TEXT("SELECT `Value`, `Text` FROM `ListBox` WHERE `Property`=? ORDER BY `Order`"); 
const ICHAR sqlListBoxShort[] = TEXT("SELECT `Value`, NULL FROM `ListBox` WHERE `Property`= ORDER BY `Order`?"); 
const ICHAR sqlComboBox[] = TEXT("SELECT `Value`, `Text` FROM `ComboBox` WHERE `Property`=? ORDER BY `Order`");
const ICHAR sqlComboBoxShort[] = TEXT("SELECT `Value`, NULL FROM `ComboBox` WHERE `Property`=? ORDER BY `Order`");
const ICHAR sqlError[] = TEXT("SELECT `DebugMessage` FROM `Error` WHERE `Error`=?");
const ICHAR sqlControlEvent[] = TEXT("SELECT `Event`, `Argument`, `Condition` FROM `ControlEvent` WHERE `Dialog_`=? AND `Control_`=? ORDER BY `Ordering`");
const ICHAR sqlFeature[] = TEXT("SELECT `Feature`, `Feature`.`Directory_`, `Title`, `Description`, `Display`, `RuntimeLevel`, `Select`, `Action`, `Installed`, `Handle` FROM `Feature` WHERE `Feature_Parent`=? ORDER BY `Display`");
const ICHAR sqlListView[] = TEXT("SELECT `Value`, `Text`, `Binary_` FROM `ListView` WHERE `Property`=? ORDER BY `Order`");
const ICHAR sqlListViewShort[] = TEXT("SELECT `Value`, NULL, `Binary_` FROM `ListView` WHERE `Property`=? ORDER BY `Order`");
const ICHAR sqlBillboardView[] = TEXT("SELECT `Billboard` FROM `Billboard`, `Feature` WHERE `Billboard`.`Action`=? AND `Billboard`.`Feature_`=`Feature`.`Feature` AND (`Feature`.`Select`=1 OR `Feature`.`Select`=2)");
const ICHAR sqlBillboardSortedView[] = TEXT("SELECT `Billboard` FROM `Billboard`, `Feature` WHERE `Billboard`.`Action`=? AND `Billboard`.`Feature_`=`Feature`.`Feature` AND (`Feature`.`Select`=1 OR `Feature`.`Select`=2) ORDER BY `Billboard`.`Ordering`");
const ICHAR sqlBillboardControl[] = TEXT("SELECT `BBControl`, `Type`, `X`, `Y`, `Width`, `Height`, `Attributes`, NULL, `Text`, NULL, NULL FROM `BBControl` WHERE `Billboard_`=?");
const ICHAR sqlTextStyle[] = TEXT("SELECT `FaceName`, `Size`, `Color`, `StyleBits`, `AbsoluteSize`, `FontHandle` FROM `TextStyle` WHERE `TextStyle`=?");
const ICHAR sqlTextStyleUpdate[] = TEXT("UPDATE `TextStyle` SET `AbsoluteSize`=?, `FontHandle`=? WHERE `TextStyle`=?");
const ICHAR sqlTextStyleInsert[] = TEXT("INSERT INTO `TextStyle` (`TextStyle`, `FaceName`, `Size`, `Color`, `StyleBits`, `AbsoluteSize`, `FontHandle`) VALUES(?, ?, ?, ?, ?, ?, ?) TEMPORARY");
const ICHAR sqlCheckBox[] = TEXT("SELECT `Value` FROM `CheckBox` WHERE `Property`=?");

// names of the persistent and internal tables
const ICHAR     pcaTablePDialog[] = TEXT("Dialog");
const ICHAR     pcaTablePControl[] = TEXT("Control");
const ICHAR     pcaTablePRadioButton[] = TEXT("RadioButton");
const ICHAR     pcaTablePListBox[] = TEXT("ListBox");
const ICHAR     pcaTableIValues[] = TEXT("Values");
const ICHAR     pcaTablePComboBox[] = TEXT("ComboBox");
const ICHAR     pcaTablePEventMapping[] = TEXT("EventMapping");
const ICHAR     pcaTablePControlEvent[] = TEXT("ControlEvent");
const ICHAR     pcaTablePValidation[] = TEXT("ControlValidation");
const ICHAR     pcaTablePControlCondition[] = TEXT("ControlCondition");
const ICHAR     pcaTablePBinary[] = TEXT("Binary");
const ICHAR     pcaTableIDialogs[] = TEXT("Dialogs");
const ICHAR     pcaTableIControls[] = TEXT("Controls");
const ICHAR     pcaTableIControlTypes[] = TEXT("ControlTypes");
const ICHAR     pcaTableIDialogAttributes[] = TEXT("DialogAttributes");
const ICHAR     pcaTableIControlAttributes[] = TEXT("ControlAttributes");
const ICHAR     pcaTableIEventRegister[] = TEXT("EventRegister");
const ICHAR     pcaTableIRadioButton[] = TEXT("RadioButton");
const ICHAR     pcaTableIDirectoryList[] = TEXT("DirectoryList");
const ICHAR     pcaTableIDirectoryCombo[] = TEXT("DirectoryCombo");
const ICHAR     pcaTableIVolumeSelectCombo[] = TEXT("VolumeSelectCombo");
const ICHAR     pcaTablePFeature[] = TEXT("Feature");
const ICHAR     pcaTableIProperties[] = TEXT("Properties");
const ICHAR     pcaTablePUIText[] = TEXT("UIText");
const ICHAR     pcaTableISelMenu[] = TEXT("SelectionMenu");
const ICHAR     pcaTablePVolumeCost[] = TEXT("VolumeCost");
const ICHAR     pcaTableIVolumeCost[] = TEXT("InternalVolumeCost");
const ICHAR     pcaTableIVolumeList[] = TEXT("VolumeList");
const ICHAR     pcaTablePListView[] = TEXT("ListView");
const ICHAR     pcaTableIBBControls[] = TEXT("BillboardControls");
const ICHAR     pcaTablePTextStyle[] = TEXT("TextStyle");
const ICHAR     pcaTablePCheckBox[] = TEXT("CheckBox");

// names of optional columns in tables that we check for 
const ICHAR     pcaTableColumnPDialogCancel[] = TEXT("Control_Cancel");
const ICHAR     pcaTableColumnPListBoxText[] = TEXT("Text");
const ICHAR     pcaTableColumnPComboBoxText[] = TEXT("Text");
const ICHAR     pcaTableColumnPListViewText[] = TEXT("Text");

// names of the columns in the Feature Table
const ICHAR szFeatureKey[]       = TEXT("Feature");
const ICHAR szFeatureParent[]    = TEXT("Feature_Parent");
const ICHAR szFeatureTitle[]     = TEXT("Title");
const ICHAR szFeatureDescription[] = TEXT("Description");
const ICHAR szFeatureDisplay[]   = TEXT("Display");
const ICHAR szFeatureLevel[]     = TEXT("RuntimeLevel");
const ICHAR szFeatureDirectory[]      = TEXT("Directory_");
const ICHAR szFeatureOldDirectory[]      = TEXT("Directory_Configurable"); //!! Remove after grace period
const ICHAR szFeatureAttributes[]      = TEXT("Attributes");
const ICHAR szFeatureSelect[]    = TEXT("Select");
const ICHAR szFeatureAction[] = TEXT("Action");
const ICHAR szFeatureInstalled[] = TEXT("Installed");
const ICHAR szFeatureHandle[]    = TEXT("Handle");

// names of the columns in the VolumeCost Table
const ICHAR szColVolumeObject[]    = TEXT("VolumeObject");
const ICHAR szColVolumeCost[]      = TEXT("VolumeCost");
const ICHAR szColNoRbVolumeCost[]  = TEXT("NoRbVolumeCost");

// names of the columns in the TextStyle Table
const ICHAR szColTextStyleTextStyle[] = TEXT("TextStyle");
const ICHAR szColTextStyleFaceName[] = TEXT("FaceName");
const ICHAR szColTextStyleSize[] = TEXT("Size");
const ICHAR szColTextStyleColor[] = TEXT("Color");
const ICHAR szColTextStyleStyleBits[] = TEXT("StyleBits");
const ICHAR szColTextStyleAbsoluteSize[] = TEXT("AbsoluteSize"); // temporary column
const ICHAR szColTextStyleFontHandle[] = TEXT("FontHandle"); // temporary column

const ICHAR szUserLangTextStyleSuffix[] = TEXT("__UL"); // 


const ICHAR szPropShortFileNames[] = TEXT("SHORTFILENAMES");

//  control type names (to be continued as IMsiControl::GetControlType()
//  will be implemented for classes)
const ICHAR g_szPushButtonType[] = TEXT("PushButton");
const ICHAR g_szIconType[] = TEXT("Icon");

extern const int iDlgUnitSize;

// global function used by the dialogs and controls to create a cursor
IMsiRecord* CursorCreate(IMsiTable& riTable, const ICHAR* szTable, Bool fTree, IMsiServices& riServices, IMsiCursor*& rpiCursor);
// global function used by controls to access the UIText table
const IMsiString& GetUIText(const IMsiString& riPropertyString);
// global function used to create a column in a temporary table
void CreateTemporaryColumn(IMsiTable& rpiTable, int iAttributes, int iIndex);
// global function to format disk size into string
const IMsiString& FormatSize(INT64 iSize, Bool fLeftUnit);
// global function to get the index of the icon in the global image list, corresponding to the volume, using the volume
int GetVolumeIconIndex(IMsiVolume& riVolume);
// global function to get the index of the icon in the global image list, corresponding to the volume, using the volume type 
int GetVolumeIconIndex(idtEnum iDriveType);
// global function to check if a column exists in a table
IMsiRecord* IsColumnPresent(IMsiDatabase& riDatabase, const IMsiString& riTableNameString, const IMsiString& riColumnNameString, Bool* pfPresent);
// escapes every character in the string
const IMsiString& EscapeAll(const IMsiString& riIn);
boolean FExtractSubString(MsiString& riIn, int ichStart, const ICHAR chEnd, const IMsiString*& pReturn);
// rounds float to integer
int Round(double rArg);

// Columns of the persistent UIText table
enum UITextColumns
{
	itabUIKey = 1,      //S
	itabUIText,         //S
};


// Columns of the internal Dialogs table
enum DialogsColumns
{
	itabDSKey = 1,      //S
	itabDSPointer,      //P
	itabDSParent,       //S
	itabDSWindow,		//I
	itabDSModal,        //I
};

// Columns of the internal Controls table
enum ControlsColumns
{
	itabCSKey = 1,      //S
	itabCSWindow,       //I
	itabCSIndirectProperty,  //S 
	itabCSProperty,     //S
	itabCSPointer,      //P
	itabCSNext,         //S
	itabCSPrev,         //S
};

// Columns of the internal Properties table
enum PropertiesColumns
{
	itabPRProperty = 1,   // S
	itabPRValue,          // S
};

// Columns of the EventReg table
enum EventRegColumns
{
	itabEREvent = 1,    //S
	itabERPublisher,    //S
};

// Columns of the internal ControlTypes table
enum ControlTypesColumns
{
	itabCTKey = 1,      //S
	itabCTCreate,       //I
};

// Columns of the Browse table
enum BrowseColumns
{
	itabBRKey = 1,      //S
};


// Entries for the record fetched from the permanent Dialog table
enum PDIColumns
{
	itabDIName = 1,
	itabDIHCentering,
	itabDIVCentering,
	itabDIdX,
	itabDIdY,
	itabDIAttributes,
	itabDITitle,
	itabDIFirstControl,
	itabDIDefButton,
	itabDICancelButton,
};

// Fields of the record fetched from the permanent Control table
enum PCOColumns
{
	itabCOControl = 1,
	itabCOType,
	itabCOX,
	itabCOY,
	itabCOWidth,
	itabCOHeight,
	itabCOAttributes,
	itabCOProperty,
	itabCOText,
	itabCONext,
	itabCOHelp,
};

// Fields of the record fetched from the permanent Features table
enum PFEColumns
{
	itabFEFeature = 1,
	itabFEDirectory,
	itabFETitle,
	itabFEDescription,
	itabFEDisplay,
	itabFELevel,
	itabFESelect,
	itabFEAction,
	itabFEInstalled,
	itabFEHandle,
};


// Entries for the record fetched from the permanent RadioButton table
enum PRBColumns
{
	itabRBValue = 1,
	itabRBX,
	itabRBY,
	itabRBWidth,
	itabRBHeight,
	itabRBText,
	itabRBHelp,
};

// Entries for the record fetched from the permanent ListView table
enum PLVColumns
{
	itabLVValue = 1,
	itabLVText,
	itabLVImage,
};


// Columns of the permanent EventMapping table
enum PEMColumns
{
	itabEMDialog = 1,
	itabEMControl,
	itabEMEvent,
	itabEMAttribute,
};

// Columns of the permanent ControlEvent table
enum PCEColumns
{
	itabCEDialog = 1,
	itabCEControl,
	itabCEEvent,
	itabCEArgument,
	itabCECondition,
	itabCEOrdering,
};

// Columns of the permanent ControlCondition table
enum PCCColumns
{
	itabCCDialog = 1,
	itabCCControl,
	itabCCAction,
	itabCCCondition,
};

// Columns of the internal Values table
enum ValuesColumns
{
	itabVAValue = 1,    //S
	itabVAText,			//S
};

// Columns of the internal BBControls table
enum BBCColumns
{
	itabBBName = 1,     //S
	itabBBObject,       //O
};

// Columns of the TextStyle table
enum TSTColumns
{
	itabTSTTextStyle = 1,
	itabTSTFaceName,
	itabTSTSize,
	itabTSTColor,
	itabTSTStyleBits,
	itabTSTAbsoluteSize,
	itabTSTFontHandle,
};

// Fields of the record fetched from the TextStyle table
enum TSColumns
{
	itabTSFaceName = 1,   //S
	itabTSSize,           //I
	itabTSColor,          //I
	itabTSStyleBits,      //I
	itabTSAbsoluteSize,   //I
	itabTSFontHandle,     //I
};


extern WNDPROC pWindowProc;

typedef Bool (*StrSetFun)(const IMsiString&);
typedef Bool (*IntSetFun)(int);
typedef Bool (*BoolSetFun)(Bool);
typedef const IMsiString& (*StrGetFun)();
typedef int (*IntGetFun)();
typedef Bool (*BoolGetFun)();



class CMsiHandler;
class CMsiDialog;
class CMsiControl;
class CMsiStringControl;
class CMsiIntControl;



IMsiDialog* CreateMsiDialog(const IMsiString& riTypeString, IMsiDialogHandler& riHandler, IMsiEngine& riEngine, WindowRef pwndParent);

IMsiControl* CreateMsiControl(const IMsiString& riTypeString, IMsiEvent& riDialog);

void ChangeWindowStyle (WindowRef pWnd, DWORD dwRemove, DWORD dwAdd, Bool fExtendedStyles); 
Bool IsSpecialMessage(LPMSG lpMsg);
boolean FInBuffer(CTempBufferRef<MsiStringId>& rgControls, MsiStringId iControl);
inline int TOOLINFOsize(void)
{
	// this is to keep in sync with the defintion of
	// struct tagTOOLINFO in COMMCTRL.H
	return MinimumPlatformWindowsNT51() ? sizeof(TOOLINFO) : TTTOOLINFOA_V2_SIZE;
}

#if defined(_WIN64) || defined(DEBUG)
#define USE_OBJECT_POOL
#endif // _WIN64 || DEBUG

extern bool g_fUseObjectPool;


#endif  //__HANDLER_SHARED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\dmemmgr.c ===
/*
 * jmemmgr.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains the JPEG system-independent memory management
 * routines.  This code is usable across a wide variety of machines; most
 * of the system dependencies have been isolated in a separate file.
 * The major functions provided here are:
 *   * pool-based allocation and freeing of memory;
 *   * policy decisions about how to divide available memory among the
 *     virtual arrays;
 *   * control logic for swapping virtual arrays between main memory and
 *     backing storage.
 * The separate system-dependent file provides the actual backing-storage
 * access code, and it contains the policy decision about how much total
 * main memory to use.
 * This file is system-dependent in the sense that some of its functions
 * are unnecessary in some systems.  For example, if there is enough virtual
 * memory so that backing storage will never be used, much of the virtual
 * array control logic could be removed.  (Of course, if you have that much
 * memory then you shouldn't care about a little bit of unused code...)
 */

#define JPEG_INTERNALS
#define AM_MEMORY_MANAGER	/* we define jvirt_Xarray_control structs */
#include "jinclude.h"
#include "jpeglib.h"
#include "jmemsys.h"		/* import the system-dependent declarations */

#ifndef NO_GETENV
#ifndef HAVE_STDLIB_H		/* <stdlib.h> should declare getenv() */
extern char * getenv JPP((const char * name));
#endif
#endif


/*
 * Some important notes:
 *   The allocation routines provided here must never return NULL.
 *   They should exit to error_exit if unsuccessful.
 *
 *   It's not a good idea to try to merge the sarray and barray routines,
 *   even though they are textually almost the same, because samples are
 *   usually stored as bytes while coefficients are shorts or ints.  Thus,
 *   in machines where byte pointers have a different representation from
 *   word pointers, the resulting machine code could not be the same.
 */


/*
 * Many machines require storage alignment: longs must start on 4-byte
 * boundaries, doubles on 8-byte boundaries, etc.  On such machines, malloc()
 * always returns pointers that are multiples of the worst-case alignment
 * requirement, and we had better do so too.
 * There isn't any really portable way to determine the worst-case alignment
 * requirement.  This module assumes that the alignment requirement is
 * multiples of sizeof(ALIGN_TYPE).
 * By default, we define ALIGN_TYPE as double.  This is necessary on some
 * workstations (where doubles really do need 8-byte alignment) and will work
 * fine on nearly everything.  If your machine has lesser alignment needs,
 * you can save a few bytes by making ALIGN_TYPE smaller.
 * The only place I know of where this will NOT work is certain Macintosh
 * 680x0 compilers that define double as a 10-byte IEEE extended float.
 * Doing 10-byte alignment is counterproductive because longwords won't be
 * aligned well.  Put "#define ALIGN_TYPE long" in jconfig.h if you have
 * such a compiler.
 */

#ifndef ALIGN_TYPE		/* so can override from jconfig.h */
#define ALIGN_TYPE  double
#endif


/*
 * We allocate objects from "pools", where each pool is gotten with a single
 * request to jpeg_get_small() or jpeg_get_large().  There is no per-object
 * overhead within a pool, except for alignment padding.  Each pool has a
 * header with a link to the next pool of the same class.
 * Small and large pool headers are identical except that the latter's
 * link pointer must be FAR on 80x86 machines.
 * Notice that the "real" header fields are union'ed with a dummy ALIGN_TYPE
 * field.  This forces the compiler to make SIZEOF(small_pool_hdr) a multiple
 * of the alignment requirement of ALIGN_TYPE.
 */

typedef union small_pool_struct * small_pool_ptr;

typedef union small_pool_struct {
  struct {
    small_pool_ptr next;	/* next in list of pools */
    size_t bytes_used;		/* how many bytes already used within pool */
    size_t bytes_left;		/* bytes still available in this pool */
  } hdr;
  ALIGN_TYPE dummy;		/* included in union to ensure alignment */
} small_pool_hdr;

typedef union large_pool_struct FAR * large_pool_ptr;

typedef union large_pool_struct {
  struct {
    large_pool_ptr next;	/* next in list of pools */
    size_t bytes_used;		/* how many bytes already used within pool */
    size_t bytes_left;		/* bytes still available in this pool */
  } hdr;
  ALIGN_TYPE dummy;		/* included in union to ensure alignment */
} large_pool_hdr;


/*
 * Here is the full definition of a memory manager object.
 */

typedef struct {
  struct jpeg_memory_mgr pub;	/* public fields */

  /* Each pool identifier (lifetime class) names a linked list of pools. */
  small_pool_ptr small_list[JPOOL_NUMPOOLS];
  large_pool_ptr large_list[JPOOL_NUMPOOLS];

  /* Since we only have one lifetime class of virtual arrays, only one
   * linked list is necessary (for each datatype).  Note that the virtual
   * array control blocks being linked together are actually stored somewhere
   * in the small-pool list.
   */
  jvirt_sarray_ptr virt_sarray_list;
  jvirt_barray_ptr virt_barray_list;

  /* This counts total space obtained from jpeg_get_small/large */
  long total_space_allocated;

  /* alloc_sarray and alloc_barray set this value for use by virtual
   * array routines.
   */
  JDIMENSION last_rowsperchunk;	/* from most recent alloc_sarray/barray */
} my_memory_mgr;

typedef my_memory_mgr * my_mem_ptr;


/*
 * The control blocks for virtual arrays.
 * Note that these blocks are allocated in the "small" pool area.
 * System-dependent info for the associated backing store (if any) is hidden
 * inside the backing_store_info struct.
 */

struct jvirt_sarray_control {
  JSAMPARRAY mem_buffer;	/* => the in-memory buffer */
  JDIMENSION rows_in_array;	/* total virtual array height */
  JDIMENSION samplesperrow;	/* width of array (and of memory buffer) */
  JDIMENSION maxaccess;		/* max rows accessed by access_virt_sarray */
  JDIMENSION rows_in_mem;	/* height of memory buffer */
  JDIMENSION rowsperchunk;	/* allocation chunk size in mem_buffer */
  JDIMENSION cur_start_row;	/* first logical row # in the buffer */
  JDIMENSION first_undef_row;	/* row # of first uninitialized row */
  boolean pre_zero;		/* pre-zero mode requested? */
  boolean dirty;		/* do current buffer contents need written? */
  jvirt_sarray_ptr next;	/* link to next virtual sarray control block */
  backing_store_info b_s_info;	/* System-dependent control info */
};

struct jvirt_barray_control {
  JBLOCKARRAY mem_buffer;	/* => the in-memory buffer */
  JDIMENSION rows_in_array;	/* total virtual array height */
  JDIMENSION blocksperrow;	/* width of array (and of memory buffer) */
  JDIMENSION maxaccess;		/* max rows accessed by access_virt_barray */
  JDIMENSION rows_in_mem;	/* height of memory buffer */
  JDIMENSION rowsperchunk;	/* allocation chunk size in mem_buffer */
  JDIMENSION cur_start_row;	/* first logical row # in the buffer */
  JDIMENSION first_undef_row;	/* row # of first uninitialized row */
  boolean pre_zero;		/* pre-zero mode requested? */
  boolean dirty;		/* do current buffer contents need written? */
  jvirt_barray_ptr next;	/* link to next virtual barray control block */
  backing_store_info b_s_info;	/* System-dependent control info */
};


#ifdef MEM_STATS		/* optional extra stuff for statistics */

LOCAL(void)
print_mem_stats (j_common_ptr cinfo, int pool_id)
{
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
  small_pool_ptr shdr_ptr;
  large_pool_ptr lhdr_ptr;

  /* Since this is only a debugging stub, we can cheat a little by using
   * fprintf directly rather than going through the trace message code.
   * This is helpful because message parm array can't handle longs.
   */
  fprintf(stderr, "Freeing pool %d, total space = %ld\n",
	  pool_id, mem->total_space_allocated);

  for (lhdr_ptr = mem->large_list[pool_id]; lhdr_ptr != NULL;
       lhdr_ptr = lhdr_ptr->hdr.next) {
    fprintf(stderr, "  Large chunk used %ld\n",
	    (long) lhdr_ptr->hdr.bytes_used);
  }

  for (shdr_ptr = mem->small_list[pool_id]; shdr_ptr != NULL;
       shdr_ptr = shdr_ptr->hdr.next) {
    fprintf(stderr, "  Small chunk used %ld free %ld\n",
	    (long) shdr_ptr->hdr.bytes_used,
	    (long) shdr_ptr->hdr.bytes_left);
  }
}

#endif /* MEM_STATS */


LOCAL(void)
out_of_memory (j_common_ptr cinfo, int which)
/* Report an out-of-memory error and stop execution */
/* If we compiled MEM_STATS support, report alloc requests before dying */
{
#ifdef MEM_STATS
  cinfo->err->trace_level = 2;	/* force self_destruct to report stats */
#endif
  ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, which);
}


/*
 * Allocation of "small" objects.
 *
 * For these, we use pooled storage.  When a new pool must be created,
 * we try to get enough space for the current request plus a "slop" factor,
 * where the slop will be the amount of leftover space in the new pool.
 * The speed vs. space tradeoff is largely determined by the slop values.
 * A different slop value is provided for each pool class (lifetime),
 * and we also distinguish the first pool of a class from later ones.
 * NOTE: the values given work fairly well on both 16- and 32-bit-int
 * machines, but may be too small if longs are 64 bits or more.
 */

static const size_t first_pool_slop[JPOOL_NUMPOOLS] = 
{
	1600,			/* first PERMANENT pool */
	16000			/* first IMAGE pool */
};

static const size_t extra_pool_slop[JPOOL_NUMPOOLS] = 
{
	0,			/* additional PERMANENT pools */
	5000			/* additional IMAGE pools */
};

#define MIN_SLOP  50		/* greater than 0 to avoid futile looping */


METHODDEF(void *)
alloc_small (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
/* Allocate a "small" object */
{
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
  small_pool_ptr hdr_ptr, prev_hdr_ptr;
  char * data_ptr;
  size_t odd_bytes, min_request, slop;

  /* Check for unsatisfiable request (do now to ensure no overflow below) */
  if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(small_pool_hdr)))
    out_of_memory(cinfo, 1);	/* request exceeds malloc's ability */

  /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
  odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
  if (odd_bytes > 0)
    sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;

  /* See if space is available in any existing pool */
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
  prev_hdr_ptr = NULL;
  hdr_ptr = mem->small_list[pool_id];
  while (hdr_ptr != NULL) {
    if (hdr_ptr->hdr.bytes_left >= sizeofobject)
      break;			/* found pool with enough space */
    prev_hdr_ptr = hdr_ptr;
    hdr_ptr = hdr_ptr->hdr.next;
  }

  /* Time to make a new pool? */
  if (hdr_ptr == NULL) {
    /* min_request is what we need now, slop is what will be leftover */
    min_request = sizeofobject + SIZEOF(small_pool_hdr);
    if (prev_hdr_ptr == NULL)	/* first pool in class? */
      slop = first_pool_slop[pool_id];
    else
      slop = extra_pool_slop[pool_id];
    /* Don't ask for more than MAX_ALLOC_CHUNK */
    if (slop > (size_t) (MAX_ALLOC_CHUNK-min_request))
      slop = (size_t) (MAX_ALLOC_CHUNK-min_request);
    /* Try to get space, if fail reduce slop and try again */
    for (;;) {
      hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
      if (hdr_ptr != NULL)
	break;
      slop /= 2;
      if (slop < MIN_SLOP)	/* give up when it gets real small */
	out_of_memory(cinfo, 2); /* jpeg_get_small failed */
    }
#ifdef _WIN64
    mem->total_space_allocated += (long)(min_request + slop); //!!WIN64 shouldn't need to cast - BENCH
#else //!_WIN64
    mem->total_space_allocated += min_request + slop;
#endif //_WIN64
    /* Success, initialize the new pool header and add to end of list */
    hdr_ptr->hdr.next = NULL;
    hdr_ptr->hdr.bytes_used = 0;
    hdr_ptr->hdr.bytes_left = sizeofobject + slop;
    if (prev_hdr_ptr == NULL)	/* first pool in class? */
      mem->small_list[pool_id] = hdr_ptr;
    else
      prev_hdr_ptr->hdr.next = hdr_ptr;
  }

  /* OK, allocate the object from the current pool */
  data_ptr = (char *) (hdr_ptr + 1); /* point to first data byte in pool */
  data_ptr += hdr_ptr->hdr.bytes_used; /* point to place for object */
  hdr_ptr->hdr.bytes_used += sizeofobject;
  hdr_ptr->hdr.bytes_left -= sizeofobject;

  return (void *) data_ptr;
}


/*
 * Allocation of "large" objects.
 *
 * The external semantics of these are the same as "small" objects,
 * except that FAR pointers are used on 80x86.  However the pool
 * management heuristics are quite different.  We assume that each
 * request is large enough that it may as well be passed directly to
 * jpeg_get_large; the pool management just links everything together
 * so that we can free it all on demand.
 * Note: the major use of "large" objects is in JSAMPARRAY and JBLOCKARRAY
 * structures.  The routines that create these structures (see below)
 * deliberately bunch rows together to ensure a large request size.
 */

METHODDEF(void FAR *)
alloc_large (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
/* Allocate a "large" object */
{
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
  large_pool_ptr hdr_ptr;
  size_t odd_bytes;

  /* Check for unsatisfiable request (do now to ensure no overflow below) */
  if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)))
    out_of_memory(cinfo, 3);	/* request exceeds malloc's ability */

  /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
  odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
  if (odd_bytes > 0)
    sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;

  /* Always make a new pool */
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */

  hdr_ptr = (large_pool_ptr) jpeg_get_large(cinfo, sizeofobject +
					    SIZEOF(large_pool_hdr));
  if (hdr_ptr == NULL)
    out_of_memory(cinfo, 4);	/* jpeg_get_large failed */
#ifdef _WIN64
  mem->total_space_allocated += (long)(sizeofobject + SIZEOF(large_pool_hdr)); //!!WIN64 shouldn't need to cast - BENCH
#else //!_WIN64
  mem->total_space_allocated += sizeofobject + SIZEOF(large_pool_hdr);
#endif

  /* Success, initialize the new pool header and add to list */
  hdr_ptr->hdr.next = mem->large_list[pool_id];
  /* We maintain space counts in each pool header for statistical purposes,
   * even though they are not needed for allocation.
   */
  hdr_ptr->hdr.bytes_used = sizeofobject;
  hdr_ptr->hdr.bytes_left = 0;
  mem->large_list[pool_id] = hdr_ptr;

  return (void FAR *) (hdr_ptr + 1); /* point to first data byte in pool */
}


/*
 * Creation of 2-D sample arrays.
 * The pointers are in near heap, the samples themselves in FAR heap.
 *
 * To minimize allocation overhead and to allow I/O of large contiguous
 * blocks, we allocate the sample rows in groups of as many rows as possible
 * without exceeding MAX_ALLOC_CHUNK total bytes per allocation request.
 * NB: the virtual array control routines, later in this file, know about
 * this chunking of rows.  The rowsperchunk value is left in the mem manager
 * object so that it can be saved away if this sarray is the workspace for
 * a virtual array.
 */

METHODDEF(JSAMPARRAY)
alloc_sarray (j_common_ptr cinfo, int pool_id,
	      JDIMENSION samplesperrow, JDIMENSION numrows)
/* Allocate a 2-D sample array */
{
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
  JSAMPARRAY result;
  JSAMPROW workspace;
  JDIMENSION rowsperchunk, currow, i;
  long ltemp;

  /* Calculate max # of rows allowed in one allocation chunk */
  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
	  ((long) samplesperrow * SIZEOF(JSAMPLE));
  if (ltemp <= 0)
    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
  if (ltemp < (long) numrows)
    rowsperchunk = (JDIMENSION) ltemp;
  else
    rowsperchunk = numrows;
  mem->last_rowsperchunk = rowsperchunk;

  /* Get space for row pointers (small object) */
  result = (JSAMPARRAY) alloc_small(cinfo, pool_id,
				    (size_t) (numrows * SIZEOF(JSAMPROW)));

  /* Get the rows themselves (large objects) */
  currow = 0;
  while (currow < numrows) {
    rowsperchunk = MIN(rowsperchunk, numrows - currow);
    workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
	(size_t) ((size_t) rowsperchunk * (size_t) samplesperrow
		  * SIZEOF(JSAMPLE)));
    for (i = rowsperchunk; i > 0; i--) {
      result[currow++] = workspace;
      workspace += samplesperrow;
    }
  }

  return result;
}


/*
 * Creation of 2-D coefficient-block arrays.
 * This is essentially the same as the code for sample arrays, above.
 */

METHODDEF(JBLOCKARRAY)
alloc_barray (j_common_ptr cinfo, int pool_id,
	      JDIMENSION blocksperrow, JDIMENSION numrows)
/* Allocate a 2-D coefficient-block array */
{
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
  JBLOCKARRAY result;
  JBLOCKROW workspace;
  JDIMENSION rowsperchunk, currow, i;
  long ltemp;

  /* Calculate max # of rows allowed in one allocation chunk */
  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
	  ((long) blocksperrow * SIZEOF(JBLOCK));
  if (ltemp <= 0)
    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
  if (ltemp < (long) numrows)
    rowsperchunk = (JDIMENSION) ltemp;
  else
    rowsperchunk = numrows;
  mem->last_rowsperchunk = rowsperchunk;

  /* Get space for row pointers (small object) */
  result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
				     (size_t) (numrows * SIZEOF(JBLOCKROW)));

  /* Get the rows themselves (large objects) */
  currow = 0;
  while (currow < numrows) {
    rowsperchunk = MIN(rowsperchunk, numrows - currow);
    workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
	(size_t) ((size_t) rowsperchunk * (size_t) blocksperrow
		  * SIZEOF(JBLOCK)));
    for (i = rowsperchunk; i > 0; i--) {
      result[currow++] = workspace;
      workspace += blocksperrow;
    }
  }

  return result;
}


/*
 * About virtual array management:
 *
 * The above "normal" array routines are only used to allocate strip buffers
 * (as wide as the image, but just a few rows high).  Full-image-sized buffers
 * are handled as "virtual" arrays.  The array is still accessed a strip at a
 * time, but the memory manager must save the whole array for repeated
 * accesses.  The intended implementation is that there is a strip buffer in
 * memory (as high as is possible given the desired memory limit), plus a
 * backing file that holds the rest of the array.
 *
 * The request_virt_array routines are told the total size of the image and
 * the maximum number of rows that will be accessed at once.  The in-memory
 * buffer must be at least as large as the maxaccess value.
 *
 * The request routines create control blocks but not the in-memory buffers.
 * That is postponed until realize_virt_arrays is called.  At that time the
 * total amount of space needed is known (approximately, anyway), so free
 * memory can be divided up fairly.
 *
 * The access_virt_array routines are responsible for making a specific strip
 * area accessible (after reading or writing the backing file, if necessary).
 * Note that the access routines are told whether the caller intends to modify
 * the accessed strip; during a read-only pass this saves having to rewrite
 * data to disk.  The access routines are also responsible for pre-zeroing
 * any newly accessed rows, if pre-zeroing was requested.
 *
 * In current usage, the access requests are usually for nonoverlapping
 * strips; that is, successive access start_row numbers differ by exactly
 * num_rows = maxaccess.  This means we can get good performance with simple
 * buffer dump/reload logic, by making the in-memory buffer be a multiple
 * of the access height; then there will never be accesses across bufferload
 * boundaries.  The code will still work with overlapping access requests,
 * but it doesn't handle bufferload overlaps very efficiently.
 */


METHODDEF(jvirt_sarray_ptr)
request_virt_sarray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
		     JDIMENSION samplesperrow, JDIMENSION numrows,
		     JDIMENSION maxaccess)
/* Request a virtual 2-D sample array */
{
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
  jvirt_sarray_ptr result;

  /* Only IMAGE-lifetime virtual arrays are currently supported */
  if (pool_id != JPOOL_IMAGE)
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */

  /* get control block */
  result = (jvirt_sarray_ptr) alloc_small(cinfo, pool_id,
					  SIZEOF(struct jvirt_sarray_control));

  result->mem_buffer = NULL;	/* marks array not yet realized */
  result->rows_in_array = numrows;
  result->samplesperrow = samplesperrow;
  result->maxaccess = maxaccess;
  result->pre_zero = pre_zero;
  result->next = mem->virt_sarray_list; /* add to list of virtual arrays */
  mem->virt_sarray_list = result;

  return result;
}


METHODDEF(jvirt_barray_ptr)
request_virt_barray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
		     JDIMENSION blocksperrow, JDIMENSION numrows,
		     JDIMENSION maxaccess)
/* Request a virtual 2-D coefficient-block array */
{
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
  jvirt_barray_ptr result;

  /* Only IMAGE-lifetime virtual arrays are currently supported */
  if (pool_id != JPOOL_IMAGE)
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */

  /* get control block */
  result = (jvirt_barray_ptr) alloc_small(cinfo, pool_id,
					  SIZEOF(struct jvirt_barray_control));

  result->mem_buffer = NULL;	/* marks array not yet realized */
  result->rows_in_array = numrows;
  result->blocksperrow = blocksperrow;
  result->maxaccess = maxaccess;
  result->pre_zero = pre_zero;
  result->next = mem->virt_barray_list; /* add to list of virtual arrays */
  mem->virt_barray_list = result;

  return result;
}


METHODDEF(void)
realize_virt_arrays (j_common_ptr cinfo)
/* Allocate the in-memory buffers for any unrealized virtual arrays */
{
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
  long space_per_minheight, maximum_space, avail_mem;
  long minheights, max_minheights;
  jvirt_sarray_ptr sptr;
  jvirt_barray_ptr bptr;

  /* Compute the minimum space needed (maxaccess rows in each buffer)
   * and the maximum space needed (full image height in each buffer).
   * These may be of use to the system-dependent jpeg_mem_available routine.
   */
  space_per_minheight = 0;
  maximum_space = 0;
  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
    if (sptr->mem_buffer == NULL) { /* if not realized yet */
      space_per_minheight += (long) sptr->maxaccess *
			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
      maximum_space += (long) sptr->rows_in_array *
		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
    }
  }
  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
    if (bptr->mem_buffer == NULL) { /* if not realized yet */
      space_per_minheight += (long) bptr->maxaccess *
			     (long) bptr->blocksperrow * SIZEOF(JBLOCK);
      maximum_space += (long) bptr->rows_in_array *
		       (long) bptr->blocksperrow * SIZEOF(JBLOCK);
    }
  }

  if (space_per_minheight <= 0)
    return;			/* no unrealized arrays, no work */

  /* Determine amount of memory to actually use; this is system-dependent. */
  avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space,
				 mem->total_space_allocated);

  /* If the maximum space needed is available, make all the buffers full
   * height; otherwise parcel it out with the same number of minheights
   * in each buffer.
   */
  if (avail_mem >= maximum_space)
    max_minheights = 1000000000L;
  else {
    max_minheights = avail_mem / space_per_minheight;
    /* If there doesn't seem to be enough space, try to get the minimum
     * anyway.  This allows a "stub" implementation of jpeg_mem_available().
     */
    if (max_minheights <= 0)
      max_minheights = 1;
  }

  /* Allocate the in-memory buffers and initialize backing store as needed. */

  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
    if (sptr->mem_buffer == NULL) { /* if not realized yet */
      minheights = ((long) sptr->rows_in_array - 1L) / sptr->maxaccess + 1L;
	/* This buffer fits in memory */
	sptr->rows_in_mem = sptr->rows_in_array;
      sptr->mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,
				      sptr->samplesperrow, sptr->rows_in_mem);
      sptr->rowsperchunk = mem->last_rowsperchunk;
      sptr->cur_start_row = 0;
      sptr->first_undef_row = 0;
      sptr->dirty = FALSE;
    }
  }

  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
    if (bptr->mem_buffer == NULL) { /* if not realized yet */
      minheights = ((long) bptr->rows_in_array - 1L) / bptr->maxaccess + 1L;
	/* This buffer fits in memory */
	bptr->rows_in_mem = bptr->rows_in_array;
      bptr->mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,
				      bptr->blocksperrow, bptr->rows_in_mem);
      bptr->rowsperchunk = mem->last_rowsperchunk;
      bptr->cur_start_row = 0;
      bptr->first_undef_row = 0;
      bptr->dirty = FALSE;
    }
  }
}


LOCAL(void)
do_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing)
/* Do backing store read or write of a virtual sample array */
{
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;

  bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLE);
  file_offset = ptr->cur_start_row * bytesperrow;
  /* Loop to read or write each allocation chunk in mem_buffer */
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
    /* One chunk, but check for short chunk at end of buffer */
    rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
    /* Transfer no more than is currently defined */
    thisrow = (long) ptr->cur_start_row + i;
    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
    /* Transfer no more than fits in file */
    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
    if (rows <= 0)		/* this chunk might be past end of file! */
      break;
    byte_count = rows * bytesperrow;
    if (writing)
      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
					    (void FAR *) ptr->mem_buffer[i],
					    file_offset, byte_count);
    else
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
					   (void FAR *) ptr->mem_buffer[i],
					   file_offset, byte_count);
    file_offset += byte_count;
  }
}


LOCAL(void)
do_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing)
/* Do backing store read or write of a virtual coefficient-block array */
{
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;

  bytesperrow = (long) ptr->blocksperrow * SIZEOF(JBLOCK);
  file_offset = ptr->cur_start_row * bytesperrow;
  /* Loop to read or write each allocation chunk in mem_buffer */
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
    /* One chunk, but check for short chunk at end of buffer */
    rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
    /* Transfer no more than is currently defined */
    thisrow = (long) ptr->cur_start_row + i;
    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
    /* Transfer no more than fits in file */
    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
    if (rows <= 0)		/* this chunk might be past end of file! */
      break;
    byte_count = rows * bytesperrow;
    if (writing)
      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
					    (void FAR *) ptr->mem_buffer[i],
					    file_offset, byte_count);
    else
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
					   (void FAR *) ptr->mem_buffer[i],
					   file_offset, byte_count);
    file_offset += byte_count;
  }
}


METHODDEF(JSAMPARRAY)
access_virt_sarray (j_common_ptr cinfo, jvirt_sarray_ptr ptr,
		    JDIMENSION start_row, JDIMENSION num_rows,
		    boolean writable)
/* Access the part of a virtual sample array starting at start_row */
/* and extending for num_rows rows.  writable is true if  */
/* caller intends to modify the accessed area. */
{
  JDIMENSION end_row = start_row + num_rows;
  JDIMENSION undef_row;

  /* debugging check */
  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
      ptr->mem_buffer == NULL)
    ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);

  /* Make the desired part of the virtual array accessible */
  if (start_row < ptr->cur_start_row ||
      end_row > ptr->cur_start_row+ptr->rows_in_mem) {
      ERREXIT(cinfo, JERR_VIRTUAL_BUG);
  }
  /* Ensure the accessed part of the array is defined; prezero if needed.
   * To improve locality of access, we only prezero the part of the array
   * that the caller is about to access, not the entire in-memory array.
   */
  if (ptr->first_undef_row < end_row) {
    if (ptr->first_undef_row < start_row) {
      if (writable)		/* writer skipped over a section of array */
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
      undef_row = start_row;	/* but reader is allowed to read ahead */
    } else {
      undef_row = ptr->first_undef_row;
    }
    if (writable)
      ptr->first_undef_row = end_row;
    if (ptr->pre_zero) {
      size_t bytesperrow = (size_t) ptr->samplesperrow * SIZEOF(JSAMPLE);
      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
      end_row -= ptr->cur_start_row;
      while (undef_row < end_row) {
	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
	undef_row++;
      }
    } else {
      if (! writable)		/* reader looking at undefined data */
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
    }
  }
  /* Flag the buffer dirty if caller will write in it */
  if (writable)
    ptr->dirty = TRUE;
  /* Return address of proper part of the buffer */
  return ptr->mem_buffer + (start_row - ptr->cur_start_row);
}


METHODDEF(JBLOCKARRAY)
access_virt_barray (j_common_ptr cinfo, jvirt_barray_ptr ptr,
		    JDIMENSION start_row, JDIMENSION num_rows,
		    boolean writable)
/* Access the part of a virtual block array starting at start_row */
/* and extending for num_rows rows.  writable is true if  */
/* caller intends to modify the accessed area. */
{
  JDIMENSION end_row = start_row + num_rows;
  JDIMENSION undef_row;

  /* debugging check */
  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
      ptr->mem_buffer == NULL)
    ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);

  /* Make the desired part of the virtual array accessible */
  if (start_row < ptr->cur_start_row ||
      end_row > ptr->cur_start_row+ptr->rows_in_mem) {
      ERREXIT(cinfo, JERR_VIRTUAL_BUG);
  }
  /* Ensure the accessed part of the array is defined; prezero if needed.
   * To improve locality of access, we only prezero the part of the array
   * that the caller is about to access, not the entire in-memory array.
   */
  if (ptr->first_undef_row < end_row) {
    if (ptr->first_undef_row < start_row) {
      if (writable)		/* writer skipped over a section of array */
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
      undef_row = start_row;	/* but reader is allowed to read ahead */
    } else {
      undef_row = ptr->first_undef_row;
    }
    if (writable)
      ptr->first_undef_row = end_row;
    if (ptr->pre_zero) {
      size_t bytesperrow = (size_t) ptr->blocksperrow * SIZEOF(JBLOCK);
      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
      end_row -= ptr->cur_start_row;
      while (undef_row < end_row) {
	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
	undef_row++;
      }
    } else {
      if (! writable)		/* reader looking at undefined data */
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
    }
  }
  /* Flag the buffer dirty if caller will write in it */
  if (writable)
    ptr->dirty = TRUE;
  /* Return address of proper part of the buffer */
  return ptr->mem_buffer + (start_row - ptr->cur_start_row);
}


/*
 * Release all objects belonging to a specified pool.
 */

METHODDEF(void)
free_pool (j_common_ptr cinfo, int pool_id)
{
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
  small_pool_ptr shdr_ptr;
  large_pool_ptr lhdr_ptr;
  size_t space_freed;

  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */

#ifdef MEM_STATS
  if (cinfo->err->trace_level > 1)
    print_mem_stats(cinfo, pool_id); /* print pool's memory usage statistics */
#endif

  /* If freeing IMAGE pool, close any virtual arrays first */
  if (pool_id == JPOOL_IMAGE) {
    jvirt_sarray_ptr sptr;
    jvirt_barray_ptr bptr;

    for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
    }
    mem->virt_sarray_list = NULL;
    for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
    }
    mem->virt_barray_list = NULL;
  }

  /* Release large objects */
  lhdr_ptr = mem->large_list[pool_id];
  mem->large_list[pool_id] = NULL;

  while (lhdr_ptr != NULL) {
    large_pool_ptr next_lhdr_ptr = lhdr_ptr->hdr.next;
    space_freed = lhdr_ptr->hdr.bytes_used +
		  lhdr_ptr->hdr.bytes_left +
		  SIZEOF(large_pool_hdr);
    jpeg_free_large(cinfo, (void FAR *) lhdr_ptr, space_freed);
#ifdef _WIN64
    mem->total_space_allocated -= (long)space_freed; //!!WIN64 shouldn't need to cast - BENCH
#else //!_WIN64
    mem->total_space_allocated -= space_freed;
#endif
    lhdr_ptr = next_lhdr_ptr;
  }

  /* Release small objects */
  shdr_ptr = mem->small_list[pool_id];
  mem->small_list[pool_id] = NULL;

  while (shdr_ptr != NULL) {
    small_pool_ptr next_shdr_ptr = shdr_ptr->hdr.next;
    space_freed = shdr_ptr->hdr.bytes_used +
		  shdr_ptr->hdr.bytes_left +
		  SIZEOF(small_pool_hdr);
    jpeg_free_small(cinfo, (void *) shdr_ptr, space_freed);
#ifdef _WIN64
    mem->total_space_allocated -= (long)space_freed; //!!WIN64 shouldn't need to cast - BENCH
#else //!_WIN64
    mem->total_space_allocated -= space_freed;
#endif
    shdr_ptr = next_shdr_ptr;
  }
}


/*
 * Close up shop entirely.
 * Note that this cannot be called unless cinfo->mem is non-NULL.
 */

METHODDEF(void)
self_destruct (j_common_ptr cinfo)
{
  int pool;

  /* Close all backing store, release all memory.
   * Releasing pools in reverse order might help avoid fragmentation
   * with some malloc libraries.
   */
  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
    free_pool(cinfo, pool);
  }

  /* Release the memory manager control block too. */
  jpeg_free_small(cinfo, (void *) cinfo->mem, SIZEOF(my_memory_mgr));
  cinfo->mem = NULL;		/* ensures I will be called only once */

  jpeg_mem_term(cinfo);		/* system-dependent cleanup */
}


/*
 * Memory manager initialization.
 * When this is called, only the error manager pointer is valid in cinfo!
 */

GLOBAL(void)
jinit_memory_mgr (j_common_ptr cinfo)
{
  my_mem_ptr mem;
  long max_to_use;
  int pool;
  size_t test_mac;

  cinfo->mem = NULL;		/* for safety if init fails */

  /* Check for configuration errors.
   * SIZEOF(ALIGN_TYPE) should be a power of 2; otherwise, it probably
   * doesn't reflect any real hardware alignment requirement.
   * The test is a little tricky: for X>0, X and X-1 have no one-bits
   * in common if and only if X is a power of 2, ie has only one one-bit.
   * Some compilers may give an "unreachable code" warning here; ignore it.
   */
  if ((SIZEOF(ALIGN_TYPE) & (SIZEOF(ALIGN_TYPE)-1)) != 0)
    ERREXIT(cinfo, JERR_BAD_ALIGN_TYPE);
  /* MAX_ALLOC_CHUNK must be representable as type size_t, and must be
   * a multiple of SIZEOF(ALIGN_TYPE).
   * Again, an "unreachable code" warning may be ignored here.
   * But a "constant too large" warning means you need to fix MAX_ALLOC_CHUNK.
   */
  test_mac = (size_t) MAX_ALLOC_CHUNK;
  if ((long) test_mac != MAX_ALLOC_CHUNK ||
      (MAX_ALLOC_CHUNK % SIZEOF(ALIGN_TYPE)) != 0)
    ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);

  max_to_use = jpeg_mem_init(cinfo); /* system-dependent initialization */

  /* Attempt to allocate memory manager's control block */
  mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));

  if (mem == NULL) {
    jpeg_mem_term(cinfo);	/* system-dependent cleanup */
    ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);
  }

  /* OK, fill in the method pointers */
  mem->pub.alloc_small = alloc_small;
  mem->pub.alloc_large = alloc_large;
  mem->pub.alloc_sarray = alloc_sarray;
  mem->pub.alloc_barray = alloc_barray;
  mem->pub.request_virt_sarray = request_virt_sarray;
  mem->pub.request_virt_barray = request_virt_barray;
  mem->pub.realize_virt_arrays = realize_virt_arrays;
  mem->pub.access_virt_sarray = access_virt_sarray;
  mem->pub.access_virt_barray = access_virt_barray;
  mem->pub.free_pool = free_pool;
  mem->pub.self_destruct = self_destruct;

  /* Initialize working state */
  mem->pub.max_memory_to_use = max_to_use;

  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
    mem->small_list[pool] = NULL;
    mem->large_list[pool] = NULL;
  }
  mem->virt_sarray_list = NULL;
  mem->virt_barray_list = NULL;

  mem->total_space_allocated = SIZEOF(my_memory_mgr);

  /* Declare ourselves open for business */
  cinfo->mem = & mem->pub;

  /* Check for an environment variable JPEGMEM; if found, override the
   * default max_memory setting from jpeg_mem_init.  Note that the
   * surrounding application may again override this value.
   * If your system doesn't support getenv(), define NO_GETENV to disable
   * this feature.
   */
#ifndef NO_GETENV
  { char * memenv;

    if ((memenv = getenv("JPEGMEM")) != NULL) {
      char ch = 'x';

      if (sscanf(memenv, "%ld%c", &max_to_use, &ch) > 0) {
	if (ch == 'm' || ch == 'M')
	  max_to_use *= 1000L;
	mem->pub.max_memory_to_use = max_to_use * 1000L;
      }
    }
  }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jcomapi.c ===
/*
 * jcomapi.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains application interface routines that are used for both
 * compression and decompression.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/*
 * Abort processing of a JPEG compression or decompression operation,
 * but don't destroy the object itself.
 *
 * For this, we merely clean up all the nonpermanent memory pools.
 * Note that temp files (virtual arrays) are not allowed to belong to
 * the permanent pool, so we will be able to close all temp files here.
 * Closing a data source or destination, if necessary, is the application's
 * responsibility.
 */

GLOBAL(void)
jpeg_abort (j_common_ptr cinfo)
{
  int pool;

  /* Releasing pools in reverse order might help avoid fragmentation
   * with some malloc libraries.
   */
  for (pool = JPOOL_NUMPOOLS-1; pool > JPOOL_PERMANENT; pool--) {
    (*cinfo->mem->free_pool) (cinfo, pool);
  }

  /* Reset overall state for possible reuse of object */
  cinfo->global_state = (cinfo->is_decompressor ? DSTATE_START : CSTATE_START);
}


/*
 * Destruction of a JPEG object.
 *
 * Everything gets deallocated except the master jpeg_compress_struct itself
 * and the error manager struct.  Both of these are supplied by the application
 * and must be freed, if necessary, by the application.  (Often they are on
 * the stack and so don't need to be freed anyway.)
 * Closing a data source or destination, if necessary, is the application's
 * responsibility.
 */

GLOBAL(void)
jpeg_destroy (j_common_ptr cinfo)
{
  /* We need only tell the memory manager to release everything. */
  /* NB: mem pointer is NULL if memory mgr failed to initialize. */
  if (cinfo->mem != NULL)
    (*cinfo->mem->self_destruct) (cinfo);
  cinfo->mem = NULL;		/* be safe if jpeg_destroy is called twice */
  cinfo->global_state = 0;	/* mark it destroyed */
}


/*
 * Convenience routines for allocating quantization and Huffman tables.
 * (Would jutils.c be a more reasonable place to put these?)
 */

GLOBAL(JQUANT_TBL *)
jpeg_alloc_quant_table (j_common_ptr cinfo)
{
  JQUANT_TBL *tbl;

  tbl = (JQUANT_TBL *)
    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JQUANT_TBL));
  tbl->sent_table = FALSE;	/* make sure this is false in any new table */
  return tbl;
}


GLOBAL(JHUFF_TBL *)
jpeg_alloc_huff_table (j_common_ptr cinfo)
{
  JHUFF_TBL *tbl;

  tbl = (JHUFF_TBL *)
    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JHUFF_TBL));
  tbl->sent_table = FALSE;	/* make sure this is false in any new table */
  return tbl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jdcoefct.c ===
/*
 * jdcoefct.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains the coefficient buffer controller for decompression.
 * This controller is the top level of the JPEG decompressor proper.
 * The coefficient buffer lies between entropy decoding and inverse-DCT steps.
 *
 * In buffered-image mode, this controller is the interface between
 * input-oriented processing and output-oriented processing.
 * Also, the input side (only) is used when reading a file for transcoding.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"

/* Block smoothing is only applicable for progressive JPEG, so: */
#ifndef D_PROGRESSIVE_SUPPORTED
#undef BLOCK_SMOOTHING_SUPPORTED
#endif

/* Private buffer controller object */

typedef struct {
  struct jpeg_d_coef_controller pub; /* public fields */

  /* These variables keep track of the current location of the input side. */
  /* cinfo->input_iMCU_row is also used for this. */
  JDIMENSION MCU_ctr;		/* counts MCUs processed in current row */
  int MCU_vert_offset;		/* counts MCU rows within iMCU row */
  int MCU_rows_per_iMCU_row;	/* number of such rows needed */

  /* The output side's location is represented by cinfo->output_iMCU_row. */

  /* In single-pass modes, it's sufficient to buffer just one MCU.
   * We allocate a workspace of D_MAX_BLOCKS_IN_MCU coefficient blocks,
   * and let the entropy decoder write into that workspace each time.
   * (On 80x86, the workspace is FAR even though it's not really very big;
   * this is to keep the module interfaces unchanged when a large coefficient
   * buffer is necessary.)
   * In multi-pass modes, this array points to the current MCU's blocks
   * within the virtual arrays; it is used only by the input side.
   */
  JBLOCKROW MCU_buffer[D_MAX_BLOCKS_IN_MCU];

#ifdef D_MULTISCAN_FILES_SUPPORTED
  /* In multi-pass modes, we need a virtual block array for each component. */
  jvirt_barray_ptr whole_image[MAX_COMPONENTS];
#endif

#ifdef BLOCK_SMOOTHING_SUPPORTED
  /* When doing block smoothing, we latch coefficient Al values here */
  int * coef_bits_latch;
#define SAVED_COEFS  6		/* we save coef_bits[0..5] */
#endif
} my_coef_controller;

typedef my_coef_controller * my_coef_ptr;

/* Forward declarations */
METHODDEF(int) decompress_onepass
	JPP((j_decompress_ptr cinfo, JSAMPIMAGE output_buf));
#ifdef D_MULTISCAN_FILES_SUPPORTED
METHODDEF(int) decompress_data
	JPP((j_decompress_ptr cinfo, JSAMPIMAGE output_buf));
#endif
#ifdef BLOCK_SMOOTHING_SUPPORTED
LOCAL(boolean) smoothing_ok JPP((j_decompress_ptr cinfo));
METHODDEF(int) decompress_smooth_data
	JPP((j_decompress_ptr cinfo, JSAMPIMAGE output_buf));
#endif


LOCAL(void)
start_iMCU_row (j_decompress_ptr cinfo)
/* Reset within-iMCU-row counters for a new row (input side) */
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;

  /* In an interleaved scan, an MCU row is the same as an iMCU row.
   * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
   * But at the bottom of the image, process only what's left.
   */
  if (cinfo->comps_in_scan > 1) {
    coef->MCU_rows_per_iMCU_row = 1;
  } else {
    if (cinfo->input_iMCU_row < (cinfo->total_iMCU_rows-1))
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
    else
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
  }

  coef->MCU_ctr = 0;
  coef->MCU_vert_offset = 0;
}


/*
 * Initialize for an input processing pass.
 */

METHODDEF(void)
start_input_pass (j_decompress_ptr cinfo)
{
  cinfo->input_iMCU_row = 0;
  start_iMCU_row(cinfo);
}


/*
 * Initialize for an output processing pass.
 */

METHODDEF(void)
start_output_pass (j_decompress_ptr cinfo)
{
#ifdef BLOCK_SMOOTHING_SUPPORTED
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;

  /* If multipass, check to see whether to use block smoothing on this pass */
  if (coef->pub.coef_arrays != NULL) {
    if (cinfo->do_block_smoothing && smoothing_ok(cinfo))
      coef->pub.decompress_data = decompress_smooth_data;
    else
      coef->pub.decompress_data = decompress_data;
  }
#endif
  cinfo->output_iMCU_row = 0;
}


/*
 * Decompress and return some data in the single-pass case.
 * Always attempts to emit one fully interleaved MCU row ("iMCU" row).
 * Input and output must run in lockstep since we have only a one-MCU buffer.
 * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
 *
 * NB: output_buf contains a plane for each component in image.
 * For single pass, this is the same as the components in the scan.
 */

METHODDEF(int)
decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION MCU_col_num;	/* index of current MCU within row */
  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
  int blkn, ci, xindex, yindex, yoffset, useful_width;
  JSAMPARRAY output_ptr;
  JDIMENSION start_col, output_col;
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;

  /* Loop to process as much as one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
	 MCU_col_num++) {
      /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
      jzero_far((void FAR *) coef->MCU_buffer[0],
		(size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));
      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
	coef->MCU_ctr = MCU_col_num;
	return JPEG_SUSPENDED;
      }
      /* Determine where data should go in output_buf and do the IDCT thing.
       * We skip dummy blocks at the right and bottom edges (but blkn gets
       * incremented past them!).  Note the inner loop relies on having
       * allocated the MCU_buffer[] blocks sequentially.
       */
      blkn = 0;			/* index of current DCT block within MCU */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
	compptr = cinfo->cur_comp_info[ci];
	/* Don't bother to IDCT an uninteresting component. */
	if (! compptr->component_needed) {
	  blkn += compptr->MCU_blocks;
	  continue;
	}
	inverse_DCT = cinfo->idct->inverse_DCT[compptr->component_index];
	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
						    : compptr->last_col_width;
	output_ptr = output_buf[ci] + yoffset * compptr->DCT_scaled_size;
	start_col = MCU_col_num * compptr->MCU_sample_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  if (cinfo->input_iMCU_row < last_iMCU_row ||
	      yoffset+yindex < compptr->last_row_height) {
	    output_col = start_col;
	    for (xindex = 0; xindex < useful_width; xindex++) {
	      (*inverse_DCT) (cinfo, compptr,
			      (JCOEFPTR) coef->MCU_buffer[blkn+xindex],
			      output_ptr, output_col);
	      output_col += compptr->DCT_scaled_size;
	    }
	  }
	  blkn += compptr->MCU_width;
	  output_ptr += compptr->DCT_scaled_size;
	}
      }
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->MCU_ctr = 0;
  }
  /* Completed the iMCU row, advance counters for next one */
  cinfo->output_iMCU_row++;
  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
    start_iMCU_row(cinfo);
    return JPEG_ROW_COMPLETED;
  }
  /* Completed the scan */
  (*cinfo->inputctl->finish_input_pass) (cinfo);
  return JPEG_SCAN_COMPLETED;
}


/*
 * Dummy consume-input routine for single-pass operation.
 */

METHODDEF(int)
dummy_consume_data (j_decompress_ptr cinfo)
{
  return JPEG_SUSPENDED;	/* Always indicate nothing was done */
}


#ifdef D_MULTISCAN_FILES_SUPPORTED

/*
 * Consume input data and store it in the full-image coefficient buffer.
 * We read as much as one fully interleaved MCU row ("iMCU" row) per call,
 * ie, v_samp_factor block rows for each component in the scan.
 * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
 */

METHODDEF(int)
consume_data (j_decompress_ptr cinfo)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION MCU_col_num;	/* index of current MCU within row */
  int blkn, ci, xindex, yindex, yoffset;
  JDIMENSION start_col;
  JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];
  JBLOCKROW buffer_ptr;
  jpeg_component_info *compptr;

  /* Align the virtual buffers for the components used in this scan. */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
    buffer[ci] = (*cinfo->mem->access_virt_barray)
      ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
       cinfo->input_iMCU_row * compptr->v_samp_factor,
       (JDIMENSION) compptr->v_samp_factor, TRUE);
    /* Note: entropy decoder expects buffer to be zeroed,
     * but this is handled automatically by the memory manager
     * because we requested a pre-zeroed array.
     */
  }

  /* Loop to process one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
	 MCU_col_num++) {
      /* Construct list of pointers to DCT blocks belonging to this MCU */
      blkn = 0;			/* index of current DCT block within MCU */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
	compptr = cinfo->cur_comp_info[ci];
	start_col = MCU_col_num * compptr->MCU_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
	    coef->MCU_buffer[blkn++] = buffer_ptr++;
	  }
	}
      }
      /* Try to fetch the MCU. */
      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
	coef->MCU_ctr = MCU_col_num;
	return JPEG_SUSPENDED;
      }
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->MCU_ctr = 0;
  }
  /* Completed the iMCU row, advance counters for next one */
  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
    start_iMCU_row(cinfo);
    return JPEG_ROW_COMPLETED;
  }
  /* Completed the scan */
  (*cinfo->inputctl->finish_input_pass) (cinfo);
  return JPEG_SCAN_COMPLETED;
}


/*
 * Decompress and return some data in the multi-pass case.
 * Always attempts to emit one fully interleaved MCU row ("iMCU" row).
 * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
 *
 * NB: output_buf contains a plane for each component in image.
 */

METHODDEF(int)
decompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
  JDIMENSION block_num;
  int ci, block_row, block_rows;
  JBLOCKARRAY buffer;
  JBLOCKROW buffer_ptr;
  JSAMPARRAY output_ptr;
  JDIMENSION output_col;
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;

  /* Force some input to be done if we are getting ahead of the input. */
  while (cinfo->input_scan_number < cinfo->output_scan_number ||
	 (cinfo->input_scan_number == cinfo->output_scan_number &&
	  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {
    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
      return JPEG_SUSPENDED;
  }

  /* OK, output from the virtual arrays. */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Don't bother to IDCT an uninteresting component. */
    if (! compptr->component_needed)
      continue;
    /* Align the virtual buffer for this component. */
    buffer = (*cinfo->mem->access_virt_barray)
      ((j_common_ptr) cinfo, coef->whole_image[ci],
       cinfo->output_iMCU_row * compptr->v_samp_factor,
       (JDIMENSION) compptr->v_samp_factor, FALSE);
    /* Count non-dummy DCT block rows in this iMCU row. */
    if (cinfo->output_iMCU_row < last_iMCU_row)
      block_rows = compptr->v_samp_factor;
    else {
      /* NB: can't use last_row_height here; it is input-side-dependent! */
      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
      if (block_rows == 0) block_rows = compptr->v_samp_factor;
    }
    inverse_DCT = cinfo->idct->inverse_DCT[ci];
    output_ptr = output_buf[ci];
    /* Loop over all DCT blocks to be processed. */
    for (block_row = 0; block_row < block_rows; block_row++) {
      buffer_ptr = buffer[block_row];
      output_col = 0;
      for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {
	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) buffer_ptr,
			output_ptr, output_col);
	buffer_ptr++;
	output_col += compptr->DCT_scaled_size;
      }
      output_ptr += compptr->DCT_scaled_size;
    }
  }

  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
    return JPEG_ROW_COMPLETED;
  return JPEG_SCAN_COMPLETED;
}

#endif /* D_MULTISCAN_FILES_SUPPORTED */


#ifdef BLOCK_SMOOTHING_SUPPORTED

/*
 * This code applies interblock smoothing as described by section K.8
 * of the JPEG standard: the first 5 AC coefficients are estimated from
 * the DC values of a DCT block and its 8 neighboring blocks.
 * We apply smoothing only for progressive JPEG decoding, and only if
 * the coefficients it can estimate are not yet known to full precision.
 */

/* Natural-order array positions of the first 5 zigzag-order coefficients */
#define Q01_POS  1
#define Q10_POS  8
#define Q20_POS  16
#define Q11_POS  9
#define Q02_POS  2

/*
 * Determine whether block smoothing is applicable and safe.
 * We also latch the current states of the coef_bits[] entries for the
 * AC coefficients; otherwise, if the input side of the decompressor
 * advances into a new scan, we might think the coefficients are known
 * more accurately than they really are.
 */

LOCAL(boolean)
smoothing_ok (j_decompress_ptr cinfo)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  boolean smoothing_useful = FALSE;
  int ci, coefi;
  jpeg_component_info *compptr;
  JQUANT_TBL * qtable;
  int * coef_bits;
  int * coef_bits_latch;

  if (! cinfo->progressive_mode || cinfo->coef_bits == NULL)
    return FALSE;

  /* Allocate latch area if not already done */
  if (coef->coef_bits_latch == NULL)
    coef->coef_bits_latch = (int *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  cinfo->num_components *
				  (SAVED_COEFS * SIZEOF(int)));
  coef_bits_latch = coef->coef_bits_latch;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* All components' quantization values must already be latched. */
    if ((qtable = compptr->quant_table) == NULL)
      return FALSE;
    /* Verify DC & first 5 AC quantizers are nonzero to avoid zero-divide. */
    if (qtable->quantval[0] == 0 ||
	qtable->quantval[Q01_POS] == 0 ||
	qtable->quantval[Q10_POS] == 0 ||
	qtable->quantval[Q20_POS] == 0 ||
	qtable->quantval[Q11_POS] == 0 ||
	qtable->quantval[Q02_POS] == 0)
      return FALSE;
    /* DC values must be at least partly known for all components. */
    coef_bits = cinfo->coef_bits[ci];
    if (coef_bits[0] < 0)
      return FALSE;
    /* Block smoothing is helpful if some AC coefficients remain inaccurate. */
    for (coefi = 1; coefi <= 5; coefi++) {
      coef_bits_latch[coefi] = coef_bits[coefi];
      if (coef_bits[coefi] != 0)
	smoothing_useful = TRUE;
    }
    coef_bits_latch += SAVED_COEFS;
  }

  return smoothing_useful;
}


/*
 * Variant of decompress_data for use when doing block smoothing.
 */

METHODDEF(int)
decompress_smooth_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
  JDIMENSION block_num, last_block_column;
  int ci, block_row, block_rows, access_rows;
  JBLOCKARRAY buffer;
  JBLOCKROW buffer_ptr, prev_block_row, next_block_row;
  JSAMPARRAY output_ptr;
  JDIMENSION output_col;
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;
  boolean first_row, last_row;
  JBLOCK workspace;
  int *coef_bits;
  JQUANT_TBL *quanttbl;
  INT32 Q00,Q01,Q02,Q10,Q11,Q20, num;
  int DC1,DC2,DC3,DC4,DC5,DC6,DC7,DC8,DC9;
  int Al, pred;

  /* Force some input to be done if we are getting ahead of the input. */
  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
	 ! cinfo->inputctl->eoi_reached) {
    if (cinfo->input_scan_number == cinfo->output_scan_number) {
      /* If input is working on current scan, we ordinarily want it to
       * have completed the current row.  But if input scan is DC,
       * we want it to keep one row ahead so that next block row's DC
       * values are up to date.
       */
      JDIMENSION delta = (cinfo->Ss == 0) ? 1 : 0;
      if (cinfo->input_iMCU_row > cinfo->output_iMCU_row+delta)
	break;
    }
    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
      return JPEG_SUSPENDED;
  }

  /* OK, output from the virtual arrays. */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Don't bother to IDCT an uninteresting component. */
    if (! compptr->component_needed)
      continue;
    /* Count non-dummy DCT block rows in this iMCU row. */
    if (cinfo->output_iMCU_row < last_iMCU_row) {
      block_rows = compptr->v_samp_factor;
      access_rows = block_rows * 2; /* this and next iMCU row */
      last_row = FALSE;
    } else {
      /* NB: can't use last_row_height here; it is input-side-dependent! */
      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
      if (block_rows == 0) block_rows = compptr->v_samp_factor;
      access_rows = block_rows; /* this iMCU row only */
      last_row = TRUE;
    }
    /* Align the virtual buffer for this component. */
    if (cinfo->output_iMCU_row > 0) {
      access_rows += compptr->v_samp_factor; /* prior iMCU row too */
      buffer = (*cinfo->mem->access_virt_barray)
	((j_common_ptr) cinfo, coef->whole_image[ci],
	 (cinfo->output_iMCU_row - 1) * compptr->v_samp_factor,
	 (JDIMENSION) access_rows, FALSE);
      buffer += compptr->v_samp_factor;	/* point to current iMCU row */
      first_row = FALSE;
    } else {
      buffer = (*cinfo->mem->access_virt_barray)
	((j_common_ptr) cinfo, coef->whole_image[ci],
	 (JDIMENSION) 0, (JDIMENSION) access_rows, FALSE);
      first_row = TRUE;
    }
    /* Fetch component-dependent info */
    coef_bits = coef->coef_bits_latch + (ci * SAVED_COEFS);
    quanttbl = compptr->quant_table;
    Q00 = quanttbl->quantval[0];
    Q01 = quanttbl->quantval[Q01_POS];
    Q10 = quanttbl->quantval[Q10_POS];
    Q20 = quanttbl->quantval[Q20_POS];
    Q11 = quanttbl->quantval[Q11_POS];
    Q02 = quanttbl->quantval[Q02_POS];
    inverse_DCT = cinfo->idct->inverse_DCT[ci];
    output_ptr = output_buf[ci];
    /* Loop over all DCT blocks to be processed. */
    for (block_row = 0; block_row < block_rows; block_row++) {
      buffer_ptr = buffer[block_row];
      if (first_row && block_row == 0)
	prev_block_row = buffer_ptr;
      else
	prev_block_row = buffer[block_row-1];
      if (last_row && block_row == block_rows-1)
	next_block_row = buffer_ptr;
      else
	next_block_row = buffer[block_row+1];
      /* We fetch the surrounding DC values using a sliding-register approach.
       * Initialize all nine here so as to do the right thing on narrow pics.
       */
      DC1 = DC2 = DC3 = (int) prev_block_row[0][0];
      DC4 = DC5 = DC6 = (int) buffer_ptr[0][0];
      DC7 = DC8 = DC9 = (int) next_block_row[0][0];
      output_col = 0;
      last_block_column = compptr->width_in_blocks - 1;
      for (block_num = 0; block_num <= last_block_column; block_num++) {
	/* Fetch current DCT block into workspace so we can modify it. */
	jcopy_block_row(buffer_ptr, (JBLOCKROW) workspace, (JDIMENSION) 1);
	/* Update DC values */
	if (block_num < last_block_column) {
	  DC3 = (int) prev_block_row[1][0];
	  DC6 = (int) buffer_ptr[1][0];
	  DC9 = (int) next_block_row[1][0];
	}
	/* Compute coefficient estimates per K.8.
	 * An estimate is applied only if coefficient is still zero,
	 * and is not known to be fully accurate.
	 */
	/* AC01 */
	if ((Al=coef_bits[1]) != 0 && workspace[1] == 0) {
	  num = 36 * Q00 * (DC4 - DC6);
	  if (num >= 0) {
	    pred = (int) (((Q01<<7) + num) / (Q01<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	  } else {
	    pred = (int) (((Q01<<7) - num) / (Q01<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	    pred = -pred;
	  }
	  workspace[1] = (JCOEF) pred;
	}
	/* AC10 */
	if ((Al=coef_bits[2]) != 0 && workspace[8] == 0) {
	  num = 36 * Q00 * (DC2 - DC8);
	  if (num >= 0) {
	    pred = (int) (((Q10<<7) + num) / (Q10<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	  } else {
	    pred = (int) (((Q10<<7) - num) / (Q10<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	    pred = -pred;
	  }
	  workspace[8] = (JCOEF) pred;
	}
	/* AC20 */
	if ((Al=coef_bits[3]) != 0 && workspace[16] == 0) {
	  num = 9 * Q00 * (DC2 + DC8 - 2*DC5);
	  if (num >= 0) {
	    pred = (int) (((Q20<<7) + num) / (Q20<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	  } else {
	    pred = (int) (((Q20<<7) - num) / (Q20<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	    pred = -pred;
	  }
	  workspace[16] = (JCOEF) pred;
	}
	/* AC11 */
	if ((Al=coef_bits[4]) != 0 && workspace[9] == 0) {
	  num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);
	  if (num >= 0) {
	    pred = (int) (((Q11<<7) + num) / (Q11<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	  } else {
	    pred = (int) (((Q11<<7) - num) / (Q11<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	    pred = -pred;
	  }
	  workspace[9] = (JCOEF) pred;
	}
	/* AC02 */
	if ((Al=coef_bits[5]) != 0 && workspace[2] == 0) {
	  num = 9 * Q00 * (DC4 + DC6 - 2*DC5);
	  if (num >= 0) {
	    pred = (int) (((Q02<<7) + num) / (Q02<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	  } else {
	    pred = (int) (((Q02<<7) - num) / (Q02<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	    pred = -pred;
	  }
	  workspace[2] = (JCOEF) pred;
	}
	/* OK, do the IDCT */
	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) workspace,
			output_ptr, output_col);
	/* Advance for next column */
	DC1 = DC2; DC2 = DC3;
	DC4 = DC5; DC5 = DC6;
	DC7 = DC8; DC8 = DC9;
	buffer_ptr++, prev_block_row++, next_block_row++;
	output_col += compptr->DCT_scaled_size;
      }
      output_ptr += compptr->DCT_scaled_size;
    }
  }

  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
    return JPEG_ROW_COMPLETED;
  return JPEG_SCAN_COMPLETED;
}

#endif /* BLOCK_SMOOTHING_SUPPORTED */


/*
 * Initialize coefficient buffer controller.
 */

GLOBAL(void)
jinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
{
  my_coef_ptr coef;

  coef = (my_coef_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_coef_controller));
  cinfo->coef = (struct jpeg_d_coef_controller *) coef;
  coef->pub.start_input_pass = start_input_pass;
  coef->pub.start_output_pass = start_output_pass;
#ifdef BLOCK_SMOOTHING_SUPPORTED
  coef->coef_bits_latch = NULL;
#endif

  /* Create the coefficient buffer. */
  if (need_full_buffer) {
#ifdef D_MULTISCAN_FILES_SUPPORTED
    /* Allocate a full-image virtual array for each component, */
    /* padded to a multiple of samp_factor DCT blocks in each direction. */
    /* Note we ask for a pre-zeroed array. */
    int ci, access_rows;
    jpeg_component_info *compptr;

    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
	 ci++, compptr++) {
      access_rows = compptr->v_samp_factor;
#ifdef BLOCK_SMOOTHING_SUPPORTED
      /* If block smoothing could be used, need a bigger window */
      if (cinfo->progressive_mode)
	access_rows *= 3;
#endif
      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
	((j_common_ptr) cinfo, JPOOL_IMAGE, TRUE,
	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
				(long) compptr->h_samp_factor),
	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
				(long) compptr->v_samp_factor),
	 (JDIMENSION) access_rows);
    }
    coef->pub.consume_data = consume_data;
    coef->pub.decompress_data = decompress_data;
    coef->pub.coef_arrays = coef->whole_image; /* link to virtual arrays */
#else
    ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
  } else {
    /* We only need a single-MCU buffer. */
    JBLOCKROW buffer;
    int i;

    buffer = (JBLOCKROW)
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  D_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));
    for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {
      coef->MCU_buffer[i] = buffer + i;
    }
    coef->pub.consume_data = dummy_consume_data;
    coef->pub.decompress_data = decompress_onepass;
    coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jcparam.c ===
/*
 * jcparam.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains optional default-setting code for the JPEG compressor.
 * Applications do not have to use this file, but those that don't use it
 * must know a lot more about the innards of the JPEG code.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/*
 * Quantization table setup routines
 */

GLOBAL(void)
jpeg_add_quant_table (j_compress_ptr cinfo, int which_tbl,
		      const unsigned int *basic_table,
		      int scale_factor, boolean force_baseline)
/* Define a quantization table equal to the basic_table times
 * a scale factor (given as a percentage).
 * If force_baseline is TRUE, the computed quantization table entries
 * are limited to 1..255 for JPEG baseline compatibility.
 */
{
  JQUANT_TBL ** qtblptr = & cinfo->quant_tbl_ptrs[which_tbl];
  int i;
  long temp;

  /* Safety check to ensure start_compress not called yet. */
  if (cinfo->global_state != CSTATE_START)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  if (*qtblptr == NULL)
    *qtblptr = jpeg_alloc_quant_table((j_common_ptr) cinfo);

  for (i = 0; i < DCTSIZE2; i++) {
    temp = ((long) basic_table[i] * scale_factor + 50L) / 100L;
    /* limit the values to the valid range */
    if (temp <= 0L) temp = 1L;
    if (temp > 32767L) temp = 32767L; /* max quantizer needed for 12 bits */
    if (force_baseline && temp > 255L)
      temp = 255L;		/* limit to baseline range if requested */
    (*qtblptr)->quantval[i] = (UINT16) temp;
  }

  /* Initialize sent_table FALSE so table will be written to JPEG file. */
  (*qtblptr)->sent_table = FALSE;
}


GLOBAL(void)
jpeg_set_linear_quality (j_compress_ptr cinfo, int scale_factor,
			 boolean force_baseline)
/* Set or change the 'quality' (quantization) setting, using default tables
 * and a straight percentage-scaling quality scale.  In most cases it's better
 * to use jpeg_set_quality (below); this entry point is provided for
 * applications that insist on a linear percentage scaling.
 */
{
  /* These are the sample quantization tables given in JPEG spec section K.1.
   * The spec says that the values given produce "good" quality, and
   * when divided by 2, "very good" quality.
   */
  static const unsigned int std_luminance_quant_tbl[DCTSIZE2] = {
    16,  11,  10,  16,  24,  40,  51,  61,
    12,  12,  14,  19,  26,  58,  60,  55,
    14,  13,  16,  24,  40,  57,  69,  56,
    14,  17,  22,  29,  51,  87,  80,  62,
    18,  22,  37,  56,  68, 109, 103,  77,
    24,  35,  55,  64,  81, 104, 113,  92,
    49,  64,  78,  87, 103, 121, 120, 101,
    72,  92,  95,  98, 112, 100, 103,  99
  };
  static const unsigned int std_chrominance_quant_tbl[DCTSIZE2] = {
    17,  18,  24,  47,  99,  99,  99,  99,
    18,  21,  26,  66,  99,  99,  99,  99,
    24,  26,  56,  99,  99,  99,  99,  99,
    47,  66,  99,  99,  99,  99,  99,  99,
    99,  99,  99,  99,  99,  99,  99,  99,
    99,  99,  99,  99,  99,  99,  99,  99,
    99,  99,  99,  99,  99,  99,  99,  99,
    99,  99,  99,  99,  99,  99,  99,  99
  };

  /* Set up two quantization tables using the specified scaling */
  jpeg_add_quant_table(cinfo, 0, std_luminance_quant_tbl,
		       scale_factor, force_baseline);
  jpeg_add_quant_table(cinfo, 1, std_chrominance_quant_tbl,
		       scale_factor, force_baseline);
}


GLOBAL(int)
jpeg_quality_scaling (int quality)
/* Convert a user-specified quality rating to a percentage scaling factor
 * for an underlying quantization table, using our recommended scaling curve.
 * The input 'quality' factor should be 0 (terrible) to 100 (very good).
 */
{
  /* Safety limit on quality factor.  Convert 0 to 1 to avoid zero divide. */
  if (quality <= 0) quality = 1;
  if (quality > 100) quality = 100;

  /* The basic table is used as-is (scaling 100) for a quality of 50.
   * Qualities 50..100 are converted to scaling percentage 200 - 2*Q;
   * note that at Q=100 the scaling is 0, which will cause jpeg_add_quant_table
   * to make all the table entries 1 (hence, minimum quantization loss).
   * Qualities 1..50 are converted to scaling percentage 5000/Q.
   */
  if (quality < 50)
    quality = 5000 / quality;
  else
    quality = 200 - quality*2;

  return quality;
}


GLOBAL(void)
jpeg_set_quality (j_compress_ptr cinfo, int quality, boolean force_baseline)
/* Set or change the 'quality' (quantization) setting, using default tables.
 * This is the standard quality-adjusting entry point for typical user
 * interfaces; only those who want detailed control over quantization tables
 * would use the preceding three routines directly.
 */
{
  /* Convert user 0-100 rating to percentage scaling */
  quality = jpeg_quality_scaling(quality);

  /* Set up standard quality tables */
  jpeg_set_linear_quality(cinfo, quality, force_baseline);
}


/*
 * Huffman table setup routines
 */

LOCAL(void)
add_huff_table (j_compress_ptr cinfo,
		JHUFF_TBL **htblptr, const UINT8 *bits, const UINT8 *val)
/* Define a Huffman table */
{
  if (*htblptr == NULL)
    *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
  
  MEMCOPY((*htblptr)->bits, bits, SIZEOF((*htblptr)->bits));
  MEMCOPY((*htblptr)->huffval, val, SIZEOF((*htblptr)->huffval));

  /* Initialize sent_table FALSE so table will be written to JPEG file. */
  (*htblptr)->sent_table = FALSE;
}


LOCAL(void)
std_huff_tables (j_compress_ptr cinfo)
/* Set up the standard Huffman tables (cf. JPEG standard section K.3) */
/* IMPORTANT: these are only valid for 8-bit data precision! */
{
  static const UINT8 bits_dc_luminance[17] =
    { /* 0-base */ 0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
  static const UINT8 val_dc_luminance[] =
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
  
  static const UINT8 bits_dc_chrominance[17] =
    { /* 0-base */ 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 };
  static const UINT8 val_dc_chrominance[] =
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
  
  static const UINT8 bits_ac_luminance[17] =
    { /* 0-base */ 0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d };
  static const UINT8 val_ac_luminance[] =
    { 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,
      0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,
      0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,
      0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0,
      0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16,
      0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,
      0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
      0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
      0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
      0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
      0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
      0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
      0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
      0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
      0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,
      0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,
      0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,
      0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,
      0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,
      0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
      0xf9, 0xfa };
  
  static const UINT8 bits_ac_chrominance[17] =
    { /* 0-base */ 0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77 };
  static const UINT8 val_ac_chrominance[] =
    { 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,
      0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,
      0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,
      0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0,
      0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34,
      0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26,
      0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38,
      0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
      0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
      0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
      0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
      0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
      0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96,
      0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5,
      0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,
      0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,
      0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2,
      0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,
      0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,
      0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
      0xf9, 0xfa };
  
  add_huff_table(cinfo, &cinfo->dc_huff_tbl_ptrs[0],
		 bits_dc_luminance, val_dc_luminance);
  add_huff_table(cinfo, &cinfo->ac_huff_tbl_ptrs[0],
		 bits_ac_luminance, val_ac_luminance);
  add_huff_table(cinfo, &cinfo->dc_huff_tbl_ptrs[1],
		 bits_dc_chrominance, val_dc_chrominance);
  add_huff_table(cinfo, &cinfo->ac_huff_tbl_ptrs[1],
		 bits_ac_chrominance, val_ac_chrominance);
}


/*
 * Default parameter setup for compression.
 *
 * Applications that don't choose to use this routine must do their
 * own setup of all these parameters.  Alternately, you can call this
 * to establish defaults and then alter parameters selectively.  This
 * is the recommended approach since, if we add any new parameters,
 * your code will still work (they'll be set to reasonable defaults).
 */

GLOBAL(void)
jpeg_set_defaults (j_compress_ptr cinfo)
{
  int i;

  /* Safety check to ensure start_compress not called yet. */
  if (cinfo->global_state != CSTATE_START)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  /* Allocate comp_info array large enough for maximum component count.
   * Array is made permanent in case application wants to compress
   * multiple images at same param settings.
   */
  if (cinfo->comp_info == NULL)
    cinfo->comp_info = (jpeg_component_info *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
				  MAX_COMPONENTS * SIZEOF(jpeg_component_info));

  /* Initialize everything not dependent on the color space */

  cinfo->data_precision = BITS_IN_JSAMPLE;
  /* Set up two quantization tables using default quality of 75 */
  jpeg_set_quality(cinfo, 75, TRUE);
  /* Set up two Huffman tables */
  std_huff_tables(cinfo);

  /* Initialize default arithmetic coding conditioning */
  for (i = 0; i < NUM_ARITH_TBLS; i++) {
    cinfo->arith_dc_L[i] = 0;
    cinfo->arith_dc_U[i] = 1;
    cinfo->arith_ac_K[i] = 5;
  }

  /* Default is no multiple-scan output */
  cinfo->scan_info = NULL;
  cinfo->num_scans = 0;

  /* Expect normal source image, not raw downsampled data */
  cinfo->raw_data_in = FALSE;

  /* Use Huffman coding, not arithmetic coding, by default */
  cinfo->arith_code = FALSE;

  /* By default, don't do extra passes to optimize entropy coding */
  cinfo->optimize_coding = FALSE;
  /* The standard Huffman tables are only valid for 8-bit data precision.
   * If the precision is higher, force optimization on so that usable
   * tables will be computed.  This test can be removed if default tables
   * are supplied that are valid for the desired precision.
   */
  if (cinfo->data_precision > 8)
    cinfo->optimize_coding = TRUE;

  /* By default, use the simpler non-cosited sampling alignment */
  cinfo->CCIR601_sampling = FALSE;

  /* No input smoothing */
  cinfo->smoothing_factor = 0;

  /* DCT algorithm preference */
  cinfo->dct_method = JDCT_DEFAULT;

  /* No restart markers */
  cinfo->restart_interval = 0;
  cinfo->restart_in_rows = 0;

  /* Fill in default JFIF marker parameters.  Note that whether the marker
   * will actually be written is determined by jpeg_set_colorspace.
   */
  cinfo->density_unit = 0;	/* Pixel size is unknown by default */
  cinfo->X_density = 1;		/* Pixel aspect ratio is square by default */
  cinfo->Y_density = 1;

  /* Choose JPEG colorspace based on input space, set defaults accordingly */

  jpeg_default_colorspace(cinfo);
}


/*
 * Select an appropriate JPEG colorspace for in_color_space.
 */

GLOBAL(void)
jpeg_default_colorspace (j_compress_ptr cinfo)
{
  switch (cinfo->in_color_space) {
  case JCS_GRAYSCALE:
    jpeg_set_colorspace(cinfo, JCS_GRAYSCALE);
    break;
  case JCS_RGB:
    jpeg_set_colorspace(cinfo, JCS_YCbCr);
    break;
  case JCS_YCbCr:
    jpeg_set_colorspace(cinfo, JCS_YCbCr);
    break;
  case JCS_CMYK:
    jpeg_set_colorspace(cinfo, JCS_CMYK); /* By default, no translation */
    break;
  case JCS_YCCK:
    jpeg_set_colorspace(cinfo, JCS_YCCK);
    break;
  case JCS_UNKNOWN:
    jpeg_set_colorspace(cinfo, JCS_UNKNOWN);
    break;
  default:
    ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
  }
}


/*
 * Set the JPEG colorspace, and choose colorspace-dependent default values.
 */

GLOBAL(void)
jpeg_set_colorspace (j_compress_ptr cinfo, J_COLOR_SPACE colorspace)
{
  jpeg_component_info * compptr;
  int ci;

#define SET_COMP(index,id,hsamp,vsamp,quant,dctbl,actbl)  \
  (compptr = &cinfo->comp_info[index], \
   compptr->component_id = (id), \
   compptr->h_samp_factor = (hsamp), \
   compptr->v_samp_factor = (vsamp), \
   compptr->quant_tbl_no = (quant), \
   compptr->dc_tbl_no = (dctbl), \
   compptr->ac_tbl_no = (actbl) )

  /* Safety check to ensure start_compress not called yet. */
  if (cinfo->global_state != CSTATE_START)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  /* For all colorspaces, we use Q and Huff tables 0 for luminance components,
   * tables 1 for chrominance components.
   */

  cinfo->jpeg_color_space = colorspace;

  cinfo->write_JFIF_header = FALSE; /* No marker for non-JFIF colorspaces */
  cinfo->write_Adobe_marker = FALSE; /* write no Adobe marker by default */

  switch (colorspace) {
  case JCS_GRAYSCALE:
    cinfo->write_JFIF_header = TRUE; /* Write a JFIF marker */
    cinfo->num_components = 1;
    /* JFIF specifies component ID 1 */
    SET_COMP(0, 1, 1,1, 0, 0,0);
    break;
  case JCS_RGB:
    cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag RGB */
    cinfo->num_components = 3;
    SET_COMP(0, 0x52 /* 'R' */, 1,1, 0, 0,0);
    SET_COMP(1, 0x47 /* 'G' */, 1,1, 0, 0,0);
    SET_COMP(2, 0x42 /* 'B' */, 1,1, 0, 0,0);
    break;
  case JCS_YCbCr:
    cinfo->write_JFIF_header = TRUE; /* Write a JFIF marker */
    cinfo->num_components = 3;
    /* JFIF specifies component IDs 1,2,3 */
    /* We default to 2x2 subsamples of chrominance */
    SET_COMP(0, 1, 2,2, 0, 0,0);
    SET_COMP(1, 2, 1,1, 1, 1,1);
    SET_COMP(2, 3, 1,1, 1, 1,1);
    break;
  case JCS_CMYK:
    cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag CMYK */
    cinfo->num_components = 4;
    SET_COMP(0, 0x43 /* 'C' */, 1,1, 0, 0,0);
    SET_COMP(1, 0x4D /* 'M' */, 1,1, 0, 0,0);
    SET_COMP(2, 0x59 /* 'Y' */, 1,1, 0, 0,0);
    SET_COMP(3, 0x4B /* 'K' */, 1,1, 0, 0,0);
    break;
  case JCS_YCCK:
    cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag YCCK */
    cinfo->num_components = 4;
    SET_COMP(0, 1, 2,2, 0, 0,0);
    SET_COMP(1, 2, 1,1, 1, 1,1);
    SET_COMP(2, 3, 1,1, 1, 1,1);
    SET_COMP(3, 4, 2,2, 0, 0,0);
    break;
  case JCS_UNKNOWN:
    cinfo->num_components = cinfo->input_components;
    if (cinfo->num_components < 1 || cinfo->num_components > MAX_COMPONENTS)
      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
	       MAX_COMPONENTS);
    for (ci = 0; ci < cinfo->num_components; ci++) {
      SET_COMP(ci, ci, 1,1, 0, 0,0);
    }
    break;
  default:
    ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
  }
}


#ifdef C_PROGRESSIVE_SUPPORTED

LOCAL(jpeg_scan_info *)
fill_a_scan (jpeg_scan_info * scanptr, int ci,
	     int Ss, int Se, int Ah, int Al)
/* Support routine: generate one scan for specified component */
{
  scanptr->comps_in_scan = 1;
  scanptr->component_index[0] = ci;
  scanptr->Ss = Ss;
  scanptr->Se = Se;
  scanptr->Ah = Ah;
  scanptr->Al = Al;
  scanptr++;
  return scanptr;
}

LOCAL(jpeg_scan_info *)
fill_scans (jpeg_scan_info * scanptr, int ncomps,
	    int Ss, int Se, int Ah, int Al)
/* Support routine: generate one scan for each component */
{
  int ci;

  for (ci = 0; ci < ncomps; ci++) {
    scanptr->comps_in_scan = 1;
    scanptr->component_index[0] = ci;
    scanptr->Ss = Ss;
    scanptr->Se = Se;
    scanptr->Ah = Ah;
    scanptr->Al = Al;
    scanptr++;
  }
  return scanptr;
}

LOCAL(jpeg_scan_info *)
fill_dc_scans (jpeg_scan_info * scanptr, int ncomps, int Ah, int Al)
/* Support routine: generate interleaved DC scan if possible, else N scans */
{
  int ci;

  if (ncomps <= MAX_COMPS_IN_SCAN) {
    /* Single interleaved DC scan */
    scanptr->comps_in_scan = ncomps;
    for (ci = 0; ci < ncomps; ci++)
      scanptr->component_index[ci] = ci;
    scanptr->Ss = scanptr->Se = 0;
    scanptr->Ah = Ah;
    scanptr->Al = Al;
    scanptr++;
  } else {
    /* Noninterleaved DC scan for each component */
    scanptr = fill_scans(scanptr, ncomps, 0, 0, Ah, Al);
  }
  return scanptr;
}


/*
 * Create a recommended progressive-JPEG script.
 * cinfo->num_components and cinfo->jpeg_color_space must be correct.
 */

GLOBAL(void)
jpeg_simple_progression (j_compress_ptr cinfo)
{
  int ncomps = cinfo->num_components;
  int nscans;
  jpeg_scan_info * scanptr;

  /* Safety check to ensure start_compress not called yet. */
  if (cinfo->global_state != CSTATE_START)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  /* Figure space needed for script.  Calculation must match code below! */
  if (ncomps == 3 && cinfo->jpeg_color_space == JCS_YCbCr) {
    /* Custom script for YCbCr color images. */
    nscans = 10;
  } else {
    /* All-purpose script for other color spaces. */
    if (ncomps > MAX_COMPS_IN_SCAN)
      nscans = 6 * ncomps;	/* 2 DC + 4 AC scans per component */
    else
      nscans = 2 + 4 * ncomps;	/* 2 DC scans; 4 AC scans per component */
  }

  /* Allocate space for script. */
  /* We use permanent pool just in case application re-uses script. */
  scanptr = (jpeg_scan_info *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
				nscans * SIZEOF(jpeg_scan_info));
  cinfo->scan_info = scanptr;
  cinfo->num_scans = nscans;

  if (ncomps == 3 && cinfo->jpeg_color_space == JCS_YCbCr) {
    /* Custom script for YCbCr color images. */
    /* Initial DC scan */
    scanptr = fill_dc_scans(scanptr, ncomps, 0, 1);
    /* Initial AC scan: get some luma data out in a hurry */
    scanptr = fill_a_scan(scanptr, 0, 1, 5, 0, 2);
    /* Chroma data is too small to be worth expending many scans on */
    scanptr = fill_a_scan(scanptr, 2, 1, 63, 0, 1);
    scanptr = fill_a_scan(scanptr, 1, 1, 63, 0, 1);
    /* Complete spectral selection for luma AC */
    scanptr = fill_a_scan(scanptr, 0, 6, 63, 0, 2);
    /* Refine next bit of luma AC */
    scanptr = fill_a_scan(scanptr, 0, 1, 63, 2, 1);
    /* Finish DC successive approximation */
    scanptr = fill_dc_scans(scanptr, ncomps, 1, 0);
    /* Finish AC successive approximation */
    scanptr = fill_a_scan(scanptr, 2, 1, 63, 1, 0);
    scanptr = fill_a_scan(scanptr, 1, 1, 63, 1, 0);
    /* Luma bottom bit comes last since it's usually largest scan */
    scanptr = fill_a_scan(scanptr, 0, 1, 63, 1, 0);
  } else {
    /* All-purpose script for other color spaces. */
    /* Successive approximation first pass */
    scanptr = fill_dc_scans(scanptr, ncomps, 0, 1);
    scanptr = fill_scans(scanptr, ncomps, 1, 5, 0, 2);
    scanptr = fill_scans(scanptr, ncomps, 6, 63, 0, 2);
    /* Successive approximation second pass */
    scanptr = fill_scans(scanptr, ncomps, 1, 63, 2, 1);
    /* Successive approximation final pass */
    scanptr = fill_dc_scans(scanptr, ncomps, 1, 0);
    scanptr = fill_scans(scanptr, ncomps, 1, 63, 1, 0);
  }
}

#endif /* C_PROGRESSIVE_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jdapimin.c ===
/*
 * jdapimin.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains application interface code for the decompression half
 * of the JPEG library.  These are the "minimum" API routines that may be
 * needed in either the normal full-decompression case or the
 * transcoding-only case.
 *
 * Most of the routines intended to be called directly by an application
 * are in this file or in jdapistd.c.  But also see jcomapi.c for routines
 * shared by compression and decompression, and jdtrans.c for the transcoding
 * case.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/*
 * Initialization of a JPEG decompression object.
 * The error manager must already be set up (in case memory manager fails).
 */

GLOBAL(void)
jpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize)
{
  int i;

  /* Guard against version mismatches between library and caller. */
  cinfo->mem = NULL;		/* so jpeg_destroy knows mem mgr not called */
  if (version != JPEG_LIB_VERSION)
    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);
  if (structsize != SIZEOF(struct jpeg_decompress_struct))
    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE, 
	     (int) SIZEOF(struct jpeg_decompress_struct), (int) structsize);

  /* For debugging purposes, zero the whole master structure.
   * But error manager pointer is already there, so save and restore it.
   */
  {
    struct jpeg_error_mgr * err = cinfo->err;
    MEMZERO(cinfo, SIZEOF(struct jpeg_decompress_struct));
    cinfo->err = err;
  }
  cinfo->is_decompressor = TRUE;

  /* Initialize a memory manager instance for this object */
  jinit_memory_mgr((j_common_ptr) cinfo);

  /* Zero out pointers to permanent structures. */
  cinfo->progress = NULL;
  cinfo->src = NULL;

  for (i = 0; i < NUM_QUANT_TBLS; i++)
    cinfo->quant_tbl_ptrs[i] = NULL;

  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    cinfo->dc_huff_tbl_ptrs[i] = NULL;
    cinfo->ac_huff_tbl_ptrs[i] = NULL;
  }

  /* Initialize marker processor so application can override methods
   * for COM, APPn markers before calling jpeg_read_header.
   */
  jinit_marker_reader(cinfo);

  /* And initialize the overall input controller. */
  jinit_input_controller(cinfo);

  /* OK, I'm ready */
  cinfo->global_state = DSTATE_START;
}


/*
 * Destruction of a JPEG decompression object
 */

GLOBAL(void)
jpeg_destroy_decompress (j_decompress_ptr cinfo)
{
  jpeg_destroy((j_common_ptr) cinfo); /* use common routine */
}


/*
 * Abort processing of a JPEG decompression operation,
 * but don't destroy the object itself.
 */

GLOBAL(void)
jpeg_abort_decompress (j_decompress_ptr cinfo)
{
  jpeg_abort((j_common_ptr) cinfo); /* use common routine */
}


/*
 * Install a special processing method for COM or APPn markers.
 */

GLOBAL(void)
jpeg_set_marker_processor (j_decompress_ptr cinfo, int marker_code,
			   jpeg_marker_parser_method routine)
{
  if (marker_code == JPEG_COM)
    cinfo->marker->process_COM = routine;
  else if (marker_code >= JPEG_APP0 && marker_code <= JPEG_APP0+15)
    cinfo->marker->process_APPn[marker_code-JPEG_APP0] = routine;
  else
    ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, marker_code);
}


/*
 * Set default decompression parameters.
 */

LOCAL(void)
default_decompress_parms (j_decompress_ptr cinfo)
{
  /* Guess the input colorspace, and set output colorspace accordingly. */
  /* (Wish JPEG committee had provided a real way to specify this...) */
  /* Note application may override our guesses. */
  switch (cinfo->num_components) {
  case 1:
    cinfo->jpeg_color_space = JCS_GRAYSCALE;
    cinfo->out_color_space = JCS_GRAYSCALE;
    break;
    
  case 3:
    if (cinfo->saw_JFIF_marker) {
      cinfo->jpeg_color_space = JCS_YCbCr; /* JFIF implies YCbCr */
    } else if (cinfo->saw_Adobe_marker) {
      switch (cinfo->Adobe_transform) {
      case 0:
	cinfo->jpeg_color_space = JCS_RGB;
	break;
      case 1:
	cinfo->jpeg_color_space = JCS_YCbCr;
	break;
      default:
	WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
	break;
      }
    } else {
      /* Saw no special markers, try to guess from the component IDs */
      int cid0 = cinfo->comp_info[0].component_id;
      int cid1 = cinfo->comp_info[1].component_id;
      int cid2 = cinfo->comp_info[2].component_id;

      if (cid0 == 1 && cid1 == 2 && cid2 == 3)
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume JFIF w/out marker */
      else if (cid0 == 82 && cid1 == 71 && cid2 == 66)
	cinfo->jpeg_color_space = JCS_RGB; /* ASCII 'R', 'G', 'B' */
      else {
	TRACEMS3(cinfo, 1, JTRC_UNKNOWN_IDS, cid0, cid1, cid2);
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
      }
    }
    /* Always guess RGB is proper output colorspace. */
    cinfo->out_color_space = JCS_RGB;
    break;
    
  case 4:
    if (cinfo->saw_Adobe_marker) {
      switch (cinfo->Adobe_transform) {
      case 0:
	cinfo->jpeg_color_space = JCS_CMYK;
	break;
      case 2:
	cinfo->jpeg_color_space = JCS_YCCK;
	break;
      default:
	WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);
	cinfo->jpeg_color_space = JCS_YCCK; /* assume it's YCCK */
	break;
      }
    } else {
      /* No special markers, assume straight CMYK. */
      cinfo->jpeg_color_space = JCS_CMYK;
    }
    cinfo->out_color_space = JCS_CMYK;
    break;
    
  default:
    cinfo->jpeg_color_space = JCS_UNKNOWN;
    cinfo->out_color_space = JCS_UNKNOWN;
    break;
  }

  /* Set defaults for other decompression parameters. */
  cinfo->scale_num = 1;		/* 1:1 scaling */
  cinfo->scale_denom = 1;
  cinfo->output_gamma = 1.0;
  cinfo->buffered_image = FALSE;
  cinfo->raw_data_out = FALSE;
  cinfo->dct_method = JDCT_DEFAULT;
  cinfo->do_fancy_upsampling = TRUE;
  cinfo->do_block_smoothing = TRUE;
  cinfo->quantize_colors = FALSE;
  /* We set these in case application only sets quantize_colors. */
  cinfo->dither_mode = JDITHER_FS;
#ifdef QUANT_2PASS_SUPPORTED
  cinfo->two_pass_quantize = TRUE;
#else
  cinfo->two_pass_quantize = FALSE;
#endif
  cinfo->desired_number_of_colors = 256;
  cinfo->colormap = NULL;
  /* Initialize for no mode change in buffered-image mode. */
  cinfo->enable_1pass_quant = FALSE;
  cinfo->enable_external_quant = FALSE;
  cinfo->enable_2pass_quant = FALSE;
}


/*
 * Decompression startup: read start of JPEG datastream to see what's there.
 * Need only initialize JPEG object and supply a data source before calling.
 *
 * This routine will read as far as the first SOS marker (ie, actual start of
 * compressed data), and will save all tables and parameters in the JPEG
 * object.  It will also initialize the decompression parameters to default
 * values, and finally return JPEG_HEADER_OK.  On return, the application may
 * adjust the decompression parameters and then call jpeg_start_decompress.
 * (Or, if the application only wanted to determine the image parameters,
 * the data need not be decompressed.  In that case, call jpeg_abort or
 * jpeg_destroy to release any temporary space.)
 * If an abbreviated (tables only) datastream is presented, the routine will
 * return JPEG_HEADER_TABLES_ONLY upon reaching EOI.  The application may then
 * re-use the JPEG object to read the abbreviated image datastream(s).
 * It is unnecessary (but OK) to call jpeg_abort in this case.
 * The JPEG_SUSPENDED return code only occurs if the data source module
 * requests suspension of the decompressor.  In this case the application
 * should load more source data and then re-call jpeg_read_header to resume
 * processing.
 * If a non-suspending data source is used and require_image is TRUE, then the
 * return code need not be inspected since only JPEG_HEADER_OK is possible.
 *
 * This routine is now just a front end to jpeg_consume_input, with some
 * extra error checking.
 */

GLOBAL(int)
jpeg_read_header (j_decompress_ptr cinfo, boolean require_image)
{
  int retcode;

  if (cinfo->global_state != DSTATE_START &&
      cinfo->global_state != DSTATE_INHEADER)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  retcode = jpeg_consume_input(cinfo);

  switch (retcode) {
  case JPEG_REACHED_SOS:
    retcode = JPEG_HEADER_OK;
    break;
  case JPEG_REACHED_EOI:
    if (require_image)		/* Complain if application wanted an image */
      ERREXIT(cinfo, JERR_NO_IMAGE);
    /* Reset to start state; it would be safer to require the application to
     * call jpeg_abort, but we can't change it now for compatibility reasons.
     * A side effect is to free any temporary memory (there shouldn't be any).
     */
    jpeg_abort((j_common_ptr) cinfo); /* sets state = DSTATE_START */
    retcode = JPEG_HEADER_TABLES_ONLY;
    break;
  case JPEG_SUSPENDED:
    /* no work */
    break;
  }

  return retcode;
}


/*
 * Consume data in advance of what the decompressor requires.
 * This can be called at any time once the decompressor object has
 * been created and a data source has been set up.
 *
 * This routine is essentially a state machine that handles a couple
 * of critical state-transition actions, namely initial setup and
 * transition from header scanning to ready-for-start_decompress.
 * All the actual input is done via the input controller's consume_input
 * method.
 */

GLOBAL(int)
jpeg_consume_input (j_decompress_ptr cinfo)
{
  int retcode = JPEG_SUSPENDED;

  /* NB: every possible DSTATE value should be listed in this switch */
  switch (cinfo->global_state) {
  case DSTATE_START:
    /* Start-of-datastream actions: reset appropriate modules */
    (*cinfo->inputctl->reset_input_controller) (cinfo);
    /* Initialize application's data source module */
    (*cinfo->src->init_source) (cinfo);
    cinfo->global_state = DSTATE_INHEADER;
    /*FALLTHROUGH*/
  case DSTATE_INHEADER:
    retcode = (*cinfo->inputctl->consume_input) (cinfo);
    if (retcode == JPEG_REACHED_SOS) { /* Found SOS, prepare to decompress */
      /* Set up default parameters based on header data */
      default_decompress_parms(cinfo);
      /* Set global state: ready for start_decompress */
      cinfo->global_state = DSTATE_READY;
    }
    break;
  case DSTATE_READY:
    /* Can't advance past first SOS until start_decompress is called */
    retcode = JPEG_REACHED_SOS;
    break;
  case DSTATE_PRELOAD:
  case DSTATE_PRESCAN:
  case DSTATE_SCANNING:
  case DSTATE_RAW_OK:
  case DSTATE_BUFIMAGE:
  case DSTATE_BUFPOST:
  case DSTATE_STOPPING:
    retcode = (*cinfo->inputctl->consume_input) (cinfo);
    break;
  default:
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  }
  return retcode;
}


/*
 * Have we finished reading the input file?
 */

GLOBAL(boolean)
jpeg_input_complete (j_decompress_ptr cinfo)
{
  /* Check for valid jpeg object */
  if (cinfo->global_state < DSTATE_START ||
      cinfo->global_state > DSTATE_STOPPING)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  return cinfo->inputctl->eoi_reached;
}


/*
 * Is there more than one scan?
 */

GLOBAL(boolean)
jpeg_has_multiple_scans (j_decompress_ptr cinfo)
{
  /* Only valid after jpeg_read_header completes */
  if (cinfo->global_state < DSTATE_READY ||
      cinfo->global_state > DSTATE_STOPPING)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  return cinfo->inputctl->has_multiple_scans;
}


/*
 * Finish JPEG decompression.
 *
 * This will normally just verify the file trailer and release temp storage.
 *
 * Returns FALSE if suspended.  The return value need be inspected only if
 * a suspending data source is used.
 */

GLOBAL(boolean)
jpeg_finish_decompress (j_decompress_ptr cinfo)
{
  if ((cinfo->global_state == DSTATE_SCANNING ||
       cinfo->global_state == DSTATE_RAW_OK) && ! cinfo->buffered_image) {
    /* Terminate final pass of non-buffered mode */
    if (cinfo->output_scanline < cinfo->output_height)
      ERREXIT(cinfo, JERR_TOO_LITTLE_DATA);
    (*cinfo->master->finish_output_pass) (cinfo);
    cinfo->global_state = DSTATE_STOPPING;
  } else if (cinfo->global_state == DSTATE_BUFIMAGE) {
    /* Finishing after a buffered-image operation */
    cinfo->global_state = DSTATE_STOPPING;
  } else if (cinfo->global_state != DSTATE_STOPPING) {
    /* STOPPING = repeat call after a suspension, anything else is error */
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  }
  /* Read until EOI */
  while (! cinfo->inputctl->eoi_reached) {
    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)
      return FALSE;		/* Suspend, come back later */
  }
  /* Do final cleanup */
  (*cinfo->src->term_source) (cinfo);
  /* We can use jpeg_abort to release memory and reset global_state */
  jpeg_abort((j_common_ptr) cinfo);
  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jddctmgr.c ===
/*
 * jddctmgr.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains the inverse-DCT management logic.
 * This code selects a particular IDCT implementation to be used,
 * and it performs related housekeeping chores.  No code in this file
 * is executed per IDCT step, only during output pass setup.
 *
 * Note that the IDCT routines are responsible for performing coefficient
 * dequantization as well as the IDCT proper.  This module sets up the
 * dequantization multiplier table needed by the IDCT routine.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"
#include "jdct.h"		/* Private declarations for DCT subsystem */


/*
 * The decompressor input side (jdinput.c) saves away the appropriate
 * quantization table for each component at the start of the first scan
 * involving that component.  (This is necessary in order to correctly
 * decode files that reuse Q-table slots.)
 * When we are ready to make an output pass, the saved Q-table is converted
 * to a multiplier table that will actually be used by the IDCT routine.
 * The multiplier table contents are IDCT-method-dependent.  To support
 * application changes in IDCT method between scans, we can remake the
 * multiplier tables if necessary.
 * In buffered-image mode, the first output pass may occur before any data
 * has been seen for some components, and thus before their Q-tables have
 * been saved away.  To handle this case, multiplier tables are preset
 * to zeroes; the result of the IDCT will be a neutral gray level.
 */


/* Private subobject for this module */

typedef struct {
  struct jpeg_inverse_dct pub;	/* public fields */

  /* This array contains the IDCT method code that each multiplier table
   * is currently set up for, or -1 if it's not yet set up.
   * The actual multiplier tables are pointed to by dct_table in the
   * per-component comp_info structures.
   */
  int cur_method[MAX_COMPONENTS];
} my_idct_controller;

typedef my_idct_controller * my_idct_ptr;


/* Allocated multiplier tables: big enough for any supported variant */

typedef union {
  ISLOW_MULT_TYPE islow_array[DCTSIZE2];
#ifdef DCT_IFAST_SUPPORTED
  IFAST_MULT_TYPE ifast_array[DCTSIZE2];
#endif
#ifdef DCT_FLOAT_SUPPORTED
  FLOAT_MULT_TYPE float_array[DCTSIZE2];
#endif
} multiplier_table;


/* The current scaled-IDCT routines require ISLOW-style multiplier tables,
 * so be sure to compile that code if either ISLOW or SCALING is requested.
 */
#ifdef DCT_ISLOW_SUPPORTED
#define PROVIDE_ISLOW_TABLES
#else
#ifdef IDCT_SCALING_SUPPORTED
#define PROVIDE_ISLOW_TABLES
#endif
#endif


/*
 * Prepare for an output pass.
 * Here we select the proper IDCT routine for each component and build
 * a matching multiplier table.
 */

METHODDEF(void)
start_pass (j_decompress_ptr cinfo)
{
  my_idct_ptr idct = (my_idct_ptr) cinfo->idct;
  int ci, i;
  jpeg_component_info *compptr;
  int method = 0;
  inverse_DCT_method_ptr method_ptr = NULL;
  JQUANT_TBL * qtbl;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Select the proper IDCT routine for this component's scaling */
    switch (compptr->DCT_scaled_size) {
#ifdef IDCT_SCALING_SUPPORTED
    case 1:
      method_ptr = jpeg_idct_1x1;
      method = JDCT_ISLOW;	/* jidctred uses islow-style table */
      break;
    case 2:
      method_ptr = jpeg_idct_2x2;
      method = JDCT_ISLOW;	/* jidctred uses islow-style table */
      break;
    case 4:
      method_ptr = jpeg_idct_4x4;
      method = JDCT_ISLOW;	/* jidctred uses islow-style table */
      break;
#endif
    case DCTSIZE:
      switch (cinfo->dct_method) {
#ifdef DCT_ISLOW_SUPPORTED
      case JDCT_ISLOW:
	method_ptr = jpeg_idct_islow;
	method = JDCT_ISLOW;
	break;
#endif
#ifdef DCT_IFAST_SUPPORTED
      case JDCT_IFAST:
	method_ptr = jpeg_idct_ifast;
	method = JDCT_IFAST;
	break;
#endif
#ifdef DCT_FLOAT_SUPPORTED
      case JDCT_FLOAT:
	method_ptr = jpeg_idct_float;
	method = JDCT_FLOAT;
	break;
#endif
      default:
	ERREXIT(cinfo, JERR_NOT_COMPILED);
	break;
      }
      break;
    default:
      ERREXIT1(cinfo, JERR_BAD_DCTSIZE, compptr->DCT_scaled_size);
      break;
    }
    idct->pub.inverse_DCT[ci] = method_ptr;
    /* Create multiplier table from quant table.
     * However, we can skip this if the component is uninteresting
     * or if we already built the table.  Also, if no quant table
     * has yet been saved for the component, we leave the
     * multiplier table all-zero; we'll be reading zeroes from the
     * coefficient controller's buffer anyway.
     */
    if (! compptr->component_needed || idct->cur_method[ci] == method)
      continue;
    qtbl = compptr->quant_table;
    if (qtbl == NULL)		/* happens if no data yet for component */
      continue;
    idct->cur_method[ci] = method;
    switch (method) {
#ifdef PROVIDE_ISLOW_TABLES
    case JDCT_ISLOW:
      {
	/* For LL&M IDCT method, multipliers are equal to raw quantization
	 * coefficients, but are stored as ints to ensure access efficiency.
	 */
	ISLOW_MULT_TYPE * ismtbl = (ISLOW_MULT_TYPE *) compptr->dct_table;
	for (i = 0; i < DCTSIZE2; i++) {
	  ismtbl[i] = (ISLOW_MULT_TYPE) qtbl->quantval[i];
	}
      }
      break;
#endif
#ifdef DCT_IFAST_SUPPORTED
    case JDCT_IFAST:
      {
	/* For AA&N IDCT method, multipliers are equal to quantization
	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
	 *   scalefactor[0] = 1
	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
	 * For integer operation, the multiplier table is to be scaled by
	 * IFAST_SCALE_BITS.
	 */
	IFAST_MULT_TYPE * ifmtbl = (IFAST_MULT_TYPE *) compptr->dct_table;
#define CONST_BITS 14
	static const INT16 aanscales[DCTSIZE2] = {
	  /* precomputed values scaled up by 14 bits */
	  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
	  22725, 31521, 29692, 26722, 22725, 17855, 12299,  6270,
	  21407, 29692, 27969, 25172, 21407, 16819, 11585,  5906,
	  19266, 26722, 25172, 22654, 19266, 15137, 10426,  5315,
	  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
	  12873, 17855, 16819, 15137, 12873, 10114,  6967,  3552,
	   8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,
	   4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247
	};
	SHIFT_TEMPS

	for (i = 0; i < DCTSIZE2; i++) {
	  ifmtbl[i] = (IFAST_MULT_TYPE)
	    DESCALE(MULTIPLY16V16((INT32) qtbl->quantval[i],
				  (INT32) aanscales[i]),
		    CONST_BITS-IFAST_SCALE_BITS);
	}
      }
      break;
#endif
#ifdef DCT_FLOAT_SUPPORTED
    case JDCT_FLOAT:
      {
	/* For float AA&N IDCT method, multipliers are equal to quantization
	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
	 *   scalefactor[0] = 1
	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
	 */
	FLOAT_MULT_TYPE * fmtbl = (FLOAT_MULT_TYPE *) compptr->dct_table;
	int row, col;
	static const double aanscalefactor[DCTSIZE] = {
	  1.0, 1.387039845, 1.306562965, 1.175875602,
	  1.0, 0.785694958, 0.541196100, 0.275899379
	};

	i = 0;
	for (row = 0; row < DCTSIZE; row++) {
	  for (col = 0; col < DCTSIZE; col++) {
	    fmtbl[i] = (FLOAT_MULT_TYPE)
	      ((double) qtbl->quantval[i] *
	       aanscalefactor[row] * aanscalefactor[col]);
	    i++;
	  }
	}
      }
      break;
#endif
    default:
      ERREXIT(cinfo, JERR_NOT_COMPILED);
      break;
    }
  }
}


/*
 * Initialize IDCT manager.
 */

GLOBAL(void)
jinit_inverse_dct (j_decompress_ptr cinfo)
{
  my_idct_ptr idct;
  int ci;
  jpeg_component_info *compptr;

  idct = (my_idct_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_idct_controller));
  cinfo->idct = (struct jpeg_inverse_dct *) idct;
  idct->pub.start_pass = start_pass;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Allocate and pre-zero a multiplier table for each component */
    compptr->dct_table =
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  SIZEOF(multiplier_table));
    MEMZERO(compptr->dct_table, SIZEOF(multiplier_table));
    /* Mark multiplier table not yet set up for any method */
    idct->cur_method[ci] = -1;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jdcolor.c ===
/*
 * jdcolor.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains output colorspace conversion routines.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/* Private subobject */

typedef struct {
  struct jpeg_color_deconverter pub; /* public fields */

  /* Private state for YCC->RGB conversion */
  int * Cr_r_tab;		/* => table for Cr to R conversion */
  int * Cb_b_tab;		/* => table for Cb to B conversion */
  INT32 * Cr_g_tab;		/* => table for Cr to G conversion */
  INT32 * Cb_g_tab;		/* => table for Cb to G conversion */
} my_color_deconverter;

typedef my_color_deconverter * my_cconvert_ptr;


/**************** YCbCr -> RGB conversion: most common case **************/

/*
 * YCbCr is defined per CCIR 601-1, except that Cb and Cr are
 * normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
 * The conversion equations to be implemented are therefore
 *	R = Y                + 1.40200 * Cr
 *	G = Y - 0.34414 * Cb - 0.71414 * Cr
 *	B = Y + 1.77200 * Cb
 * where Cb and Cr represent the incoming values less CENTERJSAMPLE.
 * (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)
 *
 * To avoid floating-point arithmetic, we represent the fractional constants
 * as integers scaled up by 2^16 (about 4 digits precision); we have to divide
 * the products by 2^16, with appropriate rounding, to get the correct answer.
 * Notice that Y, being an integral input, does not contribute any fraction
 * so it need not participate in the rounding.
 *
 * For even more speed, we avoid doing any multiplications in the inner loop
 * by precalculating the constants times Cb and Cr for all possible values.
 * For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);
 * for 12-bit samples it is still acceptable.  It's not very reasonable for
 * 16-bit samples, but if you want lossless storage you shouldn't be changing
 * colorspace anyway.
 * The Cr=>R and Cb=>B values can be rounded to integers in advance; the
 * values for the G calculation are left scaled up, since we must add them
 * together before rounding.
 */

#define SCALEBITS	16	/* speediest right-shift on some machines */
#define ONE_HALF	((INT32) 1 << (SCALEBITS-1))
#define FIX(x)		((INT32) ((x) * (1L<<SCALEBITS) + 0.5))


/*
 * Initialize tables for YCC->RGB colorspace conversion.
 */

LOCAL(void)
build_ycc_rgb_table (j_decompress_ptr cinfo)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  int i;
  INT32 x;
  SHIFT_TEMPS

  cconvert->Cr_r_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(int));
  cconvert->Cb_b_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(int));
  cconvert->Cr_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(INT32));
  cconvert->Cb_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(INT32));

  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
    /* Cr=>R value is nearest int to 1.40200 * x */
    cconvert->Cr_r_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
    /* Cb=>B value is nearest int to 1.77200 * x */
    cconvert->Cb_b_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
    /* Cr=>G value is scaled-up -0.71414 * x */
    cconvert->Cr_g_tab[i] = (- FIX(0.71414)) * x;
    /* Cb=>G value is scaled-up -0.34414 * x */
    /* We also add in ONE_HALF so that need not do it in inner loop */
    cconvert->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
  }
}


/*
 * Convert some rows of samples to the output colorspace.
 *
 * Note that we change from noninterleaved, one-plane-per-component format
 * to interleaved-pixel format.  The output buffer is therefore three times
 * as wide as the input buffer.
 * A starting row offset is provided only for the input buffer.  The caller
 * can easily adjust the passed output_buf value to accommodate any row
 * offset required on that side.
 */

METHODDEF(void)
ycc_rgb_convert (j_decompress_ptr cinfo,
		 JSAMPIMAGE input_buf, JDIMENSION input_row,
		 JSAMPARRAY output_buf, int num_rows)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  register int y, cb, cr;
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
  register int * Crrtab = cconvert->Cr_r_tab;
  register int * Cbbtab = cconvert->Cb_b_tab;
  register INT32 * Crgtab = cconvert->Cr_g_tab;
  register INT32 * Cbgtab = cconvert->Cb_g_tab;
  SHIFT_TEMPS

  while (--num_rows >= 0) {
    inptr0 = input_buf[0][input_row];
    inptr1 = input_buf[1][input_row];
    inptr2 = input_buf[2][input_row];
    input_row++;
    outptr = *output_buf++;
    for (col = 0; col < num_cols; col++) {
      y  = GETJSAMPLE(inptr0[col]);
      cb = GETJSAMPLE(inptr1[col]);
      cr = GETJSAMPLE(inptr2[col]);
      /* Range-limiting is essential due to noise introduced by DCT losses. */
      outptr[RGB_RED] =   range_limit[y + Crrtab[cr]];
      outptr[RGB_GREEN] = range_limit[y +
			      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
						 SCALEBITS))];
      outptr[RGB_BLUE] =  range_limit[y + Cbbtab[cb]];
      outptr += RGB_PIXELSIZE;
    }
  }
}


/**************** Cases other than YCbCr -> RGB **************/


/*
 * Color conversion for no colorspace change: just copy the data,
 * converting from separate-planes to interleaved representation.
 */

METHODDEF(void)
null_convert (j_decompress_ptr cinfo,
	      JSAMPIMAGE input_buf, JDIMENSION input_row,
	      JSAMPARRAY output_buf, int num_rows)
{
  register JSAMPROW inptr, outptr;
  register JDIMENSION count;
  register int num_components = cinfo->num_components;
  JDIMENSION num_cols = cinfo->output_width;
  int ci;

  while (--num_rows >= 0) {
    for (ci = 0; ci < num_components; ci++) {
      inptr = input_buf[ci][input_row];
      outptr = output_buf[0] + ci;
      for (count = num_cols; count > 0; count--) {
	*outptr = *inptr++;	/* needn't bother with GETJSAMPLE() here */
	outptr += num_components;
      }
    }
    input_row++;
    output_buf++;
  }
}


/*
 * Color conversion for grayscale: just copy the data.
 * This also works for YCbCr -> grayscale conversion, in which
 * we just copy the Y (luminance) component and ignore chrominance.
 */

METHODDEF(void)
grayscale_convert (j_decompress_ptr cinfo,
		   JSAMPIMAGE input_buf, JDIMENSION input_row,
		   JSAMPARRAY output_buf, int num_rows)
{
  jcopy_sample_rows(input_buf[0], (int) input_row, output_buf, 0,
		    num_rows, cinfo->output_width);
}


/*
 * Adobe-style YCCK->CMYK conversion.
 * We convert YCbCr to R=1-C, G=1-M, and B=1-Y using the same
 * conversion as above, while passing K (black) unchanged.
 * We assume build_ycc_rgb_table has been called.
 */

METHODDEF(void)
ycck_cmyk_convert (j_decompress_ptr cinfo,
		   JSAMPIMAGE input_buf, JDIMENSION input_row,
		   JSAMPARRAY output_buf, int num_rows)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  register int y, cb, cr;
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2, inptr3;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
  register int * Crrtab = cconvert->Cr_r_tab;
  register int * Cbbtab = cconvert->Cb_b_tab;
  register INT32 * Crgtab = cconvert->Cr_g_tab;
  register INT32 * Cbgtab = cconvert->Cb_g_tab;
  SHIFT_TEMPS

  while (--num_rows >= 0) {
    inptr0 = input_buf[0][input_row];
    inptr1 = input_buf[1][input_row];
    inptr2 = input_buf[2][input_row];
    inptr3 = input_buf[3][input_row];
    input_row++;
    outptr = *output_buf++;
    for (col = 0; col < num_cols; col++) {
      y  = GETJSAMPLE(inptr0[col]);
      cb = GETJSAMPLE(inptr1[col]);
      cr = GETJSAMPLE(inptr2[col]);
      /* Range-limiting is essential due to noise introduced by DCT losses. */
      outptr[0] = range_limit[MAXJSAMPLE - (y + Crrtab[cr])];	/* red */
      outptr[1] = range_limit[MAXJSAMPLE - (y +			/* green */
			      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
						 SCALEBITS)))];
      outptr[2] = range_limit[MAXJSAMPLE - (y + Cbbtab[cb])];	/* blue */
      /* K passes through unchanged */
      outptr[3] = inptr3[col];	/* don't need GETJSAMPLE here */
      outptr += 4;
    }
  }
}


/*
 * Empty method for start_pass.
 */

METHODDEF(void)
start_pass_dcolor (j_decompress_ptr cinfo)
{
  /* no work needed */
}


/*
 * Module initialization routine for output colorspace conversion.
 */

GLOBAL(void)
jinit_color_deconverter (j_decompress_ptr cinfo)
{
  my_cconvert_ptr cconvert;
  int ci;

  cconvert = (my_cconvert_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_color_deconverter));
  cinfo->cconvert = (struct jpeg_color_deconverter *) cconvert;
  cconvert->pub.start_pass = start_pass_dcolor;

  /* Make sure num_components agrees with jpeg_color_space */
  switch (cinfo->jpeg_color_space) {
  case JCS_GRAYSCALE:
    if (cinfo->num_components != 1)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    break;

  case JCS_RGB:
  case JCS_YCbCr:
    if (cinfo->num_components != 3)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    break;

  case JCS_CMYK:
  case JCS_YCCK:
    if (cinfo->num_components != 4)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    break;

  default:			/* JCS_UNKNOWN can be anything */
    if (cinfo->num_components < 1)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    break;
  }

  /* Set out_color_components and conversion method based on requested space.
   * Also clear the component_needed flags for any unused components,
   * so that earlier pipeline stages can avoid useless computation.
   */

  switch (cinfo->out_color_space) {
  case JCS_GRAYSCALE:
    cinfo->out_color_components = 1;
    if (cinfo->jpeg_color_space == JCS_GRAYSCALE ||
	cinfo->jpeg_color_space == JCS_YCbCr) {
      cconvert->pub.color_convert = grayscale_convert;
      /* For color->grayscale conversion, only the Y (0) component is needed */
      for (ci = 1; ci < cinfo->num_components; ci++)
	cinfo->comp_info[ci].component_needed = FALSE;
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  case JCS_RGB:
    cinfo->out_color_components = RGB_PIXELSIZE;
    if (cinfo->jpeg_color_space == JCS_YCbCr) {
      cconvert->pub.color_convert = ycc_rgb_convert;
      build_ycc_rgb_table(cinfo);
    } else if (cinfo->jpeg_color_space == JCS_RGB && RGB_PIXELSIZE == 3) {
      cconvert->pub.color_convert = null_convert;
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  case JCS_CMYK:
    cinfo->out_color_components = 4;
    if (cinfo->jpeg_color_space == JCS_YCCK) {
      cconvert->pub.color_convert = ycck_cmyk_convert;
      build_ycc_rgb_table(cinfo);
    } else if (cinfo->jpeg_color_space == JCS_CMYK) {
      cconvert->pub.color_convert = null_convert;
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  default:
    /* Permit null conversion to same output space */
    if (cinfo->out_color_space == cinfo->jpeg_color_space) {
      cinfo->out_color_components = cinfo->num_components;
      cconvert->pub.color_convert = null_convert;
    } else			/* unsupported non-null conversion */
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;
  }

  if (cinfo->quantize_colors)
    cinfo->output_components = 1; /* single colormapped output component */
  else
    cinfo->output_components = cinfo->out_color_components;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jdapistd.c ===
/*
 * jdapistd.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains application interface code for the decompression half
 * of the JPEG library.  These are the "standard" API routines that are
 * used in the normal full-decompression case.  They are not used by a
 * transcoding-only application.  Note that if an application links in
 * jpeg_start_decompress, it will end up linking in the entire decompressor.
 * We thus must separate this file from jdapimin.c to avoid linking the
 * whole decompression library into a transcoder.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/* Forward declarations */
LOCAL(boolean) output_pass_setup JPP((j_decompress_ptr cinfo));


/*
 * Decompression initialization.
 * jpeg_read_header must be completed before calling this.
 *
 * If a multipass operating mode was selected, this will do all but the
 * last pass, and thus may take a great deal of time.
 *
 * Returns FALSE if suspended.  The return value need be inspected only if
 * a suspending data source is used.
 */

GLOBAL(boolean)
jpeg_start_decompress (j_decompress_ptr cinfo)
{
  if (cinfo->global_state == DSTATE_READY) {
    /* First call: initialize master control, select active modules */
    jinit_master_decompress(cinfo);
    if (cinfo->buffered_image) {
      /* No more work here; expecting jpeg_start_output next */
      cinfo->global_state = DSTATE_BUFIMAGE;
      return TRUE;
    }
    cinfo->global_state = DSTATE_PRELOAD;
  }
  if (cinfo->global_state == DSTATE_PRELOAD) {
    /* If file has multiple scans, absorb them all into the coef buffer */
    if (cinfo->inputctl->has_multiple_scans) {
#ifdef D_MULTISCAN_FILES_SUPPORTED
      for (;;) {
	int retcode;
	/* Call progress monitor hook if present */
	if (cinfo->progress != NULL)
	  (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
	/* Absorb some more input */
	retcode = (*cinfo->inputctl->consume_input) (cinfo);
	if (retcode == JPEG_SUSPENDED)
	  return FALSE;
	if (retcode == JPEG_REACHED_EOI)
	  break;
	/* Advance progress counter if appropriate */
	if (cinfo->progress != NULL &&
	    (retcode == JPEG_ROW_COMPLETED || retcode == JPEG_REACHED_SOS)) {
	  if (++cinfo->progress->pass_counter >= cinfo->progress->pass_limit) {
	    /* jdmaster underestimated number of scans; ratchet up one scan */
	    cinfo->progress->pass_limit += (long) cinfo->total_iMCU_rows;
	  }
	}
      }
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif /* D_MULTISCAN_FILES_SUPPORTED */
    }
    cinfo->output_scan_number = cinfo->input_scan_number;
  } else if (cinfo->global_state != DSTATE_PRESCAN)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  /* Perform any dummy output passes, and set up for the final pass */
  return output_pass_setup(cinfo);
}


/*
 * Set up for an output pass, and perform any dummy pass(es) needed.
 * Common subroutine for jpeg_start_decompress and jpeg_start_output.
 * Entry: global_state = DSTATE_PRESCAN only if previously suspended.
 * Exit: If done, returns TRUE and sets global_state for proper output mode.
 *       If suspended, returns FALSE and sets global_state = DSTATE_PRESCAN.
 */

LOCAL(boolean)
output_pass_setup (j_decompress_ptr cinfo)
{
  if (cinfo->global_state != DSTATE_PRESCAN) {
    /* First call: do pass setup */
    (*cinfo->master->prepare_for_output_pass) (cinfo);
    cinfo->output_scanline = 0;
    cinfo->global_state = DSTATE_PRESCAN;
  }
  /* Loop over any required dummy passes */
  while (cinfo->master->is_dummy_pass) {
#ifdef QUANT_2PASS_SUPPORTED
    /* Crank through the dummy pass */
    while (cinfo->output_scanline < cinfo->output_height) {
      JDIMENSION last_scanline;
      /* Call progress monitor hook if present */
      if (cinfo->progress != NULL) {
	cinfo->progress->pass_counter = (long) cinfo->output_scanline;
	cinfo->progress->pass_limit = (long) cinfo->output_height;
	(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
      }
      /* Process some data */
      last_scanline = cinfo->output_scanline;
      (*cinfo->main->process_data) (cinfo, (JSAMPARRAY) NULL,
				    &cinfo->output_scanline, (JDIMENSION) 0);
      if (cinfo->output_scanline == last_scanline)
	return FALSE;		/* No progress made, must suspend */
    }
    /* Finish up dummy pass, and set up for another one */
    (*cinfo->master->finish_output_pass) (cinfo);
    (*cinfo->master->prepare_for_output_pass) (cinfo);
    cinfo->output_scanline = 0;
#else
    ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif /* QUANT_2PASS_SUPPORTED */
  }
  /* Ready for application to drive output pass through
   * jpeg_read_scanlines or jpeg_read_raw_data.
   */
  cinfo->global_state = cinfo->raw_data_out ? DSTATE_RAW_OK : DSTATE_SCANNING;
  return TRUE;
}


/*
 * Read some scanlines of data from the JPEG decompressor.
 *
 * The return value will be the number of lines actually read.
 * This may be less than the number requested in several cases,
 * including bottom of image, data source suspension, and operating
 * modes that emit multiple scanlines at a time.
 *
 * Note: we warn about excess calls to jpeg_read_scanlines() since
 * this likely signals an application programmer error.  However,
 * an oversize buffer (max_lines > scanlines remaining) is not an error.
 */

GLOBAL(JDIMENSION)
jpeg_read_scanlines (j_decompress_ptr cinfo, JSAMPARRAY scanlines,
		     JDIMENSION max_lines)
{
  JDIMENSION row_ctr;

  if (cinfo->global_state != DSTATE_SCANNING)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  if (cinfo->output_scanline >= cinfo->output_height) {
    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);
    return 0;
  }

  /* Call progress monitor hook if present */
  if (cinfo->progress != NULL) {
    cinfo->progress->pass_counter = (long) cinfo->output_scanline;
    cinfo->progress->pass_limit = (long) cinfo->output_height;
    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
  }

  /* Process some data */
  row_ctr = 0;
  (*cinfo->main->process_data) (cinfo, scanlines, &row_ctr, max_lines);
  cinfo->output_scanline += row_ctr;
  return row_ctr;
}


/*
 * Alternate entry point to read raw data.
 * Processes exactly one iMCU row per call, unless suspended.
 */

GLOBAL(JDIMENSION)
jpeg_read_raw_data (j_decompress_ptr cinfo, JSAMPIMAGE data,
		    JDIMENSION max_lines)
{
  JDIMENSION lines_per_iMCU_row;

  if (cinfo->global_state != DSTATE_RAW_OK)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  if (cinfo->output_scanline >= cinfo->output_height) {
    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);
    return 0;
  }

  /* Call progress monitor hook if present */
  if (cinfo->progress != NULL) {
    cinfo->progress->pass_counter = (long) cinfo->output_scanline;
    cinfo->progress->pass_limit = (long) cinfo->output_height;
    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
  }

  /* Verify that at least one iMCU row can be returned. */
  lines_per_iMCU_row = cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size;
  if (max_lines < lines_per_iMCU_row)
    ERREXIT(cinfo, JERR_BUFFER_SIZE);

  /* Decompress directly into user's buffer. */
  if (! (*cinfo->coef->decompress_data) (cinfo, data))
    return 0;			/* suspension forced, can do nothing more */

  /* OK, we processed one iMCU row. */
  cinfo->output_scanline += lines_per_iMCU_row;
  return lines_per_iMCU_row;
}


/* Additional entry points for buffered-image mode. */

#ifdef D_MULTISCAN_FILES_SUPPORTED

/*
 * Initialize for an output pass in buffered-image mode.
 */

GLOBAL(boolean)
jpeg_start_output (j_decompress_ptr cinfo, int scan_number)
{
  if (cinfo->global_state != DSTATE_BUFIMAGE &&
      cinfo->global_state != DSTATE_PRESCAN)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  /* Limit scan number to valid range */
  if (scan_number <= 0)
    scan_number = 1;
  if (cinfo->inputctl->eoi_reached &&
      scan_number > cinfo->input_scan_number)
    scan_number = cinfo->input_scan_number;
  cinfo->output_scan_number = scan_number;
  /* Perform any dummy output passes, and set up for the real pass */
  return output_pass_setup(cinfo);
}


/*
 * Finish up after an output pass in buffered-image mode.
 *
 * Returns FALSE if suspended.  The return value need be inspected only if
 * a suspending data source is used.
 */

GLOBAL(boolean)
jpeg_finish_output (j_decompress_ptr cinfo)
{
  if ((cinfo->global_state == DSTATE_SCANNING ||
       cinfo->global_state == DSTATE_RAW_OK) && cinfo->buffered_image) {
    /* Terminate this pass. */
    /* We do not require the whole pass to have been completed. */
    (*cinfo->master->finish_output_pass) (cinfo);
    cinfo->global_state = DSTATE_BUFPOST;
  } else if (cinfo->global_state != DSTATE_BUFPOST) {
    /* BUFPOST = repeat call after a suspension, anything else is error */
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  }
  /* Read markers looking for SOS or EOI */
  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
	 ! cinfo->inputctl->eoi_reached) {
    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)
      return FALSE;		/* Suspend, come back later */
  }
  cinfo->global_state = DSTATE_BUFIMAGE;
  return TRUE;
}

#endif /* D_MULTISCAN_FILES_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jdhuff.c ===
/*
 * jdhuff.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains Huffman entropy decoding routines.
 *
 * Much of the complexity here has to do with supporting input suspension.
 * If the data source module demands suspension, we want to be able to back
 * up to the start of the current MCU.  To do this, we copy state variables
 * into local working storage, and update them back to the permanent
 * storage only upon successful completion of an MCU.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"
#include "jdhuff.h"		/* Declarations shared with jdphuff.c */


/*
 * Expanded entropy decoder object for Huffman decoding.
 *
 * The savable_state subrecord contains fields that change within an MCU,
 * but must not be updated permanently until we complete the MCU.
 */

typedef struct {
  int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */
} savable_state;

/* This macro is to work around compilers with missing or broken
 * structure assignment.  You'll need to fix this code if you have
 * such a compiler and you change MAX_COMPS_IN_SCAN.
 */

#ifndef NO_STRUCT_ASSIGN
#define ASSIGN_STATE(dest,src)  ((dest) = (src))
#else
#if MAX_COMPS_IN_SCAN == 4
#define ASSIGN_STATE(dest,src)  \
	((dest).last_dc_val[0] = (src).last_dc_val[0], \
	 (dest).last_dc_val[1] = (src).last_dc_val[1], \
	 (dest).last_dc_val[2] = (src).last_dc_val[2], \
	 (dest).last_dc_val[3] = (src).last_dc_val[3])
#endif
#endif


typedef struct {
  struct jpeg_entropy_decoder pub; /* public fields */

  /* These fields are loaded into local variables at start of each MCU.
   * In case of suspension, we exit WITHOUT updating them.
   */
  bitread_perm_state bitstate;	/* Bit buffer at start of MCU */
  savable_state saved;		/* Other state at start of MCU */

  /* These fields are NOT loaded into local working state. */
  unsigned int restarts_to_go;	/* MCUs left in this restart interval */

  /* Pointers to derived tables (these workspaces have image lifespan) */
  d_derived_tbl * dc_derived_tbls[NUM_HUFF_TBLS];
  d_derived_tbl * ac_derived_tbls[NUM_HUFF_TBLS];
} huff_entropy_decoder;

typedef huff_entropy_decoder * huff_entropy_ptr;


/*
 * Initialize for a Huffman-compressed scan.
 */

METHODDEF(void)
start_pass_huff_decoder (j_decompress_ptr cinfo)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  int ci, dctbl, actbl;
  jpeg_component_info * compptr;

  /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
   * This ought to be an error condition, but we make it a warning because
   * there are some baseline files out there with all zeroes in these bytes.
   */
  if (cinfo->Ss != 0 || cinfo->Se != DCTSIZE2-1 ||
      cinfo->Ah != 0 || cinfo->Al != 0)
    WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
    dctbl = compptr->dc_tbl_no;
    actbl = compptr->ac_tbl_no;
    /* Make sure requested tables are present */
    if (dctbl < 0 || dctbl >= NUM_HUFF_TBLS ||
	cinfo->dc_huff_tbl_ptrs[dctbl] == NULL)
      ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, dctbl);
    if (actbl < 0 || actbl >= NUM_HUFF_TBLS ||
	cinfo->ac_huff_tbl_ptrs[actbl] == NULL)
      ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, actbl);
    /* Compute derived values for Huffman tables */
    /* We may do this more than once for a table, but it's not expensive */
    jpeg_make_d_derived_tbl(cinfo, cinfo->dc_huff_tbl_ptrs[dctbl],
			    & entropy->dc_derived_tbls[dctbl]);
    jpeg_make_d_derived_tbl(cinfo, cinfo->ac_huff_tbl_ptrs[actbl],
			    & entropy->ac_derived_tbls[actbl]);
    /* Initialize DC predictions to 0 */
    entropy->saved.last_dc_val[ci] = 0;
  }

  /* Initialize bitread state variables */
  entropy->bitstate.bits_left = 0;
  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
  entropy->bitstate.printed_eod = FALSE;

  /* Initialize restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
}


/*
 * Compute the derived values for a Huffman table.
 * Note this is also used by jdphuff.c.
 */

GLOBAL(void)
jpeg_make_d_derived_tbl (j_decompress_ptr cinfo, JHUFF_TBL * htbl,
			 d_derived_tbl ** pdtbl)
{
  d_derived_tbl *dtbl;
  int p, i, l, si;
  int lookbits, ctr;
  char huffsize[257];
  unsigned int huffcode[257];
  unsigned int code;

  /* Allocate a workspace if we haven't already done so. */
  if (*pdtbl == NULL)
    *pdtbl = (d_derived_tbl *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  SIZEOF(d_derived_tbl));
  dtbl = *pdtbl;
  dtbl->pub = htbl;		/* fill in back link */
  
  /* Figure C.1: make table of Huffman code length for each symbol */
  /* Note that this is in code-length order. */

  p = 0;
  for (l = 1; l <= 16; l++) {
    for (i = 1; i <= (int) htbl->bits[l]; i++)
      huffsize[p++] = (char) l;
  }
  huffsize[p] = 0;
  
  /* Figure C.2: generate the codes themselves */
  /* Note that this is in code-length order. */
  
  code = 0;
  si = huffsize[0];
  p = 0;
  while (huffsize[p]) {
    while (((int) huffsize[p]) == si) {
      huffcode[p++] = code;
      code++;
    }
    code <<= 1;
    si++;
  }

  /* Figure F.15: generate decoding tables for bit-sequential decoding */

  p = 0;
  for (l = 1; l <= 16; l++) {
    if (htbl->bits[l]) {
      dtbl->valptr[l] = p; /* huffval[] index of 1st symbol of code length l */
      dtbl->mincode[l] = huffcode[p]; /* minimum code of length l */
      p += htbl->bits[l];
      dtbl->maxcode[l] = huffcode[p-1]; /* maximum code of length l */
    } else {
      dtbl->maxcode[l] = -1;	/* -1 if no codes of this length */
    }
  }
  dtbl->maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates */

  /* Compute lookahead tables to speed up decoding.
   * First we set all the table entries to 0, indicating "too long";
   * then we iterate through the Huffman codes that are short enough and
   * fill in all the entries that correspond to bit sequences starting
   * with that code.
   */

  MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));

  p = 0;
  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
      /* l = current code's length, p = its index in huffcode[] & huffval[]. */
      /* Generate left-justified code followed by all possible bit sequences */
      lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);
      for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
	dtbl->look_nbits[lookbits] = l;
	dtbl->look_sym[lookbits] = htbl->huffval[p];
	lookbits++;
      }
    }
  }
}


/*
 * Out-of-line code for bit fetching (shared with jdphuff.c).
 * See jdhuff.h for info about usage.
 * Note: current values of get_buffer and bits_left are passed as parameters,
 * but are returned in the corresponding fields of the state struct.
 *
 * On most machines MIN_GET_BITS should be 25 to allow the full 32-bit width
 * of get_buffer to be used.  (On machines with wider words, an even larger
 * buffer could be used.)  However, on some machines 32-bit shifts are
 * quite slow and take time proportional to the number of places shifted.
 * (This is true with most PC compilers, for instance.)  In this case it may
 * be a win to set MIN_GET_BITS to the minimum value of 15.  This reduces the
 * average shift distance at the cost of more calls to jpeg_fill_bit_buffer.
 */

#ifdef SLOW_SHIFT_32
#define MIN_GET_BITS  15	/* minimum allowable value */
#else
#define MIN_GET_BITS  (BIT_BUF_SIZE-7)
#endif


GLOBAL(boolean)
jpeg_fill_bit_buffer (bitread_working_state * state,
		      register bit_buf_type get_buffer, register int bits_left,
		      int nbits)
/* Load up the bit buffer to a depth of at least nbits */
{
  /* Copy heavily used state fields into locals (hopefully registers) */
  register const JOCTET * next_input_byte = state->next_input_byte;
  register size_t bytes_in_buffer = state->bytes_in_buffer;
  register int c;

  /* Attempt to load at least MIN_GET_BITS bits into get_buffer. */
  /* (It is assumed that no request will be for more than that many bits.) */

  while (bits_left < MIN_GET_BITS) {
    /* Attempt to read a byte */
    if (state->unread_marker != 0)
      goto no_more_data;	/* can't advance past a marker */

    if (bytes_in_buffer == 0) {
      if (! (*state->cinfo->src->fill_input_buffer) (state->cinfo))
	return FALSE;
      next_input_byte = state->cinfo->src->next_input_byte;
      bytes_in_buffer = state->cinfo->src->bytes_in_buffer;
    }
    bytes_in_buffer--;
    c = GETJOCTET(*next_input_byte++);

    /* If it's 0xFF, check and discard stuffed zero byte */
    if (c == 0xFF) {
      do {
	if (bytes_in_buffer == 0) {
	  if (! (*state->cinfo->src->fill_input_buffer) (state->cinfo))
	    return FALSE;
	  next_input_byte = state->cinfo->src->next_input_byte;
	  bytes_in_buffer = state->cinfo->src->bytes_in_buffer;
	}
	bytes_in_buffer--;
	c = GETJOCTET(*next_input_byte++);
      } while (c == 0xFF);

      if (c == 0) {
	/* Found FF/00, which represents an FF data byte */
	c = 0xFF;
      } else {
	/* Oops, it's actually a marker indicating end of compressed data. */
	/* Better put it back for use later */
	state->unread_marker = c;

      no_more_data:
	/* There should be enough bits still left in the data segment; */
	/* if so, just break out of the outer while loop. */
	if (bits_left >= nbits)
	  break;
	/* Uh-oh.  Report corrupted data to user and stuff zeroes into
	 * the data stream, so that we can produce some kind of image.
	 * Note that this code will be repeated for each byte demanded
	 * for the rest of the segment.  We use a nonvolatile flag to ensure
	 * that only one warning message appears.
	 */
	if (! *(state->printed_eod_ptr)) {
	  WARNMS(state->cinfo, JWRN_HIT_MARKER);
	  *(state->printed_eod_ptr) = TRUE;
	}
	c = 0;			/* insert a zero byte into bit buffer */
      }
    }

    /* OK, load c into get_buffer */
    get_buffer = (get_buffer << 8) | c;
    bits_left += 8;
  }

  /* Unload the local registers */
  state->next_input_byte = next_input_byte;
  state->bytes_in_buffer = bytes_in_buffer;
  state->get_buffer = get_buffer;
  state->bits_left = bits_left;

  return TRUE;
}


/*
 * Out-of-line code for Huffman code decoding.
 * See jdhuff.h for info about usage.
 */

GLOBAL(int)
jpeg_huff_decode (bitread_working_state * state,
		  register bit_buf_type get_buffer, register int bits_left,
		  d_derived_tbl * htbl, int min_bits)
{
  register int l = min_bits;
  register INT32 code;

  /* HUFF_DECODE has determined that the code is at least min_bits */
  /* bits long, so fetch that many bits in one swoop. */

  CHECK_BIT_BUFFER(*state, l, return -1);
  code = GET_BITS(l);

  /* Collect the rest of the Huffman code one bit at a time. */
  /* This is per Figure F.16 in the JPEG spec. */

  while (code > htbl->maxcode[l]) {
    code <<= 1;
    CHECK_BIT_BUFFER(*state, 1, return -1);
    code |= GET_BITS(1);
    l++;
  }

  /* Unload the local registers */
  state->get_buffer = get_buffer;
  state->bits_left = bits_left;

  /* With garbage input we may reach the sentinel value l = 17. */

  if (l > 16) {
    WARNMS(state->cinfo, JWRN_HUFF_BAD_CODE);
    return 0;			/* fake a zero as the safest result */
  }

  return htbl->pub->huffval[ htbl->valptr[l] +
			    ((int) (code - htbl->mincode[l])) ];
}


/*
 * Figure F.12: extend sign bit.
 * On some machines, a shift and add will be faster than a table lookup.
 */

#ifdef AVOID_TABLES

#define HUFF_EXTEND(x,s)  ((x) < (1<<((s)-1)) ? (x) + (((-1)<<(s)) + 1) : (x))

#else

#define HUFF_EXTEND(x,s)  ((x) < extend_test[s] ? (x) + extend_offset[s] : (x))

static const int extend_test[16] =   /* entry n is 2**(n-1) */
  { 0, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
    0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000 };

static const int extend_offset[16] = /* entry n is (-1 << n) + 1 */
  { 0, ((-1)<<1) + 1, ((-1)<<2) + 1, ((-1)<<3) + 1, ((-1)<<4) + 1,
    ((-1)<<5) + 1, ((-1)<<6) + 1, ((-1)<<7) + 1, ((-1)<<8) + 1,
    ((-1)<<9) + 1, ((-1)<<10) + 1, ((-1)<<11) + 1, ((-1)<<12) + 1,
    ((-1)<<13) + 1, ((-1)<<14) + 1, ((-1)<<15) + 1 };

#endif /* AVOID_TABLES */


/*
 * Check for a restart marker & resynchronize decoder.
 * Returns FALSE if must suspend.
 */

LOCAL(boolean)
process_restart (j_decompress_ptr cinfo)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  int ci;

  /* Throw away any unused bits remaining in bit buffer; */
  /* include any full bytes in next_marker's count of discarded bytes */
  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
  entropy->bitstate.bits_left = 0;

  /* Advance past the RSTn marker */
  if (! (*cinfo->marker->read_restart_marker) (cinfo))
    return FALSE;

  /* Re-initialize DC predictions to 0 */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
    entropy->saved.last_dc_val[ci] = 0;

  /* Reset restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;

  /* Next segment can get another out-of-data warning */
  entropy->bitstate.printed_eod = FALSE;

  return TRUE;
}


/*
 * Decode and return one MCU's worth of Huffman-compressed coefficients.
 * The coefficients are reordered from zigzag order into natural array order,
 * but are not dequantized.
 *
 * The i'th block of the MCU is stored into the block pointed to by
 * MCU_data[i].  WE ASSUME THIS AREA HAS BEEN ZEROED BY THE CALLER.
 * (Wholesale zeroing is usually a little faster than retail...)
 *
 * Returns FALSE if data source requested suspension.  In that case no
 * changes have been made to permanent state.  (Exception: some output
 * coefficients may already have been assigned.  This is harmless for
 * this module, since we'll just re-assign them on the next call.)
 */

METHODDEF(boolean)
decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  register int s, k, r;
  int blkn, ci;
  JBLOCKROW block;
  BITREAD_STATE_VARS;
  savable_state state;
  d_derived_tbl * dctbl;
  d_derived_tbl * actbl;
  jpeg_component_info * compptr;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0)
      if (! process_restart(cinfo))
	return FALSE;
  }

  /* Load up working state */
  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
  ASSIGN_STATE(state, entropy->saved);

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
    block = MCU_data[blkn];
    ci = cinfo->MCU_membership[blkn];
    compptr = cinfo->cur_comp_info[ci];
    dctbl = entropy->dc_derived_tbls[compptr->dc_tbl_no];
    actbl = entropy->ac_derived_tbls[compptr->ac_tbl_no];

    /* Decode a single block's worth of coefficients */

    /* Section F.2.2.1: decode the DC coefficient difference */
    HUFF_DECODE(s, br_state, dctbl, return FALSE, label1);
    if (s) {
      CHECK_BIT_BUFFER(br_state, s, return FALSE);
      r = GET_BITS(s);
      s = HUFF_EXTEND(r, s);
    }

    /* Shortcut if component's values are not interesting */
    if (! compptr->component_needed)
      goto skip_ACs;

    /* Convert DC difference to actual value, update last_dc_val */
    s += state.last_dc_val[ci];
    state.last_dc_val[ci] = s;
    /* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */
    (*block)[0] = (JCOEF) s;

    /* Do we need to decode the AC coefficients for this component? */
    if (compptr->DCT_scaled_size > 1) {

      /* Section F.2.2.2: decode the AC coefficients */
      /* Since zeroes are skipped, output area must be cleared beforehand */
      for (k = 1; k < DCTSIZE2; k++) {
	HUFF_DECODE(s, br_state, actbl, return FALSE, label2);
      
	r = s >> 4;
	s &= 15;
      
	if (s) {
	  k += r;
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
	  r = GET_BITS(s);
	  s = HUFF_EXTEND(r, s);
	  /* Output coefficient in natural (dezigzagged) order.
	   * Note: the extra entries in jpeg_natural_order[] will save us
	   * if k >= DCTSIZE2, which could happen if the data is corrupted.
	   */
	  (*block)[jpeg_natural_order[k]] = (JCOEF) s;
	} else {
	  if (r != 15)
	    break;
	  k += 15;
	}
      }

    } else {
skip_ACs:

      /* Section F.2.2.2: decode the AC coefficients */
      /* In this path we just discard the values */
      for (k = 1; k < DCTSIZE2; k++) {
	HUFF_DECODE(s, br_state, actbl, return FALSE, label3);
      
	r = s >> 4;
	s &= 15;
      
	if (s) {
	  k += r;
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
	  DROP_BITS(s);
	} else {
	  if (r != 15)
	    break;
	  k += 15;
	}
      }

    }
  }

  /* Completed MCU, so update state */
  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
  ASSIGN_STATE(entropy->saved, state);

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;

  return TRUE;
}


/*
 * Module initialization routine for Huffman entropy decoding.
 */

GLOBAL(void)
jinit_huff_decoder (j_decompress_ptr cinfo)
{
  huff_entropy_ptr entropy;
  int i;

  entropy = (huff_entropy_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(huff_entropy_decoder));
  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
  entropy->pub.start_pass = start_pass_huff_decoder;
  entropy->pub.decode_mcu = decode_mcu;

  /* Mark tables unallocated */
  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jdinput.c ===
/*
 * jdinput.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains input control logic for the JPEG decompressor.
 * These routines are concerned with controlling the decompressor's input
 * processing (marker reading and coefficient decoding).  The actual input
 * reading is done in jdmarker.c, jdhuff.c, and jdphuff.c.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/* Private state */

typedef struct {
  struct jpeg_input_controller pub; /* public fields */

  boolean inheaders;		/* TRUE until first SOS is reached */
} my_input_controller;

typedef my_input_controller * my_inputctl_ptr;


/* Forward declarations */
METHODDEF(int) consume_markers JPP((j_decompress_ptr cinfo));


/*
 * Routines to calculate various quantities related to the size of the image.
 */

LOCAL(void)
initial_setup (j_decompress_ptr cinfo)
/* Called once, when first SOS marker is reached */
{
  int ci;
  jpeg_component_info *compptr;

  /* Make sure image isn't bigger than I can handle */
  if ((long) cinfo->image_height > (long) JPEG_MAX_DIMENSION ||
      (long) cinfo->image_width > (long) JPEG_MAX_DIMENSION)
    ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int) JPEG_MAX_DIMENSION);

  /* For now, precision must match compiled-in value... */
  if (cinfo->data_precision != BITS_IN_JSAMPLE)
    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);

  /* Check that number of components won't exceed internal array sizes */
  if (cinfo->num_components > MAX_COMPONENTS)
    ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
	     MAX_COMPONENTS);

  /* Compute maximum sampling factors; check factor validity */
  cinfo->max_h_samp_factor = 1;
  cinfo->max_v_samp_factor = 1;
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||
	compptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)
      ERREXIT(cinfo, JERR_BAD_SAMPLING);
    cinfo->max_h_samp_factor = MAX(cinfo->max_h_samp_factor,
				   compptr->h_samp_factor);
    cinfo->max_v_samp_factor = MAX(cinfo->max_v_samp_factor,
				   compptr->v_samp_factor);
  }

  /* We initialize DCT_scaled_size and min_DCT_scaled_size to DCTSIZE.
   * In the full decompressor, this will be overridden by jdmaster.c;
   * but in the transcoder, jdmaster.c is not used, so we must do it here.
   */
  cinfo->min_DCT_scaled_size = DCTSIZE;

  /* Compute dimensions of components */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    compptr->DCT_scaled_size = DCTSIZE;
    /* Size in DCT blocks */
    compptr->width_in_blocks = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
    compptr->height_in_blocks = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
    /* downsampled_width and downsampled_height will also be overridden by
     * jdmaster.c if we are doing full decompression.  The transcoder library
     * doesn't use these values, but the calling application might.
     */
    /* Size in samples */
    compptr->downsampled_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
		    (long) cinfo->max_h_samp_factor);
    compptr->downsampled_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
		    (long) cinfo->max_v_samp_factor);
    /* Mark component needed, until color conversion says otherwise */
    compptr->component_needed = TRUE;
    /* Mark no quantization table yet saved for component */
    compptr->quant_table = NULL;
  }

  /* Compute number of fully interleaved MCU rows. */
  cinfo->total_iMCU_rows = (JDIMENSION)
    jdiv_round_up((long) cinfo->image_height,
		  (long) (cinfo->max_v_samp_factor*DCTSIZE));

  /* Decide whether file contains multiple scans */
  if (cinfo->comps_in_scan < cinfo->num_components || cinfo->progressive_mode)
    cinfo->inputctl->has_multiple_scans = TRUE;
  else
    cinfo->inputctl->has_multiple_scans = FALSE;
}


LOCAL(void)
per_scan_setup (j_decompress_ptr cinfo)
/* Do computations that are needed before processing a JPEG scan */
/* cinfo->comps_in_scan and cinfo->cur_comp_info[] were set from SOS marker */
{
  int ci, mcublks, tmp;
  jpeg_component_info *compptr;
  
  if (cinfo->comps_in_scan == 1) {
    
    /* Noninterleaved (single-component) scan */
    compptr = cinfo->cur_comp_info[0];
    
    /* Overall image size in MCUs */
    cinfo->MCUs_per_row = compptr->width_in_blocks;
    cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
    
    /* For noninterleaved scan, always one block per MCU */
    compptr->MCU_width = 1;
    compptr->MCU_height = 1;
    compptr->MCU_blocks = 1;
    compptr->MCU_sample_width = compptr->DCT_scaled_size;
    compptr->last_col_width = 1;
    /* For noninterleaved scans, it is convenient to define last_row_height
     * as the number of block rows present in the last iMCU row.
     */
    tmp = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
    if (tmp == 0) tmp = compptr->v_samp_factor;
    compptr->last_row_height = tmp;
    
    /* Prepare array describing MCU composition */
    cinfo->blocks_in_MCU = 1;
    cinfo->MCU_membership[0] = 0;
    
  } else {
    
    /* Interleaved (multi-component) scan */
    if (cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > MAX_COMPS_IN_SCAN)
      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->comps_in_scan,
	       MAX_COMPS_IN_SCAN);
    
    /* Overall image size in MCUs */
    cinfo->MCUs_per_row = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width,
		    (long) (cinfo->max_h_samp_factor*DCTSIZE));
    cinfo->MCU_rows_in_scan = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height,
		    (long) (cinfo->max_v_samp_factor*DCTSIZE));
    
    cinfo->blocks_in_MCU = 0;
    
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
      compptr = cinfo->cur_comp_info[ci];
      /* Sampling factors give # of blocks of component in each MCU */
      compptr->MCU_width = compptr->h_samp_factor;
      compptr->MCU_height = compptr->v_samp_factor;
      compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
      compptr->MCU_sample_width = compptr->MCU_width * compptr->DCT_scaled_size;
      /* Figure number of non-dummy blocks in last MCU column & row */
      tmp = (int) (compptr->width_in_blocks % compptr->MCU_width);
      if (tmp == 0) tmp = compptr->MCU_width;
      compptr->last_col_width = tmp;
      tmp = (int) (compptr->height_in_blocks % compptr->MCU_height);
      if (tmp == 0) tmp = compptr->MCU_height;
      compptr->last_row_height = tmp;
      /* Prepare array describing MCU composition */
      mcublks = compptr->MCU_blocks;
      if (cinfo->blocks_in_MCU + mcublks > D_MAX_BLOCKS_IN_MCU)
	ERREXIT(cinfo, JERR_BAD_MCU_SIZE);
      while (mcublks-- > 0) {
	cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
      }
    }
    
  }
}


/*
 * Save away a copy of the Q-table referenced by each component present
 * in the current scan, unless already saved during a prior scan.
 *
 * In a multiple-scan JPEG file, the encoder could assign different components
 * the same Q-table slot number, but change table definitions between scans
 * so that each component uses a different Q-table.  (The IJG encoder is not
 * currently capable of doing this, but other encoders might.)  Since we want
 * to be able to dequantize all the components at the end of the file, this
 * means that we have to save away the table actually used for each component.
 * We do this by copying the table at the start of the first scan containing
 * the component.
 * The JPEG spec prohibits the encoder from changing the contents of a Q-table
 * slot between scans of a component using that slot.  If the encoder does so
 * anyway, this decoder will simply use the Q-table values that were current
 * at the start of the first scan for the component.
 *
 * The decompressor output side looks only at the saved quant tables,
 * not at the current Q-table slots.
 */

LOCAL(void)
latch_quant_tables (j_decompress_ptr cinfo)
{
  int ci, qtblno;
  jpeg_component_info *compptr;
  JQUANT_TBL * qtbl;

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
    /* No work if we already saved Q-table for this component */
    if (compptr->quant_table != NULL)
      continue;
    /* Make sure specified quantization table is present */
    qtblno = compptr->quant_tbl_no;
    if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
	cinfo->quant_tbl_ptrs[qtblno] == NULL)
      ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, qtblno);
    /* OK, save away the quantization table */
    qtbl = (JQUANT_TBL *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  SIZEOF(JQUANT_TBL));
    MEMCOPY(qtbl, cinfo->quant_tbl_ptrs[qtblno], SIZEOF(JQUANT_TBL));
    compptr->quant_table = qtbl;
  }
}


/*
 * Initialize the input modules to read a scan of compressed data.
 * The first call to this is done by jdmaster.c after initializing
 * the entire decompressor (during jpeg_start_decompress).
 * Subsequent calls come from consume_markers, below.
 */

METHODDEF(void)
start_input_pass (j_decompress_ptr cinfo)
{
  per_scan_setup(cinfo);
  latch_quant_tables(cinfo);
  (*cinfo->entropy->start_pass) (cinfo);
  (*cinfo->coef->start_input_pass) (cinfo);
  cinfo->inputctl->consume_input = cinfo->coef->consume_data;
}


/*
 * Finish up after inputting a compressed-data scan.
 * This is called by the coefficient controller after it's read all
 * the expected data of the scan.
 */

METHODDEF(void)
finish_input_pass (j_decompress_ptr cinfo)
{
  cinfo->inputctl->consume_input = consume_markers;
}


/*
 * Read JPEG markers before, between, or after compressed-data scans.
 * Change state as necessary when a new scan is reached.
 * Return value is JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
 *
 * The consume_input method pointer points either here or to the
 * coefficient controller's consume_data routine, depending on whether
 * we are reading a compressed data segment or inter-segment markers.
 */

METHODDEF(int)
consume_markers (j_decompress_ptr cinfo)
{
  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
  int val;

  if (inputctl->pub.eoi_reached) /* After hitting EOI, read no further */
    return JPEG_REACHED_EOI;

  val = (*cinfo->marker->read_markers) (cinfo);

  switch (val) {
  case JPEG_REACHED_SOS:	/* Found SOS */
    if (inputctl->inheaders) {	/* 1st SOS */
      initial_setup(cinfo);
      inputctl->inheaders = FALSE;
      /* Note: start_input_pass must be called by jdmaster.c
       * before any more input can be consumed.  jdapi.c is
       * responsible for enforcing this sequencing.
       */
    } else {			/* 2nd or later SOS marker */
      if (! inputctl->pub.has_multiple_scans)
	ERREXIT(cinfo, JERR_EOI_EXPECTED); /* Oops, I wasn't expecting this! */
      start_input_pass(cinfo);
    }
    break;
  case JPEG_REACHED_EOI:	/* Found EOI */
    inputctl->pub.eoi_reached = TRUE;
    if (inputctl->inheaders) {	/* Tables-only datastream, apparently */
      if (cinfo->marker->saw_SOF)
	ERREXIT(cinfo, JERR_SOF_NO_SOS);
    } else {
      /* Prevent infinite loop in coef ctlr's decompress_data routine
       * if user set output_scan_number larger than number of scans.
       */
      if (cinfo->output_scan_number > cinfo->input_scan_number)
	cinfo->output_scan_number = cinfo->input_scan_number;
    }
    break;
  case JPEG_SUSPENDED:
    break;
  }

  return val;
}


/*
 * Reset state to begin a fresh datastream.
 */

METHODDEF(void)
reset_input_controller (j_decompress_ptr cinfo)
{
  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;

  inputctl->pub.consume_input = consume_markers;
  inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
  inputctl->pub.eoi_reached = FALSE;
  inputctl->inheaders = TRUE;
  /* Reset other modules */
  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
  (*cinfo->marker->reset_marker_reader) (cinfo);
  /* Reset progression state -- would be cleaner if entropy decoder did this */
  cinfo->coef_bits = NULL;
}


/*
 * Initialize the input controller module.
 * This is called only once, when the decompression object is created.
 */

GLOBAL(void)
jinit_input_controller (j_decompress_ptr cinfo)
{
  my_inputctl_ptr inputctl;

  /* Create subobject in permanent pool */
  inputctl = (my_inputctl_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
				SIZEOF(my_input_controller));
  cinfo->inputctl = (struct jpeg_input_controller *) inputctl;
  /* Initialize method pointers */
  inputctl->pub.consume_input = consume_markers;
  inputctl->pub.reset_input_controller = reset_input_controller;
  inputctl->pub.start_input_pass = start_input_pass;
  inputctl->pub.finish_input_pass = finish_input_pass;
  /* Initialize state: can't use reset_input_controller since we don't
   * want to try to reset other modules yet.
   */
  inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
  inputctl->pub.eoi_reached = FALSE;
  inputctl->inheaders = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jdmainct.c ===
/*
 * jdmainct.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains the main buffer controller for decompression.
 * The main buffer lies between the JPEG decompressor proper and the
 * post-processor; it holds downsampled data in the JPEG colorspace.
 *
 * Note that this code is bypassed in raw-data mode, since the application
 * supplies the equivalent of the main buffer in that case.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/*
 * In the current system design, the main buffer need never be a full-image
 * buffer; any full-height buffers will be found inside the coefficient or
 * postprocessing controllers.  Nonetheless, the main controller is not
 * trivial.  Its responsibility is to provide context rows for upsampling/
 * rescaling, and doing this in an efficient fashion is a bit tricky.
 *
 * Postprocessor input data is counted in "row groups".  A row group
 * is defined to be (v_samp_factor * DCT_scaled_size / min_DCT_scaled_size)
 * sample rows of each component.  (We require DCT_scaled_size values to be
 * chosen such that these numbers are integers.  In practice DCT_scaled_size
 * values will likely be powers of two, so we actually have the stronger
 * condition that DCT_scaled_size / min_DCT_scaled_size is an integer.)
 * Upsampling will typically produce max_v_samp_factor pixel rows from each
 * row group (times any additional scale factor that the upsampler is
 * applying).
 *
 * The coefficient controller will deliver data to us one iMCU row at a time;
 * each iMCU row contains v_samp_factor * DCT_scaled_size sample rows, or
 * exactly min_DCT_scaled_size row groups.  (This amount of data corresponds
 * to one row of MCUs when the image is fully interleaved.)  Note that the
 * number of sample rows varies across components, but the number of row
 * groups does not.  Some garbage sample rows may be included in the last iMCU
 * row at the bottom of the image.
 *
 * Depending on the vertical scaling algorithm used, the upsampler may need
 * access to the sample row(s) above and below its current input row group.
 * The upsampler is required to set need_context_rows TRUE at global selection
 * time if so.  When need_context_rows is FALSE, this controller can simply
 * obtain one iMCU row at a time from the coefficient controller and dole it
 * out as row groups to the postprocessor.
 *
 * When need_context_rows is TRUE, this controller guarantees that the buffer
 * passed to postprocessing contains at least one row group's worth of samples
 * above and below the row group(s) being processed.  Note that the context
 * rows "above" the first passed row group appear at negative row offsets in
 * the passed buffer.  At the top and bottom of the image, the required
 * context rows are manufactured by duplicating the first or last real sample
 * row; this avoids having special cases in the upsampling inner loops.
 *
 * The amount of context is fixed at one row group just because that's a
 * convenient number for this controller to work with.  The existing
 * upsamplers really only need one sample row of context.  An upsampler
 * supporting arbitrary output rescaling might wish for more than one row
 * group of context when shrinking the image; tough, we don't handle that.
 * (This is justified by the assumption that downsizing will be handled mostly
 * by adjusting the DCT_scaled_size values, so that the actual scale factor at
 * the upsample step needn't be much less than one.)
 *
 * To provide the desired context, we have to retain the last two row groups
 * of one iMCU row while reading in the next iMCU row.  (The last row group
 * can't be processed until we have another row group for its below-context,
 * and so we have to save the next-to-last group too for its above-context.)
 * We could do this most simply by copying data around in our buffer, but
 * that'd be very slow.  We can avoid copying any data by creating a rather
 * strange pointer structure.  Here's how it works.  We allocate a workspace
 * consisting of M+2 row groups (where M = min_DCT_scaled_size is the number
 * of row groups per iMCU row).  We create two sets of redundant pointers to
 * the workspace.  Labeling the physical row groups 0 to M+1, the synthesized
 * pointer lists look like this:
 *                   M+1                          M-1
 * master pointer --> 0         master pointer --> 0
 *                    1                            1
 *                   ...                          ...
 *                   M-3                          M-3
 *                   M-2                           M
 *                   M-1                          M+1
 *                    M                           M-2
 *                   M+1                          M-1
 *                    0                            0
 * We read alternate iMCU rows using each master pointer; thus the last two
 * row groups of the previous iMCU row remain un-overwritten in the workspace.
 * The pointer lists are set up so that the required context rows appear to
 * be adjacent to the proper places when we pass the pointer lists to the
 * upsampler.
 *
 * The above pictures describe the normal state of the pointer lists.
 * At top and bottom of the image, we diddle the pointer lists to duplicate
 * the first or last sample row as necessary (this is cheaper than copying
 * sample rows around).
 *
 * This scheme breaks down if M < 2, ie, min_DCT_scaled_size is 1.  In that
 * situation each iMCU row provides only one row group so the buffering logic
 * must be different (eg, we must read two iMCU rows before we can emit the
 * first row group).  For now, we simply do not support providing context
 * rows when min_DCT_scaled_size is 1.  That combination seems unlikely to
 * be worth providing --- if someone wants a 1/8th-size preview, they probably
 * want it quick and dirty, so a context-free upsampler is sufficient.
 */


/* Private buffer controller object */

typedef struct {
  struct jpeg_d_main_controller pub; /* public fields */

  /* Pointer to allocated workspace (M or M+2 row groups). */
  JSAMPARRAY buffer[MAX_COMPONENTS];

  boolean buffer_full;		/* Have we gotten an iMCU row from decoder? */
  JDIMENSION rowgroup_ctr;	/* counts row groups output to postprocessor */

  /* Remaining fields are only used in the context case. */

  /* These are the master pointers to the funny-order pointer lists. */
  JSAMPIMAGE xbuffer[2];	/* pointers to weird pointer lists */

  int whichptr;			/* indicates which pointer set is now in use */
  int context_state;		/* process_data state machine status */
  JDIMENSION rowgroups_avail;	/* row groups available to postprocessor */
  JDIMENSION iMCU_row_ctr;	/* counts iMCU rows to detect image top/bot */
} my_main_controller;

typedef my_main_controller * my_main_ptr;

/* context_state values: */
#define CTX_PREPARE_FOR_IMCU	0	/* need to prepare for MCU row */
#define CTX_PROCESS_IMCU	1	/* feeding iMCU to postprocessor */
#define CTX_POSTPONED_ROW	2	/* feeding postponed row group */


/* Forward declarations */
METHODDEF(void) process_data_simple_main
	JPP((j_decompress_ptr cinfo, JSAMPARRAY output_buf,
	     JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail));
METHODDEF(void) process_data_context_main
	JPP((j_decompress_ptr cinfo, JSAMPARRAY output_buf,
	     JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail));
#ifdef QUANT_2PASS_SUPPORTED
METHODDEF(void) process_data_crank_post
	JPP((j_decompress_ptr cinfo, JSAMPARRAY output_buf,
	     JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail));
#endif


LOCAL(void)
alloc_funny_pointers (j_decompress_ptr cinfo)
/* Allocate space for the funny pointer lists.
 * This is done only once, not once per pass.
 */
{
  my_main_ptr main = (my_main_ptr) cinfo->main;
  int ci, rgroup;
  int M = cinfo->min_DCT_scaled_size;
  jpeg_component_info *compptr;
  JSAMPARRAY xbuf;

  /* Get top-level space for component array pointers.
   * We alloc both arrays with one call to save a few cycles.
   */
  main->xbuffer[0] = (JSAMPIMAGE)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				cinfo->num_components * 2 * SIZEOF(JSAMPARRAY));
  main->xbuffer[1] = main->xbuffer[0] + cinfo->num_components;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
      cinfo->min_DCT_scaled_size; /* height of a row group of component */
    /* Get space for pointer lists --- M+4 row groups in each list.
     * We alloc both pointer lists with one call to save a few cycles.
     */
    xbuf = (JSAMPARRAY)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  2 * (rgroup * (M + 4)) * SIZEOF(JSAMPROW));
    xbuf += rgroup;		/* want one row group at negative offsets */
    main->xbuffer[0][ci] = xbuf;
    xbuf += rgroup * (M + 4);
    main->xbuffer[1][ci] = xbuf;
  }
}


LOCAL(void)
make_funny_pointers (j_decompress_ptr cinfo)
/* Create the funny pointer lists discussed in the comments above.
 * The actual workspace is already allocated (in main->buffer),
 * and the space for the pointer lists is allocated too.
 * This routine just fills in the curiously ordered lists.
 * This will be repeated at the beginning of each pass.
 */
{
  my_main_ptr main = (my_main_ptr) cinfo->main;
  int ci, i, rgroup;
  int M = cinfo->min_DCT_scaled_size;
  jpeg_component_info *compptr;
  JSAMPARRAY buf, xbuf0, xbuf1;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
      cinfo->min_DCT_scaled_size; /* height of a row group of component */
    xbuf0 = main->xbuffer[0][ci];
    xbuf1 = main->xbuffer[1][ci];
    /* First copy the workspace pointers as-is */
    buf = main->buffer[ci];
    for (i = 0; i < rgroup * (M + 2); i++) {
      xbuf0[i] = xbuf1[i] = buf[i];
    }
    /* In the second list, put the last four row groups in swapped order */
    for (i = 0; i < rgroup * 2; i++) {
      xbuf1[rgroup*(M-2) + i] = buf[rgroup*M + i];
      xbuf1[rgroup*M + i] = buf[rgroup*(M-2) + i];
    }
    /* The wraparound pointers at top and bottom will be filled later
     * (see set_wraparound_pointers, below).  Initially we want the "above"
     * pointers to duplicate the first actual data line.  This only needs
     * to happen in xbuffer[0].
     */
    for (i = 0; i < rgroup; i++) {
      xbuf0[i - rgroup] = xbuf0[0];
    }
  }
}


LOCAL(void)
set_wraparound_pointers (j_decompress_ptr cinfo)
/* Set up the "wraparound" pointers at top and bottom of the pointer lists.
 * This changes the pointer list state from top-of-image to the normal state.
 */
{
  my_main_ptr main = (my_main_ptr) cinfo->main;
  int ci, i, rgroup;
  int M = cinfo->min_DCT_scaled_size;
  jpeg_component_info *compptr;
  JSAMPARRAY xbuf0, xbuf1;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
      cinfo->min_DCT_scaled_size; /* height of a row group of component */
    xbuf0 = main->xbuffer[0][ci];
    xbuf1 = main->xbuffer[1][ci];
    for (i = 0; i < rgroup; i++) {
      xbuf0[i - rgroup] = xbuf0[rgroup*(M+1) + i];
      xbuf1[i - rgroup] = xbuf1[rgroup*(M+1) + i];
      xbuf0[rgroup*(M+2) + i] = xbuf0[i];
      xbuf1[rgroup*(M+2) + i] = xbuf1[i];
    }
  }
}


LOCAL(void)
set_bottom_pointers (j_decompress_ptr cinfo)
/* Change the pointer lists to duplicate the last sample row at the bottom
 * of the image.  whichptr indicates which xbuffer holds the final iMCU row.
 * Also sets rowgroups_avail to indicate number of nondummy row groups in row.
 */
{
  my_main_ptr main = (my_main_ptr) cinfo->main;
  int ci, i, rgroup, iMCUheight, rows_left;
  jpeg_component_info *compptr;
  JSAMPARRAY xbuf;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Count sample rows in one iMCU row and in one row group */
    iMCUheight = compptr->v_samp_factor * compptr->DCT_scaled_size;
    rgroup = iMCUheight / cinfo->min_DCT_scaled_size;
    /* Count nondummy sample rows remaining for this component */
    rows_left = (int) (compptr->downsampled_height % (JDIMENSION) iMCUheight);
    if (rows_left == 0) rows_left = iMCUheight;
    /* Count nondummy row groups.  Should get same answer for each component,
     * so we need only do it once.
     */
    if (ci == 0) {
      main->rowgroups_avail = (JDIMENSION) ((rows_left-1) / rgroup + 1);
    }
    /* Duplicate the last real sample row rgroup*2 times; this pads out the
     * last partial rowgroup and ensures at least one full rowgroup of context.
     */
    xbuf = main->xbuffer[main->whichptr][ci];
    for (i = 0; i < rgroup * 2; i++) {
      xbuf[rows_left + i] = xbuf[rows_left-1];
    }
  }
}


/*
 * Initialize for a processing pass.
 */

METHODDEF(void)
start_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
{
  my_main_ptr main = (my_main_ptr) cinfo->main;

  switch (pass_mode) {
  case JBUF_PASS_THRU:
    if (cinfo->upsample->need_context_rows) {
      main->pub.process_data = process_data_context_main;
      make_funny_pointers(cinfo); /* Create the xbuffer[] lists */
      main->whichptr = 0;	/* Read first iMCU row into xbuffer[0] */
      main->context_state = CTX_PREPARE_FOR_IMCU;
      main->iMCU_row_ctr = 0;
    } else {
      /* Simple case with no context needed */
      main->pub.process_data = process_data_simple_main;
    }
    main->buffer_full = FALSE;	/* Mark buffer empty */
    main->rowgroup_ctr = 0;
    break;
#ifdef QUANT_2PASS_SUPPORTED
  case JBUF_CRANK_DEST:
    /* For last pass of 2-pass quantization, just crank the postprocessor */
    main->pub.process_data = process_data_crank_post;
    break;
#endif
  default:
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    break;
  }
}


/*
 * Process some data.
 * This handles the simple case where no context is required.
 */

METHODDEF(void)
process_data_simple_main (j_decompress_ptr cinfo,
			  JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
			  JDIMENSION out_rows_avail)
{
  my_main_ptr main = (my_main_ptr) cinfo->main;
  JDIMENSION rowgroups_avail;

  /* Read input data if we haven't filled the main buffer yet */
  if (! main->buffer_full) {
    if (! (*cinfo->coef->decompress_data) (cinfo, main->buffer))
      return;			/* suspension forced, can do nothing more */
    main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
  }

  /* There are always min_DCT_scaled_size row groups in an iMCU row. */
  rowgroups_avail = (JDIMENSION) cinfo->min_DCT_scaled_size;
  /* Note: at the bottom of the image, we may pass extra garbage row groups
   * to the postprocessor.  The postprocessor has to check for bottom
   * of image anyway (at row resolution), so no point in us doing it too.
   */

  /* Feed the postprocessor */
  (*cinfo->post->post_process_data) (cinfo, main->buffer,
				     &main->rowgroup_ctr, rowgroups_avail,
				     output_buf, out_row_ctr, out_rows_avail);

  /* Has postprocessor consumed all the data yet? If so, mark buffer empty */
  if (main->rowgroup_ctr >= rowgroups_avail) {
    main->buffer_full = FALSE;
    main->rowgroup_ctr = 0;
  }
}


/*
 * Process some data.
 * This handles the case where context rows must be provided.
 */

METHODDEF(void)
process_data_context_main (j_decompress_ptr cinfo,
			   JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
			   JDIMENSION out_rows_avail)
{
  my_main_ptr main = (my_main_ptr) cinfo->main;

  /* Read input data if we haven't filled the main buffer yet */
  if (! main->buffer_full) {
    if (! (*cinfo->coef->decompress_data) (cinfo,
					   main->xbuffer[main->whichptr]))
      return;			/* suspension forced, can do nothing more */
    main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
    main->iMCU_row_ctr++;	/* count rows received */
  }

  /* Postprocessor typically will not swallow all the input data it is handed
   * in one call (due to filling the output buffer first).  Must be prepared
   * to exit and restart.  This switch lets us keep track of how far we got.
   * Note that each case falls through to the next on successful completion.
   */
  switch (main->context_state) {
  case CTX_POSTPONED_ROW:
    /* Call postprocessor using previously set pointers for postponed row */
    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
			&main->rowgroup_ctr, main->rowgroups_avail,
			output_buf, out_row_ctr, out_rows_avail);
    if (main->rowgroup_ctr < main->rowgroups_avail)
      return;			/* Need to suspend */
    main->context_state = CTX_PREPARE_FOR_IMCU;
    if (*out_row_ctr >= out_rows_avail)
      return;			/* Postprocessor exactly filled output buf */
    /*FALLTHROUGH*/
  case CTX_PREPARE_FOR_IMCU:
    /* Prepare to process first M-1 row groups of this iMCU row */
    main->rowgroup_ctr = 0;
    main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size - 1);
    /* Check for bottom of image: if so, tweak pointers to "duplicate"
     * the last sample row, and adjust rowgroups_avail to ignore padding rows.
     */
    if (main->iMCU_row_ctr == cinfo->total_iMCU_rows)
      set_bottom_pointers(cinfo);
    main->context_state = CTX_PROCESS_IMCU;
    /*FALLTHROUGH*/
  case CTX_PROCESS_IMCU:
    /* Call postprocessor using previously set pointers */
    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
			&main->rowgroup_ctr, main->rowgroups_avail,
			output_buf, out_row_ctr, out_rows_avail);
    if (main->rowgroup_ctr < main->rowgroups_avail)
      return;			/* Need to suspend */
    /* After the first iMCU, change wraparound pointers to normal state */
    if (main->iMCU_row_ctr == 1)
      set_wraparound_pointers(cinfo);
    /* Prepare to load new iMCU row using other xbuffer list */
    main->whichptr ^= 1;	/* 0=>1 or 1=>0 */
    main->buffer_full = FALSE;
    /* Still need to process last row group of this iMCU row, */
    /* which is saved at index M+1 of the other xbuffer */
    main->rowgroup_ctr = (JDIMENSION) (cinfo->min_DCT_scaled_size + 1);
    main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size + 2);
    main->context_state = CTX_POSTPONED_ROW;
  }
}


/*
 * Process some data.
 * Final pass of two-pass quantization: just call the postprocessor.
 * Source data will be the postprocessor controller's internal buffer.
 */

#ifdef QUANT_2PASS_SUPPORTED

METHODDEF(void)
process_data_crank_post (j_decompress_ptr cinfo,
			 JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
			 JDIMENSION out_rows_avail)
{
  (*cinfo->post->post_process_data) (cinfo, (JSAMPIMAGE) NULL,
				     (JDIMENSION *) NULL, (JDIMENSION) 0,
				     output_buf, out_row_ctr, out_rows_avail);
}

#endif /* QUANT_2PASS_SUPPORTED */


/*
 * Initialize main buffer controller.
 */

GLOBAL(void)
jinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
{
  my_main_ptr main;
  int ci, rgroup, ngroups;
  jpeg_component_info *compptr;

  main = (my_main_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_main_controller));
  cinfo->main = (struct jpeg_d_main_controller *) main;
  main->pub.start_pass = start_pass_main;

  if (need_full_buffer)		/* shouldn't happen */
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);

  /* Allocate the workspace.
   * ngroups is the number of row groups we need.
   */
  if (cinfo->upsample->need_context_rows) {
    if (cinfo->min_DCT_scaled_size < 2) /* unsupported, see comments above */
      ERREXIT(cinfo, JERR_NOTIMPL);
    alloc_funny_pointers(cinfo); /* Alloc space for xbuffer[] lists */
    ngroups = cinfo->min_DCT_scaled_size + 2;
  } else {
    ngroups = cinfo->min_DCT_scaled_size;
  }

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
      cinfo->min_DCT_scaled_size; /* height of a row group of component */
    main->buffer[ci] = (*cinfo->mem->alloc_sarray)
			((j_common_ptr) cinfo, JPOOL_IMAGE,
			 compptr->width_in_blocks * compptr->DCT_scaled_size,
			 (JDIMENSION) (rgroup * ngroups));
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jdmaster.c ===
/*
 * jdmaster.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains master control logic for the JPEG decompressor.
 * These routines are concerned with selecting the modules to be executed
 * and with determining the number of passes and the work to be done in each
 * pass.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/* Private state */

typedef struct {
  struct jpeg_decomp_master pub; /* public fields */

  int pass_number;		/* # of passes completed */

  boolean using_merged_upsample; /* TRUE if using merged upsample/cconvert */

  /* Saved references to initialized quantizer modules,
   * in case we need to switch modes.
   */
  struct jpeg_color_quantizer * quantizer_1pass;
  struct jpeg_color_quantizer * quantizer_2pass;
} my_decomp_master;

typedef my_decomp_master * my_master_ptr;


/*
 * Determine whether merged upsample/color conversion should be used.
 * CRUCIAL: this must match the actual capabilities of jdmerge.c!
 */

LOCAL(boolean)
use_merged_upsample (j_decompress_ptr cinfo)
{
#ifdef UPSAMPLE_MERGING_SUPPORTED
  /* Merging is the equivalent of plain box-filter upsampling */
  if (cinfo->do_fancy_upsampling || cinfo->CCIR601_sampling)
    return FALSE;
  /* jdmerge.c only supports YCC=>RGB color conversion */
  if (cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||
      cinfo->out_color_space != JCS_RGB ||
      cinfo->out_color_components != RGB_PIXELSIZE)
    return FALSE;
  /* and it only handles 2h1v or 2h2v sampling ratios */
  if (cinfo->comp_info[0].h_samp_factor != 2 ||
      cinfo->comp_info[1].h_samp_factor != 1 ||
      cinfo->comp_info[2].h_samp_factor != 1 ||
      cinfo->comp_info[0].v_samp_factor >  2 ||
      cinfo->comp_info[1].v_samp_factor != 1 ||
      cinfo->comp_info[2].v_samp_factor != 1)
    return FALSE;
  /* furthermore, it doesn't work if we've scaled the IDCTs differently */
  if (cinfo->comp_info[0].DCT_scaled_size != cinfo->min_DCT_scaled_size ||
      cinfo->comp_info[1].DCT_scaled_size != cinfo->min_DCT_scaled_size ||
      cinfo->comp_info[2].DCT_scaled_size != cinfo->min_DCT_scaled_size)
    return FALSE;
  /* ??? also need to test for upsample-time rescaling, when & if supported */
  return TRUE;			/* by golly, it'll work... */
#else
  return FALSE;
#endif
}


/*
 * Compute output image dimensions and related values.
 * NOTE: this is exported for possible use by application.
 * Hence it mustn't do anything that can't be done twice.
 * Also note that it may be called before the master module is initialized!
 */

GLOBAL(void)
jpeg_calc_output_dimensions (j_decompress_ptr cinfo)
/* Do computations that are needed before master selection phase */
{
  int ci;
  jpeg_component_info *compptr;

  /* Prevent application from calling me at wrong times */
  if (cinfo->global_state != DSTATE_READY)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

#ifdef IDCT_SCALING_SUPPORTED

  /* Compute actual output image dimensions and DCT scaling choices. */
  if (cinfo->scale_num * 8 <= cinfo->scale_denom) {
    /* Provide 1/8 scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width, 8L);
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height, 8L);
    cinfo->min_DCT_scaled_size = 1;
  } else if (cinfo->scale_num * 4 <= cinfo->scale_denom) {
    /* Provide 1/4 scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width, 4L);
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height, 4L);
    cinfo->min_DCT_scaled_size = 2;
  } else if (cinfo->scale_num * 2 <= cinfo->scale_denom) {
    /* Provide 1/2 scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width, 2L);
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height, 2L);
    cinfo->min_DCT_scaled_size = 4;
  } else {
    /* Provide 1/1 scaling */
    cinfo->output_width = cinfo->image_width;
    cinfo->output_height = cinfo->image_height;
    cinfo->min_DCT_scaled_size = DCTSIZE;
  }
  /* In selecting the actual DCT scaling for each component, we try to
   * scale up the chroma components via IDCT scaling rather than upsampling.
   * This saves time if the upsampler gets to use 1:1 scaling.
   * Note this code assumes that the supported DCT scalings are powers of 2.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    int ssize = cinfo->min_DCT_scaled_size;
    while (ssize < DCTSIZE &&
	   (compptr->h_samp_factor * ssize * 2 <=
	    cinfo->max_h_samp_factor * cinfo->min_DCT_scaled_size) &&
	   (compptr->v_samp_factor * ssize * 2 <=
	    cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size)) {
      ssize = ssize * 2;
    }
    compptr->DCT_scaled_size = ssize;
  }

  /* Recompute downsampled dimensions of components;
   * application needs to know these if using raw downsampled data.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Size in samples, after IDCT scaling */
    compptr->downsampled_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width *
		    (long) (compptr->h_samp_factor * compptr->DCT_scaled_size),
		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
    compptr->downsampled_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height *
		    (long) (compptr->v_samp_factor * compptr->DCT_scaled_size),
		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
  }

#else /* !IDCT_SCALING_SUPPORTED */

  /* Hardwire it to "no scaling" */
  cinfo->output_width = cinfo->image_width;
  cinfo->output_height = cinfo->image_height;
  /* jdinput.c has already initialized DCT_scaled_size to DCTSIZE,
   * and has computed unscaled downsampled_width and downsampled_height.
   */

#endif /* IDCT_SCALING_SUPPORTED */

  /* Report number of components in selected colorspace. */
  /* Probably this should be in the color conversion module... */
  switch (cinfo->out_color_space) {
  case JCS_GRAYSCALE:
    cinfo->out_color_components = 1;
    break;
  case JCS_RGB:
#if RGB_PIXELSIZE != 3
    cinfo->out_color_components = RGB_PIXELSIZE;
    break;
#endif /* else share code with YCbCr */
  case JCS_YCbCr:
    cinfo->out_color_components = 3;
    break;
  case JCS_CMYK:
  case JCS_YCCK:
    cinfo->out_color_components = 4;
    break;
  default:			/* else must be same colorspace as in file */
    cinfo->out_color_components = cinfo->num_components;
    break;
  }
  cinfo->output_components = (cinfo->quantize_colors ? 1 :
			      cinfo->out_color_components);

  /* See if upsampler will want to emit more than one row at a time */
  if (use_merged_upsample(cinfo))
    cinfo->rec_outbuf_height = cinfo->max_v_samp_factor;
  else
    cinfo->rec_outbuf_height = 1;
}


/*
 * Several decompression processes need to range-limit values to the range
 * 0..MAXJSAMPLE; the input value may fall somewhat outside this range
 * due to noise introduced by quantization, roundoff error, etc.  These
 * processes are inner loops and need to be as fast as possible.  On most
 * machines, particularly CPUs with pipelines or instruction prefetch,
 * a (subscript-check-less) C table lookup
 *		x = sample_range_limit[x];
 * is faster than explicit tests
 *		if (x < 0)  x = 0;
 *		else if (x > MAXJSAMPLE)  x = MAXJSAMPLE;
 * These processes all use a common table prepared by the routine below.
 *
 * For most steps we can mathematically guarantee that the initial value
 * of x is within MAXJSAMPLE+1 of the legal range, so a table running from
 * -(MAXJSAMPLE+1) to 2*MAXJSAMPLE+1 is sufficient.  But for the initial
 * limiting step (just after the IDCT), a wildly out-of-range value is 
 * possible if the input data is corrupt.  To avoid any chance of indexing
 * off the end of memory and getting a bad-pointer trap, we perform the
 * post-IDCT limiting thus:
 *		x = range_limit[x & MASK];
 * where MASK is 2 bits wider than legal sample data, ie 10 bits for 8-bit
 * samples.  Under normal circumstances this is more than enough range and
 * a correct output will be generated; with bogus input data the mask will
 * cause wraparound, and we will safely generate a bogus-but-in-range output.
 * For the post-IDCT step, we want to convert the data from signed to unsigned
 * representation by adding CENTERJSAMPLE at the same time that we limit it.
 * So the post-IDCT limiting table ends up looking like this:
 *   CENTERJSAMPLE,CENTERJSAMPLE+1,...,MAXJSAMPLE,
 *   MAXJSAMPLE (repeat 2*(MAXJSAMPLE+1)-CENTERJSAMPLE times),
 *   0          (repeat 2*(MAXJSAMPLE+1)-CENTERJSAMPLE times),
 *   0,1,...,CENTERJSAMPLE-1
 * Negative inputs select values from the upper half of the table after
 * masking.
 *
 * We can save some space by overlapping the start of the post-IDCT table
 * with the simpler range limiting table.  The post-IDCT table begins at
 * sample_range_limit + CENTERJSAMPLE.
 *
 * Note that the table is allocated in near data space on PCs; it's small
 * enough and used often enough to justify this.
 */

LOCAL(void)
prepare_range_limit_table (j_decompress_ptr cinfo)
/* Allocate and fill in the sample_range_limit table */
{
  JSAMPLE * table;
  int i;

  table = (JSAMPLE *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
		(5 * (MAXJSAMPLE+1) + CENTERJSAMPLE) * SIZEOF(JSAMPLE));
  table += (MAXJSAMPLE+1);	/* allow negative subscripts of simple table */
  cinfo->sample_range_limit = table;
  /* First segment of "simple" table: limit[x] = 0 for x < 0 */
  MEMZERO(table - (MAXJSAMPLE+1), (MAXJSAMPLE+1) * SIZEOF(JSAMPLE));
  /* Main part of "simple" table: limit[x] = x */
  for (i = 0; i <= MAXJSAMPLE; i++)
    table[i] = (JSAMPLE) i;
  table += CENTERJSAMPLE;	/* Point to where post-IDCT table starts */
  /* End of simple table, rest of first half of post-IDCT table */
  for (i = CENTERJSAMPLE; i < 2*(MAXJSAMPLE+1); i++)
    table[i] = MAXJSAMPLE;
  /* Second half of post-IDCT table */
  MEMZERO(table + (2 * (MAXJSAMPLE+1)),
	  (2 * (MAXJSAMPLE+1) - CENTERJSAMPLE) * SIZEOF(JSAMPLE));
  MEMCOPY(table + (4 * (MAXJSAMPLE+1) - CENTERJSAMPLE),
	  cinfo->sample_range_limit, CENTERJSAMPLE * SIZEOF(JSAMPLE));
}


/*
 * Master selection of decompression modules.
 * This is done once at jpeg_start_decompress time.  We determine
 * which modules will be used and give them appropriate initialization calls.
 * We also initialize the decompressor input side to begin consuming data.
 *
 * Since jpeg_read_header has finished, we know what is in the SOF
 * and (first) SOS markers.  We also have all the application parameter
 * settings.
 */

LOCAL(void)
master_selection (j_decompress_ptr cinfo)
{
  my_master_ptr master = (my_master_ptr) cinfo->master;
  boolean use_c_buffer;
  long samplesperrow;
  JDIMENSION jd_samplesperrow;

  /* Initialize dimensions and other stuff */
  jpeg_calc_output_dimensions(cinfo);
  prepare_range_limit_table(cinfo);

  /* Width of an output scanline must be representable as JDIMENSION. */
  samplesperrow = (long) cinfo->output_width * (long) cinfo->out_color_components;
  jd_samplesperrow = (JDIMENSION) samplesperrow;
  if ((long) jd_samplesperrow != samplesperrow)
    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);

  /* Initialize my private state */
  master->pass_number = 0;
  master->using_merged_upsample = use_merged_upsample(cinfo);

  /* Color quantizer selection */
  master->quantizer_1pass = NULL;
  master->quantizer_2pass = NULL;
  /* No mode changes if not using buffered-image mode. */
  if (! cinfo->quantize_colors || ! cinfo->buffered_image) {
    cinfo->enable_1pass_quant = FALSE;
    cinfo->enable_external_quant = FALSE;
    cinfo->enable_2pass_quant = FALSE;
  }
  if (cinfo->quantize_colors) {
    if (cinfo->raw_data_out)
      ERREXIT(cinfo, JERR_NOTIMPL);
    /* 2-pass quantizer only works in 3-component color space. */
    if (cinfo->out_color_components != 3) {
      cinfo->enable_1pass_quant = TRUE;
      cinfo->enable_external_quant = FALSE;
      cinfo->enable_2pass_quant = FALSE;
      cinfo->colormap = NULL;
    } else if (cinfo->colormap != NULL) {
      cinfo->enable_external_quant = TRUE;
    } else if (cinfo->two_pass_quantize) {
      cinfo->enable_2pass_quant = TRUE;
    } else {
      cinfo->enable_1pass_quant = TRUE;
    }

    if (cinfo->enable_1pass_quant) {
#ifdef QUANT_1PASS_SUPPORTED
      jinit_1pass_quantizer(cinfo);
      master->quantizer_1pass = cinfo->cquantize;
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
    }

    /* We use the 2-pass code to map to external colormaps. */
    if (cinfo->enable_2pass_quant || cinfo->enable_external_quant) {
#ifdef QUANT_2PASS_SUPPORTED
      jinit_2pass_quantizer(cinfo);
      master->quantizer_2pass = cinfo->cquantize;
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
    }
    /* If both quantizers are initialized, the 2-pass one is left active;
     * this is necessary for starting with quantization to an external map.
     */
  }

  /* Post-processing: in particular, color conversion first */
  if (! cinfo->raw_data_out) {
    if (master->using_merged_upsample) {
#ifdef UPSAMPLE_MERGING_SUPPORTED
      jinit_merged_upsampler(cinfo); /* does color conversion too */
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
    } else {
      jinit_color_deconverter(cinfo);
      jinit_upsampler(cinfo);
    }
    jinit_d_post_controller(cinfo, cinfo->enable_2pass_quant);
  }
  /* Inverse DCT */
  jinit_inverse_dct(cinfo);
  /* Entropy decoding: either Huffman or arithmetic coding. */
  if (cinfo->arith_code) {
    ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
  } else {
    if (cinfo->progressive_mode) {
#ifdef D_PROGRESSIVE_SUPPORTED
      jinit_phuff_decoder(cinfo);
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
    } else
      jinit_huff_decoder(cinfo);
  }

  /* Initialize principal buffer controllers. */
  use_c_buffer = cinfo->inputctl->has_multiple_scans || cinfo->buffered_image;
  jinit_d_coef_controller(cinfo, use_c_buffer);

  if (! cinfo->raw_data_out)
    jinit_d_main_controller(cinfo, FALSE /* never need full buffer here */);

  /* We can now tell the memory manager to allocate virtual arrays. */
  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);

  /* Initialize input side of decompressor to consume first scan. */
  (*cinfo->inputctl->start_input_pass) (cinfo);

#ifdef D_MULTISCAN_FILES_SUPPORTED
  /* If jpeg_start_decompress will read the whole file, initialize
   * progress monitoring appropriately.  The input step is counted
   * as one pass.
   */
  if (cinfo->progress != NULL && ! cinfo->buffered_image &&
      cinfo->inputctl->has_multiple_scans) {
    int nscans;
    /* Estimate number of scans to set pass_limit. */
    if (cinfo->progressive_mode) {
      /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
      nscans = 2 + 3 * cinfo->num_components;
    } else {
      /* For a nonprogressive multiscan file, estimate 1 scan per component. */
      nscans = cinfo->num_components;
    }
    cinfo->progress->pass_counter = 0L;
    cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows * nscans;
    cinfo->progress->completed_passes = 0;
    cinfo->progress->total_passes = (cinfo->enable_2pass_quant ? 3 : 2);
    /* Count the input pass as done */
    master->pass_number++;
  }
#endif /* D_MULTISCAN_FILES_SUPPORTED */
}


/*
 * Per-pass setup.
 * This is called at the beginning of each output pass.  We determine which
 * modules will be active during this pass and give them appropriate
 * start_pass calls.  We also set is_dummy_pass to indicate whether this
 * is a "real" output pass or a dummy pass for color quantization.
 * (In the latter case, jdapi.c will crank the pass to completion.)
 */

METHODDEF(void)
prepare_for_output_pass (j_decompress_ptr cinfo)
{
  my_master_ptr master = (my_master_ptr) cinfo->master;

  if (master->pub.is_dummy_pass) {
#ifdef QUANT_2PASS_SUPPORTED
    /* Final pass of 2-pass quantization */
    master->pub.is_dummy_pass = FALSE;
    (*cinfo->cquantize->start_pass) (cinfo, FALSE);
    (*cinfo->post->start_pass) (cinfo, JBUF_CRANK_DEST);
    (*cinfo->main->start_pass) (cinfo, JBUF_CRANK_DEST);
#else
    ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif /* QUANT_2PASS_SUPPORTED */
  } else {
    if (cinfo->quantize_colors && cinfo->colormap == NULL) {
      /* Select new quantization method */
      if (cinfo->two_pass_quantize && cinfo->enable_2pass_quant) {
	cinfo->cquantize = master->quantizer_2pass;
	master->pub.is_dummy_pass = TRUE;
      } else if (cinfo->enable_1pass_quant) {
	cinfo->cquantize = master->quantizer_1pass;
      } else {
	ERREXIT(cinfo, JERR_MODE_CHANGE);
      }
    }
    (*cinfo->idct->start_pass) (cinfo);
    (*cinfo->coef->start_output_pass) (cinfo);
    if (! cinfo->raw_data_out) {
      if (! master->using_merged_upsample)
	(*cinfo->cconvert->start_pass) (cinfo);
      (*cinfo->upsample->start_pass) (cinfo);
      if (cinfo->quantize_colors)
	(*cinfo->cquantize->start_pass) (cinfo, master->pub.is_dummy_pass);
      (*cinfo->post->start_pass) (cinfo,
	    (master->pub.is_dummy_pass ? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
      (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);
    }
  }

  /* Set up progress monitor's pass info if present */
  if (cinfo->progress != NULL) {
    cinfo->progress->completed_passes = master->pass_number;
    cinfo->progress->total_passes = master->pass_number +
				    (master->pub.is_dummy_pass ? 2 : 1);
    /* In buffered-image mode, we assume one more output pass if EOI not
     * yet reached, but no more passes if EOI has been reached.
     */
    if (cinfo->buffered_image && ! cinfo->inputctl->eoi_reached) {
      cinfo->progress->total_passes += (cinfo->enable_2pass_quant ? 2 : 1);
    }
  }
}


/*
 * Finish up at end of an output pass.
 */

METHODDEF(void)
finish_output_pass (j_decompress_ptr cinfo)
{
  my_master_ptr master = (my_master_ptr) cinfo->master;

  if (cinfo->quantize_colors)
    (*cinfo->cquantize->finish_pass) (cinfo);
  master->pass_number++;
}


#ifdef D_MULTISCAN_FILES_SUPPORTED

/*
 * Switch to a new external colormap between output passes.
 */

GLOBAL(void)
jpeg_new_colormap (j_decompress_ptr cinfo)
{
  my_master_ptr master = (my_master_ptr) cinfo->master;

  /* Prevent application from calling me at wrong times */
  if (cinfo->global_state != DSTATE_BUFIMAGE)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  if (cinfo->quantize_colors && cinfo->enable_external_quant &&
      cinfo->colormap != NULL) {
    /* Select 2-pass quantizer for external colormap use */
    cinfo->cquantize = master->quantizer_2pass;
    /* Notify quantizer of colormap change */
    (*cinfo->cquantize->new_color_map) (cinfo);
    master->pub.is_dummy_pass = FALSE; /* just in case */
  } else
    ERREXIT(cinfo, JERR_MODE_CHANGE);
}

#endif /* D_MULTISCAN_FILES_SUPPORTED */


/*
 * Initialize master decompression control and select active modules.
 * This is performed at the start of jpeg_start_decompress.
 */

GLOBAL(void)
jinit_master_decompress (j_decompress_ptr cinfo)
{
  my_master_ptr master;

  master = (my_master_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  SIZEOF(my_decomp_master));
  cinfo->master = (struct jpeg_decomp_master *) master;
  master->pub.prepare_for_output_pass = prepare_for_output_pass;
  master->pub.finish_output_pass = finish_output_pass;

  master->pub.is_dummy_pass = FALSE;

  master_selection(cinfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jdmarker.c ===
/*
 * jdmarker.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains routines to decode JPEG datastream markers.
 * Most of the complexity arises from our desire to support input
 * suspension: if not all of the data for a marker is available,
 * we must exit back to the application.  On resumption, we reprocess
 * the marker.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


typedef enum {			/* JPEG marker codes */
  M_SOF0  = 0xc0,
  M_SOF1  = 0xc1,
  M_SOF2  = 0xc2,
  M_SOF3  = 0xc3,
  
  M_SOF5  = 0xc5,
  M_SOF6  = 0xc6,
  M_SOF7  = 0xc7,
  
  M_JPG   = 0xc8,
  M_SOF9  = 0xc9,
  M_SOF10 = 0xca,
  M_SOF11 = 0xcb,
  
  M_SOF13 = 0xcd,
  M_SOF14 = 0xce,
  M_SOF15 = 0xcf,
  
  M_DHT   = 0xc4,
  
  M_DAC   = 0xcc,
  
  M_RST0  = 0xd0,
  M_RST1  = 0xd1,
  M_RST2  = 0xd2,
  M_RST3  = 0xd3,
  M_RST4  = 0xd4,
  M_RST5  = 0xd5,
  M_RST6  = 0xd6,
  M_RST7  = 0xd7,
  
  M_SOI   = 0xd8,
  M_EOI   = 0xd9,
  M_SOS   = 0xda,
  M_DQT   = 0xdb,
  M_DNL   = 0xdc,
  M_DRI   = 0xdd,
  M_DHP   = 0xde,
  M_EXP   = 0xdf,
  
  M_APP0  = 0xe0,
  M_APP1  = 0xe1,
  M_APP2  = 0xe2,
  M_APP3  = 0xe3,
  M_APP4  = 0xe4,
  M_APP5  = 0xe5,
  M_APP6  = 0xe6,
  M_APP7  = 0xe7,
  M_APP8  = 0xe8,
  M_APP9  = 0xe9,
  M_APP10 = 0xea,
  M_APP11 = 0xeb,
  M_APP12 = 0xec,
  M_APP13 = 0xed,
  M_APP14 = 0xee,
  M_APP15 = 0xef,
  
  M_JPG0  = 0xf0,
  M_JPG13 = 0xfd,
  M_COM   = 0xfe,
  
  M_TEM   = 0x01,
  
  M_ERROR = 0x100
} JPEG_MARKER;


/*
 * Macros for fetching data from the data source module.
 *
 * At all times, cinfo->src->next_input_byte and ->bytes_in_buffer reflect
 * the current restart point; we update them only when we have reached a
 * suitable place to restart if a suspension occurs.
 */

/* Declare and initialize local copies of input pointer/count */
#define INPUT_VARS(cinfo)  \
	struct jpeg_source_mgr * datasrc = (cinfo)->src;  \
	const JOCTET * next_input_byte = datasrc->next_input_byte;  \
	size_t bytes_in_buffer = datasrc->bytes_in_buffer

/* Unload the local copies --- do this only at a restart boundary */
#define INPUT_SYNC(cinfo)  \
	( datasrc->next_input_byte = next_input_byte,  \
	  datasrc->bytes_in_buffer = bytes_in_buffer )

/* Reload the local copies --- seldom used except in MAKE_BYTE_AVAIL */
#define INPUT_RELOAD(cinfo)  \
	( next_input_byte = datasrc->next_input_byte,  \
	  bytes_in_buffer = datasrc->bytes_in_buffer )

/* Internal macro for INPUT_BYTE and INPUT_2BYTES: make a byte available.
 * Note we do *not* do INPUT_SYNC before calling fill_input_buffer,
 * but we must reload the local copies after a successful fill.
 */
#define MAKE_BYTE_AVAIL(cinfo,action)  \
	if (bytes_in_buffer == 0) {  \
	  if (! (*datasrc->fill_input_buffer) (cinfo))  \
	    { action; }  \
	  INPUT_RELOAD(cinfo);  \
	}  \
	bytes_in_buffer--

/* Read a byte into variable V.
 * If must suspend, take the specified action (typically "return FALSE").
 */
#define INPUT_BYTE(cinfo,V,action)  \
	MAKESTMT( MAKE_BYTE_AVAIL(cinfo,action); \
		  V = GETJOCTET(*next_input_byte++); )

/* As above, but read two bytes interpreted as an unsigned 16-bit integer.
 * V should be declared unsigned int or perhaps INT32.
 */
#define INPUT_2BYTES(cinfo,V,action)  \
	MAKESTMT( MAKE_BYTE_AVAIL(cinfo,action); \
		  V = ((unsigned int) GETJOCTET(*next_input_byte++)) << 8; \
		  MAKE_BYTE_AVAIL(cinfo,action); \
		  V += GETJOCTET(*next_input_byte++); )


/*
 * Routines to process JPEG markers.
 *
 * Entry condition: JPEG marker itself has been read and its code saved
 *   in cinfo->unread_marker; input restart point is just after the marker.
 *
 * Exit: if return TRUE, have read and processed any parameters, and have
 *   updated the restart point to point after the parameters.
 *   If return FALSE, was forced to suspend before reaching end of
 *   marker parameters; restart point has not been moved.  Same routine
 *   will be called again after application supplies more input data.
 *
 * This approach to suspension assumes that all of a marker's parameters can
 * fit into a single input bufferload.  This should hold for "normal"
 * markers.  Some COM/APPn markers might have large parameter segments,
 * but we use skip_input_data to get past those, and thereby put the problem
 * on the source manager's shoulders.
 *
 * Note that we don't bother to avoid duplicate trace messages if a
 * suspension occurs within marker parameters.  Other side effects
 * require more care.
 */


LOCAL(boolean)
get_soi (j_decompress_ptr cinfo)
/* Process an SOI marker */
{
  int i;
  
  TRACEMS(cinfo, 1, JTRC_SOI);

  if (cinfo->marker->saw_SOI)
    ERREXIT(cinfo, JERR_SOI_DUPLICATE);

  /* Reset all parameters that are defined to be reset by SOI */

  for (i = 0; i < NUM_ARITH_TBLS; i++) {
    cinfo->arith_dc_L[i] = 0;
    cinfo->arith_dc_U[i] = 1;
    cinfo->arith_ac_K[i] = 5;
  }
  cinfo->restart_interval = 0;

  /* Set initial assumptions for colorspace etc */

  cinfo->jpeg_color_space = JCS_UNKNOWN;
  cinfo->CCIR601_sampling = FALSE; /* Assume non-CCIR sampling??? */

  cinfo->saw_JFIF_marker = FALSE;
  cinfo->density_unit = 0;	/* set default JFIF APP0 values */
  cinfo->X_density = 1;
  cinfo->Y_density = 1;
  cinfo->saw_Adobe_marker = FALSE;
  cinfo->Adobe_transform = 0;

  cinfo->marker->saw_SOI = TRUE;

  return TRUE;
}


LOCAL(boolean)
get_sof (j_decompress_ptr cinfo, boolean is_prog, boolean is_arith)
/* Process a SOFn marker */
{
  INT32 length;
  int c, ci;
  jpeg_component_info * compptr;
  INPUT_VARS(cinfo);

  cinfo->progressive_mode = is_prog;
  cinfo->arith_code = is_arith;

  INPUT_2BYTES(cinfo, length, return FALSE);

  INPUT_BYTE(cinfo, cinfo->data_precision, return FALSE);
  INPUT_2BYTES(cinfo, cinfo->image_height, return FALSE);
  INPUT_2BYTES(cinfo, cinfo->image_width, return FALSE);
  INPUT_BYTE(cinfo, cinfo->num_components, return FALSE);

  length -= 8;

  TRACEMS4(cinfo, 1, JTRC_SOF, cinfo->unread_marker,
	   (int) cinfo->image_width, (int) cinfo->image_height,
	   cinfo->num_components);

  if (cinfo->marker->saw_SOF)
    ERREXIT(cinfo, JERR_SOF_DUPLICATE);

  /* We don't support files in which the image height is initially specified */
  /* as 0 and is later redefined by DNL.  As long as we have to check that,  */
  /* might as well have a general sanity check. */
  if (cinfo->image_height <= 0 || cinfo->image_width <= 0
      || cinfo->num_components <= 0)
    ERREXIT(cinfo, JERR_EMPTY_IMAGE);

  if (length != (cinfo->num_components * 3))
    ERREXIT(cinfo, JERR_BAD_LENGTH);

  if (cinfo->comp_info == NULL)	/* do only once, even if suspend */
    cinfo->comp_info = (jpeg_component_info *) (*cinfo->mem->alloc_small)
			((j_common_ptr) cinfo, JPOOL_IMAGE,
			 cinfo->num_components * SIZEOF(jpeg_component_info));
  
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    compptr->component_index = ci;
    INPUT_BYTE(cinfo, compptr->component_id, return FALSE);
    INPUT_BYTE(cinfo, c, return FALSE);
    compptr->h_samp_factor = (c >> 4) & 15;
    compptr->v_samp_factor = (c     ) & 15;
    INPUT_BYTE(cinfo, compptr->quant_tbl_no, return FALSE);

    TRACEMS4(cinfo, 1, JTRC_SOF_COMPONENT,
	     compptr->component_id, compptr->h_samp_factor,
	     compptr->v_samp_factor, compptr->quant_tbl_no);
  }

  cinfo->marker->saw_SOF = TRUE;

  INPUT_SYNC(cinfo);
  return TRUE;
}


LOCAL(boolean)
get_sos (j_decompress_ptr cinfo)
/* Process a SOS marker */
{
  INT32 length;
  int i, ci, n, c, cc;
  jpeg_component_info * compptr;
  INPUT_VARS(cinfo);

  if (! cinfo->marker->saw_SOF)
    ERREXIT(cinfo, JERR_SOS_NO_SOF);

  INPUT_2BYTES(cinfo, length, return FALSE);

  INPUT_BYTE(cinfo, n, return FALSE); /* Number of components */

  if (length != (n * 2 + 6) || n < 1 || n > MAX_COMPS_IN_SCAN)
    ERREXIT(cinfo, JERR_BAD_LENGTH);

  TRACEMS1(cinfo, 1, JTRC_SOS, n);

  cinfo->comps_in_scan = n;

  /* Collect the component-spec parameters */

  for (i = 0; i < n; i++) {
    INPUT_BYTE(cinfo, cc, return FALSE);
    INPUT_BYTE(cinfo, c, return FALSE);
    
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
	 ci++, compptr++) {
      if (cc == compptr->component_id)
	goto id_found;
    }

    ERREXIT1(cinfo, JERR_BAD_COMPONENT_ID, cc);

  id_found:

    cinfo->cur_comp_info[i] = compptr;
    compptr->dc_tbl_no = (c >> 4) & 15;
    compptr->ac_tbl_no = (c     ) & 15;
    
    TRACEMS3(cinfo, 1, JTRC_SOS_COMPONENT, cc,
	     compptr->dc_tbl_no, compptr->ac_tbl_no);
  }

  /* Collect the additional scan parameters Ss, Se, Ah/Al. */
  INPUT_BYTE(cinfo, c, return FALSE);
  cinfo->Ss = c;
  INPUT_BYTE(cinfo, c, return FALSE);
  cinfo->Se = c;
  INPUT_BYTE(cinfo, c, return FALSE);
  cinfo->Ah = (c >> 4) & 15;
  cinfo->Al = (c     ) & 15;

  TRACEMS4(cinfo, 1, JTRC_SOS_PARAMS, cinfo->Ss, cinfo->Se,
	   cinfo->Ah, cinfo->Al);

  /* Prepare to scan data & restart markers */
  cinfo->marker->next_restart_num = 0;

  /* Count another SOS marker */
  cinfo->input_scan_number++;

  INPUT_SYNC(cinfo);
  return TRUE;
}


METHODDEF(boolean)
get_app0 (j_decompress_ptr cinfo)
/* Process an APP0 marker */
{
#define JFIF_LEN 14
  INT32 length;
  UINT8 b[JFIF_LEN];
  int buffp;
  INPUT_VARS(cinfo);

  INPUT_2BYTES(cinfo, length, return FALSE);
  length -= 2;

  /* See if a JFIF APP0 marker is present */

  if (length >= JFIF_LEN) {
    for (buffp = 0; buffp < JFIF_LEN; buffp++)
      INPUT_BYTE(cinfo, b[buffp], return FALSE);
    length -= JFIF_LEN;

    if (b[0]==0x4A && b[1]==0x46 && b[2]==0x49 && b[3]==0x46 && b[4]==0) {
      /* Found JFIF APP0 marker: check version */
      /* Major version must be 1, anything else signals an incompatible change.
       * We used to treat this as an error, but now it's a nonfatal warning.
       * Minor version should be 0..2, but process anyway if newer.
       */
      if (b[5] != 1)
	WARNMS2(cinfo, JWRN_JFIF_MAJOR, b[5], b[6]);
      else if (b[6] > 2)
	TRACEMS2(cinfo, 1, JTRC_JFIF_MINOR, b[5], b[6]);
      /* Save info */
      cinfo->saw_JFIF_marker = TRUE;
      cinfo->density_unit = b[7];
      cinfo->X_density = (b[8] << 8) + b[9];
      cinfo->Y_density = (b[10] << 8) + b[11];
      TRACEMS3(cinfo, 1, JTRC_JFIF,
	       cinfo->X_density, cinfo->Y_density, cinfo->density_unit);
      if (b[12] | b[13])
	TRACEMS2(cinfo, 1, JTRC_JFIF_THUMBNAIL, b[12], b[13]);
      if (length != ((INT32) b[12] * (INT32) b[13] * (INT32) 3))
	TRACEMS1(cinfo, 1, JTRC_JFIF_BADTHUMBNAILSIZE, (int) length);
    } else {
      /* Start of APP0 does not match "JFIF" */
      TRACEMS1(cinfo, 1, JTRC_APP0, (int) length + JFIF_LEN);
    }
  } else {
    /* Too short to be JFIF marker */
    TRACEMS1(cinfo, 1, JTRC_APP0, (int) length);
  }

  INPUT_SYNC(cinfo);
  if (length > 0)		/* skip any remaining data -- could be lots */
    (*cinfo->src->skip_input_data) (cinfo, (long) length);

  return TRUE;
}


METHODDEF(boolean)
get_app14 (j_decompress_ptr cinfo)
/* Process an APP14 marker */
{
#define ADOBE_LEN 12
  INT32 length;
  UINT8 b[ADOBE_LEN];
  int buffp;
  unsigned int version, flags0, flags1, transform;
  INPUT_VARS(cinfo);

  INPUT_2BYTES(cinfo, length, return FALSE);
  length -= 2;

  /* See if an Adobe APP14 marker is present */

  if (length >= ADOBE_LEN) {
    for (buffp = 0; buffp < ADOBE_LEN; buffp++)
      INPUT_BYTE(cinfo, b[buffp], return FALSE);
    length -= ADOBE_LEN;

    if (b[0]==0x41 && b[1]==0x64 && b[2]==0x6F && b[3]==0x62 && b[4]==0x65) {
      /* Found Adobe APP14 marker */
      version = (b[5] << 8) + b[6];
      flags0 = (b[7] << 8) + b[8];
      flags1 = (b[9] << 8) + b[10];
      transform = b[11];
      TRACEMS4(cinfo, 1, JTRC_ADOBE, version, flags0, flags1, transform);
      cinfo->saw_Adobe_marker = TRUE;
      cinfo->Adobe_transform = (UINT8) transform;
    } else {
      /* Start of APP14 does not match "Adobe" */
      TRACEMS1(cinfo, 1, JTRC_APP14, (int) length + ADOBE_LEN);
    }
  } else {
    /* Too short to be Adobe marker */
    TRACEMS1(cinfo, 1, JTRC_APP14, (int) length);
  }

  INPUT_SYNC(cinfo);
  if (length > 0)		/* skip any remaining data -- could be lots */
    (*cinfo->src->skip_input_data) (cinfo, (long) length);

  return TRUE;
}


LOCAL(boolean)
get_dac (j_decompress_ptr cinfo)
/* Process a DAC marker */
{
  INT32 length;
  int index, val;
  INPUT_VARS(cinfo);

  INPUT_2BYTES(cinfo, length, return FALSE);
  length -= 2;
  
  while (length > 0) {
    INPUT_BYTE(cinfo, index, return FALSE);
    INPUT_BYTE(cinfo, val, return FALSE);

    length -= 2;

    TRACEMS2(cinfo, 1, JTRC_DAC, index, val);

    if (index < 0 || index >= (2*NUM_ARITH_TBLS))
      ERREXIT1(cinfo, JERR_DAC_INDEX, index);

    if (index >= NUM_ARITH_TBLS) { /* define AC table */
      cinfo->arith_ac_K[index-NUM_ARITH_TBLS] = (UINT8) val;
    } else {			/* define DC table */
      cinfo->arith_dc_L[index] = (UINT8) (val & 0x0F);
      cinfo->arith_dc_U[index] = (UINT8) (val >> 4);
      if (cinfo->arith_dc_L[index] > cinfo->arith_dc_U[index])
	ERREXIT1(cinfo, JERR_DAC_VALUE, val);
    }
  }

  INPUT_SYNC(cinfo);
  return TRUE;
}


LOCAL(boolean)
get_dht (j_decompress_ptr cinfo)
/* Process a DHT marker */
{
  INT32 length;
  UINT8 bits[17];
  UINT8 huffval[256];
  int i, index, count;
  JHUFF_TBL **htblptr;
  INPUT_VARS(cinfo);

  INPUT_2BYTES(cinfo, length, return FALSE);
  length -= 2;
  
  while (length > 0) {
    INPUT_BYTE(cinfo, index, return FALSE);

    TRACEMS1(cinfo, 1, JTRC_DHT, index);
      
    bits[0] = 0;
    count = 0;
    for (i = 1; i <= 16; i++) {
      INPUT_BYTE(cinfo, bits[i], return FALSE);
      count += bits[i];
    }

    length -= 1 + 16;

    TRACEMS8(cinfo, 2, JTRC_HUFFBITS,
	     bits[1], bits[2], bits[3], bits[4],
	     bits[5], bits[6], bits[7], bits[8]);
    TRACEMS8(cinfo, 2, JTRC_HUFFBITS,
	     bits[9], bits[10], bits[11], bits[12],
	     bits[13], bits[14], bits[15], bits[16]);

    if (count > 256 || ((INT32) count) > length)
      ERREXIT(cinfo, JERR_DHT_COUNTS);

    for (i = 0; i < count; i++)
      INPUT_BYTE(cinfo, huffval[i], return FALSE);

    length -= count;

    if (index & 0x10) {		/* AC table definition */
      index -= 0x10;
      htblptr = &cinfo->ac_huff_tbl_ptrs[index];
    } else {			/* DC table definition */
      htblptr = &cinfo->dc_huff_tbl_ptrs[index];
    }

    if (index < 0 || index >= NUM_HUFF_TBLS)
      ERREXIT1(cinfo, JERR_DHT_INDEX, index);

    if (*htblptr == NULL)
      *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
  
    MEMCOPY((*htblptr)->bits, bits, SIZEOF((*htblptr)->bits));
    MEMCOPY((*htblptr)->huffval, huffval, SIZEOF((*htblptr)->huffval));
  }

  INPUT_SYNC(cinfo);
  return TRUE;
}


LOCAL(boolean)
get_dqt (j_decompress_ptr cinfo)
/* Process a DQT marker */
{
  INT32 length;
  int n, i, prec;
  unsigned int tmp;
  JQUANT_TBL *quant_ptr;
  INPUT_VARS(cinfo);

  INPUT_2BYTES(cinfo, length, return FALSE);
  length -= 2;

  while (length > 0) {
    INPUT_BYTE(cinfo, n, return FALSE);
    prec = n >> 4;
    n &= 0x0F;

    TRACEMS2(cinfo, 1, JTRC_DQT, n, prec);

    if (n >= NUM_QUANT_TBLS)
      ERREXIT1(cinfo, JERR_DQT_INDEX, n);
      
    if (cinfo->quant_tbl_ptrs[n] == NULL)
      cinfo->quant_tbl_ptrs[n] = jpeg_alloc_quant_table((j_common_ptr) cinfo);
    quant_ptr = cinfo->quant_tbl_ptrs[n];

    for (i = 0; i < DCTSIZE2; i++) {
      if (prec)
	INPUT_2BYTES(cinfo, tmp, return FALSE);
      else
	INPUT_BYTE(cinfo, tmp, return FALSE);
      /* We convert the zigzag-order table to natural array order. */
      quant_ptr->quantval[jpeg_natural_order[i]] = (UINT16) tmp;
    }

    if (cinfo->err->trace_level >= 2) {
      for (i = 0; i < DCTSIZE2; i += 8) {
	TRACEMS8(cinfo, 2, JTRC_QUANTVALS,
		 quant_ptr->quantval[i],   quant_ptr->quantval[i+1],
		 quant_ptr->quantval[i+2], quant_ptr->quantval[i+3],
		 quant_ptr->quantval[i+4], quant_ptr->quantval[i+5],
		 quant_ptr->quantval[i+6], quant_ptr->quantval[i+7]);
      }
    }

    length -= DCTSIZE2+1;
    if (prec) length -= DCTSIZE2;
  }

  INPUT_SYNC(cinfo);
  return TRUE;
}


LOCAL(boolean)
get_dri (j_decompress_ptr cinfo)
/* Process a DRI marker */
{
  INT32 length;
  unsigned int tmp;
  INPUT_VARS(cinfo);

  INPUT_2BYTES(cinfo, length, return FALSE);
  
  if (length != 4)
    ERREXIT(cinfo, JERR_BAD_LENGTH);

  INPUT_2BYTES(cinfo, tmp, return FALSE);

  TRACEMS1(cinfo, 1, JTRC_DRI, tmp);

  cinfo->restart_interval = tmp;

  INPUT_SYNC(cinfo);
  return TRUE;
}


METHODDEF(boolean)
skip_variable (j_decompress_ptr cinfo)
/* Skip over an unknown or uninteresting variable-length marker */
{
  INT32 length;
  INPUT_VARS(cinfo);

  INPUT_2BYTES(cinfo, length, return FALSE);
  
  TRACEMS2(cinfo, 1, JTRC_MISC_MARKER, cinfo->unread_marker, (int) length);

  INPUT_SYNC(cinfo);		/* do before skip_input_data */
  (*cinfo->src->skip_input_data) (cinfo, (long) length - 2L);

  return TRUE;
}


/*
 * Find the next JPEG marker, save it in cinfo->unread_marker.
 * Returns FALSE if had to suspend before reaching a marker;
 * in that case cinfo->unread_marker is unchanged.
 *
 * Note that the result might not be a valid marker code,
 * but it will never be 0 or FF.
 */

LOCAL(boolean)
next_marker (j_decompress_ptr cinfo)
{
  int c;
  INPUT_VARS(cinfo);

  for (;;) {
    INPUT_BYTE(cinfo, c, return FALSE);
    /* Skip any non-FF bytes.
     * This may look a bit inefficient, but it will not occur in a valid file.
     * We sync after each discarded byte so that a suspending data source
     * can discard the byte from its buffer.
     */
    while (c != 0xFF) {
      cinfo->marker->discarded_bytes++;
      INPUT_SYNC(cinfo);
      INPUT_BYTE(cinfo, c, return FALSE);
    }
    /* This loop swallows any duplicate FF bytes.  Extra FFs are legal as
     * pad bytes, so don't count them in discarded_bytes.  We assume there
     * will not be so many consecutive FF bytes as to overflow a suspending
     * data source's input buffer.
     */
    do {
      INPUT_BYTE(cinfo, c, return FALSE);
    } while (c == 0xFF);
    if (c != 0)
      break;			/* found a valid marker, exit loop */
    /* Reach here if we found a stuffed-zero data sequence (FF/00).
     * Discard it and loop back to try again.
     */
    cinfo->marker->discarded_bytes += 2;
    INPUT_SYNC(cinfo);
  }

  if (cinfo->marker->discarded_bytes != 0) {
    WARNMS2(cinfo, JWRN_EXTRANEOUS_DATA, cinfo->marker->discarded_bytes, c);
    cinfo->marker->discarded_bytes = 0;
  }

  cinfo->unread_marker = c;

  INPUT_SYNC(cinfo);
  return TRUE;
}


LOCAL(boolean)
first_marker (j_decompress_ptr cinfo)
/* Like next_marker, but used to obtain the initial SOI marker. */
/* For this marker, we do not allow preceding garbage or fill; otherwise,
 * we might well scan an entire input file before realizing it ain't JPEG.
 * If an application wants to process non-JFIF files, it must seek to the
 * SOI before calling the JPEG library.
 */
{
  int c, c2;
  INPUT_VARS(cinfo);

  INPUT_BYTE(cinfo, c, return FALSE);
  INPUT_BYTE(cinfo, c2, return FALSE);
  if (c != 0xFF || c2 != (int) M_SOI)
    ERREXIT2(cinfo, JERR_NO_SOI, c, c2);

  cinfo->unread_marker = c2;

  INPUT_SYNC(cinfo);
  return TRUE;
}


/*
 * Read markers until SOS or EOI.
 *
 * Returns same codes as are defined for jpeg_consume_input:
 * JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
 */

METHODDEF(int)
read_markers (j_decompress_ptr cinfo)
{
  /* Outer loop repeats once for each marker. */
  for (;;) {
    /* Collect the marker proper, unless we already did. */
    /* NB: first_marker() enforces the requirement that SOI appear first. */
    if (cinfo->unread_marker == 0) {
      if (! cinfo->marker->saw_SOI) {
	if (! first_marker(cinfo))
	  return JPEG_SUSPENDED;
      } else {
	if (! next_marker(cinfo))
	  return JPEG_SUSPENDED;
      }
    }
    /* At this point cinfo->unread_marker contains the marker code and the
     * input point is just past the marker proper, but before any parameters.
     * A suspension will cause us to return with this state still true.
     */
    switch (cinfo->unread_marker) {
    case M_SOI:
      if (! get_soi(cinfo))
	return JPEG_SUSPENDED;
      break;

    case M_SOF0:		/* Baseline */
    case M_SOF1:		/* Extended sequential, Huffman */
      if (! get_sof(cinfo, FALSE, FALSE))
	return JPEG_SUSPENDED;
      break;

    case M_SOF2:		/* Progressive, Huffman */
      if (! get_sof(cinfo, TRUE, FALSE))
	return JPEG_SUSPENDED;
      break;

    case M_SOF9:		/* Extended sequential, arithmetic */
      if (! get_sof(cinfo, FALSE, TRUE))
	return JPEG_SUSPENDED;
      break;

    case M_SOF10:		/* Progressive, arithmetic */
      if (! get_sof(cinfo, TRUE, TRUE))
	return JPEG_SUSPENDED;
      break;

    /* Currently unsupported SOFn types */
    case M_SOF3:		/* Lossless, Huffman */
    case M_SOF5:		/* Differential sequential, Huffman */
    case M_SOF6:		/* Differential progressive, Huffman */
    case M_SOF7:		/* Differential lossless, Huffman */
    case M_JPG:			/* Reserved for JPEG extensions */
    case M_SOF11:		/* Lossless, arithmetic */
    case M_SOF13:		/* Differential sequential, arithmetic */
    case M_SOF14:		/* Differential progressive, arithmetic */
    case M_SOF15:		/* Differential lossless, arithmetic */
      ERREXIT1(cinfo, JERR_SOF_UNSUPPORTED, cinfo->unread_marker);
      break;

    case M_SOS:
      if (! get_sos(cinfo))
	return JPEG_SUSPENDED;
      cinfo->unread_marker = 0;	/* processed the marker */
      return JPEG_REACHED_SOS;
    
    case M_EOI:
      TRACEMS(cinfo, 1, JTRC_EOI);
      cinfo->unread_marker = 0;	/* processed the marker */
      return JPEG_REACHED_EOI;
      
    case M_DAC:
      if (! get_dac(cinfo))
	return JPEG_SUSPENDED;
      break;
      
    case M_DHT:
      if (! get_dht(cinfo))
	return JPEG_SUSPENDED;
      break;
      
    case M_DQT:
      if (! get_dqt(cinfo))
	return JPEG_SUSPENDED;
      break;
      
    case M_DRI:
      if (! get_dri(cinfo))
	return JPEG_SUSPENDED;
      break;
      
    case M_APP0:
    case M_APP1:
    case M_APP2:
    case M_APP3:
    case M_APP4:
    case M_APP5:
    case M_APP6:
    case M_APP7:
    case M_APP8:
    case M_APP9:
    case M_APP10:
    case M_APP11:
    case M_APP12:
    case M_APP13:
    case M_APP14:
    case M_APP15:
      if (! (*cinfo->marker->process_APPn[cinfo->unread_marker - (int) M_APP0]) (cinfo))
	return JPEG_SUSPENDED;
      break;
      
    case M_COM:
      if (! (*cinfo->marker->process_COM) (cinfo))
	return JPEG_SUSPENDED;
      break;

    case M_RST0:		/* these are all parameterless */
    case M_RST1:
    case M_RST2:
    case M_RST3:
    case M_RST4:
    case M_RST5:
    case M_RST6:
    case M_RST7:
    case M_TEM:
      TRACEMS1(cinfo, 1, JTRC_PARMLESS_MARKER, cinfo->unread_marker);
      break;

    case M_DNL:			/* Ignore DNL ... perhaps the wrong thing */
      if (! skip_variable(cinfo))
	return JPEG_SUSPENDED;
      break;

    default:			/* must be DHP, EXP, JPGn, or RESn */
      /* For now, we treat the reserved markers as fatal errors since they are
       * likely to be used to signal incompatible JPEG Part 3 extensions.
       * Once the JPEG 3 version-number marker is well defined, this code
       * ought to change!
       */
      ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);
      break;
    }
    /* Successfully processed marker, so reset state variable */
    cinfo->unread_marker = 0;
  } /* end loop */
}


/*
 * Read a restart marker, which is expected to appear next in the datastream;
 * if the marker is not there, take appropriate recovery action.
 * Returns FALSE if suspension is required.
 *
 * This is called by the entropy decoder after it has read an appropriate
 * number of MCUs.  cinfo->unread_marker may be nonzero if the entropy decoder
 * has already read a marker from the data source.  Under normal conditions
 * cinfo->unread_marker will be reset to 0 before returning; if not reset,
 * it holds a marker which the decoder will be unable to read past.
 */

METHODDEF(boolean)
read_restart_marker (j_decompress_ptr cinfo)
{
  /* Obtain a marker unless we already did. */
  /* Note that next_marker will complain if it skips any data. */
  if (cinfo->unread_marker == 0) {
    if (! next_marker(cinfo))
      return FALSE;
  }

  if (cinfo->unread_marker ==
      ((int) M_RST0 + cinfo->marker->next_restart_num)) {
    /* Normal case --- swallow the marker and let entropy decoder continue */
    TRACEMS1(cinfo, 3, JTRC_RST, cinfo->marker->next_restart_num);
    cinfo->unread_marker = 0;
  } else {
    /* Uh-oh, the restart markers have been messed up. */
    /* Let the data source manager determine how to resync. */
    if (! (*cinfo->src->resync_to_restart) (cinfo,
					    cinfo->marker->next_restart_num))
      return FALSE;
  }

  /* Update next-restart state */
  cinfo->marker->next_restart_num = (cinfo->marker->next_restart_num + 1) & 7;

  return TRUE;
}


/*
 * This is the default resync_to_restart method for data source managers
 * to use if they don't have any better approach.  Some data source managers
 * may be able to back up, or may have additional knowledge about the data
 * which permits a more intelligent recovery strategy; such managers would
 * presumably supply their own resync method.
 *
 * read_restart_marker calls resync_to_restart if it finds a marker other than
 * the restart marker it was expecting.  (This code is *not* used unless
 * a nonzero restart interval has been declared.)  cinfo->unread_marker is
 * the marker code actually found (might be anything, except 0 or FF).
 * The desired restart marker number (0..7) is passed as a parameter.
 * This routine is supposed to apply whatever error recovery strategy seems
 * appropriate in order to position the input stream to the next data segment.
 * Note that cinfo->unread_marker is treated as a marker appearing before
 * the current data-source input point; usually it should be reset to zero
 * before returning.
 * Returns FALSE if suspension is required.
 *
 * This implementation is substantially constrained by wanting to treat the
 * input as a data stream; this means we can't back up.  Therefore, we have
 * only the following actions to work with:
 *   1. Simply discard the marker and let the entropy decoder resume at next
 *      byte of file.
 *   2. Read forward until we find another marker, discarding intervening
 *      data.  (In theory we could look ahead within the current bufferload,
 *      without having to discard data if we don't find the desired marker.
 *      This idea is not implemented here, in part because it makes behavior
 *      dependent on buffer size and chance buffer-boundary positions.)
 *   3. Leave the marker unread (by failing to zero cinfo->unread_marker).
 *      This will cause the entropy decoder to process an empty data segment,
 *      inserting dummy zeroes, and then we will reprocess the marker.
 *
 * #2 is appropriate if we think the desired marker lies ahead, while #3 is
 * appropriate if the found marker is a future restart marker (indicating
 * that we have missed the desired restart marker, probably because it got
 * corrupted).
 * We apply #2 or #3 if the found marker is a restart marker no more than
 * two counts behind or ahead of the expected one.  We also apply #2 if the
 * found marker is not a legal JPEG marker code (it's certainly bogus data).
 * If the found marker is a restart marker more than 2 counts away, we do #1
 * (too much risk that the marker is erroneous; with luck we will be able to
 * resync at some future point).
 * For any valid non-restart JPEG marker, we apply #3.  This keeps us from
 * overrunning the end of a scan.  An implementation limited to single-scan
 * files might find it better to apply #2 for markers other than EOI, since
 * any other marker would have to be bogus data in that case.
 */

GLOBAL(boolean)
jpeg_resync_to_restart (j_decompress_ptr cinfo, int desired)
{
  int marker = cinfo->unread_marker;
  int action = 1;
  
  /* Always put up a warning. */
  WARNMS2(cinfo, JWRN_MUST_RESYNC, marker, desired);
  
  /* Outer loop handles repeated decision after scanning forward. */
  for (;;) {
    if (marker < (int) M_SOF0)
      action = 2;		/* invalid marker */
    else if (marker < (int) M_RST0 || marker > (int) M_RST7)
      action = 3;		/* valid non-restart marker */
    else {
      if (marker == ((int) M_RST0 + ((desired+1) & 7)) ||
	  marker == ((int) M_RST0 + ((desired+2) & 7)))
	action = 3;		/* one of the next two expected restarts */
      else if (marker == ((int) M_RST0 + ((desired-1) & 7)) ||
	       marker == ((int) M_RST0 + ((desired-2) & 7)))
	action = 2;		/* a prior restart, so advance */
      else
	action = 1;		/* desired restart or too far away */
    }
    TRACEMS2(cinfo, 4, JTRC_RECOVERY_ACTION, marker, action);
    switch (action) {
    case 1:
      /* Discard marker and let entropy decoder resume processing. */
      cinfo->unread_marker = 0;
      return TRUE;
    case 2:
      /* Scan to the next marker, and repeat the decision loop. */
      if (! next_marker(cinfo))
	return FALSE;
      marker = cinfo->unread_marker;
      break;
    case 3:
      /* Return without advancing past this marker. */
      /* Entropy decoder will be forced to process an empty segment. */
      return TRUE;
    }
  } /* end loop */
}


/*
 * Reset marker processing state to begin a fresh datastream.
 */

METHODDEF(void)
reset_marker_reader (j_decompress_ptr cinfo)
{
  cinfo->comp_info = NULL;		/* until allocated by get_sof */
  cinfo->input_scan_number = 0;		/* no SOS seen yet */
  cinfo->unread_marker = 0;		/* no pending marker */
  cinfo->marker->saw_SOI = FALSE;	/* set internal state too */
  cinfo->marker->saw_SOF = FALSE;
  cinfo->marker->discarded_bytes = 0;
}


/*
 * Initialize the marker reader module.
 * This is called only once, when the decompression object is created.
 */

GLOBAL(void)
jinit_marker_reader (j_decompress_ptr cinfo)
{
  int i;

  /* Create subobject in permanent pool */
  cinfo->marker = (struct jpeg_marker_reader *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
				SIZEOF(struct jpeg_marker_reader));
  /* Initialize method pointers */
  cinfo->marker->reset_marker_reader = reset_marker_reader;
  cinfo->marker->read_markers = read_markers;
  cinfo->marker->read_restart_marker = read_restart_marker;
  cinfo->marker->process_COM = skip_variable;
  for (i = 0; i < 16; i++)
    cinfo->marker->process_APPn[i] = skip_variable;
  cinfo->marker->process_APPn[0] = get_app0;
  cinfo->marker->process_APPn[14] = get_app14;
  /* Reset marker processing state */
  reset_marker_reader(cinfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jdphuff.c ===
/*
 * jdphuff.c
 *
 * Copyright (C) 1995-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains Huffman entropy decoding routines for progressive JPEG.
 *
 * Much of the complexity here has to do with supporting input suspension.
 * If the data source module demands suspension, we want to be able to back
 * up to the start of the current MCU.  To do this, we copy state variables
 * into local working storage, and update them back to the permanent
 * storage only upon successful completion of an MCU.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"
#include "jdhuff.h"		/* Declarations shared with jdhuff.c */

//!! Warnings should be fixed up and the pragma removed
#pragma warning(disable : 4242) // conversion from int to unsigned short

#ifdef D_PROGRESSIVE_SUPPORTED

/*
 * Expanded entropy decoder object for progressive Huffman decoding.
 *
 * The savable_state subrecord contains fields that change within an MCU,
 * but must not be updated permanently until we complete the MCU.
 */

typedef struct {
  unsigned int EOBRUN;			/* remaining EOBs in EOBRUN */
  int last_dc_val[MAX_COMPS_IN_SCAN];	/* last DC coef for each component */
} savable_state;

/* This macro is to work around compilers with missing or broken
 * structure assignment.  You'll need to fix this code if you have
 * such a compiler and you change MAX_COMPS_IN_SCAN.
 */

#ifndef NO_STRUCT_ASSIGN
#define ASSIGN_STATE(dest,src)  ((dest) = (src))
#else
#if MAX_COMPS_IN_SCAN == 4
#define ASSIGN_STATE(dest,src)  \
	((dest).EOBRUN = (src).EOBRUN, \
	 (dest).last_dc_val[0] = (src).last_dc_val[0], \
	 (dest).last_dc_val[1] = (src).last_dc_val[1], \
	 (dest).last_dc_val[2] = (src).last_dc_val[2], \
	 (dest).last_dc_val[3] = (src).last_dc_val[3])
#endif
#endif


typedef struct {
  struct jpeg_entropy_decoder pub; /* public fields */

  /* These fields are loaded into local variables at start of each MCU.
   * In case of suspension, we exit WITHOUT updating them.
   */
  bitread_perm_state bitstate;	/* Bit buffer at start of MCU */
  savable_state saved;		/* Other state at start of MCU */

  /* These fields are NOT loaded into local working state. */
  unsigned int restarts_to_go;	/* MCUs left in this restart interval */

  /* Pointers to derived tables (these workspaces have image lifespan) */
  d_derived_tbl * derived_tbls[NUM_HUFF_TBLS];

  d_derived_tbl * ac_derived_tbl; /* active table during an AC scan */
} phuff_entropy_decoder;

typedef phuff_entropy_decoder * phuff_entropy_ptr;

/* Forward declarations */
METHODDEF(boolean) decode_mcu_DC_first JPP((j_decompress_ptr cinfo,
					    JBLOCKROW *MCU_data));
METHODDEF(boolean) decode_mcu_AC_first JPP((j_decompress_ptr cinfo,
					    JBLOCKROW *MCU_data));
METHODDEF(boolean) decode_mcu_DC_refine JPP((j_decompress_ptr cinfo,
					     JBLOCKROW *MCU_data));
METHODDEF(boolean) decode_mcu_AC_refine JPP((j_decompress_ptr cinfo,
					     JBLOCKROW *MCU_data));


/*
 * Initialize for a Huffman-compressed scan.
 */

METHODDEF(void)
start_pass_phuff_decoder (j_decompress_ptr cinfo)
{
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
  boolean is_DC_band, bad;
  int ci, coefi, tbl;
  int *coef_bit_ptr;
  jpeg_component_info * compptr;

  is_DC_band = (cinfo->Ss == 0);

  /* Validate scan parameters */
  bad = FALSE;
  if (is_DC_band) {
    if (cinfo->Se != 0)
      bad = TRUE;
  } else {
    /* need not check Ss/Se < 0 since they came from unsigned bytes */
    if (cinfo->Ss > cinfo->Se || cinfo->Se >= DCTSIZE2)
      bad = TRUE;
    /* AC scans may have only one component */
    if (cinfo->comps_in_scan != 1)
      bad = TRUE;
  }
  if (cinfo->Ah != 0) {
    /* Successive approximation refinement scan: must have Al = Ah-1. */
    if (cinfo->Al != cinfo->Ah-1)
      bad = TRUE;
  }
  if (cinfo->Al > 13)		/* need not check for < 0 */
    bad = TRUE;
  if (bad)
    ERREXIT4(cinfo, JERR_BAD_PROGRESSION,
	     cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);
  /* Update progression status, and verify that scan order is legal.
   * Note that inter-scan inconsistencies are treated as warnings
   * not fatal errors ... not clear if this is right way to behave.
   */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    int cindex = cinfo->cur_comp_info[ci]->component_index;
    coef_bit_ptr = & cinfo->coef_bits[cindex][0];
    if (!is_DC_band && coef_bit_ptr[0] < 0) /* AC without prior DC scan */
      WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);
    for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
      int expected = (coef_bit_ptr[coefi] < 0) ? 0 : coef_bit_ptr[coefi];
      if (cinfo->Ah != expected)
	WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, coefi);
      coef_bit_ptr[coefi] = cinfo->Al;
    }
  }

  /* Select MCU decoding routine */
  if (cinfo->Ah == 0) {
    if (is_DC_band)
      entropy->pub.decode_mcu = decode_mcu_DC_first;
    else
      entropy->pub.decode_mcu = decode_mcu_AC_first;
  } else {
    if (is_DC_band)
      entropy->pub.decode_mcu = decode_mcu_DC_refine;
    else
      entropy->pub.decode_mcu = decode_mcu_AC_refine;
  }

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
    /* Make sure requested tables are present, and compute derived tables.
     * We may build same derived table more than once, but it's not expensive.
     */
    if (is_DC_band) {
      if (cinfo->Ah == 0) {	/* DC refinement needs no table */
	tbl = compptr->dc_tbl_no;
	if (tbl < 0 || tbl >= NUM_HUFF_TBLS ||
	    cinfo->dc_huff_tbl_ptrs[tbl] == NULL)
	  ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tbl);
	jpeg_make_d_derived_tbl(cinfo, cinfo->dc_huff_tbl_ptrs[tbl],
				& entropy->derived_tbls[tbl]);
      }
    } else {
      tbl = compptr->ac_tbl_no;
      if (tbl < 0 || tbl >= NUM_HUFF_TBLS ||
          cinfo->ac_huff_tbl_ptrs[tbl] == NULL)
        ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tbl);
      jpeg_make_d_derived_tbl(cinfo, cinfo->ac_huff_tbl_ptrs[tbl],
			      & entropy->derived_tbls[tbl]);
      /* remember the single active table */
      entropy->ac_derived_tbl = entropy->derived_tbls[tbl];
    }
    /* Initialize DC predictions to 0 */
    entropy->saved.last_dc_val[ci] = 0;
  }

  /* Initialize bitread state variables */
  entropy->bitstate.bits_left = 0;
  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
  entropy->bitstate.printed_eod = FALSE;

  /* Initialize private state variables */
  entropy->saved.EOBRUN = 0;

  /* Initialize restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
}


/*
 * Figure F.12: extend sign bit.
 * On some machines, a shift and add will be faster than a table lookup.
 */

#ifdef AVOID_TABLES

#define HUFF_EXTEND(x,s)  ((x) < (1<<((s)-1)) ? (x) + (((-1)<<(s)) + 1) : (x))

#else

#define HUFF_EXTEND(x,s)  ((x) < extend_test[s] ? (x) + extend_offset[s] : (x))

static const int extend_test[16] =   /* entry n is 2**(n-1) */
  { 0, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
    0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000 };

static const int extend_offset[16] = /* entry n is (-1 << n) + 1 */
  { 0, ((-1)<<1) + 1, ((-1)<<2) + 1, ((-1)<<3) + 1, ((-1)<<4) + 1,
    ((-1)<<5) + 1, ((-1)<<6) + 1, ((-1)<<7) + 1, ((-1)<<8) + 1,
    ((-1)<<9) + 1, ((-1)<<10) + 1, ((-1)<<11) + 1, ((-1)<<12) + 1,
    ((-1)<<13) + 1, ((-1)<<14) + 1, ((-1)<<15) + 1 };

#endif /* AVOID_TABLES */


/*
 * Check for a restart marker & resynchronize decoder.
 * Returns FALSE if must suspend.
 */

LOCAL(boolean)
process_restart (j_decompress_ptr cinfo)
{
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
  int ci;

  /* Throw away any unused bits remaining in bit buffer; */
  /* include any full bytes in next_marker's count of discarded bytes */
  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
  entropy->bitstate.bits_left = 0;

  /* Advance past the RSTn marker */
  if (! (*cinfo->marker->read_restart_marker) (cinfo))
    return FALSE;

  /* Re-initialize DC predictions to 0 */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
    entropy->saved.last_dc_val[ci] = 0;
  /* Re-init EOB run count, too */
  entropy->saved.EOBRUN = 0;

  /* Reset restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;

  /* Next segment can get another out-of-data warning */
  entropy->bitstate.printed_eod = FALSE;

  return TRUE;
}


/*
 * Huffman MCU decoding.
 * Each of these routines decodes and returns one MCU's worth of
 * Huffman-compressed coefficients. 
 * The coefficients are reordered from zigzag order into natural array order,
 * but are not dequantized.
 *
 * The i'th block of the MCU is stored into the block pointed to by
 * MCU_data[i].  WE ASSUME THIS AREA IS INITIALLY ZEROED BY THE CALLER.
 *
 * We return FALSE if data source requested suspension.  In that case no
 * changes have been made to permanent state.  (Exception: some output
 * coefficients may already have been assigned.  This is harmless for
 * spectral selection, since we'll just re-assign them on the next call.
 * Successive approximation AC refinement has to be more careful, however.)
 */

/*
 * MCU decoding for DC initial scan (either spectral selection,
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
  int Al = cinfo->Al;
  register int s, r;
  int blkn, ci;
  JBLOCKROW block;
  BITREAD_STATE_VARS;
  savable_state state;
  d_derived_tbl * tbl;
  jpeg_component_info * compptr;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0)
      if (! process_restart(cinfo))
	return FALSE;
  }

  /* Load up working state */
  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
  ASSIGN_STATE(state, entropy->saved);

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
    block = MCU_data[blkn];
    ci = cinfo->MCU_membership[blkn];
    compptr = cinfo->cur_comp_info[ci];
    tbl = entropy->derived_tbls[compptr->dc_tbl_no];

    /* Decode a single block's worth of coefficients */

    /* Section F.2.2.1: decode the DC coefficient difference */
    HUFF_DECODE(s, br_state, tbl, return FALSE, label1);
    if (s) {
      CHECK_BIT_BUFFER(br_state, s, return FALSE);
      r = GET_BITS(s);
      s = HUFF_EXTEND(r, s);
    }

    /* Convert DC difference to actual value, update last_dc_val */
    s += state.last_dc_val[ci];
    state.last_dc_val[ci] = s;
    /* Scale and output the DC coefficient (assumes jpeg_natural_order[0]=0) */
    (*block)[0] = (JCOEF) (s << Al);
  }

  /* Completed MCU, so update state */
  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
  ASSIGN_STATE(entropy->saved, state);

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;

  return TRUE;
}


/*
 * MCU decoding for AC initial scan (either spectral selection,
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
  int Se = cinfo->Se;
  int Al = cinfo->Al;
  register int s, k, r;
  unsigned int EOBRUN;
  JBLOCKROW block;
  BITREAD_STATE_VARS;
  d_derived_tbl * tbl;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0)
      if (! process_restart(cinfo))
	return FALSE;
  }

  /* Load up working state.
   * We can avoid loading/saving bitread state if in an EOB run.
   */
  EOBRUN = entropy->saved.EOBRUN; /* only part of saved state we care about */

  /* There is always only one block per MCU */

  if (EOBRUN > 0)		/* if it's a band of zeroes... */
    EOBRUN--;			/* ...process it now (we do nothing) */
  else {
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
    block = MCU_data[0];
    tbl = entropy->ac_derived_tbl;

    for (k = cinfo->Ss; k <= Se; k++) {
      HUFF_DECODE(s, br_state, tbl, return FALSE, label2);
      r = s >> 4;
      s &= 15;
      if (s) {
        k += r;
        CHECK_BIT_BUFFER(br_state, s, return FALSE);
        r = GET_BITS(s);
        s = HUFF_EXTEND(r, s);
	/* Scale and output coefficient in natural (dezigzagged) order */
        (*block)[jpeg_natural_order[k]] = (JCOEF) (s << Al);
      } else {
        if (r == 15) {		/* ZRL */
          k += 15;		/* skip 15 zeroes in band */
        } else {		/* EOBr, run length is 2^r + appended bits */
          EOBRUN = 1 << r;
          if (r) {		/* EOBr, r > 0 */
	    CHECK_BIT_BUFFER(br_state, r, return FALSE);
            r = GET_BITS(r);
            EOBRUN += r;
          }
	  EOBRUN--;		/* this band is processed at this moment */
	  break;		/* force end-of-band */
	}
      }
    }

    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
  }

  /* Completed MCU, so update state */
  entropy->saved.EOBRUN = EOBRUN; /* only part of saved state we care about */

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;

  return TRUE;
}


/*
 * MCU decoding for DC successive approximation refinement scan.
 * Note: we assume such scans can be multi-component, although the spec
 * is not very clear on the point.
 */

METHODDEF(boolean)
decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
  int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
  int blkn;
  JBLOCKROW block;
  BITREAD_STATE_VARS;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0)
      if (! process_restart(cinfo))
	return FALSE;
  }

  /* Load up working state */
  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
    block = MCU_data[blkn];

    /* Encoded data is simply the next bit of the two's-complement DC value */
    CHECK_BIT_BUFFER(br_state, 1, return FALSE);
    if (GET_BITS(1))
      (*block)[0] |= p1;
    /* Note: since we use |=, repeating the assignment later is safe */
  }

  /* Completed MCU, so update state */
  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;

  return TRUE;
}


/*
 * MCU decoding for AC successive approximation refinement scan.
 */

METHODDEF(boolean)
decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
  int Se = cinfo->Se;
  int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
  int m1 = (-1) << cinfo->Al;	/* -1 in the bit position being coded */
  register int s, k, r;
  unsigned int EOBRUN;
  JBLOCKROW block;
  JCOEFPTR thiscoef;
  BITREAD_STATE_VARS;
  d_derived_tbl * tbl;
  int num_newnz;
  int newnz_pos[DCTSIZE2];

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0)
      if (! process_restart(cinfo))
	return FALSE;
  }

  /* Load up working state */
  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
  EOBRUN = entropy->saved.EOBRUN; /* only part of saved state we care about */

  /* There is always only one block per MCU */
  block = MCU_data[0];
  tbl = entropy->ac_derived_tbl;

  /* If we are forced to suspend, we must undo the assignments to any newly
   * nonzero coefficients in the block, because otherwise we'd get confused
   * next time about which coefficients were already nonzero.
   * But we need not undo addition of bits to already-nonzero coefficients;
   * instead, we can test the current bit position to see if we already did it.
   */
  num_newnz = 0;

  /* initialize coefficient loop counter to start of band */
  k = cinfo->Ss;

  if (EOBRUN == 0) {
    for (; k <= Se; k++) {
      HUFF_DECODE(s, br_state, tbl, goto undoit, label3);
      r = s >> 4;
      s &= 15;
      if (s) {
	if (s != 1)		/* size of new coef should always be 1 */
	  WARNMS(cinfo, JWRN_HUFF_BAD_CODE);
        CHECK_BIT_BUFFER(br_state, 1, goto undoit);
        if (GET_BITS(1))
	  s = p1;		/* newly nonzero coef is positive */
	else
	  s = m1;		/* newly nonzero coef is negative */
      } else {
	if (r != 15) {
	  EOBRUN = 1 << r;	/* EOBr, run length is 2^r + appended bits */
	  if (r) {
	    CHECK_BIT_BUFFER(br_state, r, goto undoit);
	    r = GET_BITS(r);
	    EOBRUN += r;
	  }
	  break;		/* rest of block is handled by EOB logic */
	}
	/* note s = 0 for processing ZRL */
      }
      /* Advance over already-nonzero coefs and r still-zero coefs,
       * appending correction bits to the nonzeroes.  A correction bit is 1
       * if the absolute value of the coefficient must be increased.
       */
      do {
	thiscoef = *block + jpeg_natural_order[k];
	if (*thiscoef != 0) {
	  CHECK_BIT_BUFFER(br_state, 1, goto undoit);
	  if (GET_BITS(1)) {
	    if ((*thiscoef & p1) == 0) { /* do nothing if already changed it */
	      if (*thiscoef >= 0)
		*thiscoef += p1;
	      else
		*thiscoef += m1;
	    }
	  }
	} else {
	  if (--r < 0)
	    break;		/* reached target zero coefficient */
	}
	k++;
      } while (k <= Se);
      if (s) {
	int pos = jpeg_natural_order[k];
	/* Output newly nonzero coefficient */
	(*block)[pos] = (JCOEF) s;
	/* Remember its position in case we have to suspend */
	newnz_pos[num_newnz++] = pos;
      }
    }
  }

  if (EOBRUN > 0) {
    /* Scan any remaining coefficient positions after the end-of-band
     * (the last newly nonzero coefficient, if any).  Append a correction
     * bit to each already-nonzero coefficient.  A correction bit is 1
     * if the absolute value of the coefficient must be increased.
     */
    for (; k <= Se; k++) {
      thiscoef = *block + jpeg_natural_order[k];
      if (*thiscoef != 0) {
	CHECK_BIT_BUFFER(br_state, 1, goto undoit);
	if (GET_BITS(1)) {
	  if ((*thiscoef & p1) == 0) { /* do nothing if already changed it */
	    if (*thiscoef >= 0)
	      *thiscoef += p1;
	    else
	      *thiscoef += m1;
	  }
	}
      }
    }
    /* Count one block completed in EOB run */
    EOBRUN--;
  }

  /* Completed MCU, so update state */
  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
  entropy->saved.EOBRUN = EOBRUN; /* only part of saved state we care about */

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;

  return TRUE;

undoit:
  /* Re-zero any output coefficients that we made newly nonzero */
  while (num_newnz > 0)
    (*block)[newnz_pos[--num_newnz]] = 0;

  return FALSE;
}


/*
 * Module initialization routine for progressive Huffman entropy decoding.
 */

GLOBAL(void)
jinit_phuff_decoder (j_decompress_ptr cinfo)
{
  phuff_entropy_ptr entropy;
  int *coef_bit_ptr;
  int ci, i;

  entropy = (phuff_entropy_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(phuff_entropy_decoder));
  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
  entropy->pub.start_pass = start_pass_phuff_decoder;

  /* Mark derived tables unallocated */
  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    entropy->derived_tbls[i] = NULL;
  }

  /* Create progression status table */
  cinfo->coef_bits = (int (*)[DCTSIZE2])
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				cinfo->num_components*DCTSIZE2*SIZEOF(int));
  coef_bit_ptr = & cinfo->coef_bits[0][0];
  for (ci = 0; ci < cinfo->num_components; ci++) 
    for (i = 0; i < DCTSIZE2; i++)
      *coef_bit_ptr++ = -1;
}

#endif /* D_PROGRESSIVE_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jdpostct.c ===
/*
 * jdpostct.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains the decompression postprocessing controller.
 * This controller manages the upsampling, color conversion, and color
 * quantization/reduction steps; specifically, it controls the buffering
 * between upsample/color conversion and color quantization/reduction.
 *
 * If no color quantization/reduction is required, then this module has no
 * work to do, and it just hands off to the upsample/color conversion code.
 * An integrated upsample/convert/quantize process would replace this module
 * entirely.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/* Private buffer controller object */

typedef struct {
  struct jpeg_d_post_controller pub; /* public fields */

  /* Color quantization source buffer: this holds output data from
   * the upsample/color conversion step to be passed to the quantizer.
   * For two-pass color quantization, we need a full-image buffer;
   * for one-pass operation, a strip buffer is sufficient.
   */
  jvirt_sarray_ptr whole_image;	/* virtual array, or NULL if one-pass */
  JSAMPARRAY buffer;		/* strip buffer, or current strip of virtual */
  JDIMENSION strip_height;	/* buffer size in rows */
  /* for two-pass mode only: */
  JDIMENSION starting_row;	/* row # of first row in current strip */
  JDIMENSION next_row;		/* index of next row to fill/empty in strip */
} my_post_controller;

typedef my_post_controller * my_post_ptr;


/* Forward declarations */
METHODDEF(void) post_process_1pass
	JPP((j_decompress_ptr cinfo,
	     JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
	     JDIMENSION in_row_groups_avail,
	     JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
	     JDIMENSION out_rows_avail));
#ifdef QUANT_2PASS_SUPPORTED
METHODDEF(void) post_process_prepass
	JPP((j_decompress_ptr cinfo,
	     JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
	     JDIMENSION in_row_groups_avail,
	     JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
	     JDIMENSION out_rows_avail));
METHODDEF(void) post_process_2pass
	JPP((j_decompress_ptr cinfo,
	     JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
	     JDIMENSION in_row_groups_avail,
	     JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
	     JDIMENSION out_rows_avail));
#endif


/*
 * Initialize for a processing pass.
 */

METHODDEF(void)
start_pass_dpost (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
{
  my_post_ptr post = (my_post_ptr) cinfo->post;

  switch (pass_mode) {
  case JBUF_PASS_THRU:
    if (cinfo->quantize_colors) {
      /* Single-pass processing with color quantization. */
      post->pub.post_process_data = post_process_1pass;
      /* We could be doing buffered-image output before starting a 2-pass
       * color quantization; in that case, jinit_d_post_controller did not
       * allocate a strip buffer.  Use the virtual-array buffer as workspace.
       */
      if (post->buffer == NULL) {
	post->buffer = (*cinfo->mem->access_virt_sarray)
	  ((j_common_ptr) cinfo, post->whole_image,
	   (JDIMENSION) 0, post->strip_height, TRUE);
      }
    } else {
      /* For single-pass processing without color quantization,
       * I have no work to do; just call the upsampler directly.
       */
      post->pub.post_process_data = cinfo->upsample->upsample;
    }
    break;
#ifdef QUANT_2PASS_SUPPORTED
  case JBUF_SAVE_AND_PASS:
    /* First pass of 2-pass quantization */
    if (post->whole_image == NULL)
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    post->pub.post_process_data = post_process_prepass;
    break;
  case JBUF_CRANK_DEST:
    /* Second pass of 2-pass quantization */
    if (post->whole_image == NULL)
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    post->pub.post_process_data = post_process_2pass;
    break;
#endif /* QUANT_2PASS_SUPPORTED */
  default:
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    break;
  }
  post->starting_row = post->next_row = 0;
}


/*
 * Process some data in the one-pass (strip buffer) case.
 * This is used for color precision reduction as well as one-pass quantization.
 */

METHODDEF(void)
post_process_1pass (j_decompress_ptr cinfo,
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
{
  my_post_ptr post = (my_post_ptr) cinfo->post;
  JDIMENSION num_rows, max_rows;

  /* Fill the buffer, but not more than what we can dump out in one go. */
  /* Note we rely on the upsampler to detect bottom of image. */
  max_rows = out_rows_avail - *out_row_ctr;
  if (max_rows > post->strip_height)
    max_rows = post->strip_height;
  num_rows = 0;
  (*cinfo->upsample->upsample) (cinfo,
		input_buf, in_row_group_ctr, in_row_groups_avail,
		post->buffer, &num_rows, max_rows);
  /* Quantize and emit data. */
  (*cinfo->cquantize->color_quantize) (cinfo,
		post->buffer, output_buf + *out_row_ctr, (int) num_rows);
  *out_row_ctr += num_rows;
}


#ifdef QUANT_2PASS_SUPPORTED

/*
 * Process some data in the first pass of 2-pass quantization.
 */

METHODDEF(void)
post_process_prepass (j_decompress_ptr cinfo,
		      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		      JDIMENSION in_row_groups_avail,
		      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		      JDIMENSION out_rows_avail)
{
  my_post_ptr post = (my_post_ptr) cinfo->post;
  JDIMENSION old_next_row, num_rows;

  /* Reposition virtual buffer if at start of strip. */
  if (post->next_row == 0) {
    post->buffer = (*cinfo->mem->access_virt_sarray)
	((j_common_ptr) cinfo, post->whole_image,
	 post->starting_row, post->strip_height, TRUE);
  }

  /* Upsample some data (up to a strip height's worth). */
  old_next_row = post->next_row;
  (*cinfo->upsample->upsample) (cinfo,
		input_buf, in_row_group_ctr, in_row_groups_avail,
		post->buffer, &post->next_row, post->strip_height);

  /* Allow quantizer to scan new data.  No data is emitted, */
  /* but we advance out_row_ctr so outer loop can tell when we're done. */
  if (post->next_row > old_next_row) {
    num_rows = post->next_row - old_next_row;
    (*cinfo->cquantize->color_quantize) (cinfo, post->buffer + old_next_row,
					 (JSAMPARRAY) NULL, (int) num_rows);
    *out_row_ctr += num_rows;
  }

  /* Advance if we filled the strip. */
  if (post->next_row >= post->strip_height) {
    post->starting_row += post->strip_height;
    post->next_row = 0;
  }
}


/*
 * Process some data in the second pass of 2-pass quantization.
 */

METHODDEF(void)
post_process_2pass (j_decompress_ptr cinfo,
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
{
  my_post_ptr post = (my_post_ptr) cinfo->post;
  JDIMENSION num_rows, max_rows;

  /* Reposition virtual buffer if at start of strip. */
  if (post->next_row == 0) {
    post->buffer = (*cinfo->mem->access_virt_sarray)
	((j_common_ptr) cinfo, post->whole_image,
	 post->starting_row, post->strip_height, FALSE);
  }

  /* Determine number of rows to emit. */
  num_rows = post->strip_height - post->next_row; /* available in strip */
  max_rows = out_rows_avail - *out_row_ctr; /* available in output area */
  if (num_rows > max_rows)
    num_rows = max_rows;
  /* We have to check bottom of image here, can't depend on upsampler. */
  max_rows = cinfo->output_height - post->starting_row;
  if (num_rows > max_rows)
    num_rows = max_rows;

  /* Quantize and emit data. */
  (*cinfo->cquantize->color_quantize) (cinfo,
		post->buffer + post->next_row, output_buf + *out_row_ctr,
		(int) num_rows);
  *out_row_ctr += num_rows;

  /* Advance if we filled the strip. */
  post->next_row += num_rows;
  if (post->next_row >= post->strip_height) {
    post->starting_row += post->strip_height;
    post->next_row = 0;
  }
}

#endif /* QUANT_2PASS_SUPPORTED */


/*
 * Initialize postprocessing controller.
 */

GLOBAL(void)
jinit_d_post_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
{
  my_post_ptr post;

  post = (my_post_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_post_controller));
  cinfo->post = (struct jpeg_d_post_controller *) post;
  post->pub.start_pass = start_pass_dpost;
  post->whole_image = NULL;	/* flag for no virtual arrays */
  post->buffer = NULL;		/* flag for no strip buffer */

  /* Create the quantization buffer, if needed */
  if (cinfo->quantize_colors) {
    /* The buffer strip height is max_v_samp_factor, which is typically
     * an efficient number of rows for upsampling to return.
     * (In the presence of output rescaling, we might want to be smarter?)
     */
    post->strip_height = (JDIMENSION) cinfo->max_v_samp_factor;
    if (need_full_buffer) {
      /* Two-pass color quantization: need full-image storage. */
      /* We round up the number of rows to a multiple of the strip height. */
#ifdef QUANT_2PASS_SUPPORTED
      post->whole_image = (*cinfo->mem->request_virt_sarray)
	((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
	 cinfo->output_width * cinfo->out_color_components,
	 (JDIMENSION) jround_up((long) cinfo->output_height,
				(long) post->strip_height),
	 post->strip_height);
#else
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
#endif /* QUANT_2PASS_SUPPORTED */
    } else {
      /* One-pass color quantization: just make a strip buffer. */
      post->buffer = (*cinfo->mem->alloc_sarray)
	((j_common_ptr) cinfo, JPOOL_IMAGE,
	 cinfo->output_width * cinfo->out_color_components,
	 post->strip_height);
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jdmerge.c ===
/*
 * jdmerge.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains code for merged upsampling/color conversion.
 *
 * This file combines functions from jdsample.c and jdcolor.c;
 * read those files first to understand what's going on.
 *
 * When the chroma components are to be upsampled by simple replication
 * (ie, box filtering), we can save some work in color conversion by
 * calculating all the output pixels corresponding to a pair of chroma
 * samples at one time.  In the conversion equations
 *	R = Y           + K1 * Cr
 *	G = Y + K2 * Cb + K3 * Cr
 *	B = Y + K4 * Cb
 * only the Y term varies among the group of pixels corresponding to a pair
 * of chroma samples, so the rest of the terms can be calculated just once.
 * At typical sampling ratios, this eliminates half or three-quarters of the
 * multiplications needed for color conversion.
 *
 * This file currently provides implementations for the following cases:
 *	YCbCr => RGB color conversion only.
 *	Sampling ratios of 2h1v or 2h2v.
 *	No scaling needed at upsample time.
 *	Corner-aligned (non-CCIR601) sampling alignment.
 * Other special cases could be added, but in most applications these are
 * the only common cases.  (For uncommon cases we fall back on the more
 * general code in jdsample.c and jdcolor.c.)
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"

#ifdef UPSAMPLE_MERGING_SUPPORTED


/* Private subobject */

typedef struct {
  struct jpeg_upsampler pub;	/* public fields */

  /* Pointer to routine to do actual upsampling/conversion of one row group */
  JMETHOD(void, upmethod, (j_decompress_ptr cinfo,
			   JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
			   JSAMPARRAY output_buf));

  /* Private state for YCC->RGB conversion */
  int * Cr_r_tab;		/* => table for Cr to R conversion */
  int * Cb_b_tab;		/* => table for Cb to B conversion */
  INT32 * Cr_g_tab;		/* => table for Cr to G conversion */
  INT32 * Cb_g_tab;		/* => table for Cb to G conversion */

  /* For 2:1 vertical sampling, we produce two output rows at a time.
   * We need a "spare" row buffer to hold the second output row if the
   * application provides just a one-row buffer; we also use the spare
   * to discard the dummy last row if the image height is odd.
   */
  JSAMPROW spare_row;
  boolean spare_full;		/* T if spare buffer is occupied */

  JDIMENSION out_row_width;	/* samples per output row */
  JDIMENSION rows_to_go;	/* counts rows remaining in image */
} my_upsampler;

typedef my_upsampler * my_upsample_ptr;

#define SCALEBITS	16	/* speediest right-shift on some machines */
#define ONE_HALF	((INT32) 1 << (SCALEBITS-1))
#define FIX(x)		((INT32) ((x) * (1L<<SCALEBITS) + 0.5))


/*
 * Initialize tables for YCC->RGB colorspace conversion.
 * This is taken directly from jdcolor.c; see that file for more info.
 */

LOCAL(void)
build_ycc_rgb_table (j_decompress_ptr cinfo)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
  int i;
  INT32 x;
  SHIFT_TEMPS

  upsample->Cr_r_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(int));
  upsample->Cb_b_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(int));
  upsample->Cr_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(INT32));
  upsample->Cb_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(INT32));

  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
    /* Cr=>R value is nearest int to 1.40200 * x */
    upsample->Cr_r_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
    /* Cb=>B value is nearest int to 1.77200 * x */
    upsample->Cb_b_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
    /* Cr=>G value is scaled-up -0.71414 * x */
    upsample->Cr_g_tab[i] = (- FIX(0.71414)) * x;
    /* Cb=>G value is scaled-up -0.34414 * x */
    /* We also add in ONE_HALF so that need not do it in inner loop */
    upsample->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
  }
}


/*
 * Initialize for an upsampling pass.
 */

METHODDEF(void)
start_pass_merged_upsample (j_decompress_ptr cinfo)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;

  /* Mark the spare buffer empty */
  upsample->spare_full = FALSE;
  /* Initialize total-height counter for detecting bottom of image */
  upsample->rows_to_go = cinfo->output_height;
}


/*
 * Control routine to do upsampling (and color conversion).
 *
 * The control routine just handles the row buffering considerations.
 */

METHODDEF(void)
merged_2v_upsample (j_decompress_ptr cinfo,
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
/* 2:1 vertical sampling case: may need a spare row. */
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
  JSAMPROW work_ptrs[2];
  JDIMENSION num_rows;		/* number of rows returned to caller */

  if (upsample->spare_full) {
    /* If we have a spare row saved from a previous cycle, just return it. */
    jcopy_sample_rows(& upsample->spare_row, 0, output_buf + *out_row_ctr, 0,
		      1, upsample->out_row_width);
    num_rows = 1;
    upsample->spare_full = FALSE;
  } else {
    /* Figure number of rows to return to caller. */
    num_rows = 2;
    /* Not more than the distance to the end of the image. */
    if (num_rows > upsample->rows_to_go)
      num_rows = upsample->rows_to_go;
    /* And not more than what the client can accept: */
    out_rows_avail -= *out_row_ctr;
    if (num_rows > out_rows_avail)
      num_rows = out_rows_avail;
    /* Create output pointer array for upsampler. */
    work_ptrs[0] = output_buf[*out_row_ctr];
    if (num_rows > 1) {
      work_ptrs[1] = output_buf[*out_row_ctr + 1];
    } else {
      work_ptrs[1] = upsample->spare_row;
      upsample->spare_full = TRUE;
    }
    /* Now do the upsampling. */
    (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);
  }

  /* Adjust counts */
  *out_row_ctr += num_rows;
  upsample->rows_to_go -= num_rows;
  /* When the buffer is emptied, declare this input row group consumed */
  if (! upsample->spare_full)
    (*in_row_group_ctr)++;
}


METHODDEF(void)
merged_1v_upsample (j_decompress_ptr cinfo,
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
/* 1:1 vertical sampling case: much easier, never need a spare row. */
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;

  /* Just do the upsampling. */
  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,
			 output_buf + *out_row_ctr);
  /* Adjust counts */
  (*out_row_ctr)++;
  (*in_row_group_ctr)++;
}


/*
 * These are the routines invoked by the control routines to do
 * the actual upsampling/conversion.  One row group is processed per call.
 *
 * Note: since we may be writing directly into application-supplied buffers,
 * we have to be honest about the output width; we can't assume the buffer
 * has been rounded up to an even width.
 */


/*
 * Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.
 */

METHODDEF(void)
h2v1_merged_upsample (j_decompress_ptr cinfo,
		      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
		      JSAMPARRAY output_buf)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
  register int y, cred, cgreen, cblue;
  int cb, cr;
  register JSAMPROW outptr;
  JSAMPROW inptr0, inptr1, inptr2;
  JDIMENSION col;
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
  int * Crrtab = upsample->Cr_r_tab;
  int * Cbbtab = upsample->Cb_b_tab;
  INT32 * Crgtab = upsample->Cr_g_tab;
  INT32 * Cbgtab = upsample->Cb_g_tab;
  SHIFT_TEMPS

  inptr0 = input_buf[0][in_row_group_ctr];
  inptr1 = input_buf[1][in_row_group_ctr];
  inptr2 = input_buf[2][in_row_group_ctr];
  outptr = output_buf[0];
  /* Loop for each pair of output pixels */
  for (col = cinfo->output_width >> 1; col > 0; col--) {
    /* Do the chroma part of the calculation */
    cb = GETJSAMPLE(*inptr1++);
    cr = GETJSAMPLE(*inptr2++);
    cred = Crrtab[cr];
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
    cblue = Cbbtab[cb];
    /* Fetch 2 Y values and emit 2 pixels */
    y  = GETJSAMPLE(*inptr0++);
    outptr[RGB_RED] =   range_limit[y + cred];
    outptr[RGB_GREEN] = range_limit[y + cgreen];
    outptr[RGB_BLUE] =  range_limit[y + cblue];
    outptr += RGB_PIXELSIZE;
    y  = GETJSAMPLE(*inptr0++);
    outptr[RGB_RED] =   range_limit[y + cred];
    outptr[RGB_GREEN] = range_limit[y + cgreen];
    outptr[RGB_BLUE] =  range_limit[y + cblue];
    outptr += RGB_PIXELSIZE;
  }
  /* If image width is odd, do the last output column separately */
  if (cinfo->output_width & 1) {
    cb = GETJSAMPLE(*inptr1);
    cr = GETJSAMPLE(*inptr2);
    cred = Crrtab[cr];
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
    cblue = Cbbtab[cb];
    y  = GETJSAMPLE(*inptr0);
    outptr[RGB_RED] =   range_limit[y + cred];
    outptr[RGB_GREEN] = range_limit[y + cgreen];
    outptr[RGB_BLUE] =  range_limit[y + cblue];
  }
}


/*
 * Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.
 */

METHODDEF(void)
h2v2_merged_upsample (j_decompress_ptr cinfo,
		      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
		      JSAMPARRAY output_buf)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
  register int y, cred, cgreen, cblue;
  int cb, cr;
  register JSAMPROW outptr0, outptr1;
  JSAMPROW inptr00, inptr01, inptr1, inptr2;
  JDIMENSION col;
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
  int * Crrtab = upsample->Cr_r_tab;
  int * Cbbtab = upsample->Cb_b_tab;
  INT32 * Crgtab = upsample->Cr_g_tab;
  INT32 * Cbgtab = upsample->Cb_g_tab;
  SHIFT_TEMPS

  inptr00 = input_buf[0][in_row_group_ctr*2];
  inptr01 = input_buf[0][in_row_group_ctr*2 + 1];
  inptr1 = input_buf[1][in_row_group_ctr];
  inptr2 = input_buf[2][in_row_group_ctr];
  outptr0 = output_buf[0];
  outptr1 = output_buf[1];
  /* Loop for each group of output pixels */
  for (col = cinfo->output_width >> 1; col > 0; col--) {
    /* Do the chroma part of the calculation */
    cb = GETJSAMPLE(*inptr1++);
    cr = GETJSAMPLE(*inptr2++);
    cred = Crrtab[cr];
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
    cblue = Cbbtab[cb];
    /* Fetch 4 Y values and emit 4 pixels */
    y  = GETJSAMPLE(*inptr00++);
    outptr0[RGB_RED] =   range_limit[y + cred];
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
    outptr0 += RGB_PIXELSIZE;
    y  = GETJSAMPLE(*inptr00++);
    outptr0[RGB_RED] =   range_limit[y + cred];
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
    outptr0 += RGB_PIXELSIZE;
    y  = GETJSAMPLE(*inptr01++);
    outptr1[RGB_RED] =   range_limit[y + cred];
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
    outptr1 += RGB_PIXELSIZE;
    y  = GETJSAMPLE(*inptr01++);
    outptr1[RGB_RED] =   range_limit[y + cred];
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
    outptr1 += RGB_PIXELSIZE;
  }
  /* If image width is odd, do the last output column separately */
  if (cinfo->output_width & 1) {
    cb = GETJSAMPLE(*inptr1);
    cr = GETJSAMPLE(*inptr2);
    cred = Crrtab[cr];
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
    cblue = Cbbtab[cb];
    y  = GETJSAMPLE(*inptr00);
    outptr0[RGB_RED] =   range_limit[y + cred];
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
    y  = GETJSAMPLE(*inptr01);
    outptr1[RGB_RED] =   range_limit[y + cred];
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
  }
}


/*
 * Module initialization routine for merged upsampling/color conversion.
 *
 * NB: this is called under the conditions determined by use_merged_upsample()
 * in jdmaster.c.  That routine MUST correspond to the actual capabilities
 * of this module; no safety checks are made here.
 */

GLOBAL(void)
jinit_merged_upsampler (j_decompress_ptr cinfo)
{
  my_upsample_ptr upsample;

  upsample = (my_upsample_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_upsampler));
  cinfo->upsample = (struct jpeg_upsampler *) upsample;
  upsample->pub.start_pass = start_pass_merged_upsample;
  upsample->pub.need_context_rows = FALSE;

  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;

  if (cinfo->max_v_samp_factor == 2) {
    upsample->pub.upsample = merged_2v_upsample;
    upsample->upmethod = h2v2_merged_upsample;
    /* Allocate a spare row buffer */
    upsample->spare_row = (JSAMPROW)
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
		(size_t) (upsample->out_row_width * SIZEOF(JSAMPLE)));
  } else {
    upsample->pub.upsample = merged_1v_upsample;
    upsample->upmethod = h2v1_merged_upsample;
    /* No spare row needed */
    upsample->spare_row = NULL;
  }

  build_ycc_rgb_table(cinfo);
}

#endif /* UPSAMPLE_MERGING_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jdsample.c ===
/*
 * jdsample.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains upsampling routines.
 *
 * Upsampling input data is counted in "row groups".  A row group
 * is defined to be (v_samp_factor * DCT_scaled_size / min_DCT_scaled_size)
 * sample rows of each component.  Upsampling will normally produce
 * max_v_samp_factor pixel rows from each row group (but this could vary
 * if the upsampler is applying a scale factor of its own).
 *
 * An excellent reference for image resampling is
 *   Digital Image Warping, George Wolberg, 1990.
 *   Pub. by IEEE Computer Society Press, Los Alamitos, CA. ISBN 0-8186-8944-7.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/* Pointer to routine to upsample a single component */
typedef JMETHOD(void, upsample1_ptr,
		(j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr));

/* Private subobject */

typedef struct {
  struct jpeg_upsampler pub;	/* public fields */

  /* Color conversion buffer.  When using separate upsampling and color
   * conversion steps, this buffer holds one upsampled row group until it
   * has been color converted and output.
   * Note: we do not allocate any storage for component(s) which are full-size,
   * ie do not need rescaling.  The corresponding entry of color_buf[] is
   * simply set to point to the input data array, thereby avoiding copying.
   */
  JSAMPARRAY color_buf[MAX_COMPONENTS];

  /* Per-component upsampling method pointers */
  upsample1_ptr methods[MAX_COMPONENTS];

  int next_row_out;		/* counts rows emitted from color_buf */
  JDIMENSION rows_to_go;	/* counts rows remaining in image */

  /* Height of an input row group for each component. */
  int rowgroup_height[MAX_COMPONENTS];

  /* These arrays save pixel expansion factors so that int_expand need not
   * recompute them each time.  They are unused for other upsampling methods.
   */
  UINT8 h_expand[MAX_COMPONENTS];
  UINT8 v_expand[MAX_COMPONENTS];
} my_upsampler;

typedef my_upsampler * my_upsample_ptr;


/*
 * Initialize for an upsampling pass.
 */

METHODDEF(void)
start_pass_upsample (j_decompress_ptr cinfo)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;

  /* Mark the conversion buffer empty */
  upsample->next_row_out = cinfo->max_v_samp_factor;
  /* Initialize total-height counter for detecting bottom of image */
  upsample->rows_to_go = cinfo->output_height;
}


/*
 * Control routine to do upsampling (and color conversion).
 *
 * In this version we upsample each component independently.
 * We upsample one row group into the conversion buffer, then apply
 * color conversion a row at a time.
 */

METHODDEF(void)
sep_upsample (j_decompress_ptr cinfo,
	      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
	      JDIMENSION in_row_groups_avail,
	      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
	      JDIMENSION out_rows_avail)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
  int ci;
  jpeg_component_info * compptr;
  JDIMENSION num_rows;

  /* Fill the conversion buffer, if it's empty */
  if (upsample->next_row_out >= cinfo->max_v_samp_factor) {
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
	 ci++, compptr++) {
      /* Invoke per-component upsample method.  Notice we pass a POINTER
       * to color_buf[ci], so that fullsize_upsample can change it.
       */
      (*upsample->methods[ci]) (cinfo, compptr,
	input_buf[ci] + (*in_row_group_ctr * upsample->rowgroup_height[ci]),
	upsample->color_buf + ci);
    }
    upsample->next_row_out = 0;
  }

  /* Color-convert and emit rows */

  /* How many we have in the buffer: */
  num_rows = (JDIMENSION) (cinfo->max_v_samp_factor - upsample->next_row_out);
  /* Not more than the distance to the end of the image.  Need this test
   * in case the image height is not a multiple of max_v_samp_factor:
   */
  if (num_rows > upsample->rows_to_go) 
    num_rows = upsample->rows_to_go;
  /* And not more than what the client can accept: */
  out_rows_avail -= *out_row_ctr;
  if (num_rows > out_rows_avail)
    num_rows = out_rows_avail;

  (*cinfo->cconvert->color_convert) (cinfo, upsample->color_buf,
				     (JDIMENSION) upsample->next_row_out,
				     output_buf + *out_row_ctr,
				     (int) num_rows);

  /* Adjust counts */
  *out_row_ctr += num_rows;
  upsample->rows_to_go -= num_rows;
  upsample->next_row_out += num_rows;
  /* When the buffer is emptied, declare this input row group consumed */
  if (upsample->next_row_out >= cinfo->max_v_samp_factor)
    (*in_row_group_ctr)++;
}


/*
 * These are the routines invoked by sep_upsample to upsample pixel values
 * of a single component.  One row group is processed per call.
 */


/*
 * For full-size components, we just make color_buf[ci] point at the
 * input buffer, and thus avoid copying any data.  Note that this is
 * safe only because sep_upsample doesn't declare the input row group
 * "consumed" until we are done color converting and emitting it.
 */

METHODDEF(void)
fullsize_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		   JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
  *output_data_ptr = input_data;
}


/*
 * This is a no-op version used for "uninteresting" components.
 * These components will not be referenced by color conversion.
 */

METHODDEF(void)
noop_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
  *output_data_ptr = NULL;	/* safety check */
}


/*
 * This version handles any integral sampling ratios.
 * This is not used for typical JPEG files, so it need not be fast.
 * Nor, for that matter, is it particularly accurate: the algorithm is
 * simple replication of the input pixel onto the corresponding output
 * pixels.  The hi-falutin sampling literature refers to this as a
 * "box filter".  A box filter tends to introduce visible artifacts,
 * so if you are actually going to use 3:1 or 4:1 sampling ratios
 * you would be well advised to improve this code.
 */

METHODDEF(void)
int_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	      JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
  JSAMPARRAY output_data = *output_data_ptr;
  register JSAMPROW inptr, outptr;
  register JSAMPLE invalue;
  register int h;
  JSAMPROW outend;
  int h_expand, v_expand;
  int inrow, outrow;

  h_expand = upsample->h_expand[compptr->component_index];
  v_expand = upsample->v_expand[compptr->component_index];

  inrow = outrow = 0;
  while (outrow < cinfo->max_v_samp_factor) {
    /* Generate one output row with proper horizontal expansion */
    inptr = input_data[inrow];
    outptr = output_data[outrow];
    outend = outptr + cinfo->output_width;
    while (outptr < outend) {
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
      for (h = h_expand; h > 0; h--) {
	*outptr++ = invalue;
      }
    }
    /* Generate any additional output rows by duplicating the first one */
    if (v_expand > 1) {
      jcopy_sample_rows(output_data, outrow, output_data, outrow+1,
			v_expand-1, cinfo->output_width);
    }
    inrow++;
    outrow += v_expand;
  }
}


/*
 * Fast processing for the common case of 2:1 horizontal and 1:1 vertical.
 * It's still a box filter.
 */

METHODDEF(void)
h2v1_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
  JSAMPARRAY output_data = *output_data_ptr;
  register JSAMPROW inptr, outptr;
  register JSAMPLE invalue;
  JSAMPROW outend;
  int inrow;

  for (inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++) {
    inptr = input_data[inrow];
    outptr = output_data[inrow];
    outend = outptr + cinfo->output_width;
    while (outptr < outend) {
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
      *outptr++ = invalue;
      *outptr++ = invalue;
    }
  }
}


/*
 * Fast processing for the common case of 2:1 horizontal and 2:1 vertical.
 * It's still a box filter.
 */

METHODDEF(void)
h2v2_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
  JSAMPARRAY output_data = *output_data_ptr;
  register JSAMPROW inptr, outptr;
  register JSAMPLE invalue;
  JSAMPROW outend;
  int inrow, outrow;

  inrow = outrow = 0;
  while (outrow < cinfo->max_v_samp_factor) {
    inptr = input_data[inrow];
    outptr = output_data[outrow];
    outend = outptr + cinfo->output_width;
    while (outptr < outend) {
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
      *outptr++ = invalue;
      *outptr++ = invalue;
    }
    jcopy_sample_rows(output_data, outrow, output_data, outrow+1,
		      1, cinfo->output_width);
    inrow++;
    outrow += 2;
  }
}


/*
 * Fancy processing for the common case of 2:1 horizontal and 1:1 vertical.
 *
 * The upsampling algorithm is linear interpolation between pixel centers,
 * also known as a "triangle filter".  This is a good compromise between
 * speed and visual quality.  The centers of the output pixels are 1/4 and 3/4
 * of the way between input pixel centers.
 *
 * A note about the "bias" calculations: when rounding fractional values to
 * integer, we do not want to always round 0.5 up to the next integer.
 * If we did that, we'd introduce a noticeable bias towards larger values.
 * Instead, this code is arranged so that 0.5 will be rounded up or down at
 * alternate pixel locations (a simple ordered dither pattern).
 */

METHODDEF(void)
h2v1_fancy_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		     JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
  JSAMPARRAY output_data = *output_data_ptr;
  register JSAMPROW inptr, outptr;
  register int invalue;
  register JDIMENSION colctr;
  int inrow;

  for (inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++) {
    inptr = input_data[inrow];
    outptr = output_data[inrow];
    /* Special case for first column */
    invalue = GETJSAMPLE(*inptr++);
    *outptr++ = (JSAMPLE) invalue;
    *outptr++ = (JSAMPLE) ((invalue * 3 + GETJSAMPLE(*inptr) + 2) >> 2);

    for (colctr = compptr->downsampled_width - 2; colctr > 0; colctr--) {
      /* General case: 3/4 * nearer pixel + 1/4 * further pixel */
      invalue = GETJSAMPLE(*inptr++) * 3;
      *outptr++ = (JSAMPLE) ((invalue + GETJSAMPLE(inptr[-2]) + 1) >> 2);
      *outptr++ = (JSAMPLE) ((invalue + GETJSAMPLE(*inptr) + 2) >> 2);
    }

    /* Special case for last column */
    invalue = GETJSAMPLE(*inptr);
    *outptr++ = (JSAMPLE) ((invalue * 3 + GETJSAMPLE(inptr[-1]) + 1) >> 2);
    *outptr++ = (JSAMPLE) invalue;
  }
}


/*
 * Fancy processing for the common case of 2:1 horizontal and 2:1 vertical.
 * Again a triangle filter; see comments for h2v1 case, above.
 *
 * It is OK for us to reference the adjacent input rows because we demanded
 * context from the main buffer controller (see initialization code).
 */

METHODDEF(void)
h2v2_fancy_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		     JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
  JSAMPARRAY output_data = *output_data_ptr;
  register JSAMPROW inptr0, inptr1, outptr;
#if BITS_IN_JSAMPLE == 8
  register int thiscolsum, lastcolsum, nextcolsum;
#else
  register INT32 thiscolsum, lastcolsum, nextcolsum;
#endif
  register JDIMENSION colctr;
  int inrow, outrow, v;

  inrow = outrow = 0;
  while (outrow < cinfo->max_v_samp_factor) {
    for (v = 0; v < 2; v++) {
      /* inptr0 points to nearest input row, inptr1 points to next nearest */
      inptr0 = input_data[inrow];
      if (v == 0)		/* next nearest is row above */
	inptr1 = input_data[inrow-1];
      else			/* next nearest is row below */
	inptr1 = input_data[inrow+1];
      outptr = output_data[outrow++];

      /* Special case for first column */
      thiscolsum = GETJSAMPLE(*inptr0++) * 3 + GETJSAMPLE(*inptr1++);
      nextcolsum = GETJSAMPLE(*inptr0++) * 3 + GETJSAMPLE(*inptr1++);
      *outptr++ = (JSAMPLE) ((thiscolsum * 4 + 8) >> 4);
      *outptr++ = (JSAMPLE) ((thiscolsum * 3 + nextcolsum + 7) >> 4);
      lastcolsum = thiscolsum; thiscolsum = nextcolsum;

      for (colctr = compptr->downsampled_width - 2; colctr > 0; colctr--) {
	/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each */
	/* dimension, thus 9/16, 3/16, 3/16, 1/16 overall */
	nextcolsum = GETJSAMPLE(*inptr0++) * 3 + GETJSAMPLE(*inptr1++);
	*outptr++ = (JSAMPLE) ((thiscolsum * 3 + lastcolsum + 8) >> 4);
	*outptr++ = (JSAMPLE) ((thiscolsum * 3 + nextcolsum + 7) >> 4);
	lastcolsum = thiscolsum; thiscolsum = nextcolsum;
      }

      /* Special case for last column */
      *outptr++ = (JSAMPLE) ((thiscolsum * 3 + lastcolsum + 8) >> 4);
      *outptr++ = (JSAMPLE) ((thiscolsum * 4 + 7) >> 4);
    }
    inrow++;
  }
}


/*
 * Module initialization routine for upsampling.
 */

GLOBAL(void)
jinit_upsampler (j_decompress_ptr cinfo)
{
  my_upsample_ptr upsample;
  int ci;
  jpeg_component_info * compptr;
  boolean need_buffer, do_fancy;
  int h_in_group, v_in_group, h_out_group, v_out_group;

  upsample = (my_upsample_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_upsampler));
  cinfo->upsample = (struct jpeg_upsampler *) upsample;
  upsample->pub.start_pass = start_pass_upsample;
  upsample->pub.upsample = sep_upsample;
  upsample->pub.need_context_rows = FALSE; /* until we find out differently */

  if (cinfo->CCIR601_sampling)	/* this isn't supported */
    ERREXIT(cinfo, JERR_CCIR601_NOTIMPL);

  /* jdmainct.c doesn't support context rows when min_DCT_scaled_size = 1,
   * so don't ask for it.
   */
  do_fancy = cinfo->do_fancy_upsampling && cinfo->min_DCT_scaled_size > 1;

  /* Verify we can handle the sampling factors, select per-component methods,
   * and create storage as needed.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Compute size of an "input group" after IDCT scaling.  This many samples
     * are to be converted to max_h_samp_factor * max_v_samp_factor pixels.
     */
    h_in_group = (compptr->h_samp_factor * compptr->DCT_scaled_size) /
		 cinfo->min_DCT_scaled_size;
    v_in_group = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
		 cinfo->min_DCT_scaled_size;
    h_out_group = cinfo->max_h_samp_factor;
    v_out_group = cinfo->max_v_samp_factor;
    upsample->rowgroup_height[ci] = v_in_group; /* save for use later */
    need_buffer = TRUE;
    if (! compptr->component_needed) {
      /* Don't bother to upsample an uninteresting component. */
      upsample->methods[ci] = noop_upsample;
      need_buffer = FALSE;
    } else if (h_in_group == h_out_group && v_in_group == v_out_group) {
      /* Fullsize components can be processed without any work. */
      upsample->methods[ci] = fullsize_upsample;
      need_buffer = FALSE;
    } else if (h_in_group * 2 == h_out_group &&
	       v_in_group == v_out_group) {
      /* Special cases for 2h1v upsampling */
      if (do_fancy && compptr->downsampled_width > 2)
	upsample->methods[ci] = h2v1_fancy_upsample;
      else
	upsample->methods[ci] = h2v1_upsample;
    } else if (h_in_group * 2 == h_out_group &&
	       v_in_group * 2 == v_out_group) {
      /* Special cases for 2h2v upsampling */
      if (do_fancy && compptr->downsampled_width > 2) {
	upsample->methods[ci] = h2v2_fancy_upsample;
	upsample->pub.need_context_rows = TRUE;
      } else
	upsample->methods[ci] = h2v2_upsample;
    } else if ((h_out_group % h_in_group) == 0 &&
	       (v_out_group % v_in_group) == 0) {
      /* Generic integral-factors upsampling method */
      upsample->methods[ci] = int_upsample;
      upsample->h_expand[ci] = (UINT8) (h_out_group / h_in_group);
      upsample->v_expand[ci] = (UINT8) (v_out_group / v_in_group);
    } else
      ERREXIT(cinfo, JERR_FRACT_SAMPLE_NOTIMPL);
    if (need_buffer) {
      upsample->color_buf[ci] = (*cinfo->mem->alloc_sarray)
	((j_common_ptr) cinfo, JPOOL_IMAGE,
	 (JDIMENSION) jround_up((long) cinfo->output_width,
				(long) cinfo->max_h_samp_factor),
	 (JDIMENSION) cinfo->max_v_samp_factor);
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jerror.c ===
/*
 * jerror.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains simple error-reporting and trace-message routines.
 * These are suitable for Unix-like systems and others where writing to
 * stderr is the right thing to do.  Many applications will want to replace
 * some or all of these routines.
 *
 * These routines are used by both the compression and decompression code.
 */

/* this is not a core library module, so it doesn't define JPEG_INTERNALS */
#include "jinclude.h"
#include "jpeglib.h"
#include "jversion.h"
#include "jerror.h"

#ifndef EXIT_FAILURE		/* define exit() codes if not provided */
#define EXIT_FAILURE  1
#endif


/*
 * Create the message string table.
 * We do this from the master message list in jerror.h by re-reading
 * jerror.h with a suitable definition for macro JMESSAGE.
 * The message table is made an external symbol just in case any applications
 * want to refer to it directly.
 */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jpeg_std_message_table	jMsgTable
#endif

#define JMESSAGE(code,string)	string ,

const char * const jpeg_std_message_table[] = {
#include "jerror.h"
  NULL
};


#ifndef DARWIN
/*
 * Error exit handler: must not return to caller.
 *
 * Applications may override this if they want to get control back after
 * an error.  Typically one would longjmp somewhere instead of exiting.
 * The setjmp buffer can be made a private field within an expanded error
 * handler object.  Note that the info needed to generate an error message
 * is stored in the error object, so you can generate the message now or
 * later, at your convenience.
 * You should make sure that the JPEG object is cleaned up (with jpeg_abort
 * or jpeg_destroy) at some point.
 */

METHODDEF(void)
error_exit (j_common_ptr cinfo)
{
  /* Always display the message */
  (*cinfo->err->output_message) (cinfo);

  /* Let the memory manager delete any temp files before we die */
  jpeg_destroy(cinfo);

  exit(EXIT_FAILURE);
}


/*
 * Actual output of an error or trace message.
 * Applications may override this method to send JPEG messages somewhere
 * other than stderr.
 */

METHODDEF(void)
output_message (j_common_ptr cinfo)
{
  char buffer[JMSG_LENGTH_MAX];

  /* Create the message */
  (*cinfo->err->format_message) (cinfo, buffer);

  /* Send it to stderr, adding a newline */
  fprintf(stderr, "%s\n", buffer);
}


/*
 * Decide whether to emit a trace or warning message.
 * msg_level is one of:
 *   -1: recoverable corrupt-data warning, may want to abort.
 *    0: important advisory messages (always display to user).
 *    1: first level of tracing detail.
 *    2,3,...: successively more detailed tracing messages.
 * An application might override this method if it wanted to abort on warnings
 * or change the policy about which messages to display.
 */

METHODDEF(void)
emit_message (j_common_ptr cinfo, int msg_level)
{
  struct jpeg_error_mgr * err = cinfo->err;

  if (msg_level < 0) {
    /* It's a warning message.  Since corrupt files may generate many warnings,
     * the policy implemented here is to show only the first warning,
     * unless trace_level >= 3.
     */
    if (err->num_warnings == 0 || err->trace_level >= 3)
      (*err->output_message) (cinfo);
    /* Always count warnings in num_warnings. */
    err->num_warnings++;
  } else {
    /* It's a trace message.  Show it if trace_level >= msg_level. */
    if (err->trace_level >= msg_level)
      (*err->output_message) (cinfo);
  }
}


/*
 * Format a message string for the most recent JPEG error or message.
 * The message is stored into buffer, which should be at least JMSG_LENGTH_MAX
 * characters.  Note that no '\n' character is added to the string.
 * Few applications should need to override this method.
 */

METHODDEF(void)
format_message (j_common_ptr cinfo, char * buffer)
{
  struct jpeg_error_mgr * err = cinfo->err;
  int msg_code = err->msg_code;
  const char * msgtext = NULL;
  const char * msgptr;
  char ch;
  boolean isstring;

  /* Look up message string in proper table */
  if (msg_code > 0 && msg_code <= err->last_jpeg_message) {
    msgtext = err->jpeg_message_table[msg_code];
  } else if (err->addon_message_table != NULL &&
	     msg_code >= err->first_addon_message &&
	     msg_code <= err->last_addon_message) {
    msgtext = err->addon_message_table[msg_code - err->first_addon_message];
  }

  /* Defend against bogus message number */
  if (msgtext == NULL) {
    err->msg_parm.i[0] = msg_code;
    msgtext = err->jpeg_message_table[0];
  }

  /* Check for string parameter, as indicated by %s in the message text */
  isstring = FALSE;
  msgptr = msgtext;
  while ((ch = *msgptr++) != '\0') {
    if (ch == '%') {
      if (*msgptr == 's') isstring = TRUE;
      break;
    }
  }

  /* Format the message into the passed buffer */
  if (isstring)
    sprintf(buffer, msgtext, err->msg_parm.s);
  else
    sprintf(buffer, msgtext,
	    err->msg_parm.i[0], err->msg_parm.i[1],
	    err->msg_parm.i[2], err->msg_parm.i[3],
	    err->msg_parm.i[4], err->msg_parm.i[5],
	    err->msg_parm.i[6], err->msg_parm.i[7]);
}


/*
 * Reset error state variables at start of a new image.
 * This is called during compression startup to reset trace/error
 * processing to default state, without losing any application-specific
 * method pointers.  An application might possibly want to override
 * this method if it has additional error processing state.
 */

METHODDEF(void)
reset_error_mgr (j_common_ptr cinfo)
{
  cinfo->err->num_warnings = 0;
  /* trace_level is not reset since it is an application-supplied parameter */
  cinfo->err->msg_code = 0;	/* may be useful as a flag for "no error" */
}
#endif //!DARWIN


/*
 * Fill in the standard error-handling methods in a jpeg_error_mgr object.
 * Typical call is:
 *	struct jpeg_compress_struct cinfo;
 *	struct jpeg_error_mgr err;
 *
 *	cinfo.err = jpeg_std_error(&err);
 * after which the application may override some of the methods.
 */

GLOBAL(struct jpeg_error_mgr *)
jpeg_std_error (struct jpeg_error_mgr * err)
{

// We override these and don't need them. They just take
// up space.
#ifndef DARWIN
  err->error_exit = error_exit;
  err->emit_message = emit_message;
  err->output_message = output_message;
  err->format_message = format_message;
  err->reset_error_mgr = reset_error_mgr;
#endif //!DARWIN

  err->trace_level = 0;		/* default = no tracing */
  err->num_warnings = 0;	/* no warnings emitted yet */
  err->msg_code = 0;		/* may be useful as a flag for "no error" */

  /* Initialize message table pointers */
  err->jpeg_message_table = jpeg_std_message_table;
  err->last_jpeg_message = (int) JMSG_LASTMSGCODE - 1;

  err->addon_message_table = NULL;
  err->first_addon_message = 0;	/* for safety */
  err->last_addon_message = 0;

  return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jfdctflt.c ===
/*
 * jfdctflt.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains a floating-point implementation of the
 * forward DCT (Discrete Cosine Transform).
 *
 * This implementation should be more accurate than either of the integer
 * DCT implementations.  However, it may not give the same results on all
 * machines because of differences in roundoff behavior.  Speed will depend
 * on the hardware's floating point capacity.
 *
 * A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
 * on each column.  Direct algorithms are also available, but they are
 * much more complex and seem not to be any faster when reduced to code.
 *
 * This implementation is based on Arai, Agui, and Nakajima's algorithm for
 * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
 * Japanese, but the algorithm is described in the Pennebaker & Mitchell
 * JPEG textbook (see REFERENCES section in file README).  The following code
 * is based directly on figure 4-8 in P&M.
 * While an 8-point DCT cannot be done in less than 11 multiplies, it is
 * possible to arrange the computation so that many of the multiplies are
 * simple scalings of the final outputs.  These multiplies can then be
 * folded into the multiplications or divisions by the JPEG quantization
 * table entries.  The AA&N method leaves only 5 multiplies and 29 adds
 * to be done in the DCT itself.
 * The primary disadvantage of this method is that with a fixed-point
 * implementation, accuracy is lost due to imprecise representation of the
 * scaled quantization values.  However, that problem does not arise if
 * we use floating point arithmetic.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"
#include "jdct.h"		/* Private declarations for DCT subsystem */

#ifdef DCT_FLOAT_SUPPORTED


/*
 * This module is specialized to the case DCTSIZE = 8.
 */

#if DCTSIZE != 8
  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */
#endif


/*
 * Perform the forward DCT on one block of samples.
 */

GLOBAL(void)
jpeg_fdct_float (FAST_FLOAT * data)
{
  FAST_FLOAT tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
  FAST_FLOAT tmp10, tmp11, tmp12, tmp13;
  FAST_FLOAT z1, z2, z3, z4, z5, z11, z13;
  FAST_FLOAT *dataptr;
  int ctr;

  /* Pass 1: process rows. */

  dataptr = data;
  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {
    tmp0 = dataptr[0] + dataptr[7];
    tmp7 = dataptr[0] - dataptr[7];
    tmp1 = dataptr[1] + dataptr[6];
    tmp6 = dataptr[1] - dataptr[6];
    tmp2 = dataptr[2] + dataptr[5];
    tmp5 = dataptr[2] - dataptr[5];
    tmp3 = dataptr[3] + dataptr[4];
    tmp4 = dataptr[3] - dataptr[4];
    
    /* Even part */
    
    tmp10 = tmp0 + tmp3;	/* phase 2 */
    tmp13 = tmp0 - tmp3;
    tmp11 = tmp1 + tmp2;
    tmp12 = tmp1 - tmp2;
    
    dataptr[0] = tmp10 + tmp11; /* phase 3 */
    dataptr[4] = tmp10 - tmp11;
    
    z1 = (tmp12 + tmp13) * ((FAST_FLOAT) 0.707106781); /* c4 */
    dataptr[2] = tmp13 + z1;	/* phase 5 */
    dataptr[6] = tmp13 - z1;
    
    /* Odd part */

    tmp10 = tmp4 + tmp5;	/* phase 2 */
    tmp11 = tmp5 + tmp6;
    tmp12 = tmp6 + tmp7;

    /* The rotator is modified from fig 4-8 to avoid extra negations. */
    z5 = (tmp10 - tmp12) * ((FAST_FLOAT) 0.382683433); /* c6 */
    z2 = ((FAST_FLOAT) 0.541196100) * tmp10 + z5; /* c2-c6 */
    z4 = ((FAST_FLOAT) 1.306562965) * tmp12 + z5; /* c2+c6 */
    z3 = tmp11 * ((FAST_FLOAT) 0.707106781); /* c4 */

    z11 = tmp7 + z3;		/* phase 5 */
    z13 = tmp7 - z3;

    dataptr[5] = z13 + z2;	/* phase 6 */
    dataptr[3] = z13 - z2;
    dataptr[1] = z11 + z4;
    dataptr[7] = z11 - z4;

    dataptr += DCTSIZE;		/* advance pointer to next row */
  }

  /* Pass 2: process columns. */

  dataptr = data;
  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {
    tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*7];
    tmp7 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*7];
    tmp1 = dataptr[DCTSIZE*1] + dataptr[DCTSIZE*6];
    tmp6 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*6];
    tmp2 = dataptr[DCTSIZE*2] + dataptr[DCTSIZE*5];
    tmp5 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*5];
    tmp3 = dataptr[DCTSIZE*3] + dataptr[DCTSIZE*4];
    tmp4 = dataptr[DCTSIZE*3] - dataptr[DCTSIZE*4];
    
    /* Even part */
    
    tmp10 = tmp0 + tmp3;	/* phase 2 */
    tmp13 = tmp0 - tmp3;
    tmp11 = tmp1 + tmp2;
    tmp12 = tmp1 - tmp2;
    
    dataptr[DCTSIZE*0] = tmp10 + tmp11; /* phase 3 */
    dataptr[DCTSIZE*4] = tmp10 - tmp11;
    
    z1 = (tmp12 + tmp13) * ((FAST_FLOAT) 0.707106781); /* c4 */
    dataptr[DCTSIZE*2] = tmp13 + z1; /* phase 5 */
    dataptr[DCTSIZE*6] = tmp13 - z1;
    
    /* Odd part */

    tmp10 = tmp4 + tmp5;	/* phase 2 */
    tmp11 = tmp5 + tmp6;
    tmp12 = tmp6 + tmp7;

    /* The rotator is modified from fig 4-8 to avoid extra negations. */
    z5 = (tmp10 - tmp12) * ((FAST_FLOAT) 0.382683433); /* c6 */
    z2 = ((FAST_FLOAT) 0.541196100) * tmp10 + z5; /* c2-c6 */
    z4 = ((FAST_FLOAT) 1.306562965) * tmp12 + z5; /* c2+c6 */
    z3 = tmp11 * ((FAST_FLOAT) 0.707106781); /* c4 */

    z11 = tmp7 + z3;		/* phase 5 */
    z13 = tmp7 - z3;

    dataptr[DCTSIZE*5] = z13 + z2; /* phase 6 */
    dataptr[DCTSIZE*3] = z13 - z2;
    dataptr[DCTSIZE*1] = z11 + z4;
    dataptr[DCTSIZE*7] = z11 - z4;

    dataptr++;			/* advance pointer to next column */
  }
}

#endif /* DCT_FLOAT_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jfdctint.c ===
/*
 * jfdctint.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains a slow-but-accurate integer implementation of the
 * forward DCT (Discrete Cosine Transform).
 *
 * A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
 * on each column.  Direct algorithms are also available, but they are
 * much more complex and seem not to be any faster when reduced to code.
 *
 * This implementation is based on an algorithm described in
 *   C. Loeffler, A. Ligtenberg and G. Moschytz, "Practical Fast 1-D DCT
 *   Algorithms with 11 Multiplications", Proc. Int'l. Conf. on Acoustics,
 *   Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.
 * The primary algorithm described there uses 11 multiplies and 29 adds.
 * We use their alternate method with 12 multiplies and 32 adds.
 * The advantage of this method is that no data path contains more than one
 * multiplication; this allows a very simple and accurate implementation in
 * scaled fixed-point arithmetic, with a minimal number of shifts.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"
#include "jdct.h"		/* Private declarations for DCT subsystem */

#ifdef DCT_ISLOW_SUPPORTED


/*
 * This module is specialized to the case DCTSIZE = 8.
 */

#if DCTSIZE != 8
  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */
#endif


/*
 * The scaling stuff is as follows:
 *
 * Each 1-D DCT step produces outputs which are a factor of sqrt(N)
 * larger than the true DCT outputs.  The final outputs are therefore
 * a factor of N larger than desired; since N=8 this can be cured by
 * a simple right shift at the end of the algorithm.  The advantage of
 * this arrangement is that we save two multiplications per 1-D DCT,
 * because the y0 and y4 outputs need not be divided by sqrt(N).
 * In the IJG code, this factor of 8 is removed by the quantization step
 * (in jcdctmgr.c), NOT in this module.
 *
 * We have to do addition and subtraction of the integer inputs, which
 * is no problem, and multiplication by fractional constants, which is
 * a problem to do in integer arithmetic.  We multiply all the constants
 * by CONST_SCALE and convert them to integer constants (thus retaining
 * CONST_BITS bits of precision in the constants).  After doing a
 * multiplication we have to divide the product by CONST_SCALE, with proper
 * rounding, to produce the correct output.  This division can be done
 * cheaply as a right shift of CONST_BITS bits.  We postpone shifting
 * as long as possible so that partial sums can be added together with
 * full fractional precision.
 *
 * The outputs of the first pass are scaled up by PASS1_BITS bits so that
 * they are represented to better-than-integral precision.  These outputs
 * require BITS_IN_JSAMPLE + PASS1_BITS + 3 bits; this fits in a 16-bit word
 * with the recommended scaling.  (For 12-bit sample data, the intermediate
 * array is INT32 anyway.)
 *
 * To avoid overflow of the 32-bit intermediate results in pass 2, we must
 * have BITS_IN_JSAMPLE + CONST_BITS + PASS1_BITS <= 26.  Error analysis
 * shows that the values given below are the most effective.
 */

#if BITS_IN_JSAMPLE == 8
#define CONST_BITS  13
#define PASS1_BITS  2
#else
#define CONST_BITS  13
#define PASS1_BITS  1		/* lose a little precision to avoid overflow */
#endif

/* Some C compilers fail to reduce "FIX(constant)" at compile time, thus
 * causing a lot of useless floating-point operations at run time.
 * To get around this we use the following pre-calculated constants.
 * If you change CONST_BITS you may want to add appropriate values.
 * (With a reasonable C compiler, you can just rely on the FIX() macro...)
 */

#if CONST_BITS == 13
#define FIX_0_298631336  ((INT32)  2446)	/* FIX(0.298631336) */
#define FIX_0_390180644  ((INT32)  3196)	/* FIX(0.390180644) */
#define FIX_0_541196100  ((INT32)  4433)	/* FIX(0.541196100) */
#define FIX_0_765366865  ((INT32)  6270)	/* FIX(0.765366865) */
#define FIX_0_899976223  ((INT32)  7373)	/* FIX(0.899976223) */
#define FIX_1_175875602  ((INT32)  9633)	/* FIX(1.175875602) */
#define FIX_1_501321110  ((INT32)  12299)	/* FIX(1.501321110) */
#define FIX_1_847759065  ((INT32)  15137)	/* FIX(1.847759065) */
#define FIX_1_961570560  ((INT32)  16069)	/* FIX(1.961570560) */
#define FIX_2_053119869  ((INT32)  16819)	/* FIX(2.053119869) */
#define FIX_2_562915447  ((INT32)  20995)	/* FIX(2.562915447) */
#define FIX_3_072711026  ((INT32)  25172)	/* FIX(3.072711026) */
#else
#define FIX_0_298631336  FIX(0.298631336)
#define FIX_0_390180644  FIX(0.390180644)
#define FIX_0_541196100  FIX(0.541196100)
#define FIX_0_765366865  FIX(0.765366865)
#define FIX_0_899976223  FIX(0.899976223)
#define FIX_1_175875602  FIX(1.175875602)
#define FIX_1_501321110  FIX(1.501321110)
#define FIX_1_847759065  FIX(1.847759065)
#define FIX_1_961570560  FIX(1.961570560)
#define FIX_2_053119869  FIX(2.053119869)
#define FIX_2_562915447  FIX(2.562915447)
#define FIX_3_072711026  FIX(3.072711026)
#endif


/* Multiply an INT32 variable by an INT32 constant to yield an INT32 result.
 * For 8-bit samples with the recommended scaling, all the variable
 * and constant values involved are no more than 16 bits wide, so a
 * 16x16->32 bit multiply can be used instead of a full 32x32 multiply.
 * For 12-bit samples, a full 32-bit multiplication will be needed.
 */

#if BITS_IN_JSAMPLE == 8
#define MULTIPLY(var,const)  MULTIPLY16C16(var,const)
#else
#define MULTIPLY(var,const)  ((var) * (const))
#endif


/*
 * Perform the forward DCT on one block of samples.
 */

GLOBAL(void)
jpeg_fdct_islow (DCTELEM * data)
{
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
  INT32 tmp10, tmp11, tmp12, tmp13;
  INT32 z1, z2, z3, z4, z5;
  DCTELEM *dataptr;
  int ctr;
  SHIFT_TEMPS

  /* Pass 1: process rows. */
  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
  /* furthermore, we scale the results by 2**PASS1_BITS. */

  dataptr = data;
  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {
    tmp0 = dataptr[0] + dataptr[7];
    tmp7 = dataptr[0] - dataptr[7];
    tmp1 = dataptr[1] + dataptr[6];
    tmp6 = dataptr[1] - dataptr[6];
    tmp2 = dataptr[2] + dataptr[5];
    tmp5 = dataptr[2] - dataptr[5];
    tmp3 = dataptr[3] + dataptr[4];
    tmp4 = dataptr[3] - dataptr[4];
    
    /* Even part per LL&M figure 1 --- note that published figure is faulty;
     * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".
     */
    
    tmp10 = tmp0 + tmp3;
    tmp13 = tmp0 - tmp3;
    tmp11 = tmp1 + tmp2;
    tmp12 = tmp1 - tmp2;
    
    dataptr[0] = (DCTELEM) ((tmp10 + tmp11) << PASS1_BITS);
    dataptr[4] = (DCTELEM) ((tmp10 - tmp11) << PASS1_BITS);
    
    z1 = MULTIPLY(tmp12 + tmp13, FIX_0_541196100);
    dataptr[2] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp13, FIX_0_765366865),
				   CONST_BITS-PASS1_BITS);
    dataptr[6] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp12, - FIX_1_847759065),
				   CONST_BITS-PASS1_BITS);
    
    /* Odd part per figure 8 --- note paper omits factor of sqrt(2).
     * cK represents cos(K*pi/16).
     * i0..i3 in the paper are tmp4..tmp7 here.
     */
    
    z1 = tmp4 + tmp7;
    z2 = tmp5 + tmp6;
    z3 = tmp4 + tmp6;
    z4 = tmp5 + tmp7;
    z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
    
    tmp4 = MULTIPLY(tmp4, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
    tmp5 = MULTIPLY(tmp5, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
    tmp6 = MULTIPLY(tmp6, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
    tmp7 = MULTIPLY(tmp7, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
    
    z3 += z5;
    z4 += z5;
    
    dataptr[7] = (DCTELEM) DESCALE(tmp4 + z1 + z3, CONST_BITS-PASS1_BITS);
    dataptr[5] = (DCTELEM) DESCALE(tmp5 + z2 + z4, CONST_BITS-PASS1_BITS);
    dataptr[3] = (DCTELEM) DESCALE(tmp6 + z2 + z3, CONST_BITS-PASS1_BITS);
    dataptr[1] = (DCTELEM) DESCALE(tmp7 + z1 + z4, CONST_BITS-PASS1_BITS);
    
    dataptr += DCTSIZE;		/* advance pointer to next row */
  }

  /* Pass 2: process columns.
   * We remove the PASS1_BITS scaling, but leave the results scaled up
   * by an overall factor of 8.
   */

  dataptr = data;
  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {
    tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*7];
    tmp7 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*7];
    tmp1 = dataptr[DCTSIZE*1] + dataptr[DCTSIZE*6];
    tmp6 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*6];
    tmp2 = dataptr[DCTSIZE*2] + dataptr[DCTSIZE*5];
    tmp5 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*5];
    tmp3 = dataptr[DCTSIZE*3] + dataptr[DCTSIZE*4];
    tmp4 = dataptr[DCTSIZE*3] - dataptr[DCTSIZE*4];
    
    /* Even part per LL&M figure 1 --- note that published figure is faulty;
     * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".
     */
    
    tmp10 = tmp0 + tmp3;
    tmp13 = tmp0 - tmp3;
    tmp11 = tmp1 + tmp2;
    tmp12 = tmp1 - tmp2;
    
    dataptr[DCTSIZE*0] = (DCTELEM) DESCALE(tmp10 + tmp11, PASS1_BITS);
    dataptr[DCTSIZE*4] = (DCTELEM) DESCALE(tmp10 - tmp11, PASS1_BITS);
    
    z1 = MULTIPLY(tmp12 + tmp13, FIX_0_541196100);
    dataptr[DCTSIZE*2] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp13, FIX_0_765366865),
					   CONST_BITS+PASS1_BITS);
    dataptr[DCTSIZE*6] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp12, - FIX_1_847759065),
					   CONST_BITS+PASS1_BITS);
    
    /* Odd part per figure 8 --- note paper omits factor of sqrt(2).
     * cK represents cos(K*pi/16).
     * i0..i3 in the paper are tmp4..tmp7 here.
     */
    
    z1 = tmp4 + tmp7;
    z2 = tmp5 + tmp6;
    z3 = tmp4 + tmp6;
    z4 = tmp5 + tmp7;
    z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
    
    tmp4 = MULTIPLY(tmp4, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
    tmp5 = MULTIPLY(tmp5, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
    tmp6 = MULTIPLY(tmp6, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
    tmp7 = MULTIPLY(tmp7, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
    
    z3 += z5;
    z4 += z5;
    
    dataptr[DCTSIZE*7] = (DCTELEM) DESCALE(tmp4 + z1 + z3,
					   CONST_BITS+PASS1_BITS);
    dataptr[DCTSIZE*5] = (DCTELEM) DESCALE(tmp5 + z2 + z4,
					   CONST_BITS+PASS1_BITS);
    dataptr[DCTSIZE*3] = (DCTELEM) DESCALE(tmp6 + z2 + z3,
					   CONST_BITS+PASS1_BITS);
    dataptr[DCTSIZE*1] = (DCTELEM) DESCALE(tmp7 + z1 + z4,
					   CONST_BITS+PASS1_BITS);
    
    dataptr++;			/* advance pointer to next column */
  }
}

#endif /* DCT_ISLOW_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jfdctfst.c ===
/*
 * jfdctfst.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains a fast, not so accurate integer implementation of the
 * forward DCT (Discrete Cosine Transform).
 *
 * A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
 * on each column.  Direct algorithms are also available, but they are
 * much more complex and seem not to be any faster when reduced to code.
 *
 * This implementation is based on Arai, Agui, and Nakajima's algorithm for
 * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
 * Japanese, but the algorithm is described in the Pennebaker & Mitchell
 * JPEG textbook (see REFERENCES section in file README).  The following code
 * is based directly on figure 4-8 in P&M.
 * While an 8-point DCT cannot be done in less than 11 multiplies, it is
 * possible to arrange the computation so that many of the multiplies are
 * simple scalings of the final outputs.  These multiplies can then be
 * folded into the multiplications or divisions by the JPEG quantization
 * table entries.  The AA&N method leaves only 5 multiplies and 29 adds
 * to be done in the DCT itself.
 * The primary disadvantage of this method is that with fixed-point math,
 * accuracy is lost due to imprecise representation of the scaled
 * quantization values.  The smaller the quantization table entry, the less
 * precise the scaled value, so this implementation does worse with high-
 * quality-setting files than with low-quality ones.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"
#include "jdct.h"		/* Private declarations for DCT subsystem */

#ifdef DCT_IFAST_SUPPORTED


/*
 * This module is specialized to the case DCTSIZE = 8.
 */

#if DCTSIZE != 8
  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */
#endif


/* Scaling decisions are generally the same as in the LL&M algorithm;
 * see jfdctint.c for more details.  However, we choose to descale
 * (right shift) multiplication products as soon as they are formed,
 * rather than carrying additional fractional bits into subsequent additions.
 * This compromises accuracy slightly, but it lets us save a few shifts.
 * More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)
 * everywhere except in the multiplications proper; this saves a good deal
 * of work on 16-bit-int machines.
 *
 * Again to save a few shifts, the intermediate results between pass 1 and
 * pass 2 are not upscaled, but are represented only to integral precision.
 *
 * A final compromise is to represent the multiplicative constants to only
 * 8 fractional bits, rather than 13.  This saves some shifting work on some
 * machines, and may also reduce the cost of multiplication (since there
 * are fewer one-bits in the constants).
 */

#define CONST_BITS  8


/* Some C compilers fail to reduce "FIX(constant)" at compile time, thus
 * causing a lot of useless floating-point operations at run time.
 * To get around this we use the following pre-calculated constants.
 * If you change CONST_BITS you may want to add appropriate values.
 * (With a reasonable C compiler, you can just rely on the FIX() macro...)
 */

#if CONST_BITS == 8
#define FIX_0_382683433  ((INT32)   98)		/* FIX(0.382683433) */
#define FIX_0_541196100  ((INT32)  139)		/* FIX(0.541196100) */
#define FIX_0_707106781  ((INT32)  181)		/* FIX(0.707106781) */
#define FIX_1_306562965  ((INT32)  334)		/* FIX(1.306562965) */
#else
#define FIX_0_382683433  FIX(0.382683433)
#define FIX_0_541196100  FIX(0.541196100)
#define FIX_0_707106781  FIX(0.707106781)
#define FIX_1_306562965  FIX(1.306562965)
#endif


/* We can gain a little more speed, with a further compromise in accuracy,
 * by omitting the addition in a descaling shift.  This yields an incorrectly
 * rounded result half the time...
 */

#ifndef USE_ACCURATE_ROUNDING
#undef DESCALE
#define DESCALE(x,n)  RIGHT_SHIFT(x, n)
#endif


/* Multiply a DCTELEM variable by an INT32 constant, and immediately
 * descale to yield a DCTELEM result.
 */

#define MULTIPLY(var,const)  ((DCTELEM) DESCALE((var) * (const), CONST_BITS))


/*
 * Perform the forward DCT on one block of samples.
 */

GLOBAL(void)
jpeg_fdct_ifast (DCTELEM * data)
{
  DCTELEM tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
  DCTELEM tmp10, tmp11, tmp12, tmp13;
  DCTELEM z1, z2, z3, z4, z5, z11, z13;
  DCTELEM *dataptr;
  int ctr;
  SHIFT_TEMPS

  /* Pass 1: process rows. */

  dataptr = data;
  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {
    tmp0 = dataptr[0] + dataptr[7];
    tmp7 = dataptr[0] - dataptr[7];
    tmp1 = dataptr[1] + dataptr[6];
    tmp6 = dataptr[1] - dataptr[6];
    tmp2 = dataptr[2] + dataptr[5];
    tmp5 = dataptr[2] - dataptr[5];
    tmp3 = dataptr[3] + dataptr[4];
    tmp4 = dataptr[3] - dataptr[4];
    
    /* Even part */
    
    tmp10 = tmp0 + tmp3;	/* phase 2 */
    tmp13 = tmp0 - tmp3;
    tmp11 = tmp1 + tmp2;
    tmp12 = tmp1 - tmp2;
    
    dataptr[0] = tmp10 + tmp11; /* phase 3 */
    dataptr[4] = tmp10 - tmp11;
    
    z1 = MULTIPLY(tmp12 + tmp13, FIX_0_707106781); /* c4 */
    dataptr[2] = tmp13 + z1;	/* phase 5 */
    dataptr[6] = tmp13 - z1;
    
    /* Odd part */

    tmp10 = tmp4 + tmp5;	/* phase 2 */
    tmp11 = tmp5 + tmp6;
    tmp12 = tmp6 + tmp7;

    /* The rotator is modified from fig 4-8 to avoid extra negations. */
    z5 = MULTIPLY(tmp10 - tmp12, FIX_0_382683433); /* c6 */
    z2 = MULTIPLY(tmp10, FIX_0_541196100) + z5; /* c2-c6 */
    z4 = MULTIPLY(tmp12, FIX_1_306562965) + z5; /* c2+c6 */
    z3 = MULTIPLY(tmp11, FIX_0_707106781); /* c4 */

    z11 = tmp7 + z3;		/* phase 5 */
    z13 = tmp7 - z3;

    dataptr[5] = z13 + z2;	/* phase 6 */
    dataptr[3] = z13 - z2;
    dataptr[1] = z11 + z4;
    dataptr[7] = z11 - z4;

    dataptr += DCTSIZE;		/* advance pointer to next row */
  }

  /* Pass 2: process columns. */

  dataptr = data;
  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {
    tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*7];
    tmp7 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*7];
    tmp1 = dataptr[DCTSIZE*1] + dataptr[DCTSIZE*6];
    tmp6 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*6];
    tmp2 = dataptr[DCTSIZE*2] + dataptr[DCTSIZE*5];
    tmp5 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*5];
    tmp3 = dataptr[DCTSIZE*3] + dataptr[DCTSIZE*4];
    tmp4 = dataptr[DCTSIZE*3] - dataptr[DCTSIZE*4];
    
    /* Even part */
    
    tmp10 = tmp0 + tmp3;	/* phase 2 */
    tmp13 = tmp0 - tmp3;
    tmp11 = tmp1 + tmp2;
    tmp12 = tmp1 - tmp2;
    
    dataptr[DCTSIZE*0] = tmp10 + tmp11; /* phase 3 */
    dataptr[DCTSIZE*4] = tmp10 - tmp11;
    
    z1 = MULTIPLY(tmp12 + tmp13, FIX_0_707106781); /* c4 */
    dataptr[DCTSIZE*2] = tmp13 + z1; /* phase 5 */
    dataptr[DCTSIZE*6] = tmp13 - z1;
    
    /* Odd part */

    tmp10 = tmp4 + tmp5;	/* phase 2 */
    tmp11 = tmp5 + tmp6;
    tmp12 = tmp6 + tmp7;

    /* The rotator is modified from fig 4-8 to avoid extra negations. */
    z5 = MULTIPLY(tmp10 - tmp12, FIX_0_382683433); /* c6 */
    z2 = MULTIPLY(tmp10, FIX_0_541196100) + z5; /* c2-c6 */
    z4 = MULTIPLY(tmp12, FIX_1_306562965) + z5; /* c2+c6 */
    z3 = MULTIPLY(tmp11, FIX_0_707106781); /* c4 */

    z11 = tmp7 + z3;		/* phase 5 */
    z13 = tmp7 - z3;

    dataptr[DCTSIZE*5] = z13 + z2; /* phase 6 */
    dataptr[DCTSIZE*3] = z13 - z2;
    dataptr[DCTSIZE*1] = z11 + z4;
    dataptr[DCTSIZE*7] = z11 - z4;

    dataptr++;			/* advance pointer to next column */
  }
}

#endif /* DCT_IFAST_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jidctflt.c ===
/*
 * jidctflt.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains a floating-point implementation of the
 * inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
 * must also perform dequantization of the input coefficients.
 *
 * This implementation should be more accurate than either of the integer
 * IDCT implementations.  However, it may not give the same results on all
 * machines because of differences in roundoff behavior.  Speed will depend
 * on the hardware's floating point capacity.
 *
 * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
 * on each row (or vice versa, but it's more convenient to emit a row at
 * a time).  Direct algorithms are also available, but they are much more
 * complex and seem not to be any faster when reduced to code.
 *
 * This implementation is based on Arai, Agui, and Nakajima's algorithm for
 * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
 * Japanese, but the algorithm is described in the Pennebaker & Mitchell
 * JPEG textbook (see REFERENCES section in file README).  The following code
 * is based directly on figure 4-8 in P&M.
 * While an 8-point DCT cannot be done in less than 11 multiplies, it is
 * possible to arrange the computation so that many of the multiplies are
 * simple scalings of the final outputs.  These multiplies can then be
 * folded into the multiplications or divisions by the JPEG quantization
 * table entries.  The AA&N method leaves only 5 multiplies and 29 adds
 * to be done in the DCT itself.
 * The primary disadvantage of this method is that with a fixed-point
 * implementation, accuracy is lost due to imprecise representation of the
 * scaled quantization values.  However, that problem does not arise if
 * we use floating point arithmetic.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"
#include "jdct.h"		/* Private declarations for DCT subsystem */

#ifdef DCT_FLOAT_SUPPORTED


/*
 * This module is specialized to the case DCTSIZE = 8.
 */

#if DCTSIZE != 8
  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */
#endif


/* Dequantize a coefficient by multiplying it by the multiplier-table
 * entry; produce a float result.
 */

#define DEQUANTIZE(coef,quantval)  (((FAST_FLOAT) (coef)) * (quantval))


/*
 * Perform dequantization and inverse DCT on one block of coefficients.
 */

GLOBAL(void)
jpeg_idct_float (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
  FAST_FLOAT tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
  FAST_FLOAT tmp10, tmp11, tmp12, tmp13;
  FAST_FLOAT z5, z10, z11, z12, z13;
  JCOEFPTR inptr;
  FLOAT_MULT_TYPE * quantptr;
  FAST_FLOAT * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
  int ctr;
  FAST_FLOAT workspace[DCTSIZE2]; /* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
  quantptr = (FLOAT_MULT_TYPE *) compptr->dct_table;
  wsptr = workspace;
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
    /* Due to quantization, we will usually find that many of the input
     * coefficients are zero, especially the AC terms.  We can exploit this
     * by short-circuiting the IDCT calculation for any column in which all
     * the AC terms are zero.  In that case each output is equal to the
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */
    
    if ((inptr[DCTSIZE*1] | inptr[DCTSIZE*2] | inptr[DCTSIZE*3] |
	 inptr[DCTSIZE*4] | inptr[DCTSIZE*5] | inptr[DCTSIZE*6] |
	 inptr[DCTSIZE*7]) == 0) {
      /* AC terms all zero */
      FAST_FLOAT dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
      
      wsptr[DCTSIZE*0] = dcval;
      wsptr[DCTSIZE*1] = dcval;
      wsptr[DCTSIZE*2] = dcval;
      wsptr[DCTSIZE*3] = dcval;
      wsptr[DCTSIZE*4] = dcval;
      wsptr[DCTSIZE*5] = dcval;
      wsptr[DCTSIZE*6] = dcval;
      wsptr[DCTSIZE*7] = dcval;
      
      inptr++;			/* advance pointers to next column */
      quantptr++;
      wsptr++;
      continue;
    }
    
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);

    tmp10 = tmp0 + tmp2;	/* phase 3 */
    tmp11 = tmp0 - tmp2;

    tmp13 = tmp1 + tmp3;	/* phases 5-3 */
    tmp12 = (tmp1 - tmp3) * ((FAST_FLOAT) 1.414213562) - tmp13; /* 2*c4 */

    tmp0 = tmp10 + tmp13;	/* phase 2 */
    tmp3 = tmp10 - tmp13;
    tmp1 = tmp11 + tmp12;
    tmp2 = tmp11 - tmp12;
    
    /* Odd part */

    tmp4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
    tmp5 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
    tmp6 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
    tmp7 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);

    z13 = tmp6 + tmp5;		/* phase 6 */
    z10 = tmp6 - tmp5;
    z11 = tmp4 + tmp7;
    z12 = tmp4 - tmp7;

    tmp7 = z11 + z13;		/* phase 5 */
    tmp11 = (z11 - z13) * ((FAST_FLOAT) 1.414213562); /* 2*c4 */

    z5 = (z10 + z12) * ((FAST_FLOAT) 1.847759065); /* 2*c2 */
    tmp10 = ((FAST_FLOAT) 1.082392200) * z12 - z5; /* 2*(c2-c6) */
    tmp12 = ((FAST_FLOAT) -2.613125930) * z10 + z5; /* -2*(c2+c6) */

    tmp6 = tmp12 - tmp7;	/* phase 2 */
    tmp5 = tmp11 - tmp6;
    tmp4 = tmp10 + tmp5;

    wsptr[DCTSIZE*0] = tmp0 + tmp7;
    wsptr[DCTSIZE*7] = tmp0 - tmp7;
    wsptr[DCTSIZE*1] = tmp1 + tmp6;
    wsptr[DCTSIZE*6] = tmp1 - tmp6;
    wsptr[DCTSIZE*2] = tmp2 + tmp5;
    wsptr[DCTSIZE*5] = tmp2 - tmp5;
    wsptr[DCTSIZE*4] = tmp3 + tmp4;
    wsptr[DCTSIZE*3] = tmp3 - tmp4;

    inptr++;			/* advance pointers to next column */
    quantptr++;
    wsptr++;
  }
  
  /* Pass 2: process rows from work array, store into output array. */
  /* Note that we must descale the results by a factor of 8 == 2**3. */

  wsptr = workspace;
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
    outptr = output_buf[ctr] + output_col;
    /* Rows of zeroes can be exploited in the same way as we did with columns.
     * However, the column calculation has created many nonzero AC terms, so
     * the simplification applies less often (typically 5% to 10% of the time).
     * And testing floats for zero is relatively expensive, so we don't bother.
     */
    
    /* Even part */

    tmp10 = wsptr[0] + wsptr[4];
    tmp11 = wsptr[0] - wsptr[4];

    tmp13 = wsptr[2] + wsptr[6];
    tmp12 = (wsptr[2] - wsptr[6]) * ((FAST_FLOAT) 1.414213562) - tmp13;

    tmp0 = tmp10 + tmp13;
    tmp3 = tmp10 - tmp13;
    tmp1 = tmp11 + tmp12;
    tmp2 = tmp11 - tmp12;

    /* Odd part */

    z13 = wsptr[5] + wsptr[3];
    z10 = wsptr[5] - wsptr[3];
    z11 = wsptr[1] + wsptr[7];
    z12 = wsptr[1] - wsptr[7];

    tmp7 = z11 + z13;
    tmp11 = (z11 - z13) * ((FAST_FLOAT) 1.414213562);

    z5 = (z10 + z12) * ((FAST_FLOAT) 1.847759065); /* 2*c2 */
    tmp10 = ((FAST_FLOAT) 1.082392200) * z12 - z5; /* 2*(c2-c6) */
    tmp12 = ((FAST_FLOAT) -2.613125930) * z10 + z5; /* -2*(c2+c6) */

    tmp6 = tmp12 - tmp7;
    tmp5 = tmp11 - tmp6;
    tmp4 = tmp10 + tmp5;

    /* Final output stage: scale down by a factor of 8 and range-limit */

    outptr[0] = range_limit[(int) DESCALE((INT32) (tmp0 + tmp7), 3)
			    & RANGE_MASK];
    outptr[7] = range_limit[(int) DESCALE((INT32) (tmp0 - tmp7), 3)
			    & RANGE_MASK];
    outptr[1] = range_limit[(int) DESCALE((INT32) (tmp1 + tmp6), 3)
			    & RANGE_MASK];
    outptr[6] = range_limit[(int) DESCALE((INT32) (tmp1 - tmp6), 3)
			    & RANGE_MASK];
    outptr[2] = range_limit[(int) DESCALE((INT32) (tmp2 + tmp5), 3)
			    & RANGE_MASK];
    outptr[5] = range_limit[(int) DESCALE((INT32) (tmp2 - tmp5), 3)
			    & RANGE_MASK];
    outptr[4] = range_limit[(int) DESCALE((INT32) (tmp3 + tmp4), 3)
			    & RANGE_MASK];
    outptr[3] = range_limit[(int) DESCALE((INT32) (tmp3 - tmp4), 3)
			    & RANGE_MASK];
    
    wsptr += DCTSIZE;		/* advance pointer to next row */
  }
}

#endif /* DCT_FLOAT_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jidctfst.c ===
/*
 * jidctfst.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains a fast, not so accurate integer implementation of the
 * inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
 * must also perform dequantization of the input coefficients.
 *
 * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
 * on each row (or vice versa, but it's more convenient to emit a row at
 * a time).  Direct algorithms are also available, but they are much more
 * complex and seem not to be any faster when reduced to code.
 *
 * This implementation is based on Arai, Agui, and Nakajima's algorithm for
 * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
 * Japanese, but the algorithm is described in the Pennebaker & Mitchell
 * JPEG textbook (see REFERENCES section in file README).  The following code
 * is based directly on figure 4-8 in P&M.
 * While an 8-point DCT cannot be done in less than 11 multiplies, it is
 * possible to arrange the computation so that many of the multiplies are
 * simple scalings of the final outputs.  These multiplies can then be
 * folded into the multiplications or divisions by the JPEG quantization
 * table entries.  The AA&N method leaves only 5 multiplies and 29 adds
 * to be done in the DCT itself.
 * The primary disadvantage of this method is that with fixed-point math,
 * accuracy is lost due to imprecise representation of the scaled
 * quantization values.  The smaller the quantization table entry, the less
 * precise the scaled value, so this implementation does worse with high-
 * quality-setting files than with low-quality ones.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"
#include "jdct.h"		/* Private declarations for DCT subsystem */

#ifdef DCT_IFAST_SUPPORTED


/*
 * This module is specialized to the case DCTSIZE = 8.
 */

#if DCTSIZE != 8
  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */
#endif


/* Scaling decisions are generally the same as in the LL&M algorithm;
 * see jidctint.c for more details.  However, we choose to descale
 * (right shift) multiplication products as soon as they are formed,
 * rather than carrying additional fractional bits into subsequent additions.
 * This compromises accuracy slightly, but it lets us save a few shifts.
 * More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)
 * everywhere except in the multiplications proper; this saves a good deal
 * of work on 16-bit-int machines.
 *
 * The dequantized coefficients are not integers because the AA&N scaling
 * factors have been incorporated.  We represent them scaled up by PASS1_BITS,
 * so that the first and second IDCT rounds have the same input scaling.
 * For 8-bit JSAMPLEs, we choose IFAST_SCALE_BITS = PASS1_BITS so as to
 * avoid a descaling shift; this compromises accuracy rather drastically
 * for small quantization table entries, but it saves a lot of shifts.
 * For 12-bit JSAMPLEs, there's no hope of using 16x16 multiplies anyway,
 * so we use a much larger scaling factor to preserve accuracy.
 *
 * A final compromise is to represent the multiplicative constants to only
 * 8 fractional bits, rather than 13.  This saves some shifting work on some
 * machines, and may also reduce the cost of multiplication (since there
 * are fewer one-bits in the constants).
 */

#if BITS_IN_JSAMPLE == 8
#define CONST_BITS  8
#define PASS1_BITS  2
#else
#define CONST_BITS  8
#define PASS1_BITS  1		/* lose a little precision to avoid overflow */
#endif

/* Some C compilers fail to reduce "FIX(constant)" at compile time, thus
 * causing a lot of useless floating-point operations at run time.
 * To get around this we use the following pre-calculated constants.
 * If you change CONST_BITS you may want to add appropriate values.
 * (With a reasonable C compiler, you can just rely on the FIX() macro...)
 */

#if CONST_BITS == 8
#define FIX_1_082392200  ((INT32)  277)		/* FIX(1.082392200) */
#define FIX_1_414213562  ((INT32)  362)		/* FIX(1.414213562) */
#define FIX_1_847759065  ((INT32)  473)		/* FIX(1.847759065) */
#define FIX_2_613125930  ((INT32)  669)		/* FIX(2.613125930) */
#else
#define FIX_1_082392200  FIX(1.082392200)
#define FIX_1_414213562  FIX(1.414213562)
#define FIX_1_847759065  FIX(1.847759065)
#define FIX_2_613125930  FIX(2.613125930)
#endif


/* We can gain a little more speed, with a further compromise in accuracy,
 * by omitting the addition in a descaling shift.  This yields an incorrectly
 * rounded result half the time...
 */

#ifndef USE_ACCURATE_ROUNDING
#undef DESCALE
#define DESCALE(x,n)  RIGHT_SHIFT(x, n)
#endif


/* Multiply a DCTELEM variable by an INT32 constant, and immediately
 * descale to yield a DCTELEM result.
 */

#define MULTIPLY(var,const)  ((DCTELEM) DESCALE((var) * (const), CONST_BITS))


/* Dequantize a coefficient by multiplying it by the multiplier-table
 * entry; produce a DCTELEM result.  For 8-bit data a 16x16->16
 * multiplication will do.  For 12-bit data, the multiplier table is
 * declared INT32, so a 32-bit multiply will be used.
 */

#if BITS_IN_JSAMPLE == 8
#define DEQUANTIZE(coef,quantval)  (((IFAST_MULT_TYPE) (coef)) * (quantval))
#else
#define DEQUANTIZE(coef,quantval)  \
	DESCALE((coef)*(quantval), IFAST_SCALE_BITS-PASS1_BITS)
#endif


/* Like DESCALE, but applies to a DCTELEM and produces an int.
 * We assume that int right shift is unsigned if INT32 right shift is.
 */

#ifdef RIGHT_SHIFT_IS_UNSIGNED
#define ISHIFT_TEMPS	DCTELEM ishift_temp;
#if BITS_IN_JSAMPLE == 8
#define DCTELEMBITS  16		/* DCTELEM may be 16 or 32 bits */
#else
#define DCTELEMBITS  32		/* DCTELEM must be 32 bits */
#endif
#define IRIGHT_SHIFT(x,shft)  \
    ((ishift_temp = (x)) < 0 ? \
     (ishift_temp >> (shft)) | ((~((DCTELEM) 0)) << (DCTELEMBITS-(shft))) : \
     (ishift_temp >> (shft)))
#else
#define ISHIFT_TEMPS
#define IRIGHT_SHIFT(x,shft)	((x) >> (shft))
#endif

#ifdef USE_ACCURATE_ROUNDING
#define IDESCALE(x,n)  ((int) IRIGHT_SHIFT((x) + (1 << ((n)-1)), n))
#else
#define IDESCALE(x,n)  ((int) IRIGHT_SHIFT(x, n))
#endif


/*
 * Perform dequantization and inverse DCT on one block of coefficients.
 */

GLOBAL(void)
jpeg_idct_ifast (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
  DCTELEM tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
  DCTELEM tmp10, tmp11, tmp12, tmp13;
  DCTELEM z5, z10, z11, z12, z13;
  JCOEFPTR inptr;
  IFAST_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
  int ctr;
  int workspace[DCTSIZE2];	/* buffers data between passes */
  SHIFT_TEMPS			/* for DESCALE */
  ISHIFT_TEMPS			/* for IDESCALE */

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
  quantptr = (IFAST_MULT_TYPE *) compptr->dct_table;
  wsptr = workspace;
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
    /* Due to quantization, we will usually find that many of the input
     * coefficients are zero, especially the AC terms.  We can exploit this
     * by short-circuiting the IDCT calculation for any column in which all
     * the AC terms are zero.  In that case each output is equal to the
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */
    
    if ((inptr[DCTSIZE*1] | inptr[DCTSIZE*2] | inptr[DCTSIZE*3] |
	 inptr[DCTSIZE*4] | inptr[DCTSIZE*5] | inptr[DCTSIZE*6] |
	 inptr[DCTSIZE*7]) == 0) {
      /* AC terms all zero */
      int dcval = (int) DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);

      wsptr[DCTSIZE*0] = dcval;
      wsptr[DCTSIZE*1] = dcval;
      wsptr[DCTSIZE*2] = dcval;
      wsptr[DCTSIZE*3] = dcval;
      wsptr[DCTSIZE*4] = dcval;
      wsptr[DCTSIZE*5] = dcval;
      wsptr[DCTSIZE*6] = dcval;
      wsptr[DCTSIZE*7] = dcval;
      
      inptr++;			/* advance pointers to next column */
      quantptr++;
      wsptr++;
      continue;
    }
    
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);

    tmp10 = tmp0 + tmp2;	/* phase 3 */
    tmp11 = tmp0 - tmp2;

    tmp13 = tmp1 + tmp3;	/* phases 5-3 */
    tmp12 = MULTIPLY(tmp1 - tmp3, FIX_1_414213562) - tmp13; /* 2*c4 */

    tmp0 = tmp10 + tmp13;	/* phase 2 */
    tmp3 = tmp10 - tmp13;
    tmp1 = tmp11 + tmp12;
    tmp2 = tmp11 - tmp12;
    
    /* Odd part */

    tmp4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
    tmp5 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
    tmp6 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
    tmp7 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);

    z13 = tmp6 + tmp5;		/* phase 6 */
    z10 = tmp6 - tmp5;
    z11 = tmp4 + tmp7;
    z12 = tmp4 - tmp7;

    tmp7 = z11 + z13;		/* phase 5 */
    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */

    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */
    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */
    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */

    tmp6 = tmp12 - tmp7;	/* phase 2 */
    tmp5 = tmp11 - tmp6;
    tmp4 = tmp10 + tmp5;

    wsptr[DCTSIZE*0] = (int) (tmp0 + tmp7);
    wsptr[DCTSIZE*7] = (int) (tmp0 - tmp7);
    wsptr[DCTSIZE*1] = (int) (tmp1 + tmp6);
    wsptr[DCTSIZE*6] = (int) (tmp1 - tmp6);
    wsptr[DCTSIZE*2] = (int) (tmp2 + tmp5);
    wsptr[DCTSIZE*5] = (int) (tmp2 - tmp5);
    wsptr[DCTSIZE*4] = (int) (tmp3 + tmp4);
    wsptr[DCTSIZE*3] = (int) (tmp3 - tmp4);

    inptr++;			/* advance pointers to next column */
    quantptr++;
    wsptr++;
  }
  
  /* Pass 2: process rows from work array, store into output array. */
  /* Note that we must descale the results by a factor of 8 == 2**3, */
  /* and also undo the PASS1_BITS scaling. */

  wsptr = workspace;
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
    outptr = output_buf[ctr] + output_col;
    /* Rows of zeroes can be exploited in the same way as we did with columns.
     * However, the column calculation has created many nonzero AC terms, so
     * the simplification applies less often (typically 5% to 10% of the time).
     * On machines with very fast multiplication, it's possible that the
     * test takes more time than it's worth.  In that case this section
     * may be commented out.
     */
    
#ifndef NO_ZERO_ROW_TEST
    if ((wsptr[1] | wsptr[2] | wsptr[3] | wsptr[4] | wsptr[5] | wsptr[6] |
	 wsptr[7]) == 0) {
      /* AC terms all zero */
      JSAMPLE dcval = range_limit[IDESCALE(wsptr[0], PASS1_BITS+3)
				  & RANGE_MASK];
      
      outptr[0] = dcval;
      outptr[1] = dcval;
      outptr[2] = dcval;
      outptr[3] = dcval;
      outptr[4] = dcval;
      outptr[5] = dcval;
      outptr[6] = dcval;
      outptr[7] = dcval;

      wsptr += DCTSIZE;		/* advance pointer to next row */
      continue;
    }
#endif
    
    /* Even part */

    tmp10 = ((DCTELEM) wsptr[0] + (DCTELEM) wsptr[4]);
    tmp11 = ((DCTELEM) wsptr[0] - (DCTELEM) wsptr[4]);

    tmp13 = ((DCTELEM) wsptr[2] + (DCTELEM) wsptr[6]);
    tmp12 = MULTIPLY((DCTELEM) wsptr[2] - (DCTELEM) wsptr[6], FIX_1_414213562)
	    - tmp13;

    tmp0 = tmp10 + tmp13;
    tmp3 = tmp10 - tmp13;
    tmp1 = tmp11 + tmp12;
    tmp2 = tmp11 - tmp12;

    /* Odd part */

    z13 = (DCTELEM) wsptr[5] + (DCTELEM) wsptr[3];
    z10 = (DCTELEM) wsptr[5] - (DCTELEM) wsptr[3];
    z11 = (DCTELEM) wsptr[1] + (DCTELEM) wsptr[7];
    z12 = (DCTELEM) wsptr[1] - (DCTELEM) wsptr[7];

    tmp7 = z11 + z13;		/* phase 5 */
    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */

    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */
    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */
    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */

    tmp6 = tmp12 - tmp7;	/* phase 2 */
    tmp5 = tmp11 - tmp6;
    tmp4 = tmp10 + tmp5;

    /* Final output stage: scale down by a factor of 8 and range-limit */

    outptr[0] = range_limit[IDESCALE(tmp0 + tmp7, PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[7] = range_limit[IDESCALE(tmp0 - tmp7, PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[1] = range_limit[IDESCALE(tmp1 + tmp6, PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[6] = range_limit[IDESCALE(tmp1 - tmp6, PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[2] = range_limit[IDESCALE(tmp2 + tmp5, PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[5] = range_limit[IDESCALE(tmp2 - tmp5, PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[4] = range_limit[IDESCALE(tmp3 + tmp4, PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[3] = range_limit[IDESCALE(tmp3 - tmp4, PASS1_BITS+3)
			    & RANGE_MASK];

    wsptr += DCTSIZE;		/* advance pointer to next row */
  }
}

#endif /* DCT_IFAST_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jidctint.c ===
/*
 * jidctint.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains a slow-but-accurate integer implementation of the
 * inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
 * must also perform dequantization of the input coefficients.
 *
 * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
 * on each row (or vice versa, but it's more convenient to emit a row at
 * a time).  Direct algorithms are also available, but they are much more
 * complex and seem not to be any faster when reduced to code.
 *
 * This implementation is based on an algorithm described in
 *   C. Loeffler, A. Ligtenberg and G. Moschytz, "Practical Fast 1-D DCT
 *   Algorithms with 11 Multiplications", Proc. Int'l. Conf. on Acoustics,
 *   Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.
 * The primary algorithm described there uses 11 multiplies and 29 adds.
 * We use their alternate method with 12 multiplies and 32 adds.
 * The advantage of this method is that no data path contains more than one
 * multiplication; this allows a very simple and accurate implementation in
 * scaled fixed-point arithmetic, with a minimal number of shifts.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"
#include "jdct.h"		/* Private declarations for DCT subsystem */

#ifdef DCT_ISLOW_SUPPORTED


/*
 * This module is specialized to the case DCTSIZE = 8.
 */

#if DCTSIZE != 8
  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */
#endif


/*
 * The poop on this scaling stuff is as follows:
 *
 * Each 1-D IDCT step produces outputs which are a factor of sqrt(N)
 * larger than the true IDCT outputs.  The final outputs are therefore
 * a factor of N larger than desired; since N=8 this can be cured by
 * a simple right shift at the end of the algorithm.  The advantage of
 * this arrangement is that we save two multiplications per 1-D IDCT,
 * because the y0 and y4 inputs need not be divided by sqrt(N).
 *
 * We have to do addition and subtraction of the integer inputs, which
 * is no problem, and multiplication by fractional constants, which is
 * a problem to do in integer arithmetic.  We multiply all the constants
 * by CONST_SCALE and convert them to integer constants (thus retaining
 * CONST_BITS bits of precision in the constants).  After doing a
 * multiplication we have to divide the product by CONST_SCALE, with proper
 * rounding, to produce the correct output.  This division can be done
 * cheaply as a right shift of CONST_BITS bits.  We postpone shifting
 * as long as possible so that partial sums can be added together with
 * full fractional precision.
 *
 * The outputs of the first pass are scaled up by PASS1_BITS bits so that
 * they are represented to better-than-integral precision.  These outputs
 * require BITS_IN_JSAMPLE + PASS1_BITS + 3 bits; this fits in a 16-bit word
 * with the recommended scaling.  (To scale up 12-bit sample data further, an
 * intermediate INT32 array would be needed.)
 *
 * To avoid overflow of the 32-bit intermediate results in pass 2, we must
 * have BITS_IN_JSAMPLE + CONST_BITS + PASS1_BITS <= 26.  Error analysis
 * shows that the values given below are the most effective.
 */

#if BITS_IN_JSAMPLE == 8
#define CONST_BITS  13
#define PASS1_BITS  2
#else
#define CONST_BITS  13
#define PASS1_BITS  1		/* lose a little precision to avoid overflow */
#endif

/* Some C compilers fail to reduce "FIX(constant)" at compile time, thus
 * causing a lot of useless floating-point operations at run time.
 * To get around this we use the following pre-calculated constants.
 * If you change CONST_BITS you may want to add appropriate values.
 * (With a reasonable C compiler, you can just rely on the FIX() macro...)
 */

#if CONST_BITS == 13
#define FIX_0_298631336  ((INT32)  2446)	/* FIX(0.298631336) */
#define FIX_0_390180644  ((INT32)  3196)	/* FIX(0.390180644) */
#define FIX_0_541196100  ((INT32)  4433)	/* FIX(0.541196100) */
#define FIX_0_765366865  ((INT32)  6270)	/* FIX(0.765366865) */
#define FIX_0_899976223  ((INT32)  7373)	/* FIX(0.899976223) */
#define FIX_1_175875602  ((INT32)  9633)	/* FIX(1.175875602) */
#define FIX_1_501321110  ((INT32)  12299)	/* FIX(1.501321110) */
#define FIX_1_847759065  ((INT32)  15137)	/* FIX(1.847759065) */
#define FIX_1_961570560  ((INT32)  16069)	/* FIX(1.961570560) */
#define FIX_2_053119869  ((INT32)  16819)	/* FIX(2.053119869) */
#define FIX_2_562915447  ((INT32)  20995)	/* FIX(2.562915447) */
#define FIX_3_072711026  ((INT32)  25172)	/* FIX(3.072711026) */
#else
#define FIX_0_298631336  FIX(0.298631336)
#define FIX_0_390180644  FIX(0.390180644)
#define FIX_0_541196100  FIX(0.541196100)
#define FIX_0_765366865  FIX(0.765366865)
#define FIX_0_899976223  FIX(0.899976223)
#define FIX_1_175875602  FIX(1.175875602)
#define FIX_1_501321110  FIX(1.501321110)
#define FIX_1_847759065  FIX(1.847759065)
#define FIX_1_961570560  FIX(1.961570560)
#define FIX_2_053119869  FIX(2.053119869)
#define FIX_2_562915447  FIX(2.562915447)
#define FIX_3_072711026  FIX(3.072711026)
#endif


/* Multiply an INT32 variable by an INT32 constant to yield an INT32 result.
 * For 8-bit samples with the recommended scaling, all the variable
 * and constant values involved are no more than 16 bits wide, so a
 * 16x16->32 bit multiply can be used instead of a full 32x32 multiply.
 * For 12-bit samples, a full 32-bit multiplication will be needed.
 */

#if BITS_IN_JSAMPLE == 8
#define MULTIPLY(var,const)  MULTIPLY16C16(var,const)
#else
#define MULTIPLY(var,const)  ((var) * (const))
#endif


/* Dequantize a coefficient by multiplying it by the multiplier-table
 * entry; produce an int result.  In this module, both inputs and result
 * are 16 bits or less, so either int or short multiply will work.
 */

#define DEQUANTIZE(coef,quantval)  (((ISLOW_MULT_TYPE) (coef)) * (quantval))


/*
 * Perform dequantization and inverse DCT on one block of coefficients.
 */

GLOBAL(void)
jpeg_idct_islow (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
  INT32 tmp0, tmp1, tmp2, tmp3;
  INT32 tmp10, tmp11, tmp12, tmp13;
  INT32 z1, z2, z3, z4, z5;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
  int ctr;
  int workspace[DCTSIZE2];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */
  /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
  /* furthermore, we scale the results by 2**PASS1_BITS. */

  inptr = coef_block;
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
  wsptr = workspace;
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
    /* Due to quantization, we will usually find that many of the input
     * coefficients are zero, especially the AC terms.  We can exploit this
     * by short-circuiting the IDCT calculation for any column in which all
     * the AC terms are zero.  In that case each output is equal to the
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */
    
    if ((inptr[DCTSIZE*1] | inptr[DCTSIZE*2] | inptr[DCTSIZE*3] |
	 inptr[DCTSIZE*4] | inptr[DCTSIZE*5] | inptr[DCTSIZE*6] |
	 inptr[DCTSIZE*7]) == 0) {
      /* AC terms all zero */
      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
      
      wsptr[DCTSIZE*0] = dcval;
      wsptr[DCTSIZE*1] = dcval;
      wsptr[DCTSIZE*2] = dcval;
      wsptr[DCTSIZE*3] = dcval;
      wsptr[DCTSIZE*4] = dcval;
      wsptr[DCTSIZE*5] = dcval;
      wsptr[DCTSIZE*6] = dcval;
      wsptr[DCTSIZE*7] = dcval;
      
      inptr++;			/* advance pointers to next column */
      quantptr++;
      wsptr++;
      continue;
    }
    
    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */
    
    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
    
    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
    tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
    tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
    
    z2 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);

    tmp0 = (z2 + z3) << CONST_BITS;
    tmp1 = (z2 - z3) << CONST_BITS;
    
    tmp10 = tmp0 + tmp3;
    tmp13 = tmp0 - tmp3;
    tmp11 = tmp1 + tmp2;
    tmp12 = tmp1 - tmp2;
    
    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */
    
    tmp0 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
    
    z1 = tmp0 + tmp3;
    z2 = tmp1 + tmp2;
    z3 = tmp0 + tmp2;
    z4 = tmp1 + tmp3;
    z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
    
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
    
    z3 += z5;
    z4 += z5;
    
    tmp0 += z1 + z3;
    tmp1 += z2 + z4;
    tmp2 += z2 + z3;
    tmp3 += z1 + z4;
    
    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
    
    wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
    wsptr[DCTSIZE*7] = (int) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
    wsptr[DCTSIZE*1] = (int) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
    wsptr[DCTSIZE*6] = (int) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
    wsptr[DCTSIZE*2] = (int) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
    wsptr[DCTSIZE*5] = (int) DESCALE(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
    wsptr[DCTSIZE*3] = (int) DESCALE(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
    wsptr[DCTSIZE*4] = (int) DESCALE(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
    
    inptr++;			/* advance pointers to next column */
    quantptr++;
    wsptr++;
  }
  
  /* Pass 2: process rows from work array, store into output array. */
  /* Note that we must descale the results by a factor of 8 == 2**3, */
  /* and also undo the PASS1_BITS scaling. */

  wsptr = workspace;
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
    outptr = output_buf[ctr] + output_col;
    /* Rows of zeroes can be exploited in the same way as we did with columns.
     * However, the column calculation has created many nonzero AC terms, so
     * the simplification applies less often (typically 5% to 10% of the time).
     * On machines with very fast multiplication, it's possible that the
     * test takes more time than it's worth.  In that case this section
     * may be commented out.
     */
    
#ifndef NO_ZERO_ROW_TEST
    if ((wsptr[1] | wsptr[2] | wsptr[3] | wsptr[4] | wsptr[5] | wsptr[6] |
	 wsptr[7]) == 0) {
      /* AC terms all zero */
      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
				  & RANGE_MASK];
      
      outptr[0] = dcval;
      outptr[1] = dcval;
      outptr[2] = dcval;
      outptr[3] = dcval;
      outptr[4] = dcval;
      outptr[5] = dcval;
      outptr[6] = dcval;
      outptr[7] = dcval;

      wsptr += DCTSIZE;		/* advance pointer to next row */
      continue;
    }
#endif
    
    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */
    
    z2 = (INT32) wsptr[2];
    z3 = (INT32) wsptr[6];
    
    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
    tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
    tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
    
    tmp0 = ((INT32) wsptr[0] + (INT32) wsptr[4]) << CONST_BITS;
    tmp1 = ((INT32) wsptr[0] - (INT32) wsptr[4]) << CONST_BITS;
    
    tmp10 = tmp0 + tmp3;
    tmp13 = tmp0 - tmp3;
    tmp11 = tmp1 + tmp2;
    tmp12 = tmp1 - tmp2;
    
    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */
    
    tmp0 = (INT32) wsptr[7];
    tmp1 = (INT32) wsptr[5];
    tmp2 = (INT32) wsptr[3];
    tmp3 = (INT32) wsptr[1];
    
    z1 = tmp0 + tmp3;
    z2 = tmp1 + tmp2;
    z3 = tmp0 + tmp2;
    z4 = tmp1 + tmp3;
    z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
    
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
    
    z3 += z5;
    z4 += z5;
    
    tmp0 += z1 + z3;
    tmp1 += z2 + z4;
    tmp2 += z2 + z3;
    tmp3 += z1 + z4;
    
    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
    
    outptr[0] = range_limit[(int) DESCALE(tmp10 + tmp3,
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[7] = range_limit[(int) DESCALE(tmp10 - tmp3,
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[1] = range_limit[(int) DESCALE(tmp11 + tmp2,
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[6] = range_limit[(int) DESCALE(tmp11 - tmp2,
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[2] = range_limit[(int) DESCALE(tmp12 + tmp1,
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[5] = range_limit[(int) DESCALE(tmp12 - tmp1,
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[3] = range_limit[(int) DESCALE(tmp13 + tmp0,
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[4] = range_limit[(int) DESCALE(tmp13 - tmp0,
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    
    wsptr += DCTSIZE;		/* advance pointer to next row */
  }
}

#endif /* DCT_ISLOW_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jmemwin.c ===
/*
 * jmemansi.c
 *
 * Copyright (C) 1992-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file provides a simple generic implementation of the system-
 * dependent portion of the JPEG memory manager.  This implementation
 * assumes that you have the ANSI-standard library routine tmpfile().
 * Also, the problem of determining the amount of memory available
 * is shoved onto the user.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"
#include "jmemsys.h"		/* import the system-dependent declarations */

void *AllocMem(size_t cb);
void FreeMem(void *);

#ifndef HAVE_STDLIB_H		/* <stdlib.h> should declare malloc(),free() */
extern void * malloc JPP((size_t size));
extern void free JPP((void *ptr));
#endif

#ifndef SEEK_SET		/* pre-ANSI systems may not define this; */
#define SEEK_SET  0		/* if not, assume 0 is correct */
#endif


/*
 * Memory allocation and freeing are controlled by the regular library
 * routines malloc() and free().
 */

GLOBAL(void *)
jpeg_get_small (j_common_ptr cinfo, size_t sizeofobject)
{
  return (void *) AllocMem(sizeofobject);
}

GLOBAL(void)
jpeg_free_small (j_common_ptr cinfo, void * object, size_t sizeofobject)
{
  FreeMem(object);
}


/*
 * "Large" objects are treated the same as "small" ones.
 * NB: although we include FAR keywords in the routine declarations,
 * this file won't actually work in 80x86 small/medium model; at least,
 * you probably won't be able to process useful-size images in only 64KB.
 */

GLOBAL(void FAR *)
jpeg_get_large (j_common_ptr cinfo, size_t sizeofobject)
{
  return (void FAR *) AllocMem(sizeofobject);
}

GLOBAL(void)
jpeg_free_large (j_common_ptr cinfo, void FAR * object, size_t sizeofobject)
{
  FreeMem(object);
}


/*
 * This routine computes the total memory space available for allocation.
 * It's impossible to do this in a portable way; our current solution is
 * to make the user tell us (with a default value set at compile time).
 * If you can actually get the available space, it's a good idea to subtract
 * a slop factor of 5% or so.
 */

#ifndef DEFAULT_MAX_MEM		/* so can override from makefile */
#define DEFAULT_MAX_MEM		1000000L /* default: one megabyte */
#endif

GLOBAL(long)
jpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed,
		    long max_bytes_needed, long already_allocated)
{
  return cinfo->mem->max_memory_to_use - already_allocated;
}



/*
 * These routines take care of any system-dependent initialization and
 * cleanup required.
 */

GLOBAL(long)
jpeg_mem_init (j_common_ptr cinfo)
{
  return DEFAULT_MAX_MEM;	/* default for max_memory_to_use */
}

GLOBAL(void)
jpeg_mem_term (j_common_ptr cinfo)
{
  /* no work */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jpegdata.cpp ===
#include "JPEGData.h"

void CJPEGDatasource::Create (
	j_decompress_ptr cinfo)
{

	m_dataSource.sourceMgr.next_input_byte = 0;
	m_dataSource.sourceMgr.bytes_in_buffer = 0;
	
	m_dataSource.sourceMgr.init_source = CJPEGDatasource::InitSourceEntry;
	m_dataSource.sourceMgr.fill_input_buffer = CJPEGDatasource::FillInputBufferEntry;
	m_dataSource.sourceMgr.skip_input_data = CJPEGDatasource::SkipInputDataEntry;
	m_dataSource.sourceMgr.resync_to_restart = CJPEGDatasource::ResyncToRestartEntry;
	m_dataSource.sourceMgr.term_source = CJPEGDatasource::TermSourceEntry;

	m_dataSource.dataSource = this;
	cinfo->src = (struct jpeg_source_mgr *) &m_dataSource;
}

boolean CJPEGDatasource::ResyncToRestart (j_decompress_ptr cinfo, int desired)
{
	return (jpeg_resync_to_restart (cinfo, desired));
}

void CJPEGDatasource::InitSourceEntry (
	j_decompress_ptr cinfo)
{
	CJPEGDatasource* dataSource = cinfo ? ((jpeg_source_ptr) cinfo-> src)-> dataSource : 0;
	if (dataSource)
		dataSource-> InitSource (cinfo);
}

boolean CJPEGDatasource::FillInputBufferEntry (
	j_decompress_ptr cinfo)
{
	CJPEGDatasource* dataSource = cinfo ? ((jpeg_source_ptr) cinfo-> src)-> dataSource : 0;
	return (dataSource ? dataSource-> FillInputBuffer (cinfo) : FALSE);
}

void CJPEGDatasource::SkipInputDataEntry (
	j_decompress_ptr cinfo,
	long num_bytes)
{
	CJPEGDatasource* dataSource = cinfo ? ((jpeg_source_ptr) cinfo-> src)-> dataSource : 0;
	if (dataSource)
		dataSource-> SkipInputData (cinfo, num_bytes);
}

boolean CJPEGDatasource::ResyncToRestartEntry (
	j_decompress_ptr cinfo,
	int desired)
{
	CJPEGDatasource* dataSource = cinfo ? ((jpeg_source_ptr) cinfo-> src)-> dataSource : 0;
	return (dataSource ? dataSource-> ResyncToRestart (cinfo, desired) : FALSE);
}

void CJPEGDatasource::TermSourceEntry (
	j_decompress_ptr cinfo)
{
	CJPEGDatasource* dataSource = cinfo ? ((jpeg_source_ptr) cinfo-> src)-> dataSource : 0;
	if (dataSource)
		dataSource-> TermSource (cinfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jidctred.c ===
/*
 * jidctred.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains inverse-DCT routines that produce reduced-size output:
 * either 4x4, 2x2, or 1x1 pixels from an 8x8 DCT block.
 *
 * The implementation is based on the Loeffler, Ligtenberg and Moschytz (LL&M)
 * algorithm used in jidctint.c.  We simply replace each 8-to-8 1-D IDCT step
 * with an 8-to-4 step that produces the four averages of two adjacent outputs
 * (or an 8-to-2 step producing two averages of four outputs, for 2x2 output).
 * These steps were derived by computing the corresponding values at the end
 * of the normal LL&M code, then simplifying as much as possible.
 *
 * 1x1 is trivial: just take the DC coefficient divided by 8.
 *
 * See jidctint.c for additional comments.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"
#include "jdct.h"		/* Private declarations for DCT subsystem */

#ifdef IDCT_SCALING_SUPPORTED


/*
 * This module is specialized to the case DCTSIZE = 8.
 */

#if DCTSIZE != 8
  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */
#endif


/* Scaling is the same as in jidctint.c. */

#if BITS_IN_JSAMPLE == 8
#define CONST_BITS  13
#define PASS1_BITS  2
#else
#define CONST_BITS  13
#define PASS1_BITS  1		/* lose a little precision to avoid overflow */
#endif

/* Some C compilers fail to reduce "FIX(constant)" at compile time, thus
 * causing a lot of useless floating-point operations at run time.
 * To get around this we use the following pre-calculated constants.
 * If you change CONST_BITS you may want to add appropriate values.
 * (With a reasonable C compiler, you can just rely on the FIX() macro...)
 */

#if CONST_BITS == 13
#define FIX_0_211164243  ((INT32)  1730)	/* FIX(0.211164243) */
#define FIX_0_509795579  ((INT32)  4176)	/* FIX(0.509795579) */
#define FIX_0_601344887  ((INT32)  4926)	/* FIX(0.601344887) */
#define FIX_0_720959822  ((INT32)  5906)	/* FIX(0.720959822) */
#define FIX_0_765366865  ((INT32)  6270)	/* FIX(0.765366865) */
#define FIX_0_850430095  ((INT32)  6967)	/* FIX(0.850430095) */
#define FIX_0_899976223  ((INT32)  7373)	/* FIX(0.899976223) */
#define FIX_1_061594337  ((INT32)  8697)	/* FIX(1.061594337) */
#define FIX_1_272758580  ((INT32)  10426)	/* FIX(1.272758580) */
#define FIX_1_451774981  ((INT32)  11893)	/* FIX(1.451774981) */
#define FIX_1_847759065  ((INT32)  15137)	/* FIX(1.847759065) */
#define FIX_2_172734803  ((INT32)  17799)	/* FIX(2.172734803) */
#define FIX_2_562915447  ((INT32)  20995)	/* FIX(2.562915447) */
#define FIX_3_624509785  ((INT32)  29692)	/* FIX(3.624509785) */
#else
#define FIX_0_211164243  FIX(0.211164243)
#define FIX_0_509795579  FIX(0.509795579)
#define FIX_0_601344887  FIX(0.601344887)
#define FIX_0_720959822  FIX(0.720959822)
#define FIX_0_765366865  FIX(0.765366865)
#define FIX_0_850430095  FIX(0.850430095)
#define FIX_0_899976223  FIX(0.899976223)
#define FIX_1_061594337  FIX(1.061594337)
#define FIX_1_272758580  FIX(1.272758580)
#define FIX_1_451774981  FIX(1.451774981)
#define FIX_1_847759065  FIX(1.847759065)
#define FIX_2_172734803  FIX(2.172734803)
#define FIX_2_562915447  FIX(2.562915447)
#define FIX_3_624509785  FIX(3.624509785)
#endif


/* Multiply an INT32 variable by an INT32 constant to yield an INT32 result.
 * For 8-bit samples with the recommended scaling, all the variable
 * and constant values involved are no more than 16 bits wide, so a
 * 16x16->32 bit multiply can be used instead of a full 32x32 multiply.
 * For 12-bit samples, a full 32-bit multiplication will be needed.
 */

#if BITS_IN_JSAMPLE == 8
#define MULTIPLY(var,const)  MULTIPLY16C16(var,const)
#else
#define MULTIPLY(var,const)  ((var) * (const))
#endif


/* Dequantize a coefficient by multiplying it by the multiplier-table
 * entry; produce an int result.  In this module, both inputs and result
 * are 16 bits or less, so either int or short multiply will work.
 */

#define DEQUANTIZE(coef,quantval)  (((ISLOW_MULT_TYPE) (coef)) * (quantval))


/*
 * Perform dequantization and inverse DCT on one block of coefficients,
 * producing a reduced-size 4x4 output block.
 */

GLOBAL(void)
jpeg_idct_4x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
  INT32 tmp0, tmp2, tmp10, tmp12;
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
  int ctr;
  int workspace[DCTSIZE*4];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
  wsptr = workspace;
  for (ctr = DCTSIZE; ctr > 0; inptr++, quantptr++, wsptr++, ctr--) {
    /* Don't bother to process column 4, because second pass won't use it */
    if (ctr == DCTSIZE-4)
      continue;
    if ((inptr[DCTSIZE*1] | inptr[DCTSIZE*2] | inptr[DCTSIZE*3] |
	 inptr[DCTSIZE*5] | inptr[DCTSIZE*6] | inptr[DCTSIZE*7]) == 0) {
      /* AC terms all zero; we need not examine term 4 for 4x4 output */
      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
      
      wsptr[DCTSIZE*0] = dcval;
      wsptr[DCTSIZE*1] = dcval;
      wsptr[DCTSIZE*2] = dcval;
      wsptr[DCTSIZE*3] = dcval;
      
      continue;
    }
    
    /* Even part */
    
    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
    tmp0 <<= (CONST_BITS+1);
    
    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);

    tmp2 = MULTIPLY(z2, FIX_1_847759065) + MULTIPLY(z3, - FIX_0_765366865);
    
    tmp10 = tmp0 + tmp2;
    tmp12 = tmp0 - tmp2;
    
    /* Odd part */
    
    z1 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
    z2 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
    z4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
    
    tmp0 = MULTIPLY(z1, - FIX_0_211164243) /* sqrt(2) * (c3-c1) */
	 + MULTIPLY(z2, FIX_1_451774981) /* sqrt(2) * (c3+c7) */
	 + MULTIPLY(z3, - FIX_2_172734803) /* sqrt(2) * (-c1-c5) */
	 + MULTIPLY(z4, FIX_1_061594337); /* sqrt(2) * (c5+c7) */
    
    tmp2 = MULTIPLY(z1, - FIX_0_509795579) /* sqrt(2) * (c7-c5) */
	 + MULTIPLY(z2, - FIX_0_601344887) /* sqrt(2) * (c5-c1) */
	 + MULTIPLY(z3, FIX_0_899976223) /* sqrt(2) * (c3-c7) */
	 + MULTIPLY(z4, FIX_2_562915447); /* sqrt(2) * (c1+c3) */

    /* Final output stage */
    
    wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp2, CONST_BITS-PASS1_BITS+1);
    wsptr[DCTSIZE*3] = (int) DESCALE(tmp10 - tmp2, CONST_BITS-PASS1_BITS+1);
    wsptr[DCTSIZE*1] = (int) DESCALE(tmp12 + tmp0, CONST_BITS-PASS1_BITS+1);
    wsptr[DCTSIZE*2] = (int) DESCALE(tmp12 - tmp0, CONST_BITS-PASS1_BITS+1);
  }
  
  /* Pass 2: process 4 rows from work array, store into output array. */

  wsptr = workspace;
  for (ctr = 0; ctr < 4; ctr++) {
    outptr = output_buf[ctr] + output_col;
    /* It's not clear whether a zero row test is worthwhile here ... */

#ifndef NO_ZERO_ROW_TEST
    if ((wsptr[1] | wsptr[2] | wsptr[3] | wsptr[5] | wsptr[6] |
	 wsptr[7]) == 0) {
      /* AC terms all zero */
      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
				  & RANGE_MASK];
      
      outptr[0] = dcval;
      outptr[1] = dcval;
      outptr[2] = dcval;
      outptr[3] = dcval;
      
      wsptr += DCTSIZE;		/* advance pointer to next row */
      continue;
    }
#endif
    
    /* Even part */
    
    tmp0 = ((INT32) wsptr[0]) << (CONST_BITS+1);
    
    tmp2 = MULTIPLY((INT32) wsptr[2], FIX_1_847759065)
	 + MULTIPLY((INT32) wsptr[6], - FIX_0_765366865);
    
    tmp10 = tmp0 + tmp2;
    tmp12 = tmp0 - tmp2;
    
    /* Odd part */
    
    z1 = (INT32) wsptr[7];
    z2 = (INT32) wsptr[5];
    z3 = (INT32) wsptr[3];
    z4 = (INT32) wsptr[1];
    
    tmp0 = MULTIPLY(z1, - FIX_0_211164243) /* sqrt(2) * (c3-c1) */
	 + MULTIPLY(z2, FIX_1_451774981) /* sqrt(2) * (c3+c7) */
	 + MULTIPLY(z3, - FIX_2_172734803) /* sqrt(2) * (-c1-c5) */
	 + MULTIPLY(z4, FIX_1_061594337); /* sqrt(2) * (c5+c7) */
    
    tmp2 = MULTIPLY(z1, - FIX_0_509795579) /* sqrt(2) * (c7-c5) */
	 + MULTIPLY(z2, - FIX_0_601344887) /* sqrt(2) * (c5-c1) */
	 + MULTIPLY(z3, FIX_0_899976223) /* sqrt(2) * (c3-c7) */
	 + MULTIPLY(z4, FIX_2_562915447); /* sqrt(2) * (c1+c3) */

    /* Final output stage */
    
    outptr[0] = range_limit[(int) DESCALE(tmp10 + tmp2,
					  CONST_BITS+PASS1_BITS+3+1)
			    & RANGE_MASK];
    outptr[3] = range_limit[(int) DESCALE(tmp10 - tmp2,
					  CONST_BITS+PASS1_BITS+3+1)
			    & RANGE_MASK];
    outptr[1] = range_limit[(int) DESCALE(tmp12 + tmp0,
					  CONST_BITS+PASS1_BITS+3+1)
			    & RANGE_MASK];
    outptr[2] = range_limit[(int) DESCALE(tmp12 - tmp0,
					  CONST_BITS+PASS1_BITS+3+1)
			    & RANGE_MASK];
    
    wsptr += DCTSIZE;		/* advance pointer to next row */
  }
}


/*
 * Perform dequantization and inverse DCT on one block of coefficients,
 * producing a reduced-size 2x2 output block.
 */

GLOBAL(void)
jpeg_idct_2x2 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
  INT32 tmp0, tmp10, z1;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
  int ctr;
  int workspace[DCTSIZE*2];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
  wsptr = workspace;
  for (ctr = DCTSIZE; ctr > 0; inptr++, quantptr++, wsptr++, ctr--) {
    /* Don't bother to process columns 2,4,6 */
    if (ctr == DCTSIZE-2 || ctr == DCTSIZE-4 || ctr == DCTSIZE-6)
      continue;
    if ((inptr[DCTSIZE*1] | inptr[DCTSIZE*3] |
	 inptr[DCTSIZE*5] | inptr[DCTSIZE*7]) == 0) {
      /* AC terms all zero; we need not examine terms 2,4,6 for 2x2 output */
      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
      
      wsptr[DCTSIZE*0] = dcval;
      wsptr[DCTSIZE*1] = dcval;
      
      continue;
    }
    
    /* Even part */
    
    z1 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
    tmp10 = z1 << (CONST_BITS+2);
    
    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
    tmp0 = MULTIPLY(z1, - FIX_0_720959822); /* sqrt(2) * (c7-c5+c3-c1) */
    z1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
    tmp0 += MULTIPLY(z1, FIX_0_850430095); /* sqrt(2) * (-c1+c3+c5+c7) */
    z1 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
    tmp0 += MULTIPLY(z1, - FIX_1_272758580); /* sqrt(2) * (-c1+c3-c5-c7) */
    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
    tmp0 += MULTIPLY(z1, FIX_3_624509785); /* sqrt(2) * (c1+c3+c5+c7) */

    /* Final output stage */
    
    wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp0, CONST_BITS-PASS1_BITS+2);
    wsptr[DCTSIZE*1] = (int) DESCALE(tmp10 - tmp0, CONST_BITS-PASS1_BITS+2);
  }
  
  /* Pass 2: process 2 rows from work array, store into output array. */

  wsptr = workspace;
  for (ctr = 0; ctr < 2; ctr++) {
    outptr = output_buf[ctr] + output_col;
    /* It's not clear whether a zero row test is worthwhile here ... */

#ifndef NO_ZERO_ROW_TEST
    if ((wsptr[1] | wsptr[3] | wsptr[5] | wsptr[7]) == 0) {
      /* AC terms all zero */
      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
				  & RANGE_MASK];
      
      outptr[0] = dcval;
      outptr[1] = dcval;
      
      wsptr += DCTSIZE;		/* advance pointer to next row */
      continue;
    }
#endif
    
    /* Even part */
    
    tmp10 = ((INT32) wsptr[0]) << (CONST_BITS+2);
    
    /* Odd part */

    tmp0 = MULTIPLY((INT32) wsptr[7], - FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */
	 + MULTIPLY((INT32) wsptr[5], FIX_0_850430095) /* sqrt(2) * (-c1+c3+c5+c7) */
	 + MULTIPLY((INT32) wsptr[3], - FIX_1_272758580) /* sqrt(2) * (-c1+c3-c5-c7) */
	 + MULTIPLY((INT32) wsptr[1], FIX_3_624509785); /* sqrt(2) * (c1+c3+c5+c7) */

    /* Final output stage */
    
    outptr[0] = range_limit[(int) DESCALE(tmp10 + tmp0,
					  CONST_BITS+PASS1_BITS+3+2)
			    & RANGE_MASK];
    outptr[1] = range_limit[(int) DESCALE(tmp10 - tmp0,
					  CONST_BITS+PASS1_BITS+3+2)
			    & RANGE_MASK];
    
    wsptr += DCTSIZE;		/* advance pointer to next row */
  }
}


/*
 * Perform dequantization and inverse DCT on one block of coefficients,
 * producing a reduced-size 1x1 output block.
 */

GLOBAL(void)
jpeg_idct_1x1 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
  int dcval;
  ISLOW_MULT_TYPE * quantptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
  SHIFT_TEMPS

  /* We hardly need an inverse DCT routine for this: just take the
   * average pixel value, which is one-eighth of the DC coefficient.
   */
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
  dcval = DEQUANTIZE(coef_block[0], quantptr[0]);
  dcval = (int) DESCALE((INT32) dcval, 3);

  output_buf[0][output_col] = range_limit[dcval & RANGE_MASK];
}

#endif /* IDCT_SCALING_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jpegdeco.cpp ===
#include "JPEGDeco.h"
#include "JPEGData.h"

extern "C"{
#include "jerror.h"
}

CJPEGDecompressor::CJPEGDecompressor ()
{	
}

CJPEGDecompressor::~CJPEGDecompressor ()
{
}

void CJPEGDecompressor::Init (
	CJPEGDatasource* dataSource)
{
	m_archive.archive = this;
	m_archive.cinfo.err = jpeg_std_error(&m_jErr);
  	m_jErr.error_exit = CJPEGDecompressor::ErrorExitEntry;
  	m_jErr.emit_message = CJPEGDecompressor::EmitMessageEntry;
  	m_jErr.output_message = CJPEGDecompressor::OutputMessageEntry;
  	m_jErr.format_message = CJPEGDecompressor::FormatMessageEntry;
  	m_jErr.reset_error_mgr = CJPEGDecompressor::ResetErrorManagerEntry;

	jpeg_create_decompress (&m_archive.cinfo);
	dataSource-> Create (&m_archive.cinfo);

  	m_dataSource = dataSource;
}

void CJPEGDecompressor::Terminate ()
{
	jpeg_destroy_decompress (&m_archive.cinfo);
}

boolean CJPEGDecompressor::Decompress (
	CJPEGDatasource* dataSource)
{
	boolean result = FALSE;

	JSAMPARRAY buffer;		/* Output row buffer */
	int row_stride;			/* physical row width in output buffer */
	
	try
	{
		Init (dataSource);
		(void) jpeg_read_header (&m_archive.cinfo, TRUE);
		BuildColorMap ();
		(void) jpeg_start_decompress (&m_archive.cinfo);
		BeginDecompression ();

		row_stride = m_archive.cinfo.output_width * m_archive.cinfo.output_components;
		buffer = (*m_archive.cinfo.mem->alloc_sarray)((j_common_ptr) &m_archive.cinfo, JPOOL_IMAGE, row_stride, 1);
		while (m_archive.cinfo.output_scanline < m_archive.cinfo.output_height)
		{
			(void) jpeg_read_scanlines (&m_archive.cinfo, buffer, 1);
			StoreScanline (buffer[0], m_archive.cinfo.output_scanline);
		}

		EndDecompression ();
		(void) jpeg_finish_decompress (&m_archive.cinfo);
		Terminate ();
		result = TRUE;
	}
	
	catch (...)
	{
	}
	
  	return (result);
}

void CJPEGDecompressor::ErrorExitEntry (
	j_common_ptr cinfo)
{
	CJPEGDecompressor* archive = cinfo ? ((jpeg_archive_ptr) cinfo)-> archive : 0;
	if (archive)
		archive-> ErrorExit ();
	throw FALSE;
}

void CJPEGDecompressor::EmitMessageEntry (
	j_common_ptr cinfo, 
	int msg_level)
{
	CJPEGDecompressor* archive = cinfo ? ((jpeg_archive_ptr) cinfo)-> archive : 0;
	if (archive)
		archive-> EmitMessage (msg_level);
}

void CJPEGDecompressor::OutputMessageEntry (
	j_common_ptr cinfo)
{
	CJPEGDecompressor* archive = cinfo ? ((jpeg_archive_ptr) cinfo)-> archive : 0;
	if (archive)
		archive-> OutputMessage ();
}

void CJPEGDecompressor::FormatMessageEntry (
	j_common_ptr cinfo,
	char* buffer)
{
	CJPEGDecompressor* archive = cinfo ? ((jpeg_archive_ptr) cinfo)-> archive : 0;
	if (archive)
		archive-> FormatMessage (buffer);
}

void CJPEGDecompressor::ResetErrorManagerEntry (
	j_common_ptr cinfo)
{
	CJPEGDecompressor* archive = cinfo ? ((jpeg_archive_ptr) cinfo)-> archive : 0;
	if (archive)
		archive-> ResetErrorManager ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\sources.inc ===
TARGETNAME=
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=NOTARGET
TARGETLIBS=
USE_NATIVE_EH=1

INCLUDES=$(INCLUDES);..\..\jpeginc;$(INC_DIR);$(TOOLS_INC_DIR)

SOURCES=darwjpeg.cpp \
	jpegdata.cpp \
	jpegdeco.cpp \
	jdapimin.c \
	jdapistd.c \
	jcomapi.c \
	jcparam.c \
	jdmaster.c \
	jdinput.c \
	jdmainct.c \
	jdcoefct.c \
	jdpostct.c \
	jdmarker.c \
	jdhuff.c \
	jdphuff.c \
	jddctmgr.c \
	jidctint.c \
	jidctfst.c \
	jidctflt.c \
	jidctred.c \
	jdsample.c \
	jdcolor.c \
	jdmerge.c \
	jquant1.c \
	jquant2.c \
	jerror.c \
	dmemmgr.c \
	jutils.c \
	jmemwin.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jutils.c ===
/*
 * jutils.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains tables and miscellaneous utility routines needed
 * for both compression and decompression.
 * Note we prefix all global names with "j" to minimize conflicts with
 * a surrounding application.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/*
 * jpeg_zigzag_order[i] is the zigzag-order position of the i'th element
 * of a DCT block read in natural order (left to right, top to bottom).
 */

#if 0				/* This table is not actually needed in v6a */

const int jpeg_zigzag_order[DCTSIZE2] = {
   0,  1,  5,  6, 14, 15, 27, 28,
   2,  4,  7, 13, 16, 26, 29, 42,
   3,  8, 12, 17, 25, 30, 41, 43,
   9, 11, 18, 24, 31, 40, 44, 53,
  10, 19, 23, 32, 39, 45, 52, 54,
  20, 22, 33, 38, 46, 51, 55, 60,
  21, 34, 37, 47, 50, 56, 59, 61,
  35, 36, 48, 49, 57, 58, 62, 63
};

#endif

/*
 * jpeg_natural_order[i] is the natural-order position of the i'th element
 * of zigzag order.
 *
 * When reading corrupted data, the Huffman decoders could attempt
 * to reference an entry beyond the end of this array (if the decoded
 * zero run length reaches past the end of the block).  To prevent
 * wild stores without adding an inner-loop test, we put some extra
 * "63"s after the real entries.  This will cause the extra coefficient
 * to be stored in location 63 of the block, not somewhere random.
 * The worst case would be a run-length of 15, which means we need 16
 * fake entries.
 */

const int jpeg_natural_order[DCTSIZE2+16] = {
  0,  1,  8, 16,  9,  2,  3, 10,
 17, 24, 32, 25, 18, 11,  4,  5,
 12, 19, 26, 33, 40, 48, 41, 34,
 27, 20, 13,  6,  7, 14, 21, 28,
 35, 42, 49, 56, 57, 50, 43, 36,
 29, 22, 15, 23, 30, 37, 44, 51,
 58, 59, 52, 45, 38, 31, 39, 46,
 53, 60, 61, 54, 47, 55, 62, 63,
 63, 63, 63, 63, 63, 63, 63, 63, /* extra entries for safety in decoder */
 63, 63, 63, 63, 63, 63, 63, 63
};


/*
 * Arithmetic utilities
 */

GLOBAL(long)
jdiv_round_up (long a, long b)
/* Compute a/b rounded up to next integer, ie, ceil(a/b) */
/* Assumes a >= 0, b > 0 */
{
  return (a + b - 1L) / b;
}


GLOBAL(long)
jround_up (long a, long b)
/* Compute a rounded up to next multiple of b, ie, ceil(a/b)*b */
/* Assumes a >= 0, b > 0 */
{
  a += b - 1L;
  return a - (a % b);
}


/* On normal machines we can apply MEMCOPY() and MEMZERO() to sample arrays
 * and coefficient-block arrays.  This won't work on 80x86 because the arrays
 * are FAR and we're assuming a small-pointer memory model.  However, some
 * DOS compilers provide far-pointer versions of memcpy() and memset() even
 * in the small-model libraries.  These will be used if USE_FMEM is defined.
 * Otherwise, the routines below do it the hard way.  (The performance cost
 * is not all that great, because these routines aren't very heavily used.)
 */

#ifndef NEED_FAR_POINTERS	/* normal case, same as regular macros */
#define FMEMCOPY(dest,src,size)	MEMCOPY(dest,src,size)
#define FMEMZERO(target,size)	MEMZERO(target,size)
#else				/* 80x86 case, define if we can */
#ifdef USE_FMEM
#define FMEMCOPY(dest,src,size)	_fmemcpy((void FAR *)(dest), (const void FAR *)(src), (size_t)(size))
#define FMEMZERO(target,size)	_fmemset((void FAR *)(target), 0, (size_t)(size))
#endif
#endif


GLOBAL(void)
jcopy_sample_rows (JSAMPARRAY input_array, int source_row,
		   JSAMPARRAY output_array, int dest_row,
		   int num_rows, JDIMENSION num_cols)
/* Copy some rows of samples from one place to another.
 * num_rows rows are copied from input_array[source_row++]
 * to output_array[dest_row++]; these areas may overlap for duplication.
 * The source and destination arrays must be at least as wide as num_cols.
 */
{
  register JSAMPROW inptr, outptr;
#ifdef FMEMCOPY
  register size_t count = (size_t) (num_cols * SIZEOF(JSAMPLE));
#else
  register JDIMENSION count;
#endif
  register int row;

  input_array += source_row;
  output_array += dest_row;

  for (row = num_rows; row > 0; row--) {
    inptr = *input_array++;
    outptr = *output_array++;
#ifdef FMEMCOPY
    FMEMCOPY(outptr, inptr, count);
#else
    for (count = num_cols; count > 0; count--)
      *outptr++ = *inptr++;	/* needn't bother with GETJSAMPLE() here */
#endif
  }
}


GLOBAL(void)
jcopy_block_row (JBLOCKROW input_row, JBLOCKROW output_row,
		 JDIMENSION num_blocks)
/* Copy a row of coefficient blocks from one place to another. */
{
#ifdef FMEMCOPY
  FMEMCOPY(output_row, input_row, num_blocks * (DCTSIZE2 * SIZEOF(JCOEF)));
#else
  register JCOEFPTR inptr, outptr;
  register long count;

  inptr = (JCOEFPTR) input_row;
  outptr = (JCOEFPTR) output_row;
  for (count = (long) num_blocks * DCTSIZE2; count > 0; count--) {
    *outptr++ = *inptr++;
  }
#endif
}


GLOBAL(void)
jzero_far (void FAR * target, size_t bytestozero)
/* Zero out a chunk of FAR memory. */
/* This might be sample-array data, block-array data, or alloc_large data. */
{
#ifdef FMEMZERO
  FMEMZERO(target, bytestozero);
#else
  register char FAR * ptr = (char FAR *) target;
  register size_t count;

  for (count = bytestozero; count > 0; count--) {
    *ptr++ = 0;
  }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jquant2.c ===
/*
 * jquant2.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains 2-pass color quantization (color mapping) routines.
 * These routines provide selection of a custom color map for an image,
 * followed by mapping of the image to that color map, with optional
 * Floyd-Steinberg dithering.
 * It is also possible to use just the second pass to map to an arbitrary
 * externally-given color map.
 *
 * Note: ordered dithering is not supported, since there isn't any fast
 * way to compute intercolor distances; it's unclear that ordered dither's
 * fundamental assumptions even hold with an irregularly spaced color map.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"

#ifdef QUANT_2PASS_SUPPORTED


/*
 * This module implements the well-known Heckbert paradigm for color
 * quantization.  Most of the ideas used here can be traced back to
 * Heckbert's seminal paper
 *   Heckbert, Paul.  "Color Image Quantization for Frame Buffer Display",
 *   Proc. SIGGRAPH '82, Computer Graphics v.16 #3 (July 1982), pp 297-304.
 *
 * In the first pass over the image, we accumulate a histogram showing the
 * usage count of each possible color.  To keep the histogram to a reasonable
 * size, we reduce the precision of the input; typical practice is to retain
 * 5 or 6 bits per color, so that 8 or 4 different input values are counted
 * in the same histogram cell.
 *
 * Next, the color-selection step begins with a box representing the whole
 * color space, and repeatedly splits the "largest" remaining box until we
 * have as many boxes as desired colors.  Then the mean color in each
 * remaining box becomes one of the possible output colors.
 * 
 * The second pass over the image maps each input pixel to the closest output
 * color (optionally after applying a Floyd-Steinberg dithering correction).
 * This mapping is logically trivial, but making it go fast enough requires
 * considerable care.
 *
 * Heckbert-style quantizers vary a good deal in their policies for choosing
 * the "largest" box and deciding where to cut it.  The particular policies
 * used here have proved out well in experimental comparisons, but better ones
 * may yet be found.
 *
 * In earlier versions of the IJG code, this module quantized in YCbCr color
 * space, processing the raw upsampled data without a color conversion step.
 * This allowed the color conversion math to be done only once per colormap
 * entry, not once per pixel.  However, that optimization precluded other
 * useful optimizations (such as merging color conversion with upsampling)
 * and it also interfered with desired capabilities such as quantizing to an
 * externally-supplied colormap.  We have therefore abandoned that approach.
 * The present code works in the post-conversion color space, typically RGB.
 *
 * To improve the visual quality of the results, we actually work in scaled
 * RGB space, giving G distances more weight than R, and R in turn more than
 * B.  To do everything in integer math, we must use integer scale factors.
 * The 2/3/1 scale factors used here correspond loosely to the relative
 * weights of the colors in the NTSC grayscale equation.
 * If you want to use this code to quantize a non-RGB color space, you'll
 * probably need to change these scale factors.
 */

#define R_SCALE 2		/* scale R distances by this much */
#define G_SCALE 3		/* scale G distances by this much */
#define B_SCALE 1		/* and B by this much */

/* Relabel R/G/B as components 0/1/2, respecting the RGB ordering defined
 * in jmorecfg.h.  As the code stands, it will do the right thing for R,G,B
 * and B,G,R orders.  If you define some other weird order in jmorecfg.h,
 * you'll get compile errors until you extend this logic.  In that case
 * you'll probably want to tweak the histogram sizes too.
 */

#if RGB_RED == 0
#define C0_SCALE R_SCALE
#endif
#if RGB_BLUE == 0
#define C0_SCALE B_SCALE
#endif
#if RGB_GREEN == 1
#define C1_SCALE G_SCALE
#endif
#if RGB_RED == 2
#define C2_SCALE R_SCALE
#endif
#if RGB_BLUE == 2
#define C2_SCALE B_SCALE
#endif


/*
 * First we have the histogram data structure and routines for creating it.
 *
 * The number of bits of precision can be adjusted by changing these symbols.
 * We recommend keeping 6 bits for G and 5 each for R and B.
 * If you have plenty of memory and cycles, 6 bits all around gives marginally
 * better results; if you are short of memory, 5 bits all around will save
 * some space but degrade the results.
 * To maintain a fully accurate histogram, we'd need to allocate a "long"
 * (preferably unsigned long) for each cell.  In practice this is overkill;
 * we can get by with 16 bits per cell.  Few of the cell counts will overflow,
 * and clamping those that do overflow to the maximum value will give close-
 * enough results.  This reduces the recommended histogram size from 256Kb
 * to 128Kb, which is a useful savings on PC-class machines.
 * (In the second pass the histogram space is re-used for pixel mapping data;
 * in that capacity, each cell must be able to store zero to the number of
 * desired colors.  16 bits/cell is plenty for that too.)
 * Since the JPEG code is intended to run in small memory model on 80x86
 * machines, we can't just allocate the histogram in one chunk.  Instead
 * of a true 3-D array, we use a row of pointers to 2-D arrays.  Each
 * pointer corresponds to a C0 value (typically 2^5 = 32 pointers) and
 * each 2-D array has 2^6*2^5 = 2048 or 2^6*2^6 = 4096 entries.  Note that
 * on 80x86 machines, the pointer row is in near memory but the actual
 * arrays are in far memory (same arrangement as we use for image arrays).
 */

#define MAXNUMCOLORS  (MAXJSAMPLE+1) /* maximum size of colormap */

/* These will do the right thing for either R,G,B or B,G,R color order,
 * but you may not like the results for other color orders.
 */
#define HIST_C0_BITS  5		/* bits of precision in R/B histogram */
#define HIST_C1_BITS  6		/* bits of precision in G histogram */
#define HIST_C2_BITS  5		/* bits of precision in B/R histogram */

/* Number of elements along histogram axes. */
#define HIST_C0_ELEMS  (1<<HIST_C0_BITS)
#define HIST_C1_ELEMS  (1<<HIST_C1_BITS)
#define HIST_C2_ELEMS  (1<<HIST_C2_BITS)

/* These are the amounts to shift an input value to get a histogram index. */
#define C0_SHIFT  (BITS_IN_JSAMPLE-HIST_C0_BITS)
#define C1_SHIFT  (BITS_IN_JSAMPLE-HIST_C1_BITS)
#define C2_SHIFT  (BITS_IN_JSAMPLE-HIST_C2_BITS)


typedef UINT16 histcell;	/* histogram cell; prefer an unsigned type */

typedef histcell FAR * histptr;	/* for pointers to histogram cells */

typedef histcell hist1d[HIST_C2_ELEMS]; /* typedefs for the array */
typedef hist1d FAR * hist2d;	/* type for the 2nd-level pointers */
typedef hist2d * hist3d;	/* type for top-level pointer */


/* Declarations for Floyd-Steinberg dithering.
 *
 * Errors are accumulated into the array fserrors[], at a resolution of
 * 1/16th of a pixel count.  The error at a given pixel is propagated
 * to its not-yet-processed neighbors using the standard F-S fractions,
 *		...	(here)	7/16
 *		3/16	5/16	1/16
 * We work left-to-right on even rows, right-to-left on odd rows.
 *
 * We can get away with a single array (holding one row's worth of errors)
 * by using it to store the current row's errors at pixel columns not yet
 * processed, but the next row's errors at columns already processed.  We
 * need only a few extra variables to hold the errors immediately around the
 * current column.  (If we are lucky, those variables are in registers, but
 * even if not, they're probably cheaper to access than array elements are.)
 *
 * The fserrors[] array has (#columns + 2) entries; the extra entry at
 * each end saves us from special-casing the first and last pixels.
 * Each entry is three values long, one value for each color component.
 *
 * Note: on a wide image, we might not have enough room in a PC's near data
 * segment to hold the error array; so it is allocated with alloc_large.
 */

#if BITS_IN_JSAMPLE == 8
typedef INT16 FSERROR;		/* 16 bits should be enough */
typedef int LOCFSERROR;		/* use 'int' for calculation temps */
#else
typedef INT32 FSERROR;		/* may need more than 16 bits */
typedef INT32 LOCFSERROR;	/* be sure calculation temps are big enough */
#endif

typedef FSERROR FAR *FSERRPTR;	/* pointer to error array (in FAR storage!) */


/* Private subobject */

typedef struct {
  struct jpeg_color_quantizer pub; /* public fields */

  /* Space for the eventually created colormap is stashed here */
  JSAMPARRAY sv_colormap;	/* colormap allocated at init time */
  int desired;			/* desired # of colors = size of colormap */

  /* Variables for accumulating image statistics */
  hist3d histogram;		/* pointer to the histogram */

  boolean needs_zeroed;		/* TRUE if next pass must zero histogram */

  /* Variables for Floyd-Steinberg dithering */
  FSERRPTR fserrors;		/* accumulated errors */
  boolean on_odd_row;		/* flag to remember which row we are on */
  int * error_limiter;		/* table for clamping the applied error */
} my_cquantizer;

typedef my_cquantizer * my_cquantize_ptr;


/*
 * Prescan some rows of pixels.
 * In this module the prescan simply updates the histogram, which has been
 * initialized to zeroes by start_pass.
 * An output_buf parameter is required by the method signature, but no data
 * is actually output (in fact the buffer controller is probably passing a
 * NULL pointer).
 */

METHODDEF(void)
prescan_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		  JSAMPARRAY output_buf, int num_rows)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  register JSAMPROW ptr;
  register histptr histp;
  register hist3d histogram = cquantize->histogram;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    ptr = input_buf[row];
    for (col = width; col > 0; col--) {
      /* get pixel value and index into the histogram */
      histp = & histogram[GETJSAMPLE(ptr[0]) >> C0_SHIFT]
			 [GETJSAMPLE(ptr[1]) >> C1_SHIFT]
			 [GETJSAMPLE(ptr[2]) >> C2_SHIFT];
      /* increment, check for overflow and undo increment if so. */
      if (++(*histp) <= 0)
	(*histp)--;
      ptr += 3;
    }
  }
}


/*
 * Next we have the really interesting routines: selection of a colormap
 * given the completed histogram.
 * These routines work with a list of "boxes", each representing a rectangular
 * subset of the input color space (to histogram precision).
 */

typedef struct {
  /* The bounds of the box (inclusive); expressed as histogram indexes */
  int c0min, c0max;
  int c1min, c1max;
  int c2min, c2max;
  /* The volume (actually 2-norm) of the box */
  INT32 volume;
  /* The number of nonzero histogram cells within this box */
  long colorcount;
} box;

typedef box * boxptr;


LOCAL(boxptr)
find_biggest_color_pop (boxptr boxlist, int numboxes)
/* Find the splittable box with the largest color population */
/* Returns NULL if no splittable boxes remain */
{
  register boxptr boxp;
  register int i;
  register long maxc = 0;
  boxptr which = NULL;
  
  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
    if (boxp->colorcount > maxc && boxp->volume > 0) {
      which = boxp;
      maxc = boxp->colorcount;
    }
  }
  return which;
}


LOCAL(boxptr)
find_biggest_volume (boxptr boxlist, int numboxes)
/* Find the splittable box with the largest (scaled) volume */
/* Returns NULL if no splittable boxes remain */
{
  register boxptr boxp;
  register int i;
  register INT32 maxv = 0;
  boxptr which = NULL;
  
  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
    if (boxp->volume > maxv) {
      which = boxp;
      maxv = boxp->volume;
    }
  }
  return which;
}


LOCAL(void)
update_box (j_decompress_ptr cinfo, boxptr boxp)
/* Shrink the min/max bounds of a box to enclose only nonzero elements, */
/* and recompute its volume and population */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
  histptr histp;
  int c0,c1,c2;
  int c0min,c0max,c1min,c1max,c2min,c2max;
  INT32 dist0,dist1,dist2;
  long ccount;
  
  c0min = boxp->c0min;  c0max = boxp->c0max;
  c1min = boxp->c1min;  c1max = boxp->c1max;
  c2min = boxp->c2min;  c2max = boxp->c2max;
  
  if (c0max > c0min)
    for (c0 = c0min; c0 <= c0max; c0++)
      for (c1 = c1min; c1 <= c1max; c1++) {
	histp = & histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
	  if (*histp++ != 0) {
	    boxp->c0min = c0min = c0;
	    goto have_c0min;
	  }
      }
 have_c0min:
  if (c0max > c0min)
    for (c0 = c0max; c0 >= c0min; c0--)
      for (c1 = c1min; c1 <= c1max; c1++) {
	histp = & histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
	  if (*histp++ != 0) {
	    boxp->c0max = c0max = c0;
	    goto have_c0max;
	  }
      }
 have_c0max:
  if (c1max > c1min)
    for (c1 = c1min; c1 <= c1max; c1++)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
	  if (*histp++ != 0) {
	    boxp->c1min = c1min = c1;
	    goto have_c1min;
	  }
      }
 have_c1min:
  if (c1max > c1min)
    for (c1 = c1max; c1 >= c1min; c1--)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
	  if (*histp++ != 0) {
	    boxp->c1max = c1max = c1;
	    goto have_c1max;
	  }
      }
 have_c1max:
  if (c2max > c2min)
    for (c2 = c2min; c2 <= c2max; c2++)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1min][c2];
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
	  if (*histp != 0) {
	    boxp->c2min = c2min = c2;
	    goto have_c2min;
	  }
      }
 have_c2min:
  if (c2max > c2min)
    for (c2 = c2max; c2 >= c2min; c2--)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1min][c2];
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
	  if (*histp != 0) {
	    boxp->c2max = c2max = c2;
	    goto have_c2max;
	  }
      }
 have_c2max:

  /* Update box volume.
   * We use 2-norm rather than real volume here; this biases the method
   * against making long narrow boxes, and it has the side benefit that
   * a box is splittable iff norm > 0.
   * Since the differences are expressed in histogram-cell units,
   * we have to shift back to JSAMPLE units to get consistent distances;
   * after which, we scale according to the selected distance scale factors.
   */
  dist0 = ((c0max - c0min) << C0_SHIFT) * C0_SCALE;
  dist1 = ((c1max - c1min) << C1_SHIFT) * C1_SCALE;
  dist2 = ((c2max - c2min) << C2_SHIFT) * C2_SCALE;
  boxp->volume = dist0*dist0 + dist1*dist1 + dist2*dist2;
  
  /* Now scan remaining volume of box and compute population */
  ccount = 0;
  for (c0 = c0min; c0 <= c0max; c0++)
    for (c1 = c1min; c1 <= c1max; c1++) {
      histp = & histogram[c0][c1][c2min];
      for (c2 = c2min; c2 <= c2max; c2++, histp++)
	if (*histp != 0) {
	  ccount++;
	}
    }
  boxp->colorcount = ccount;
}


LOCAL(int)
median_cut (j_decompress_ptr cinfo, boxptr boxlist, int numboxes,
	    int desired_colors)
/* Repeatedly select and split the largest box until we have enough boxes */
{
  int n,lb;
  int c0,c1,c2,cmax;
  register boxptr b1,b2;

  while (numboxes < desired_colors) {
    /* Select box to split.
     * Current algorithm: by population for first half, then by volume.
     */
    if (numboxes*2 <= desired_colors) {
      b1 = find_biggest_color_pop(boxlist, numboxes);
    } else {
      b1 = find_biggest_volume(boxlist, numboxes);
    }
    if (b1 == NULL)		/* no splittable boxes left! */
      break;
    b2 = &boxlist[numboxes];	/* where new box will go */
    /* Copy the color bounds to the new box. */
    b2->c0max = b1->c0max; b2->c1max = b1->c1max; b2->c2max = b1->c2max;
    b2->c0min = b1->c0min; b2->c1min = b1->c1min; b2->c2min = b1->c2min;
    /* Choose which axis to split the box on.
     * Current algorithm: longest scaled axis.
     * See notes in update_box about scaling distances.
     */
    c0 = ((b1->c0max - b1->c0min) << C0_SHIFT) * C0_SCALE;
    c1 = ((b1->c1max - b1->c1min) << C1_SHIFT) * C1_SCALE;
    c2 = ((b1->c2max - b1->c2min) << C2_SHIFT) * C2_SCALE;
    /* We want to break any ties in favor of green, then red, blue last.
     * This code does the right thing for R,G,B or B,G,R color orders only.
     */
#if RGB_RED == 0
    cmax = c1; n = 1;
    if (c0 > cmax) { cmax = c0; n = 0; }
    if (c2 > cmax) { n = 2; }
#else
    cmax = c1; n = 1;
    if (c2 > cmax) { cmax = c2; n = 2; }
    if (c0 > cmax) { n = 0; }
#endif
    /* Choose split point along selected axis, and update box bounds.
     * Current algorithm: split at halfway point.
     * (Since the box has been shrunk to minimum volume,
     * any split will produce two nonempty subboxes.)
     * Note that lb value is max for lower box, so must be < old max.
     */
    switch (n) {
    case 0:
      lb = (b1->c0max + b1->c0min) / 2;
      b1->c0max = lb;
      b2->c0min = lb+1;
      break;
    case 1:
      lb = (b1->c1max + b1->c1min) / 2;
      b1->c1max = lb;
      b2->c1min = lb+1;
      break;
    case 2:
      lb = (b1->c2max + b1->c2min) / 2;
      b1->c2max = lb;
      b2->c2min = lb+1;
      break;
    }
    /* Update stats for boxes */
    update_box(cinfo, b1);
    update_box(cinfo, b2);
    numboxes++;
  }
  return numboxes;
}


LOCAL(void)
compute_color (j_decompress_ptr cinfo, boxptr boxp, int icolor)
/* Compute representative color for a box, put it in colormap[icolor] */
{
  /* Current algorithm: mean weighted by pixels (not colors) */
  /* Note it is important to get the rounding correct! */
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
  histptr histp;
  int c0,c1,c2;
  int c0min,c0max,c1min,c1max,c2min,c2max;
  long count;
  long total = 0;
  long c0total = 0;
  long c1total = 0;
  long c2total = 0;
  
  c0min = boxp->c0min;  c0max = boxp->c0max;
  c1min = boxp->c1min;  c1max = boxp->c1max;
  c2min = boxp->c2min;  c2max = boxp->c2max;
  
  for (c0 = c0min; c0 <= c0max; c0++)
    for (c1 = c1min; c1 <= c1max; c1++) {
      histp = & histogram[c0][c1][c2min];
      for (c2 = c2min; c2 <= c2max; c2++) {
	if ((count = *histp++) != 0) {
	  total += count;
	  c0total += ((c0 << C0_SHIFT) + ((1<<C0_SHIFT)>>1)) * count;
	  c1total += ((c1 << C1_SHIFT) + ((1<<C1_SHIFT)>>1)) * count;
	  c2total += ((c2 << C2_SHIFT) + ((1<<C2_SHIFT)>>1)) * count;
	}
      }
    }
  
  cinfo->colormap[0][icolor] = (JSAMPLE) ((c0total + (total>>1)) / total);
  cinfo->colormap[1][icolor] = (JSAMPLE) ((c1total + (total>>1)) / total);
  cinfo->colormap[2][icolor] = (JSAMPLE) ((c2total + (total>>1)) / total);
}


LOCAL(void)
select_colors (j_decompress_ptr cinfo, int desired_colors)
/* Master routine for color selection */
{
  boxptr boxlist;
  int numboxes;
  int i;

  /* Allocate workspace for box list */
  boxlist = (boxptr) (*cinfo->mem->alloc_small)
    ((j_common_ptr) cinfo, JPOOL_IMAGE, desired_colors * SIZEOF(box));
  /* Initialize one box containing whole space */
  numboxes = 1;
  boxlist[0].c0min = 0;
  boxlist[0].c0max = MAXJSAMPLE >> C0_SHIFT;
  boxlist[0].c1min = 0;
  boxlist[0].c1max = MAXJSAMPLE >> C1_SHIFT;
  boxlist[0].c2min = 0;
  boxlist[0].c2max = MAXJSAMPLE >> C2_SHIFT;
  /* Shrink it to actually-used volume and set its statistics */
  update_box(cinfo, & boxlist[0]);
  /* Perform median-cut to produce final box list */
  numboxes = median_cut(cinfo, boxlist, numboxes, desired_colors);
  /* Compute the representative color for each box, fill colormap */
  for (i = 0; i < numboxes; i++)
    compute_color(cinfo, & boxlist[i], i);
  cinfo->actual_number_of_colors = numboxes;
  TRACEMS1(cinfo, 1, JTRC_QUANT_SELECTED, numboxes);
}


/*
 * These routines are concerned with the time-critical task of mapping input
 * colors to the nearest color in the selected colormap.
 *
 * We re-use the histogram space as an "inverse color map", essentially a
 * cache for the results of nearest-color searches.  All colors within a
 * histogram cell will be mapped to the same colormap entry, namely the one
 * closest to the cell's center.  This may not be quite the closest entry to
 * the actual input color, but it's almost as good.  A zero in the cache
 * indicates we haven't found the nearest color for that cell yet; the array
 * is cleared to zeroes before starting the mapping pass.  When we find the
 * nearest color for a cell, its colormap index plus one is recorded in the
 * cache for future use.  The pass2 scanning routines call fill_inverse_cmap
 * when they need to use an unfilled entry in the cache.
 *
 * Our method of efficiently finding nearest colors is based on the "locally
 * sorted search" idea described by Heckbert and on the incremental distance
 * calculation described by Spencer W. Thomas in chapter III.1 of Graphics
 * Gems II (James Arvo, ed.  Academic Press, 1991).  Thomas points out that
 * the distances from a given colormap entry to each cell of the histogram can
 * be computed quickly using an incremental method: the differences between
 * distances to adjacent cells themselves differ by a constant.  This allows a
 * fairly fast implementation of the "brute force" approach of computing the
 * distance from every colormap entry to every histogram cell.  Unfortunately,
 * it needs a work array to hold the best-distance-so-far for each histogram
 * cell (because the inner loop has to be over cells, not colormap entries).
 * The work array elements have to be INT32s, so the work array would need
 * 256Kb at our recommended precision.  This is not feasible in DOS machines.
 *
 * To get around these problems, we apply Thomas' method to compute the
 * nearest colors for only the cells within a small subbox of the histogram.
 * The work array need be only as big as the subbox, so the memory usage
 * problem is solved.  Furthermore, we need not fill subboxes that are never
 * referenced in pass2; many images use only part of the color gamut, so a
 * fair amount of work is saved.  An additional advantage of this
 * approach is that we can apply Heckbert's locality criterion to quickly
 * eliminate colormap entries that are far away from the subbox; typically
 * three-fourths of the colormap entries are rejected by Heckbert's criterion,
 * and we need not compute their distances to individual cells in the subbox.
 * The speed of this approach is heavily influenced by the subbox size: too
 * small means too much overhead, too big loses because Heckbert's criterion
 * can't eliminate as many colormap entries.  Empirically the best subbox
 * size seems to be about 1/512th of the histogram (1/8th in each direction).
 *
 * Thomas' article also describes a refined method which is asymptotically
 * faster than the brute-force method, but it is also far more complex and
 * cannot efficiently be applied to small subboxes.  It is therefore not
 * useful for programs intended to be portable to DOS machines.  On machines
 * with plenty of memory, filling the whole histogram in one shot with Thomas'
 * refined method might be faster than the present code --- but then again,
 * it might not be any faster, and it's certainly more complicated.
 */


/* log2(histogram cells in update box) for each axis; this can be adjusted */
#define BOX_C0_LOG  (HIST_C0_BITS-3)
#define BOX_C1_LOG  (HIST_C1_BITS-3)
#define BOX_C2_LOG  (HIST_C2_BITS-3)

#define BOX_C0_ELEMS  (1<<BOX_C0_LOG) /* # of hist cells in update box */
#define BOX_C1_ELEMS  (1<<BOX_C1_LOG)
#define BOX_C2_ELEMS  (1<<BOX_C2_LOG)

#define BOX_C0_SHIFT  (C0_SHIFT + BOX_C0_LOG)
#define BOX_C1_SHIFT  (C1_SHIFT + BOX_C1_LOG)
#define BOX_C2_SHIFT  (C2_SHIFT + BOX_C2_LOG)


/*
 * The next three routines implement inverse colormap filling.  They could
 * all be folded into one big routine, but splitting them up this way saves
 * some stack space (the mindist[] and bestdist[] arrays need not coexist)
 * and may allow some compilers to produce better code by registerizing more
 * inner-loop variables.
 */

LOCAL(int)
find_nearby_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
		    JSAMPLE colorlist[])
/* Locate the colormap entries close enough to an update box to be candidates
 * for the nearest entry to some cell(s) in the update box.  The update box
 * is specified by the center coordinates of its first cell.  The number of
 * candidate colormap entries is returned, and their colormap indexes are
 * placed in colorlist[].
 * This routine uses Heckbert's "locally sorted search" criterion to select
 * the colors that need further consideration.
 */
{
  int numcolors = cinfo->actual_number_of_colors;
  int maxc0, maxc1, maxc2;
  int centerc0, centerc1, centerc2;
  int i, x, ncolors;
  INT32 minmaxdist, min_dist, max_dist, tdist;
  INT32 mindist[MAXNUMCOLORS];	/* min distance to colormap entry i */

  /* Compute true coordinates of update box's upper corner and center.
   * Actually we compute the coordinates of the center of the upper-corner
   * histogram cell, which are the upper bounds of the volume we care about.
   * Note that since ">>" rounds down, the "center" values may be closer to
   * min than to max; hence comparisons to them must be "<=", not "<".
   */
  maxc0 = minc0 + ((1 << BOX_C0_SHIFT) - (1 << C0_SHIFT));
  centerc0 = (minc0 + maxc0) >> 1;
  maxc1 = minc1 + ((1 << BOX_C1_SHIFT) - (1 << C1_SHIFT));
  centerc1 = (minc1 + maxc1) >> 1;
  maxc2 = minc2 + ((1 << BOX_C2_SHIFT) - (1 << C2_SHIFT));
  centerc2 = (minc2 + maxc2) >> 1;

  /* For each color in colormap, find:
   *  1. its minimum squared-distance to any point in the update box
   *     (zero if color is within update box);
   *  2. its maximum squared-distance to any point in the update box.
   * Both of these can be found by considering only the corners of the box.
   * We save the minimum distance for each color in mindist[];
   * only the smallest maximum distance is of interest.
   */
  minmaxdist = 0x7FFFFFFFL;

  for (i = 0; i < numcolors; i++) {
    /* We compute the squared-c0-distance term, then add in the other two. */
    x = GETJSAMPLE(cinfo->colormap[0][i]);
    if (x < minc0) {
      tdist = (x - minc0) * C0_SCALE;
      min_dist = tdist*tdist;
      tdist = (x - maxc0) * C0_SCALE;
      max_dist = tdist*tdist;
    } else if (x > maxc0) {
      tdist = (x - maxc0) * C0_SCALE;
      min_dist = tdist*tdist;
      tdist = (x - minc0) * C0_SCALE;
      max_dist = tdist*tdist;
    } else {
      /* within cell range so no contribution to min_dist */
      min_dist = 0;
      if (x <= centerc0) {
	tdist = (x - maxc0) * C0_SCALE;
	max_dist = tdist*tdist;
      } else {
	tdist = (x - minc0) * C0_SCALE;
	max_dist = tdist*tdist;
      }
    }

    x = GETJSAMPLE(cinfo->colormap[1][i]);
    if (x < minc1) {
      tdist = (x - minc1) * C1_SCALE;
      min_dist += tdist*tdist;
      tdist = (x - maxc1) * C1_SCALE;
      max_dist += tdist*tdist;
    } else if (x > maxc1) {
      tdist = (x - maxc1) * C1_SCALE;
      min_dist += tdist*tdist;
      tdist = (x - minc1) * C1_SCALE;
      max_dist += tdist*tdist;
    } else {
      /* within cell range so no contribution to min_dist */
      if (x <= centerc1) {
	tdist = (x - maxc1) * C1_SCALE;
	max_dist += tdist*tdist;
      } else {
	tdist = (x - minc1) * C1_SCALE;
	max_dist += tdist*tdist;
      }
    }

    x = GETJSAMPLE(cinfo->colormap[2][i]);
    if (x < minc2) {
      tdist = (x - minc2) * C2_SCALE;
      min_dist += tdist*tdist;
      tdist = (x - maxc2) * C2_SCALE;
      max_dist += tdist*tdist;
    } else if (x > maxc2) {
      tdist = (x - maxc2) * C2_SCALE;
      min_dist += tdist*tdist;
      tdist = (x - minc2) * C2_SCALE;
      max_dist += tdist*tdist;
    } else {
      /* within cell range so no contribution to min_dist */
      if (x <= centerc2) {
	tdist = (x - maxc2) * C2_SCALE;
	max_dist += tdist*tdist;
      } else {
	tdist = (x - minc2) * C2_SCALE;
	max_dist += tdist*tdist;
      }
    }

    mindist[i] = min_dist;	/* save away the results */
    if (max_dist < minmaxdist)
      minmaxdist = max_dist;
  }

  /* Now we know that no cell in the update box is more than minmaxdist
   * away from some colormap entry.  Therefore, only colors that are
   * within minmaxdist of some part of the box need be considered.
   */
  ncolors = 0;
  for (i = 0; i < numcolors; i++) {
    if (mindist[i] <= minmaxdist)
      colorlist[ncolors++] = (JSAMPLE) i;
  }
  return ncolors;
}


LOCAL(void)
find_best_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
		  int numcolors, JSAMPLE colorlist[], JSAMPLE bestcolor[])
/* Find the closest colormap entry for each cell in the update box,
 * given the list of candidate colors prepared by find_nearby_colors.
 * Return the indexes of the closest entries in the bestcolor[] array.
 * This routine uses Thomas' incremental distance calculation method to
 * find the distance from a colormap entry to successive cells in the box.
 */
{
  int ic0, ic1, ic2;
  int i, icolor;
  register INT32 * bptr;	/* pointer into bestdist[] array */
  JSAMPLE * cptr;		/* pointer into bestcolor[] array */
  INT32 dist0, dist1;		/* initial distance values */
  register INT32 dist2;		/* current distance in inner loop */
  INT32 xx0, xx1;		/* distance increments */
  register INT32 xx2;
  INT32 inc0, inc1, inc2;	/* initial values for increments */
  /* This array holds the distance to the nearest-so-far color for each cell */
  INT32 bestdist[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];

  /* Initialize best-distance for each cell of the update box */
  bptr = bestdist;
  for (i = BOX_C0_ELEMS*BOX_C1_ELEMS*BOX_C2_ELEMS-1; i >= 0; i--)
    *bptr++ = 0x7FFFFFFFL;
  
  /* For each color selected by find_nearby_colors,
   * compute its distance to the center of each cell in the box.
   * If that's less than best-so-far, update best distance and color number.
   */
  
  /* Nominal steps between cell centers ("x" in Thomas article) */
#define STEP_C0  ((1 << C0_SHIFT) * C0_SCALE)
#define STEP_C1  ((1 << C1_SHIFT) * C1_SCALE)
#define STEP_C2  ((1 << C2_SHIFT) * C2_SCALE)
  
  for (i = 0; i < numcolors; i++) {
    icolor = GETJSAMPLE(colorlist[i]);
    /* Compute (square of) distance from minc0/c1/c2 to this color */
    inc0 = (minc0 - GETJSAMPLE(cinfo->colormap[0][icolor])) * C0_SCALE;
    dist0 = inc0*inc0;
    inc1 = (minc1 - GETJSAMPLE(cinfo->colormap[1][icolor])) * C1_SCALE;
    dist0 += inc1*inc1;
    inc2 = (minc2 - GETJSAMPLE(cinfo->colormap[2][icolor])) * C2_SCALE;
    dist0 += inc2*inc2;
    /* Form the initial difference increments */
    inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;
    inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;
    inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;
    /* Now loop over all cells in box, updating distance per Thomas method */
    bptr = bestdist;
    cptr = bestcolor;
    xx0 = inc0;
    for (ic0 = BOX_C0_ELEMS-1; ic0 >= 0; ic0--) {
      dist1 = dist0;
      xx1 = inc1;
      for (ic1 = BOX_C1_ELEMS-1; ic1 >= 0; ic1--) {
	dist2 = dist1;
	xx2 = inc2;
	for (ic2 = BOX_C2_ELEMS-1; ic2 >= 0; ic2--) {
	  if (dist2 < *bptr) {
	    *bptr = dist2;
	    *cptr = (JSAMPLE) icolor;
	  }
	  dist2 += xx2;
	  xx2 += 2 * STEP_C2 * STEP_C2;
	  bptr++;
	  cptr++;
	}
	dist1 += xx1;
	xx1 += 2 * STEP_C1 * STEP_C1;
      }
      dist0 += xx0;
      xx0 += 2 * STEP_C0 * STEP_C0;
    }
  }
}


LOCAL(void)
fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
/* Fill the inverse-colormap entries in the update box that contains */
/* histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but */
/* we can fill as many others as we wish.) */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
  int minc0, minc1, minc2;	/* lower left corner of update box */
  int ic0, ic1, ic2;
  register JSAMPLE * cptr;	/* pointer into bestcolor[] array */
  register histptr cachep;	/* pointer into main cache array */
  /* This array lists the candidate colormap indexes. */
  JSAMPLE colorlist[MAXNUMCOLORS];
  int numcolors;		/* number of candidate colors */
  /* This array holds the actually closest colormap index for each cell. */
  JSAMPLE bestcolor[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];

  /* Convert cell coordinates to update box ID */
  c0 >>= BOX_C0_LOG;
  c1 >>= BOX_C1_LOG;
  c2 >>= BOX_C2_LOG;

  /* Compute true coordinates of update box's origin corner.
   * Actually we compute the coordinates of the center of the corner
   * histogram cell, which are the lower bounds of the volume we care about.
   */
  minc0 = (c0 << BOX_C0_SHIFT) + ((1 << C0_SHIFT) >> 1);
  minc1 = (c1 << BOX_C1_SHIFT) + ((1 << C1_SHIFT) >> 1);
  minc2 = (c2 << BOX_C2_SHIFT) + ((1 << C2_SHIFT) >> 1);
  
  /* Determine which colormap entries are close enough to be candidates
   * for the nearest entry to some cell in the update box.
   */
  numcolors = find_nearby_colors(cinfo, minc0, minc1, minc2, colorlist);

  /* Determine the actually nearest colors. */
  find_best_colors(cinfo, minc0, minc1, minc2, numcolors, colorlist,
		   bestcolor);

  /* Save the best color numbers (plus 1) in the main cache array */
  c0 <<= BOX_C0_LOG;		/* convert ID back to base cell indexes */
  c1 <<= BOX_C1_LOG;
  c2 <<= BOX_C2_LOG;
  cptr = bestcolor;
  for (ic0 = 0; ic0 < BOX_C0_ELEMS; ic0++) {
    for (ic1 = 0; ic1 < BOX_C1_ELEMS; ic1++) {
      cachep = & histogram[c0+ic0][c1+ic1][c2];
      for (ic2 = 0; ic2 < BOX_C2_ELEMS; ic2++) {
	*cachep++ = (histcell) (GETJSAMPLE(*cptr++) + 1);
      }
    }
  }
}


/*
 * Map some rows of pixels to the output colormapped representation.
 */

METHODDEF(void)
pass2_no_dither (j_decompress_ptr cinfo,
		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
/* This version performs no dithering */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
  register JSAMPROW inptr, outptr;
  register histptr cachep;
  register int c0, c1, c2;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    inptr = input_buf[row];
    outptr = output_buf[row];
    for (col = width; col > 0; col--) {
      /* get pixel value and index into the cache */
      c0 = GETJSAMPLE(*inptr++) >> C0_SHIFT;
      c1 = GETJSAMPLE(*inptr++) >> C1_SHIFT;
      c2 = GETJSAMPLE(*inptr++) >> C2_SHIFT;
      cachep = & histogram[c0][c1][c2];
      /* If we have not seen this color before, find nearest colormap entry */
      /* and update the cache */
      if (*cachep == 0)
	fill_inverse_cmap(cinfo, c0,c1,c2);
      /* Now emit the colormap index for this cell */
      *outptr++ = (JSAMPLE) (*cachep - 1);
    }
  }
}


METHODDEF(void)
pass2_fs_dither (j_decompress_ptr cinfo,
		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
/* This version performs Floyd-Steinberg dithering */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
  register LOCFSERROR cur0, cur1, cur2;	/* current error or pixel value */
  LOCFSERROR belowerr0, belowerr1, belowerr2; /* error for pixel below cur */
  LOCFSERROR bpreverr0, bpreverr1, bpreverr2; /* error for below/prev col */
  register FSERRPTR errorptr;	/* => fserrors[] at column before current */
  JSAMPROW inptr;		/* => current input pixel */
  JSAMPROW outptr;		/* => current output pixel */
  histptr cachep;
  int dir;			/* +1 or -1 depending on direction */
  int dir3;			/* 3*dir, for advancing inptr & errorptr */
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
  JSAMPLE *range_limit = cinfo->sample_range_limit;
  int *error_limit = cquantize->error_limiter;
  JSAMPROW colormap0 = cinfo->colormap[0];
  JSAMPROW colormap1 = cinfo->colormap[1];
  JSAMPROW colormap2 = cinfo->colormap[2];
  SHIFT_TEMPS

  for (row = 0; row < num_rows; row++) {
    inptr = input_buf[row];
    outptr = output_buf[row];
    if (cquantize->on_odd_row) {
      /* work right to left in this row */
      inptr += (width-1) * 3;	/* so point to rightmost pixel */
      outptr += width-1;
      dir = -1;
      dir3 = -3;
      errorptr = cquantize->fserrors + (width+1)*3; /* => entry after last column */
      cquantize->on_odd_row = FALSE; /* flip for next time */
    } else {
      /* work left to right in this row */
      dir = 1;
      dir3 = 3;
      errorptr = cquantize->fserrors; /* => entry before first real column */
      cquantize->on_odd_row = TRUE; /* flip for next time */
    }
    /* Preset error values: no error propagated to first pixel from left */
    cur0 = cur1 = cur2 = 0;
    /* and no error propagated to row below yet */
    belowerr0 = belowerr1 = belowerr2 = 0;
    bpreverr0 = bpreverr1 = bpreverr2 = 0;

    for (col = width; col > 0; col--) {
      /* curN holds the error propagated from the previous pixel on the
       * current line.  Add the error propagated from the previous line
       * to form the complete error correction term for this pixel, and
       * round the error term (which is expressed * 16) to an integer.
       * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
       * for either sign of the error value.
       * Note: errorptr points to *previous* column's array entry.
       */
      cur0 = RIGHT_SHIFT(cur0 + errorptr[dir3+0] + 8, 4);
      cur1 = RIGHT_SHIFT(cur1 + errorptr[dir3+1] + 8, 4);
      cur2 = RIGHT_SHIFT(cur2 + errorptr[dir3+2] + 8, 4);
      /* Limit the error using transfer function set by init_error_limit.
       * See comments with init_error_limit for rationale.
       */
      cur0 = error_limit[cur0];
      cur1 = error_limit[cur1];
      cur2 = error_limit[cur2];
      /* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
       * The maximum error is +- MAXJSAMPLE (or less with error limiting);
       * this sets the required size of the range_limit array.
       */
      cur0 += GETJSAMPLE(inptr[0]);
      cur1 += GETJSAMPLE(inptr[1]);
      cur2 += GETJSAMPLE(inptr[2]);
      cur0 = GETJSAMPLE(range_limit[cur0]);
      cur1 = GETJSAMPLE(range_limit[cur1]);
      cur2 = GETJSAMPLE(range_limit[cur2]);
      /* Index into the cache with adjusted pixel value */
      cachep = & histogram[cur0>>C0_SHIFT][cur1>>C1_SHIFT][cur2>>C2_SHIFT];
      /* If we have not seen this color before, find nearest colormap */
      /* entry and update the cache */
      if (*cachep == 0)
	fill_inverse_cmap(cinfo, cur0>>C0_SHIFT,cur1>>C1_SHIFT,cur2>>C2_SHIFT);
      /* Now emit the colormap index for this cell */
      { register int pixcode = *cachep - 1;
	*outptr = (JSAMPLE) pixcode;
	/* Compute representation error for this pixel */
	cur0 -= GETJSAMPLE(colormap0[pixcode]);
	cur1 -= GETJSAMPLE(colormap1[pixcode]);
	cur2 -= GETJSAMPLE(colormap2[pixcode]);
      }
      /* Compute error fractions to be propagated to adjacent pixels.
       * Add these into the running sums, and simultaneously shift the
       * next-line error sums left by 1 column.
       */
      { register LOCFSERROR bnexterr, delta;

	bnexterr = cur0;	/* Process component 0 */
	delta = cur0 * 2;
	cur0 += delta;		/* form error * 3 */
	errorptr[0] = (FSERROR) (bpreverr0 + cur0);
	cur0 += delta;		/* form error * 5 */
	bpreverr0 = belowerr0 + cur0;
	belowerr0 = bnexterr;
	cur0 += delta;		/* form error * 7 */
	bnexterr = cur1;	/* Process component 1 */
	delta = cur1 * 2;
	cur1 += delta;		/* form error * 3 */
	errorptr[1] = (FSERROR) (bpreverr1 + cur1);
	cur1 += delta;		/* form error * 5 */
	bpreverr1 = belowerr1 + cur1;
	belowerr1 = bnexterr;
	cur1 += delta;		/* form error * 7 */
	bnexterr = cur2;	/* Process component 2 */
	delta = cur2 * 2;
	cur2 += delta;		/* form error * 3 */
	errorptr[2] = (FSERROR) (bpreverr2 + cur2);
	cur2 += delta;		/* form error * 5 */
	bpreverr2 = belowerr2 + cur2;
	belowerr2 = bnexterr;
	cur2 += delta;		/* form error * 7 */
      }
      /* At this point curN contains the 7/16 error value to be propagated
       * to the next pixel on the current line, and all the errors for the
       * next line have been shifted over.  We are therefore ready to move on.
       */
      inptr += dir3;		/* Advance pixel pointers to next column */
      outptr += dir;
      errorptr += dir3;		/* advance errorptr to current column */
    }
    /* Post-loop cleanup: we must unload the final error values into the
     * final fserrors[] entry.  Note we need not unload belowerrN because
     * it is for the dummy column before or after the actual array.
     */
    errorptr[0] = (FSERROR) bpreverr0; /* unload prev errs into array */
    errorptr[1] = (FSERROR) bpreverr1;
    errorptr[2] = (FSERROR) bpreverr2;
  }
}


/*
 * Initialize the error-limiting transfer function (lookup table).
 * The raw F-S error computation can potentially compute error values of up to
 * +- MAXJSAMPLE.  But we want the maximum correction applied to a pixel to be
 * much less, otherwise obviously wrong pixels will be created.  (Typical
 * effects include weird fringes at color-area boundaries, isolated bright
 * pixels in a dark area, etc.)  The standard advice for avoiding this problem
 * is to ensure that the "corners" of the color cube are allocated as output
 * colors; then repeated errors in the same direction cannot cause cascading
 * error buildup.  However, that only prevents the error from getting
 * completely out of hand; Aaron Giles reports that error limiting improves
 * the results even with corner colors allocated.
 * A simple clamping of the error values to about +- MAXJSAMPLE/8 works pretty
 * well, but the smoother transfer function used below is even better.  Thanks
 * to Aaron Giles for this idea.
 */

LOCAL(void)
init_error_limit (j_decompress_ptr cinfo)
/* Allocate and fill in the error_limiter table */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  int * table;
  int in, out;

  table = (int *) (*cinfo->mem->alloc_small)
    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE*2+1) * SIZEOF(int));
  table += MAXJSAMPLE;		/* so can index -MAXJSAMPLE .. +MAXJSAMPLE */
  cquantize->error_limiter = table;

#define STEPSIZE ((MAXJSAMPLE+1)/16)
  /* Map errors 1:1 up to +- MAXJSAMPLE/16 */
  out = 0;
  for (in = 0; in < STEPSIZE; in++, out++) {
    table[in] = out; table[-in] = -out;
  }
  /* Map errors 1:2 up to +- 3*MAXJSAMPLE/16 */
  for (; in < STEPSIZE*3; in++, out += (in&1) ? 0 : 1) {
    table[in] = out; table[-in] = -out;
  }
  /* Clamp the rest to final out value (which is (MAXJSAMPLE+1)/8) */
  for (; in <= MAXJSAMPLE; in++) {
    table[in] = out; table[-in] = -out;
  }
#undef STEPSIZE
}


/*
 * Finish up at the end of each pass.
 */

METHODDEF(void)
finish_pass1 (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;

  /* Select the representative colors and fill in cinfo->colormap */
  cinfo->colormap = cquantize->sv_colormap;
  select_colors(cinfo, cquantize->desired);
  /* Force next pass to zero the color index table */
  cquantize->needs_zeroed = TRUE;
}


METHODDEF(void)
finish_pass2 (j_decompress_ptr cinfo)
{
  /* no work */
}


/*
 * Initialize for each processing pass.
 */

METHODDEF(void)
start_pass_2_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
  int i;

  /* Only F-S dithering or no dithering is supported. */
  /* If user asks for ordered dither, give him F-S. */
  if (cinfo->dither_mode != JDITHER_NONE)
    cinfo->dither_mode = JDITHER_FS;

  if (is_pre_scan) {
    /* Set up method pointers */
    cquantize->pub.color_quantize = prescan_quantize;
    cquantize->pub.finish_pass = finish_pass1;
    cquantize->needs_zeroed = TRUE; /* Always zero histogram */
  } else {
    /* Set up method pointers */
    if (cinfo->dither_mode == JDITHER_FS)
      cquantize->pub.color_quantize = pass2_fs_dither;
    else
      cquantize->pub.color_quantize = pass2_no_dither;
    cquantize->pub.finish_pass = finish_pass2;

    /* Make sure color count is acceptable */
    i = cinfo->actual_number_of_colors;
    if (i < 1)
      ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 1);
    if (i > MAXNUMCOLORS)
      ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);

    if (cinfo->dither_mode == JDITHER_FS) {
      size_t arraysize = (size_t) ((cinfo->output_width + 2) *
				   (3 * SIZEOF(FSERROR)));
      /* Allocate Floyd-Steinberg workspace if we didn't already. */
      if (cquantize->fserrors == NULL)
	cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
	  ((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
      /* Initialize the propagated errors to zero. */
      jzero_far((void FAR *) cquantize->fserrors, arraysize);
      /* Make the error-limit table if we didn't already. */
      if (cquantize->error_limiter == NULL)
	init_error_limit(cinfo);
      cquantize->on_odd_row = FALSE;
    }

  }
  /* Zero the histogram or inverse color map, if necessary */
  if (cquantize->needs_zeroed) {
    for (i = 0; i < HIST_C0_ELEMS; i++) {
      jzero_far((void FAR *) histogram[i],
		HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
    }
    cquantize->needs_zeroed = FALSE;
  }
}


/*
 * Switch to a new external colormap between output passes.
 */

METHODDEF(void)
new_color_map_2_quant (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;

  /* Reset the inverse color map */
  cquantize->needs_zeroed = TRUE;
}


/*
 * Module initialization routine for 2-pass color quantization.
 */

GLOBAL(void)
jinit_2pass_quantizer (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize;
  int i;

  cquantize = (my_cquantize_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_cquantizer));
  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
  cquantize->pub.start_pass = start_pass_2_quant;
  cquantize->pub.new_color_map = new_color_map_2_quant;
  cquantize->fserrors = NULL;	/* flag optional arrays not allocated */
  cquantize->error_limiter = NULL;

  /* Make sure jdmaster didn't give me a case I can't handle */
  if (cinfo->out_color_components != 3)
    ERREXIT(cinfo, JERR_NOTIMPL);

  /* Allocate the histogram/inverse colormap storage */
  cquantize->histogram = (hist3d) (*cinfo->mem->alloc_small)
    ((j_common_ptr) cinfo, JPOOL_IMAGE, HIST_C0_ELEMS * SIZEOF(hist2d));
  for (i = 0; i < HIST_C0_ELEMS; i++) {
    cquantize->histogram[i] = (hist2d) (*cinfo->mem->alloc_large)
      ((j_common_ptr) cinfo, JPOOL_IMAGE,
       HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
  }
  cquantize->needs_zeroed = TRUE; /* histogram is garbage now */

  /* Allocate storage for the completed colormap, if required.
   * We do this now since it is FAR storage and may affect
   * the memory manager's space calculations.
   */
  if (cinfo->enable_2pass_quant) {
    /* Make sure color count is acceptable */
    int desired = cinfo->desired_number_of_colors;
    /* Lower bound on # of colors ... somewhat arbitrary as long as > 0 */
    if (desired < 8)
      ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 8);
    /* Make sure colormap indexes can be represented by JSAMPLEs */
    if (desired > MAXNUMCOLORS)
      ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
    cquantize->sv_colormap = (*cinfo->mem->alloc_sarray)
      ((j_common_ptr) cinfo,JPOOL_IMAGE, (JDIMENSION) desired, (JDIMENSION) 3);
    cquantize->desired = desired;
  } else
    cquantize->sv_colormap = NULL;

  /* Only F-S dithering or no dithering is supported. */
  /* If user asks for ordered dither, give him F-S. */
  if (cinfo->dither_mode != JDITHER_NONE)
    cinfo->dither_mode = JDITHER_FS;

  /* Allocate Floyd-Steinberg workspace if necessary.
   * This isn't really needed until pass 2, but again it is FAR storage.
   * Although we will cope with a later change in dither_mode,
   * we do not promise to honor max_memory_to_use if dither_mode changes.
   */
  if (cinfo->dither_mode == JDITHER_FS) {
    cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
      ((j_common_ptr) cinfo, JPOOL_IMAGE,
       (size_t) ((cinfo->output_width + 2) * (3 * SIZEOF(FSERROR))));
    /* Might as well create the error-limiting table too. */
    init_error_limit(cinfo);
  }
}

#endif /* QUANT_2PASS_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeg\jquant1.c ===
/*
 * jquant1.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains 1-pass color quantization (color mapping) routines.
 * These routines provide mapping to a fixed color map using equally spaced
 * color values.  Optional Floyd-Steinberg or ordered dithering is available.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"

#ifdef QUANT_1PASS_SUPPORTED


/*
 * The main purpose of 1-pass quantization is to provide a fast, if not very
 * high quality, colormapped output capability.  A 2-pass quantizer usually
 * gives better visual quality; however, for quantized grayscale output this
 * quantizer is perfectly adequate.  Dithering is highly recommended with this
 * quantizer, though you can turn it off if you really want to.
 *
 * In 1-pass quantization the colormap must be chosen in advance of seeing the
 * image.  We use a map consisting of all combinations of Ncolors[i] color
 * values for the i'th component.  The Ncolors[] values are chosen so that
 * their product, the total number of colors, is no more than that requested.
 * (In most cases, the product will be somewhat less.)
 *
 * Since the colormap is orthogonal, the representative value for each color
 * component can be determined without considering the other components;
 * then these indexes can be combined into a colormap index by a standard
 * N-dimensional-array-subscript calculation.  Most of the arithmetic involved
 * can be precalculated and stored in the lookup table colorindex[].
 * colorindex[i][j] maps pixel value j in component i to the nearest
 * representative value (grid plane) for that component; this index is
 * multiplied by the array stride for component i, so that the
 * index of the colormap entry closest to a given pixel value is just
 *    sum( colorindex[component-number][pixel-component-value] )
 * Aside from being fast, this scheme allows for variable spacing between
 * representative values with no additional lookup cost.
 *
 * If gamma correction has been applied in color conversion, it might be wise
 * to adjust the color grid spacing so that the representative colors are
 * equidistant in linear space.  At this writing, gamma correction is not
 * implemented by jdcolor, so nothing is done here.
 */


/* Declarations for ordered dithering.
 *
 * We use a standard 16x16 ordered dither array.  The basic concept of ordered
 * dithering is described in many references, for instance Dale Schumacher's
 * chapter II.2 of Graphics Gems II (James Arvo, ed. Academic Press, 1991).
 * In place of Schumacher's comparisons against a "threshold" value, we add a
 * "dither" value to the input pixel and then round the result to the nearest
 * output value.  The dither value is equivalent to (0.5 - threshold) times
 * the distance between output values.  For ordered dithering, we assume that
 * the output colors are equally spaced; if not, results will probably be
 * worse, since the dither may be too much or too little at a given point.
 *
 * The normal calculation would be to form pixel value + dither, range-limit
 * this to 0..MAXJSAMPLE, and then index into the colorindex table as usual.
 * We can skip the separate range-limiting step by extending the colorindex
 * table in both directions.
 */

#define ODITHER_SIZE  16	/* dimension of dither matrix */
/* NB: if ODITHER_SIZE is not a power of 2, ODITHER_MASK uses will break */
#define ODITHER_CELLS (ODITHER_SIZE*ODITHER_SIZE)	/* # cells in matrix */
#define ODITHER_MASK  (ODITHER_SIZE-1) /* mask for wrapping around counters */

typedef int ODITHER_MATRIX[ODITHER_SIZE][ODITHER_SIZE];
typedef int (*ODITHER_MATRIX_PTR)[ODITHER_SIZE];

static const UINT8 base_dither_matrix[ODITHER_SIZE][ODITHER_SIZE] = {
  /* Bayer's order-4 dither array.  Generated by the code given in
   * Stephen Hawley's article "Ordered Dithering" in Graphics Gems I.
   * The values in this array must range from 0 to ODITHER_CELLS-1.
   */
  {   0,192, 48,240, 12,204, 60,252,  3,195, 51,243, 15,207, 63,255 },
  { 128, 64,176,112,140, 76,188,124,131, 67,179,115,143, 79,191,127 },
  {  32,224, 16,208, 44,236, 28,220, 35,227, 19,211, 47,239, 31,223 },
  { 160, 96,144, 80,172,108,156, 92,163, 99,147, 83,175,111,159, 95 },
  {   8,200, 56,248,  4,196, 52,244, 11,203, 59,251,  7,199, 55,247 },
  { 136, 72,184,120,132, 68,180,116,139, 75,187,123,135, 71,183,119 },
  {  40,232, 24,216, 36,228, 20,212, 43,235, 27,219, 39,231, 23,215 },
  { 168,104,152, 88,164,100,148, 84,171,107,155, 91,167,103,151, 87 },
  {   2,194, 50,242, 14,206, 62,254,  1,193, 49,241, 13,205, 61,253 },
  { 130, 66,178,114,142, 78,190,126,129, 65,177,113,141, 77,189,125 },
  {  34,226, 18,210, 46,238, 30,222, 33,225, 17,209, 45,237, 29,221 },
  { 162, 98,146, 82,174,110,158, 94,161, 97,145, 81,173,109,157, 93 },
  {  10,202, 58,250,  6,198, 54,246,  9,201, 57,249,  5,197, 53,245 },
  { 138, 74,186,122,134, 70,182,118,137, 73,185,121,133, 69,181,117 },
  {  42,234, 26,218, 38,230, 22,214, 41,233, 25,217, 37,229, 21,213 },
  { 170,106,154, 90,166,102,150, 86,169,105,153, 89,165,101,149, 85 }
};


/* Declarations for Floyd-Steinberg dithering.
 *
 * Errors are accumulated into the array fserrors[], at a resolution of
 * 1/16th of a pixel count.  The error at a given pixel is propagated
 * to its not-yet-processed neighbors using the standard F-S fractions,
 *		...	(here)	7/16
 *		3/16	5/16	1/16
 * We work left-to-right on even rows, right-to-left on odd rows.
 *
 * We can get away with a single array (holding one row's worth of errors)
 * by using it to store the current row's errors at pixel columns not yet
 * processed, but the next row's errors at columns already processed.  We
 * need only a few extra variables to hold the errors immediately around the
 * current column.  (If we are lucky, those variables are in registers, but
 * even if not, they're probably cheaper to access than array elements are.)
 *
 * The fserrors[] array is indexed [component#][position].
 * We provide (#columns + 2) entries per component; the extra entry at each
 * end saves us from special-casing the first and last pixels.
 *
 * Note: on a wide image, we might not have enough room in a PC's near data
 * segment to hold the error array; so it is allocated with alloc_large.
 */

#if BITS_IN_JSAMPLE == 8
typedef INT16 FSERROR;		/* 16 bits should be enough */
typedef int LOCFSERROR;		/* use 'int' for calculation temps */
#else
typedef INT32 FSERROR;		/* may need more than 16 bits */
typedef INT32 LOCFSERROR;	/* be sure calculation temps are big enough */
#endif

typedef FSERROR FAR *FSERRPTR;	/* pointer to error array (in FAR storage!) */


/* Private subobject */

#define MAX_Q_COMPS 4		/* max components I can handle */

typedef struct {
  struct jpeg_color_quantizer pub; /* public fields */

  /* Initially allocated colormap is saved here */
  JSAMPARRAY sv_colormap;	/* The color map as a 2-D pixel array */
  int sv_actual;		/* number of entries in use */

  JSAMPARRAY colorindex;	/* Precomputed mapping for speed */
  /* colorindex[i][j] = index of color closest to pixel value j in component i,
   * premultiplied as described above.  Since colormap indexes must fit into
   * JSAMPLEs, the entries of this array will too.
   */
  boolean is_padded;		/* is the colorindex padded for odither? */

  int Ncolors[MAX_Q_COMPS];	/* # of values alloced to each component */

  /* Variables for ordered dithering */
  int row_index;		/* cur row's vertical index in dither matrix */
  ODITHER_MATRIX_PTR odither[MAX_Q_COMPS]; /* one dither array per component */

  /* Variables for Floyd-Steinberg dithering */
  FSERRPTR fserrors[MAX_Q_COMPS]; /* accumulated errors */
  boolean on_odd_row;		/* flag to remember which row we are on */
} my_cquantizer;

typedef my_cquantizer * my_cquantize_ptr;


/*
 * Policy-making subroutines for create_colormap and create_colorindex.
 * These routines determine the colormap to be used.  The rest of the module
 * only assumes that the colormap is orthogonal.
 *
 *  * select_ncolors decides how to divvy up the available colors
 *    among the components.
 *  * output_value defines the set of representative values for a component.
 *  * largest_input_value defines the mapping from input values to
 *    representative values for a component.
 * Note that the latter two routines may impose different policies for
 * different components, though this is not currently done.
 */


LOCAL(int)
select_ncolors (j_decompress_ptr cinfo, int Ncolors[])
/* Determine allocation of desired colors to components, */
/* and fill in Ncolors[] array to indicate choice. */
/* Return value is total number of colors (product of Ncolors[] values). */
{
  int nc = cinfo->out_color_components; /* number of color components */
  int max_colors = cinfo->desired_number_of_colors;
  int total_colors, iroot, i, j;
  boolean changed;
  long temp;
  static const int RGB_order[3] = { RGB_GREEN, RGB_RED, RGB_BLUE };

  /* We can allocate at least the nc'th root of max_colors per component. */
  /* Compute floor(nc'th root of max_colors). */
  iroot = 1;
  do {
    iroot++;
    temp = iroot;		/* set temp = iroot ** nc */
    for (i = 1; i < nc; i++)
      temp *= iroot;
  } while (temp <= (long) max_colors); /* repeat till iroot exceeds root */
  iroot--;			/* now iroot = floor(root) */

  /* Must have at least 2 color values per component */
  if (iroot < 2)
    ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, (int) temp);

  /* Initialize to iroot color values for each component */
  total_colors = 1;
  for (i = 0; i < nc; i++) {
    Ncolors[i] = iroot;
    total_colors *= iroot;
  }
  /* We may be able to increment the count for one or more components without
   * exceeding max_colors, though we know not all can be incremented.
   * Sometimes, the first component can be incremented more than once!
   * (Example: for 16 colors, we start at 2*2*2, go to 3*2*2, then 4*2*2.)
   * In RGB colorspace, try to increment G first, then R, then B.
   */
  do {
    changed = FALSE;
    for (i = 0; i < nc; i++) {
      j = (cinfo->out_color_space == JCS_RGB ? RGB_order[i] : i);
      /* calculate new total_colors if Ncolors[j] is incremented */
      temp = total_colors / Ncolors[j];
      temp *= Ncolors[j]+1;	/* done in long arith to avoid oflo */
      if (temp > (long) max_colors)
	break;			/* won't fit, done with this pass */
      Ncolors[j]++;		/* OK, apply the increment */
      total_colors = (int) temp;
      changed = TRUE;
    }
  } while (changed);

  return total_colors;
}


LOCAL(int)
output_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
/* Return j'th output value, where j will range from 0 to maxj */
/* The output values must fall in 0..MAXJSAMPLE in increasing order */
{
  /* We always provide values 0 and MAXJSAMPLE for each component;
   * any additional values are equally spaced between these limits.
   * (Forcing the upper and lower values to the limits ensures that
   * dithering can't produce a color outside the selected gamut.)
   */
  return (int) (((INT32) j * MAXJSAMPLE + maxj/2) / maxj);
}


LOCAL(int)
largest_input_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
/* Return largest input value that should map to j'th output value */
/* Must have largest(j=0) >= 0, and largest(j=maxj) >= MAXJSAMPLE */
{
  /* Breakpoints are halfway between values returned by output_value */
  return (int) (((INT32) (2*j + 1) * MAXJSAMPLE + maxj) / (2*maxj));
}


/*
 * Create the colormap.
 */

LOCAL(void)
create_colormap (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  JSAMPARRAY colormap;		/* Created colormap */
  int total_colors;		/* Number of distinct output colors */
  int i,j,k, nci, blksize, blkdist, ptr, val;

  /* Select number of colors for each component */
  total_colors = select_ncolors(cinfo, cquantize->Ncolors);

  /* Report selected color counts */
  if (cinfo->out_color_components == 3)
    TRACEMS4(cinfo, 1, JTRC_QUANT_3_NCOLORS,
	     total_colors, cquantize->Ncolors[0],
	     cquantize->Ncolors[1], cquantize->Ncolors[2]);
  else
    TRACEMS1(cinfo, 1, JTRC_QUANT_NCOLORS, total_colors);

  /* Allocate and fill in the colormap. */
  /* The colors are ordered in the map in standard row-major order, */
  /* i.e. rightmost (highest-indexed) color changes most rapidly. */

  colormap = (*cinfo->mem->alloc_sarray)
    ((j_common_ptr) cinfo, JPOOL_IMAGE,
     (JDIMENSION) total_colors, (JDIMENSION) cinfo->out_color_components);

  /* blksize is number of adjacent repeated entries for a component */
  /* blkdist is distance between groups of identical entries for a component */
  blkdist = total_colors;

  for (i = 0; i < cinfo->out_color_components; i++) {
    /* fill in colormap entries for i'th color component */
    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
    blksize = blkdist / nci;
    for (j = 0; j < nci; j++) {
      /* Compute j'th output value (out of nci) for component */
      val = output_value(cinfo, i, j, nci-1);
      /* Fill in all colormap entries that have this value of this component */
      for (ptr = j * blksize; ptr < total_colors; ptr += blkdist) {
	/* fill in blksize entries beginning at ptr */
	for (k = 0; k < blksize; k++)
	  colormap[i][ptr+k] = (JSAMPLE) val;
      }
    }
    blkdist = blksize;		/* blksize of this color is blkdist of next */
  }

  /* Save the colormap in private storage,
   * where it will survive color quantization mode changes.
   */
  cquantize->sv_colormap = colormap;
  cquantize->sv_actual = total_colors;
}


/*
 * Create the color index table.
 */

LOCAL(void)
create_colorindex (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  JSAMPROW indexptr;
  int i,j,k, nci, blksize, val, pad;

  /* For ordered dither, we pad the color index tables by MAXJSAMPLE in
   * each direction (input index values can be -MAXJSAMPLE .. 2*MAXJSAMPLE).
   * This is not necessary in the other dithering modes.  However, we
   * flag whether it was done in case user changes dithering mode.
   */
  if (cinfo->dither_mode == JDITHER_ORDERED) {
    pad = MAXJSAMPLE*2;
    cquantize->is_padded = TRUE;
  } else {
    pad = 0;
    cquantize->is_padded = FALSE;
  }

  cquantize->colorindex = (*cinfo->mem->alloc_sarray)
    ((j_common_ptr) cinfo, JPOOL_IMAGE,
     (JDIMENSION) (MAXJSAMPLE+1 + pad),
     (JDIMENSION) cinfo->out_color_components);

  /* blksize is number of adjacent repeated entries for a component */
  blksize = cquantize->sv_actual;

  for (i = 0; i < cinfo->out_color_components; i++) {
    /* fill in colorindex entries for i'th color component */
    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
    blksize = blksize / nci;

    /* adjust colorindex pointers to provide padding at negative indexes. */
    if (pad)
      cquantize->colorindex[i] += MAXJSAMPLE;

    /* in loop, val = index of current output value, */
    /* and k = largest j that maps to current val */
    indexptr = cquantize->colorindex[i];
    val = 0;
    k = largest_input_value(cinfo, i, 0, nci-1);
    for (j = 0; j <= MAXJSAMPLE; j++) {
      while (j > k)		/* advance val if past boundary */
	k = largest_input_value(cinfo, i, ++val, nci-1);
      /* premultiply so that no multiplication needed in main processing */
      indexptr[j] = (JSAMPLE) (val * blksize);
    }
    /* Pad at both ends if necessary */
    if (pad)
      for (j = 1; j <= MAXJSAMPLE; j++) {
	indexptr[-j] = indexptr[0];
	indexptr[MAXJSAMPLE+j] = indexptr[MAXJSAMPLE];
      }
  }
}


/*
 * Create an ordered-dither array for a component having ncolors
 * distinct output values.
 */

LOCAL(ODITHER_MATRIX_PTR)
make_odither_array (j_decompress_ptr cinfo, int ncolors)
{
  ODITHER_MATRIX_PTR odither;
  int j,k;
  INT32 num,den;

  odither = (ODITHER_MATRIX_PTR)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(ODITHER_MATRIX));
  /* The inter-value distance for this color is MAXJSAMPLE/(ncolors-1).
   * Hence the dither value for the matrix cell with fill order f
   * (f=0..N-1) should be (N-1-2*f)/(2*N) * MAXJSAMPLE/(ncolors-1).
   * On 16-bit-int machine, be careful to avoid overflow.
   */
  den = 2 * ODITHER_CELLS * ((INT32) (ncolors - 1));
  for (j = 0; j < ODITHER_SIZE; j++) {
    for (k = 0; k < ODITHER_SIZE; k++) {
      num = ((INT32) (ODITHER_CELLS-1 - 2*((int)base_dither_matrix[j][k])))
	    * MAXJSAMPLE;
      /* Ensure round towards zero despite C's lack of consistency
       * about rounding negative values in integer division...
       */
      odither[j][k] = (int) (num<0 ? -((-num)/den) : num/den);
    }
  }
  return odither;
}


/*
 * Create the ordered-dither tables.
 * Components having the same number of representative colors may 
 * share a dither table.
 */

LOCAL(void)
create_odither_tables (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  ODITHER_MATRIX_PTR odither;
  int i, j, nci;

  for (i = 0; i < cinfo->out_color_components; i++) {
    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
    odither = NULL;		/* search for matching prior component */
    for (j = 0; j < i; j++) {
      if (nci == cquantize->Ncolors[j]) {
	odither = cquantize->odither[j];
	break;
      }
    }
    if (odither == NULL)	/* need a new table? */
      odither = make_odither_array(cinfo, nci);
    cquantize->odither[i] = odither;
  }
}


/*
 * Map some rows of pixels to the output colormapped representation.
 */

METHODDEF(void)
color_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		JSAMPARRAY output_buf, int num_rows)
/* General case, no dithering */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  JSAMPARRAY colorindex = cquantize->colorindex;
  register int pixcode, ci;
  register JSAMPROW ptrin, ptrout;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
  register int nc = cinfo->out_color_components;

  for (row = 0; row < num_rows; row++) {
    ptrin = input_buf[row];
    ptrout = output_buf[row];
    for (col = width; col > 0; col--) {
      pixcode = 0;
      for (ci = 0; ci < nc; ci++) {
	pixcode += GETJSAMPLE(colorindex[ci][GETJSAMPLE(*ptrin++)]);
      }
      *ptrout++ = (JSAMPLE) pixcode;
    }
  }
}


METHODDEF(void)
color_quantize3 (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		 JSAMPARRAY output_buf, int num_rows)
/* Fast path for out_color_components==3, no dithering */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  register int pixcode;
  register JSAMPROW ptrin, ptrout;
  JSAMPROW colorindex0 = cquantize->colorindex[0];
  JSAMPROW colorindex1 = cquantize->colorindex[1];
  JSAMPROW colorindex2 = cquantize->colorindex[2];
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    ptrin = input_buf[row];
    ptrout = output_buf[row];
    for (col = width; col > 0; col--) {
      pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*ptrin++)]);
      pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*ptrin++)]);
      pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*ptrin++)]);
      *ptrout++ = (JSAMPLE) pixcode;
    }
  }
}


METHODDEF(void)
quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		     JSAMPARRAY output_buf, int num_rows)
/* General case, with ordered dithering */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  register JSAMPROW input_ptr;
  register JSAMPROW output_ptr;
  JSAMPROW colorindex_ci;
  int * dither;			/* points to active row of dither matrix */
  int row_index, col_index;	/* current indexes into dither matrix */
  int nc = cinfo->out_color_components;
  int ci;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    /* Initialize output values to 0 so can process components separately */
    jzero_far((void FAR *) output_buf[row],
	      (size_t) (width * SIZEOF(JSAMPLE)));
    row_index = cquantize->row_index;
    for (ci = 0; ci < nc; ci++) {
      input_ptr = input_buf[row] + ci;
      output_ptr = output_buf[row];
      colorindex_ci = cquantize->colorindex[ci];
      dither = cquantize->odither[ci][row_index];
      col_index = 0;

      for (col = width; col > 0; col--) {
	/* Form pixel value + dither, range-limit to 0..MAXJSAMPLE,
	 * select output value, accumulate into output code for this pixel.
	 * Range-limiting need not be done explicitly, as we have extended
	 * the colorindex table to produce the right answers for out-of-range
	 * inputs.  The maximum dither is +- MAXJSAMPLE; this sets the
	 * required amount of padding.
	 */
	*output_ptr += colorindex_ci[GETJSAMPLE(*input_ptr)+dither[col_index]];
	input_ptr += nc;
	output_ptr++;
	col_index = (col_index + 1) & ODITHER_MASK;
      }
    }
    /* Advance row index for next row */
    row_index = (row_index + 1) & ODITHER_MASK;
    cquantize->row_index = row_index;
  }
}


METHODDEF(void)
quantize3_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		      JSAMPARRAY output_buf, int num_rows)
/* Fast path for out_color_components==3, with ordered dithering */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  register int pixcode;
  register JSAMPROW input_ptr;
  register JSAMPROW output_ptr;
  JSAMPROW colorindex0 = cquantize->colorindex[0];
  JSAMPROW colorindex1 = cquantize->colorindex[1];
  JSAMPROW colorindex2 = cquantize->colorindex[2];
  int * dither0;		/* points to active row of dither matrix */
  int * dither1;
  int * dither2;
  int row_index, col_index;	/* current indexes into dither matrix */
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    row_index = cquantize->row_index;
    input_ptr = input_buf[row];
    output_ptr = output_buf[row];
    dither0 = cquantize->odither[0][row_index];
    dither1 = cquantize->odither[1][row_index];
    dither2 = cquantize->odither[2][row_index];
    col_index = 0;

    for (col = width; col > 0; col--) {
      pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*input_ptr++) +
					dither0[col_index]]);
      pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*input_ptr++) +
					dither1[col_index]]);
      pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*input_ptr++) +
					dither2[col_index]]);
      *output_ptr++ = (JSAMPLE) pixcode;
      col_index = (col_index + 1) & ODITHER_MASK;
    }
    row_index = (row_index + 1) & ODITHER_MASK;
    cquantize->row_index = row_index;
  }
}


METHODDEF(void)
quantize_fs_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		    JSAMPARRAY output_buf, int num_rows)
/* General case, with Floyd-Steinberg dithering */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  register LOCFSERROR cur;	/* current error or pixel value */
  LOCFSERROR belowerr;		/* error for pixel below cur */
  LOCFSERROR bpreverr;		/* error for below/prev col */
  LOCFSERROR bnexterr;		/* error for below/next col */
  LOCFSERROR delta;
  register FSERRPTR errorptr;	/* => fserrors[] at column before current */
  register JSAMPROW input_ptr;
  register JSAMPROW output_ptr;
  JSAMPROW colorindex_ci;
  JSAMPROW colormap_ci;
  int pixcode;
  int nc = cinfo->out_color_components;
  int dir;			/* 1 for left-to-right, -1 for right-to-left */
  int dirnc;			/* dir * nc */
  int ci;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
  JSAMPLE *range_limit = cinfo->sample_range_limit;
  SHIFT_TEMPS

  for (row = 0; row < num_rows; row++) {
    /* Initialize output values to 0 so can process components separately */
    jzero_far((void FAR *) output_buf[row],
	      (size_t) (width * SIZEOF(JSAMPLE)));
    for (ci = 0; ci < nc; ci++) {
      input_ptr = input_buf[row] + ci;
      output_ptr = output_buf[row];
      if (cquantize->on_odd_row) {
	/* work right to left in this row */
	input_ptr += (width-1) * nc; /* so point to rightmost pixel */
	output_ptr += width-1;
	dir = -1;
	dirnc = -nc;
	errorptr = cquantize->fserrors[ci] + (width+1); /* => entry after last column */
      } else {
	/* work left to right in this row */
	dir = 1;
	dirnc = nc;
	errorptr = cquantize->fserrors[ci]; /* => entry before first column */
      }
      colorindex_ci = cquantize->colorindex[ci];
      colormap_ci = cquantize->sv_colormap[ci];
      /* Preset error values: no error propagated to first pixel from left */
      cur = 0;
      /* and no error propagated to row below yet */
      belowerr = bpreverr = 0;

      for (col = width; col > 0; col--) {
	/* cur holds the error propagated from the previous pixel on the
	 * current line.  Add the error propagated from the previous line
	 * to form the complete error correction term for this pixel, and
	 * round the error term (which is expressed * 16) to an integer.
	 * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
	 * for either sign of the error value.
	 * Note: errorptr points to *previous* column's array entry.
	 */
	cur = RIGHT_SHIFT(cur + errorptr[dir] + 8, 4);
	/* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
	 * The maximum error is +- MAXJSAMPLE; this sets the required size
	 * of the range_limit array.
	 */
	cur += GETJSAMPLE(*input_ptr);
	cur = GETJSAMPLE(range_limit[cur]);
	/* Select output value, accumulate into output code for this pixel */
	pixcode = GETJSAMPLE(colorindex_ci[cur]);
	*output_ptr += (JSAMPLE) pixcode;
	/* Compute actual representation error at this pixel */
	/* Note: we can do this even though we don't have the final */
	/* pixel code, because the colormap is orthogonal. */
	cur -= GETJSAMPLE(colormap_ci[pixcode]);
	/* Compute error fractions to be propagated to adjacent pixels.
	 * Add these into the running sums, and simultaneously shift the
	 * next-line error sums left by 1 column.
	 */
	bnexterr = cur;
	delta = cur * 2;
	cur += delta;		/* form error * 3 */
	errorptr[0] = (FSERROR) (bpreverr + cur);
	cur += delta;		/* form error * 5 */
	bpreverr = belowerr + cur;
	belowerr = bnexterr;
	cur += delta;		/* form error * 7 */
	/* At this point cur contains the 7/16 error value to be propagated
	 * to the next pixel on the current line, and all the errors for the
	 * next line have been shifted over. We are therefore ready to move on.
	 */
	input_ptr += dirnc;	/* advance input ptr to next column */
	output_ptr += dir;	/* advance output ptr to next column */
	errorptr += dir;	/* advance errorptr to current column */
      }
      /* Post-loop cleanup: we must unload the final error value into the
       * final fserrors[] entry.  Note we need not unload belowerr because
       * it is for the dummy column before or after the actual array.
       */
      errorptr[0] = (FSERROR) bpreverr; /* unload prev err into array */
    }
    cquantize->on_odd_row = (cquantize->on_odd_row ? FALSE : TRUE);
  }
}


/*
 * Allocate workspace for Floyd-Steinberg errors.
 */

LOCAL(void)
alloc_fs_workspace (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  size_t arraysize;
  int i;

  arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
  for (i = 0; i < cinfo->out_color_components; i++) {
    cquantize->fserrors[i] = (FSERRPTR)
      (*cinfo->mem->alloc_large)((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
  }
}


/*
 * Initialize for one-pass color quantization.
 */

METHODDEF(void)
start_pass_1_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  size_t arraysize;
  int i;

  /* Install my colormap. */
  cinfo->colormap = cquantize->sv_colormap;
  cinfo->actual_number_of_colors = cquantize->sv_actual;

  /* Initialize for desired dithering mode. */
  switch (cinfo->dither_mode) {
  case JDITHER_NONE:
    if (cinfo->out_color_components == 3)
      cquantize->pub.color_quantize = color_quantize3;
    else
      cquantize->pub.color_quantize = color_quantize;
    break;
  case JDITHER_ORDERED:
    if (cinfo->out_color_components == 3)
      cquantize->pub.color_quantize = quantize3_ord_dither;
    else
      cquantize->pub.color_quantize = quantize_ord_dither;
    cquantize->row_index = 0;	/* initialize state for ordered dither */
    /* If user changed to ordered dither from another mode,
     * we must recreate the color index table with padding.
     * This will cost extra space, but probably isn't very likely.
     */
    if (! cquantize->is_padded)
      create_colorindex(cinfo);
    /* Create ordered-dither tables if we didn't already. */
    if (cquantize->odither[0] == NULL)
      create_odither_tables(cinfo);
    break;
  case JDITHER_FS:
    cquantize->pub.color_quantize = quantize_fs_dither;
    cquantize->on_odd_row = FALSE; /* initialize state for F-S dither */
    /* Allocate Floyd-Steinberg workspace if didn't already. */
    if (cquantize->fserrors[0] == NULL)
      alloc_fs_workspace(cinfo);
    /* Initialize the propagated errors to zero. */
    arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
    for (i = 0; i < cinfo->out_color_components; i++)
      jzero_far((void FAR *) cquantize->fserrors[i], arraysize);
    break;
  default:
    ERREXIT(cinfo, JERR_NOT_COMPILED);
    break;
  }
}


/*
 * Finish up at the end of the pass.
 */

METHODDEF(void)
finish_pass_1_quant (j_decompress_ptr cinfo)
{
  /* no work in 1-pass case */
}


/*
 * Switch to a new external colormap between output passes.
 * Shouldn't get to this module!
 */

METHODDEF(void)
new_color_map_1_quant (j_decompress_ptr cinfo)
{
  ERREXIT(cinfo, JERR_MODE_CHANGE);
}


/*
 * Module initialization routine for 1-pass color quantization.
 */

GLOBAL(void)
jinit_1pass_quantizer (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize;

  cquantize = (my_cquantize_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_cquantizer));
  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
  cquantize->pub.start_pass = start_pass_1_quant;
  cquantize->pub.finish_pass = finish_pass_1_quant;
  cquantize->pub.new_color_map = new_color_map_1_quant;
  cquantize->fserrors[0] = NULL; /* Flag FS workspace not allocated */
  cquantize->odither[0] = NULL;	/* Also flag odither arrays not allocated */

  /* Make sure my internal arrays won't overflow */
  if (cinfo->out_color_components > MAX_Q_COMPS)
    ERREXIT1(cinfo, JERR_QUANT_COMPONENTS, MAX_Q_COMPS);
  /* Make sure colormap indexes can be represented by JSAMPLEs */
  if (cinfo->desired_number_of_colors > (MAXJSAMPLE+1))
    ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXJSAMPLE+1);

  /* Create the colormap and color index table. */
  create_colormap(cinfo);
  create_colorindex(cinfo);

  /* Allocate Floyd-Steinberg workspace now if requested.
   * We do this now since it is FAR storage and may affect the memory
   * manager's space calculations.  If the user changes to FS dither
   * mode in a later pass, we will allocate the space then, and will
   * possibly overrun the max_memory_to_use setting.
   */
  if (cinfo->dither_mode == JDITHER_FS)
    alloc_fs_workspace(cinfo);
}

#endif /* QUANT_1PASS_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeginc\darwjpeg.h ===
#ifndef __DARWINJPEG
#define __DARWINJPEG

#ifdef JPEGTEST
	#define WIN
	#define ToBool(x) (x)
	#define fTrue TRUE
	#define fFalse FALSE
#else
	#include "common.h"
#endif

extern "C" {
#include "jconfig.h"
}

#ifdef JPEGTEST
	typedef boolean Bool;
#endif

#pragma warning (disable:4005)	// redeclaration of far
#define HAVE_BOOLEAN
#include "jpegdata.h"
#include "jpegdeco.h"
#pragma warning (default:4005)	// redeclaration of far


class CDarwinDatasource : public CJPEGDatasource
{
public:

	CDarwinDatasource (LPBYTE pData, unsigned int len);
	virtual ~CDarwinDatasource ();

	virtual void InitSource (j_decompress_ptr cinfo);
	virtual boolean FillInputBuffer (j_decompress_ptr cinfo);
	virtual void SkipInputData (j_decompress_ptr cinfo, long num_bytes);
	virtual void TermSource (j_decompress_ptr cinfo);

private:

	boolean m_fStartOfFile;
	JOCTET* m_buffer;
	unsigned int m_dataLen;
};

class CDarwinDecompressor : public CJPEGDecompressor
{
public:

	CDarwinDecompressor ();
	virtual ~CDarwinDecompressor ();

	Bool Decompress (HBITMAP& rhBitmap, HPALETTE& rhPalette, 
		Bool fUseDefaultPalette, CDarwinDatasource* dataSource);

protected:

	// Data Target
	virtual void BuildColorMap ();
	virtual void BeginDecompression ();
	virtual void StoreScanline (void* buffer, int row);
	virtual void EndDecompression ();

	// Error handling
	virtual void ErrorExit ();
	virtual void EmitMessage (int msg_level);
	virtual void OutputMessage ();
	virtual void FormatMessage (char* buffer);
	virtual void ResetErrorManager ();

	// Windows Palette handling
	int CreateDefaultColorMap (JSAMPARRAY& colorMap);

private:
	
	HBITMAP m_hBitmap;
	HPALETTE m_hPalette;
	Bool m_fUseDefaultPalette;
	unsigned long m_rowBytes;
	BYTE* m_pBits;
	int m_depth;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeginc\jerror.h ===
/*
 * jerror.h
 *
 * Copyright (C) 1994-1995, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file defines the error and message codes for the JPEG library.
 * Edit this file to add new codes, or to translate the message strings to
 * some other language.
 * A set of error-reporting macros are defined too.  Some applications using
 * the JPEG library may wish to include this file to get the error codes
 * and/or the macros.
 */

/*
 * To define the enum list of message codes, include this file without
 * defining macro JMESSAGE.  To create a message string table, include it
 * again with a suitable JMESSAGE definition (see jerror.c for an example).
 */
#ifndef JMESSAGE
#ifndef JERROR_H
/* First time through, define the enum list */
#define JMAKE_ENUM_LIST
#else
/* Repeated inclusions of this file are no-ops unless JMESSAGE is defined */
#define JMESSAGE(code,string)
#endif /* JERROR_H */
#endif /* JMESSAGE */

#ifdef JMAKE_ENUM_LIST

typedef enum {

#define JMESSAGE(code,string)	code ,

#endif /* JMAKE_ENUM_LIST */

JMESSAGE(JMSG_NOMESSAGE, "Bogus message code %d") /* Must be first entry! */

/* For maintenance convenience, list is alphabetical by message code name */
JMESSAGE(JERR_ARITH_NOTIMPL,
	 "Sorry, there are legal restrictions on arithmetic coding")
JMESSAGE(JERR_BAD_ALIGN_TYPE, "ALIGN_TYPE is wrong, please fix")
JMESSAGE(JERR_BAD_ALLOC_CHUNK, "MAX_ALLOC_CHUNK is wrong, please fix")
JMESSAGE(JERR_BAD_BUFFER_MODE, "Bogus buffer control mode")
JMESSAGE(JERR_BAD_COMPONENT_ID, "Invalid component ID %d in SOS")
JMESSAGE(JERR_BAD_DCTSIZE, "IDCT output block size %d not supported")
JMESSAGE(JERR_BAD_IN_COLORSPACE, "Bogus input colorspace")
JMESSAGE(JERR_BAD_J_COLORSPACE, "Bogus JPEG colorspace")
JMESSAGE(JERR_BAD_LENGTH, "Bogus marker length")
JMESSAGE(JERR_BAD_LIB_VERSION,
	 "Wrong JPEG library version: library is %d, caller expects %d")
JMESSAGE(JERR_BAD_MCU_SIZE, "Sampling factors too large for interleaved scan")
JMESSAGE(JERR_BAD_POOL_ID, "Invalid memory pool code %d")
JMESSAGE(JERR_BAD_PRECISION, "Unsupported JPEG data precision %d")
JMESSAGE(JERR_BAD_PROGRESSION,
	 "Invalid progressive parameters Ss=%d Se=%d Ah=%d Al=%d")
JMESSAGE(JERR_BAD_PROG_SCRIPT,
	 "Invalid progressive parameters at scan script entry %d")
JMESSAGE(JERR_BAD_SAMPLING, "Bogus sampling factors")
JMESSAGE(JERR_BAD_SCAN_SCRIPT, "Invalid scan script at entry %d")
JMESSAGE(JERR_BAD_STATE, "Improper call to JPEG library in state %d")
JMESSAGE(JERR_BAD_STRUCT_SIZE,
	 "JPEG parameter struct mismatch: library thinks size is %u, caller expects %u")
JMESSAGE(JERR_BAD_VIRTUAL_ACCESS, "Bogus virtual array access")
JMESSAGE(JERR_BUFFER_SIZE, "Buffer passed to JPEG library is too small")
JMESSAGE(JERR_CANT_SUSPEND, "Suspension not allowed here")
JMESSAGE(JERR_CCIR601_NOTIMPL, "CCIR601 sampling not implemented yet")
JMESSAGE(JERR_COMPONENT_COUNT, "Too many color components: %d, max %d")
JMESSAGE(JERR_CONVERSION_NOTIMPL, "Unsupported color conversion request")
JMESSAGE(JERR_DAC_INDEX, "Bogus DAC index %d")
JMESSAGE(JERR_DAC_VALUE, "Bogus DAC value 0x%x")
JMESSAGE(JERR_DHT_COUNTS, "Bogus DHT counts")
JMESSAGE(JERR_DHT_INDEX, "Bogus DHT index %d")
JMESSAGE(JERR_DQT_INDEX, "Bogus DQT index %d")
JMESSAGE(JERR_EMPTY_IMAGE, "Empty JPEG image (DNL not supported)")
JMESSAGE(JERR_EMS_READ, "Read from EMS failed")
JMESSAGE(JERR_EMS_WRITE, "Write to EMS failed")
JMESSAGE(JERR_EOI_EXPECTED, "Didn't expect more than one scan")
JMESSAGE(JERR_FILE_READ, "Input file read error")
JMESSAGE(JERR_FILE_WRITE, "Output file write error --- out of disk space?")
JMESSAGE(JERR_FRACT_SAMPLE_NOTIMPL, "Fractional sampling not implemented yet")
JMESSAGE(JERR_HUFF_CLEN_OVERFLOW, "Huffman code size table overflow")
JMESSAGE(JERR_HUFF_MISSING_CODE, "Missing Huffman code table entry")
JMESSAGE(JERR_IMAGE_TOO_BIG, "Maximum supported image dimension is %u pixels")
JMESSAGE(JERR_INPUT_EMPTY, "Empty input file")
JMESSAGE(JERR_INPUT_EOF, "Premature end of input file")
JMESSAGE(JERR_MISMATCHED_QUANT_TABLE,
	 "Cannot transcode due to multiple use of quantization table %d")
JMESSAGE(JERR_MISSING_DATA, "Scan script does not transmit all data")
JMESSAGE(JERR_MODE_CHANGE, "Invalid color quantization mode change")
JMESSAGE(JERR_NOTIMPL, "Not implemented yet")
JMESSAGE(JERR_NOT_COMPILED, "Requested feature was omitted at compile time")
JMESSAGE(JERR_NO_BACKING_STORE, "Backing store not supported")
JMESSAGE(JERR_NO_HUFF_TABLE, "Huffman table 0x%02x was not defined")
JMESSAGE(JERR_NO_IMAGE, "JPEG datastream contains no image")
JMESSAGE(JERR_NO_QUANT_TABLE, "Quantization table 0x%02x was not defined")
JMESSAGE(JERR_NO_SOI, "Not a JPEG file: starts with 0x%02x 0x%02x")
JMESSAGE(JERR_OUT_OF_MEMORY, "Insufficient memory (case %d)")
JMESSAGE(JERR_QUANT_COMPONENTS,
	 "Cannot quantize more than %d color components")
JMESSAGE(JERR_QUANT_FEW_COLORS, "Cannot quantize to fewer than %d colors")
JMESSAGE(JERR_QUANT_MANY_COLORS, "Cannot quantize to more than %d colors")
JMESSAGE(JERR_SOF_DUPLICATE, "Invalid JPEG file structure: two SOF markers")
JMESSAGE(JERR_SOF_NO_SOS, "Invalid JPEG file structure: missing SOS marker")
JMESSAGE(JERR_SOF_UNSUPPORTED, "Unsupported JPEG process: SOF type 0x%02x")
JMESSAGE(JERR_SOI_DUPLICATE, "Invalid JPEG file structure: two SOI markers")
JMESSAGE(JERR_SOS_NO_SOF, "Invalid JPEG file structure: SOS before SOF")
JMESSAGE(JERR_TFILE_CREATE, "Failed to create temporary file %s")
JMESSAGE(JERR_TFILE_READ, "Read failed on temporary file")
JMESSAGE(JERR_TFILE_SEEK, "Seek failed on temporary file")
JMESSAGE(JERR_TFILE_WRITE,
	 "Write failed on temporary file --- out of disk space?")
JMESSAGE(JERR_TOO_LITTLE_DATA, "Application transferred too few scanlines")
JMESSAGE(JERR_UNKNOWN_MARKER, "Unsupported marker type 0x%02x")
JMESSAGE(JERR_VIRTUAL_BUG, "Virtual array controller messed up")
JMESSAGE(JERR_WIDTH_OVERFLOW, "Image too wide for this implementation")
JMESSAGE(JERR_XMS_READ, "Read from XMS failed")
JMESSAGE(JERR_XMS_WRITE, "Write to XMS failed")
JMESSAGE(JMSG_COPYRIGHT, JCOPYRIGHT)
JMESSAGE(JMSG_VERSION, JVERSION)
JMESSAGE(JTRC_16BIT_TABLES,
	 "Caution: quantization tables are too coarse for baseline JPEG")
JMESSAGE(JTRC_ADOBE,
	 "Adobe APP14 marker: version %d, flags 0x%04x 0x%04x, transform %d")
JMESSAGE(JTRC_APP0, "Unknown APP0 marker (not JFIF), length %u")
JMESSAGE(JTRC_APP14, "Unknown APP14 marker (not Adobe), length %u")
JMESSAGE(JTRC_DAC, "Define Arithmetic Table 0x%02x: 0x%02x")
JMESSAGE(JTRC_DHT, "Define Huffman Table 0x%02x")
JMESSAGE(JTRC_DQT, "Define Quantization Table %d  precision %d")
JMESSAGE(JTRC_DRI, "Define Restart Interval %u")
JMESSAGE(JTRC_EMS_CLOSE, "Freed EMS handle %u")
JMESSAGE(JTRC_EMS_OPEN, "Obtained EMS handle %u")
JMESSAGE(JTRC_EOI, "End Of Image")
JMESSAGE(JTRC_HUFFBITS, "        %3d %3d %3d %3d %3d %3d %3d %3d")
JMESSAGE(JTRC_JFIF, "JFIF APP0 marker, density %dx%d  %d")
JMESSAGE(JTRC_JFIF_BADTHUMBNAILSIZE,
	 "Warning: thumbnail image size does not match data length %u")
JMESSAGE(JTRC_JFIF_MINOR, "Unknown JFIF minor revision number %d.%02d")
JMESSAGE(JTRC_JFIF_THUMBNAIL, "    with %d x %d thumbnail image")
JMESSAGE(JTRC_MISC_MARKER, "Skipping marker 0x%02x, length %u")
JMESSAGE(JTRC_PARMLESS_MARKER, "Unexpected marker 0x%02x")
JMESSAGE(JTRC_QUANTVALS, "        %4u %4u %4u %4u %4u %4u %4u %4u")
JMESSAGE(JTRC_QUANT_3_NCOLORS, "Quantizing to %d = %d*%d*%d colors")
JMESSAGE(JTRC_QUANT_NCOLORS, "Quantizing to %d colors")
JMESSAGE(JTRC_QUANT_SELECTED, "Selected %d colors for quantization")
JMESSAGE(JTRC_RECOVERY_ACTION, "At marker 0x%02x, recovery action %d")
JMESSAGE(JTRC_RST, "RST%d")
JMESSAGE(JTRC_SMOOTH_NOTIMPL,
	 "Smoothing not supported with nonstandard sampling ratios")
JMESSAGE(JTRC_SOF, "Start Of Frame 0x%02x: width=%u, height=%u, components=%d")
JMESSAGE(JTRC_SOF_COMPONENT, "    Component %d: %dhx%dv q=%d")
JMESSAGE(JTRC_SOI, "Start of Image")
JMESSAGE(JTRC_SOS, "Start Of Scan: %d components")
JMESSAGE(JTRC_SOS_COMPONENT, "    Component %d: dc=%d ac=%d")
JMESSAGE(JTRC_SOS_PARAMS, "  Ss=%d, Se=%d, Ah=%d, Al=%d")
JMESSAGE(JTRC_TFILE_CLOSE, "Closed temporary file %s")
JMESSAGE(JTRC_TFILE_OPEN, "Opened temporary file %s")
JMESSAGE(JTRC_UNKNOWN_IDS,
	 "Unrecognized component IDs %d %d %d, assuming YCbCr")
JMESSAGE(JTRC_XMS_CLOSE, "Freed XMS handle %u")
JMESSAGE(JTRC_XMS_OPEN, "Obtained XMS handle %u")
JMESSAGE(JWRN_ADOBE_XFORM, "Unknown Adobe color transform code %d")
JMESSAGE(JWRN_BOGUS_PROGRESSION,
	 "Inconsistent progression sequence for component %d coefficient %d")
JMESSAGE(JWRN_EXTRANEOUS_DATA,
	 "Corrupt JPEG data: %u extraneous bytes before marker 0x%02x")
JMESSAGE(JWRN_HIT_MARKER, "Corrupt JPEG data: premature end of data segment")
JMESSAGE(JWRN_HUFF_BAD_CODE, "Corrupt JPEG data: bad Huffman code")
JMESSAGE(JWRN_JFIF_MAJOR, "Warning: unknown JFIF revision number %d.%02d")
JMESSAGE(JWRN_JPEG_EOF, "Premature end of JPEG file")
JMESSAGE(JWRN_MUST_RESYNC,
	 "Corrupt JPEG data: found marker 0x%02x instead of RST%d")
JMESSAGE(JWRN_NOT_SEQUENTIAL, "Invalid SOS parameters for sequential JPEG")
JMESSAGE(JWRN_TOO_MUCH_DATA, "Application transferred too many scanlines")

#ifdef JMAKE_ENUM_LIST

  JMSG_LASTMSGCODE
} J_MESSAGE_CODE;

#undef JMAKE_ENUM_LIST
#endif /* JMAKE_ENUM_LIST */

/* Zap JMESSAGE macro so that future re-inclusions do nothing by default */
#undef JMESSAGE


#ifndef JERROR_H
#define JERROR_H

/* Macros to simplify using the error and trace message stuff */
/* The first parameter is either type of cinfo pointer */

/* Fatal errors (print message and exit) */
#define ERREXIT(cinfo,code)  \
  ((cinfo)->err->msg_code = (code), \
   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
#define ERREXIT1(cinfo,code,p1)  \
  ((cinfo)->err->msg_code = (code), \
   (cinfo)->err->msg_parm.i[0] = (p1), \
   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
#define ERREXIT2(cinfo,code,p1,p2)  \
  ((cinfo)->err->msg_code = (code), \
   (cinfo)->err->msg_parm.i[0] = (p1), \
   (cinfo)->err->msg_parm.i[1] = (p2), \
   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
#define ERREXIT3(cinfo,code,p1,p2,p3)  \
  ((cinfo)->err->msg_code = (code), \
   (cinfo)->err->msg_parm.i[0] = (p1), \
   (cinfo)->err->msg_parm.i[1] = (p2), \
   (cinfo)->err->msg_parm.i[2] = (p3), \
   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
#define ERREXIT4(cinfo,code,p1,p2,p3,p4)  \
  ((cinfo)->err->msg_code = (code), \
   (cinfo)->err->msg_parm.i[0] = (p1), \
   (cinfo)->err->msg_parm.i[1] = (p2), \
   (cinfo)->err->msg_parm.i[2] = (p3), \
   (cinfo)->err->msg_parm.i[3] = (p4), \
   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
#define ERREXITS(cinfo,code,str)  \
  ((cinfo)->err->msg_code = (code), \
   strncpy((cinfo)->err->msg_parm.s, (str), JMSG_STR_PARM_MAX), \
   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))

#define MAKESTMT(stuff)		do { stuff } while (0)

/* Nonfatal errors (we can keep going, but the data is probably corrupt) */
#define WARNMS(cinfo,code)  \
  ((cinfo)->err->msg_code = (code), \
   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))
#define WARNMS1(cinfo,code,p1)  \
  ((cinfo)->err->msg_code = (code), \
   (cinfo)->err->msg_parm.i[0] = (p1), \
   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))
#define WARNMS2(cinfo,code,p1,p2)  \
  ((cinfo)->err->msg_code = (code), \
   (cinfo)->err->msg_parm.i[0] = (p1), \
   (cinfo)->err->msg_parm.i[1] = (p2), \
   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))

/* Informational/debugging messages */
#define TRACEMS(cinfo,lvl,code)  \
  ((cinfo)->err->msg_code = (code), \
   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
#define TRACEMS1(cinfo,lvl,code,p1)  \
  ((cinfo)->err->msg_code = (code), \
   (cinfo)->err->msg_parm.i[0] = (p1), \
   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
#define TRACEMS2(cinfo,lvl,code,p1,p2)  \
  ((cinfo)->err->msg_code = (code), \
   (cinfo)->err->msg_parm.i[0] = (p1), \
   (cinfo)->err->msg_parm.i[1] = (p2), \
   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
#define TRACEMS3(cinfo,lvl,code,p1,p2,p3)  \
  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
	   _mp[0] = (p1); _mp[1] = (p2); _mp[2] = (p3); \
	   (cinfo)->err->msg_code = (code); \
	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
#define TRACEMS4(cinfo,lvl,code,p1,p2,p3,p4)  \
  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
	   _mp[0] = (p1); _mp[1] = (p2); _mp[2] = (p3); _mp[3] = (p4); \
	   (cinfo)->err->msg_code = (code); \
	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
#define TRACEMS8(cinfo,lvl,code,p1,p2,p3,p4,p5,p6,p7,p8)  \
  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
	   _mp[0] = (p1); _mp[1] = (p2); _mp[2] = (p3); _mp[3] = (p4); \
	   _mp[4] = (p5); _mp[5] = (p6); _mp[6] = (p7); _mp[7] = (p8); \
	   (cinfo)->err->msg_code = (code); \
	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
#define TRACEMSS(cinfo,lvl,code,str)  \
  ((cinfo)->err->msg_code = (code), \
   strncpy((cinfo)->err->msg_parm.s, (str), JMSG_STR_PARM_MAX), \
   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))

#endif /* JERROR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeginc\jconfig.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       jconfig.h
//
//--------------------------------------------------------------------------

/*
 * jconfig.doc
 *
 * Copyright (C) 1991-1994, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file documents the configuration options that are required to
 * customize the JPEG software for a particular system.
 *
 * The actual configuration options for a particular installation are stored
 * in jconfig.h.  On many machines, jconfig.h can be generated automatically
 * or copied from one of the "canned" jconfig files that we supply.  But if
 * you need to generate a jconfig.h file by hand, this file tells you how.
 *
 * DO NOT EDIT THIS FILE --- IT WON'T ACCOMPLISH ANYTHING.
 * EDIT A COPY NAMED JCONFIG.H.
 */
//  header problem: everybody wants to define boolean differently.
#ifndef HAVE_BOOLEAN
	#define HAVE_BOOLEAN
	typedef unsigned char boolean;
#endif

/*
 * These symbols indicate the properties of your machine or compiler.
 * #define the symbol if yes, #undef it if no.
 */

/* Does your compiler support function prototypes?
 * (If not, you also need to use ansi2knr, see install.doc)
 */
#define HAVE_PROTOTYPES

/* Does your compiler support the declaration "unsigned char" ?
 * How about "unsigned short" ?
 */
#define HAVE_UNSIGNED_CHAR
#define HAVE_UNSIGNED_SHORT

/* Define "void" as "char" if your compiler doesn't know about type void.
 * NOTE: be sure to define void such that "void *" represents the most general
 * pointer type, e.g., that returned by malloc().
 */
/* #define void char */

/* Define "const" as empty if your compiler doesn't know the "const" keyword.
 */
/* #define const */

/* Define this if an ordinary "char" type is unsigned.
 * If you're not sure, leaving it undefined will work at some cost in speed.
 * If you defined HAVE_UNSIGNED_CHAR then the speed difference is minimal.
 */
#undef CHAR_IS_UNSIGNED

/* Define this if your system has an ANSI-conforming <stddef.h> file.
 */
#define HAVE_STDDEF_H

/* Define this if your system has an ANSI-conforming <stdlib.h> file.
 */
#define HAVE_STDLIB_H

/* Define this if your system does not have an ANSI/SysV <string.h>,
 * but does have a BSD-style <strings.h>.
 */
#undef NEED_BSD_STRINGS

/* Define this if your system does not provide typedef size_t in any of the
 * ANSI-standard places (stddef.h, stdlib.h, or stdio.h), but places it in
 * <sys/types.h> instead.
 */
#undef NEED_SYS_TYPES_H

/* For 80x86 machines, you need to define NEED_FAR_POINTERS,
 * unless you are using a large-data memory model or 80386 flat-memory mode.
 * On less intelegent CPUs this symbol must not be defined.
 * (Defining this symbol causes large data structures to be referenced through
 * "far" pointers and to be allocated with a special version of malloc.)
 */
#undef NEED_FAR_POINTERS

/* Define this if your linker needs global names to be unique in less
 * than the first 15 characters.
 */
#undef NEED_SHORT_EXTERNAL_NAMES

/* Although a real ANSI C compiler can deal perfectly well with pointers to
 * unspecified structures (see "incomplete types" in the spec), a few pre-ANSI
 * and pseudo-ANSI compilers get confused.  To keep one of these happy,
 * define INCOMPLETE_TYPES_BROKEN.  This is not recommended unless you
 * actually get "missing structure definition" warnings or errors while
 * compiling the JPEG code.
 */
#undef INCOMPLETE_TYPES_BROKEN


/*
 * The following options affect code selection within the JPEG library,
 * but they don't need to be visible to applications using the library.
 * To minimize application namespace pollution, the symbols won't be
 * defined unless JPEG_INTERNALS has been defined.
 */

#ifdef JPEG_INTERNALS

/* Define this if your compiler implements ">>" on signed values as a logical
 * (unsigned) shift; leave it undefined if ">>" is a signed (arithmetic) shift,
 * which is the normal and rational definition.
 */
#undef RIGHT_SHIFT_IS_UNSIGNED


#endif /* JPEG_INTERNALS */


/*
 * The remaining options do not affect the JPEG library proper,
 * but only the sample applications cjpeg/djpeg (see cjpeg.c, djpeg.c).
 * Other applications can ignore these.
 */

#ifdef JPEG_CJPEG_DJPEG

/* These defines indicate which image (non-JPEG) file formats are allowed. */

#define BMP_SUPPORTED		/* BMP image file format */
#define GIF_SUPPORTED		/* GIF image file format */
#define PPM_SUPPORTED		/* PBMPLUS PPM/PGM image file format */
#undef RLE_SUPPORTED		/* Utah RLE image file format */
#define TARGA_SUPPORTED		/* Targa image file format */

/* Define this if you want to name both input and output files on the command
 * line, rather than using stdout and optionally stdin.  You MUST do this if
 * your system can't cope with binary I/O to stdin/stdout.  See comments at
 * head of cjpeg.c or djpeg.c.
 */
#undef TWO_FILE_COMMANDLINE

/* Define this if your system needs explicit cleanup of temporary files.
 * This is crucial under MS-DOS, where the temporary "files" may be areas
 * of extended memory; on most other systems it's not as important.
 */
#undef NEED_SIGNAL_CATCHER

/* By default, we open image files with fopen(...,"rb") or fopen(...,"wb").
 * This is necessary on systems that distinguish text files from binary files,
 * and is harmless on most systems that don't.  If you have one of the rare
 * systems that complains about the "b" spec, define this symbol.
 */
#undef DONT_USE_B_MODE

/* Define this if you want percent-done progress reports from cjpeg/djpeg.
 */
#undef PROGRESS_REPORT


#endif /* JPEG_CJPEG_DJPEG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeginc\jdct.h ===
/*
 * jdct.h
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This include file contains common declarations for the forward and
 * inverse DCT modules.  These declarations are private to the DCT managers
 * (jcdctmgr.c, jddctmgr.c) and the individual DCT algorithms.
 * The individual DCT algorithms are kept in separate files to ease 
 * machine-dependent tuning (e.g., assembly coding).
 */


/*
 * A forward DCT routine is given a pointer to a work area of type DCTELEM[];
 * the DCT is to be performed in-place in that buffer.  Type DCTELEM is int
 * for 8-bit samples, INT32 for 12-bit samples.  (NOTE: Floating-point DCT
 * implementations use an array of type FAST_FLOAT, instead.)
 * The DCT inputs are expected to be signed (range +-CENTERJSAMPLE).
 * The DCT outputs are returned scaled up by a factor of 8; they therefore
 * have a range of +-8K for 8-bit data, +-128K for 12-bit data.  This
 * convention improves accuracy in integer implementations and saves some
 * work in floating-point ones.
 * Quantization of the output coefficients is done by jcdctmgr.c.
 */

#if BITS_IN_JSAMPLE == 8
typedef int DCTELEM;		/* 16 or 32 bits is fine */
#else
typedef INT32 DCTELEM;		/* must have 32 bits */
#endif

typedef JMETHOD(void, forward_DCT_method_ptr, (DCTELEM * data));
typedef JMETHOD(void, float_DCT_method_ptr, (FAST_FLOAT * data));


/*
 * An inverse DCT routine is given a pointer to the input JBLOCK and a pointer
 * to an output sample array.  The routine must dequantize the input data as
 * well as perform the IDCT; for dequantization, it uses the multiplier table
 * pointed to by compptr->dct_table.  The output data is to be placed into the
 * sample array starting at a specified column.  (Any row offset needed will
 * be applied to the array pointer before it is passed to the IDCT code.)
 * Note that the number of samples emitted by the IDCT routine is
 * DCT_scaled_size * DCT_scaled_size.
 */

/* typedef inverse_DCT_method_ptr is declared in jpegint.h */

/*
 * Each IDCT routine has its own ideas about the best dct_table element type.
 */

typedef MULTIPLIER ISLOW_MULT_TYPE; /* short or int, whichever is faster */
#if BITS_IN_JSAMPLE == 8
typedef MULTIPLIER IFAST_MULT_TYPE; /* 16 bits is OK, use short if faster */
#define IFAST_SCALE_BITS  2	/* fractional bits in scale factors */
#else
typedef INT32 IFAST_MULT_TYPE;	/* need 32 bits for scaled quantizers */
#define IFAST_SCALE_BITS  13	/* fractional bits in scale factors */
#endif
typedef FAST_FLOAT FLOAT_MULT_TYPE; /* preferred floating type */


/*
 * Each IDCT routine is responsible for range-limiting its results and
 * converting them to unsigned form (0..MAXJSAMPLE).  The raw outputs could
 * be quite far out of range if the input data is corrupt, so a bulletproof
 * range-limiting step is required.  We use a mask-and-table-lookup method
 * to do the combined operations quickly.  See the comments with
 * prepare_range_limit_table (in jdmaster.c) for more info.
 */

#define IDCT_range_limit(cinfo)  ((cinfo)->sample_range_limit + CENTERJSAMPLE)

#define RANGE_MASK  (MAXJSAMPLE * 4 + 3) /* 2 bits wider than legal samples */


/* Short forms of external names for systems with bad linkers. */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jpeg_fdct_islow		jFDislow
#define jpeg_fdct_ifast		jFDifast
#define jpeg_fdct_float		jFDfloat
#define jpeg_idct_islow		jRDislow
#define jpeg_idct_ifast		jRDifast
#define jpeg_idct_float		jRDfloat
#define jpeg_idct_4x4		jRD4x4
#define jpeg_idct_2x2		jRD2x2
#define jpeg_idct_1x1		jRD1x1
#endif /* NEED_SHORT_EXTERNAL_NAMES */

/* Extern declarations for the forward and inverse DCT routines. */

EXTERN(void) jpeg_fdct_islow JPP((DCTELEM * data));
EXTERN(void) jpeg_fdct_ifast JPP((DCTELEM * data));
EXTERN(void) jpeg_fdct_float JPP((FAST_FLOAT * data));

EXTERN(void) jpeg_idct_islow
    JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
	 JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col));
EXTERN(void) jpeg_idct_ifast
    JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
	 JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col));
EXTERN(void) jpeg_idct_float
    JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
	 JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col));
EXTERN(void) jpeg_idct_4x4
    JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
	 JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col));
EXTERN(void) jpeg_idct_2x2
    JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
	 JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col));
EXTERN(void) jpeg_idct_1x1
    JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
	 JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col));


/*
 * Macros for handling fixed-point arithmetic; these are used by many
 * but not all of the DCT/IDCT modules.
 *
 * All values are expected to be of type INT32.
 * Fractional constants are scaled left by CONST_BITS bits.
 * CONST_BITS is defined within each module using these macros,
 * and may differ from one module to the next.
 */

#define ONE	((INT32) 1)
#define CONST_SCALE (ONE << CONST_BITS)

/* Convert a positive real constant to an integer scaled by CONST_SCALE.
 * Caution: some C compilers fail to reduce "FIX(constant)" at compile time,
 * thus causing a lot of useless floating-point operations at run time.
 */

#define FIX(x)	((INT32) ((x) * CONST_SCALE + 0.5))

/* Descale and correctly round an INT32 value that's scaled by N bits.
 * We assume RIGHT_SHIFT rounds towards minus infinity, so adding
 * the fudge factor is correct for either sign of X.
 */

#define DESCALE(x,n)  RIGHT_SHIFT((x) + (ONE << ((n)-1)), n)

/* Multiply an INT32 variable by an INT32 constant to yield an INT32 result.
 * This macro is used only when the two inputs will actually be no more than
 * 16 bits wide, so that a 16x16->32 bit multiply can be used instead of a
 * full 32x32 multiply.  This provides a useful speedup on many machines.
 * Unfortunately there is no way to specify a 16x16->32 multiply portably
 * in C, but some C compilers will do the right thing if you provide the
 * correct combination of casts.
 */

#ifdef SHORTxSHORT_32		/* may work if 'int' is 32 bits */
#define MULTIPLY16C16(var,const)  (((INT16) (var)) * ((INT16) (const)))
#endif
#ifdef SHORTxLCONST_32		/* known to work with Microsoft C 6.0 */
#define MULTIPLY16C16(var,const)  (((INT16) (var)) * ((INT32) (const)))
#endif

#ifndef MULTIPLY16C16		/* default definition */
#define MULTIPLY16C16(var,const)  ((var) * (const))
#endif

/* Same except both inputs are variables. */

#ifdef SHORTxSHORT_32		/* may work if 'int' is 32 bits */
#define MULTIPLY16V16(var1,var2)  (((INT16) (var1)) * ((INT16) (var2)))
#endif

#ifndef MULTIPLY16V16		/* default definition */
#define MULTIPLY16V16(var1,var2)  ((var1) * (var2))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeginc\jinclude.h ===
/*
 * jinclude.h
 *
 * Copyright (C) 1991-1994, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file exists to provide a single place to fix any problems with
 * including the wrong system include files.  (Common problems are taken
 * care of by the standard jconfig symbols, but on really weird systems
 * you may have to edit this file.)
 *
 * NOTE: this file is NOT intended to be included by applications using the
 * JPEG library.  Most applications need only include jpeglib.h.
 */


/* Include auto-config file to find out which system include files we need. */

#include "jconfig.h"		/* auto configuration options */
#define JCONFIG_INCLUDED	/* so that jpeglib.h doesn't do it again */

/*
 * We need the NULL macro and size_t typedef.
 * On an ANSI-conforming system it is sufficient to include <stddef.h>.
 * Otherwise, we get them from <stdlib.h> or <stdio.h>; we may have to
 * pull in <sys/types.h> as well.
 * Note that the core JPEG library does not require <stdio.h>;
 * only the default error handler and data source/destination modules do.
 * But we must pull it in because of the references to FILE in jpeglib.h.
 * You can remove those references if you want to compile without <stdio.h>.
 */

#ifdef HAVE_STDDEF_H
#include <stddef.h>
#endif

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#ifdef NEED_SYS_TYPES_H
#include <sys/types.h>
#endif

#include <stdio.h>

/*
 * We need memory copying and zeroing functions, plus strncpy().
 * ANSI and System V implementations declare these in <string.h>.
 * BSD doesn't have the mem() functions, but it does have bcopy()/bzero().
 * Some systems may declare memset and memcpy in <memory.h>.
 *
 * NOTE: we assume the size parameters to these functions are of type size_t.
 * Change the casts in these macros if not!
 */

#ifdef NEED_BSD_STRINGS

#include <strings.h>
#define MEMZERO(target,size)	bzero((void *)(target), (size_t)(size))
#define MEMCOPY(dest,src,size)	bcopy((const void *)(src), (void *)(dest), (size_t)(size))

#else /* not BSD, assume ANSI/SysV string lib */

#include <string.h>
#define MEMZERO(target,size)	memset((void *)(target), 0, (size_t)(size))
#define MEMCOPY(dest,src,size)	memcpy((void *)(dest), (const void *)(src), (size_t)(size))

#endif

/*
 * In ANSI C, and indeed any rational implementation, size_t is also the
 * type returned by sizeof().  However, it seems there are some irrational
 * implementations out there, in which sizeof() returns an int even though
 * size_t is defined as long or unsigned long.  To ensure consistent results
 * we always use this SIZEOF() macro in place of using sizeof() directly.
 */

#define SIZEOF(object)	((size_t) sizeof(object))

/*
 * The modules that use fread() and fwrite() always invoke them through
 * these macros.  On some systems you may need to twiddle the argument casts.
 * CAUTION: argument order is different from underlying functions!
 */

#define JFREAD(file,buf,sizeofbuf)  \
  ((size_t) fread((void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))
#define JFWRITE(file,buf,sizeofbuf)  \
  ((size_t) fwrite((const void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeginc\jmemsys.h ===
/*
 * jmemsys.h
 *
 * Copyright (C) 1992-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This include file defines the interface between the system-independent
 * and system-dependent portions of the JPEG memory manager.  No other
 * modules need include it.  (The system-independent portion is jmemmgr.c;
 * there are several different versions of the system-dependent portion.)
 *
 * This file works as-is for the system-dependent memory managers supplied
 * in the IJG distribution.  You may need to modify it if you write a
 * custom memory manager.  If system-dependent changes are needed in
 * this file, the best method is to #ifdef them based on a configuration
 * symbol supplied in jconfig.h, as we have done with USE_MSDOS_MEMMGR.
 */


/* Short forms of external names for systems with bad linkers. */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jpeg_get_small		jGetSmall
#define jpeg_free_small		jFreeSmall
#define jpeg_get_large		jGetLarge
#define jpeg_free_large		jFreeLarge
#define jpeg_mem_available	jMemAvail
#define jpeg_open_backing_store	jOpenBackStore
#define jpeg_mem_init		jMemInit
#define jpeg_mem_term		jMemTerm
#endif /* NEED_SHORT_EXTERNAL_NAMES */


/*
 * These two functions are used to allocate and release small chunks of
 * memory.  (Typically the total amount requested through jpeg_get_small is
 * no more than 20K or so; this will be requested in chunks of a few K each.)
 * Behavior should be the same as for the standard library functions malloc
 * and free; in particular, jpeg_get_small must return NULL on failure.
 * On most systems, these ARE malloc and free.  jpeg_free_small is passed the
 * size of the object being freed, just in case it's needed.
 * On an 80x86 machine using small-data memory model, these manage near heap.
 */

EXTERN(void *) jpeg_get_small JPP((j_common_ptr cinfo, size_t sizeofobject));
EXTERN(void) jpeg_free_small JPP((j_common_ptr cinfo, void * object,
				  size_t sizeofobject));

/*
 * These two functions are used to allocate and release large chunks of
 * memory (up to the total free space designated by jpeg_mem_available).
 * The interface is the same as above, except that on an 80x86 machine,
 * far pointers are used.  On most other machines these are identical to
 * the jpeg_get/free_small routines; but we keep them separate anyway,
 * in case a different allocation strategy is desirable for large chunks.
 */

EXTERN(void FAR *) jpeg_get_large JPP((j_common_ptr cinfo,
				       size_t sizeofobject));
EXTERN(void) jpeg_free_large JPP((j_common_ptr cinfo, void FAR * object,
				  size_t sizeofobject));

/*
 * The macro MAX_ALLOC_CHUNK designates the maximum number of bytes that may
 * be requested in a single call to jpeg_get_large (and jpeg_get_small for that
 * matter, but that case should never come into play).  This macro is needed
 * to model the 64Kb-segment-size limit of far addressing on 80x86 machines.
 * On those machines, we expect that jconfig.h will provide a proper value.
 * On machines with 32-bit flat address spaces, any large constant may be used.
 *
 * NB: jmemmgr.c expects that MAX_ALLOC_CHUNK will be representable as type
 * size_t and will be a multiple of sizeof(align_type).
 */

#ifndef MAX_ALLOC_CHUNK		/* may be overridden in jconfig.h */
#define MAX_ALLOC_CHUNK  1000000000L
#endif

/*
 * This routine computes the total space still available for allocation by
 * jpeg_get_large.  If more space than this is needed, backing store will be
 * used.  NOTE: any memory already allocated must not be counted.
 *
 * There is a minimum space requirement, corresponding to the minimum
 * feasible buffer sizes; jmemmgr.c will request that much space even if
 * jpeg_mem_available returns zero.  The maximum space needed, enough to hold
 * all working storage in memory, is also passed in case it is useful.
 * Finally, the total space already allocated is passed.  If no better
 * method is available, cinfo->mem->max_memory_to_use - already_allocated
 * is often a suitable calculation.
 *
 * It is OK for jpeg_mem_available to underestimate the space available
 * (that'll just lead to more backing-store access than is really necessary).
 * However, an overestimate will lead to failure.  Hence it's wise to subtract
 * a slop factor from the true available space.  5% should be enough.
 *
 * On machines with lots of virtual memory, any large constant may be returned.
 * Conversely, zero may be returned to always use the minimum amount of memory.
 */

EXTERN(long) jpeg_mem_available JPP((j_common_ptr cinfo,
				     long min_bytes_needed,
				     long max_bytes_needed,
				     long already_allocated));


/*
 * This structure holds whatever state is needed to access a single
 * backing-store object.  The read/write/close method pointers are called
 * by jmemmgr.c to manipulate the backing-store object; all other fields
 * are private to the system-dependent backing store routines.
 */

#define TEMP_NAME_LENGTH   64	/* max length of a temporary file's name */

#ifdef USE_MSDOS_MEMMGR		/* DOS-specific junk */

typedef unsigned short XMSH;	/* type of extended-memory handles */
typedef unsigned short EMSH;	/* type of expanded-memory handles */

typedef union {
  short file_handle;		/* DOS file handle if it's a temp file */
  XMSH xms_handle;		/* handle if it's a chunk of XMS */
  EMSH ems_handle;		/* handle if it's a chunk of EMS */
} handle_union;

#endif /* USE_MSDOS_MEMMGR */

typedef struct backing_store_struct * backing_store_ptr;

typedef struct backing_store_struct {
  /* Methods for reading/writing/closing this backing-store object */
  JMETHOD(void, read_backing_store, (j_common_ptr cinfo,
				     backing_store_ptr info,
				     void FAR * buffer_address,
				     long file_offset, long byte_count));
  JMETHOD(void, write_backing_store, (j_common_ptr cinfo,
				      backing_store_ptr info,
				      void FAR * buffer_address,
				      long file_offset, long byte_count));
  JMETHOD(void, close_backing_store, (j_common_ptr cinfo,
				      backing_store_ptr info));

  /* Private fields for system-dependent backing-store management */
#ifdef USE_MSDOS_MEMMGR
  /* For the MS-DOS manager (jmemdos.c), we need: */
  handle_union handle;		/* reference to backing-store storage object */
  char temp_name[TEMP_NAME_LENGTH]; /* name if it's a file */
#else
  /* For a typical implementation with temp files, we need: */
  FILE * temp_file;		/* stdio reference to temp file */
  char temp_name[TEMP_NAME_LENGTH]; /* name of temp file */
#endif
} backing_store_info;

/*
 * Initial opening of a backing-store object.  This must fill in the
 * read/write/close pointers in the object.  The read/write routines
 * may take an error exit if the specified maximum file size is exceeded.
 * (If jpeg_mem_available always returns a large value, this routine can
 * just take an error exit.)
 */

EXTERN(void) jpeg_open_backing_store JPP((j_common_ptr cinfo,
					  backing_store_ptr info,
					  long total_bytes_needed));


/*
 * These routines take care of any system-dependent initialization and
 * cleanup required.  jpeg_mem_init will be called before anything is
 * allocated (and, therefore, nothing in cinfo is of use except the error
 * manager pointer).  It should return a suitable default value for
 * max_memory_to_use; this may subsequently be overridden by the surrounding
 * application.  (Note that max_memory_to_use is only important if
 * jpeg_mem_available chooses to consult it ... no one else will.)
 * jpeg_mem_term may assume that all requested memory has been freed and that
 * all opened backing-store objects have been closed.
 */

EXTERN(long) jpeg_mem_init JPP((j_common_ptr cinfo));
EXTERN(void) jpeg_mem_term JPP((j_common_ptr cinfo));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeginc\jdhuff.h ===
/*
 * jdhuff.h
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains declarations for Huffman entropy decoding routines
 * that are shared between the sequential decoder (jdhuff.c) and the
 * progressive decoder (jdphuff.c).  No other modules need to see these.
 */

/* Short forms of external names for systems with bad linkers. */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jpeg_make_d_derived_tbl	jMkDDerived
#define jpeg_fill_bit_buffer	jFilBitBuf
#define jpeg_huff_decode	jHufDecode
#endif /* NEED_SHORT_EXTERNAL_NAMES */


/* Derived data constructed for each Huffman table */

#define HUFF_LOOKAHEAD	8	/* # of bits of lookahead */

typedef struct {
  /* Basic tables: (element [0] of each array is unused) */
  INT32 mincode[17];		/* smallest code of length k */
  INT32 maxcode[18];		/* largest code of length k (-1 if none) */
  /* (maxcode[17] is a sentinel to ensure jpeg_huff_decode terminates) */
  int valptr[17];		/* huffval[] index of 1st symbol of length k */

  /* Link to public Huffman table (needed only in jpeg_huff_decode) */
  JHUFF_TBL *pub;

  /* Lookahead tables: indexed by the next HUFF_LOOKAHEAD bits of
   * the input data stream.  If the next Huffman code is no more
   * than HUFF_LOOKAHEAD bits long, we can obtain its length and
   * the corresponding symbol directly from these tables.
   */
  int look_nbits[1<<HUFF_LOOKAHEAD]; /* # bits, or 0 if too long */
  UINT8 look_sym[1<<HUFF_LOOKAHEAD]; /* symbol, or unused */
} d_derived_tbl;

/* Expand a Huffman table definition into the derived format */
EXTERN(void) jpeg_make_d_derived_tbl JPP((j_decompress_ptr cinfo,
				JHUFF_TBL * htbl, d_derived_tbl ** pdtbl));


/*
 * Fetching the next N bits from the input stream is a time-critical operation
 * for the Huffman decoders.  We implement it with a combination of inline
 * macros and out-of-line subroutines.  Note that N (the number of bits
 * demanded at one time) never exceeds 15 for JPEG use.
 *
 * We read source bytes into get_buffer and dole out bits as needed.
 * If get_buffer already contains enough bits, they are fetched in-line
 * by the macros CHECK_BIT_BUFFER and GET_BITS.  When there aren't enough
 * bits, jpeg_fill_bit_buffer is called; it will attempt to fill get_buffer
 * as full as possible (not just to the number of bits needed; this
 * prefetching reduces the overhead cost of calling jpeg_fill_bit_buffer).
 * Note that jpeg_fill_bit_buffer may return FALSE to indicate suspension.
 * On TRUE return, jpeg_fill_bit_buffer guarantees that get_buffer contains
 * at least the requested number of bits --- dummy zeroes are inserted if
 * necessary.
 */

typedef INT32 bit_buf_type;	/* type of bit-extraction buffer */
#define BIT_BUF_SIZE  32	/* size of buffer in bits */

/* If long is > 32 bits on your machine, and shifting/masking longs is
 * reasonably fast, making bit_buf_type be long and setting BIT_BUF_SIZE
 * appropriately should be a win.  Unfortunately we can't do this with
 * something like  #define BIT_BUF_SIZE (sizeof(bit_buf_type)*8)
 * because not all machines measure sizeof in 8-bit bytes.
 */

typedef struct {		/* Bitreading state saved across MCUs */
  bit_buf_type get_buffer;	/* current bit-extraction buffer */
  int bits_left;		/* # of unused bits in it */
  boolean printed_eod;		/* flag to suppress multiple warning msgs */
} bitread_perm_state;

typedef struct {		/* Bitreading working state within an MCU */
  /* current data source state */
  const JOCTET * next_input_byte; /* => next byte to read from source */
  size_t bytes_in_buffer;	/* # of bytes remaining in source buffer */
  int unread_marker;		/* nonzero if we have hit a marker */
  /* bit input buffer --- note these values are kept in register variables,
   * not in this struct, inside the inner loops.
   */
  bit_buf_type get_buffer;	/* current bit-extraction buffer */
  int bits_left;		/* # of unused bits in it */
  /* pointers needed by jpeg_fill_bit_buffer */
  j_decompress_ptr cinfo;	/* back link to decompress master record */
  boolean * printed_eod_ptr;	/* => flag in permanent state */
} bitread_working_state;

/* Macros to declare and load/save bitread local variables. */
#define BITREAD_STATE_VARS  \
	register bit_buf_type get_buffer;  \
	register int bits_left;  \
	bitread_working_state br_state

#define BITREAD_LOAD_STATE(cinfop,permstate)  \
	br_state.cinfo = cinfop; \
	br_state.next_input_byte = cinfop->src->next_input_byte; \
	br_state.bytes_in_buffer = cinfop->src->bytes_in_buffer; \
	br_state.unread_marker = cinfop->unread_marker; \
	get_buffer = permstate.get_buffer; \
	bits_left = permstate.bits_left; \
	br_state.printed_eod_ptr = & permstate.printed_eod

#define BITREAD_SAVE_STATE(cinfop,permstate)  \
	cinfop->src->next_input_byte = br_state.next_input_byte; \
	cinfop->src->bytes_in_buffer = br_state.bytes_in_buffer; \
	cinfop->unread_marker = br_state.unread_marker; \
	permstate.get_buffer = get_buffer; \
	permstate.bits_left = bits_left

/*
 * These macros provide the in-line portion of bit fetching.
 * Use CHECK_BIT_BUFFER to ensure there are N bits in get_buffer
 * before using GET_BITS, PEEK_BITS, or DROP_BITS.
 * The variables get_buffer and bits_left are assumed to be locals,
 * but the state struct might not be (jpeg_huff_decode needs this).
 *	CHECK_BIT_BUFFER(state,n,action);
 *		Ensure there are N bits in get_buffer; if suspend, take action.
 *      val = GET_BITS(n);
 *		Fetch next N bits.
 *      val = PEEK_BITS(n);
 *		Fetch next N bits without removing them from the buffer.
 *	DROP_BITS(n);
 *		Discard next N bits.
 * The value N should be a simple variable, not an expression, because it
 * is evaluated multiple times.
 */

#define CHECK_BIT_BUFFER(state,nbits,action) \
	{ if (bits_left < (nbits)) {  \
	    if (! jpeg_fill_bit_buffer(&(state),get_buffer,bits_left,nbits))  \
	      { action; }  \
	    get_buffer = (state).get_buffer; bits_left = (state).bits_left; } }

#define GET_BITS(nbits) \
	(((int) (get_buffer >> (bits_left -= (nbits)))) & ((1<<(nbits))-1))

#define PEEK_BITS(nbits) \
	(((int) (get_buffer >> (bits_left -  (nbits)))) & ((1<<(nbits))-1))

#define DROP_BITS(nbits) \
	(bits_left -= (nbits))

/* Load up the bit buffer to a depth of at least nbits */
EXTERN(boolean) jpeg_fill_bit_buffer
	JPP((bitread_working_state * state, register bit_buf_type get_buffer,
	     register int bits_left, int nbits));


/*
 * Code for extracting next Huffman-coded symbol from input bit stream.
 * Again, this is time-critical and we make the main paths be macros.
 *
 * We use a lookahead table to process codes of up to HUFF_LOOKAHEAD bits
 * without looping.  Usually, more than 95% of the Huffman codes will be 8
 * or fewer bits long.  The few overlength codes are handled with a loop,
 * which need not be inline code.
 *
 * Notes about the HUFF_DECODE macro:
 * 1. Near the end of the data segment, we may fail to get enough bits
 *    for a lookahead.  In that case, we do it the hard way.
 * 2. If the lookahead table contains no entry, the next code must be
 *    more than HUFF_LOOKAHEAD bits long.
 * 3. jpeg_huff_decode returns -1 if forced to suspend.
 */

#define HUFF_DECODE(result,state,htbl,failaction,slowlabel) \
{ register int nb, look; \
  if (bits_left < HUFF_LOOKAHEAD) { \
    if (! jpeg_fill_bit_buffer(&state,get_buffer,bits_left, 0)) {failaction;} \
    get_buffer = state.get_buffer; bits_left = state.bits_left; \
    if (bits_left < HUFF_LOOKAHEAD) { \
      nb = 1; goto slowlabel; \
    } \
  } \
  look = PEEK_BITS(HUFF_LOOKAHEAD); \
  if ((nb = htbl->look_nbits[look]) != 0) { \
    DROP_BITS(nb); \
    result = htbl->look_sym[look]; \
  } else { \
    nb = HUFF_LOOKAHEAD+1; \
slowlabel: \
    if ((result=jpeg_huff_decode(&state,get_buffer,bits_left,htbl,nb)) < 0) \
	{ failaction; } \
    get_buffer = state.get_buffer; bits_left = state.bits_left; \
  } \
}

/* Out-of-line case for Huffman code fetching */
EXTERN(int) jpeg_huff_decode
	JPP((bitread_working_state * state, register bit_buf_type get_buffer,
	     register int bits_left, d_derived_tbl * htbl, int min_bits));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeginc\jmorecfg.h ===
/*
 * jmorecfg.h
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains additional configuration options that customize the
 * JPEG software for special applications or support machine-dependent
 * optimizations.  Most users will not need to touch this file.
 */


/*
 * Define BITS_IN_JSAMPLE as either
 *   8   for 8-bit sample values (the usual setting)
 *   12  for 12-bit sample values
 * Only 8 and 12 are legal data precisions for lossy JPEG according to the
 * JPEG standard, and the IJG code does not support anything else!
 * We do not support run-time selection of data precision, sorry.
 */

#define BITS_IN_JSAMPLE  8	/* use 8 or 12 */


/*
 * Maximum number of components (color channels) allowed in JPEG image.
 * To meet the letter of the JPEG spec, set this to 255.  However, darn
 * few applications need more than 4 channels (maybe 5 for CMYK + alpha
 * mask).  We recommend 10 as a reasonable compromise; use 4 if you are
 * really short on memory.  (Each allowed component costs a hundred or so
 * bytes of storage, whether actually used in an image or not.)
 */

#define MAX_COMPONENTS  10	/* maximum number of image components */


/*
 * Basic data types.
 * You may need to change these if you have a machine with unusual data
 * type sizes; for example, "char" not 8 bits, "short" not 16 bits,
 * or "long" not 32 bits.  We don't care whether "int" is 16 or 32 bits,
 * but it had better be at least 16.
 */

/* Representation of a single sample (pixel element value).
 * We frequently allocate large arrays of these, so it's important to keep
 * them small.  But if you have memory to burn and access to char or short
 * arrays is very slow on your hardware, you might want to change these.
 */

#if BITS_IN_JSAMPLE == 8
/* JSAMPLE should be the smallest type that will hold the values 0..255.
 * You can use a signed char by having GETJSAMPLE mask it with 0xFF.
 */

#ifdef HAVE_UNSIGNED_CHAR

typedef unsigned char JSAMPLE;
#define GETJSAMPLE(value)  ((int) (value))

#else /* not HAVE_UNSIGNED_CHAR */

typedef char JSAMPLE;
#ifdef CHAR_IS_UNSIGNED
#define GETJSAMPLE(value)  ((int) (value))
#else
#define GETJSAMPLE(value)  ((int) (value) & 0xFF)
#endif /* CHAR_IS_UNSIGNED */

#endif /* HAVE_UNSIGNED_CHAR */

#define MAXJSAMPLE	255
#define CENTERJSAMPLE	128

#endif /* BITS_IN_JSAMPLE == 8 */


#if BITS_IN_JSAMPLE == 12
/* JSAMPLE should be the smallest type that will hold the values 0..4095.
 * On nearly all machines "short" will do nicely.
 */

typedef short JSAMPLE;
#define GETJSAMPLE(value)  ((int) (value))

#define MAXJSAMPLE	4095
#define CENTERJSAMPLE	2048

#endif /* BITS_IN_JSAMPLE == 12 */


/* Representation of a DCT frequency coefficient.
 * This should be a signed value of at least 16 bits; "short" is usually OK.
 * Again, we allocate large arrays of these, but you can change to int
 * if you have memory to burn and "short" is really slow.
 */

typedef short JCOEF;


/* Compressed datastreams are represented as arrays of JOCTET.
 * These must be EXACTLY 8 bits wide, at least once they are written to
 * external storage.  Note that when using the stdio data source/destination
 * managers, this is also the data type passed to fread/fwrite.
 */

#ifdef HAVE_UNSIGNED_CHAR

typedef unsigned char JOCTET;
#define GETJOCTET(value)  (value)

#else /* not HAVE_UNSIGNED_CHAR */

typedef char JOCTET;
#ifdef CHAR_IS_UNSIGNED
#define GETJOCTET(value)  (value)
#else
#define GETJOCTET(value)  ((value) & 0xFF)
#endif /* CHAR_IS_UNSIGNED */

#endif /* HAVE_UNSIGNED_CHAR */


/* These typedefs are used for various table entries and so forth.
 * They must be at least as wide as specified; but making them too big
 * won't cost a huge amount of memory, so we don't provide special
 * extraction code like we did for JSAMPLE.  (In other words, these
 * typedefs live at a different point on the speed/space tradeoff curve.)
 */
#ifndef _BASETSD_H_		/* basetsd.h correctly defines [U]INT[8|16|32] */

/* UINT8 must hold at least the values 0..255. */

#ifdef HAVE_UNSIGNED_CHAR
typedef unsigned char UINT8;
#else /* not HAVE_UNSIGNED_CHAR */
#ifdef CHAR_IS_UNSIGNED
typedef char UINT8;
#else /* not CHAR_IS_UNSIGNED */
typedef short UINT8;
#endif /* CHAR_IS_UNSIGNED */
#endif /* HAVE_UNSIGNED_CHAR */

/* UINT16 must hold at least the values 0..65535. */

#ifdef HAVE_UNSIGNED_SHORT
typedef unsigned short UINT16;
#else /* not HAVE_UNSIGNED_SHORT */
typedef unsigned int UINT16;
#endif /* HAVE_UNSIGNED_SHORT */

/* INT16 must hold at least the values -32768..32767. */

#ifndef XMD_H			/* X11/xmd.h correctly defines INT16 */
typedef short INT16;
#endif

/* INT32 must hold at least signed 32-bit values. */

#ifdef _WIN64			//!!merced: basetsd.h defines INT32
typedef int INT32;
#else
typedef long INT32;
#endif
#endif

/* Datatype used for image dimensions.  The JPEG standard only supports
 * images up to 64K*64K due to 16-bit fields in SOF markers.  Therefore
 * "unsigned int" is sufficient on all machines.  However, if you need to
 * handle larger images and you don't mind deviating from the spec, you
 * can change this datatype.
 */

typedef unsigned int JDIMENSION;

#define JPEG_MAX_DIMENSION  65500L  /* a tad under 64K to prevent overflows */


/* These macros are used in all function definitions and extern declarations.
 * You could modify them if you need to change function linkage conventions;
 * in particular, you'll need to do that to make the library a Windows DLL.
 * Another application is to make all functions global for use with debuggers
 * or code profilers that require it.
 */

/* a function called through method pointers: */
#define METHODDEF(type)		static type
/* a function used only in its module: */
#define LOCAL(type)		static type
/* a function referenced thru EXTERNs: */
#define GLOBAL(type)		type
/* a reference to a GLOBAL function: */
#define EXTERN(type)		extern type


/* This macro is used to declare a "method", that is, a function pointer.
 * We want to supply prototype parameters if the compiler can cope.
 * Note that the arglist parameter must be parenthesized!
 * Again, you can customize this if you need special linkage keywords.
 */

#ifdef HAVE_PROTOTYPES
#define JMETHOD(type,methodname,arglist)  type (*methodname) arglist
#else
#define JMETHOD(type,methodname,arglist)  type (*methodname) ()
#endif


/* Here is the pseudo-keyword for declaring pointers that must be "far"
 * on 80x86 machines.  Most of the specialized coding for 80x86 is handled
 * by just saying "FAR *" where such a pointer is needed.  In a few places
 * explicit coding is needed; see uses of the NEED_FAR_POINTERS symbol.
 */


#ifdef NEED_FAR_POINTERS
#define FAR  far
#else
#define FAR
#endif


/*
 * On a few systems, type boolean and/or its values FALSE, TRUE may appear
 * in standard header files.  Or you may have conflicts with application-
 * specific header files that you want to include together with these files.
 * Defining HAVE_BOOLEAN before including jpeglib.h should make it work.
 */

#ifndef HAVE_BOOLEAN
typedef int boolean;
#endif
#ifndef FALSE			/* in case these macros already exist */
#define FALSE	0		/* values of boolean */
#endif
#ifndef TRUE
#define TRUE	1
#endif


/*
 * The remaining options affect code selection within the JPEG library,
 * but they don't need to be visible to most applications using the library.
 * To minimize application namespace pollution, the symbols won't be
 * defined unless JPEG_INTERNALS or JPEG_INTERNAL_OPTIONS has been defined.
 */

#ifdef JPEG_INTERNALS
#define JPEG_INTERNAL_OPTIONS
#endif

#ifdef JPEG_INTERNAL_OPTIONS


/*
 * These defines indicate whether to include various optional functions.
 * Undefining some of these symbols will produce a smaller but less capable
 * library.  Note that you can leave certain source files out of the
 * compilation/linking process if you've #undef'd the corresponding symbols.
 * (You may HAVE to do that if your compiler doesn't like null source files.)
 */

/* Arithmetic coding is unsupported for legal reasons.  Complaints to IBM. */

/* Capability options common to encoder and decoder: */

#define DCT_ISLOW_SUPPORTED	/* slow but accurate integer algorithm */
#define DCT_IFAST_SUPPORTED	/* faster, less accurate integer method */
// #define DCT_FLOAT_SUPPORTED	/* floating-point: accurate, fast on fast HW */

/* Encoder capability options: */

#undef  C_ARITH_CODING_SUPPORTED    /* Arithmetic coding back end? */
#define C_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */
#define C_PROGRESSIVE_SUPPORTED	    /* Progressive JPEG? (Requires MULTISCAN)*/
#define ENTROPY_OPT_SUPPORTED	    /* Optimization of entropy coding parms? */
/* Note: if you selected 12-bit data precision, it is dangerous to turn off
 * ENTROPY_OPT_SUPPORTED.  The standard Huffman tables are only good for 8-bit
 * precision, so jchuff.c normally uses entropy optimization to compute
 * usable tables for higher precision.  If you don't want to do optimization,
 * you'll have to supply different default Huffman tables.
 * The exact same statements apply for progressive JPEG: the default tables
 * don't work for progressive mode.  (This may get fixed, however.)
 */
#define INPUT_SMOOTHING_SUPPORTED   /* Input image smoothing option? */

/* Decoder capability options: */

#undef  D_ARITH_CODING_SUPPORTED    /* Arithmetic coding back end? */
#define D_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */
#define D_PROGRESSIVE_SUPPORTED	    /* Progressive JPEG? (Requires MULTISCAN)*/
#define BLOCK_SMOOTHING_SUPPORTED   /* Block smoothing? (Progressive only) */
#define IDCT_SCALING_SUPPORTED	    /* Output rescaling via IDCT? */
#undef  UPSAMPLE_SCALING_SUPPORTED  /* Output rescaling at upsample stage? */
#define UPSAMPLE_MERGING_SUPPORTED  /* Fast path for sloppy upsampling? */
#define QUANT_1PASS_SUPPORTED	    /* 1-pass color quantization? */
#define QUANT_2PASS_SUPPORTED	    /* 2-pass color quantization? */

/* more capability options later, no doubt */


/*
 * Ordering of RGB data in scanlines passed to or from the application.
 * If your application wants to deal with data in the order B,G,R, just
 * change these macros.  You can also deal with formats such as R,G,B,X
 * (one extra byte per pixel) by changing RGB_PIXELSIZE.  Note that changing
 * the offsets will also change the order in which colormap data is organized.
 * RESTRICTIONS:
 * 1. The sample applications cjpeg,djpeg do NOT support modified RGB formats.
 * 2. These macros only affect RGB<=>YCbCr color conversion, so they are not
 *    useful if you are using JPEG color spaces other than YCbCr or grayscale.
 * 3. The color quantizer modules will not behave desirably if RGB_PIXELSIZE
 *    is not 3 (they don't understand about dummy color components!).  So you
 *    can't use color quantization if you change that value.
 */

#define RGB_RED		0	/* Offset of Red in an RGB scanline element */
#define RGB_GREEN	1	/* Offset of Green */
#define RGB_BLUE	2	/* Offset of Blue */
#define RGB_PIXELSIZE	3	/* JSAMPLEs per RGB scanline element */


/* Definitions for speed-related optimizations. */


/* If your compiler supports inline functions, define INLINE
 * as the inline keyword; otherwise define it as empty.
 */

#ifndef INLINE
#ifdef __GNUC__			/* for instance, GNU C knows about inline */
#define INLINE __inline__
#endif
#ifndef INLINE
#define INLINE			/* default is to define it as empty */
#endif
#endif


/* On some machines (notably 68000 series) "int" is 32 bits, but multiplying
 * two 16-bit shorts is faster than multiplying two ints.  Define MULTIPLIER
 * as short on such a machine.  MULTIPLIER must be at least 16 bits wide.
 */

#ifndef MULTIPLIER
#define MULTIPLIER  int		/* type for fastest integer multiply */
#endif


/* FAST_FLOAT should be either float or double, whichever is done faster
 * by your compiler.  (Note that this type is only used in the floating point
 * DCT routines, so it only matters if you've defined DCT_FLOAT_SUPPORTED.)
 * Typically, float is faster in ANSI C compilers, while double is faster in
 * pre-ANSI compilers (because they insist on converting to double anyway).
 * The code below therefore chooses float if we have ANSI-style prototypes.
 */

#ifndef FAST_FLOAT
#ifdef HAVE_PROTOTYPES
#define FAST_FLOAT  float
#else
#define FAST_FLOAT  double
#endif
#endif

#endif /* JPEG_INTERNAL_OPTIONS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeginc\jversion.h ===
/*
 * jversion.h
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains software version identification.
 */


#define JVERSION	"6a  7-Feb-96"

#define JCOPYRIGHT	"Copyright (C) 1996, Thomas G. Lane"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeginc\jpegdeco.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       jpegdeco.h
//
//--------------------------------------------------------------------------

#ifndef __CJPEGDECOMPRESSOR
#define __CJPEGDECOMPRESSOR

#include <stdio.h>
extern "C" {
#include "jpeglib.h"
}

class CJPEGDatasource;

class CJPEGDecompressor
{

public:

	CJPEGDecompressor();
	virtual ~CJPEGDecompressor();
	
	boolean Decompress (CJPEGDatasource* dataSource);
		
protected:
			
	// Data target
	virtual void BuildColorMap () = 0;
	virtual void BeginDecompression	() = 0;
	virtual void StoreScanline (void* buffer, int row) = 0;
	virtual void EndDecompression () = 0;
	
	// Error handling
	virtual void ErrorExit () = 0;
	virtual void EmitMessage (int msg_level) = 0;
	virtual void OutputMessage () = 0;
	virtual void FormatMessage (char* buffer) = 0;
	virtual void ResetErrorManager () = 0;
		
	void Init (CJPEGDatasource* dataSource);
	void Terminate ();
	
  	typedef struct jpeg_archive_record {
  		jpeg_decompress_struct	cinfo;
  		CJPEGDecompressor*		archive;
  	} jpeg_archive_record, *jpeg_archive_ptr;

	CJPEGDatasource* m_dataSource;
  	jpeg_archive_record m_archive;

private:

	static void ErrorExitEntry (j_common_ptr cinfo);
	static void EmitMessageEntry (j_common_ptr cinfo, int msg_level);
	static void OutputMessageEntry (j_common_ptr cinfo);
	static void FormatMessageEntry (j_common_ptr cinfo, char* buffer);
	static void ResetErrorManagerEntry (j_common_ptr cinfo);
	
  	jpeg_error_mgr m_jErr;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeginc\jpeglib.h ===
/*
 * jpeglib.h
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file defines the application interface for the JPEG library.
 * Most applications using the library need only include this file,
 * and perhaps jerror.h if they want to know the exact error codes.
 */

#ifndef JPEGLIB_H
#define JPEGLIB_H

/*
 * First we include the configuration files that record how this
 * installation of the JPEG library is set up.  jconfig.h can be
 * generated automatically for many systems.  jmorecfg.h contains
 * manual configuration options that most people need not worry about.
 */

#ifndef JCONFIG_INCLUDED	/* in case jinclude.h already did */
#include "jconfig.h"		/* widely used configuration options */
#endif
#include "jmorecfg.h"		/* seldom changed options */


/* Version ID for the JPEG library.
 * Might be useful for tests like "#if JPEG_LIB_VERSION >= 60".
 */

#define JPEG_LIB_VERSION  61	/* Version 6a */


/* Various constants determining the sizes of things.
 * All of these are specified by the JPEG standard, so don't change them
 * if you want to be compatible.
 */

#define DCTSIZE		    8	/* The basic DCT block is 8x8 samples */
#define DCTSIZE2	    64	/* DCTSIZE squared; # of elements in a block */
#define NUM_QUANT_TBLS      4	/* Quantization tables are numbered 0..3 */
#define NUM_HUFF_TBLS       4	/* Huffman tables are numbered 0..3 */
#define NUM_ARITH_TBLS      16	/* Arith-coding tables are numbered 0..15 */
#define MAX_COMPS_IN_SCAN   4	/* JPEG limit on # of components in one scan */
#define MAX_SAMP_FACTOR     4	/* JPEG limit on sampling factors */
/* Unfortunately, someone at Adobe saw no reason to be bound by the standard;
 * the PostScript DCT filter can emit files with many more than 10 blocks/MCU.
 * If you happen to run across such a file, you can up D_MAX_BLOCKS_IN_MCU
 * to handle it.  We even let you do this from the jconfig.h file.  However,
 * we strongly discourage changing C_MAX_BLOCKS_IN_MCU; just because Adobe
 * sometimes emits noncompliant files doesn't mean you should too.
 */
#define C_MAX_BLOCKS_IN_MCU   10 /* compressor's limit on blocks per MCU */
#ifndef D_MAX_BLOCKS_IN_MCU
#define D_MAX_BLOCKS_IN_MCU   10 /* decompressor's limit on blocks per MCU */
#endif


/* Data structures for images (arrays of samples and of DCT coefficients).
 * On 80x86 machines, the image arrays are too big for near pointers,
 * but the pointer arrays can fit in near memory.
 */

typedef JSAMPLE FAR *JSAMPROW;	/* ptr to one image row of pixel samples. */
typedef JSAMPROW *JSAMPARRAY;	/* ptr to some rows (a 2-D sample array) */
typedef JSAMPARRAY *JSAMPIMAGE;	/* a 3-D sample array: top index is color */

typedef JCOEF JBLOCK[DCTSIZE2];	/* one block of coefficients */
typedef JBLOCK FAR *JBLOCKROW;	/* pointer to one row of coefficient blocks */
typedef JBLOCKROW *JBLOCKARRAY;		/* a 2-D array of coefficient blocks */
typedef JBLOCKARRAY *JBLOCKIMAGE;	/* a 3-D array of coefficient blocks */

typedef JCOEF FAR *JCOEFPTR;	/* useful in a couple of places */


/* Types for JPEG compression parameters and working tables. */


/* DCT coefficient quantization tables. */

typedef struct {
  /* This array gives the coefficient quantizers in natural array order
   * (not the zigzag order in which they are stored in a JPEG DQT marker).
   * CAUTION: IJG versions prior to v6a kept this array in zigzag order.
   */
  UINT16 quantval[DCTSIZE2];	/* quantization step for each coefficient */
  /* This field is used only during compression.  It's initialized FALSE when
   * the table is created, and set TRUE when it's been output to the file.
   * You could suppress output of a table by setting this to TRUE.
   * (See jpeg_suppress_tables for an example.)
   */
  boolean sent_table;		/* TRUE when table has been output */
} JQUANT_TBL;


/* Huffman coding tables. */

typedef struct {
  /* These two fields directly represent the contents of a JPEG DHT marker */
  UINT8 bits[17];		/* bits[k] = # of symbols with codes of */
				/* length k bits; bits[0] is unused */
  UINT8 huffval[256];		/* The symbols, in order of incr code length */
  /* This field is used only during compression.  It's initialized FALSE when
   * the table is created, and set TRUE when it's been output to the file.
   * You could suppress output of a table by setting this to TRUE.
   * (See jpeg_suppress_tables for an example.)
   */
  boolean sent_table;		/* TRUE when table has been output */
} JHUFF_TBL;


/* Basic info about one component (color channel). */

typedef struct {
  /* These values are fixed over the whole image. */
  /* For compression, they must be supplied by parameter setup; */
  /* for decompression, they are read from the SOF marker. */
  int component_id;		/* identifier for this component (0..255) */
  int component_index;		/* its index in SOF or cinfo->comp_info[] */
  int h_samp_factor;		/* horizontal sampling factor (1..4) */
  int v_samp_factor;		/* vertical sampling factor (1..4) */
  int quant_tbl_no;		/* quantization table selector (0..3) */
  /* These values may vary between scans. */
  /* For compression, they must be supplied by parameter setup; */
  /* for decompression, they are read from the SOS marker. */
  /* The decompressor output side may not use these variables. */
  int dc_tbl_no;		/* DC entropy table selector (0..3) */
  int ac_tbl_no;		/* AC entropy table selector (0..3) */
  
  /* Remaining fields should be treated as private by applications. */
  
  /* These values are computed during compression or decompression startup: */
  /* Component's size in DCT blocks.
   * Any dummy blocks added to complete an MCU are not counted; therefore
   * these values do not depend on whether a scan is interleaved or not.
   */
  JDIMENSION width_in_blocks;
  JDIMENSION height_in_blocks;
  /* Size of a DCT block in samples.  Always DCTSIZE for compression.
   * For decompression this is the size of the output from one DCT block,
   * reflecting any scaling we choose to apply during the IDCT step.
   * Values of 1,2,4,8 are likely to be supported.  Note that different
   * components may receive different IDCT scalings.
   */
  int DCT_scaled_size;
  /* The downsampled dimensions are the component's actual, unpadded number
   * of samples at the main buffer (preprocessing/compression interface), thus
   * downsampled_width = ceil(image_width * Hi/Hmax)
   * and similarly for height.  For decompression, IDCT scaling is included, so
   * downsampled_width = ceil(image_width * Hi/Hmax * DCT_scaled_size/DCTSIZE)
   */
  JDIMENSION downsampled_width;	 /* actual width in samples */
  JDIMENSION downsampled_height; /* actual height in samples */
  /* This flag is used only for decompression.  In cases where some of the
   * components will be ignored (eg grayscale output from YCbCr image),
   * we can skip most computations for the unused components.
   */
  boolean component_needed;	/* do we need the value of this component? */

  /* These values are computed before starting a scan of the component. */
  /* The decompressor output side may not use these variables. */
  int MCU_width;		/* number of blocks per MCU, horizontally */
  int MCU_height;		/* number of blocks per MCU, vertically */
  int MCU_blocks;		/* MCU_width * MCU_height */
  int MCU_sample_width;		/* MCU width in samples, MCU_width*DCT_scaled_size */
  int last_col_width;		/* # of non-dummy blocks across in last MCU */
  int last_row_height;		/* # of non-dummy blocks down in last MCU */

  /* Saved quantization table for component; NULL if none yet saved.
   * See jdinput.c comments about the need for this information.
   * This field is currently used only for decompression.
   */
  JQUANT_TBL * quant_table;

  /* Private per-component storage for DCT or IDCT subsystem. */
  void * dct_table;
} jpeg_component_info;


/* The script for encoding a multiple-scan file is an array of these: */

typedef struct {
  int comps_in_scan;		/* number of components encoded in this scan */
  int component_index[MAX_COMPS_IN_SCAN]; /* their SOF/comp_info[] indexes */
  int Ss, Se;			/* progressive JPEG spectral selection parms */
  int Ah, Al;			/* progressive JPEG successive approx. parms */
} jpeg_scan_info;


/* Known color spaces. */

typedef enum {
	JCS_UNKNOWN,		/* error/unspecified */
	JCS_GRAYSCALE,		/* monochrome */
	JCS_RGB,		/* red/green/blue */
	JCS_YCbCr,		/* Y/Cb/Cr (also known as YUV) */
	JCS_CMYK,		/* C/M/Y/K */
	JCS_YCCK		/* Y/Cb/Cr/K */
} J_COLOR_SPACE;

/* DCT/IDCT algorithm options. */

typedef enum {
	JDCT_ISLOW,		/* slow but accurate integer algorithm */
	JDCT_IFAST,		/* faster, less accurate integer method */
	JDCT_FLOAT		/* floating-point: accurate, fast on fast HW */
} J_DCT_METHOD;

#ifndef JDCT_DEFAULT		/* may be overridden in jconfig.h */
#define JDCT_DEFAULT  JDCT_ISLOW
#endif
#ifndef JDCT_FASTEST		/* may be overridden in jconfig.h */
#define JDCT_FASTEST  JDCT_IFAST
#endif

/* Dithering options for decompression. */

typedef enum {
	JDITHER_NONE,		/* no dithering */
	JDITHER_ORDERED,	/* simple ordered dither */
	JDITHER_FS		/* Floyd-Steinberg error diffusion dither */
} J_DITHER_MODE;


/* Common fields between JPEG compression and decompression master structs. */

#define jpeg_common_fields \
  struct jpeg_error_mgr * err;	/* Error handler module */\
  struct jpeg_memory_mgr * mem;	/* Memory manager module */\
  struct jpeg_progress_mgr * progress; /* Progress monitor, or NULL if none */\
  boolean is_decompressor;	/* so common code can tell which is which */\
  int global_state		/* for checking call sequence validity */

/* Routines that are to be used by both halves of the library are declared
 * to receive a pointer to this structure.  There are no actual instances of
 * jpeg_common_struct, only of jpeg_compress_struct and jpeg_decompress_struct.
 */
struct jpeg_common_struct {
  jpeg_common_fields;		/* Fields common to both master struct types */
  /* Additional fields follow in an actual jpeg_compress_struct or
   * jpeg_decompress_struct.  All three structs must agree on these
   * initial fields!  (This would be a lot cleaner in C++.)
   */
};

typedef struct jpeg_common_struct * j_common_ptr;
typedef struct jpeg_compress_struct * j_compress_ptr;
typedef struct jpeg_decompress_struct * j_decompress_ptr;


/* Master record for a compression instance */

struct jpeg_compress_struct {
  jpeg_common_fields;		/* Fields shared with jpeg_decompress_struct */

  /* Destination for compressed data */
  struct jpeg_destination_mgr * dest;

  /* Description of source image --- these fields must be filled in by
   * outer application before starting compression.  in_color_space must
   * be correct before you can even call jpeg_set_defaults().
   */

  JDIMENSION image_width;	/* input image width */
  JDIMENSION image_height;	/* input image height */
  int input_components;		/* # of color components in input image */
  J_COLOR_SPACE in_color_space;	/* colorspace of input image */

  double input_gamma;		/* image gamma of input image */

  /* Compression parameters --- these fields must be set before calling
   * jpeg_start_compress().  We recommend calling jpeg_set_defaults() to
   * initialize everything to reasonable defaults, then changing anything
   * the application specifically wants to change.  That way you won't get
   * burnt when new parameters are added.  Also note that there are several
   * helper routines to simplify changing parameters.
   */

  int data_precision;		/* bits of precision in image data */

  int num_components;		/* # of color components in JPEG image */
  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */

  jpeg_component_info * comp_info;
  /* comp_info[i] describes component that appears i'th in SOF */
  
  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
  /* ptrs to coefficient quantization tables, or NULL if not defined */
  
  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
  /* ptrs to Huffman coding tables, or NULL if not defined */
  
  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */

  int num_scans;		/* # of entries in scan_info array */
  const jpeg_scan_info * scan_info; /* script for multi-scan file, or NULL */
  /* The default value of scan_info is NULL, which causes a single-scan
   * sequential JPEG file to be emitted.  To create a multi-scan file,
   * set num_scans and scan_info to point to an array of scan definitions.
   */

  boolean raw_data_in;		/* TRUE=caller supplies downsampled data */
  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
  boolean optimize_coding;	/* TRUE=optimize entropy encoding parms */
  boolean CCIR601_sampling;	/* TRUE=first samples are cosited */
  int smoothing_factor;		/* 1..100, or 0 for no input smoothing */
  J_DCT_METHOD dct_method;	/* DCT algorithm selector */

  /* The restart interval can be specified in absolute MCUs by setting
   * restart_interval, or in MCU rows by setting restart_in_rows
   * (in which case the correct restart_interval will be figured
   * for each scan).
   */
  unsigned int restart_interval; /* MCUs per restart, or 0 for no restart */
  int restart_in_rows;		/* if > 0, MCU rows per restart interval */

  /* Parameters controlling emission of special markers. */

  boolean write_JFIF_header;	/* should a JFIF marker be written? */
  /* These three values are not used by the JPEG code, merely copied */
  /* into the JFIF APP0 marker.  density_unit can be 0 for unknown, */
  /* 1 for dots/inch, or 2 for dots/cm.  Note that the pixel aspect */
  /* ratio is defined by X_density/Y_density even when density_unit=0. */
  UINT8 density_unit;		/* JFIF code for pixel size units */
  UINT16 X_density;		/* Horizontal pixel density */
  UINT16 Y_density;		/* Vertical pixel density */
  boolean write_Adobe_marker;	/* should an Adobe marker be written? */
  
  /* State variable: index of next scanline to be written to
   * jpeg_write_scanlines().  Application may use this to control its
   * processing loop, e.g., "while (next_scanline < image_height)".
   */

  JDIMENSION next_scanline;	/* 0 .. image_height-1  */

  /* Remaining fields are known throughout compressor, but generally
   * should not be touched by a surrounding application.
   */

  /*
   * These fields are computed during compression startup
   */
  boolean progressive_mode;	/* TRUE if scan script uses progressive mode */
  int max_h_samp_factor;	/* largest h_samp_factor */
  int max_v_samp_factor;	/* largest v_samp_factor */

  JDIMENSION total_iMCU_rows;	/* # of iMCU rows to be input to coef ctlr */
  /* The coefficient controller receives data in units of MCU rows as defined
   * for fully interleaved scans (whether the JPEG file is interleaved or not).
   * There are v_samp_factor * DCTSIZE sample rows of each component in an
   * "iMCU" (interleaved MCU) row.
   */
  
  /*
   * These fields are valid during any one scan.
   * They describe the components and MCUs actually appearing in the scan.
   */
  int comps_in_scan;		/* # of JPEG components in this scan */
  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
  /* *cur_comp_info[i] describes component that appears i'th in SOS */
  
  JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
  JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */
  
  int blocks_in_MCU;		/* # of DCT blocks per MCU */
  int MCU_membership[C_MAX_BLOCKS_IN_MCU];
  /* MCU_membership[i] is index in cur_comp_info of component owning */
  /* i'th block in an MCU */

  int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */

  /*
   * Links to compression subobjects (methods and private variables of modules)
   */
  struct jpeg_comp_master * master;
  struct jpeg_c_main_controller * main;
  struct jpeg_c_prep_controller * prep;
  struct jpeg_c_coef_controller * coef;
  struct jpeg_marker_writer * marker;
  struct jpeg_color_converter * cconvert;
  struct jpeg_downsampler * downsample;
  struct jpeg_forward_dct * fdct;
  struct jpeg_entropy_encoder * entropy;
};


/* Master record for a decompression instance */

struct jpeg_decompress_struct {
  jpeg_common_fields;		/* Fields shared with jpeg_compress_struct */

  /* Source of compressed data */
  struct jpeg_source_mgr * src;

  /* Basic description of image --- filled in by jpeg_read_header(). */
  /* Application may inspect these values to decide how to process image. */

  JDIMENSION image_width;	/* nominal image width (from SOF marker) */
  JDIMENSION image_height;	/* nominal image height */
  int num_components;		/* # of color components in JPEG image */
  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */

  /* Decompression processing parameters --- these fields must be set before
   * calling jpeg_start_decompress().  Note that jpeg_read_header() initializes
   * them to default values.
   */

  J_COLOR_SPACE out_color_space; /* colorspace for output */

  unsigned int scale_num, scale_denom; /* fraction by which to scale image */

  double output_gamma;		/* image gamma wanted in output */

  boolean buffered_image;	/* TRUE=multiple output passes */
  boolean raw_data_out;		/* TRUE=downsampled data wanted */

  J_DCT_METHOD dct_method;	/* IDCT algorithm selector */
  boolean do_fancy_upsampling;	/* TRUE=apply fancy upsampling */
  boolean do_block_smoothing;	/* TRUE=apply interblock smoothing */

  boolean quantize_colors;	/* TRUE=colormapped output wanted */
  /* the following are ignored if not quantize_colors: */
  J_DITHER_MODE dither_mode;	/* type of color dithering to use */
  boolean two_pass_quantize;	/* TRUE=use two-pass color quantization */
  int desired_number_of_colors;	/* max # colors to use in created colormap */
  /* these are significant only in buffered-image mode: */
  boolean enable_1pass_quant;	/* enable future use of 1-pass quantizer */
  boolean enable_external_quant;/* enable future use of external colormap */
  boolean enable_2pass_quant;	/* enable future use of 2-pass quantizer */

  /* Description of actual output image that will be returned to application.
   * These fields are computed by jpeg_start_decompress().
   * You can also use jpeg_calc_output_dimensions() to determine these values
   * in advance of calling jpeg_start_decompress().
   */

  JDIMENSION output_width;	/* scaled image width */
  JDIMENSION output_height;	/* scaled image height */
  int out_color_components;	/* # of color components in out_color_space */
  int output_components;	/* # of color components returned */
  /* output_components is 1 (a colormap index) when quantizing colors;
   * otherwise it equals out_color_components.
   */
  int rec_outbuf_height;	/* min recommended height of scanline buffer */
  /* If the buffer passed to jpeg_read_scanlines() is less than this many rows
   * high, space and time will be wasted due to unnecessary data copying.
   * Usually rec_outbuf_height will be 1 or 2, at most 4.
   */

  /* When quantizing colors, the output colormap is described by these fields.
   * The application can supply a colormap by setting colormap non-NULL before
   * calling jpeg_start_decompress; otherwise a colormap is created during
   * jpeg_start_decompress or jpeg_start_output.
   * The map has out_color_components rows and actual_number_of_colors columns.
   */
  int actual_number_of_colors;	/* number of entries in use */
  JSAMPARRAY colormap;		/* The color map as a 2-D pixel array */

  /* State variables: these variables indicate the progress of decompression.
   * The application may examine these but must not modify them.
   */

  /* Row index of next scanline to be read from jpeg_read_scanlines().
   * Application may use this to control its processing loop, e.g.,
   * "while (output_scanline < output_height)".
   */
  JDIMENSION output_scanline;	/* 0 .. output_height-1  */

  /* Current input scan number and number of iMCU rows completed in scan.
   * These indicate the progress of the decompressor input side.
   */
  int input_scan_number;	/* Number of SOS markers seen so far */
  JDIMENSION input_iMCU_row;	/* Number of iMCU rows completed */

  /* The "output scan number" is the notional scan being displayed by the
   * output side.  The decompressor will not allow output scan/row number
   * to get ahead of input scan/row, but it can fall arbitrarily far behind.
   */
  int output_scan_number;	/* Nominal scan number being displayed */
  JDIMENSION output_iMCU_row;	/* Number of iMCU rows read */

  /* Current progression status.  coef_bits[c][i] indicates the precision
   * with which component c's DCT coefficient i (in zigzag order) is known.
   * It is -1 when no data has yet been received, otherwise it is the point
   * transform (shift) value for the most recent scan of the coefficient
   * (thus, 0 at completion of the progression).
   * This pointer is NULL when reading a non-progressive file.
   */
  int (*coef_bits)[DCTSIZE2];	/* -1 or current Al value for each coef */

  /* Internal JPEG parameters --- the application usually need not look at
   * these fields.  Note that the decompressor output side may not use
   * any parameters that can change between scans.
   */

  /* Quantization and Huffman tables are carried forward across input
   * datastreams when processing abbreviated JPEG datastreams.
   */

  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
  /* ptrs to coefficient quantization tables, or NULL if not defined */

  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
  /* ptrs to Huffman coding tables, or NULL if not defined */

  /* These parameters are never carried across datastreams, since they
   * are given in SOF/SOS markers or defined to be reset by SOI.
   */

  int data_precision;		/* bits of precision in image data */

  jpeg_component_info * comp_info;
  /* comp_info[i] describes component that appears i'th in SOF */

  boolean progressive_mode;	/* TRUE if SOFn specifies progressive mode */
  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */

  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */

  unsigned int restart_interval; /* MCUs per restart interval, or 0 for no restart */

  /* These fields record data obtained from optional markers recognized by
   * the JPEG library.
   */
  boolean saw_JFIF_marker;	/* TRUE iff a JFIF APP0 marker was found */
  /* Data copied from JFIF marker: */
  UINT8 density_unit;		/* JFIF code for pixel size units */
  UINT16 X_density;		/* Horizontal pixel density */
  UINT16 Y_density;		/* Vertical pixel density */
  boolean saw_Adobe_marker;	/* TRUE iff an Adobe APP14 marker was found */
  UINT8 Adobe_transform;	/* Color transform code from Adobe marker */

  boolean CCIR601_sampling;	/* TRUE=first samples are cosited */

  /* Remaining fields are known throughout decompressor, but generally
   * should not be touched by a surrounding application.
   */

  /*
   * These fields are computed during decompression startup
   */
  int max_h_samp_factor;	/* largest h_samp_factor */
  int max_v_samp_factor;	/* largest v_samp_factor */

  int min_DCT_scaled_size;	/* smallest DCT_scaled_size of any component */

  JDIMENSION total_iMCU_rows;	/* # of iMCU rows in image */
  /* The coefficient controller's input and output progress is measured in
   * units of "iMCU" (interleaved MCU) rows.  These are the same as MCU rows
   * in fully interleaved JPEG scans, but are used whether the scan is
   * interleaved or not.  We define an iMCU row as v_samp_factor DCT block
   * rows of each component.  Therefore, the IDCT output contains
   * v_samp_factor*DCT_scaled_size sample rows of a component per iMCU row.
   */

  JSAMPLE * sample_range_limit; /* table for fast range-limiting */

  /*
   * These fields are valid during any one scan.
   * They describe the components and MCUs actually appearing in the scan.
   * Note that the decompressor output side must not use these fields.
   */
  int comps_in_scan;		/* # of JPEG components in this scan */
  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
  /* *cur_comp_info[i] describes component that appears i'th in SOS */

  JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
  JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */

  int blocks_in_MCU;		/* # of DCT blocks per MCU */
  int MCU_membership[D_MAX_BLOCKS_IN_MCU];
  /* MCU_membership[i] is index in cur_comp_info of component owning */
  /* i'th block in an MCU */

  int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */

  /* This field is shared between entropy decoder and marker parser.
   * It is either zero or the code of a JPEG marker that has been
   * read from the data source, but has not yet been processed.
   */
  int unread_marker;

  /*
   * Links to decompression subobjects (methods, private variables of modules)
   */
  struct jpeg_decomp_master * master;
  struct jpeg_d_main_controller * main;
  struct jpeg_d_coef_controller * coef;
  struct jpeg_d_post_controller * post;
  struct jpeg_input_controller * inputctl;
  struct jpeg_marker_reader * marker;
  struct jpeg_entropy_decoder * entropy;
  struct jpeg_inverse_dct * idct;
  struct jpeg_upsampler * upsample;
  struct jpeg_color_deconverter * cconvert;
  struct jpeg_color_quantizer * cquantize;
};


/* "Object" declarations for JPEG modules that may be supplied or called
 * directly by the surrounding application.
 * As with all objects in the JPEG library, these structs only define the
 * publicly visible methods and state variables of a module.  Additional
 * private fields may exist after the public ones.
 */


/* Error handler object */

struct jpeg_error_mgr {
  /* Error exit handler: does not return to caller */
  JMETHOD(void, error_exit, (j_common_ptr cinfo));
  /* Conditionally emit a trace or warning message */
  JMETHOD(void, emit_message, (j_common_ptr cinfo, int msg_level));
  /* Routine that actually outputs a trace or error message */
  JMETHOD(void, output_message, (j_common_ptr cinfo));
  /* Format a message string for the most recent JPEG error or message */
  JMETHOD(void, format_message, (j_common_ptr cinfo, char * buffer));
#define JMSG_LENGTH_MAX  200	/* recommended size of format_message buffer */
  /* Reset error state variables at start of a new image */
  JMETHOD(void, reset_error_mgr, (j_common_ptr cinfo));
  
  /* The message ID code and any parameters are saved here.
   * A message can have one string parameter or up to 8 int parameters.
   */
  int msg_code;
#define JMSG_STR_PARM_MAX  80
  union {
    int i[8];
    char s[JMSG_STR_PARM_MAX];
  } msg_parm;
  
  /* Standard state variables for error facility */
  
  int trace_level;		/* max msg_level that will be displayed */
  
  /* For recoverable corrupt-data errors, we emit a warning message,
   * but keep going unless emit_message chooses to abort.  emit_message
   * should count warnings in num_warnings.  The surrounding application
   * can check for bad data by seeing if num_warnings is nonzero at the
   * end of processing.
   */
  long num_warnings;		/* number of corrupt-data warnings */

  /* These fields point to the table(s) of error message strings.
   * An application can change the table pointer to switch to a different
   * message list (typically, to change the language in which errors are
   * reported).  Some applications may wish to add additional error codes
   * that will be handled by the JPEG library error mechanism; the second
   * table pointer is used for this purpose.
   *
   * First table includes all errors generated by JPEG library itself.
   * Error code 0 is reserved for a "no such error string" message.
   */
  const char * const * jpeg_message_table; /* Library errors */
  int last_jpeg_message;    /* Table contains strings 0..last_jpeg_message */
  /* Second table can be added by application (see cjpeg/djpeg for example).
   * It contains strings numbered first_addon_message..last_addon_message.
   */
  const char * const * addon_message_table; /* Non-library errors */
  int first_addon_message;	/* code for first string in addon table */
  int last_addon_message;	/* code for last string in addon table */
};


/* Progress monitor object */

struct jpeg_progress_mgr {
  JMETHOD(void, progress_monitor, (j_common_ptr cinfo));

  long pass_counter;		/* work units completed in this pass */
  long pass_limit;		/* total number of work units in this pass */
  int completed_passes;		/* passes completed so far */
  int total_passes;		/* total number of passes expected */
};


/* Data destination object for compression */

struct jpeg_destination_mgr {
  JOCTET * next_output_byte;	/* => next byte to write in buffer */
  size_t free_in_buffer;	/* # of byte spaces remaining in buffer */

  JMETHOD(void, init_destination, (j_compress_ptr cinfo));
  JMETHOD(boolean, empty_output_buffer, (j_compress_ptr cinfo));
  JMETHOD(void, term_destination, (j_compress_ptr cinfo));
};


/* Data source object for decompression */

struct jpeg_source_mgr {
  const JOCTET * next_input_byte; /* => next byte to read from buffer */
  size_t bytes_in_buffer;	/* # of bytes remaining in buffer */

  JMETHOD(void, init_source, (j_decompress_ptr cinfo));
  JMETHOD(boolean, fill_input_buffer, (j_decompress_ptr cinfo));
  JMETHOD(void, skip_input_data, (j_decompress_ptr cinfo, long num_bytes));
  JMETHOD(boolean, resync_to_restart, (j_decompress_ptr cinfo, int desired));
  JMETHOD(void, term_source, (j_decompress_ptr cinfo));
};


/* Memory manager object.
 * Allocates "small" objects (a few K total), "large" objects (tens of K),
 * and "really big" objects (virtual arrays with backing store if needed).
 * The memory manager does not allow individual objects to be freed; rather,
 * each created object is assigned to a pool, and whole pools can be freed
 * at once.  This is faster and more convenient than remembering exactly what
 * to free, especially where malloc()/free() are not too speedy.
 * NB: alloc routines never return NULL.  They exit to error_exit if not
 * successful.
 */

#define JPOOL_PERMANENT	0	/* lasts until master record is destroyed */
#define JPOOL_IMAGE	1	/* lasts until done with image/datastream */
#define JPOOL_NUMPOOLS	2

typedef struct jvirt_sarray_control * jvirt_sarray_ptr;
typedef struct jvirt_barray_control * jvirt_barray_ptr;


struct jpeg_memory_mgr {
  /* Method pointers */
  JMETHOD(void *, alloc_small, (j_common_ptr cinfo, int pool_id,
				size_t sizeofobject));
  JMETHOD(void FAR *, alloc_large, (j_common_ptr cinfo, int pool_id,
				     size_t sizeofobject));
  JMETHOD(JSAMPARRAY, alloc_sarray, (j_common_ptr cinfo, int pool_id,
				     JDIMENSION samplesperrow,
				     JDIMENSION numrows));
  JMETHOD(JBLOCKARRAY, alloc_barray, (j_common_ptr cinfo, int pool_id,
				      JDIMENSION blocksperrow,
				      JDIMENSION numrows));
  JMETHOD(jvirt_sarray_ptr, request_virt_sarray, (j_common_ptr cinfo,
						  int pool_id,
						  boolean pre_zero,
						  JDIMENSION samplesperrow,
						  JDIMENSION numrows,
						  JDIMENSION maxaccess));
  JMETHOD(jvirt_barray_ptr, request_virt_barray, (j_common_ptr cinfo,
						  int pool_id,
						  boolean pre_zero,
						  JDIMENSION blocksperrow,
						  JDIMENSION numrows,
						  JDIMENSION maxaccess));
  JMETHOD(void, realize_virt_arrays, (j_common_ptr cinfo));
  JMETHOD(JSAMPARRAY, access_virt_sarray, (j_common_ptr cinfo,
					   jvirt_sarray_ptr ptr,
					   JDIMENSION start_row,
					   JDIMENSION num_rows,
					   boolean writable));
  JMETHOD(JBLOCKARRAY, access_virt_barray, (j_common_ptr cinfo,
					    jvirt_barray_ptr ptr,
					    JDIMENSION start_row,
					    JDIMENSION num_rows,
					    boolean writable));
  JMETHOD(void, free_pool, (j_common_ptr cinfo, int pool_id));
  JMETHOD(void, self_destruct, (j_common_ptr cinfo));

  /* Limit on memory allocation for this JPEG object.  (Note that this is
   * merely advisory, not a guaranteed maximum; it only affects the space
   * used for virtual-array buffers.)  May be changed by outer application
   * after creating the JPEG object.
   */
  long max_memory_to_use;
};


/* Routine signature for application-supplied marker processing methods.
 * Need not pass marker code since it is stored in cinfo->unread_marker.
 */
typedef JMETHOD(boolean, jpeg_marker_parser_method, (j_decompress_ptr cinfo));


/* Declarations for routines called by application.
 * The JPP macro hides prototype parameters from compilers that can't cope.
 * Note JPP requires double parentheses.
 */

#ifdef HAVE_PROTOTYPES
#define JPP(arglist)	arglist
#else
#define JPP(arglist)	()
#endif


/* Short forms of external names for systems with bad linkers.
 * We shorten external names to be unique in the first six letters, which
 * is good enough for all known systems.
 * (If your compiler itself needs names to be unique in less than 15 
 * characters, you are out of luck.  Get a better compiler.)
 */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jpeg_std_error		jStdError
#define jpeg_CreateCompress	jCreaCompress
#define jpeg_CreateDecompress	jCreaDecompress
#define jpeg_destroy_compress	jDestCompress
#define jpeg_destroy_decompress	jDestDecompress
#define jpeg_stdio_dest		jStdDest
#define jpeg_stdio_src		jStdSrc
#define jpeg_set_defaults	jSetDefaults
#define jpeg_set_colorspace	jSetColorspace
#define jpeg_default_colorspace	jDefColorspace
#define jpeg_set_quality	jSetQuality
#define jpeg_set_linear_quality	jSetLQuality
#define jpeg_add_quant_table	jAddQuantTable
#define jpeg_quality_scaling	jQualityScaling
#define jpeg_simple_progression	jSimProgress
#define jpeg_suppress_tables	jSuppressTables
#define jpeg_alloc_quant_table	jAlcQTable
#define jpeg_alloc_huff_table	jAlcHTable
#define jpeg_start_compress	jStrtCompress
#define jpeg_write_scanlines	jWrtScanlines
#define jpeg_finish_compress	jFinCompress
#define jpeg_write_raw_data	jWrtRawData
#define jpeg_write_marker	jWrtMarker
#define jpeg_write_tables	jWrtTables
#define jpeg_read_header	jReadHeader
#define jpeg_start_decompress	jStrtDecompress
#define jpeg_read_scanlines	jReadScanlines
#define jpeg_finish_decompress	jFinDecompress
#define jpeg_read_raw_data	jReadRawData
#define jpeg_has_multiple_scans	jHasMultScn
#define jpeg_start_output	jStrtOutput
#define jpeg_finish_output	jFinOutput
#define jpeg_input_complete	jInComplete
#define jpeg_new_colormap	jNewCMap
#define jpeg_consume_input	jConsumeInput
#define jpeg_calc_output_dimensions	jCalcDimensions
#define jpeg_set_marker_processor	jSetMarker
#define jpeg_read_coefficients	jReadCoefs
#define jpeg_write_coefficients	jWrtCoefs
#define jpeg_copy_critical_parameters	jCopyCrit
#define jpeg_abort_compress	jAbrtCompress
#define jpeg_abort_decompress	jAbrtDecompress
#define jpeg_abort		jAbort
#define jpeg_destroy		jDestroy
#define jpeg_resync_to_restart	jResyncRestart
#endif /* NEED_SHORT_EXTERNAL_NAMES */


/* Default error-management setup */
EXTERN(struct jpeg_error_mgr *) jpeg_std_error
	JPP((struct jpeg_error_mgr * err));

/* Initialization of JPEG compression objects.
 * jpeg_create_compress() and jpeg_create_decompress() are the exported
 * names that applications should call.  These expand to calls on
 * jpeg_CreateCompress and jpeg_CreateDecompress with additional information
 * passed for version mismatch checking.
 * NB: you must set up the error-manager BEFORE calling jpeg_create_xxx.
 */
#define jpeg_create_compress(cinfo) \
    jpeg_CreateCompress((cinfo), JPEG_LIB_VERSION, \
			(size_t) sizeof(struct jpeg_compress_struct))
#define jpeg_create_decompress(cinfo) \
    jpeg_CreateDecompress((cinfo), JPEG_LIB_VERSION, \
			  (size_t) sizeof(struct jpeg_decompress_struct))
EXTERN(void) jpeg_CreateCompress JPP((j_compress_ptr cinfo,
				      int version, size_t structsize));
EXTERN(void) jpeg_CreateDecompress JPP((j_decompress_ptr cinfo,
					int version, size_t structsize));
/* Destruction of JPEG compression objects */
EXTERN(void) jpeg_destroy_compress JPP((j_compress_ptr cinfo));
EXTERN(void) jpeg_destroy_decompress JPP((j_decompress_ptr cinfo));

/* Standard data source and destination managers: stdio streams. */
/* Caller is responsible for opening the file before and closing after. */
EXTERN(void) jpeg_stdio_dest JPP((j_compress_ptr cinfo, FILE * outfile));
EXTERN(void) jpeg_stdio_src JPP((j_decompress_ptr cinfo, FILE * infile));

/* Default parameter setup for compression */
EXTERN(void) jpeg_set_defaults JPP((j_compress_ptr cinfo));
/* Compression parameter setup aids */
EXTERN(void) jpeg_set_colorspace JPP((j_compress_ptr cinfo,
				      J_COLOR_SPACE colorspace));
EXTERN(void) jpeg_default_colorspace JPP((j_compress_ptr cinfo));
EXTERN(void) jpeg_set_quality JPP((j_compress_ptr cinfo, int quality,
				   boolean force_baseline));
EXTERN(void) jpeg_set_linear_quality JPP((j_compress_ptr cinfo,
					  int scale_factor,
					  boolean force_baseline));
EXTERN(void) jpeg_add_quant_table JPP((j_compress_ptr cinfo, int which_tbl,
				       const unsigned int *basic_table,
				       int scale_factor,
				       boolean force_baseline));
EXTERN(int) jpeg_quality_scaling JPP((int quality));
EXTERN(void) jpeg_simple_progression JPP((j_compress_ptr cinfo));
EXTERN(void) jpeg_suppress_tables JPP((j_compress_ptr cinfo,
				       boolean suppress));
EXTERN(JQUANT_TBL *) jpeg_alloc_quant_table JPP((j_common_ptr cinfo));
EXTERN(JHUFF_TBL *) jpeg_alloc_huff_table JPP((j_common_ptr cinfo));

/* Main entry points for compression */
EXTERN(void) jpeg_start_compress JPP((j_compress_ptr cinfo,
				      boolean write_all_tables));
EXTERN(JDIMENSION) jpeg_write_scanlines JPP((j_compress_ptr cinfo,
					     JSAMPARRAY scanlines,
					     JDIMENSION num_lines));
EXTERN(void) jpeg_finish_compress JPP((j_compress_ptr cinfo));

/* Replaces jpeg_write_scanlines when writing raw downsampled data. */
EXTERN(JDIMENSION) jpeg_write_raw_data JPP((j_compress_ptr cinfo,
					    JSAMPIMAGE data,
					    JDIMENSION num_lines));

/* Write a special marker.  See libjpeg.doc concerning safe usage. */
EXTERN(void) jpeg_write_marker
	JPP((j_compress_ptr cinfo, int marker,
	     const JOCTET * dataptr, unsigned int datalen));

/* Alternate compression function: just write an abbreviated table file */
EXTERN(void) jpeg_write_tables JPP((j_compress_ptr cinfo));

/* Decompression startup: read start of JPEG datastream to see what's there */
EXTERN(int) jpeg_read_header JPP((j_decompress_ptr cinfo,
				  boolean require_image));
/* Return value is one of: */
#define JPEG_SUSPENDED		0 /* Suspended due to lack of input data */
#define JPEG_HEADER_OK		1 /* Found valid image datastream */
#define JPEG_HEADER_TABLES_ONLY	2 /* Found valid table-specs-only datastream */
/* If you pass require_image = TRUE (normal case), you need not check for
 * a TABLES_ONLY return code; an abbreviated file will cause an error exit.
 * JPEG_SUSPENDED is only possible if you use a data source module that can
 * give a suspension return (the stdio source module doesn't).
 */

/* Main entry points for decompression */
EXTERN(boolean) jpeg_start_decompress JPP((j_decompress_ptr cinfo));
EXTERN(JDIMENSION) jpeg_read_scanlines JPP((j_decompress_ptr cinfo,
					    JSAMPARRAY scanlines,
					    JDIMENSION max_lines));
EXTERN(boolean) jpeg_finish_decompress JPP((j_decompress_ptr cinfo));

/* Replaces jpeg_read_scanlines when reading raw downsampled data. */
EXTERN(JDIMENSION) jpeg_read_raw_data JPP((j_decompress_ptr cinfo,
					   JSAMPIMAGE data,
					   JDIMENSION max_lines));

/* Additional entry points for buffered-image mode. */
EXTERN(boolean) jpeg_has_multiple_scans JPP((j_decompress_ptr cinfo));
EXTERN(boolean) jpeg_start_output JPP((j_decompress_ptr cinfo,
				       int scan_number));
EXTERN(boolean) jpeg_finish_output JPP((j_decompress_ptr cinfo));
EXTERN(boolean) jpeg_input_complete JPP((j_decompress_ptr cinfo));
EXTERN(void) jpeg_new_colormap JPP((j_decompress_ptr cinfo));
EXTERN(int) jpeg_consume_input JPP((j_decompress_ptr cinfo));
/* Return value is one of: */
/* #define JPEG_SUSPENDED	0    Suspended due to lack of input data */
#define JPEG_REACHED_SOS	1 /* Reached start of new scan */
#define JPEG_REACHED_EOI	2 /* Reached end of image */
#define JPEG_ROW_COMPLETED	3 /* Completed one iMCU row */
#define JPEG_SCAN_COMPLETED	4 /* Completed last iMCU row of a scan */

/* Precalculate output dimensions for current decompression parameters. */
EXTERN(void) jpeg_calc_output_dimensions JPP((j_decompress_ptr cinfo));

/* Install a special processing method for COM or APPn markers. */
EXTERN(void) jpeg_set_marker_processor
	JPP((j_decompress_ptr cinfo, int marker_code,
	     jpeg_marker_parser_method routine));

/* Read or write raw DCT coefficients --- useful for lossless transcoding. */
EXTERN(jvirt_barray_ptr *) jpeg_read_coefficients JPP((j_decompress_ptr cinfo));
EXTERN(void) jpeg_write_coefficients JPP((j_compress_ptr cinfo,
					  jvirt_barray_ptr * coef_arrays));
EXTERN(void) jpeg_copy_critical_parameters JPP((j_decompress_ptr srcinfo,
						j_compress_ptr dstinfo));

/* If you choose to abort compression or decompression before completing
 * jpeg_finish_(de)compress, then you need to clean up to release memory,
 * temporary files, etc.  You can just call jpeg_destroy_(de)compress
 * if you're done with the JPEG object, but if you want to clean it up and
 * reuse it, call this:
 */
EXTERN(void) jpeg_abort_compress JPP((j_compress_ptr cinfo));
EXTERN(void) jpeg_abort_decompress JPP((j_decompress_ptr cinfo));

/* Generic versions of jpeg_abort and jpeg_destroy that work on either
 * flavor of JPEG object.  These may be more convenient in some places.
 */
EXTERN(void) jpeg_abort JPP((j_common_ptr cinfo));
EXTERN(void) jpeg_destroy JPP((j_common_ptr cinfo));

/* Default restart-marker-resync procedure for use by data source modules */
EXTERN(boolean) jpeg_resync_to_restart JPP((j_decompress_ptr cinfo,
					    int desired));


/* These marker codes are exported since applications and data source modules
 * are likely to want to use them.
 */

#define JPEG_RST0	0xD0	/* RST0 marker code */
#define JPEG_EOI	0xD9	/* EOI marker code */
#define JPEG_APP0	0xE0	/* APP0 marker code */
#define JPEG_COM	0xFE	/* COM marker code */


/* If we have a bad compiler that emits warnings (or worse, errors)
 * for structure definitions that are never filled in, keep it quiet by
 * supplying dummy definitions for the various substructures.
 */

#ifdef INCOMPLETE_TYPES_BROKEN
#ifndef JPEG_INTERNALS		/* will be defined in jpegint.h */
struct jvirt_sarray_control { long dummy; };
struct jvirt_barray_control { long dummy; };
struct jpeg_comp_master { long dummy; };
struct jpeg_c_main_controller { long dummy; };
struct jpeg_c_prep_controller { long dummy; };
struct jpeg_c_coef_controller { long dummy; };
struct jpeg_marker_writer { long dummy; };
struct jpeg_color_converter { long dummy; };
struct jpeg_downsampler { long dummy; };
struct jpeg_forward_dct { long dummy; };
struct jpeg_entropy_encoder { long dummy; };
struct jpeg_decomp_master { long dummy; };
struct jpeg_d_main_controller { long dummy; };
struct jpeg_d_coef_controller { long dummy; };
struct jpeg_d_post_controller { long dummy; };
struct jpeg_input_controller { long dummy; };
struct jpeg_marker_reader { long dummy; };
struct jpeg_entropy_decoder { long dummy; };
struct jpeg_inverse_dct { long dummy; };
struct jpeg_upsampler { long dummy; };
struct jpeg_color_deconverter { long dummy; };
struct jpeg_color_quantizer { long dummy; };
#endif /* JPEG_INTERNALS */
#endif /* INCOMPLETE_TYPES_BROKEN */


/*
 * The JPEG library modules define JPEG_INTERNALS before including this file.
 * The internal structure declarations are read only when that is true.
 * Applications using the library should not include jpegint.h, but may wish
 * to include jerror.h.
 */

#ifdef JPEG_INTERNALS
#include "jpegint.h"		/* fetch private declarations */
#include "jerror.h"		/* fetch error codes too */
#endif

#endif /* JPEGLIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeginc\jpegdata.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       jpegdata.h
//
//--------------------------------------------------------------------------

#ifndef __CJPEGDATASOURCE
#define __CJPEGDATASOURCE

#include <stdio.h>
extern "C" {
#include "jpeglib.h"
}

class CJPEGDatasource 
{
public:

	CJPEGDatasource () {};
	virtual ~CJPEGDatasource () {};
	virtual void Create (j_decompress_ptr cinfo); 

	// required interface
	virtual void InitSource (j_decompress_ptr cinfo) = 0;
	virtual boolean FillInputBuffer (j_decompress_ptr cinfo) = 0;
	virtual void SkipInputData (j_decompress_ptr cinfo, long num_bytes) = 0;
	virtual void TermSource (j_decompress_ptr cinfo) = 0;
	
	// optional: override to implement resync; default implementation
	// assumes no backtracking possible
	virtual boolean ResyncToRestart (j_decompress_ptr cinfo, int desired);
	
private:

	typedef struct jpeg_source_record {
		jpeg_source_mgr sourceMgr;
		CJPEGDatasource
		* dataSource;
	} jpeg_source_record, *jpeg_source_ptr;

	static void InitSourceEntry (j_decompress_ptr cinfo);
	static boolean FillInputBufferEntry (j_decompress_ptr cinfo);
	static void SkipInputDataEntry (j_decompress_ptr cinfo, long num_bytes);
	static boolean ResyncToRestartEntry (j_decompress_ptr cinfo, int desired);
	static void TermSourceEntry (j_decompress_ptr cinfo);
	
	jpeg_source_record m_dataSource;
		
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\handler\jpeginc\jpegint.h ===
/*
 * jpegint.h
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file provides common declarations for the various JPEG modules.
 * These declarations are considered internal to the JPEG library; most
 * applications using the library shouldn't need to include this file.
 */


/* Declarations for both compression & decompression */

typedef enum {			/* Operating modes for buffer controllers */
	JBUF_PASS_THRU,		/* Plain stripwise operation */
	/* Remaining modes require a full-image buffer to have been created */
	JBUF_SAVE_SOURCE,	/* Run source subobject only, save output */
	JBUF_CRANK_DEST,	/* Run dest subobject only, using saved data */
	JBUF_SAVE_AND_PASS	/* Run both subobjects, save output */
} J_BUF_MODE;

/* Values of global_state field (jdapi.c has some dependencies on ordering!) */
#define CSTATE_START	100	/* after create_compress */
#define CSTATE_SCANNING	101	/* start_compress done, write_scanlines OK */
#define CSTATE_RAW_OK	102	/* start_compress done, write_raw_data OK */
#define CSTATE_WRCOEFS	103	/* jpeg_write_coefficients done */
#define DSTATE_START	200	/* after create_decompress */
#define DSTATE_INHEADER	201	/* reading header markers, no SOS yet */
#define DSTATE_READY	202	/* found SOS, ready for start_decompress */
#define DSTATE_PRELOAD	203	/* reading multiscan file in start_decompress*/
#define DSTATE_PRESCAN	204	/* performing dummy pass for 2-pass quant */
#define DSTATE_SCANNING	205	/* start_decompress done, read_scanlines OK */
#define DSTATE_RAW_OK	206	/* start_decompress done, read_raw_data OK */
#define DSTATE_BUFIMAGE	207	/* expecting jpeg_start_output */
#define DSTATE_BUFPOST	208	/* looking for SOS/EOI in jpeg_finish_output */
#define DSTATE_RDCOEFS	209	/* reading file in jpeg_read_coefficients */
#define DSTATE_STOPPING	210	/* looking for EOI in jpeg_finish_decompress */


/* Declarations for compression modules */

/* Master control module */
struct jpeg_comp_master {
  JMETHOD(void, prepare_for_pass, (j_compress_ptr cinfo));
  JMETHOD(void, pass_startup, (j_compress_ptr cinfo));
  JMETHOD(void, finish_pass, (j_compress_ptr cinfo));

  /* State variables made visible to other modules */
  boolean call_pass_startup;	/* True if pass_startup must be called */
  boolean is_last_pass;		/* True during last pass */
};

/* Main buffer control (downsampled-data buffer) */
struct jpeg_c_main_controller {
  JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
  JMETHOD(void, process_data, (j_compress_ptr cinfo,
			       JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,
			       JDIMENSION in_rows_avail));
};

/* Compression preprocessing (downsampling input buffer control) */
struct jpeg_c_prep_controller {
  JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
  JMETHOD(void, pre_process_data, (j_compress_ptr cinfo,
				   JSAMPARRAY input_buf,
				   JDIMENSION *in_row_ctr,
				   JDIMENSION in_rows_avail,
				   JSAMPIMAGE output_buf,
				   JDIMENSION *out_row_group_ctr,
				   JDIMENSION out_row_groups_avail));
};

/* Coefficient buffer control */
struct jpeg_c_coef_controller {
  JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
  JMETHOD(boolean, compress_data, (j_compress_ptr cinfo,
				   JSAMPIMAGE input_buf));
};

/* Colorspace conversion */
struct jpeg_color_converter {
  JMETHOD(void, start_pass, (j_compress_ptr cinfo));
  JMETHOD(void, color_convert, (j_compress_ptr cinfo,
				JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
				JDIMENSION output_row, int num_rows));
};

/* Downsampling */
struct jpeg_downsampler {
  JMETHOD(void, start_pass, (j_compress_ptr cinfo));
  JMETHOD(void, downsample, (j_compress_ptr cinfo,
			     JSAMPIMAGE input_buf, JDIMENSION in_row_index,
			     JSAMPIMAGE output_buf,
			     JDIMENSION out_row_group_index));

  boolean need_context_rows;	/* TRUE if need rows above & below */
};

/* Forward DCT (also controls coefficient quantization) */
struct jpeg_forward_dct {
  JMETHOD(void, start_pass, (j_compress_ptr cinfo));
  /* perhaps this should be an array??? */
  JMETHOD(void, forward_DCT, (j_compress_ptr cinfo,
			      jpeg_component_info * compptr,
			      JSAMPARRAY sample_data, JBLOCKROW coef_blocks,
			      JDIMENSION start_row, JDIMENSION start_col,
			      JDIMENSION num_blocks));
};

/* Entropy encoding */
struct jpeg_entropy_encoder {
  JMETHOD(void, start_pass, (j_compress_ptr cinfo, boolean gather_statistics));
  JMETHOD(boolean, encode_mcu, (j_compress_ptr cinfo, JBLOCKROW *MCU_data));
  JMETHOD(void, finish_pass, (j_compress_ptr cinfo));
};

/* Marker writing */
struct jpeg_marker_writer {
  /* write_any_marker is exported for use by applications */
  /* Probably only COM and APPn markers should be written */
  JMETHOD(void, write_any_marker, (j_compress_ptr cinfo, int marker,
				   const JOCTET *dataptr, unsigned int datalen));
  JMETHOD(void, write_file_header, (j_compress_ptr cinfo));
  JMETHOD(void, write_frame_header, (j_compress_ptr cinfo));
  JMETHOD(void, write_scan_header, (j_compress_ptr cinfo));
  JMETHOD(void, write_file_trailer, (j_compress_ptr cinfo));
  JMETHOD(void, write_tables_only, (j_compress_ptr cinfo));
};


/* Declarations for decompression modules */

/* Master control module */
struct jpeg_decomp_master {
  JMETHOD(void, prepare_for_output_pass, (j_decompress_ptr cinfo));
  JMETHOD(void, finish_output_pass, (j_decompress_ptr cinfo));

  /* State variables made visible to other modules */
  boolean is_dummy_pass;	/* True during 1st pass for 2-pass quant */
};

/* Input control module */
struct jpeg_input_controller {
  JMETHOD(int, consume_input, (j_decompress_ptr cinfo));
  JMETHOD(void, reset_input_controller, (j_decompress_ptr cinfo));
  JMETHOD(void, start_input_pass, (j_decompress_ptr cinfo));
  JMETHOD(void, finish_input_pass, (j_decompress_ptr cinfo));

  /* State variables made visible to other modules */
  boolean has_multiple_scans;	/* True if file has multiple scans */
  boolean eoi_reached;		/* True when EOI has been consumed */
};

/* Main buffer control (downsampled-data buffer) */
struct jpeg_d_main_controller {
  JMETHOD(void, start_pass, (j_decompress_ptr cinfo, J_BUF_MODE pass_mode));
  JMETHOD(void, process_data, (j_decompress_ptr cinfo,
			       JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
			       JDIMENSION out_rows_avail));
};

/* Coefficient buffer control */
struct jpeg_d_coef_controller {
  JMETHOD(void, start_input_pass, (j_decompress_ptr cinfo));
  JMETHOD(int, consume_data, (j_decompress_ptr cinfo));
  JMETHOD(void, start_output_pass, (j_decompress_ptr cinfo));
  JMETHOD(int, decompress_data, (j_decompress_ptr cinfo,
				 JSAMPIMAGE output_buf));
  /* Pointer to array of coefficient virtual arrays, or NULL if none */
  jvirt_barray_ptr *coef_arrays;
};

/* Decompression postprocessing (color quantization buffer control) */
struct jpeg_d_post_controller {
  JMETHOD(void, start_pass, (j_decompress_ptr cinfo, J_BUF_MODE pass_mode));
  JMETHOD(void, post_process_data, (j_decompress_ptr cinfo,
				    JSAMPIMAGE input_buf,
				    JDIMENSION *in_row_group_ctr,
				    JDIMENSION in_row_groups_avail,
				    JSAMPARRAY output_buf,
				    JDIMENSION *out_row_ctr,
				    JDIMENSION out_rows_avail));
};

/* Marker reading & parsing */
struct jpeg_marker_reader {
  JMETHOD(void, reset_marker_reader, (j_decompress_ptr cinfo));
  /* Read markers until SOS or EOI.
   * Returns same codes as are defined for jpeg_consume_input:
   * JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
   */
  JMETHOD(int, read_markers, (j_decompress_ptr cinfo));
  /* Read a restart marker --- exported for use by entropy decoder only */
  jpeg_marker_parser_method read_restart_marker;
  /* Application-overridable marker processing methods */
  jpeg_marker_parser_method process_COM;
  jpeg_marker_parser_method process_APPn[16];

  /* State of marker reader --- nominally internal, but applications
   * supplying COM or APPn handlers might like to know the state.
   */
  boolean saw_SOI;		/* found SOI? */
  boolean saw_SOF;		/* found SOF? */
  int next_restart_num;		/* next restart number expected (0-7) */
  unsigned int discarded_bytes;	/* # of bytes skipped looking for a marker */
};

/* Entropy decoding */
struct jpeg_entropy_decoder {
  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
  JMETHOD(boolean, decode_mcu, (j_decompress_ptr cinfo,
				JBLOCKROW *MCU_data));
};

/* Inverse DCT (also performs dequantization) */
typedef JMETHOD(void, inverse_DCT_method_ptr,
		(j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col));

struct jpeg_inverse_dct {
  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
  /* It is useful to allow each component to have a separate IDCT method. */
  inverse_DCT_method_ptr inverse_DCT[MAX_COMPONENTS];
};

/* Upsampling (note that upsampler must also call color converter) */
struct jpeg_upsampler {
  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
  JMETHOD(void, upsample, (j_decompress_ptr cinfo,
			   JSAMPIMAGE input_buf,
			   JDIMENSION *in_row_group_ctr,
			   JDIMENSION in_row_groups_avail,
			   JSAMPARRAY output_buf,
			   JDIMENSION *out_row_ctr,
			   JDIMENSION out_rows_avail));

  boolean need_context_rows;	/* TRUE if need rows above & below */
};

/* Colorspace conversion */
struct jpeg_color_deconverter {
  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
  JMETHOD(void, color_convert, (j_decompress_ptr cinfo,
				JSAMPIMAGE input_buf, JDIMENSION input_row,
				JSAMPARRAY output_buf, int num_rows));
};

/* Color quantization or color precision reduction */
struct jpeg_color_quantizer {
  JMETHOD(void, start_pass, (j_decompress_ptr cinfo, boolean is_pre_scan));
  JMETHOD(void, color_quantize, (j_decompress_ptr cinfo,
				 JSAMPARRAY input_buf, JSAMPARRAY output_buf,
				 int num_rows));
  JMETHOD(void, finish_pass, (j_decompress_ptr cinfo));
  JMETHOD(void, new_color_map, (j_decompress_ptr cinfo));
};


/* Miscellaneous useful macros */

#undef MAX
#define MAX(a,b)	((a) > (b) ? (a) : (b))
#undef MIN
#define MIN(a,b)	((a) < (b) ? (a) : (b))


/* We assume that right shift corresponds to signed division by 2 with
 * rounding towards minus infinity.  This is correct for typical "arithmetic
 * shift" instructions that shift in copies of the sign bit.  But some
 * C compilers implement >> with an unsigned shift.  For these machines you
 * must define RIGHT_SHIFT_IS_UNSIGNED.
 * RIGHT_SHIFT provides a proper signed right shift of an INT32 quantity.
 * It is only applied with constant shift counts.  SHIFT_TEMPS must be
 * included in the variables of any routine using RIGHT_SHIFT.
 */

#ifdef RIGHT_SHIFT_IS_UNSIGNED
#define SHIFT_TEMPS	INT32 shift_temp;
#define RIGHT_SHIFT(x,shft)  \
	((shift_temp = (x)) < 0 ? \
	 (shift_temp >> (shft)) | ((~((INT32) 0)) << (32-(shft))) : \
	 (shift_temp >> (shft)))
#else
#define SHIFT_TEMPS
#define RIGHT_SHIFT(x,shft)	((x) >> (shft))
#endif


/* Short forms of external names for systems with bad linkers. */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jinit_compress_master	jICompress
#define jinit_c_master_control	jICMaster
#define jinit_c_main_controller	jICMainC
#define jinit_c_prep_controller	jICPrepC
#define jinit_c_coef_controller	jICCoefC
#define jinit_color_converter	jICColor
#define jinit_downsampler	jIDownsampler
#define jinit_forward_dct	jIFDCT
#define jinit_huff_encoder	jIHEncoder
#define jinit_phuff_encoder	jIPHEncoder
#define jinit_marker_writer	jIMWriter
#define jinit_master_decompress	jIDMaster
#define jinit_d_main_controller	jIDMainC
#define jinit_d_coef_controller	jIDCoefC
#define jinit_d_post_controller	jIDPostC
#define jinit_input_controller	jIInCtlr
#define jinit_marker_reader	jIMReader
#define jinit_huff_decoder	jIHDecoder
#define jinit_phuff_decoder	jIPHDecoder
#define jinit_inverse_dct	jIIDCT
#define jinit_upsampler		jIUpsampler
#define jinit_color_deconverter	jIDColor
#define jinit_1pass_quantizer	jI1Quant
#define jinit_2pass_quantizer	jI2Quant
#define jinit_merged_upsampler	jIMUpsampler
#define jinit_memory_mgr	jIMemMgr
#define jdiv_round_up		jDivRound
#define jround_up		jRound
#define jcopy_sample_rows	jCopySamples
#define jcopy_block_row		jCopyBlocks
#define jzero_far		jZeroFar
#define jpeg_zigzag_order	jZIGTable
#define jpeg_natural_order	jZAGTable
#endif /* NEED_SHORT_EXTERNAL_NAMES */


/* Compression module initialization routines */
EXTERN(void) jinit_compress_master JPP((j_compress_ptr cinfo));
EXTERN(void) jinit_c_master_control JPP((j_compress_ptr cinfo,
					 boolean transcode_only));
EXTERN(void) jinit_c_main_controller JPP((j_compress_ptr cinfo,
					  boolean need_full_buffer));
EXTERN(void) jinit_c_prep_controller JPP((j_compress_ptr cinfo,
					  boolean need_full_buffer));
EXTERN(void) jinit_c_coef_controller JPP((j_compress_ptr cinfo,
					  boolean need_full_buffer));
EXTERN(void) jinit_color_converter JPP((j_compress_ptr cinfo));
EXTERN(void) jinit_downsampler JPP((j_compress_ptr cinfo));
EXTERN(void) jinit_forward_dct JPP((j_compress_ptr cinfo));
EXTERN(void) jinit_huff_encoder JPP((j_compress_ptr cinfo));
EXTERN(void) jinit_phuff_encoder JPP((j_compress_ptr cinfo));
EXTERN(void) jinit_marker_writer JPP((j_compress_ptr cinfo));
/* Decompression module initialization routines */
EXTERN(void) jinit_master_decompress JPP((j_decompress_ptr cinfo));
EXTERN(void) jinit_d_main_controller JPP((j_decompress_ptr cinfo,
					  boolean need_full_buffer));
EXTERN(void) jinit_d_coef_controller JPP((j_decompress_ptr cinfo,
					  boolean need_full_buffer));
EXTERN(void) jinit_d_post_controller JPP((j_decompress_ptr cinfo,
					  boolean need_full_buffer));
EXTERN(void) jinit_input_controller JPP((j_decompress_ptr cinfo));
EXTERN(void) jinit_marker_reader JPP((j_decompress_ptr cinfo));
EXTERN(void) jinit_huff_decoder JPP((j_decompress_ptr cinfo));
EXTERN(void) jinit_phuff_decoder JPP((j_decompress_ptr cinfo));
EXTERN(void) jinit_inverse_dct JPP((j_decompress_ptr cinfo));
EXTERN(void) jinit_upsampler JPP((j_decompress_ptr cinfo));
EXTERN(void) jinit_color_deconverter JPP((j_decompress_ptr cinfo));
EXTERN(void) jinit_1pass_quantizer JPP((j_decompress_ptr cinfo));
EXTERN(void) jinit_2pass_quantizer JPP((j_decompress_ptr cinfo));
EXTERN(void) jinit_merged_upsampler JPP((j_decompress_ptr cinfo));
/* Memory manager initialization */
EXTERN(void) jinit_memory_mgr JPP((j_common_ptr cinfo));

/* Utility routines in jutils.c */
EXTERN(long) jdiv_round_up JPP((long a, long b));
EXTERN(long) jround_up JPP((long a, long b));
EXTERN(void) jcopy_sample_rows JPP((JSAMPARRAY input_array, int source_row,
				    JSAMPARRAY output_array, int dest_row,
				    int num_rows, JDIMENSION num_cols));
EXTERN(void) jcopy_block_row JPP((JBLOCKROW input_row, JBLOCKROW output_row,
				  JDIMENSION num_blocks));
EXTERN(void) jzero_far JPP((void FAR * target, size_t bytestozero));
/* Constant tables in jutils.c */
extern const int jpeg_zigzag_order[]; /* natural coef order to zigzag order */
extern const int jpeg_natural_order[]; /* zigzag coef order to natural order */

/* Suppress undefined-structure complaints if necessary. */

#ifdef INCOMPLETE_TYPES_BROKEN
#ifndef AM_MEMORY_MANAGER	/* only jmemmgr.c defines these */
struct jvirt_sarray_control { long dummy; };
struct jvirt_barray_control { long dummy; };
#endif
#endif /* INCOMPLETE_TYPES_BROKEN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\help\msiauto.hh ===
/* msiauto.hh = help context identifiers for automation help

  This file is included by msiauto.hpj, makeodl.cpp, autosrv.cpp
*/

#define MsiBase_Object                1
#define MsiBase_HasInterface          2
#define MsiBase_RefCount              3
#define MsiBase_GetInterface          4

#define Msi_Obsolete                 99

#define MsiData_Object              100
#define MsiData_StringValue         199
#define MsiData_IntegerValue        101

#define MsiString_Object            200
#define MsiString_Value             299
#define MsiString_IntegerValue      201
#define MsiString_TextSize          202
#define MsiString_CharacterCount    203
#define MsiString_IsDBCS            204
#define MsiString_Compare           205
#define MsiString_Append            206
#define MsiString_Add               207
#define MsiString_Extract           208
#define MsiString_Remove            209
#define MsiString_UpperCase         210
#define MsiString_LowerCase         211

#define MsiRecord_Object            300
#define MsiRecord_Data              399
#define MsiRecord_StringData        301     
#define MsiRecord_IntegerData       302     
#define MsiRecord_ObjectData        303     
#define MsiRecord_FieldCount        304
#define MsiRecord_IsInteger         305
#define MsiRecord_IsNull            306
#define MsiRecord_IsChanged         307
#define MsiRecord_TextSize          308
#define MsiRecord_FormatText        309
#define MsiRecord_ClearData         310
#define MsiRecord_ClearUpdate       311

#define MsiVolume_Object            400
#define MsiVolume_Path              499
#define MsiVolume_VolumeID          401
#define MsiVolume_DriveType         402
#define MsiVolume_SupportsLFN       403
#define MsiVolume_FreeSpace         404
#define MsiVolume_ClusterSize       405
#define MsiVolume_FileSystem        406
#define MsiVolume_UNCServer         407
#define MsiVolume_SerialNum         408
#define MsiVolume_DiskNotInDrive    409
#define MsiVolume_VolumeLabel       410
#define MsiVolume_TotalSpace        411
#define MsiVolume_FileSystemFlags   412

#define MsiPath_Object              500
#define MsiPath_Path                599
#define MsiPath_Volume              501
#define MsiPath_AppendPiece         502
#define MsiPath_ChopPiece           503
#define MsiPath_FileExists          504
#define MsiPath_GetFullFilePath     505
#define MsiPath_GetFileAttribute    507
#define MsiPath_SetFileAttribute    508
#define MsiPath_Exists              509
#define MsiPath_FileSize            510
#define MsiPath_FileDate            511
#define MsiPath_RemoveFile          512
#define MsiPath_EnsureExists        513
#define MsiPath_Remove              514
#define MsiPath_Writable            515
#define MsiPath_FileWritable        516
#define MsiPath_FileInUse           517
#define MsiPath_UpdateResource      518
#define MsiPath_ClusteredFileSize   519
#define MsiPath_GetFileVersionString 520
#define MsiPath_CheckFileVersion    521
#define MsiPath_GetLangIDStringFromFile 522
#define MsiPath_CheckLanguageIDs    523
#define MsiPath_Compare             524
#define MsiPath_Child               525
#define MsiPath_TempFileName        526
#define MsiPath_FindFile            527
#define MsiPath_SubFolders          528
#define MsiPath_EndSubPath          529
#define MsiPath_ReadResource        530
#define MsiPath_GetImportModulesEnum 531
#define MsiPath_SetVolume           532
#define MsiPath_ComputeFileChecksum 533
#define MsiPath_GetFileOriginalChecksum 534
#define MsiPath_BindImage           535
#define MsiPath_SupportsLFN         536
#define MsiPath_GetFullUNCFilePath  537
#define MsiPath_RelativePath        538
#define MsiPath_GetSelfRelativeSD	539

#define MsiFileCopy_Object          600
#define MsiFileCopy_CopyTo          601
#define MsiFileCopy_ChangeMedia     602

#define MsiRegKey_Object            700
#define MsiRegKey_Value             701
#define MsiRegKey_Exists            702
#define MsiRegKey_RemoveValue       703
#define MsiRegKey_RemoveSubKey      704
#define MsiRegKey_RemoveSubTree     705
#define MsiRegKey_Values            706
#define MsiRegKey_SubKeys           707
#define MsiRegKey_CreateChild       708
#define MsiRegKey_Key               709
#define MsiRegKey_ValueExists       710
#define MsiRegKey_GetSelfRelativeSD	711

#define MsiTable_Object             800
#define MsiTable_Database           801
#define MsiTable_RowCount           802
#define MsiTable_ColumnCount        803
#define MsiTable_PrimaryKeyCount    804
#define MsiTable_ReadOnly           805
#define MsiTable_ColumnName         806
#define MsiTable_ColumnType         807
#define MsiTable_GetColumnIndex     808
#define MsiTable_CreateColumn       809
#define MsiTable_CreateCursor       810
#define MsiTable_LinkTree           811

#define MsiCursor_Object            900
#define MsiCursor_Table             901
#define MsiCursor_Filter            902
#define MsiCursor_IntegerData       903
#define MsiCursor_StringData        904
#define MsiCursor_ObjectData        905
#define MsiCursor_StreamData        906
#define MsiCursor_PutNull           907
#define MsiCursor_Reset             908
#define MsiCursor_Next              909
#define MsiCursor_Update            910
#define MsiCursor_Insert            911
#define MsiCursor_InsertTemporary   912
#define MsiCursor_Assign            913
#define MsiCursor_Merge             914
#define MsiCursor_Refresh           915
#define MsiCursor_Delete            916
#define MsiCursor_Seek              917
#define MsiCursor_RowState          918
#define MsiCursor_DateData          919
#define MsiCursor_Validate          920
#define MsiCursor_Moniker           921
#define MsiCursor_Replace           922

#define MsiAuto_Object                     1000
#define MsiAuto_CreateServices             1001
#define MsiAuto_CreateEngine               1002
#define MsiAuto_CreateHandler              1003
#define MsiAuto_CreateMessageHandler       1004
#define MsiAuto_CreateConfigurationManager 1005
#define MsiAuto_OpcodeName                 1006
#define MsiAuto_ShowAsserts                1007
#define MsiAuto_SetDBCSSimulation          1008
#define MsiAuto_AssertNoObjects			   1009
#define MsiAuto_SetRefTracking			   1010
#define MsiAuto_CreateExecutor            1011

#define MsiServices_Object                    1100
#define MsiServices_GetAllocator              1101
#define MsiServices_CreateString              1102
#define MsiServices_CreateRecord              1103
#define MsiServices_SetPlatformProperties     1104
#define MsiServices_CreateLog                 1105
#define MsiServices_WriteLog                  1106
#define MsiServices_LoggingEnabled            1107
#define MsiServices_CreateDatabase            1108
#define MsiServices_CreateDatabaseFromStorage 1109
#define MsiServices_CreatePath                1110
#define MsiServices_CreateVolume              1111
#define MsiServices_CreateCopier              1112
#define MsiServices_ClearAllCaches            1113
#define MsiServices_EnumDriveType             1114
#define MsiServices_GetModuleUsage            1115
#define MsiServices_GetLocalPath              1116
#define MsiServices_CreateRegKey              1117
#define MsiServices_RegisterFont              1118
#define MsiServices_UnRegisterFont            1119
#define MsiServices_WriteIniFile              1120
#define MsiServices_ReadIniFile               1121
#define MsiServices_GetLangNamesFromLangIDString 1122
#define MsiServices_CreateStorage             1123
#define MsiServices_GetUnhandledError         1124
#define MsiServices_SupportLanguageId         1125
#define MsiServices_CreateVolumeFromLabel     1127
#define MsiServices_CreateShortcut            1128
#define MsiServices_RemoveShortcut            1129
#define MsiServices_AttachClient              1132
#define MsiServices_DetachClient              1133
#define MsiServices_ExtractFileName           1134
#define MsiServices_ValidateFileName          1135
#define MsiServices_CreateFileStream          1136
#define MsiServices_CreateMemoryStream        1137
#define MsiServices_RegisterTypeLibrary       1138
#define MsiServices_UnregisterTypeLibrary     1139
#define MsiServices_GetShellFolderPath        1140
#define MsiServices_GetUserProfilePath        1141
#define MsiServices_CreateFilePath            1142
#define MsiServices_RipFileNameFromPath       1143
#define MsiServices_CreatePatcher             1144

#define MsiView_Object             1200
#define MsiView_Execute            1201
#define MsiView_FieldCount         1202
#define MsiView_Fetch              1203
#define MsiView_GetColumnNames     1204
#define MsiView_GetColumnTypes     1205
#define MsiView_Modify             1206
#define MsiView_RowCount           1207
#define MsiView_Close              1208
#define MsiView_GetError           1209
#define MsiView_State              1210

#define MsiDatabase_Object               1300
#define MsiDatabase_UpdateState          1301
#define MsiDatabase_Storage              1302
#define MsiDatabase_OpenView             1303
#define MsiDatabase_GetPrimaryKeys       1304
#define MsiDatabase_ImportTable          1305
#define MsiDatabase_ExportTable          1306
#define MsiDatabase_DropTable            1307
#define MsiDatabase_FindTable            1308
#define MsiDatabase_LoadTable            1309
#define MsiDatabase_CreateTable          1310
#define MsiDatabase_LockTable            1311
#define MsiDatabase_GetCatalogTable      1312
#define MsiDatabase_DecodeString         1313
#define MsiDatabase_EncodeString         1314
#define MsiDatabase_CreateTempTableName  1315
#define MsiDatabase_Commit               1316
#define MsiDatabase_CreateOutputDatabase 1317
#define MsiDatabase_GenerateTransform    1318
#define MsiDatabase_SetTransform         1319
#define MsiDatabase_MergeDatabase        1320
#define MsiDatabase_TableState           1321
#define MsiDatabase_ANSICodePage         1322

#define MsiEngine_Object                 1400
#define MsiEngine_Services               1401
#define MsiEngine_ConfigurationServer    1402
#define MsiEngine_Handler                1403
#define MsiEngine_Database               1404
#define MsiEngine_Property               1405
#define MsiEngine_SelectionManager       1406
#define MsiEngine_DirectoryManager       1407
#define MsiEngine_Initialize             1408
#define MsiEngine_Terminate              1409
#define MsiEngine_DoAction               1410
#define MsiEngine_Sequence               1411
#define MsiEngine_Message                1412
#define MsiEngine_OpenView               1414
#define MsiEngine_ResolveFolderProperty  1415
#define MsiEngine_FormatText             1416
#define MsiEngine_EvaluateCondition      1417
#define MsiEngine_ExecuteRecord          1418
#define MsiEngine_ValidateProductID      1419
#define MsiEngine_GetMode                1420
#define MsiEngine_SetMode                1421


#define MsiHandler_Object           1500
#define MsiHandler_Message          1501
#define MsiHandler_DoAction         1502
#define MsiHandler_Break            1503

#define MsiDialog_Object            1600
#define MsiDialog_Visible           1601
#define MsiDialog_ControlCreate     1602
#define MsiDialog_Attribute         1603
#define MsiDialog_Control           1604
#define MsiDialog_AddControl        1605
#define MsiDialog_Execute           1606
#define MsiDialog_Reset             1607
#define MsiDialog_EventAction       1608
#define MsiDialog_RemoveControl     1609
#define MsiDialog_StringValue       1610
#define MsiDialog_IntegerValue      1611
#define MsiDialog_Handler           1612
#define MsiDialog_PropertyChanged	1613
#define MsiDialog_FinishCreate      1614
#define MsiDialog_HandleEvent       1615

#define MsiEvent_Object               1700
#define MsiEvent_PropertyChanged      1701
#define MsiEvent_ControlActivated     1702
#define MsiEvent_RegisterControlEvent 1703
#define MsiEvent_Handler              1704
#define MsiEvent_PublishEvent         1705
#define MsiEvent_Control              1706
#define MsiEvent_Attribute            1707
#define MsiEvent_EventAction          1708
#define MsiEvent_SetFocus             1709
#define MsiEvent_StringValue          1710
#define MsiEvent_IntegerValue         1711
#define MsiEvent_HandleEvent          1712
#define MsiEvent_Engine               1713
#define MsiEvent_Escape               1714

#define MsiControl_Object             1800
#define MsiControl_Attribute          1801
#define MsiControl_CanTakeFocus       1802
#define MsiControl_HandleEvent        1803
#define MsiControl_Undo               1804
#define MsiControl_SetPropertyInDatabase 1805
#define MsiControl_GetPropertyFromDatabase 1806
#define MsiControl_SetFocus           1807
#define MsiControl_Dialog             1808
#define MsiControl_WindowMessage      1809
#define MsiControl_StringValue        1810
#define MsiControl_IntegerValue       1811
#define MsiControl_GetIndirectPropertyFromDatabase 1812

#define MsiDialogHandler_Object                1900         
#define MsiDialogHandler_DialogCreate          1901 
#define MsiDialogHandler_Dialog                1902
#define MsiDialogHandler_DialogFromWindow      1903  
#define MsiDialogHandler_AddDialog             1904
#define MsiDialogHandler_RemoveDialog          1905

#define MsiStorage_Object              2000
#define MsiStorage_Class               2001
#define MsiStorage_OpenStream          2002
#define MsiStorage_OpenStorage         2003
#define MsiStorage_Streams             2004
#define MsiStorage_Storages            2005
#define MsiStorage_RemoveElement       2006
#define MsiStorage_Commit              2007
#define MsiStorage_Rollback            2008
#define MsiStorage_DeleteOnRelease     2009
#define MsiStorage_CreateSummaryInfo   2010
#define MsiStorage_CopyTo              2011
#define MsiStorage_Name                2012
#define MsiStorage_RenameElement       2013

#define MsiStream_Object           2100
#define MsiStream_Length           2101
#define MsiStream_Remaining        2102
#define MsiStream_Error            2103
#define MsiStream_GetData          2104
#define MsiStream_PutData          2105
#define MsiStream_GetInt16         2106
#define MsiStream_GetInt32         2107
#define MsiStream_PutInt16         2108
#define MsiStream_PutInt32         2109
#define MsiStream_Reset            2110
#define MsiStream_Seek             2111
#define MsiStream_Clone            2112

#define MsiSummaryInfo_Object              2200
#define MsiSummaryInfo_Property            2299
#define MsiSummaryInfo_PropertyCount       2201
#define MsiSummaryInfo_PropertyType        2202
#define MsiSummaryInfo_WritePropertyStream 2203

#define MsiMalloc_Object           2300
#define MsiMalloc_Alloc            2301
#define MsiMalloc_Free             2302
#define MsiMalloc_SetDebugFlags    2303
#define MsiMalloc_GetDebugFlags    2304
#define MsiMalloc_CheckAllBlocks   2305
#define MsiMalloc_FCheckBlock      2306
#define MsiMalloc_GetSizeOfBlock   2307

#define MsiSelectionManager_Object                2400
#define MsiSelectionManager_LoadSelectionTables   2401
#define MsiSelectionManager_FeatureTable          2402
#define MsiSelectionManager_ProcessConditionTable 2403
#define MsiSelectionManager_ComponentTable        2404
#define MsiSelectionManager_FreeSelectionTables   2405
#define MsiSelectionManager_SetFeatureHandle      2406
#define MsiSelectionManager_SetComponent          2407
#define MsiSelectionManager_SetInstallLevel       2408
#define MsiSelectionManager_GetVolumeCostTable    2409
#define MsiSelectionManager_RecostDirectory       2411
#define MsiSelectionManager_InitializeDynamicCost 2413
#define MsiSelectionManager_RegisterCostAdjuster  2414
#define MsiSelectionManager_InitializeComponents  2415
#define MsiSelectionManager_ConfigureFeature      2416
#define MsiSelectionManager_GetFeatureCost        2417
#define MsiSelectionManager_GetDescendentFeatureCost   2418
#define MsiSelectionManager_GetAncestryFeatureCost 2419
#define MsiSelectionManager_GetFeatureValidStates 2420

#define MsiDirectoryManager_Object             2500
#define MsiDirectoryManager_LoadDirectoryTable 2501
#define MsiDirectoryManager_DirectoryTable     2502
#define MsiDirectoryManager_FreeDirectoryTable 2503
#define MsiDirectoryManager_CreateTargetPaths  2504
#define MsiDirectoryManager_CreateSourcePaths  2505
#define MsiDirectoryManager_GetTargetPath      2506
#define MsiDirectoryManager_SetTargetPath      2507
#define MsiDirectoryManager_GetSourcePath      2508

#define MsiCostAdjuster_Object                 2600

#define MsiConfigurationManager_Object              2700
#define MsiConfigurationManager_RunScript           2704
#define MsiConfigurationManager_RegisterUser        2710
#define MsiConfigurationManager_ProductDatabasePath 2711
#define MsiConfigurationManager_RegisterRollbackScript   2714
#define MsiConfigurationManager_UnregisterRollbackScript 2715
#define MsiConfigurationManager_RollbackScripts          2716

#define MsiConfigurationManager_InstallFinalize              2718
#define MsiConfigurationManager_Services                     2719
#define MsiConfigurationManager_RegisterProduct              2720
#define MsiConfigurationManager_UnregisterProduct            2721 
#define MsiConfigurationManager_RegisterComponent            2722
#define MsiConfigurationManager_UnregisterComponent          2723
#define MsiConfigurationManager_RegisterFolder               2726
#define MsiConfigurationManager_UnregisterFolder             2727
#define MsiConfigurationManager_IsFolderRemovable            2728
#define MsiConfigurationManager_LockServer                   2729
#define MsiConfigurationManager_SetLastUsedSource            2731
#define MsiConfigurationManager_DoInstall                    2732
#define MsiConfigurationManager_UnlockServer                 2733

#define MsiServer_Object              2800

#define MsiMessage_Object            2900
#define MsiMessage_Message           2901

#define MsiExecute_Object            3000
#define MsiExecute_ExecuteRecord     3001
#define MsiExecute_RunScript         3003
#define MsiExecute_RemoveRollbackFiles 3004
#define MsiExecute_Rollback          3005
#define MsiExecute_RollbackFinalize  3006
#define MsiExecute_CreateScript      3007
#define MsiExecute_WriteScriptRecord 3008
#define MsiExecute_CloseScript       3009

#define MsiFilePatch_Object          3100
#define MsiFilePatch_ApplyPatch      3101
#define MsiFilePatch_ContinuePatch   3102
#define MsiFilePatch_CanPatchFile    3103
#define MsiFilePatch_CancelPatch     3104


#define Server_ScriptOpcodes       5000
// Operation_* defines added in build - based on opcodes.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\help\msispy.hh ===
/* HELP Context IDs for Msispy */
#define	HELPID_Msispy				1001
#define	HELPID_MsispyDatabase			1002
#define	HELPID_MsispyProfile			1003
#define	HELPID_MsispyRegistry			1004
#define HELPID_Msispy_CreateDatabase		1006
#define HELPID_Msispy_CreateProfile		1007
#define HELPID_Msispy_CreateRegistry		1008

#define HELPID_MsispyDatabase_Open			1101
#define HELPID_MsispyDatabase_Close			1102
#define HELPID_MsispyDatabase_GetProduct		1103
#define	HELPID_MsispyDatabase_GetFeatureFromProduct	1104
#define	HELPID_MsispyDatabase_GetComponent		1105
#define	HELPID_MsispyDatabase_GetComponentFromProduct	1106
#define	HELPID_MsispyDatabase_GetComponentFromFeature	1107
#define	HELPID_MsispyDatabase_GetComponentName		1108
#define	HELPID_MsispyDatabase_GetProductInfo		1109
#define	HELPID_MsispyDatabase_GetFeatureInfo		1110
#define	HELPID_MsispyDatabase_QueryProductState		1111
#define	HELPID_MsispyDatabase_QueryFeatureState		1112
#define	HELPID_MsispyDatabase_QueryComponentState	1113
#define	HELPID_MsispyDatabase_GetFeatureUsage		1114
#define	HELPID_MsispyDatabase_GetClientFromComponent	1115
#define	HELPID_MsispyDatabase_GetFileFromComponent	1116
#define	HELPID_MsispyDatabase_GetFileInfo		1117
#define	HELPID_MsispyDatabase_GetComponentLocation	1118
#define	HELPID_MsispyDatabase_GetComponentPath	1119

#define HELPID_MsispyProfile_Open			1201
#define HELPID_MsispyProfile_Close			1202
#define HELPID_MsispyProfile_GetProduct			1203
#define	HELPID_MsispyProfile_GetFeatureFromProduct	1204
#define	HELPID_MsispyProfile_GetComponent		1205
#define	HELPID_MsispyProfile_GetComponentFromProduct	1206
#define	HELPID_MsispyProfile_GetComponentFromFeature	1207
#define	HELPID_MsispyProfile_GetComponentName		1208
#define	HELPID_MsispyProfile_GetProductInfo		1209
#define	HELPID_MsispyProfile_GetFeatureInfo		1210
#define	HELPID_MsispyProfile_QueryProductState		1211
#define	HELPID_MsispyProfile_QueryFeatureState		1212
#define	HELPID_MsispyProfile_QueryComponentState	1213
#define	HELPID_MsispyProfile_GetFeatureUsage		1214
#define	HELPID_MsispyProfile_GetClientFromComponent	1215
#define	HELPID_MsispyProfile_GetFileFromComponent	1216
#define	HELPID_MsispyProfile_GetFileInfo		1217
#define	HELPID_MsispyProfile_GetComponentLocation	1218
#define	HELPID_MsispyProfile_GetComponentPath	1219

#define HELPID_MsispyRegistry_Open			1301
#define HELPID_MsispyRegistry_Close			1302
#define HELPID_MsispyRegistry_GetProduct		1303
#define	HELPID_MsispyRegistry_GetFeatureFromProduct	1304
#define	HELPID_MsispyRegistry_GetComponent		1305
#define	HELPID_MsispyRegistry_GetComponentFromProduct	1306
#define	HELPID_MsispyRegistry_GetComponentFromFeature	1307
#define	HELPID_MsispyRegistry_GetComponentName		1308
#define	HELPID_MsispyRegistry_GetProductInfo		1309
#define	HELPID_MsispyRegistry_GetFeatureInfo		1310
#define	HELPID_MsispyRegistry_QueryProductState		1311
#define	HELPID_MsispyRegistry_QueryFeatureState		1312
#define	HELPID_MsispyRegistry_QueryComponentState	1313
#define	HELPID_MsispyRegistry_GetFeatureUsage		1314
#define	HELPID_MsispyRegistry_GetClientFromComponent	1315
#define	HELPID_MsispyRegistry_GetFileFromComponent	1316
#define	HELPID_MsispyRegistry_GetFileInfo		1317
#define	HELPID_MsispyRegistry_GetComponentLocation	1318
#define	HELPID_MsispyRegistry_GetComponentPath	1319
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\idl\sources.inc ===
TARGETNAME=
!INCLUDE ..\..\MsiMake.inc

TARGETTYPE=NOTARGET
TARGETLIBS=

C_DEFINES=$(C_DEFINES) \
	-DREGISTER_PROXY_DLL \
	-DENTRY_PREFIX=Proxy \
	-DPROXY_CLSID_IS={0x000c103e,0x0000,0x0000,{0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}}

USE_NOLIBS=1
IDL_TYPE=OLE
PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
MIDL_UUIDDIR=$(O)

INCLUDES=$(INC_DIR);$(IDL_DIR)

SOURCES=..\icust.idl \
	..\messag.idl \
	..\remapi.idl \
	..\server.idl \
	$(O)\icust_p.c \
	$(O)\messag_p.c  \
        $(O)\remapi_p.c  \
        $(O)\server_p.c \
	$(O)\dlldata.c \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\combind.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       combind.h
//
//--------------------------------------------------------------------------

/* combind.h - delay load of system DLLs
   Note: this is just latebind.cpp in header form
____________________________________________________________________________*/

#include "common.h"
#define LATEBIND_FUNCREF
#include "latebind.h"
#define LATEBIND_VECTIMP
#include "latebind.h"
#define LATEBIND_FUNCIMP
#include "latebind.h"
#define LATEBIND_UNBINDIMP
#include "latebind.h"
#include "_diagnos.h"

#include <wow64t.h>

void UnbindLibraries()
{
    ODBCCP32::Unbind();
    MSPATCHA::Unbind();
    MPR::Unbind();
    if (OLE32::hInst)
    {
        OSVERSIONINFO osviVersion;
        osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        AssertNonZero(GetVersionEx(&osviVersion));
        if(osviVersion.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS) // bug 7773: CoFreeUnusedLibraries fails on vanila Win95
            OLE32::CoFreeUnusedLibraries();
    }
    OLEAUT32::Unbind();
    COMDLG32::Unbind();
    VERSION::Unbind();
    WININET::Unbind();

    FUSION::Unbind();
    // SXS::Unbind();
    MSCOREE::Unbind();

//  Bug # 9146.  URLMON hangs when unloading.
//  URLMON::Unbind();

    USERENV::Unbind();
    SHELL32::Unbind();
    //  SFC::Unbind() is called in MsiUIMessageContext::Terminate()
    //  COMCTL32::Unbind() is called in CBasicUI::Terminate()
}   // OLE32.dll cannot be released due the the RPC connections that can't be freed

//+--------------------------------------------------------------------------
//
//  Function:   MsiGetSystemDirectory
//
//  Synopsis:   returns the system directory.
//
//  Arguments:  [out] lpBuffer : the buffer that will have the path to the system directory
//              [in]  cchSize : the size of the buffer passed in
//              [in] bAlwaysReturnWOW64Dir : if true, it means that we always want the WOW64 directory
//                                           otherwise, we want the system directory based on the bitness
//                                           of the binary that called this function.
//
//  Returns:    The length of the path if successful.
//              The length of the buffer required to hold the path if the buffer is too small
//              Zero if unsuccessful.
//
//  History:    4/20/2000  RahulTh  created
//
//  Notes:      This function is bit aware. It returns the WOW64 folder
//              for 32-bit apps. running on a 64-bit machine.
//
//              In case of an error, the error value is set using SetLastError()
//
//              Ideally, the value of cchSize should at least be MAX_PATH in order
//              to allow sufficient room in the buffer for the path.
//
//---------------------------------------------------------------------------
UINT MsiGetSystemDirectory (
         OUT LPTSTR lpBuffer,
         IN  UINT   cchSize,
         IN  BOOL   bAlwaysReturnWOW64Dir
        )
{
	typedef 		UINT (APIENTRY *PFNGETWOW64DIR)(LPTSTR, UINT);
    DWORD   		Status = ERROR_SUCCESS;
    BOOL    		bGetWOW64 = FALSE;
    UINT    		uLen;
    HMODULE 		hKernel = NULL;
    PFNGETWOW64DIR	pfnGetSysWow64Dir = NULL;
	
	bGetWOW64 = bAlwaysReturnWOW64Dir;

#ifndef _WIN64
    // For 32-bit apps. we need to get the WOW64 dir. only if we are on a 64-bit 
	// platform Otherwise we should return the system32 directory.
    if (g_fWinNT64)
        bGetWOW64 = TRUE;
    else
        bGetWOW64 = FALSE;
#endif  //_WIN64

    if (! bGetWOW64)
        return WIN::GetSystemDirectory (lpBuffer, cchSize);
	
    //
    // If we are here, then we are a 32-bit binary running on a 64-bit machine
    // because that is the only way bGetWOW64 can be true. So we now need to
    // find the location of the WOW64 system directory.
    //
    // For this code to run correctly on NT4.0 and Win9x, we cannot directly
    // call the API GetSystemWow64DirectoryW() since it is only available on
    // Whistler and later versions of Windows. Therefore, we need to explicitly
    // do a GetProcAddress() on the function to prevent it from being an imported
    // function, otherwise we won't be able to load msi.dll on the downlevel clients.
    //
    // It is very IMPORTANT to not use the latebinding mechanism below
    // because that can cause deadlock situations because the late binding
    // mechanism itself relies on this function to obtain the correct path to
    // the system directory.
    //
    // So it is important to always call the APIs directly here.
    // Note: WIN is defined to nothing.

    hKernel = WIN::LoadLibrary (TEXT("kernel32.dll"));
    if (!hKernel)
        return 0;

    pfnGetSysWow64Dir = (PFNGETWOW64DIR) WIN::GetProcAddress (hKernel, "GetSystemWow64DirectoryW");
    if (!pfnGetSysWow64Dir)
    {
        Status = GetLastError();
        uLen = 0;
        goto MsiGetSysDir_Cleanup;
    }

    uLen = (*pfnGetSysWow64Dir)(lpBuffer, cchSize);
    if (0 == uLen || uLen > cchSize)
    {
        if (0 == uLen)
            Status = GetLastError();
        goto MsiGetSysDir_Cleanup;
    }
    
	Status = ERROR_SUCCESS;
	
MsiGetSysDir_Cleanup:
    if (hKernel)
        FreeLibrary(hKernel);
    SetLastError(Status);
	
    return uLen;
}


bool MakeFullSystemPath(const ICHAR* szFile, ICHAR* szFullPath, size_t cchFullPath)
{
    // MakeFullSystemPath expects a bare file name, no path or extension
    
    // make sure this isn't a full path -- stolen liberally from PathType()
    if ( szFile && *szFile && IStrLen(szFile) >= 2 &&
         ((szFile[0] < 0x7f && szFile[1] == ':') || (szFile[0] == '\\' && szFile[1] == '\\')) )
    {
        Assert(0);
        return false;
    }

    UINT cchLength;
    if (0 == (cchLength = MsiGetSystemDirectory(szFullPath, cchFullPath, FALSE)))
        return false;
    if ( cchLength+2 > cchFullPath )
    {
        Assert(0);
        return false;
    }

    // we never expect the system directory to be
    // way down deep, so we won't mess with the performance hit of
    // CTempBuffers and resizing.

    *(szFullPath+cchLength++) = chDirSep;
    *(szFullPath+cchLength) = 0;
    
    // append the file name to the path
    RETURN_THAT_IF_FAILED(StringCchCat(szFullPath, cchFullPath, szFile), false);

    // concatenate .DLL to the string, starting
    // from the last calculated end.
    return FAILED(StringCchCat(szFullPath, cchFullPath, TEXT(".DLL"))) ? false : true;
}

HINSTANCE LoadSystemLibrary(const ICHAR* szFile)
{
    // explicitly load optional system components from the system folder on NT
    // prevent the search order from dropping out into user space.
    ICHAR szFullPath[MAX_PATH+1];

    static int iWin9X = -1;

    if (-1 == iWin9X)
    {
        OSVERSIONINFO osviVersion;
        osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        AssertNonZero(GetVersionEx(&osviVersion)); // fails only if size set wrong

        if (osviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
            iWin9X = 1;

        else
            iWin9X = 0;
    }
    
    if (iWin9X)
    {
        return WIN::LoadLibrary(szFile);
    }
    else if (MakeFullSystemPath(szFile, szFullPath, ARRAY_ELEMENTS(szFullPath)))
    {
        return WIN::LoadLibrary(szFullPath);
    }
    else
        return NULL;
}

#if defined(_MSI_DLL)
// subfolder below system32 from where to load core fusion files during bootstrapping
const ICHAR szURTBootstrapSubfolder[] = TEXT("URTTemp");
#endif

HINSTANCE MSCOREE::LoadSystemLibrary(const ICHAR* szFile, bool& rfRetryNextTimeIfWeFailThisTime)
{
	rfRetryNextTimeIfWeFailThisTime = true; // we always try reloading to allow for mscoree to appear in the midst of installation during bootstrapping
	bool fRet = false; // init to failure
	HINSTANCE hLibShim = 0;
	// check to see if mscoree.dll is already loaded
	HMODULE hModule = WIN::GetModuleHandle(szFile);
#if defined(_MSI_DLL)
	if(urtSystem == g_urtLoadFromURTTemp || (hModule && (urtPreferURTTemp == g_urtLoadFromURTTemp)))
	{
#endif
		if(hModule) // already loaded
		{
#if defined(_MSI_DLL)
			DEBUGMSG(TEXT("MSCOREE already loaded, using loaded copy"));
#endif
			hLibShim = WIN::LoadLibrary(szFile);
		}
		else
		{
#if defined(_MSI_DLL)
			DEBUGMSG(TEXT("MSCOREE not loaded loading copy from system32"));
#endif
			hLibShim = ::LoadSystemLibrary(szFile); // not bootstrapping, use system folder
		}
#if defined(_MSI_DLL)
	}
	else if(!hModule) // not already loaded
	{
		// try alternate path - we are bootstrapping
		DEBUGMSG(TEXT("MSCOREE not loaded loading copy from URTTemp"));
		ICHAR szTemp[MAX_PATH+1];
		HRESULT hRes = StringCchPrintf(szTemp, ARRAY_ELEMENTS(szTemp), TEXT("%s\\%s"),
												 szURTBootstrapSubfolder, szFile);
		if ( FAILED(hRes) )
			DEBUGMSG1(TEXT("ERROR: StringCchPrintf failure %#x in MSCOREE::LoadSystemLibrary"),
						 reinterpret_cast<ICHAR*>(static_cast<INT_PTR>(hRes)));
		else
		{
			ICHAR szMscoreePath[MAX_PATH+1];
			if(MakeFullSystemPath(szTemp, szMscoreePath, ARRAY_ELEMENTS(szMscoreePath)))
				hLibShim = WIN::LoadLibraryEx(szMscoreePath,0, LOAD_WITH_ALTERED_SEARCH_PATH); // necessary to find msvcr70.dll lying besides mscoree.dll
		}
	}
	else 
	{
		DEBUGMSG(TEXT("ERROR:MSCOREE already loaded, need to bootstrap from newer copy in URTTemp, you will need to stop the Windows Installer service before retrying;failing..."));
		// return 0;
	}
#endif
	return hLibShim;
}

bool MakeFusionPath(const ICHAR* szFile, ICHAR* szFullPath, size_t cchFullPath)
{
	bool fRet = false; // init to failure
	WCHAR wszFusionPath[MAX_PATH+1];
	DWORD cchPath = ARRAY_ELEMENTS(wszFusionPath);
	if(SUCCEEDED(MSCOREE::GetCORSystemDirectory(wszFusionPath, cchPath, &cchPath)))
	{
		if (SUCCEEDED(StringCchCopy(szFullPath, cchFullPath, wszFusionPath)) &&
			SUCCEEDED(StringCchCat(szFullPath, cchFullPath, szFile)) )
			fRet = true; // success
	}
	return fRet;
}

// the fusion dll is loaded indirectly via the mscoree.dll
HINSTANCE FUSION::LoadSystemLibrary(const ICHAR*, bool& rfRetryNextTimeIfWeFailThisTime) // we always use the unicode name, since that's what the underlying apis use
{
	rfRetryNextTimeIfWeFailThisTime = true; // we always try reloading to allow for fusion to appear in the midst of installation during bootstrapping
	HINSTANCE hLibFusion = 0; // initialize to failure
	ICHAR szFusionPath[MAX_PATH+1];
	if(MakeFusionPath(TEXT("fusion.dll"), szFusionPath, ARRAY_ELEMENTS(szFusionPath)))
		hLibFusion = WIN::LoadLibraryEx(szFusionPath, 0, LOAD_WITH_ALTERED_SEARCH_PATH); // necessary to find msvcr70.dll lying besides fusion.dll
	return hLibFusion;
}

HINSTANCE WINHTTP::LoadSystemLibrary(const ICHAR*, bool& rfRetryNextTimeIfWeFailThisTime)
{
	rfRetryNextTimeIfWeFailThisTime = false; // we dont retry next time if we cannot load WINHTTP this time around

	// winhttp is SxS, so just let fusion figure it out

	// FUTURE: if we port using WinHttp to downlevel platforms, then we'll need to consider
	//         using the LoadSystemLibrary function
	return WIN::LoadLibrary(TEXT("WINHTTP"));
}

HINSTANCE COMCTL32::LoadSystemLibrary(const ICHAR*, bool& rfRetryNextTimeIfWeFailThisTime)
{
	rfRetryNextTimeIfWeFailThisTime = false; // we dont retry next time if we cannot load COMCTL32 this time around
	OSVERSIONINFO osviVersion;
	memset(&osviVersion, 0, sizeof(osviVersion));
	osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	AssertNonZero(GetVersionEx(&osviVersion)); // fails only if size set wrong

	if ( (osviVersion.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
		  ((osviVersion.dwMajorVersion > 5) ||
		  ((osviVersion.dwMajorVersion == 5) && (osviVersion.dwMinorVersion >=1))) )
		// let fusion figure out which COMCTL32.DLL to load, i.e. we don't have to
		// specify the path to the system32 directory.
		return WIN::LoadLibrary(TEXT("COMCTL32"));
	else
		return ::LoadSystemLibrary(TEXT("COMCTL32"));
}

#ifndef UNICODE
//____________________________________________________________________________
//
// Explicit loader for OLE32.DLL on Win9X, to fix version with bad stream name handling
//____________________________________________________________________________

// code offsets to patched code in all released versions of OLE32.DLL with the upper case bug
const int iPatch1120 = 0x4099F;  // beta release, shipped with IE 4.01
const int iPatch1718 = 0x4A506;  // shipped with US builds of Win98 and IE4.01SP1
const int iPatch1719 = 0x3FD82;  // shipped with Visual Studio 6.0 and some Win98
const int iPatch2512 = 0x39D5B;  // beta build
const int iPatch2612 = 0x39DB7;  // intl builds of Win98 and IE4.01SP1
const int iPatch2618 = 0x39F0F;  // web release of Win98

const int cbPatch = 53; // length of patch sequence
const int cbVect1 = 22; // offset to __imp__WideCharToMultiByte@32
const int cbVect2 = 38; // offset to __imp__CharUpperA@4

char asmRead[cbPatch];  // buffer to read DLL code for detection of bad code sequence
char asmOrig[cbPatch] = {  // bad code sequence, used for verification of original code sequence
'\x53','\x8D','\x45','\xF4','\x53','\x8D','\x4D','\xFC','\x6A','\x08','\x50','\x6A','\x01','\x51','\x68','\x00','\x02','\x00','\x00','\x53','\xFF','\x15',
'\x18','\x14','\x00','\x00', //__imp__WideCharToMultiByte@32  '\x65F01418
'\x88','\x5C','\x05','\xF4','\x8B','\xF0','\x8D','\x4D','\xF4','\x51','\xFF','\x15',
'\x40','\x11','\x00','\x00', //__imp__CharUpperA@4  '\x65F01140
'\x6A','\x01','\x8D','\x45','\xFC','\x50','\x8D','\x4D','\xF4','\x56','\x51'
};

const int cbVect1P = 25; // offset to __imp__WideCharToMultiByte@32
const int cbVect2P = 49; // offset to __imp__CharUpperA@4

char asmRepl[cbPatch] = {  // replacement code sequence that fixes stream name bug in memory
// replaced code
'\x8D','\x45','\x08','\x50','\x8D','\x75','\xF4','\x53','\x8D','\x4D','\xFC',
'\x6A','\x08','\x56','\x6A','\x01','\x51','\x68','\x00','\x02','\x00','\x00','\x53','\xFF','\x15',
'\x18','\x14','\x00','\x00', //__imp__WideCharToMultiByte@32  '\x65F01418
'\x39','\x5D','\x08','\x75','\x1C','\x88','\x5C','\x28','\xF4','\x6A','\x01',
'\x8D','\x4D','\xFC','\x51','\x50','\x56','\x56','\xFF','\x15',
'\x40','\x11','\x00','\x00', //__imp__CharUpperA@4  '\x65F01140
};

static bool PatchCode(HINSTANCE hLib, int iOffset)
{
    HANDLE hProcess = GetCurrentProcess();
    char* pLoad = (char*)(int)(hLib);
    char* pBase = pLoad + iOffset;
    DWORD cRead;
    BOOL fReadMem = ReadProcessMemory(hProcess, pBase, asmRead, sizeof(asmRead), &cRead);
    if (!fReadMem)
	{
		AssertSz(0, TEXT("MSI: ReadProcessMemory failed on OLE32.DLL"));
		return false;
	}
    *(int*)(asmOrig + cbVect1)  = *(int*)(asmRead + cbVect1);
    *(int*)(asmOrig + cbVect2)  = *(int*)(asmRead + cbVect2);
    *(int*)(asmRepl + cbVect1P) = *(int*)(asmRead + cbVect1);
    *(int*)(asmRepl + cbVect2P) = *(int*)(asmRead + cbVect2);
    if (memcmp(asmRead, asmOrig, sizeof(asmOrig)) != 0)
        return false;
    DWORD cWrite;
    BOOL fWriteMem = WriteProcessMemory(hProcess, pBase, asmRepl, sizeof(asmRepl), &cWrite);
    if (!fWriteMem)
	{
		AssertSz(0, TEXT("MSI: WriteProcessMemory failed on OLE32.DLL"));
		return false;
	}
    return true;
}

HINSTANCE OLE32::LoadSystemLibrary(const ICHAR* szPath, bool& rfRetryNextTimeIfWeFailThisTime)
{
	rfRetryNextTimeIfWeFailThisTime = false; // we dont retry next time if we cannot load OLE32 this time around
    HINSTANCE hLib = ::LoadSystemLibrary(szPath);
    if (hLib && (PatchCode(hLib, iPatch2612)
              || PatchCode(hLib, iPatch1718)
              || PatchCode(hLib, iPatch1719)
              || PatchCode(hLib, iPatch2618)
              || PatchCode(hLib, iPatch2512)
              || PatchCode(hLib, iPatch1120)))
    {
        // DEBUGMSGV(L"MSI: Detected OLE32.DLL bad code sequence, successfully corrected");
	}	
	return hLib;
}

#endif

#if 0   // source code demonstrating fix to OLE32.DLL Version 4.71, Win 9x only
// original source code
    Length = WideCharToMultiByte (CP_ACP, WC_COMPOSITECHECK, wBuffer, 1, Buffer, sizeof (Buffer), NULL, NULL);
// patched source code
    Length = WideCharToMultiByte (CP_ACP, WC_COMPOSITECHECK, wBuffer, 1, Buffer, sizeof (Buffer), NULL, &fUsedDefault);
    if (fUsedDefault) goto return_char;
// unchanged code
    Buffer[Length] = '\0';
    CharUpperA (Buffer);
    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, Buffer, Length, wBuffer, 1);
return_char:
    return wBuffer[0];

// original compiled code                              patched code
    push ebx                                            lea  eax, [ebp+8]
    lea  eax, [ebp-12]                                  push eax
    push ebx                                            lea  esi, [ebp-12]
    lea  ecx, [ebp-4]                                   push ebx
    push 8                                              lea  ecx, [ebp-4]
    push eax                                            push 8
    push 1                                              push esi
    push ecx                                            push 1
    push 200h                                           push ecx
    push ebx                                            push 200h
    call dword ptr ds:[__imp__WideCharToMultiByte@32]   push ebx
    mov  byte ptr [ebp+eax-12], bl                      call dword ptr ds:[__imp__WideCharToMultiByte@32]
    mov  esi,eax                                        cmp  [ebp+8], ebx
    lea  ecx, [ebp-12]                                  jnz  towupper_retn
    push ecx                                            mov  byte ptr [ebp+eax-12], bl
    call dword ptr ds:[__imp__CharUpperA@4]             push 1
    push 1                                              lea  ecx, [ebp-4]
    lea  eax, [ebp-4]                                   push ecx
    push eax                                            push eax
    lea  ecx, [ebp-12]                                  push esi
    push esi                                            push esi
    push ecx                                            call dword ptr ds:[__imp__CharUpperA@4]
#endif

//____________________________________________________________________________

const int kiAllocSize = 20;
const int kNext       = 0;
const int kPrev       = 1;
const int kFirst      = 2;
const int kLast       = kiAllocSize - 1;

static HANDLE g_rgSysHandles[kiAllocSize];
static int g_iHandleIndex = kFirst;
static HANDLE* g_pCurrHandleBlock = 0;

#ifdef DEBUG
int g_cOpenHandles = 0;
int g_cMostOpen = 0;
#endif

void MsiRegisterSysHandle(HANDLE handle)
{
    if (handle == 0 || handle == INVALID_HANDLE_VALUE)
    {
        Assert(0);
        return;
    }

    if (g_pCurrHandleBlock == 0)
    {
        g_pCurrHandleBlock = g_rgSysHandles;
        g_pCurrHandleBlock[kNext] = 0;
        g_pCurrHandleBlock[kPrev] = 0;
    }

    if (g_iHandleIndex > kLast)
    {
        HANDLE* pPrevHandleBlock = g_pCurrHandleBlock;
        g_pCurrHandleBlock[kNext] = new HANDLE[kiAllocSize];
		if ( ! g_pCurrHandleBlock[kNext] )
			return;
        g_pCurrHandleBlock = (HANDLE*) g_pCurrHandleBlock[kNext];
        g_pCurrHandleBlock[kNext] = 0;
        g_pCurrHandleBlock[kPrev] = pPrevHandleBlock;
        g_iHandleIndex = kFirst;
    }

    g_pCurrHandleBlock[g_iHandleIndex++] = handle;

#ifdef DEBUG
    g_cOpenHandles++;
    if (g_cOpenHandles > g_cMostOpen)
        g_cMostOpen = g_cOpenHandles;
#endif
}

Bool MsiCloseSysHandle(HANDLE handle)
{
    if (handle == INVALID_HANDLE_VALUE)
    {
        Assert(0);
        return fTrue;
    }

    int iSeekIndex = g_iHandleIndex - 1;
    if (g_pCurrHandleBlock == 0 || iSeekIndex < kFirst)
    {
        AssertSz(0, TEXT("Attempting to close unregistered handle!"));
        return fFalse;
    }
    
    HANDLE* pHandleBlock = g_pCurrHandleBlock;
    while (pHandleBlock[iSeekIndex] != handle)
    {
        iSeekIndex--;
        if (iSeekIndex < kFirst)
        {
            pHandleBlock = (HANDLE*) pHandleBlock[kPrev];
            if (pHandleBlock == 0)
            {
                AssertSz(0, TEXT("Attempting to close unregistered handle!"));
                return fFalse;
            }
            iSeekIndex = kLast;
        }
    }

#ifdef DEBUG
    g_cOpenHandles--;
#endif

    Bool fResult = fTrue;
    if (handle != NULL)
        fResult = ToBool(WIN::CloseHandle(handle));
    pHandleBlock[iSeekIndex] = NULL;
    iSeekIndex = g_iHandleIndex - 1;
    while (g_pCurrHandleBlock[iSeekIndex] == NULL)
    {
        iSeekIndex--;
        g_iHandleIndex--;
        if (iSeekIndex < kFirst)
        {
            if (g_pCurrHandleBlock == g_rgSysHandles)
            {
                return fResult;
            }
            else
            {
                HANDLE* pOldHandleBlock = g_pCurrHandleBlock;
                g_pCurrHandleBlock = (HANDLE*) g_pCurrHandleBlock[kPrev];
                g_iHandleIndex = kLast + 1;
                iSeekIndex = kLast;
                delete pOldHandleBlock;
            }
        }
    }
    return fResult;
}

Bool MsiCloseAllSysHandles()
{
    while (g_iHandleIndex > kFirst)
    {
        MsiCloseSysHandle(g_pCurrHandleBlock[g_iHandleIndex - 1]);
    }
    return fTrue;
}

Bool MsiCloseUnregisteredSysHandle(HANDLE handle)
{
    Assert(handle != 0 && handle != INVALID_HANDLE_VALUE);
    return ToBool(WIN::CloseHandle(handle));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\autoapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       autoapi.h
//
//--------------------------------------------------------------------------

/* AutoApi.h - defines for MSI API automation layer */

/* Help context IDs */
#include "msi.hh"

/* OLE automation dispatch IDs */

#define DISPID_MsiInstall_CreateRecord       1
#define DISPID_MsiInstall_OpenPackage        2
#define DISPID_MsiInstall_OpenProduct        3
#define DISPID_MsiInstall_OpenDatabase       4
#define DISPID_MsiInstall_SummaryInformation 5
#define DISPID_MsiInstall_UILevel            6
#define DISPID_MsiInstall_EnableLog          7
#define DISPID_MsiInstall_InstallProduct     8
#define DISPID_MsiInstall_Version            9
#define DISPID_MsiInstall_LastErrorRecord   10
#define DISPID_MsiInstall_RegistryValue     11
#define DISPID_MsiInstall_Environment       12
#define DISPID_MsiInstall_FileAttributes    13
#define DISPID_MsiInstall_ExternalUI        14
#define DISPID_MsiInstall_FileSize          15
#define DISPID_MsiInstall_FileVersion       16
#define DISPID_MsiInstall_ProductState      17
#define DISPID_MsiInstall_ProductInfo       18
#define DISPID_MsiInstall_ConfigureProduct  19
#define DISPID_MsiInstall_ReinstallProduct  20
#define DISPID_MsiInstall_CollectUserInfo   21
#define DISPID_MsiInstall_ApplyPatch        22
#define DISPID_MsiInstall_FeatureParent     23
#define DISPID_MsiInstall_FeatureState      24
#define DISPID_MsiInstall_UseFeature        25
#define DISPID_MsiInstall_FeatureUsageCount 26
#define DISPID_MsiInstall_FeatureUsageDate  27
#define DISPID_MsiInstall_ConfigureFeature  28
#define DISPID_MsiInstall_ReinstallFeature  29
#define DISPID_MsiInstall_ProvideComponent  30
#define DISPID_MsiInstall_ComponentPath     31
#define DISPID_MsiInstall_ProvideQualifiedComponent 32
#define DISPID_MsiInstall_QualifierDescription 33
#define DISPID_MsiInstall_ComponentQualifiers 34
#define DISPID_MsiInstall_Products          35
#define DISPID_MsiInstall_Features          36
#define DISPID_MsiInstall_Components        37
#define DISPID_MsiInstall_ComponentClients  38
#define DISPID_MsiInstall_Patches           39
#define DISPID_MsiInstall_RelatedProducts   40
#define DISPID_MsiInstall_PatchInfo         41
#define DISPID_MsiInstall_PatchTransforms   42
#define DISPID_MsiInstall_AddSource         43
#define DISPID_MsiInstall_ClearSourceList   44
#define DISPID_MsiInstall_ForceSourceListResolution 45
#define DISPID_MsiInstall_GetShortcutTarget 46
#define DISPID_MsiInstall_FileHash          47
#define DISPID_MsiInstall_FileSignatureInfo 48

#define DISPID_MsiRecord_FieldCount   0
#define DISPID_MsiRecord_StringData   1
#define DISPID_MsiRecord_IntegerData  2
#define DISPID_MsiRecord_SetStream    3
#define DISPID_MsiRecord_ReadStream   4
#define DISPID_MsiRecord_DataSize     5
#define DISPID_MsiRecord_IsNull       6
#define DISPID_MsiRecord_ClearData    7
#define DISPID_MsiRecord_FormatText   8
#define DISPID_MsiRecord_GetHandle	  9999

#define DISPID_MsiDatabase_DatabaseState      1
#define DISPID_MsiDatabase_SummaryInformation 2
#define DISPID_MsiDatabase_OpenView           3
#define DISPID_MsiDatabase_Commit             4
#define DISPID_MsiDatabase_PrimaryKeys        5
#define DISPID_MsiDatabase_Import             6
#define DISPID_MsiDatabase_Export             7
#define DISPID_MsiDatabase_Merge              8
#define DISPID_MsiDatabase_GenerateTransform  9
#define DISPID_MsiDatabase_ApplyTransform    10
#define DISPID_MsiDatabase_EnableUIPreview   11
#define DISPID_MsiDatabase_TablePersistent   12
#define DISPID_MsiDatabase_CreateTransformSummaryInfo 13
#define DISPID_MsiDatabase_GetHandle 9999

#define DISPID_MsiView_Execute    1
#define DISPID_MsiView_Fetch      2
#define DISPID_MsiView_Modify     3
#define DISPID_MsiView_Close      4
#define DISPID_MsiView_ColumnInfo 5
#define DISPID_MsiView_GetError   6

#define DISPID_MsiSummaryInfo_Property        1
#define DISPID_MsiSummaryInfo_PropertyCount   2
#define DISPID_MsiSummaryInfo_Persist         3

#define DISPID_MsiEngine_Application            1 
#define DISPID_MsiEngine_Property               2
#define DISPID_MsiEngine_Language               3
#define DISPID_MsiEngine_Mode                   4
#define DISPID_MsiEngine_Database               5
#define DISPID_MsiEngine_SourcePath             6
#define DISPID_MsiEngine_TargetPath             7
#define DISPID_MsiEngine_DoAction               8
#define DISPID_MsiEngine_Sequence               9
#define DISPID_MsiEngine_EvaluateCondition     10
#define DISPID_MsiEngine_FormatRecord          11
#define DISPID_MsiEngine_Message               12
#define DISPID_MsiEngine_FeatureCurrentState   13
#define DISPID_MsiEngine_FeatureRequestState   14
#define DISPID_MsiEngine_FeatureValidStates    15
#define DISPID_MsiEngine_FeatureCost           16
#define DISPID_MsiEngine_ComponentCurrentState 17
#define DISPID_MsiEngine_ComponentRequestState 18
#define DISPID_MsiEngine_SetInstallLevel       19
#define DISPID_MsiEngine_VerifyDiskSpace       20
#define DISPID_MsiEngine_ProductProperty       21
#define DISPID_MsiEngine_FeatureInfo           22
#define DISPID_MsiEngine_ComponentCosts        23

#define DISPID_MsiUIPreview_Property       1
#define DISPID_MsiUIPreview_ViewDialog     2
#define DISPID_MsiUIPreview_ViewBillboard  3

#define DISPID_MsiFeatureInfo_Title        1
#define DISPID_MsiFeatureInfo_Description  2
#define DISPID_MsiFeatureInfo_Attributes   3

#define DISPID_NEWENUM                  ( -4 )
#define DISPID_VALUE                     ( 0 )
#define DISPID_MsiCollection_Count         1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\clibs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       clibs.h
//
//--------------------------------------------------------------------------


#include <limits.h>

int FIsdigit(int c)
{

	return c >= '0' && c <= '9';


}

//
// Stolen from CLibs
//
TCHAR *PchOurXtoa (
        unsigned long val,
        TCHAR *buf,
        bool fIs_neg
        )
{
        TCHAR *p;                /* pointer to traverse string */
        TCHAR *firstdig;         /* pointer to first digit */
        TCHAR temp;              /* temp char */
        unsigned digval;        /* value of digit */
		TCHAR *pchEnd;
		
        p = buf;

        if (fIs_neg) {
            /* negative, so output '-' and negate */
            *p++ = '-';
            val = (unsigned long)(-(long)val);
        }

        firstdig = p;           /* save pointer to first digit */

        do {
            digval = (unsigned) (val % 10);
            val /= 10;       /* get next digit */

            *p++ = (char) (digval + '0');       /* a digit */
        } while (val > 0);

        /* We now have the digit of the number in the buffer, but in reverse
           order.  Thus we reverse them now. */

		pchEnd = p;
        *p-- = '\0';            /* terminate string; p points to last digit */
		
        do {
            temp = *p;
            *p = *firstdig;
            *firstdig = temp;   /* swap *p and *firstdig */
            --p;
            ++firstdig;         /* advance to next two digits */
        } while (firstdig < p); /* repeat until halfway */
        
        return pchEnd;
}


//
// davidmck
// written to reduce use of StringCchPrintf
//
int ltostr(TCHAR *pch, INT_PTR i)
{
	TCHAR *pchStart = pch;
	bool fNegative = false;
	
	if (i < 0)
		{
		fNegative = true;
		}
	else if (i == 0)
	{
		*pch++ = TEXT('0');
		*pch = 0;
		return 1;
	}

	Assert((pch - pchStart) <= INT_MAX);		//--merced: 64-bit ptr subtraction may lead to values too big to fit into an int.
	pch = PchOurXtoa((unsigned long)i, pch, fNegative);
	return (int)(INT_PTR)(pch - pchStart);		
}


//
// Stolen and simplified from an office routine of the same name
//
long __cdecl strtol(const char *pch)
{
	// Parses string to long
	unsigned long   ulNum = 0;
	int             iNeg = 0;
	int             iDigit = 0;

const int iBase = 10;

	if (*pch == '-')
		{
		pch++;
		iNeg = 1;
		}

	while (FIsdigit(*pch))
		{
		iDigit = *pch - '0';

		// FIX for RAID #969 - not correctly handling overflow
		// If we are going to add a digit, before doing so make sure
		// that the current number is no greater than the max it could
		// be.  We add one in because integer divide truncates, and
		// we might be right around LONG_MAX.

		if (ulNum > (unsigned)((LONG_MAX / iBase) + 1))
			{
			return iNeg ? LONG_MIN : LONG_MAX;
			}

		ulNum = ulNum * iBase + (unsigned int)iDigit;

		// FIX cont'd:  Now, since ulNum can be no bigger
		// than (Long_MAX / iBase) + 1, then this multiplication
		// can result in something no bigger than Long_MAX + iBase,
		// and ulNum is limited by Long_MAX + iBase + iDigit.  This
		// will set the high bit of this LONG in the worst case, and
		// since iBase + iDigit is much less than LONG_MAX, will not
		// overflow us undetectably.
		
		if (ulNum > (ULONG)LONG_MAX)
			{
			return iNeg ? LONG_MIN : LONG_MAX;
			}

		pch++;
		}

	Assert(ulNum <= LONG_MAX);
	return iNeg ? - ((long)ulNum) : (long)ulNum;    
}


/***
* _mbsstr - Search for one MBCS string inside another
* Stolen from the CRuntimes and modified by Davidmck 12/97
*
*Purpose:
*       Find the first occurrence of str2 in str1.
*
*Entry:
*       unsigned char *str1 = beginning of string
*       unsigned char *str2 = string to search for
*
*Exit:
*       Returns a pointer to the first occurrence of str2 in
*       str1, or NULL if str2 does not occur in str1
*
*Exceptions:
*
*******************************************************************************/

unsigned char * __cdecl PchMbsStr(
    const unsigned char *str1,
    const unsigned char *str2
    )
{
        unsigned char *cp, *s1, *s2;

        cp = (unsigned char *) str1;

        // We could add this optimization, but we almost always are doing just
        // a single character or two
        // endp = (unsigned PCHAR) (str1 + (_BYTELEN(str1) - _BYTELEN(str2)));

        while (*cp)
        {
                s1 = cp;
                s2 = (unsigned char *) str2;

                /*
                 * MBCS: ok to ++ since doing equality comparison.
                 * [This depends on MBCS strings being "legal".]
                 */

                while ( *s1 && *s2 && (*s1 == *s2) )
                        s1++, s2++;

                if (!(*s2))
                        return(cp);     /* success! */

                /*
                 * bump pointer to next char
                 */

                cp = (unsigned char *)CharNextA((char *)cp);

        }

        return(NULL);

}

//  stolen from ISTRING.CPP

int GetIntegerValue(const ICHAR *sz, Bool* pfValid)
{
	Bool fValid;
	if (!pfValid)
		pfValid = &fValid;
	*pfValid = fTrue;

	int i, ch;
	Bool fSign = fFalse;
	for (;;)
	{
		i = ch = (*sz++ - '0');
		if (i != ('-' - '0') || fSign)
			break;
		fSign = fTrue;
	}
	if ((unsigned int)ch > 9)
	{
		WIN::SetLastError(ERROR_INVALID_DATA);
		*pfValid = fFalse;
		return iMsiStringBadInteger;
	}
	while ((ch = *sz++) != 0)
	{
		ch -= '0';
		if ((unsigned int)ch > 9)
		{
			WIN::SetLastError(ERROR_INVALID_DATA);
			*pfValid = fFalse;
			return iMsiStringBadInteger;
		}
		i = i * 10 + ch;
	} 

	WIN::SetLastError(ERROR_SUCCESS);
	return fSign ? -i : i;
}

#ifdef _WIN64
// modification of routine from above
INT_PTR GetInt64Value(const ICHAR *sz, Bool* pfValid)
{
	Bool fValid;
	if (!pfValid)
		pfValid = &fValid;
	*pfValid = fTrue;

	INT_PTR i;
	int ch;
	Bool fSign = fFalse;
	for (;;)
	{
		i = ch = (*sz++ - '0');
		if (i != ('-' - '0') || fSign)
			break;
		fSign = fTrue;
	}
	if ((unsigned int)ch > 9)
	{
		WIN::SetLastError(ERROR_INVALID_DATA);
		*pfValid = fFalse;
		return (INT_PTR)iMsiStringBadInteger;
	}
	while ((ch = *sz++) != 0)
	{
		ch -= '0';
		if ((unsigned int)ch > 9)
		{
			WIN::SetLastError(ERROR_INVALID_DATA);
			*pfValid = fFalse;
			return (INT_PTR)iMsiStringBadInteger;
		}
		i = i * 10 + ch;
	} 

	WIN::SetLastError(ERROR_SUCCESS);
	return fSign ? -i : i;
}
#endif // _WIN64

#ifdef cchHexIntPtrMax
//
// converts the value into a hex string
// this expects the buffer passed in to be at least cchHexIntPtrMax long
// we will use this to construct the string in place and then return
// a pointer to the start
const TCHAR* g_rgchHexDigits = TEXT("0123456789ABCDEF");

TCHAR* PchPtrToHexStr(TCHAR *pch, UINT_PTR val, bool fAllowNull)
{
    TCHAR *p;                /* pointer to traverse string */

	// Jump to the end and start going backwards
    p = pch + cchHexIntPtrMax - 1;
    *p-- = '\0';

    if (val == 0 && fAllowNull)
    	return p + 1;
    	
    unsigned digval;        /* value of digit */
	
    do {
        digval = (unsigned) (val & 0xF);
        val >>= 4;       /* get next digit */

        *p-- = g_rgchHexDigits[digval];       /* a digit */
    } while (val > 0);

    /* We now have the digit of the number in the buffer, but in reverse
       order.  Thus we reverse them now. */

    return p + 1;
}
#endif

//
// Currently used only by the Handle pool in the handler
// Assumes the string is a valid hex string
UINT_PTR GetIntValueFromHexSz(const ICHAR *sz)
{
	INT_PTR i = 0;
	int ch;
	while ((ch = *sz++) != 0)
	{
		ch -= '0';
		Assert(((unsigned int)ch <= 9) || (ch >= ('A' - '0') && ch <= ('F' - '0')));
		if (ch > 9)
			ch += 10 - ('A' - '0');
		i = (i << 4) + ch;
	} 

	return i;
}

int FIsspace(char c)  //  Note: you can use this instead of isspace() but shouldnt use it
							 //  instead of iswspace()!
{
	return (c >= 0x09 && c <= 0x0D) || c == 0x20;
}

//  stolen from <VC>\CRT\SRC\ATOX.C and modified by eugend.

#ifndef _NO_INT64

__int64 atoi64(const char *nptr)
{
        int c;              /* current char */
        __int64 total;      /* current total */
        int sign;           /* if '-', then negative, otherwise positive */

        /* skip whitespace */
        while ( FIsspace(*nptr) )
            ++nptr;

        c = (int)(unsigned char)*nptr++;
        sign = c;           /* save sign indication */
        if (c == '-' || c == '+')
            c = (int)(unsigned char)*nptr++;    /* skip sign */

        total = 0;

        while (FIsdigit(c)) {
            total = 10 * total + (c - '0');     /* accumulate digit */
            c = (int)(unsigned char)*nptr++;    /* get next char */
        }

        if (sign == '-')
            return -total;
        else
            return total;   /* return result, negated if necessary */
}

#endif  /* _NO_INT64 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\callback.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       callback.h
//
//--------------------------------------------------------------------------


#ifdef __cplusplus
extern "C" {
#endif

#include "..\fdi.h"

#ifdef __cplusplus
}
#endif

FNALLOC(pfnalloc);
FNFREE(pfnfree);
INT_PTR FAR DIAMONDAPI pfnopen(char FAR *pszFile, int oflag, int pmode);
UINT FAR DIAMONDAPI pfnread(INT_PTR hf, void FAR *pv, UINT cb);
UINT FAR DIAMONDAPI pfnwrite(INT_PTR hf, void FAR *pv, UINT cb);
int FAR DIAMONDAPI pfnclose(INT_PTR hf);
long FAR DIAMONDAPI pfnseek(INT_PTR hf, long dist, int seektype);
FNFDINOTIFY(fdinotify);
FNFDIDECRYPT(fdidecrypt);
void HandleError();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\autocom.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       autocom.h
//
//--------------------------------------------------------------------------

/* autocom.h - Common automation definitions and IDispatch implementation

 Include this file in the .CPP files providing automation wrappers
 This file includes "common.h" and "services.h" in the appropriate order
 To provide the implementaion, the base .CPP file for each module must define:
     #define AUTOMATION_HANDLING
 If multiple inheritance is used, CAutoBase must be first base, and must use:
     #pragma pointers_to_members(full_generality, multiple_inheritance)
____________________________________________________________________________*/

#ifndef __AUTOCOM 
#define __AUTOCOM 

#ifndef __COMMON
#include "common.h"   //!! need to remove this line and put in source files for PCH to work
#endif

#ifdef MAC
#include <macole\dispatch.h>
#endif

class IEnumMsiVolume;
class IEnumMsiRecord;

// must implement for each module for use by CAutoBase::GetInterface
IDispatch* CreateAutoObject(IUnknown& riUnknown, long iidLow);


//____________________________________________________________________________
//
// CVariant definition, VARIANT with conversion operators
//____________________________________________________________________________

//!! inaccessible error for operator tagVARIANT: class CVariant : private tagVARIANT {
class CVariant : public tagVARIANT {
 public:
	operator const char*();
	operator const wchar_t*();
	operator int();
	operator unsigned int();
	operator short();
//	operator unsigned short();
	operator long();
//	operator unsigned long();
#ifdef _WIN64
	operator LONG_PTR();
#endif // _WIN64
	operator Bool();
	operator boolean();
	operator MsiDate();
	operator IDispatch*();
	operator tagVARIANT*();
	void operator =(int i);           // used by controller
#ifdef UNICODE
	void operator =(const wchar_t* sz); // used by CEnumVariant
#else
	void operator =(const char* sz);  // used by CEnumVariant
#endif
	void operator =(IDispatch* pi);   // used by CEnumVariant
	int  GetType();
	void Clear();      // free any references, set type to VT_EMPTY
	Bool IsRef();
	Bool IsString();
	IUnknown& Object(const IID& riid); // No AddRef!, throws exception if invalid type
	IUnknown* ObjectPtr(const IID& riid); // No AddRef!, throws exception if invalid type
	const IMsiString& GetMsiString(); // caller must Release(), throws exception is not string type
 private:
	void ConvRef(int type);
   char*& StringDBCS() { return *(char**)(&bstrVal + 1); }

 friend class CAutoArgs;
 friend CVariant* GetCVariantPtr(VARIANT* var);
};
inline CVariant* GetCVariantPtr(VARIANT* var) { return (CVariant*)var; }
inline CVariant::operator tagVARIANT*() { return this; }

//____________________________________________________________________________
//
// CAutoArgs definition, access to automation variant arguments
// operator[] returns CVariant& argument 1 to n, 0 for property value
//____________________________________________________________________________

enum varVoid {fVoid};

enum axAuto
{
	axNoError,
	axInvalidType,
	axConversionFailed,
	axNotObject,
	axBadObjectType,
	axOverflow,
	axMissingArg,
	axExtraArg,
	axCreationFailed,
};

class CAutoArgs
{
 public:
	CAutoArgs(DISPPARAMS* pdispparams, VARIANT* pvarResult, WORD wFlags);
  ~CAutoArgs();
	CVariant& operator[](unsigned int iArg); // 1-based, 0 for property value
	Bool Present(unsigned int iArg);
	Bool PropertySet();
	unsigned int GetLastArg();
//	void operator =(unsigned char  ch);
	void operator =(const char*   pch);
	void operator =(const wchar_t* wsz);
	void operator =(int             i);
//	void operator =(int*           pi);
//	void operator =(unsigned int    u);
//	void operator =(unsigned int*  pu);
	void operator =(short           i);
//	void operator =(short*         pi);
//	void operator =(unsigned short  u);
//	void operator =(unsigned short* p);
	void operator =(long            i);
//	void operator =(long*          pi);
//	void operator =(unsigned long   u);
//	void operator =(unsigned long* pu);
	void operator =(Bool            f);
	void operator =(MsiDate       ad);
	void operator =(IDispatch*     pi);
	void operator =(varVoid         v);
	void operator =(const IMsiString*      pi);
	void operator =(const IMsiString&      pi);
	void operator =(IEnumMsiString&  pi);
	void operator =(IEnumMsiVolume&  pi);
	void operator =(IEnumMsiRecord&  pi);
	void operator =(IEnumVARIANT&  ri);
	void operator =(void*			pv);
	
 protected:
	int       m_cArgs;
	int       m_cNamed;
	long*     m_rgiNamed;
	CVariant* m_rgvArgs;
	CVariant* m_pvResult;
	int       m_wFlags;
	int       m_iLastArg;
	CVariant  m_vTemp;
};

inline Bool CAutoArgs::PropertySet()
{
	return (m_wFlags & DISPATCH_PROPERTYPUT) ? fTrue : fFalse;
}

inline unsigned int CAutoArgs::GetLastArg()
{
	return m_iLastArg;
}

//____________________________________________________________________________
//
// Automation table definitions
//____________________________________________________________________________

class CAutoBase;

enum aafType
{ 
	 aafMethod=DISPATCH_METHOD,
	 aafPropRW=DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT,
	 aafPropRO=DISPATCH_PROPERTYGET,
	 aafPropWO=DISPATCH_PROPERTYPUT
};

template<class T> struct DispatchEntry
{
	DISPID    dispid;
	aafType   aaf;
	void (T::*pmf)(CAutoArgs& args);
	ICHAR*    sz;
	operator DispatchEntry<CAutoBase>*()
	{return (DispatchEntry<CAutoBase>*)this;}
}; // assumption made that CAutoBase is the first or only base class of T

//____________________________________________________________________________
//
// CAutoBase definition, common implementation class for IDispatch  
//____________________________________________________________________________

class IMsiServices;

class CAutoBase : public IDispatch  // class private to this module
{
 public:   // implemented virtual functions
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	HRESULT       __stdcall GetTypeInfoCount(unsigned int *pcTinfo);
	HRESULT       __stdcall GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo** ppi);
	HRESULT       __stdcall GetIDsOfNames(const IID& riid, OLECHAR** rgszNames,
													unsigned int cNames, LCID lcid, DISPID* rgDispId);
	HRESULT       __stdcall Invoke(DISPID dispid, const IID&, LCID lcid, WORD wFlags,
											DISPPARAMS* pdispparams, VARIANT* pvarResult,
											EXCEPINFO* pexcepinfo, unsigned int* puArgErr);
 public:  // common methods of all automation classes
	void HasInterface(CAutoArgs& args);
	void GetInterface(CAutoArgs& args);
	void RefCount    (CAutoArgs& args);
 protected: // class-specific implementation required
	virtual ~CAutoBase(){}                               // optional
	virtual IUnknown& GetInterface();   // Does not AddRef()
	virtual IMsiServices* GetCurrentServices() { return s_piServices; }
	BSTR    FormatErrorString(IMsiRecord& riRecord);
	void	ReleaseStaticServices();
 protected: // constructor
	CAutoBase(DispatchEntry<CAutoBase>* pTable, int cDispId);
 protected: 
	int     m_iRefCnt;
	DispatchEntry<CAutoBase>* m_pTable;
	int     m_cDispId;
 public:
 private:
	static IMsiServices* s_piServices;
	friend class CAutoServices;             // these four share responsibility for s_piServices
	friend class CAutoConfigurationManager;  
	friend class CAutoEngine;
	friend class CAutoSummaryInfo;
	friend class CAutoExecute;
};

typedef DispatchEntry<CAutoBase> DispatchEntryBase;

// sole function is to force template instantiation for VC4.0, never called
inline DISPID GetEntryDispId(DispatchEntryBase* pTable)
{
	return pTable->dispid;
}

//____________________________________________________________________________
//
// CAutoEnum<class T> automation definitions
//____________________________________________________________________________

template<class T> class CAutoEnum : public CAutoBase
{
 public:
	CAutoEnum(T& riEnum, DispatchEntryBase* piTable, int cEntry);
	void _NewEnum(CAutoArgs& args);
 protected:
  ~CAutoEnum();  // protected to prevent creation on stack
	T&   m_riEnum;
};

template<class T>
CAutoEnum<T>::CAutoEnum(T& riEnum, DispatchEntryBase* piTable, int cEntry)
	: CAutoBase(piTable, cEntry)
	, m_riEnum(riEnum)
{
}

template<class T>
CAutoEnum<T>::~CAutoEnum()
{
	m_riEnum.Release();
}

template<class T> void
CAutoEnum<T>::_NewEnum(CAutoArgs& args)
{
	args = *new CEnumVARIANT<T>(m_riEnum);
}

//____________________________________________________________________________
//
// CEnumVariant<class T> definition
//____________________________________________________________________________

template <class T>
class CEnumVARIANT : public IEnumVARIANT
{
 public:
	HRESULT       __stdcall QueryInterface(const GUID& riid, void** ppi);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	HRESULT       __stdcall Next(unsigned long cItem, VARIANT* rgvarRet,
										  unsigned long* cItemRet);
	HRESULT       __stdcall Skip(unsigned long cItem);
	HRESULT       __stdcall Reset();
	HRESULT       __stdcall Clone(IEnumVARIANT** ppiRet);
 public:
   CEnumVARIANT(T& riEnum);
 protected:
  ~CEnumVARIANT();  // protected to prevent creation on stack
	int   m_iRefCnt;
	T&    m_riEnum;
};	

template <class T>
CEnumVARIANT<T>::CEnumVARIANT(T& riEnum)
	: m_riEnum(riEnum)
{
	m_riEnum.AddRef();
	m_iRefCnt = 1;
}

template <class T>
CEnumVARIANT<T>::~CEnumVARIANT()
{
	m_riEnum.Release();
}

template <class T>
HRESULT CEnumVARIANT<T>::QueryInterface(const GUID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IEnumVARIANT)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

template <class T>
unsigned long CEnumVARIANT<T>::AddRef()
{
	return ++m_iRefCnt;
}

template <class T>
unsigned long CEnumVARIANT<T>::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
	return 0;
}

template <class T>
HRESULT CEnumVARIANT<T>::Skip(unsigned long cItem)
{
	return m_riEnum.Skip(cItem);
}

template <class T>
HRESULT CEnumVARIANT<T>::Reset()
{
	return m_riEnum.Reset();
}


template <class T>
HRESULT CEnumVARIANT<T>::Clone(IEnumVARIANT** ppiRet)
{
	T* piEnum;
	HRESULT hrStat = m_riEnum.Clone(&piEnum);
	if (hrStat == NOERROR)
	*ppiRet = (hrStat == NOERROR) ? new CEnumVARIANT(*piEnum) : 0;
	return hrStat;
}

//____________________________________________________________________________
//
// CVariant inline function definitions
//____________________________________________________________________________

inline int CVariant::GetType()
{
	return vt;
}

inline Bool CVariant::IsRef()
{
	return (vt & VT_BYREF) ? fTrue : fFalse;
}

inline Bool CVariant::IsString()
{
	return (vt & 0xFF) == VT_BSTR ? fTrue : fFalse;
}

// Top-level automation factory functions defined in autosrv.cpp 

class IMsiServices;
class IMsiEngine;
class IMsiHandler;
class IMsiConfigurationManager;
class IMsiExecute;

IDispatch* CreateAutoServices(IMsiServices& riServices);
IDispatch* CreateAutoEngine(IMsiEngine& riEngine);
IDispatch* CreateAutoHandler(IMsiHandler& riHandler);
IDispatch* CreateAutoMessage(IMsiMessage& riMessage);
IDispatch* CreateAutoConfigurationManager(IMsiConfigurationManager& riConfigurationManager);
IDispatch* CreateAutoExecute(IMsiExecute& riExecute);

//____________________________________________________________________________
//
// CUnknown - dummy IUnknown definition
//____________________________________________________________________________

class CUnknown : public IUnknown
{
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
};

extern CUnknown g_NullInterface;
extern const IMsiString* g_piStringNull;
extern HINSTANCE g_hInstance;  // defined by module.h

extern const GUID IID_IUnknown;
extern const GUID IID_IClassFactory;
extern const GUID IID_IMarshal;
extern const GUID IID_IDispatch;
extern const GUID IID_IEnumVARIANT;
extern const GUID IID_IMsiServices;
extern const GUID IID_IMsiData;
extern const GUID IID_IMsiDebug;

//============================================================================ 
//
// --------------AUTOMATION IMPLEMENTATION-----------------

#ifdef AUTOMATION_HANDLING

//____________________________________________________________________________
//
// Global data
//____________________________________________________________________________

IMsiServices* CAutoBase::s_piServices = 0;
CMsiStringNullCopy MsiString::s_NullString;  // initialized by InitializeClass
const IMsiString* g_piStringNull = 0;  // initialized when services object created

const GUID IID_IUnknown      = GUID_IID_IUnknown;
const GUID IID_IClassFactory = GUID_IID_IClassFactory;
const GUID IID_IDispatch     = GUID_IID_IDispatch;
const GUID IID_IEnumVARIANT  = GUID_IID_IEnumVARIANT;
const GUID IID_IMsiServices  = GUID_IID_IMsiServices;
const GUID IID_IMsiData      = GUID_IID_IMsiData;
const GUID IID_IMsiDebug     = GUID_IID_IMsiDebug;

#define ERROR_SOURCE_NAME TEXT("Msi error")

//____________________________________________________________________________
//
// Unicode translation API wrappers
//____________________________________________________________________________

#ifndef UNICODE   // override system call in order to do Unicode translation
static BSTR AllocBSTR(const char* sz)
{
	if (sz == 0)
		return 0;
	int cchWide = WIN::MultiByteToWideChar(CP_ACP, 0, sz, -1, 0, 0) - 1;
	BSTR bstr = OLE::SysAllocStringLen(0, cchWide); // null added by API
	WIN::MultiByteToWideChar(CP_ACP, 0, sz, -1, bstr, cchWide);
	bstr[cchWide] = 0; // API function does not null terminate
	return bstr;
}
static BSTR AllocBSTRLen(const char* sz, unsigned int cch)
{
	if (sz == 0)
		return 0;
	int cchWide = WIN::MultiByteToWideChar(CP_ACP, 0, sz, cch, 0, 0);
	BSTR bstr = OLE::SysAllocStringLen(0, cchWide);
	WIN::MultiByteToWideChar(CP_ACP, 0, sz, cch, bstr, cchWide);
	bstr[cchWide] = 0; // API function does not null terminate
	return bstr;
}
#else // UNICODE
inline BSTR AllocBSTR(const WCHAR* sz)
{
	return OLE::SysAllocString(sz);
}
inline BSTR AllocBSTRLen(const WCHAR* sz, unsigned int cch)
{
	return OLE::SysAllocStringLen(sz, cch);
}
#endif

//____________________________________________________________________________
//
// CAutoArgs implementation
//____________________________________________________________________________

CAutoArgs::CAutoArgs(DISPPARAMS* pdispparms, VARIANT* pvarResult, WORD wFlags)
{
	m_cArgs = pdispparms->cArgs;
	m_cNamed = pdispparms->cNamedArgs;
	m_rgiNamed = pdispparms->rgdispidNamedArgs;
	m_rgvArgs = (CVariant*)pdispparms->rgvarg;
	m_pvResult= (CVariant*)pvarResult;
	m_wFlags = wFlags;
#ifdef WIN
	for (int cArgs = m_cArgs; cArgs--; )
	{
		CVariant* pvar = &m_rgvArgs[cArgs];
		if (pvar->vt == VT_VARIANT+VT_BYREF)
			pvar = (CVariant*)pvar->pvarVal;
		if ((pvar->vt & ~VT_BYREF) == VT_BSTR)  // s.bstr is Unicode string
		{
			OLECHAR* bstr;
			if (pvar->vt == VT_BSTR)
				bstr = pvar->bstrVal;
			else // (VT_BYREF | VT_BSTR))
				bstr = *pvar->pbstrVal;
			int cchWide = OLE::SysStringLen(bstr);
			BOOL fUsedDefault;
			int cbDBCS = WIN::WideCharToMultiByte(CP_ACP, 0, bstr, cchWide, 0, 0, 0, 0);
			char* szDBCS = new char[cbDBCS + 1 + sizeof(char*)];
			*(char**)szDBCS = pvar->StringDBCS();
			pvar->StringDBCS() = szDBCS;  // save for subsequent deallocation
			WIN::WideCharToMultiByte(CP_ACP, 0, bstr, cchWide, szDBCS+sizeof(char*), cbDBCS, 0, &fUsedDefault);
			szDBCS[cbDBCS+sizeof(char*)] = 0; // API function does not null terminate
		}
	}
#endif
	if (pvarResult != 0 && pvarResult->vt != VT_EMPTY)
		VariantClear(pvarResult);
}

CAutoArgs::~CAutoArgs()
{
#ifdef WIN
	for (int cArgs = m_cArgs; cArgs--; )
	{
		CVariant* pvar = &m_rgvArgs[cArgs];
		if (pvar->vt == VT_VARIANT+VT_BYREF)
			pvar = (CVariant*)pvar->pvarVal;
		if ((pvar->vt & ~VT_BYREF) == VT_BSTR)
		{
			char* szDBCS = pvar->StringDBCS();  // recover allocated string
			pvar->StringDBCS() = *(char**)szDBCS;  // restore extra bytes in union
			delete szDBCS;    // free translated string
		}
	}
#endif
}

CVariant& CAutoArgs::operator [](unsigned int iArg)
{
//	if (iArg > m_cArgs) // || (iArg ==0 && (wFlags & DISPATCH_PROPERTYPUT))
//		throw axMissingArg;
	int ivarArgs = m_cArgs - iArg;            // get index if unnamed parameter
	if (iArg == 0 || iArg > m_cArgs-m_cNamed) // SET value or named or error
	{
		iArg = iArg==0 ? DISPID_PROPERTYPUT : iArg - 1;  // values are 0-based
		for (ivarArgs = m_cNamed; --ivarArgs >= 0; )
			if (m_rgiNamed[ivarArgs] == iArg)
				break;
	}
	if (ivarArgs < 0)  // loop termination above without match
		throw axMissingArg;
	m_iLastArg = ivarArgs;
	CVariant* pvarRet = &m_rgvArgs[ivarArgs];
	if (pvarRet->GetType() == VT_VARIANT+VT_BYREF)
		pvarRet = (CVariant*)pvarRet->pvarVal;
	return *pvarRet;
}

Bool CAutoArgs::Present(unsigned int iArg)
{
	int ivarArgs = m_cArgs - iArg;            // get index if unnamed parameter
	if (iArg == 0 || iArg > m_cArgs-m_cNamed) // SET value or named or error
	{
		for (ivarArgs = m_cNamed; --ivarArgs >= 0; )
			if (m_rgiNamed[ivarArgs] == iArg-1)
				break;
	}
	return (ivarArgs >=0 && m_rgvArgs[ivarArgs].GetType() != VT_EMPTY) ?
				fTrue : fFalse;
}

//____________________________________________________________________________
//
// CAutoArgs assignment operators implementation
//____________________________________________________________________________

void CAutoArgs::operator =(enum varVoid)
{
	if (m_pvResult)
		m_pvResult->vt = VT_EMPTY;
}

void CAutoArgs::operator =(int i)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_I4;
		m_pvResult->lVal = i;
	}
}

void CAutoArgs::operator =(long i)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_I4;
		m_pvResult->lVal = i;
	}
}

void CAutoArgs::operator =(Bool f)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_BOOL;
		//m_pvResult->boolVal = short(f == fFalse ? 0 : -1);
		V_BOOL(m_pvResult) = short(f == fFalse ? 0 : -1);
	}
}

void CAutoArgs::operator =(MsiDate ad)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_DATE;
		unsigned int wDOSDate = (ad & 0xFFFF0000) >> 16;
		unsigned int wDOSTime = ad & 0x0000FFFF;
		int iDate = wDOSDate;  // save original date
		if (!iDate)   // time only
			wDOSDate = 0x0021;  // make valid date: 1/1/1980
		if (!OLE::DosDateTimeToVariantTime(unsigned short(wDOSDate),
													  unsigned short(wDOSTime), &(m_pvResult->date)))
			throw axConversionFailed;
		if (!iDate)
			m_pvResult->dblVal -= 29221.;  // remove 1/1/80 offset
	}
}

void CAutoArgs::operator =(short i)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_I2;
		m_pvResult->iVal = i;
	}
}

void CAutoArgs::operator =(IDispatch* pi)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_DISPATCH;
		m_pvResult->pdispVal = pi;  // reference count already bumped
	}
	else if(pi)
		pi->Release();
}

#ifndef UNICODE
void CAutoArgs::operator =(const char* sz)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_BSTR;
		m_pvResult->bstrVal = ::AllocBSTR(sz);
	}
}
#endif

void CAutoArgs::operator =(const wchar_t* wsz)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_BSTR;
		m_pvResult->bstrVal = OLE::SysAllocString(wsz);
	}
}

void CAutoArgs::operator =(const IMsiString* piStr)
{
	if (!piStr || !m_pvResult)
	{
		if (piStr)
			piStr->Release();
		return;
	}
	m_pvResult->vt = VT_BSTR;
	m_pvResult->bstrVal = ::AllocBSTRLen(piStr->GetString(), piStr->TextSize());
	piStr->Release();
}

void CAutoArgs::operator =(const IMsiString& riStr)
{
	if (!m_pvResult)
	{
		riStr.Release();
		return;
	}
	m_pvResult->vt = VT_BSTR;
	m_pvResult->bstrVal = ::AllocBSTRLen(riStr.GetString(), riStr.TextSize());
	riStr.Release();
}

void CAutoArgs::operator =(IEnumVARIANT& ri)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_UNKNOWN; // no defined type for IEnumVARIANT
		m_pvResult->punkVal = &ri;  // reference count already bumped
	}
	else
		ri.Release();
}

void CAutoArgs::operator =(void * pv)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_I4;
		m_pvResult->lVal = (long)(LONG_PTR)pv;				//!!merced: 4311 ptr to long
	}
}

//____________________________________________________________________________
//
// CVariant conversion operators implementation
//____________________________________________________________________________

CVariant::operator int()
{
	VARIANT varTemp;
	varTemp.vt = VT_EMPTY;
	HRESULT hrStat = OLE::VariantChangeType(&varTemp, (VARIANT*)this, 0, VT_I4);
	if (hrStat != NOERROR)
		throw axConversionFailed;
	return varTemp.lVal;
}

CVariant::operator long()
{
	VARIANT varTemp;
	varTemp.vt = VT_EMPTY;
	HRESULT hrStat = OLE::VariantChangeType(&varTemp, (VARIANT*)this, 0, VT_I4);
	if (hrStat != NOERROR)
		throw axConversionFailed;
	return varTemp.lVal;
}

#ifdef _WIN64
CVariant::operator LONG_PTR()
{
	VARIANT varTemp;
	varTemp.vt = VT_EMPTY;
	HRESULT hrStat = OLE::VariantChangeType(&varTemp, (VARIANT*)this, 0, VT_I8);
	if (hrStat != NOERROR)
		throw axConversionFailed;
	return varTemp.lVal;
}
#endif

CVariant::operator unsigned int()
{
	VARIANT varTemp;
	varTemp.vt = VT_EMPTY;
	HRESULT hrStat = OLE::VariantChangeType(&varTemp, (VARIANT*)this, 0, VT_I4);
	if (hrStat != NOERROR)
		throw axConversionFailed;
	if (varTemp.lVal < 0)
		throw axOverflow;
	return (unsigned int)varTemp.lVal;
}

CVariant::operator short()
{
	VARIANT varTemp;
	varTemp.vt = VT_EMPTY;
	HRESULT hrStat = OLE::VariantChangeType(&varTemp, (VARIANT*)this, 0, VT_I2);
	if (hrStat != NOERROR)
		throw axConversionFailed;
	return varTemp.iVal;
}

CVariant::operator Bool()
{
	VARIANT varTemp;
	varTemp.vt = VT_EMPTY;
	HRESULT hrStat = OLE::VariantChangeType(&varTemp, (VARIANT*)this, 0, VT_BOOL);
	if (hrStat != NOERROR)
		throw axConversionFailed;
	//return varTemp.boolVal ? fTrue : fFalse;
	return V_BOOL(&varTemp) ? fTrue : fFalse;
}

CVariant::operator boolean()
{
	VARIANT varTemp;
	varTemp.vt = VT_EMPTY;
	HRESULT hrStat = OLE::VariantChangeType(&varTemp, (VARIANT*)this, 0, VT_BOOL);
	if (hrStat != NOERROR)
		throw axConversionFailed;
	return V_BOOL(&varTemp) ? true : false;
}

CVariant::operator MsiDate()
{
	VARIANT varTemp;
	varTemp.vt = VT_EMPTY;
	HRESULT hrStat = OLE::VariantChangeType(&varTemp, (VARIANT*)this, 0, VT_DATE);
	if (hrStat != NOERROR)
		throw axConversionFailed;

	unsigned short usDOSDate, usDOSTime;
	int fTime = (varTemp.dblVal >= 0. && varTemp.dblVal < 1.);
	if (fTime)
		varTemp.dblVal += 29221.;  // add 1/1/80 offset so that conversion doesn't fail
	if (!OLE::VariantTimeToDosDateTime(varTemp.date, &usDOSDate, &usDOSTime))
		throw axConversionFailed;

	if (fTime)
		usDOSDate = 0;  // remove offset, should be 0021H
	MsiDate ad = (MsiDate)((usDOSDate << 16) | usDOSTime);
	return ad;
}

CVariant::operator const wchar_t*()
{
	if (vt == VT_EMPTY)
		return 0;
	if (vt == VT_BSTR)
		return bstrVal;
	else if (vt == (VT_BYREF | VT_BSTR))
		return *pbstrVal;
	else
		throw axInvalidType;
	return 0;// needed to suppress error
}

CVariant::operator const char*()
{
	OLECHAR* bstr;
	if (vt == VT_EMPTY)
		return 0;
	if (vt == VT_BSTR)
		bstr = bstrVal;
	else if (vt == (VT_BYREF | VT_BSTR))
		bstr = *pbstrVal;
	else
		throw axInvalidType;
#ifdef WIN
//	char* szDBCS = StringDBCS();  // recover allocated string
	return StringDBCS() + sizeof(char*);
#else //MAC
	return bstr;
#endif
}

CVariant::operator IDispatch*()
{
	IDispatch* piDispatch;
	if (vt == VT_EMPTY)
		return 0;
	if (vt == VT_DISPATCH)
		piDispatch = pdispVal;
	else if (vt == (VT_BYREF | VT_DISPATCH))
		piDispatch = *ppdispVal;
	else
		throw axNotObject;
	if (piDispatch)
		piDispatch->AddRef();
	return piDispatch;
}

const IMsiString& CVariant::GetMsiString()
{
	OLECHAR* bstr;
	if (vt == VT_EMPTY)
		return *g_piStringNull;
	if (vt == VT_BSTR)
		bstr = bstrVal;
	else if (vt == (VT_BYREF | VT_BSTR))
		bstr = *pbstrVal;
	else if (vt == VT_DISPATCH)
	{
		const IMsiData& piData = (const IMsiData&)Object(IID_IMsiData); // throws exception if fails
		return piData.GetMsiStringValue();  // caller must Release()
	}
	else
		throw axInvalidType;
	int cchWide = OLE::SysStringLen(bstr);
	const IMsiString* piStr = g_piStringNull;

#ifdef UNICODE
	ICHAR* pch = piStr->AllocateString(cchWide, fFalse, piStr);
	memcpy(pch, bstr, cchWide * sizeof(ICHAR));
#else
	int cb = WIN::WideCharToMultiByte(CP_ACP, 0, bstr, cchWide, 0, 0, 0, 0);
	Bool fDBCS = (cb == cchWide ? fFalse : fTrue);
	ICHAR* pch = piStr->AllocateString(cb, fDBCS, piStr);
	BOOL fUsedDefault;
	WIN::WideCharToMultiByte(CP_ACP, 0, bstr, cchWide, pch, cb, 0, &fUsedDefault);
#endif
	return *piStr; // caller must Release()
}

IUnknown& CVariant::Object(const IID& riid)
{
	IUnknown* piUnknown;
	if (vt == VT_DISPATCH || vt == VT_UNKNOWN)
		piUnknown = punkVal;
	else if (vt == (VT_BYREF | VT_DISPATCH) || vt == (VT_BYREF | VT_UNKNOWN))
		piUnknown = *ppunkVal;
	else
		piUnknown = 0;
	if (piUnknown == 0)
		throw axNotObject;
	if (piUnknown->QueryInterface(riid, (void**)&piUnknown) != NOERROR)
		throw axBadObjectType;
	piUnknown->Release();  // we don't keep a reference count
	return *piUnknown;
}

IUnknown* CVariant::ObjectPtr(const IID& riid)
{
	IUnknown* piUnknown;
	if (vt == VT_DISPATCH || vt == VT_UNKNOWN)
		piUnknown = punkVal;
	else if (vt == (VT_BYREF | VT_DISPATCH) || vt == (VT_BYREF | VT_UNKNOWN))
		piUnknown = *ppunkVal;
	else
		throw axNotObject;
	if (piUnknown != 0)
	{
		if (piUnknown->QueryInterface(riid, (void**)&piUnknown) != NOERROR)
			throw axBadObjectType;
		piUnknown->Release();  // we don't keep a reference count
	}
	return piUnknown;
}

void CVariant::operator =(const ICHAR* sz)
{
	vt = VT_BSTR;
	bstrVal = ::AllocBSTR(sz);
}

void CVariant::operator =(IDispatch* pi)
{
	vt = VT_DISPATCH;
	pdispVal = pi;  // reference count already bumped
}

void CVariant::operator =(int i)
{
	vt = VT_I4;
	lVal = i;
}

//____________________________________________________________________________
//
// CAutoBase implementation, common implementation for IDispatch  
//____________________________________________________________________________

/* These methods do not appear in the type library */

DispatchEntry<CAutoBase> AutoBaseTable[] = {
	100, aafPropRO, CAutoBase::HasInterface,  TEXT("HasInterface,iid"),
	101, aafMethod, CAutoBase::GetInterface,  TEXT("GetInterface,iid"),
	102, aafPropRO, CAutoBase::RefCount,      TEXT("RefCount"),
};
const int AutoBaseCount = sizeof(AutoBaseTable)/sizeof(DispatchEntryBase);

CAutoBase::CAutoBase(DispatchEntry<CAutoBase>* pTable, int cDispId)
 : m_pTable(pTable), m_cDispId(cDispId)
{
	m_iRefCnt = 1;
}

IUnknown& CAutoBase::GetInterface()  // default impl. if no delegated interface
{
	return g_NullInterface;  // no installer interface available
}

void CAutoBase::HasInterface(CAutoArgs& args)
{
	static GUID s_Guid = GUID_IID_IUnknown;
	s_Guid.Data1 = (long)args[1];
	Bool fStat = fTrue;
	IUnknown* pi;
	if (QueryInterface(s_Guid, (void**)&pi) == NOERROR)
		pi->Release();
	else	
		fStat = fFalse;
	args = fStat;
}

void CAutoBase::RefCount(CAutoArgs& args)
{
	int i;
	IUnknown& ri = GetInterface();
	if (&ri == &g_NullInterface)  // no delegated object
		i = m_iRefCnt;
	else
	{
		ri.AddRef();
		i = ri.Release();
	}
	args = i;
}

void CAutoBase::GetInterface(CAutoArgs& args)
{
	static GUID s_Guid = GUID_IID_IMsiAuto;
	long iidLow = (long)args[1];
	s_Guid.Data1 = iidLow;
	IUnknown* piUnknown;
	if (QueryInterface(s_Guid, (void**)&piUnknown) != NOERROR)
		throw axBadObjectType;
	IDispatch* piDispatch = ::CreateAutoObject(*piUnknown, iidLow);
	piUnknown->Release();
	if (!piDispatch)
		throw axBadObjectType;
	args = piDispatch;
}


HRESULT CAutoBase::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IDispatch)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	else
		return GetInterface().QueryInterface(riid, ppvObj);
}

unsigned long CAutoBase::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CAutoBase::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
	return 0;
}

HRESULT CAutoBase::GetTypeInfoCount(unsigned int *pcTinfo)
{
	*pcTinfo = 0;
	return NOERROR;
}

HRESULT CAutoBase::GetTypeInfo(unsigned int /*itinfo*/, LCID /*lcid*/, ITypeInfo** ppi)
{
	*ppi = 0;
	return E_NOINTERFACE;
}

HRESULT CAutoBase::GetIDsOfNames(const IID&, OLECHAR** rgszNames, unsigned int cNames,
									 			LCID /*lcid*/, DISPID* rgDispId)
{
	if (cNames == 0 || rgszNames == 0 || rgDispId == 0)
		return E_INVALIDARG;

	unsigned int cErr = cNames;
	DispatchEntryBase* pTable = m_pTable;
	int cEntry = m_cDispId;
	*rgDispId = DISPID_UNKNOWN;
	for (;; pTable++, cEntry--)
	{
		if (cEntry == 0)
		{
			if (pTable == AutoBaseTable + AutoBaseCount)
				break;
			cEntry = AutoBaseCount;
			pTable = AutoBaseTable; // cancel loop increment
		}

		ICHAR* pchName = pTable->sz; 
		for (OLECHAR* pchIn = *rgszNames; *pchIn; pchIn++, pchName++)
		{
			if ((*pchIn ^ *pchName) & ~0x20)
				break;
		}
		if (*pchIn == 0 && *pchName < '0')
		{
			*rgDispId++ = pTable->dispid;
			cErr--;
			while(--cNames != 0)
			{
				rgszNames++;
				*rgDispId = DISPID_UNKNOWN;
				ICHAR* pch = pchName;
				for (DISPID dispid = 0; *pch != 0; dispid++)
				{
					if (*pch != 0)
						pch++;
					for (pchIn = *rgszNames; *pchIn; pchIn++, pch++)
					{
						if ((*pchIn ^ *pch) & ~0x20)
							break;
					}
					if (*pchIn == 0 && *pchName < '0')
					{
						*rgDispId++ = dispid;
						cErr--;
						break;
					}
					while (*pch >= '0')
						pch++;
				}
			}
			break;
		}
	}
	return cErr ? DISP_E_UNKNOWNNAME : NOERROR;
}

BSTR CAutoBase::FormatErrorString(IMsiRecord& riRecord)
{
	if (riRecord.GetFieldCount() == 0)
		return 0;
	int cbFormat = 0;
#ifdef WIN
	ICHAR rgchError[512];
	if (riRecord.IsNull(0))
	{
		const IMsiString* piStr = &riRecord.GetMsiString(0);
		int iError = riRecord.GetInteger(1);
		cbFormat = WIN::LoadString(g_hInstance, iError, rgchError, (sizeof(rgchError)/sizeof(rgchError[0]))-1);
		if (cbFormat > 0)
		{
			piStr->SetString(rgchError, piStr);
			riRecord.SetMsiString(0, *piStr);
		}
		piStr->Release();
	}
#endif

	const IMsiString& riText = riRecord.FormatText(fFalse);
	if (cbFormat)
		riRecord.SetNull(0);  // remove ref before it goes out of scope
	BSTR bstr = ::AllocBSTR(riText.GetString());
	riText.Release();
	return bstr;
}

HRESULT CAutoBase::Invoke(DISPID dispid, const IID&, LCID /*lcid*/, WORD wFlags,
										DISPPARAMS* pdispparams, VARIANT* pvarResult,
										EXCEPINFO* pExceptInfo, unsigned int* puArgErr)
{
	HRESULT hrStat = NOERROR;
	DispatchEntryBase* pTable = m_pTable;
	int cEntry = m_cDispId;
	while (pTable->dispid != dispid)
	{
		pTable++;
		if (--cEntry == 0)
		{
			if (pTable == AutoBaseTable + AutoBaseCount)
				return DISP_E_MEMBERNOTFOUND;
			cEntry = AutoBaseCount;
			pTable = AutoBaseTable;
		}
	}

	if ((wFlags & pTable->aaf) == 0)
		return DISP_E_MEMBERNOTFOUND;

	if (wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
		pvarResult = 0;

	CAutoArgs Args(pdispparams, pvarResult, wFlags);
	try
 	{
		(this->*(pTable->pmf))(Args);
	}
	catch(axAuto axError)
	{
		switch (axError)
		{
		case axInvalidType:      hrStat = DISP_E_TYPEMISMATCH;     break;
		case axConversionFailed: hrStat = DISP_E_TYPEMISMATCH;     break;
		case axNotObject:        hrStat = DISP_E_TYPEMISMATCH;     break;
		case axBadObjectType:    hrStat = DISP_E_TYPEMISMATCH;     break;
		case axOverflow:         hrStat = DISP_E_OVERFLOW;         break;
		case axMissingArg:       hrStat = DISP_E_PARAMNOTOPTIONAL; break;
		case axExtraArg:         hrStat = DISP_E_BADPARAMCOUNT;    break;
		case axCreationFailed:   hrStat = DISP_E_TYPEMISMATCH;     break;
		}
		if (puArgErr)
			*puArgErr = Args.GetLastArg();
	}
	catch(int iHelpContext)
	{
		if (pExceptInfo)
		{
			pExceptInfo->wCode = 1000; //!! ? what should we give?
			pExceptInfo->wReserved = 0;
			pExceptInfo->bstrSource = ::AllocBSTR(ERROR_SOURCE_NAME);
			pExceptInfo->bstrDescription = ::AllocBSTR(pTable->sz);
			pExceptInfo->bstrHelpFile = ::AllocBSTR(TEXT("msiauto.hlp"));
			pExceptInfo->dwHelpContext = iHelpContext;
			pExceptInfo->pfnDeferredFillIn = 0;
			pExceptInfo->scode = 0;
			hrStat = DISP_E_EXCEPTION;
		}
		else
			hrStat = E_FAIL;  // no appropriate error?
	}
	catch(IMsiRecord* piRecord)
	{
		if (piRecord)
		{
			if (pExceptInfo)
			{
				pExceptInfo->wCode = unsigned short(piRecord->GetInteger(1));
				pExceptInfo->wReserved = 0;
				pExceptInfo->bstrSource = ::AllocBSTR(ERROR_SOURCE_NAME);
				pExceptInfo->bstrDescription = FormatErrorString(*piRecord);
				pExceptInfo->bstrHelpFile = 0;
				pExceptInfo->pfnDeferredFillIn = 0;
				pExceptInfo->scode = 0;
				hrStat = DISP_E_EXCEPTION;
			}
			else
				hrStat = E_FAIL;  // no appropriate error?
			piRecord->Release();
		}
   }
	return hrStat;
}

//____________________________________________________________________________
//
// CAutoEnum<IEnumMsiString>, CEnumVARIANT<IEnumMsiString> implementation
//____________________________________________________________________________

DispatchEntry< CAutoEnum<IEnumMsiString> > AutoEnumMsiStringTable[] = {
	DISPID_NEWENUM, aafMethod, CAutoEnum<IEnumMsiString>::_NewEnum, TEXT("_NewEnum"),
};
const int AutoEnumMsiStringCount = sizeof(AutoEnumMsiStringTable)/sizeof(DispatchEntryBase);


void CAutoArgs::operator =(IEnumMsiString& riEnum)
{
	operator =(new CAutoEnum<IEnumMsiString>(riEnum, *AutoEnumMsiStringTable, AutoEnumMsiStringCount));
}
HRESULT CEnumVARIANT<IEnumMsiString>::Next(unsigned long cItem, VARIANT* rgvarRet,
													unsigned long* pcItemRet)
{
	HRESULT hrStat;
	const IMsiString* piStr;
	unsigned long cRet;
	if (pcItemRet)
		*pcItemRet = 0;
	if (!rgvarRet)
		return S_FALSE;
	CVariant* pivar = GetCVariantPtr(rgvarRet);
	while (cItem--)
	{
		hrStat = m_riEnum.Next(1, &piStr, &cRet);
		if (cRet == 0)
			return S_FALSE;
		*pivar = piStr->GetString();
		pivar++;
		piStr->Release();
		if (pcItemRet)
			(*pcItemRet)++;
	}
	return S_OK;
}


//____________________________________________________________________________
//
// CUnknown - dummy IUnknown implementation and global object
//____________________________________________________________________________

HRESULT CUnknown::QueryInterface(const IID&, void**){return E_NOINTERFACE;}
unsigned long CUnknown::AddRef(){return 1;}
unsigned long CUnknown::Release(){return 1;}
CUnknown g_NullInterface;

#endif // AUTOMATION_HANDLING


#endif __AUTOCOM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\common.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       common.h
//
//--------------------------------------------------------------------------

/* common.h   Common MSI project definitions, #include first
              This header is for MSI core modules only
              External clients of MSI should include msidefs.h
____________________________________________________________________________*/

#ifndef __COMMON
#define __COMMON


// The following level 4 warnings have been changed to level 3 in an attempt to
// report only relevant warnings. The full spectrum of level 4 warnings can
// be found by querying for "Compiler Warning (level 4" in "Visual C++ Books"
// Any level 4 warning that is not specified here will not be displayed.
#pragma warning(3 : 4100) // unreferenced formal parameter
#pragma warning(3 : 4125) // decimal digit terminates octal escape sequence
#pragma warning(3 : 4127) // conditional expression is constant
#pragma warning(3 : 4132) // constant was not initialized.
#pragma warning(3 : 4244) // an integral type was converted to a smaller integral type.
#pragma warning(3 : 4505) // unreferenced local function has been removed
#pragma warning(3 : 4514) // unreferenced inline/local function has been removed
#pragma warning(3 : 4705) // statement has no effect
#pragma warning(3 : 4706) // assignment within conditional expression
#pragma warning(3 : 4701) // uninitialized local variable

//exception-handling warnings
#ifndef _WIN64  // New compiler is much more strict
#pragma warning(3 : 4061) // specified enumerate did not have an associated handler in a switch statement.
#endif
#pragma warning(3 : 4019) // empty statement at global scope
#pragma warning(3 : 4670) // specified base class of an object to be thrown in a try block is not accessible.
#pragma warning(3 : 4671) // user-defined copy constructor for the specified thrown object is not accessible.
#pragma warning(3 : 4672) // object to be thrown in a try block is ambiguous.
#pragma warning(3 : 4673) // throw object cannot be handled in the catch block.
#pragma warning(3 : 4674) // user-defined destructor for the specified thrown object is not accessible.
#pragma warning(3 : 4727) // conditional expression is constant


#ifdef DEBUG
// we're going to ignore this warning as we're currently only using exceptions as a fancy assert mechanism
#pragma warning(disable : 4509) // nonstandard extension used: 'function' uses SEH and 'object' has destructor
#endif

// turn off warnings that are not easily suppressed
#pragma warning(disable : 4514) // inline function not used
#pragma warning(disable : 4201) // unnamed struct/unions, in Win32 headers
#pragma warning(disable : 4702) // unreachable code, optimization bug

//!! TODO: new build tools used for NT_BUILDTOOLS/WIN64 are much more strict
//!! for now we will disable these warnings, but we need to address these eventually
#pragma warning(disable : 4018) // signed/unsigned mismatch
#pragma warning(disable : 4061) // enumerate not explicitly handled by a case label

// #define CONFIGDB  // define to utilize configuration database for file sharing

# undef  WIN  // in case defined by makefile
# define WIN  // has no value, use to designate API calls  WIN:xxx
# define INC_OLE2             // include OLE headers

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

# include <windows.h>
# include <winuserp.h>
# include "sysadd.h"
# include <commctrl.h>
# include <commdlg.h>
#include <wtsapi32.h>	// for WTSEnumerateSessions and related data structs, defs. etc.
#include <winsta.h>		// for WinStationGetTermSrvCountersValue, related data structs and defs.
#include <allproc.h>	// for TS_COUNTER
# include <pbt.h>
# ifndef ICC_PROGRESS_CLASS  // check for obsolete OTOOLS version of commctrl.h
#  define ICC_PROGRESS_CLASS   0x00000020 // progress
        typedef struct tagINITCOMMONCONTROLSEX {
                DWORD dwSize;             // size of this structure
                DWORD dwICC;              // flags indicating which classes to be initialized
        } INITCOMMONCONTROLSEX, *LPINITCOMMONCONTROLSEX;
        BOOL WINAPI InitCommonControlsEx(LPINITCOMMONCONTROLSEX);
# endif
# include <shlobj.h>
typedef BOOL OLEBOOL;   // defined differently on MAC, used in LockServer

#include <shlwapi.h>

#ifdef PROFILE
# include <icecap.h>
#endif //PROFILE

#include <fusion.h>
#include <corerror.h>

# define REG  //!! not needed, remove from client.cpp as well
# define OLE  //!! used in module.h, should use latebind functions?

#include "msidefs.h"  // public MSI definitions
#define  STRSAFE_LIB
#include <strsafe.h>


//____________________________________________________________________________
//
// Extern variables
//____________________________________________________________________________
extern bool g_fWinNT64;
extern bool g_fRunScriptElevated;


//____________________________________________________________________________
//
// Registry access functions' redirection
//____________________________________________________________________________

//  The intent of the redefinitions below is to prevent devs from calling
//  RegOpen/CreateKeyEx APIs directly in order to open/create Darwin's own
//  configuration keys.  The reason behind this is that when the 32-bit
//  MSI.DLL runs on WIN64 any attempts to open/create a key, will be made
//  to open/create the key in the redirected, virtual 32-bit hive.  This is
//  undesirable since Darwin's configuration data is stored in the regular
//  (64-bit) hive and this will cause certain calls to fail.
//
//  The right way to access Darwin's configuration data in this case is to
//  OR the REGSAM value passed to the API with KEY_WOW64_64KEY and
//  MsiRegOpen64bitKey & MsiRegCreate64bitKey functions below do just that.
//  Alternatively, these two functions can be used when we want to make sure
//  that on Win64, if the key is redirected, the 64-bit one will be opened/created.
//
//  For all non-configuration data registry accesses, the RegOpenKeyAPI and
//  RegCreateKeyAPI functions below map directly to the Windows APIs.

#undef RegOpenKeyEx
#define RegOpenKeyEx(hKey, lpSubKey, ulOptions, \
							samDesired, phkResult) \
	Please_use_MsiRegOpen64bitKey_or_RegOpenKeyAPI_instead_of_RegOpenKeyEx(hKey, \
							lpSubKey, ulOptions, samDesired, phkResult)

#undef RegCreateKeyEx
#define RegCreateKeyEx(hKey, lpSubKey, Reserved, \
							lpClass, dwOptions, samDesired, \
							lpSecurityAttributes, phkResult, \
							lpdwDisposition) \
	Please_use_MsiRegCreate64bitKey_or_RegCreateKeyAPI_instead_of_RegCreateKeyEx(hKey, \
							lpSubKey, Reserved, lpClass, dwOptions, samDesired, \
							lpSecurityAttributes, phkResult, lpdwDisposition)

#ifdef UNICODE
	#define RegOpenKeyAPI    RegOpenKeyExW
	#define RegCreateKeyAPI  RegCreateKeyExW
#else
	#define RegOpenKeyAPI    RegOpenKeyExA
	#define RegCreateKeyAPI  RegCreateKeyExA
#endif

#if defined(_MSI_DLL) || defined(_EXE)

inline void AdjustREGSAM(REGSAM& samDesired)
{
#ifndef _WIN64
	if ( g_fWinNT64 &&
		  (samDesired & KEY_WOW64_64KEY) != KEY_WOW64_64KEY )
		samDesired |= KEY_WOW64_64KEY;
#else
	samDesired = samDesired;  // the compiler rejoices now
#endif
}

//  RegOpenKeyEx wrapper that takes care of adjusting REGSAM such as
//  it will open Darwin's configuration key in the 64-bit hive when
//  called from 32-bit MSI.DLL on Win64.
//
//  Alternatively, it can be used when we want to make sure that on
//  Win64 we open the 64-bit version of a possibly redirected key.

inline DWORD MsiRegOpen64bitKey(
							IN HKEY hKey,
							IN LPCTSTR lpSubKey,
							IN DWORD ulOptions,
							IN REGSAM samDesired,
							OUT PHKEY phkResult)
{
	AdjustREGSAM(samDesired);
	return RegOpenKeyAPI(hKey, lpSubKey, ulOptions, samDesired, phkResult);
}

//  RegCreateKeyEx wrapper that takes care of adjusting REGSAM such as
//  it will create Darwin's configuration key in the 64-bit hive when
//  called from 32-bit MSI.DLL on Win64.
//
//  Alternatively, it can be used when we want to make sure that on
//  Win64 we create the 64-bit version of a possibly redirected key.

inline DWORD MsiRegCreate64bitKey(
							IN HKEY hKey,
							IN LPCTSTR lpSubKey,
							IN DWORD Reserved,
							IN LPTSTR lpClass,
							IN DWORD dwOptions,
							IN REGSAM samDesired,
							IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
							OUT PHKEY phkResult,
							OUT LPDWORD lpdwDisposition)
{
	AdjustREGSAM(samDesired);
	return RegCreateKeyAPI(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
}

#endif // defined(_MSI_DLL) || defined(_EXE)

//____________________________________________________________________________
//
// Extern function declarations
//____________________________________________________________________________

extern UINT MsiGetSystemDirectory (LPTSTR lpBuffer, UINT uSize, BOOL bAlwaysReturnWOW64Dir);
extern void GetVersionInfo(int* piMajorVersion, int* piMinorVersion, int* piWindowsBuild, bool* pfWin9X, bool* pfWinNT64);
extern bool MakeFullSystemPath(const TCHAR* szFile, TCHAR* szFullPath, size_t cchFullPath);


//____________________________________________________________________________
//
//  Common type definitions
//____________________________________________________________________________

// Definitions for platform-dependent data types
typedef HINSTANCE MsiModuleHandle;
typedef HGLOBAL   MsiMemoryHandle;

// Boolean definition, eventually will use compiler bool when available
#if !defined(MSIBOOL)
enum Bool
{
        fFalse,
        fTrue
};
#endif

enum TRI
{
        tUnknown = -1,
        tTrue = 1,
        tFalse = 0
};

enum MsiDate {};  // an int containing DosTime and DosDate
enum scEnum // server context
{
        scClient,
        scServer,
        scService,
        scCustomActionServer,
};


//____________________________________________________________________________
//
// Temporary 64-bit compatible definitions.
// !!merced: these should go away when the new windows.h is #included, since that contains these already.
//____________________________________________________________________________

#define INT_MAX       2147483647    /* maximum (signed) int value */
#define UINT_MAX      0xffffffff    /* maximum unsigned int value */

#ifndef _WIN64

typedef int LONG32, *PLONG32;
//typedef int INT32, *PINT32;

typedef __int64 INT64, *PINT64;  //  eugend stole it from basetsd.h

//
// The following types are guaranteed to be unsigned and 32 bits wide.
//

typedef unsigned int ULONG32, *PULONG32;
typedef unsigned int DWORD32, *PDWORD32;
typedef unsigned int UINT32, *PUINT32;

// pointer precision:
typedef int INT_PTR, *PINT_PTR;
typedef unsigned int UINT_PTR, *PUINT_PTR;

typedef long LONG_PTR, *PLONG_PTR;
typedef unsigned long ULONG_PTR, *PULONG_PTR;

//
// SIZE_T used for counts or ranges which need to span the range of
// of a pointer.  SSIZE_T is the signed variation.
//

typedef ULONG_PTR SIZE_T, *PSIZE_T;
typedef LONG_PTR SSIZE_T, *PSSIZE_T;


#define __int3264   __int32
#endif  // ifndef _WIN64

#if defined(_WIN64) || defined(DEBUG)
#define USE_OBJECT_POOL
#endif // _WIN64 || DEBUG

void RemoveObjectData(int iIndex);

#ifndef USE_OBJECT_POOL
#define RemoveObjectData(x)
#endif //!USE_OBJECT_POOL

//____________________________________________________________________________
//
// Error code and message group definitions
//
// Error messages must be defined using the IShipError or IDebugError macros
//      IShipError(imsgMessageName, imsgGroup + offset)
//      IDebugError(idbgMessageName, imsgGroup + offset, "Format template string")
// The template string contains record field markers in the form: [2].
// The first record field, [1], is reserved for the error code, imsgXXX.
// The template strings specified in the macro are not compiled with the SHIP code,
// but are used to generate the Error table which is imported to the database.
// The record template field, [0], is filled in by the engine from Error table.
// The message prefix with the error code is supplied by the engine Message method.
// Message definitions must occur outside of the "#ifndef ERRORTABLE" block.
//____________________________________________________________________________

enum imsgEnum
{
        imsgStart    =   32,   // start of messages to be fetched from error table
        imsgBase     = 1000,   // offset for error messages, must be >=1000 for VBA
        idbgBase     = 2000,   // offset for debug-only messages

        imsgHost     = imsgBase + 000, // produced by install host or automation
        imsgServices = imsgBase + 100, // produced by general services, services.h
        imsgDatabase = imsgBase + 200, // produced by database access, databae.h
        imsgFile     = imsgBase + 300, // produced by file/volume services, path.h
        imsgRegistry = imsgBase + 400, // produced by registry services, regkey.h
        imsgConfig   = imsgBase + 500, // produced by configuration manager, iconfig.h
        imsgAction   = imsgBase + 600, // produced by standard actions, actions.h
        imsgEngine   = imsgBase + 700, // produced by engine, engine.h
        imsgHandler  = imsgBase + 800, // associated with UI control, handler.h
        imsgExecute  = imsgBase + 900, // produced by execute methods, engine.h

        idbgHost     = imsgHost     + idbgBase - imsgBase,
        idbgServices = imsgServices + idbgBase - imsgBase,
        idbgDatabase = imsgDatabase + idbgBase - imsgBase,
        idbgFile     = imsgFile     + idbgBase - imsgBase,
        idbgRegistry = imsgRegistry + idbgBase - imsgBase,
        idbgConfig   = imsgConfig   + idbgBase - imsgBase,
        idbgAction   = imsgAction   + idbgBase - imsgBase,
        idbgEngine   = imsgEngine   + idbgBase - imsgBase,
        idbgHandler  = imsgHandler  + idbgBase - imsgBase,
        idbgExecute  = imsgExecute  + idbgBase - imsgBase,
};

#define IShipError(a,b)    const int a = (b);
#define IDebugError(a,b,c) const int a = (b);
#include "debugerr.h"
#undef IShipError
#undef IDebugError

//____________________________________________________________________________

// Version template to use when formatting version number to string
#ifdef DEBUG
#define MSI_VERSION_TEMPLATE TEXT("%d.%02d.%04d.%02d")
#else // SHIP
#define MSI_VERSION_TEMPLATE TEXT("%d.%02d")
#endif

typedef HINSTANCE    HDLLINSTANCE;

extern "C" const GUID IID_IMsiDebug;

//____________________________________________________________________________

#ifndef __ISTRING
#include "istring.h"
#endif

#ifndef __RECORD
#include "record.h"
#endif

class IMsiDebug : public IUnknown
{
public:
        virtual void  __stdcall SetAssertFlag(Bool fShowAsserts)=0;
        virtual void  __stdcall SetDBCSSimulation(char chLeadByte)=0;
        virtual Bool  __stdcall WriteLog(const ICHAR* szText)=0;
        virtual void  __stdcall AssertNoObjects()=0;
        virtual void  __stdcall SetRefTracking(long iid, Bool fTrack)=0;

};


#include "imemory.h"        // internal memory management interfaces

#define SzDllGetClassObject "DllGetClassObject"
typedef HRESULT (__stdcall *PDllGetClassObject)(const GUID&,const IID&,void**);

//____________________________________________________________________________
//
//  Internal error definitions after include of headers: Imsg, and ISetErrorCode
//____________________________________________________________________________

#  define Imsg(a) a
        typedef int IErrorCode;
        class IMsiRecord;
        inline void ISetErrorCode(IMsiRecord* piRec, IErrorCode err)
        {piRec->SetInteger(1, err);}

//____________________________________________________________________________
//
// COM pointer encapsulation to force the Release call at destruction
// The encapsulated pointer is also Release'd on assignment of a new value.
// The object may be used where either a pointer is expected.
// This object behaves as a pointer when using operators: ->, *, and &.
// A non-null pointer may be tested for simply by using: if(PointerObj).
// Typedefs may be defined for the individual template instantiations
//____________________________________________________________________________

template <class T> class CComPointer
{
 public:
        CComPointer(T* pi) : m_pi(pi){}
        CComPointer(IUnknown& ri, const IID& riid) {ri.QueryInterface(riid, (void**)&m_pi);}
        CComPointer(const CComPointer<T>& r) // copy constructor, calls AddRef
        {
                if(r.m_pi)
                        ((IUnknown*)r.m_pi)->AddRef();
                m_pi = r.m_pi;
        }
		~CComPointer() {if (m_pi) ((IUnknown*)m_pi)->Release();} // release ref count at destruction
        CComPointer<T>& operator =(const CComPointer<T>& r) // copy assignment, calls AddRef
        {
                if(r.m_pi)
                        ((IUnknown*)r.m_pi)->AddRef();
                if (m_pi) ((IUnknown*)m_pi)->Release();
                m_pi=r.m_pi;
                return *this;
        }
        CComPointer<T>& operator =(T* pi)
                                        {if (m_pi) ((IUnknown*)m_pi)->Release(); m_pi = pi; return *this;}
        operator T*() {return m_pi;}     // returns pointer, no ref count change
        T* operator ->() {return m_pi;}  // allow use of -> to call member functions
        T& operator *()  {return *m_pi;} // allow dereferencing (can't be null)
        T** operator &() {if (m_pi) ((IUnknown*)m_pi)->Release(); m_pi = 0; return &m_pi;}
 private:
        T* m_pi;
};


//____________________________________________________________________________
//
// CTempBuffer<class T, int C>   // T is array type, C is element count
//
// Temporary buffer object for variable size stack buffer allocations
// Template arguments are the type and the stack array size.
// The size may be reset at construction or later to any other size.
// If the size is larger that the stack allocation, new will be called.
// When the object goes out of scope or if its size is changed,
// any memory allocated by new will be freed.
// Function arguments may be typed as CTempBufferRef<class T>&
//  to avoid knowledge of the allocated size of the buffer object.
// CTempBuffer<T,C> will be implicitly converted when passed to such a function.
//____________________________________________________________________________

template <class T> class CTempBufferRef;  // for passing CTempBuffer as unsized ref

#if defined(DEBUG) && defined(_MSI_DLL)
#define VerifyMSIAllocator() CheckAndAssertNoAllocator()
extern void CheckAndAssertNoAllocator();
#else
#define VerifyMSIAllocator() 
#endif

template <class T, int C> class CTempBuffer
{
 public:
        CTempBuffer() { VerifyMSIAllocator(); m_cT = C; m_pT = m_rgT; }
        explicit CTempBuffer(int cT) { VerifyMSIAllocator(); m_pT = (m_cT = cT) > C ? new T[cT] : m_rgT;}
		~CTempBuffer() {if (m_cT > C) delete m_pT;}
        operator T*() const {return  m_pT;}  // returns pointer
        operator T&()  {return *m_pT;}  // returns reference
        int  GetSize() const {return  m_cT;}  // returns last requested size
        void SetSize(int cT) {if (m_cT > C) delete[] m_pT; m_pT = (m_cT=cT) > C ? new T[cT] : m_rgT;}
        void Resize(int cT) {
                T* pT = cT > C ? new T[cT] : m_rgT;
				if ( ! pT ) cT = 0;
                if(m_pT != pT)
                        for(int iTmp = (cT < m_cT)? cT: m_cT; iTmp--;) pT[iTmp] = m_pT[iTmp];
                if(m_pT != m_rgT) delete[] m_pT; m_pT = pT; m_cT = cT;
        }
        operator CTempBufferRef<T>&() {m_cC = C; return *(CTempBufferRef<T>*)this;}
        T& operator [](int iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
        T& operator [](unsigned int iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
#ifdef _WIN64           //--merced: additional operators for int64
        T& operator [](INT_PTR iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
        T& operator [](UINT_PTR iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
#endif
 protected:
        void* operator new(size_t) {return 0;} // restrict use to temporary objects
        T*  m_pT;     // current buffer pointer
        int m_cT;     // reqested buffer size, allocated if > C
        int m_cC;     // size of local buffer, set only by conversion to CTempBufferRef
        T   m_rgT[C]; // local buffer, must be final member data
};

template <class T> class CTempBufferRef : public CTempBuffer<T,1>
{
 public:
        void SetSize(int cT) {if (m_cT > m_cC) delete[] m_pT; m_pT = (m_cT=cT) > m_cC ? new T[cT] : m_rgT;}
        void Resize(int cT) {
                T* pT = cT > m_cC ? new T[cT] : m_rgT;
				if ( ! pT ) cT = 0;
                if(m_pT != pT)
                        for(int iTmp = (cT < m_cT)? cT: m_cT; iTmp--;) pT[iTmp] = m_pT[iTmp];
                if(m_pT != m_rgT) delete[] m_pT; m_pT = pT; m_cT = cT;
        }
 private:
        CTempBufferRef(); // cannot be constructed
        ~CTempBufferRef(); // ensure use as a reference
};

// This is the extra we want to add on for the future
const int cbExtraAlloc = 256;

inline void ResizeTempBuffer(CTempBufferRef<ICHAR>& rgchBuf, int cchNew)
{
	if (rgchBuf.GetSize() < cchNew)
		rgchBuf.Resize(cchNew + cbExtraAlloc);
}

//____________________________________________________________________________
//
// CAPITempBuffer class is mirrored on the CTempBuffer except that it uses GlobalAlloca
// and GlobalFree in place of new and delete. We should try combining these 2 in the future
//____________________________________________________________________________


template <class T> class CAPITempBufferRef;

template <class T, int C> class CAPITempBuffer
{
 private:
	inline void Init() {m_cT = C; m_pT = m_rgT;}
 public:
	CAPITempBuffer() {Init();}
	// I wouldn't use the constructor below because the resulting buffer
	// is not certain it will be of nSize.  It would be safer to use
	// something like:
	//    CApiTempBuffer<ICHAR, 1> rgchBuffer;
	//    if ( !rgchBuffer.SetSize(nSize) )
	//       handle error here
	explicit CAPITempBuffer(int cT) {Init(); bool fDummy = SetSize(cT, false);}
	void Destroy() {if (m_cT > C) GlobalFree(m_pT); Init();}
	~CAPITempBuffer() {Destroy();}
	operator T*() const {return  m_pT;}	// returns pointer
	operator T&()  {return *m_pT;}	// returns reference
	int  GetSize() const {return  m_cT;}	// returns last requested size
	bool SetSize(int cT, bool fSaveExisting=false) {
		T* pT = cT > C ? (T*)GlobalAlloc(GMEM_FIXED, sizeof(T)*cT) : m_rgT;
		if ( !pT ) return false;
		if (fSaveExisting && m_pT != pT)
			for (int iTmp = (cT < m_cT)? cT: m_cT; iTmp--;)
				pT[iTmp] = m_pT[iTmp];
		if (m_pT != m_rgT) GlobalFree(m_pT);
		m_pT = pT; m_cT = cT;
		return true;
	}
	bool Resize(int cT) {return SetSize(cT, true);}
	operator CAPITempBufferRef<T>&() {m_cC = C; return *(CAPITempBufferRef<T>*)this;}
	T& operator [](int iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
	T& operator [](unsigned int iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
#ifdef _WIN64           //--merced: additional operators for int64
	T& operator [](INT_PTR iTmp)  {return  *(m_pT + iTmp);}	 // returns pointer
	T& operator [](UINT_PTR iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
#endif
 protected:
	void* operator new(size_t) {return 0;} // restrict use to temporary objects
	T*  m_pT;     // current buffer pointer
	int m_cT;     // reqested buffer size, allocated if > C
	int m_cC;     // size of local buffer, set only by conversion to CAPITempBufferRef
	T   m_rgT[C]; // local buffer, must be final member data
};

template <class T> class CAPITempBufferRef : public CAPITempBuffer<T,1>
{
 public:
	bool SetSize(int cT, bool fSaveExisting=false) {
		T* pT = cT > m_cC ? (T*)GlobalAlloc(GMEM_FIXED, sizeof(T)*cT) : m_rgT;
		if ( !pT ) return false;
		if (fSaveExisting && m_pT != pT)
			for (int iTmp = (cT < m_cT)? cT: m_cT; iTmp--;)
				pT[iTmp] = m_pT[iTmp];
		if (m_pT != m_rgT) GlobalFree(m_pT);
		m_pT = pT; m_cT = cT;
		return true;
	}
	bool Resize(int cT) {return SetSize(cT, true);}
 private:
	CAPITempBufferRef(); // cannot be constructed
	~CAPITempBufferRef(); // ensure use as a reference
};

// the following function checks that we dont overflow an ICHAR buffer that we are filling
// if so, it resizes the buffer
// if the length of the string to append is known, we pass it in ELSE we pass in -1
inline void AppendStringToTempBuffer(CAPITempBufferRef<ICHAR>& rgchBuf, const ICHAR* szStringToAppend, int iLenAppend = -1)
{
        int iLenExists = IStrLen(rgchBuf);
        if(iLenAppend == -1)
                iLenAppend = IStrLen(szStringToAppend);
        if(iLenExists + iLenAppend + 1 > rgchBuf.GetSize())
                rgchBuf.Resize(iLenExists + iLenAppend + 1 + cbExtraAlloc); // we add some extra allocation to possibly prevent future reallocation
        StringCchCat((ICHAR*)rgchBuf, rgchBuf.GetSize(), szStringToAppend);
}

//____________________________________________________________________________
//
// CConvertString -- does appropriate ANSI/UNICODE string conversion for
// function arguments. Wrap string arguments that might require conversion
// (ANSI->UNICODE) or (UNICODE->ANSI). The compiler will optimize away the
// case where conversion is not required.
//
// Beware: For efficiency this class does *not* copy the string to be converted.
//____________________________________________________________________________

class CConvertString
{
public:
        explicit CConvertString(const char* szParam);
        explicit CConvertString(const WCHAR* szParam);
        operator const char*()
        {
                if (!m_szw)
                        return m_sza;
                else
                {
                        int cchParam = lstrlenW(m_szw);
                        if (cchParam+1 > m_rgchAnsiBuf.GetSize())
                                m_rgchAnsiBuf.SetSize(cchParam+1);

                        *m_rgchAnsiBuf = 0;
                        int iRet = WideCharToMultiByte(CP_ACP, 0, m_szw, -1, m_rgchAnsiBuf,
                                                                          m_rgchAnsiBuf.GetSize(), 0, 0);

                        if ((0 == iRet) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
                        {
                                iRet = WideCharToMultiByte(CP_ACP, 0, m_szw, -1, 0, 0, 0, 0);
                                if (iRet)
                                {
                                        m_rgchAnsiBuf.SetSize(iRet);
                                        *m_rgchAnsiBuf = 0;
                                        iRet = WideCharToMultiByte(CP_ACP, 0, m_szw, -1, m_rgchAnsiBuf,
                                                                  m_rgchAnsiBuf.GetSize(), 0, 0);
                                }
                                //Assert(iRet != 0);
                        }

                        return m_rgchAnsiBuf;
                }
        }



        operator const WCHAR*()
        {
                if (!m_sza)
                        return m_szw;
                else
                {
                        int cchParam = lstrlenA(m_sza);
                        if (cchParam+1 > m_rgchWideBuf.GetSize())
                                m_rgchWideBuf.SetSize(cchParam+1);

                        *m_rgchWideBuf = 0;
                        int iRet = MultiByteToWideChar(CP_ACP, 0, m_sza, -1, m_rgchWideBuf, m_rgchWideBuf.GetSize());
                        if ((0 == iRet) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
                        {
                                iRet = MultiByteToWideChar(CP_ACP, 0, m_sza, -1, 0, 0);
                                if (iRet)
                                {
                                        m_rgchWideBuf.SetSize(iRet);
                                        *m_rgchWideBuf = 0;
                                        iRet = MultiByteToWideChar(CP_ACP, 0, m_sza, -1, m_rgchWideBuf, m_rgchWideBuf.GetSize());
                                }
                                //Assert(iRet != 0);
                        }


                        return m_rgchWideBuf;
                }
        }

protected:
        void* operator new(size_t) {return 0;} // restrict use to temporary objects
        CTempBuffer<char, 1> m_rgchAnsiBuf;
        CTempBuffer<WCHAR, 1> m_rgchWideBuf;
        const char* m_sza;
        const WCHAR* m_szw;
};

inline CConvertString::CConvertString(const WCHAR* szParam)
{
		VerifyMSIAllocator();
        m_szw = szParam;
        m_sza = 0;
		m_rgchAnsiBuf[0] = '0';
		m_rgchWideBuf[0] = L'0';
}

inline CConvertString::CConvertString(const char* szParam)
{
		VerifyMSIAllocator();
        m_szw = 0;
        m_sza = szParam;
		m_rgchAnsiBuf[0] = '0';
		m_rgchWideBuf[0] = L'0';
}

//____________________________________________________________________________
//
//  GUID definitions - Standard COM interfaces and Msi interfaces
//   The GUID range 0xC1000-0xC10FF is reserved for Microsoft Installer use.
//      Installer interface IDs:     0xC1000 to 0xC101F
//      Installer enums and debug:   0xC1020 to 0xC103F (enum offset by 20H)
//      Installer automation IDs:    0xC1040 to 0xC105F (auto offset by 40H)
//      Installer auto enums, BBT:   0xC1060 to 0xC107F (enum offset by 60H)
//      Installer storage classes:   0xC1080 to 0xC108F (IStorage CLSIDs)
//      Installer API automation:    0xC1090 to 0xC109F
//      Installer tool interfaces:   0xC10A0 to 0xC10BF (defined in tools.h)
//      Installer tool debug IDs:    0xC10C0 to 0xC10DF (defined in tools.h)
//      Installer tool automation:   0xC10E0 to 0xC10EF (defined in tools.h)
//      Installer plug-in IDs:       0xC10F0 to 0xC10FF
//   The GUID range 0xC1010-0xC11FF is reserved for samples, tests, ext. tools.
//   To avoid forcing OLE DLLs to load, we also define the few OLEGUIDs here.
//   To instantiate the GUIDS, use: const GUID IID_xxx = GUID_IID_xxx;
//____________________________________________________________________________


const int iidUnknown                      = 0x00000L;
const int iidClassFactory                 = 0x00001L;
const int iidMalloc                       = 0x00002L;
const int iidMarshal                      = 0x00003L;
const int iidLockBytes                    = 0x0000AL;
const int iidStorage                      = 0x0000BL;
const int iidStream                       = 0x0000CL;
const int iidEnumSTATSTG                  = 0x0000DL;
const int iidRootStorage                  = 0x00012L;
const int iidServerSecurity               = 0x0013EL;
const int iidDispatch                     = 0x20400L;
const int iidTypeInfo                     = 0x20401L;
const int iidEnumVARIANT                  = 0x20404L;

const int iidMsiBase                      = 0xC1000L;
const int iidMsiData                      = 0xC1001L;
const int iidMsiString                    = 0xC1002L;
const int iidMsiRecord                    = 0xC1003L;
const int iidMsiVolume                    = 0xC1004L;
const int iidMsiPath                      = 0xC1005L;
const int iidMsiFileCopy                  = 0xC1006L;
const int iidMsiRegKey                    = 0xC1007L;
const int iidMsiTable                     = 0xC1008L;
const int iidMsiCursor                    = 0xC1009L;
const int iidMsiMemoryStream              = 0xC100AL;
const int iidMsiServices                  = 0xC100BL;
const int iidMsiView                      = 0xC100CL;
const int iidMsiDatabase                  = 0xC100DL;
const int iidMsiEngine                    = 0xC100EL;
const int iidMsiHandler                   = 0xC100FL;
const int iidMsiDialog                    = 0xC1010L;
const int iidMsiEvent                     = 0xC1011L;
const int iidMsiControl                   = 0xC1012L;
const int iidMsiDialogHandler             = 0xC1013L;
const int iidMsiStorage                   = 0xC1014L;
const int iidMsiStream                    = 0xC1015L;
const int iidMsiSummaryInfo               = 0xC1016L;
const int iidMsiMalloc                    = 0xC1017L;
const int iidMsiSelectionManager          = 0xC1018L;
const int iidMsiDirectoryManager          = 0xC1019L;
const int iidMsiCostAdjuster              = 0xC101AL;
const int iidMsiConfigurationManager      = 0xC101BL;
const int iidMsiServer                    = 0xC101CL;
const int iidMsiMessage                   = 0xC101DL;
const int iidMsiExecute                   = 0xC101EL;
const int iidMsiFilePatch                 = 0xC101FL;

// enums (offset 20H), debug (offset 20H), service
// unused: 26-27, 2A, 31, 39-3A
const int iidMsiDebug                     = 0xC1020L;
const int iidMsiConfigurationDatabase     = 0xC1021L;
const int iidEnumMsiString                = 0xC1022L;
const int iidEnumMsiRecord                = 0xC1023L;
const int iidEnumMsiVolume                = 0xC1024L;
const int iidEnumMsiDialog                = 0xC1030L;
const int iidEnumMsiControl               = 0xC1032L;

const int iidMsiServerUnmarshal           = 0xC1035L;
const int iidMsiServerProxy               = 0xC103DL;
const int iidMsiServerAuto                = 0xC103FL;
const int iidMsiServicesAsService         = 0xC1028L;
const int iidMsiConfigManagerAsServer     = 0xC1029L;

const int iidMsiServicesDebug             = 0xC102BL;
const int iidMsiEngineDebug               = 0xC102EL;
const int iidMsiHandlerDebug              = 0xC102FL;
const int iidMsiDebugMalloc               = 0xC1037L;
const int iidMsiConfigManagerDebug        = 0xC103BL;
const int iidMsiServerDebug               = 0xC103CL;
const int iidMsiServicesAsServiceDebug    = 0xC102CL;
const int iidMsiConfigMgrAsServerDebug    = 0xC102DL;
const int iidMsiMessageRPCClass           = 0xC103EL;
const int iidMsiCustomAction              = 0xC1025L;
const int iidMsiCustomActionProxy         = 0xC102AL;
const int iidMsiRemoteCustomActionProxy   = 0xC1034L;
// Darwin 1.0 RemoteAPI IIDs.
//const int iidMsiRemoteAPI               = 0xC1026L;
//const int iidMsiRemoteAPIProxy          = 0xC1027L;
const int iidMsiRemoteAPI                 = 0xC1033L;
const int iidMsiRemoteAPIProxy            = 0xC1035L;
const int iidMsiCustomActionLocalConfig   = 0xC1038L;

// automation classes, implemented in MsiAuto(D,L).DLL
const int iidMsiAutoBase                  = 0xC1040L;
const int iidMsiAutoData                  = 0xC1041L;
const int iidMsiAutoString                = 0xC1042L;
const int iidMsiAutoRecord                = 0xC1043L;
const int iidMsiAutoVolume                = 0xC1044L;
const int iidMsiAutoPath                  = 0xC1045L;
const int iidMsiAutoFileCopy              = 0xC1046L;
const int iidMsiAutoRegKey                = 0xC1047L;
const int iidMsiAutoTable                 = 0xC1048L;
const int iidMsiAutoCursor                = 0xC1049L;
const int iidMsiAutoConfigurationDatabase = 0xC104AL;
const int iidMsiAutoServices              = 0xC104BL;
const int iidMsiAutoView                  = 0xC104CL;
const int iidMsiAutoDatabase              = 0xC104DL;
const int iidMsiAutoEngine                = 0xC104EL;
const int iidMsiAutoHandler               = 0xC104FL;
const int iidMsiAutoDialog                = 0xC1050L;
const int iidMsiAutoEvent                 = 0xC1051L;
const int iidMsiAutoControl               = 0xC1052L;
const int iidMsiAutoDialogHandler         = 0xC1053L;
const int iidMsiAutoStorage               = 0xC1054L;
const int iidMsiAutoStream                = 0xC1055L;
const int iidMsiAutoSummaryInfo           = 0xC1056L;
const int iidMsiAutoMalloc                = 0xC1057L;
const int iidMsiAutoSelectionManager      = 0xC1058L;
const int iidMsiAutoDirectoryManager      = 0xC1059L;
const int iidMsiAutoCostAdjuster          = 0xC105AL;
const int iidMsiAutoConfigurationManager  = 0xC105BL;
const int iidMsiAutoServer                = 0xC105CL;
const int iidMsiAutoMessage               = 0xC105DL;
const int iidMsiAutoExecute               = 0xC105EL;
const int iidMsiAutoFilePatch             = 0xC105FL;
const int iidEnumMsiAutoStringCollection  = 0xC1062L;
const int iidEnumMsiAutoRecordCollection  = 0xC1063L;
const int iidEnumMsiAutoVolumeCollection  = 0xC1064L;
const int iidEnumMsiAutoDialogCollection  = 0xC1070L;
const int iidEnumMsiAutoControlCollection = 0xC1072L;
const int iidMsiAuto                      = 0xC1060L;
const int iidMsiAutoDebug                 = 0xC1066L;
const int iidMsiAutoTypeLib               = 0xC107EL;

// storage format classes (IStorage SetClass, Stat)
const int iidMsiDatabaseStorage1          = 0xC1080L;
const int iidMsiTransformStorage1         = 0xC1081L;  // transform with raw stream names
const int iidMsiTransformStorage2         = 0xC1082L;  // transform with compressed stream names
const int iidMsiPatchStorage1             = 0xC1083L;
const int iidMsiDatabaseStorage2          = 0xC1084L;
const int iidMsiTransformStorageTemp      = 0xC1085L;  //!! temporary support for transforms with compressed stream names not marked as system
const int iidMsiPatchStorage2             = 0xC1086L;

// GUID assignments for API automation classes, reserved from MSI group 90-9F
const int iidMsiApiInstall                = 0xC1090L;  // FIXED, don't change
const int iidMsiApiInstallDebug           = 0xC1091L;
const int iidMsiApiTypeLib                = 0xC1092L;
const int iidMsiApiRecord                 = 0xC1093L;
const int iidMsiSystemAccess              = 0xC1094L;  // FIXED, don't change
const int iidMsiApiCollection             = 0xC1095L;
const int iidMsiRecordCollection          = 0xC1096L;
const int iidMsiApiUIPreview              = 0xC109AL;
const int iidMsiApiSummaryInfo            = 0xC109BL;
const int iidMsiApiView                   = 0xC109CL;
const int iidMsiApiDatabase               = 0xC109DL;
const int iidMsiApiEngine                 = 0xC109EL;
const int iidMsiApiFeatureInfo            = 0xC109FL;

// installer plug-in registration GUIDs (for SIP and Policy Provider)
const int iidMsiSigningSIPProvider        = 0xC10F1L;
const int iidMsiSigningPolicyProvider     = 0xC10F2L;
          
#define MSGUID(iid) {iid,0,0,{0xC0,0,0,0,0,0,0,0x46}}

#define GUID_IID_IUnknown                  MSGUID(iidUnknown)
#define GUID_IID_IClassFactory             MSGUID(iidClassFactory)
#define GUID_IID_IMalloc                   MSGUID(iidMalloc)
#define GUID_IID_IMarshal                  MSGUID(iidMarshal)
#define GUID_IID_ILockBytes                MSGUID(iidLockBytes)
#define GUID_IID_IStorage                  MSGUID(iidStorage)
#define GUID_IID_IStream                   MSGUID(iidStream)
#define GUID_IID_IDispatch                 MSGUID(iidDispatch)
#define GUID_IID_ITypeInfo                 MSGUID(iidTypeInfo)
#define GUID_IID_IEnumVARIANT              MSGUID(iidEnumVARIANT)
#define GUID_IID_IServerSecurity           MSGUID(iidServerSecurity)
#define GUID_IID_IMsiData                  MSGUID(iidMsiData)
#define GUID_IID_IMsiString                MSGUID(iidMsiString)
#define GUID_IID_IMsiRecord                MSGUID(iidMsiRecord)
#define GUID_IID_IMsiVolume                MSGUID(iidMsiVolume)
#define GUID_IID_IMsiPath                  MSGUID(iidMsiPath)
#define GUID_IID_IMsiFileCopy              MSGUID(iidMsiFileCopy)
#define GUID_IID_IMsiFilePatch             MSGUID(iidMsiFilePatch)
#define GUID_IID_IMsiCostAdjuster          MSGUID(iidMsiCostAdjuster)
#define GUID_IID_IMsiRegKey                MSGUID(iidMsiRegKey)
#define GUID_IID_IMsiTable                 MSGUID(iidMsiTable)
#define GUID_IID_IMsiCursor                MSGUID(iidMsiCursor)
#define GUID_IID_IMsiAuto                  MSGUID(iidMsiAuto)
#define GUID_IID_IMsiServices              MSGUID(iidMsiServices)
#define GUID_IID_IMsiView                  MSGUID(iidMsiView)
#define GUID_IID_IMsiDatabase              MSGUID(iidMsiDatabase)
#define GUID_IID_IMsiEngine                MSGUID(iidMsiEngine)
#define GUID_IID_IMsiHandler               MSGUID(iidMsiHandler)
#define GUID_IID_IMsiDialog                MSGUID(iidMsiDialog)
#define GUID_IID_IMsiEvent                 MSGUID(iidMsiEvent)
#define GUID_IID_IMsiControl               MSGUID(iidMsiControl)
#define GUID_IID_IMsiStorage               MSGUID(iidMsiStorage)
#define GUID_IID_IMsiStream                MSGUID(iidMsiStream)
#define GUID_IID_IMsiMemoryStream          MSGUID(iidMsiMemoryStream)
#define GUID_IID_IMsiMalloc                MSGUID(iidMsiMalloc)
#define GUID_IID_IMsiDebugMalloc           MSGUID(iidMsiDebugMalloc)
#define GUID_IID_IMsiDebug                 MSGUID(iidMsiDebug)
#define GUID_IID_IMsiSelectionManager      MSGUID(iidMsiSelectionManager)
#define GUID_IID_IMsiDirectoryManager      MSGUID(iidMsiDirectoryManager)
#define GUID_IID_IMsiFileCost              MSGUID(iidMsiFileCost)
#define GUID_IID_IMsiConfigurationManager  MSGUID(iidMsiConfigurationManager)
#define GUID_IID_IMsiServer                MSGUID(iidMsiServer)
#define GUID_IID_IMsiServerProxy           MSGUID(iidMsiServerProxy)
#define GUID_IID_IMsiServerDebug           MSGUID(iidMsiServer)
#define GUID_IID_IMsiExecute               MSGUID(iidMsiExecute)
#define GUID_IID_IMsiSummaryInfo           MSGUID(iidMsiSummaryInfo)
#define GUID_IID_IMsiConfigurationDatabase MSGUID(iidMsiConfigurationDatabase)
#define GUID_IID_IEnumMsiString            MSGUID(iidEnumMsiString)
#define GUID_IID_IEnumMsiRecord            MSGUID(iidEnumMsiRecord)
#define GUID_IID_IEnumMsiVolume            MSGUID(iidEnumMsiVolume)
#define GUID_IID_IEnumMsiDialog            MSGUID(iidEnumMsiDialog)
#define GUID_IID_IEnumMsiControl           MSGUID(iidEnumMsiControl)
#define GUID_IID_IMsiAutoDebug             MSGUID(iidMsiAutoDebug)
#define GUID_IID_IMsiServicesAsService      MSGUID(iidMsiServicesAsService)
#define GUID_IID_IMsiServicesAsServiceDebug MSGUID(iidMsiServicesAsServiceDebug)
#define GUID_IID_IMsiServicesDebug         MSGUID(iidMsiServicesDebug)
#define GUID_IID_IMsiEngineDebug           MSGUID(iidMsiEngineDebug)
#define GUID_IID_IMsiHandlerDebug          MSGUID(iidMsiHandlerDebug)
#define GUID_IID_IMsiConfigManagerAsServer  MSGUID(iidMsiConfigManagerAsServer)
#define GUID_IID_IMsiConfigMgrAsServerDebug MSGUID(iidMsiConfigMgrAsServerDebug)
#define GUID_IID_IMsiConfigManagerDebug    MSGUID(iidMsiConfigManagerDebug)
#define GUID_IID_IMsiServerAuto            MSGUID(iidMsiServerAuto)
#define GUID_IID_IMsiDialogHandler         MSGUID(iidMsiDialogHandler)
#define GUID_IID_IMsiMessage               MSGUID(iidMsiMessage)
#define GUID_LIBID_MsiAuto                 MSGUID(iidMsiAutoTypeLib)
#define GUID_LIBID_MsiServer               MSGUID(iidMsiServerTypeLib)
#define GUID_STGID_MsiDatabase1            MSGUID(iidMsiDatabaseStorage1)
#define GUID_STGID_MsiDatabase2            MSGUID(iidMsiDatabaseStorage2)
#define GUID_STGID_MsiDatabase             MSGUID(iidMsiDatabaseStorage2)
#define GUID_STGID_MsiTransform1           MSGUID(iidMsiTransformStorage1)
#define GUID_STGID_MsiTransform2           MSGUID(iidMsiTransformStorage2)
#define GUID_STGID_MsiTransform            MSGUID(iidMsiTransformStorage2)
#define GUID_STGID_MsiTransformTemp        MSGUID(iidMsiTransformStorageTemp)  //!! remove at 1.0 ship
#define GUID_STGID_MsiPatch                MSGUID(iidMsiPatchStorage2)
#define GUID_STGID_MsiPatch1               MSGUID(iidMsiPatchStorage1)
#define GUID_STGID_MsiPatch2               MSGUID(iidMsiPatchStorage2)

#define GUID_IID_IMsiServerUnmarshal       MSGUID(iidMsiServerUnmarshal)
#define GUID_IID_IMsiMessageRPCClass       MSGUID(iidMsiMessageRPCClass)
#define GUID_IID_IMsiCustomAction          MSGUID(iidMsiCustomAction)
#define GUID_IID_IMsiCustomActionProxy     MSGUID(iidMsiCustomActionProxy)
#define GUID_IID_IMsiRemoteAPI             MSGUID(iidMsiRemoteAPI)
#define GUID_IID_IMsiRemoteAPIProxy        MSGUID(iidMsiRemoteAPIProxy)
#define GUID_IID_IMsiCustomActionLocalConfig MSGUID(iidMsiCustomActionLocalConfig)

#define GUID_IID_MsiSigningPolicyProvider  MSGUID(iidMsiSigningPolicyProvider)
#define GUID_IID_MsiSigningSIPProvider     MSGUID(iidMsiSigningSIPProvider)

//____________________________________________________________________________
//
// GUID instantiation CComPointer typedefs
//____________________________________________________________________________

extern "C" const GUID IID_IMsiServices;
extern "C" const GUID IID_IMsiRecord;
extern "C" const GUID IID_IMsiRegKey;
extern "C" const GUID IID_IMsiPath;
extern "C" const GUID IID_IMsiFileCopy;
extern "C" const GUID IID_IMsiFilePatch;
extern "C" const GUID IID_IMsiVolume;
extern "C" const GUID IID_IEnumMsiVolume;
extern "C" const GUID IID_IEnumMsiString;
extern "C" const GUID IID_IMsiStream;
extern "C" const GUID IID_IMsiMemoryStream;
extern "C" const GUID IID_IMsiStorage;
extern "C" const GUID IID_IMsiSummaryInfo;
extern "C" const GUID IID_IMsiCursor;
extern "C" const GUID IID_IMsiTable;
extern "C" const GUID IID_IMsiDatabase;
extern "C" const GUID IID_IMsiView;
extern "C" const GUID IID_IMsiEngine;
extern "C" const GUID IID_IMsiSelectionManager;
extern "C" const GUID IID_IMsiDirectoryManager;
extern "C" const GUID IID_IMsiCostAdjuster;
extern "C" const GUID IID_IMsiHandler;
extern "C" const GUID IID_IMsiDialog;
extern "C" const GUID IID_IMsiEvent;
extern "C" const GUID IID_IMsiControl;
extern "C" const GUID IID_IMsiConfigurationManager;
extern "C" const GUID IID_IMsiExecute;
extern "C" const GUID IID_IMsiMessage;
extern "C" const GUID IID_IMsiCustomAction;
extern "C" const GUID IID_IMsiServer;
extern "C" const GUID IID_IMsiServerUnmarshal;
extern "C" const GUID IID_IMsiCustomActionLocalConfig;

typedef CComPointer<const IMsiData>       PMsiData;  // breaks if a non-const typedef defined for IMsiData
typedef CComPointer<IMsiServices>         PMsiServices;
typedef CComPointer<IMsiRecord>           PMsiRecord;
typedef CComPointer<IAssemblyCacheItem>   PAssemblyCacheItem;
typedef CComPointer<IAssemblyName>        PAssemblyName;
typedef CComPointer<IAssemblyCache>       PAssemblyCache;
typedef CComPointer<IStream>              PStream;
typedef CComPointer<IStorage>             PStorage;


class IMsiRegKey;       typedef CComPointer<IMsiRegKey>           PMsiRegKey;
class IMsiPath;         typedef CComPointer<IMsiPath>             PMsiPath;
class IMsiFileCopy;     typedef CComPointer<IMsiFileCopy>         PMsiFileCopy;
class IMsiFilePatch;    typedef CComPointer<IMsiFilePatch>        PMsiFilePatch;
class IMsiVolume;       typedef CComPointer<IMsiVolume>           PMsiVolume;
class IEnumMsiVolume;   typedef CComPointer<IEnumMsiVolume>       PEnumMsiVolume;
class IEnumMsiString;   typedef CComPointer<IEnumMsiString>       PEnumMsiString;
class IEnumMsiRecord;   typedef CComPointer<IEnumMsiRecord>       PEnumMsiRecord;
class IMsiStream;       typedef CComPointer<IMsiStream>           PMsiStream;
class IMsiMemoryStream; typedef CComPointer<IMsiMemoryStream>     PMsiMemoryStream;
class IMsiStorage;      typedef CComPointer<IMsiStorage>          PMsiStorage;
class IMsiSummaryInfo;  typedef CComPointer<IMsiSummaryInfo>      PMsiSummaryInfo;
class IMsiCursor;       typedef CComPointer<IMsiCursor>           PMsiCursor;
class IMsiTable;        typedef CComPointer<IMsiTable>            PMsiTable;
class IMsiDatabase;     typedef CComPointer<IMsiDatabase>         PMsiDatabase;
class IMsiView;         typedef CComPointer<IMsiView>             PMsiView;
class IMsiEngine;       typedef CComPointer<IMsiEngine>           PMsiEngine;
class IMsiSelectionManager; typedef CComPointer<IMsiSelectionManager> PMsiSelectionManager;
class IMsiDirectoryManager; typedef CComPointer<IMsiDirectoryManager> PMsiDirectoryManager;
class IMsiCostAdjuster; typedef CComPointer<IMsiCostAdjuster>     PMsiCostAdjuster;
class IMsiHandler;      typedef CComPointer<IMsiHandler>          PMsiHandler;
class IMsiDialogHandler;typedef CComPointer<IMsiDialogHandler>    PMsiDialogHandler;
class IMsiDialog;       typedef CComPointer<IMsiDialog>           PMsiDialog;
class IMsiEvent;        typedef CComPointer<IMsiEvent>            PMsiEvent;
class IMsiControl;      typedef CComPointer<IMsiControl>          PMsiControl;
class IMsiConfigurationManager; typedef CComPointer<IMsiConfigurationManager> PMsiConfigurationManager;
class IMsiExecute;      typedef CComPointer<IMsiExecute>          PMsiExecute;
struct IMsiMessage;     typedef CComPointer<IMsiMessage>          PMsiMessage;
struct IMsiServer;      typedef CComPointer<IMsiServer>           PMsiServer;
struct IMsiCustomAction; typedef CComPointer<IMsiCustomAction>    PMsiCustomAction;
struct IMsiRemoteAPI; typedef CComPointer<IMsiRemoteAPI>          PMsiRemoteAPI;

//____________________________________________________________________________
//
// Internal Action table link and function pointer definition
//____________________________________________________________________________

enum iesEnum;  // defined in engine.h

// action function pointer definition
typedef iesEnum (*PAction)(IMsiEngine& riEngine);

// Action registration object, to put action in modules action table
struct CActionEntry
{
public:
        static const CActionEntry* Find(const ICHAR* szName);
        const ICHAR*  m_szName;
		bool          m_fSafeInRestrictedEngine;
        PAction       m_pfAction;
};

extern const CActionEntry rgcae[];

enum ixoEnum;   // defined in engine.h

enum ielfEnum  // bit flags for file copy routines
{
	ielfNoElevate     = 0,
	ielfElevateSource = 1 << 0,
	ielfElevateDest   = 1 << 1,
	ielfBypassSFC     = 1 << 2,
};



//____________________________________________________________________________
//
// Custom action types - combination of executable type, code source, and options flags
//____________________________________________________________________________

// executable types
const int icaDll          = msidbCustomActionTypeDll; // Target = entry point name  (icaDirectory not supported)
const int icaExe          = msidbCustomActionTypeExe; // Target = command line args (include EXE name if icaDirectory)
const int icaTextData     = msidbCustomActionTypeTextData; // Target = text string to be formatted and set into property
const int icaReserved     = 4; // Target = (reserved for Jave code, unimplemented)
const int icaJScript      = msidbCustomActionTypeJScript; // Target = entry point name, null if none to call
const int icaVBScript     = msidbCustomActionTypeVBScript; // Target = entry point name, null if none to call
const int icaInstall      = msidbCustomActionTypeInstall; // Target = property list for nested engine initialization

const int icaTypeMask     = icaDll | icaExe | icaTextData | icaReserved |  // mask for executable type
                                                                         icaJScript | icaVBScript | icaInstall;

// source of code
const int icaBinaryData   = msidbCustomActionTypeBinaryData; // Source = Binary.Name, data stored in stream
const int icaSourceFile   = msidbCustomActionTypeSourceFile; // Source = File.File, file part of installation
const int icaDirectory    = msidbCustomActionTypeDirectory; // Source = Directory.Directory, folder containing existing file
const int icaProperty     = msidbCustomActionTypeProperty; // Source = Property.Property, full path to executable

const int icaSourceMask   = icaBinaryData | icaSourceFile |  // mask for source location type
                                                                         icaDirectory | icaProperty;

// return processing             // default is syncronous execution, process return code
const int icaContinue     = msidbCustomActionTypeContinue; // ignore action return status, continue running
const int icaAsync        = msidbCustomActionTypeAsync; // run asynchronously

// execution pass flags             // default is execute whenever sequenced
const int icaFirstSequence  = msidbCustomActionTypeFirstSequence; // skip if UI sequence already run
const int icaOncePerProcess = msidbCustomActionTypeOncePerProcess; // skip if UI sequence already run in same process
const int icaClientRepeat   = msidbCustomActionTypeClientRepeat; // run on client only if UI already run on client
const int icaInScript       = msidbCustomActionTypeInScript; // queue for execution within script
const int icaRollback       = msidbCustomActionTypeRollback; // in conjunction with icaInScript: queue in Rollback script
const int icaCommit         = msidbCustomActionTypeCommit; // in conjunction with icaInScript: run Commit ops from script on success
const int icaPassMask       = icaFirstSequence | icaOncePerProcess | icaClientRepeat | icaInScript |
                                                                                icaRollback | icaCommit; // 3 bits for execution phase

// security context flag, default to impersonate as user, valid only if icaInScript
const int icaNoImpersonate  = msidbCustomActionTypeNoImpersonate; // no impersonation, run in system context
const int icaTSAware        = msidbCustomActionTypeTSAware;       // run in user context even on per-machine TS installs

// script process type bit flag
const int ica64BitScript    = msidbCustomActionType64BitScript;       // script 64bit flag

// debugging flags
const int icaDebugBreak = 1 << 16;  // DebugBreak before custom action call (set internally)
// not translate flag, used by self reg to make the custom action handler return the result as is to execute.cpp
const int icaNoTranslate = 1 << 17; // set internally
// causes us to set the thread token of a custom action EXE to the user's token; used by self-reg
const int icaSetThreadToken = 1 << 18; // set internally


//____________________________________________________________________________
//
// Component name definitions
//____________________________________________________________________________

#define MSI_KERNEL_NAME     TEXT("Msi.dll")
#define MSI_HANDLER_NAME    TEXT("MsiHnd.dll")
#define MSI_AUTOMATION_NAME TEXT("MsiAuto.dll")
#define MSI_SERVER_NAME     TEXT("MsiExec.exe")
#define MSI_MESSAGES_NAME   TEXT("MsiMsg.dll")

//____________________________________________________________________________
//
// Self-registration module definitions
//____________________________________________________________________________

#define SZ_PROGID_IMsiServices      TEXT("Msi.Services")
#define SZ_PROGID_IMsiEngine        TEXT("Msi.Engine")
#define SZ_PROGID_IMsiHandler       TEXT("Msi.Handler")
#define SZ_PROGID_IMsiAuto          TEXT("Msi.Automation")
#define SZ_PROGID_IMsiConfiguration TEXT("Msi.Configuration")
#define SZ_PROGID_IMsiServer        TEXT("IMsiServer")
#define SZ_PROGID_IMsiMessage       TEXT("IMsiMessage")
#define SZ_PROGID_IMsiExecute       TEXT("Msi.Execute")
#define SZ_PROGID_IMsiConfigurationDatabase TEXT("Msi.ConfigurationDatabase")

#define SZ_DESC_IMsiServices        TEXT("Msi services")
#define SZ_DESC_IMsiEngine          TEXT("Msi install engine")
#define SZ_DESC_IMsiHandler         TEXT("Msi UI handler")
#define SZ_DESC_IMsiAuto            TEXT("Msi automation wrapper")
#define SZ_DESC_IMsiConfiguration   TEXT("Msi configuration manager")
#define SZ_DESC_IMsiServer          TEXT("Msi install server")
#define SZ_DESC_IMsiMessage         TEXT("Msi message handler")
#define SZ_DESC_IMsiExecute         TEXT("Msi script executor")
#define SZ_DESC_IMsiConfigurationDatabase TEXT("Msi configuration database")
#define SZ_DESC_IMsiCustomAction    TEXT("Msi custom action server")
#define SZ_DESC_IMsiRemoteAPI       TEXT("Msi remote API")

#if defined(DEBUG)
#define SZ_PROGID_IMsiServicesDebug TEXT("Msi.ServicesDebug")
#define SZ_PROGID_IMsiEngineDebug   TEXT("Msi.EngineDebug")
#define SZ_PROGID_IMsiHandlerDebug  TEXT("Msi.HandlerDebug")
#define SZ_PROGID_IMsiAutoDebug     TEXT("Msi.AutoDebug")
#define SZ_PROGID_IMsiConfigDebug   TEXT("Msi.ConfigurationManagerDebug")
#define SZ_DESC_IMsiServicesDebug   TEXT("Msi Debug services")
#define SZ_DESC_IMsiEngineDebug     TEXT("Msi Debug engine")
#define SZ_DESC_IMsiHandlerDebug    TEXT("Msi Debug UI handler")
#define SZ_DESC_IMsiAutoDebug       TEXT("Msi Debug automation wrapper")
#define SZ_DESC_IMsiConfigDebug     TEXT("Msi Debug configuration manager")
#define SZ_DESC_IMsiServerDebug     TEXT("Msi Debug install server")
#endif
#define SZ_PROGID_IMsiMessageUnmarshal TEXT("Msi.MessageUnmarshal")
#define SZ_DESC_IMsiMessageUnmarshal   TEXT("Msi message unmarshal")

#define SZ_PROGID_IMsiServerUnmarshal  TEXT("Msi.ServerUnmarshal")
#define SZ_DESC_IMsiServerUnmarshal    TEXT("Msi server unmarshal")

#ifdef WIN
#define Win(x) x
#define WinMac(x, y) x
#define Mac(x)
#else
#define Win(x)
#define WinMac(x, y) y
#define Mac(x) x
#endif //WIN

#ifdef DEBUG
#define Debug(x) x
#else
#define Debug(x)
#endif //DEBUG

//____________________________________________________________________________
//
// Macros to get calling address from calling arguments
//____________________________________________________________________________

#if defined(_X86_)
#define GetCallingAddr(plAddr, param1) unsigned long *plAddr; \
                                                                plAddr = ((unsigned long *)(&plAddr) + 2);
#define GetCallingAddrMember(plAddr, param1) unsigned long *plAddr; \
                                                                plAddr = ((unsigned long *)(&plAddr) + 2);
#define GetCallingAddr2(plAddr, param1) unsigned long *plAddr; \
                                                                plAddr = ((unsigned long *)(&param1) - 1);
#else
#if defined(_M_MPPC)
#define GetCallingAddr(plAddr, param1) unsigned long *plAddr;  \
                                                                plAddr = (((unsigned long *)(&param1)) - 4);

#define GetCallingAddrMember(plAddr, param1) unsigned long *plAddr;  \
                                                                plAddr = (((unsigned long *)(&param1)) - 5);
#define GetCallingAddr2(plAddr, param1) unsigned long *plAddr; \
                                                                plAddr = ((unsigned long *)(&param1) - 1);
#else
#define GetCallingAddr(plAddr, param1) unsigned long plZero = 0; unsigned long *plAddr = &plZero;
#define GetCallingAddrMember(plAddr, param1) unsigned long plZero = 0; unsigned long *plAddr = &plZero;
#define GetCallingAddr2(plAddr, param1) unsigned long plZero = 0; unsigned long *plAddr = &plZero;
#endif //_M_MPPC
#endif //_X86_

//____________________________________________________________________________
//
// Miscellaneous common internal definitions
//____________________________________________________________________________

// private properties
#define IPROPNAME_VERSIONMSI                 TEXT("VersionMsi")        // Msi module version
#define IPROPNAME_VERSIONHANDLER             TEXT("VersionHandler")    // handler module version
#define IPROPNAME_SOURCEDIRPRODUCT           TEXT("SourcedirProduct")
#define IPROPNAME_SECONDSEQUENCE             TEXT("SECONDSEQUENCE")
#define IPROPNAME_ORIGINALDATABASE           TEXT("OriginalDatabase")
#define IPROPNAME_MIGRATE                    TEXT("MIGRATE")
#define IPROPNAME_DISABLEMEDIA               TEXT("DISABLEMEDIA")      // if this property is set we don't write media information
#define IPROPNAME_MEDIAPACKAGEPATH           TEXT("MEDIAPACKAGEPATH") // relative path to the MSI on the media
#define IPROPNAME_PACKAGECODE                TEXT("PackageCode")    // unique string GUID for package
#define IPROPNAME_CCPTRIGGER                 TEXT("CCPTrigger")        //?? does this need to be exposed?
#define IPROPNAME_VERSIONDATABASE            TEXT("VersionDatabase")   // database version
#define IPROPNAME_UILEVEL                    TEXT("UILevel")           // the UI Level for the current install
#define IPROPNAME_MEDIASOURCEDIR             TEXT("MediaSourceDir")    // set if our source is media; used by the UI
#define IPROPNAME_PARENTPRODUCTCODE          TEXT("ParentProductCode") // set if we're a child install
#define IPROPNAME_PARENTORIGINALDATABASE     TEXT("ParentOriginalDatabase")  // set if we're a child install
#define IPROPNAME_CURRENTMEDIAVOLUMELABEL    TEXT("CURRENTMEDIAVOLUMELABEL")
#define IPROPNAME_VERSION95                  TEXT("Version95")
#define IPROPNAME_CURRENTDIRECTORY           TEXT("CURRENTDIRECTORY")
#define IPROPNAME_PATCHEDPRODUCTCODE         TEXT("PatchedProductCode")       // set if patching to patched product's product code
#define IPROPNAME_PATCHEDPRODUCTSOURCELIST   TEXT("PatchedProductSourceList") // set if patching and patched product's source list has been compiled
#define IPROPNAME_PRODUCTTOBEREGISTERED      TEXT("ProductToBeRegistered")  // set if product registered (or will be after current script is executed)
#define IPROPNAME_RECACHETRANSFORMS          TEXT("RecacheTransforms")
#define IPROPNAME_CLIENTUILEVEL              TEXT("CLIENTUILEVEL")
#define IPROPNAME_PACKAGECODE_CHANGING       TEXT("PackagecodeChanging")
#define IPROPNAME_UPGRADINGPRODUCTCODE       TEXT("UPGRADINGPRODUCTCODE") // product code of upgrading product
#define IPROPNAME_CLIENTPROCESSID            TEXT("CLIENTPROCESSID") // the client process id - used by FilesInUse
#define IPROPNAME_ODBCREINSTALL              TEXT("ODBCREINSTALL")   // internal communication to manage ODBC ref counts
#define IPROPNAME_RUNONCEENTRY               TEXT("RUNONCEENTRY")    // the RunOnce registry value name written by ForceReboot
#define IPROPNAME_DATABASE                   TEXT("DATABASE")         // product database to open - SET BY INSTALLER
#define IPROPNAME_ALLOWSUSPEND               TEXT("ALLOWSUSPEND")     // allow suspend instead of rollback
#define IPROPNAME_SCRIPTFILE                 TEXT("SCRIPTFILE")
#define IPROPNAME_DISKSERIAL                 TEXT("DiskSerial")       // CD serial number // OBSOLETE: TO BE REMOVED
#define IPROPNAME_QFEUPGRADE                 TEXT("QFEUpgrade")       // set when upgrading existing install with a new package or patch
#define IPROPNAME_UNREG_SOURCERESFAILED      TEXT("SourceResFailedInUnreg")  // set by selfreg during uninstall to prevent rerunning source resolution stuff
#define IPROPNAME_WIN9XPROFILESENABLED       TEXT("WIN9XPROFILESENABLED")  // on Win9X and profiles are enabled
#define IPROPNAME_FASTOEMINSTALL             TEXT("FASTOEM")          // bare-bone OEM install: no progress, files moved within same drive, trimmed down InstallValidate....


// obsolete properties set for legacy support
#define IPROPNAME_SOURCEDIROLD               TEXT("SOURCEDIR")        // source location
#define IPROPNAME_GPT_SUPPORT                  TEXT("GPTSupport")
#define IPROPNAME_RESUMEOLD                  TEXT("Resume")



const ICHAR chDirSep = '\\';
const ICHAR szDirSep[] = TEXT("\\");

// MSI format string delimiters
const ICHAR chFormatEscape = '\\';

// URL separators
const ICHAR chURLSep = '/';
const ICHAR szURLSep[] = TEXT("/");

// for the registry keys
const ICHAR chRegSep = '\\';
const ICHAR szRegSep[] = TEXT("\\");

// strings that increment/ decrement the integer registry value
const ICHAR szIncrementValue[] = TEXT("#+");
const ICHAR szDecrementValue[] = TEXT("#-");

// summary information properties delimiters
const ICHAR ISUMMARY_DELIMITER(';');
const ICHAR ILANGUAGE_DELIMITER(',');
const ICHAR IPLATFORM_DELIMITER(',');

// file extensions
const ICHAR szDatabaseExtension[]  = TEXT("msi");
const ICHAR szTransformExtension[] = TEXT("mst");
const ICHAR szPatchExtension[]     = TEXT("msp");

// URL maximum length...
const int cchMaxUrlLength = 1024;

// Maximum number of chars in the string representation of an int including null
// 1 for -/+, 11 for digits and 1 for null
const int cchMaxIntLength = 12;

enum ibtBinaryType {
    ibtUndefined = -2,
    ibtCommon = -1,
    ibt32bit = 0,
    ibt64bit = 1,
};

// short|long filename/filepath separator
const ICHAR chFileNameSeparator = '|';

//____________________________________________________________________________
//
// Routines to set access g_iTestFlags from _MSI_TEST environment variable
//____________________________________________________________________________

bool SetTestFlags();  // call from module initialize to set bit flags from string

bool GetTestFlag(int chTest);  // uses low 5 bits of character (case insensitive)

// 'A' - check memory on alloc
// 'D' - dump feature cache to DEBUGMON
// 'E' - enable fatal error simulation via custom action exit codes
// 'F  - check memory on free
// 'I  - no memory preflight init
// 'K  - keep memory allocations
// 'M  - log memory allocations
// 'O  - Use object pool on 32 bit machines
// 'R' - register internal automation interfaces for use with MsiAuto.dll
// 'T  - disable separate UI thread - no UI refresh or fatal error handling
// 'V' - verbose DEBUGMON output - DEBUG ONLY
// 'W' - simulate Win9x (currently only for API call implementation)
// 'X' - disable unhandled exception handler - crash at your own risk
// '?B - always respect enable browse
// '?M - manual source validation
// 'C' - use %_MSICACHE% as folder for cached databases - DEBUG ONLY!
// 'J' - in DEBUG builds always remote API calls that get remoted in 64-bit builds
// 'P' - dump the policy provider structure to a file in the Trust Provider

//____________________________________________________________________________
//
// Global functions
//____________________________________________________________________________

extern bool __stdcall TestAndSet(int* pi);

//__________________________________
//
// Internet functions
//__________________________________

// UrlCombine and UrlCanonicalize from shlwapi are now used.  The wininet versions
// InternetCombineUrl and InternetCanonicalizeUrl were simply wrappers around these
// UrlCombine and UrlCanonicalize is available on Win98 or greater and Win2K and greater
// or any platform with at least IE 5.0.  Switching to the shlwapi versions given that
// winhttp and wininet header files do not play well together

// internal MSI defines for use -- these are then mapped to the correct shlwapi equivalents
// current values are equivalent to wininet values for which they represent
//
// flags for InternetCanonicalizeUrl() and InternetCombineUrl()
//

/*
	wininet.h

#define ICU_NO_ENCODE          0x20000000 // Don't convert unsafe characters to escape sequence
#define ICU_DECODE             0x10000000 // Convert %XX escape sequences to characters
#define ICU_NO_META            0x08000000 // Don't convert .. etc. meta path sequences
#define ICU_ENCODE_SPACES_ONLY 0x04000000 // Encode spaces only
#define ICU_BROWSER_MODE       0x02000000 // Special encode/decode rules for browser
#define ICU_ENCODE_PERCENT     0x00001000 // Encode any percent (ASCII25)signs encountered, default is to not encode percent.

*/

const DWORD dwMsiInternetNoEncode         = 0x20000000; // ICU_NO_ENCODE
const DWORD dwMsiInternetDecode           = 0x10000000; // ICU_DECODE
const DWORD dwMsiInternetNoMeta           = 0x08000000; // ICU_NO_META
const DWORD dwMsiInternetEncodeSpacesOnly = 0x04000000; // ICU_ENCODE_SPACES_ONLY
const DWORD dwMsiInternetBrowserMode      = 0x02000000; // ICU_BROWSER_MODE
const DWORD dwMsiInternetEncodePercent    = 0x00001000; // ICU_ENCODE_PERCENT

BOOL MsiCombineUrl(
    IN LPCTSTR lpszBaseUrl,
    IN LPCTSTR lpszRelativeUrl,
    OUT LPTSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags);

BOOL MsiCanonicalizeUrl(
        LPCTSTR lpszUrl,
        OUT LPTSTR lpszBuffer,
        IN OUT LPDWORD lpdwBufferLength,
        IN DWORD dwFlags);

bool IsURL(const ICHAR* szPath, bool& fFileUrl);

bool MsiConvertFileUrlToFilePath(
	IN LPCTSTR pszFileUrl,
	OUT LPTSTR pszPath,
	IN OUT LPDWORD pcchPath,
	IN DWORD dwFlags);


//__________________________________
//
// security functions
//__________________________________

bool          StartImpersonating();
void          StopImpersonating(bool fSaveLastError=true);
bool          IsImpersonating(bool fStrict=false);

DWORD         GetCurrentUserStringSID(const IMsiString*& rpistrSid);
DWORD         GetLocalSystemSID(char** pSid);
DWORD         GetAdminSID(char** pSid);

// opens a temp file in the config data folder, and locks it down solidly.
HANDLE        OpenSecuredTempFile(bool fHidden, ICHAR* szTempFile);


SECURITY_INFORMATION GetSecurityInformation(PSECURITY_DESCRIPTOR pSD);

// common way to check for privileged ownership of objects.
LONG          FIsKeySystemOrAdminOwned(HKEY hKey, bool &fResult);
bool          FIsSecurityDescriptorSystemOrAdminOwned(PSECURITY_DESCRIPTOR pSD);

bool          FVolumeRequiresImpersonation(IMsiVolume& riVolume);

bool          IsClientPrivileged(const ICHAR* szPrivilege);
bool          IsAdmin(void);
bool          RunningAsLocalSystem();
bool          SetInteractiveSynchronizeRights(bool fEnable);

// helper function for generating and applying the "default" security descriptors to
// configuration data.
DWORD         GetLockdownSecurityAttributes(SECURITY_ATTRIBUTES &SA, bool fHidden);
DWORD         GetSecureSecurityDescriptor(char** pSecurityDescriptor, Bool fAllowDelete=fTrue, bool fHidden=false);
DWORD         GetUsageKeySecurityDescriptor(char** pSecurityDescriptor);
IMsiRecord*   GetSecureSecurityDescriptor(IMsiServices& riServices, IMsiStream*& rpiStream, bool fHidden=false);
IMsiRecord*   LockdownPath(const ICHAR* szLocation, bool fHidden);

// Default security descriptor buffer.  Used with CTempBuffers, must resize if needed.
const int cbDefaultSD = 512;

const int MAX_PRIVILEGES_ADJUSTED = 3;
// AdjustTokenPrivileges can take an array of privilege names, up to MAX_PRIVILEGES_ADJUSTED.
extern bool AdjustTokenPrivileges(const ICHAR** szPrivileges, const int cPrivileges, bool fAcquire);

enum itkpEnum
{

	itkpSD_READ = 0,                  // SE_SECURITY_NAME
	itkpSD_WRITE = 1,                 // SE_RESTORE_NAME and SE_TAKE_OWNERSHIP_NAME
	itkpLastEnum = itkpSD_WRITE,
	itkpNO_CHANGE = itkpLastEnum + 1, // don't ref count this guy
};
const int cRefCountedTokenPrivileges = itkpLastEnum+1;

typedef struct tagTokenPrivilegesRefCount {
	int iCount;
	TOKEN_PRIVILEGES ptkpOld[MAX_PRIVILEGES_ADJUSTED];
	DWORD cbtkpOldReturned;
} TokenPrivilegesRefCount, *PTokenPrivilegesRefCount;

extern TokenPrivilegesRefCount g_pTokenPrivilegesRefCount[];

extern bool RefCountedTokenPrivilegesCore(itkpEnum itkpPriv, bool fAcquire, DWORD cbtkpOld, PTOKEN_PRIVILEGES ptkpOld, DWORD* pcbtkpOldReturned);

// check to see if your privilege is ref-counted before using the absolute versions.
// Currently SE_RESTORE_NAME, SE_TAKE_OWNERSHIP_NAME and SE_SECURITY_NAME are counted.
extern bool AcquireRefCountedTokenPrivileges(itkpEnum itkpPriv);
extern bool DisableRefCountedTokenPrivileges(itkpEnum itkpPriv);

extern bool AcquireTokenPrivilege(const ICHAR* szPrivilege);
extern bool DisableTokenPrivilege(const ICHAR* szPrivilege);

// CRefCountedTokenPrivileges works similarly to CImpersonate or CElevate.  Provides
// an automatic scoping for various token privileges.

class CRefCountedTokenPrivileges
{	
  protected:
        VOID Initialize(itkpEnum itkpPrivileges);
	itkpEnum m_itkpPrivileges;                          // which privilege set this object is tracking
	
  public:
	CRefCountedTokenPrivileges(itkpEnum itkpPrivileges)  { Initialize(itkpPrivileges); }

	// Welcome to the wonderful world of boolean typing that Darwin uses.
	CRefCountedTokenPrivileges(itkpEnum itkpPrivileges, bool fConditional) { Initialize((fConditional) ? itkpPrivileges : itkpNO_CHANGE); }
	CRefCountedTokenPrivileges(itkpEnum itkpPrivileges, Bool fConditional) { Initialize((fConditional) ? itkpPrivileges : itkpNO_CHANGE); }
	CRefCountedTokenPrivileges(itkpEnum itkpPrivileges, BOOL fConditional) { Initialize((fConditional) ? itkpPrivileges : itkpNO_CHANGE); }

	~CRefCountedTokenPrivileges() { if (itkpNO_CHANGE != m_itkpPrivileges) DisableRefCountedTokenPrivileges(m_itkpPrivileges); }

	itkpEnum PrivilegesHeld() { return m_itkpPrivileges; }
};

// attempts to open file without special elevation/impersonation or security.  If successful, elevates to apply special 
// security.  
HANDLE MsiCreateFileWithUserAccessCheck(const ICHAR* szDestFullPath, 
								 /*dwDesiredAccess calculated internally,*/ 
								 PSECURITY_ATTRIBUTES pSecurityAttributes,
								 DWORD dwFlagsAndAttributes,
								 bool fImpersonateDest);

//__________________________________
//
// utility functions
//__________________________________

MsiDate GetCurrentDateTime();

bool IsTokenOnTerminalServerConsole(HANDLE hToken);

void GetEnvironmentStrings(const ICHAR* sz,CTempBufferRef<ICHAR>& rgch);
void GetEnvironmentVariable(const ICHAR* sz,CTempBufferRef<ICHAR>& rgch);

void  MsiDisableTimeout();
void  MsiEnableTimeout();
void  MsiSuppressTimeout();

HANDLE CreateDiskPromptMutex();
void CloseDiskPromptMutex(HANDLE hMutex);

void MsiRegisterSysHandle(HANDLE handle);
Bool MsiCloseSysHandle(HANDLE handle);
Bool MsiCloseAllSysHandles();
Bool MsiCloseUnregisteredSysHandle(HANDLE handle);

Bool FTestNoPowerdown();

enum iddSupport{
        iddOLE      = 0,
        iddShell    = 1, // smart shell
};
Bool IsDarwinDescriptorSupported(iddSupport iddType);

enum ifvsEnum{
        ifvsValid         = 0, // filename is valid
        ifvsReservedChar  = 1, // filename contains reserved characters
        ifvsReservedWords = 2, // filename contains reserved words
        ifvsInvalidLength = 3, // invalid length for filename
        ifvsSFNFormat     = 4, // bad short filename format (not follow 8.3)
        ifvsLFNFormat     = 5, // bad long filename format (all periods)
};
ifvsEnum CheckFilename(const ICHAR* szFileName, Bool fLFN);

Bool GetLangIDArrayFromIDString(const ICHAR* szLangIDs, unsigned short rgw[], int iSize, int& riLangCount);

DWORD WINAPI MsiGetFileAttributes(const ICHAR* szFileName);

// StringConcatenate - copies strings to buffer - replaces StringCchPrintf when sum of strings > 1024
// NOTE: can add more versions of this function as needed
int StringConcatenate(CAPITempBufferRef<ICHAR>& rgchBuffer, const ICHAR* sz1, const ICHAR* sz2,
                                                         const ICHAR* sz3, const ICHAR* sz4);

#define MinimumPlatform(fWin9X, minMajor, minMinor) ((g_fWin9X == fWin9X) && ((minMajor < g_iMajorVersion) || ((minMajor == g_iMajorVersion) && (minMinor <= g_iMinorVersion))))

// make sure that the help file gets update as new platform values are added.
#define MinimumPlatformWindowsDotNETServer()  MinimumPlatform(false, 5, 2)
#define MinimumPlatformWindowsNT51() MinimumPlatform(false, 5, 1)
#define MinimumPlatformWindows2000() MinimumPlatform(false, 5, 0)
#define MinimumPlatformWindowsNT4()  MinimumPlatform(false, 4, 0)

#define MinimumPlatformMillennium()  MinimumPlatform(true,  4, 90)
#define MinimumPlatformWindows98()   MinimumPlatform(true,  4, 10)
#define MinimumPlatformWindows95()   MinimumPlatform(true,  4, 0)

//
// Downlevel platform compatible TOKEN_ALL_ACCESS
// The MSI binaries are compiled using the latest headers. In these headers,
// TOKEN_ALL_ACCESS includes TOKEN_ADJUST_SESSIONID which is not recognized
// on NT4.0. So if TOKEN_ALL_ACCESS is passed in as the desired access on NT4.0
// platforms, it returns ACCESS_DENIED. So for NT4.0, we must use
// TOKEN_ALL_ACCESS_P.
//
#define MSI_TOKEN_ALL_ACCESS ((g_fWin9X || g_iMajorVersion >= 5) ? TOKEN_ALL_ACCESS : TOKEN_ALL_ACCESS_P)


//__________________________________________________________________________
//
// Global PostError routines
//
//   PostError:  create error record and report error to event log
//   PostRecord: create error record but don't report error to event log
//
//__________________________________________________________________________

IMsiRecord* PostError(IErrorCode iErr);
IMsiRecord* PostError(IErrorCode iErr, int i);
IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr);
IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr, int i);
IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr, int i1, int i2);
IMsiRecord* PostError(IErrorCode iErr, int i, const IMsiString& ristr1, const IMsiString& ristr2);
IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz);
IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz1, const ICHAR* sz2);
IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz1, const ICHAR* sz2, const ICHAR* sz3);
IMsiRecord* PostError(IErrorCode iErr, int i, const ICHAR* sz);
IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz, int i);
IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz1, const ICHAR* sz2, int i);
IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz1, const ICHAR* sz2, int i, const ICHAR* sz3);
IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr1, const IMsiString& ristr2,
                                                         int i1);
IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr1, const IMsiString& ristr2,
                                                         int i1, int i2);
IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr1, const IMsiString& ristr2,
                                                         const IMsiString& ristr3, const IMsiString& ristr4);
IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr1, const IMsiString& ristr2);
IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr1, const IMsiString& ristr2,
                                                         const IMsiString& ristr3);
IMsiRecord* PostError(IErrorCode iErr, int i1, const ICHAR* sz1, int i2, const ICHAR* sz2,
                                                         const ICHAR* sz3);
IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz1, int i, const ICHAR* sz2, const ICHAR* sz3, const ICHAR* sz4);
IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz1, const ICHAR* sz2, const ICHAR* sz3, const ICHAR* sz4, const ICHAR* sz5);


IMsiRecord* PostRecord(IErrorCode iErr);
IMsiRecord* PostRecord(IErrorCode iErr, int i);


//__________________________________________________________________________
//
// class CHandle
//
// Wrapper for a HANDLE to ensure proper disposal of the HANDLE
// with ::CloseHandle when the HANDLE goes out of scope or is reassigned.
//
// This class handles registration and unregistration of handles using
// MsiRegisterSysHandle and MsiCloseSysHandle
//__________________________________________________________________________

class CHandle
{
 public:
   CHandle() { m_h = INVALID_HANDLE_VALUE; }
   CHandle(HANDLE h) : m_h(h)
                {
                        if(h != INVALID_HANDLE_VALUE)
                                MsiRegisterSysHandle(h);
                }
   ~CHandle() { if(m_h != INVALID_HANDLE_VALUE) MsiCloseSysHandle(m_h); }
   void operator =(HANDLE h)
           {
                        if(m_h != INVALID_HANDLE_VALUE)
                                MsiCloseSysHandle(m_h);
                        m_h = h;
                        if(m_h != INVALID_HANDLE_VALUE)
                                MsiRegisterSysHandle(m_h);
                }
   operator HANDLE() { return m_h; }
   operator INT_PTR() { return (INT_PTR) m_h; }         //--merced: changed int to INT_PTR.
   operator Bool() { return m_h==INVALID_HANDLE_VALUE?fFalse:fTrue; }
   HANDLE* operator &() { return &m_h;}

 private:
   HANDLE m_h;
};
//____________________________________________________________________________
//
// CImpersonate class.
//____________________________________________________________________________
class CImpersonate
{
public:
	CImpersonate(bool fImpersonate = true);
	~CImpersonate();
private:
	int m_cEntryCount;
	bool m_fImpersonate;
};


//____________________________________________________________________________
//
// CCoImpersonate class; similary to CImpersonate, but tries CoImpersonateClient first
//____________________________________________________________________________
class CCoImpersonate
{

public:
	CCoImpersonate(bool fImpersonate = true);
	~CCoImpersonate();
private:
	int m_cEntryCount;
	bool m_fImpersonate;
};

// these two functions are DEBUG only. In SHIP they always return TRUE.
bool IsThreadSafeForCOMImpersonation();
bool IsThreadSafeForSessionImpersonation();

class CForbidTokenChangesDuringCall
{
public:
	CForbidTokenChangesDuringCall();
	~CForbidTokenChangesDuringCall();
private:
	void* m_pOldValue;
};

class CResetImpersonationInfo
{
public:
	CResetImpersonationInfo();
	~CResetImpersonationInfo();
private:
	void* m_pOldValue;
	HANDLE m_hOldToken;
};
//____________________________________________________________________________
//
// CSIDPointer and CSIDAccess
//____________________________________________________________________________

// this class and structure are used with the CSecurityDescriptor class
// to describe a set of security settings.  Pass an array of the CSIDAccess structures
// to the CSecurityDescriptor constructor.

class CSIDPointer
{
 public:
        CSIDPointer(SID* pi) : m_pi(pi), m_fFreeOk(true) {}
        CSIDPointer(SID* pi, bool fFreeOk) : m_pi(pi), m_fFreeOk(fFreeOk) {}

        operator SID*() {return m_pi;}     // returns pointer, no ref count change

        CSIDPointer& operator=(SID* psid) { if (m_pi && m_fFreeOk) WIN::FreeSid(m_pi); m_pi = psid; return *this; }

        //passing as an outbuffer - clobber the one we already have, and prepare for incoming.
        SID** operator &() {if (m_pi && m_fFreeOk) {WIN::FreeSid(m_pi); m_pi = 0;} return &m_pi;}

        bool FreeSIDOkay(bool fOk) { bool fOld = m_fFreeOk; m_fFreeOk = fOk; return fOld; }

        ~CSIDPointer() { if (m_pi && m_fFreeOk) WIN::FreeSid(m_pi);} // release ref count at destruction

 private:
        CSIDPointer& operator=(const CSIDPointer&);
        SID* m_pi;
        bool m_fFreeOk;
};

struct CSIDAccess
{
        CSIDPointer pSID;
        DWORD dwAccessMask;
        CSIDAccess() : pSID(0), dwAccessMask(0) {}
};

//____________________________________________________________________________
//
// CSecurityDescriptor class
//____________________________________________________________________________

// this class does not allow the manipulation of a security descriptor, it
// merely wraps the various ways we create security descriptors, and allows
// a convenient way to pass them around.

class CSecurityDescription
{
 public:
        // no descriptor
        CSecurityDescription();

        // based on a reference file or folder
        CSecurityDescription(const ICHAR* szReferencePath);
        void Set(const ICHAR* szReferencePath);

        // a brand new secure object, not based on any existing object in the
        // system.
        CSecurityDescription(bool fAllowDelete, bool fHidden);

        // a brand new secure object, with allows from the structure
        CSecurityDescription(PSID psidOwner, PSID psidGroup, CSIDAccess* SIDAccessAllow, int cSIDAccessAllow);

		// from a stream passed around.
        CSecurityDescription(IMsiStream* piStream);

        //FUTURE: Several options that I've seen are needed.  Add them as
        // the need arises during more security work.

        // a more generic new security setting, not based on an existing object
        // in the system.
        //CSecurityDescription(sdSecurityDescriptor sdType, Bool fAllowDelete);

        // CSecurityDescription(SECURITY_ATTRIBUTES &sa);
        // CSecurityDescription(SECURITY_DESCRIPTOR &sd);
        // based on a reference registry key
        // CSecurityDescription(HKEY hRegKey);
        // SECURITY_INFORMATION SecurityInformation();

        ~CSecurityDescription();

        const PSECURITY_DESCRIPTOR  SecurityDescriptor();
        operator PSECURITY_DESCRIPTOR() { return SecurityDescriptor(); }

        const LPSECURITY_ATTRIBUTES SecurityAttributes();
        operator LPSECURITY_ATTRIBUTES() { return SecurityAttributes(); }

        void SecurityDescriptorStream(IMsiServices& riServices, IMsiStream*& rpiStream);

        inline bool isValid() { return m_fValid; }

 protected:
   void Initialize();

        SECURITY_ATTRIBUTES m_SA;

        // some routines will set the security descriptor
        // to a cached value, which we should not clear
        bool m_fLocalData;  // does this object own the memory

        bool m_fValid;      // is the object in a valid state?

};


//____________________________________________________________________________
//
// CElevate class.
//____________________________________________________________________________
class CElevate
{
 public:
   CElevate(bool fElevate = true);
   ~CElevate();
 protected:
	int m_cEntryCount;
	bool m_fElevate;
};

//____________________________________________________________________________
//
// CFileRead object - used for importing tables, and rewriting environment files
//____________________________________________________________________________

const int cFileReadBuffer = 512;

class CFileRead
{
 public:
        CFileRead(int iCodePage);
        CFileRead();  //!! remove this constructor when callers are fixed
  ~CFileRead();
        Bool Open(IMsiPath& riPath, const ICHAR* szFile);
        unsigned long GetSize();
        ICHAR ReadString(const IMsiString*& rpiData);
        unsigned long ReadBinary(char* rgchBuf, unsigned long cbBuf);
        Bool Close();
        HANDLE m_hFile;
        unsigned long m_cRead;
   unsigned int m_iBuffer;
        int m_iCodePage;
        char m_rgchBuf[cFileReadBuffer+2]; // room for null terminator
#ifdef UNICODE
        CTempBuffer<char, 1024> m_rgbTemp; // data to be translated to Unicode
#endif
};

//____________________________________________________________________________
//
// CFileWrite object - used for exporting tables and rewriting environment files
//____________________________________________________________________________

class CFileWrite
{
 public:
        CFileWrite(int iCodePage);
        CFileWrite();  //!! remove this constructor when callers are fixed
  ~CFileWrite();
        Bool Open(IMsiPath& riPath, const ICHAR* szFile);
        Bool WriteMsiString(const IMsiString& riData, int fNewLine);
        Bool WriteString(const ICHAR* szData, int fNewLine);
        Bool WriteInteger(int iData, int fNewLine);
        Bool WriteText(const ICHAR* szData, unsigned long cchData, int fNewLine);
        Bool WriteBinary(char* rgchBuf, unsigned long cbBuf);
        Bool Close();
 protected:
        HANDLE m_hFile;
        int m_iCodePage;
#ifdef UNICODE
        CTempBuffer<char, 1024> m_rgbTemp; // data to be translated to Unicode
#endif
};


//____________________________________________________________________________
//
// Global structures
//____________________________________________________________________________
struct ShellFolder
{
        int iFolderId;
        int iAlternateFolderId; // the per user or all users equivalent, -1 if not defined
        const ICHAR* szPropName;
        const ICHAR* szRegValue;
        bool fDeleteIfEmpty;
};


typedef int (CALLBACK *FORMAT_TEXT_CALLBACK)(const ICHAR *, int,CTempBufferRef<ICHAR>&, Bool&,Bool&,Bool&,IUnknown*);

const IMsiString& FormatText(const IMsiString& riTextString, Bool fProcessComments, Bool fKeepComments,
                                                                          FORMAT_TEXT_CALLBACK lpfnResolveValue, IUnknown* pContext, int (*prgiSFNPos)[2]=0, int* piSFNPos=0);

#define MAX_SFNS_IN_STRING      10 // maximum number of shortfile names that can appear in a format text
//____________________________________________________________________________
//
// Late-bind DLL entry point definitions
//____________________________________________________________________________

#define LATEBIND_TYPEDEF
#include "latebind.h"
#define LATEBIND_VECTREF
#include "latebind.h"


//____________________________________________________________________________
//
// Inline functions
//____________________________________________________________________________


// Make it hard to call the system's GetTempPath. Usually we should be using
// ENG::GetTempDirectory, which will give you a path to the secure Msi
// directory when we're in the service, and a path to the real TEMP dir
// when we're not.
//
// If you *really* need to call the system's GetTempPath you'll have to
// call GetTempPathA or GetTempPathW. Be careful, though, to consider
// the security implications.

#undef GetTempPath
#define GetTempPath !!!!!!


inline Bool ToBool(int i){return i ? fTrue: fFalse;}
inline bool Tobool(int i){return i ? true: false;}

inline BOOL MsGuidEqual(const GUID& guid1, const GUID& guid2)
{
        return (0 == memcmp(&guid1, &guid2, sizeof(GUID)));
}

#include "_assert.h"

// By default TRACK_OBJECTS is on in debug and off in ship
#ifdef DEBUG
#define TRACK_OBJECTS
#endif //DEBUG

#include "imsidbg.h"

//
// CLibrary replacements
//
long __cdecl strtol(const char *pch);
int ltostr(TCHAR *pch, INT_PTR i);
int FIsdigit(int c);
unsigned char * __cdecl PchMbsStr(const unsigned char *str1,const unsigned char *str2);

TCHAR* PchPtrToHexStr(TCHAR *pch, UINT_PTR val, bool fAllowNull);
UINT_PTR GetIntValueFromHexSz(const ICHAR *sz);

int FIsspace(char c);  //  Note: you can use this instead of isspace() but shouldn't use it
                                                          //  instead of iswspace()!
#ifndef _NO_INT64
__int64 atoi64(const char *nptr);
#endif  // _NO_INT64

//
// Needed for record serialization
//

enum ixoEnum
{
#define MSIXO(op,type,args) ixo##op,
#include "opcodes.h"
        ixoOpCodeCount
};

//____________________________________________________________________________
//
// Script record format definitions
//   all data is 16-bit aligned, except within non-Unicode strings
//____________________________________________________________________________

// Script record header word, 16-bits, little-endian
const int cScriptOpCodeBits    = 8;      // low bits of record header
const int cScriptOpCodeMask    = (1 << cScriptOpCodeBits) - 1;
const int cScriptMaxOpCode     = cScriptOpCodeMask;
const int cScriptArgCountBits  = 8;      // arg count bits above op code
const int cScriptMaxArgs       = (1 << cScriptArgCountBits) - 1;

// Argument data is preceded by a 16-bit length/type word
const int cScriptMaxArgLen     = 0x3FFF; // 14 bits for length, 2 bits for string type
const int iScriptTypeMask      = 0xC000; // 2 bits for type bits
const int iScriptNullString    = 0;      // used for all string types, no data bytes
const int iScriptSBCSString    = 0;      // string containing no DBCS characters
const int iScriptIntegerArg    = 0x4000; // 32-bit integer argument follows
const int iScriptDBCSString    = 0x4000; // +cb = non-null string with double-byte chars
const int iScriptNullArg       = 0x8000; // no arg data, distinct from empty string
const int iScriptBinaryStream  = 0x8000; // +cb = binary stream, 0 length same as NullArg
const int iScriptExtendedSize  = 0xC000; // length/type in following 32-bit word
const int iScriptUnicodeString = 0xC000; // + cch = non-null Unicode string


const DWORD INVALID_TLS_SLOT = 0xFFFFFFFFL;

enum ietfEnum
{
	ietfTrusted = 0,   // object was trusted
	ietfInvalidDigest, // hash of object did not validate
	ietfRejectedCert,  // signer certificate was found in the Rejected Store
	ietfUnknownCert,   // signer certificate was not found in Rejected or Accepted Stores and Unknown objects are not allowed
	ietfUnsigned,      // object is not signed, and unsigned objects are not allowed
	ietfNotTrusted,    // some other trust error
};

typedef struct tagMSIWVTPOLICYCALLBACKDATA
{
	bool     fDumpProvData;              // disables/enables dumping via TestPolicy function (set via _MSI_TEST env var)
	ietfEnum ietfTrustFailure;           // type of trust failure, ietfTrusted means no failure
	LPTSTR   szCertName;                 // name of certificate that package was signed with (use CertGetNameString API)
	DWORD    cchCertName;                // size of szCertName, including NULL
	DWORD    dwInstallKnownPackagesOnly; // value of InstallKnownPackagesOnly policy, 0 or 1
} MSIWVTPOLICYCALLBACKDATA;

#ifdef UNICODE
#define _ui64tot    _ui64tow
#else
#define _ui64tot    _ui64toa
#endif // UNICODE

#define IPROPVALUE_HIDDEN_PROPERTY     TEXT("**********")       // value dumped into the log instead of a hidden property's value
#define TSCLIENT_DRIVE                 TEXT("\\\\tsclient\\")   // drive we will not be installing from
#define ARRAY_ELEMENTS(arg)            (sizeof(arg)/sizeof(*arg)) // count of elements of a uni-dimensional array
#define RETURN_IF_FAILED(arg)          if ( FAILED(arg) ) return;
#define RETURN_IT_IF_FAILED(arg)       {HRESULT hr = arg; if ( FAILED(hr) ) return hr;}
#define RETURN_THAT_IF_FAILED(arg, that)   if ( FAILED(arg) ) return that;
#define ASSERT_IF_FAILED(arg)          AssertNonZero(SUCCEEDED(arg));

#endif // __COMMON
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\iface.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       iface.h
//
//--------------------------------------------------------------------------

// iface.h - Evaluation COM Object Interfaces declarations

#ifndef _EVALUATION_COM_INTERFACES_H_
#define _EVALUATION_COM_INTERFACES_H_

#include <objbase.h>


// returned from IEvalResult::GetResultType
typedef enum RESULTTYPES	
{
	ieUnknown = 0,
	ieError,
	ieWarning,
	ieInfo,
};

// values passed to status callback
typedef enum STATUSTYPES
{
	ieStatusGetCUB,
	ieStatusMerge,
	ieStatusSummaryInfo,
	ieStatusCreateEngine,
	ieStatusStarting,
	ieStatusRunICE,
	ieStatusRunSequence,
	ieStatusShutdown,
	ieStatusSuccess,
	ieStatusFail
};

///////////////////////////////////////////////////////////
// IEvalResult
interface IEvalResult : IUnknown
{
	virtual HRESULT __stdcall GetResultType(UINT* puiResultType) = 0;
	virtual HRESULT __stdcall GetResult(IEnumString** pResult) = 0;
};	// end of IEvalResult


///////////////////////////////////////////////////////////
// IEnumEvalResult
interface IEnumEvalResult : IUnknown
{
	virtual HRESULT __stdcall Next(ULONG cResults, IEvalResult** rgpResult, ULONG* pcResultsFetched) = 0;
	virtual HRESULT __stdcall Skip(ULONG cResults) = 0;
	virtual HRESULT __stdcall Reset(void) = 0;
	virtual HRESULT __stdcall Clone(IEnumEvalResult** ppEnum) = 0;
};	// end of IEnumEvalResult


typedef BOOL (WINAPI* LPDISPLAYVAL)(LPVOID pContext, UINT uiType, LPCWSTR szwVal, LPCWSTR szwDescription, LPCWSTR szwLocation);
typedef HRESULT (WINAPI* LPEVALCOMCALLBACK)(STATUSTYPES iStatus, LPVOID pData, LPVOID pContext);

///////////////////////////////////////////////////////////
// IEval
interface IEval : IUnknown
{
	// open/close methods
	virtual HRESULT __stdcall OpenDatabase(LPCOLESTR szDatabase) = 0;				// database to evaluate
	virtual HRESULT __stdcall OpenEvaluations(LPCOLESTR szEvaluation) = 0;		// database that contains evaluations
	virtual HRESULT __stdcall CloseDatabase() = 0;
	virtual HRESULT __stdcall CloseEvaluations() = 0;

	// set methods
	virtual HRESULT __stdcall SetDisplay(LPDISPLAYVAL pDisplayFunction,			// function to handle display
													 LPVOID pContext) = 0;						// context passed back to display
	// evaluation methods
	virtual HRESULT __stdcall Evaluate(LPCOLESTR szRunEvaluations = NULL) = 0;	// internal consistency evaluations to run
	virtual HRESULT __stdcall GetResults(IEnumEvalResult** ppResults,				// result enumerator
													 ULONG* pcResults) = 0;						// number of results
};	// end of IEval

///////////////////////////////////////////////////////////
// ValCom GUIDs
// CLSID_EvalCom
//	IID_IEval
//	IID_IEvalResult
//	IID_IEnumEvalResult

// {DC550E10-DBA5-11d1-A850-006097ABDE17}
DEFINE_GUID(CLSID_EvalCom, 
0xdc550e10, 0xdba5, 0x11d1, 0xa8, 0x50, 0x0, 0x60, 0x97, 0xab, 0xde, 0x17);

// {DC550E11-DBA5-11d1-A850-006097ABDE17}
DEFINE_GUID(IID_IEval, 
0xdc550e11, 0xdba5, 0x11d1, 0xa8, 0x50, 0x0, 0x60, 0x97, 0xab, 0xde, 0x17);

// {DC550E12-DBA5-11d1-A850-006097ABDE17}
DEFINE_GUID(IID_IEvalResult, 
0xdc550e12, 0xdba5, 0x11d1, 0xa8, 0x50, 0x0, 0x60, 0x97, 0xab, 0xde, 0x17);

// {DC550E13-DBA5-11d1-A850-006097ABDE17}
DEFINE_GUID(IID_IEnumEvalResult, 
0xdc550e13, 0xdba5, 0x11d1, 0xa8, 0x50, 0x0, 0x60, 0x97, 0xab, 0xde, 0x17);

/*
// {DC550E14-DBA5-11d1-A850-006097ABDE17}
DEFINE_GUID(<<name>>, 
0xdc550e14, 0xdba5, 0x11d1, 0xa8, 0x50, 0x0, 0x60, 0x97, 0xab, 0xde, 0x17);
*/

#endif	// _EVALUATION_COM_INTERFACES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\imemory.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       imemory.h
//
//--------------------------------------------------------------------------

/*  memory.h - IMsiMalloc definitions

	Contains the basic definitions for the IMsiMalloc object


	Alloc(unsigned long) - Allocates memory and returns a pointer
		to it.
	AllocObject(unsigned long) - Allocates memory for an object and
		returns a pointer to it.
	Free(void *) - releases the memory block

 */

#ifndef __IMEMORY
#define __IMEMORY

class IMsiMalloc : public IUnknown
{ public:
	virtual void*         __stdcall Alloc(unsigned long cb)=0;
	virtual void*         __stdcall AllocObject(unsigned long cb)=0;
	virtual void          __stdcall Free(void* pv)=0;
	virtual void		  __stdcall FreeObject(void *pv)=0;
	virtual void*         __stdcall AllocEx(unsigned long cb, unsigned long *plAddr)=0;
	virtual void*         __stdcall AllocObjectEx(unsigned long cb, unsigned long *plAddr, bool fRTTI)=0;
	virtual void          __stdcall HandleOutOfMemory(void)=0;
};

extern "C" const GUID IID_IMsiMalloc;

class IMsiDebugMalloc : public IUnknown
{ public:
	virtual void		  __stdcall SetDebugFlags(int fKeepMemory)=0;
	virtual BOOL		  __stdcall FAllBlocksFreed(void)=0;
	virtual BOOL		  __stdcall FGetFunctionNameFromAddr(unsigned long lAddr, char *pszFnName, size_t cchFnName, unsigned long *pdwDisp)=0;
	virtual void		  __stdcall ReturnBlockInfoPv(void *pv, TCHAR *pszInfo, int cchSzInfo)=0;
	virtual int			  __stdcall GetDebugFlags()=0;
	virtual BOOL		  __stdcall FCheckAllBlocks()=0;
	virtual BOOL		  __stdcall FCheckBlock(void *pv)=0;
	virtual unsigned long __stdcall GetSizeOfBlock(void *pv)=0;

};

extern "C" const GUID IID_IMsiDebugMalloc;

const int	bfKeepMem 	= 	0x1;
const int	bfLogAllocs = 	0x2;
const int	bfCheckOnAlloc	= 0x4;
const int	bfCheckOnFree	= 0x8;
const int	bfNoPreflightInit = 0x10;

// In imsimem.cpp

class IMsiServices;
void SetAllocator(IMsiServices *piServices);
void ReleaseAllocator();
void *AllocSpc(size_t cb);
void FreeSpc(void *);
void *AllocObject(size_t cb);
void FreeObject(void *);
void AddRefAllocator(void);
void InitializeMsiMalloc(void);
void FreeMsiMalloc(bool fFatalExit);

extern "C" {

void *AllocMem(size_t cb);
void FreeMem(void *);
};

void  HandleOutOfMemory();

#endif //__IMEMORY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\engine.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       engine.h
//
//--------------------------------------------------------------------------

/*  engine.h  -  IMsiEngine definitions
____________________________________________________________________________*/

#ifndef __ENGINE 
#define __ENGINE 

#ifndef __SERVICES
#include "services.h"
#endif
#ifndef __ICONFIG
#include "iconfig.h"
#endif
#ifndef __DATABASE
#include "database.h"
#endif
#ifndef __HANDLER
#include "handler.h"
#endif

// Return status enumerations

enum ieiEnum  // return status from IMsiEngine::Initialize, also use for error string access
{
	// resource strings mapped to enum value having no error message
	ieiStartupMessage      =  0, // startup message displayed during initialize
	ieiDialogCaption       =  1, // caption for messages prior to database initialize
	ieiCommandLineHelp     =  2, // string displayed as response to /?
	// return values from engine
	ieiSuccess             =  0, // initialization complete
	ieiUnused              =  1, // unused
	ieiAlreadyInitialized  =  2, // this engine object is already initialized
	ieiCommandLineOption   =  3, // invalid command line syntax
	ieiDatabaseOpenFailed  =  5, // database could not be opened
	ieiDatabaseInvalid     =  6, // incompatible database
	ieiInstallerVersion    =  7, // installer version does not support database format
	ieiSourceAbsent        =  8, // unused
	ieiUnused3             =  9, // unused
	ieiHandlerInitFailed   = 10, // could not initialize handler interface
	ieiLogOpenFailure      = 11, // could not open logfile in requested mode
	ieiLanguageUnsupported = 12, // no acceptable language could be found
	ieiPlatformUnsupported = 13, // no acceptable platform could be found
	ieiTransformFailed     = 14, // database transform failed to merge
	// 15 was formerly ieiSignatureRejected which was never used
	ieiDatabaseCopyFailed  = 16, // could not copy database to temp dir
	ieiPatchPackageOpenFailed = 17, // could not open patch package
	ieiPatchPackageInvalid = 18, // patch package invalid
	ieiTransformNotFound   = 19, // transform file not found
	ieiPatchPackageUnsupported = 20, // patch package unsupported (unsupported patching engine?)
	ieiPackageRejected     = 21, // package cannot be run because of security reasons
	ieiProductUnknown      = 22, // attempt to uninstall a product you haven't installed
	ieiDiffUserAfterReboot = 23, // different user attempting to complete install after reboot
	ieiProductAlreadyInstalled = 24, // product has been installed already w/ a different package
	ieiTSRemoteInstallDisallowed = 25, // can't do installations from a remote session on Hydra
	ieiNotValidPatchTarget = 26, // patch cannot be applied to this product
	ieiPatchPackageRejected = 27, // patch rejected because of security reasons
	ieiTransformRejected   = 28, // transform rejected because of security reasons
	ieiPerUserInstallMode = 29,	 // machine is in install mode during a per-user install
	ieiApphelpRejectedPackage = 30, // package was rejected by apphelp (not compatible with this OS)
	ieiNextEnum
};

// Execution mode, set by EXECUTEMODE property
enum ixmEnum
{
	ixmScript = 0,  // 'S' use scripts, connect to server if possible
	ixmNone,        // 'N' no execution
	ixmNextEnum
};

// IMsiEngine::EvaluateCondition() return status
enum iecEnum
{
	iecFalse = 0,  // expression evaluates to False
	iecTrue  = 1,  // expression evaluates to True
	iecNone  = 2,  // no expression present
	iecError = 3,  // syntax error in expression
	iecNextEnum
};

// Enums for the 'Installed', 'Action' columns of the Feature and Component tables
enum iisEnum
{
	iisAbsent    = 0,
	iisLocal     = 1,
	iisSource    = 2,
	iisReinstall = 3,
	iisAdvertise = 4,
	iisCurrent   = 5,
	iisFileAbsent= 6,
	iisLocalAll  = 7,
	iisSourceAll = 8,
	iisReinstallLocal = 9,
	iisReinstallSource = 10,
	iisHKCRAbsent= 11,
	iisHKCRFileAbsent = 12,
	iisNextEnum
};

enum iitEnum
{
	iitAdvertise = 0,
	iitFirstInstall,
	iitFirstInstallFromAdvertised,
	iitUninstall,
	iitMaintenance,
	iitDeployment
};

enum ifeaEnum
{
	ifeaFavorLocal         = msidbFeatureAttributesFavorLocal,       // Install components locally, if possible
	ifeaFavorSource        = msidbFeatureAttributesFavorSource,      // Run components from CD/server, if possible
	ifeaFollowParent       = msidbFeatureAttributesFollowParent,       // Follow the install option of the parent
	ifeaInstallMask        = ifeaFavorLocal | ifeaFavorSource |  ifeaFollowParent, // the mask for the last 2 bits

	// the rest of the bits are bit flags
	ifeaFavorAdvertise     = msidbFeatureAttributesFavorAdvertise,  // prefer advertising feature as default state, IF NOT ALREADY INSTALLED in the appropriate (favor local/source/follow parent) state
	ifeaDisallowAdvertise  = msidbFeatureAttributesDisallowAdvertise,  // the advertise state is disallowed for this feature
	ifeaUIDisallowAbsent   = msidbFeatureAttributesUIDisallowAbsent,   // the absent state is disallowed from being an option IN THE UI (not otherwise) as an end transition state
	ifeaNoUnsupportedAdvertise = msidbFeatureAttributesNoUnsupportedAdvertise, // advertise state is disallowed if the platform doesn't support it.
	ifeaNextEnum           = ifeaNoUnsupportedAdvertise << 1,
};

enum icaEnum
{
	icaLocalOnly         = msidbComponentAttributesLocalOnly,      // item must be installed locally
	icaSourceOnly        = msidbComponentAttributesSourceOnly,      // item should run only from CD/server
	icaOptional          = msidbComponentAttributesOptional,      // item can run either locally or from CD/server
	icaInstallMask       = msidbComponentAttributesLocalOnly |
								  msidbComponentAttributesSourceOnly |
								  msidbComponentAttributesOptional,      // the mask for the last 2 bits
	// the rest of the bits are bit flags
	icaRegistryKeyPath   = msidbComponentAttributesRegistryKeyPath, // set if the key path of the component is a registry key/value
	icaSharedDllRefCount = msidbComponentAttributesSharedDllRefCount, // set if the component is to be always refcounted (if, locally installed) in the SharedDll registry, valid only for components which have a file as the key path
	icaPermanent         = msidbComponentAttributesPermanent, // set if the component is to be installed as permanent
	icaODBCDataSource    = msidbComponentAttributesODBCDataSource, // set if component key path is an ODBCDataSource key, no file
	icaTransitive        = msidbComponentAttributesTransitive,     // set if component can transition from installed/uninstalled on changing conditional
	icaNeverOverwrite    = msidbComponentAttributesNeverOverwrite, // dont stomp over existing component if key path exists (file/ regkey)
	ica64Bit             = msidbComponentAttributes64bit, // 64-bit component
	icaNextEnum          = ica64Bit << 1,
};

// Bit definitions for GetFeatureValidStates
const int icaBitLocal     = 1 << 0;
const int icaBitSource    = 1 << 1;
const int icaBitAdvertise = 1 << 2;
const int icaBitAbsent    = 1 << 3;
const int icaBitPatchable = 1 << 4;
const int icaBitCompressable = 1 << 5;


// Script types
enum istEnum
{
	istInstall = 1,
	istRollback,
	istAdvertise,
	istPostAdminInstall,
	istAdminInstall, // aka network install
};

// script attributes
enum isaEnum
{
	isaElevate = 1, // elevate when running script
	isaUseTSRegistry = 2, // use TS registry propagation subsystem when possible
};

enum isoEnum
{
	isoStart		= msidbServiceControlEventStart,
	isoStop		= msidbServiceControlEventStop,
//	isoPause		= 1 << 2, // Reserved for possible additional feature.
	isoDelete	= msidbServiceControlEventDelete,
	isoUninstallShift = 4,
	isoUninstallStart =	msidbServiceControlEventUninstallStart,
	isoUninstallStop =	msidbServiceControlEventUninstallStop,
//	isoUninstallPause =	isoPause << isoUninstallShift,	// Reserved
	isoUninstallDelete =	msidbServiceControlEventUninstallDelete,
};

// Actions for UpdateEnvironmentStrings
enum iueEnum
{
	iueNoAction		= 0,
	iueSet			= 1 << 0,
	iueSetIfAbsent	= 1 << 1,
	iueRemove		= 1 << 2,
	iueActionModes = iueSet | iueSetIfAbsent | iueRemove,
	iueMachine		= 1 << 29,
	iueAppend		= 1 << 30,
	iuePrepend		= 1 << 31,		
	iueModifiers	= iueMachine | iueAppend | iuePrepend,
};

// assembly types
enum iatAssemblyType{
	iatNone = 0,
	iatURTAssembly,
	iatWin32Assembly,
	iatURTAssemblyPvt,
	iatWin32AssemblyPvt,
};

class IMsiCostAdjuster : public IMsiData
{
 public:
	virtual IMsiRecord* __stdcall Initialize()=0;
	virtual IMsiRecord* __stdcall Reset()=0;
	virtual IMsiRecord* __stdcall GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPCost, int& iNoRbARPCost)=0;
};

#define MAX_COMPONENT_TREE_DEPTH 16

//____________________________________________________________________________
//
// Execution opcodes. Set namespace and enums for each
//____________________________________________________________________________


#define MSIXA0()                               const int Args=0;
#define MSIXA1(a)                              const int Args=1; enum {a=1};
#define MSIXA2(a,b)                            const int Args=2; enum {a=1,b};
#define MSIXA3(a,b,c)                          const int Args=3; enum {a=1,b,c};
#define MSIXA4(a,b,c,d)                        const int Args=4; enum {a=1,b,c,d};
#define MSIXA5(a,b,c,d,e)                      const int Args=5; enum {a=1,b,c,d,e};
#define MSIXA6(a,b,c,d,e,f)                    const int Args=6; enum {a=1,b,c,d,e,f};
#define MSIXA7(a,b,c,d,e,f,g)                  const int Args=7; enum {a=1,b,c,d,e,f,g};
#define MSIXA8(a,b,c,d,e,f,g,h)                const int Args=8; enum {a=1,b,c,d,e,f,g,h};
#define MSIXA9(a,b,c,d,e,f,g,h,i)              const int Args=9; enum {a=1,b,c,d,e,f,g,h,i};
#define MSIXA10(a,b,c,d,e,f,g,h,i,j)           const int Args=10;enum {a=1,b,c,d,e,f,g,h,i,j};
#define MSIXA11(a,b,c,d,e,f,g,h,i,j,k)         const int Args=11;enum {a=1,b,c,d,e,f,g,h,i,j,k};
#define MSIXA12(a,b,c,d,e,f,g,h,i,j,k,l)       const int Args=12;enum {a=1,b,c,d,e,f,g,h,i,j,k,l};
#define MSIXA13(a,b,c,d,e,f,g,h,i,j,k,l,m)     const int Args=13;enum {a=1,b,c,d,e,f,g,h,i,j,k,l,m};
#define MSIXA14(a,b,c,d,e,f,g,h,i,j,k,l,m,n)   const int Args=14;enum {a=1,b,c,d,e,f,g,h,i,j,k,l,m,n};
#define MSIXA15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) const int Args=15;enum {a=1,b,c,d,e,f,g,h,i,j,k,l,m,n,o};
#define MSIXA16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)           const int Args=16;enum {a=1,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p};
#define MSIXA17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)         const int Args=17;enum {a=1,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q};
#define MSIXA18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r)       const int Args=18;enum {a=1,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r};
#define MSIXA19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s)     const int Args=19;enum {a=1,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s};
#define MSIXA20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t)   const int Args=20;enum {a=1,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t};
#define MSIXA21(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u) const int Args=21;enum {a=1,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u};
#define MSIXA22(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v)   const int Args=22;enum {a=1,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v};
#define MSIXA23(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w) const int Args=23;enum {a=1,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w};

#define MSIXO(op,type,args) namespace Ixo##op {const ixoEnum Op=ixo##op;args};
#include "opcodes.h"

//____________________________________________________________________________
//
// IMsiMessage interface - error reporting and progress from IMsiExecute          
//____________________________________________________________________________

// IMsiMessage::Message message types

const int imtShiftCount = 24;  // message type in high-order bits
const int imtTypeMask   = 255<<imtShiftCount;  // mask for type code and flags

enum imtEnum
{
	// messages processed by modal dialog and/or log
	imtFatalExit   =  0<<imtShiftCount, // thread terminated prematurely
	imtError       =  1<<imtShiftCount, // error message,   [1] is imsg/idbg code
	imtWarning     =  2<<imtShiftCount, // warning message, [1] is imsg/idbg code, not fatal
	imtUser        =  3<<imtShiftCount, // user request,    [1] is imsg/idbg code
	imtInfo        =  4<<imtShiftCount, // informative message for log, not to be displayed
	imtFilesInUse  =  5<<imtShiftCount, // list of files in use than need to be processed
	imtResolveSource =  6<<imtShiftCount, 
	imtOutOfDiskSpace=7<<imtShiftCount, // out of disk space for one or more volumes
	// messages processed by modeless progress dialog
	imtActionStart =  8<<imtShiftCount, // start of action, [1] action name, [2] description
	imtActionData  =  9<<imtShiftCount, // data associated with individual action item
	imtProgress    = 10<<imtShiftCount, // progress gauge info, [1] units so far, [2] total
	imtCommonData  = 11<<imtShiftCount, // control message to handler [1] is control message type followed by params
	// messages processed by message dispatcher, not sent to display or log
	imtLoadHandler = 12<<imtShiftCount, // load external UI handler
	imtFreeHandler = 13<<imtShiftCount, // free external UI handler
	imtShowDialog  = 14<<imtShiftCount, // use handler to show dialog or run wizard
	imtInternalExit= 15<<imtShiftCount, // private use by MsiUIMessageContext

	// not sent to Message(), strings used for log and UI fields, MUST TRACK imsg values
	imtLogHeader   = 12<<imtShiftCount, // log header format string, not sent to Message
	imtLogTrailer  = 13<<imtShiftCount, // log trailer format string, not sent to Message
	imtActionStarted=14<<imtShiftCount, // action started log message
	imtActionEnded = 15<<imtShiftCount, // action ended log message
	// all preceeding messsages cached by the engine, following ones cached by message handler
	imtTimeRemaining=16<<imtShiftCount, // Time remaining string for basic UI progress dlg
	imtOutOfMemory = 17<<imtShiftCount, // out of memory format string, CANNOT CONTAIN PARAMETERS
	imtTimedOut    = 18<<imtShiftCount, // engine timeout format string, CANNOT CONTAIN PARAMETERS
	imtException   = 19<<imtShiftCount, // premature termination format string, CANNOT CONTAIN PARAMETERS
	imtBannerText  = 20<<imtShiftCount, // string displayed in basic UI in the ActionStart field.
	imtScriptInProgress=21<<imtShiftCount, // Info string displayed while script is being built
	imtUpgradeRemoveTimeRemaining=22<<imtShiftCount, // Time remaining string for uninstall during upgrade
	imtUpgradeRemoveScriptInProgress=23<<imtShiftCount, // Info string displayed during script generation for uninstal during upgrade
	imtCustomServiceToClient=24<<imtShiftCount, // Custom info passed from service to the client

	// message box button styles - identical to Win32 definitions, default is imtOK
	imtOk               = 0,    // MB_OK
	imtOkCancel         = 1,    // MB_OKCANCEL
	imtAbortRetryIgnore = 2,    // MB_ABORTRETRYIGNORE
	imtYesNoCancel      = 3,    // MB_YESNOCANCEL
	imtYesNo            = 4,    // MB_YESNO
	imtRetryCancel      = 5,    // MB_RETRYCANCEL
	// message box icon styles - identical to Win32 definitions, default is none
	imtIconError        = 1<<4, // MB_ICONERROR
	imtIconQuestion     = 2<<4, // MB_ICONQUESTION
	imtIconWarning      = 3<<4, // MB_ICONWARNING
	imtIconInfo         = 4<<4, // MB_ICONINFORMATION
	// message box default button - identical to Win32 definitions, default is ficat
	imtDefault1         = 0<<8, // MB_DEFBUTTON1
	imtDefault2         = 1<<8, // MB_DEFBUTTON2
	imtDefault3         = 2<<8, // MB_DEFBUTTON3

	// internal flags, not sent to UI handlers
	imtSendToEventLog  = 1<<29,
	imtForceQuietMessage = 1<<30, // force message in quiet or basic UI
	imtSuppressLog     = 1<<31, // suppress message from log (LOGACTIONS property)
};
const int iInternalFlags = imtSuppressLog + imtSendToEventLog + imtForceQuietMessage;

const int cCachedHeaders  = (imtActionEnded>>imtShiftCount)+1;
const int cMessageHeaders = (imtUpgradeRemoveScriptInProgress>>imtShiftCount)+1;

namespace ProgressData
{
	enum imdEnum  // imt message data fields
	{
		imdSubclass      = 1,
		imdProgressTotal = 2,
		imdPerTick       = 2,
		imdIncrement     = 2,
		imdType          = 3,
		imdDirection     = 3,
		imdEventType     = 4,
		imdNextEnum
	};
	enum iscEnum  // imtProgress subclass messages
	{
		iscMasterReset      = 0,
		iscActionInfo       = 1,
		iscProgressReport   = 2,
		iscProgressAddition = 3,
		iscNextEnum
	};
	enum ipdEnum // Master reset progress direction
	{
		ipdForward,  // Advance progress bar forward
		ipdBackward, // "       "        "   backward
		ipdNextEnum
	};
	enum ietEnum // Master reset event types
	{
		ietTimeRemaining,
		ietScriptInProgress,
	};
};



enum icmtEnum // types of imtCommonData messages
{
	icmtLangId,
	icmtCaption,
	icmtCancelShow,
	icmtDialogHide,
	icmtNextEnum
};

enum istcEnum     // types of imtCustomServiceToClient messages
{
	istcSHChangeNotify,  // call SHChangeNotify on the client instead of the non-interactive service
};

enum istcfEnum    // the number of fields for records of each istcEnum
						// field # 1 is the selector integer
						// keep enum this in sync with istcEnum!!!
{
	istcfSHChangeNotify = 5,
};

enum ttblEnum 		// Temp Table enum
{
	ttblNone = 0,
	ttblRegistry,
	ttblFile
};

enum iremEnum // type of removal when checking if safe to remove product
{
	iremThis,
	iremChildUpgrade,
	iremChildNested,
};

enum iacsAppCompatShimFlags // internal appcompat "shims" (changes to behaviour for particular packages) that we support
									 // NOTE: these are bit flags (1,2,4,8,...) and correspond to the bits in the SHIMFLAGS data in the appcompat sdb
{
	iacsForceResolveSource              = 1, // resolve the source in InstallValidate unless performing full uninstall
	iacsAcceptInvalidDirectoryRootProps = 2, // ignore invalid Directory table root properties (blank or unset property)
};

//____________________________________________________________________________
//
// IMsiEngine - installer process control
// IMsiSelectionManager  - feature and component management
// IMsiDirectoryMangeger - source and target directory management
//____________________________________________________________________________

class CMsiFile;

class IMsiEngine : public IMsiMessage
{
 public:
	virtual ieiEnum         __stdcall Initialize(const ICHAR* szDatabase,
																iuiEnum iuiLevel,
																const ICHAR* szCommandLine,
																const ICHAR* szProductCode,
																iioEnum iioOptions)=0;
	virtual iesEnum         __stdcall Terminate(iesEnum iesState)=0;
	virtual IMsiServices*   __stdcall GetServices()=0;
	virtual IMsiHandler*    __stdcall GetHandler()=0;
	virtual IMsiDatabase*   __stdcall GetDatabase()=0;
	virtual IMsiServer*     __stdcall GetConfigurationServer()=0;
	virtual LANGID          __stdcall GetLanguage()=0;
	virtual int             __stdcall GetMode()=0;
	virtual void            __stdcall SetMode(int iefMode, Bool fState)=0;
	virtual iesEnum         __stdcall DoAction(const ICHAR* szAction)=0;
	virtual iesEnum         __stdcall Sequence(const ICHAR* szColumn)=0;
	virtual iesEnum         __stdcall ExecuteRecord(ixoEnum ixoOpCode, IMsiRecord& riParams)=0;
	virtual IMsiRecord*     __stdcall OpenView(const ICHAR* szName, ivcEnum ivcIntent,
															 IMsiView*& rpiView)=0;
	virtual const IMsiString& __stdcall FormatText(const IMsiString& ristrText)=0;
	virtual iecEnum         __stdcall EvaluateCondition(const ICHAR* szCondition)=0;
	virtual Bool            __stdcall SetProperty(const IMsiString& ristrProperty, const IMsiString& rData)=0;
	virtual Bool            __stdcall SetPropertyInt(const IMsiString& ristrProperty, int iData)=0;
	virtual const IMsiString& __stdcall GetProperty(const IMsiString& ristrProperty)=0;
	virtual const IMsiString& __stdcall GetPropertyFromSz(const ICHAR* szProperty)=0;
	virtual int             __stdcall GetPropertyInt(const IMsiString& ristrProperty)=0;
	virtual Bool            __stdcall ResolveFolderProperty(const IMsiString& ristrProperty)=0;
	virtual iesEnum         __stdcall FatalError(IMsiRecord& riRecord)=0; // releases record
	virtual iesEnum         __stdcall RegisterProduct()=0;
	virtual iesEnum         __stdcall UnregisterProduct()=0;
	virtual iesEnum         __stdcall RegisterUser(bool fDirect)=0;
	virtual const IMsiString& __stdcall GetProductKey()=0;

	virtual Bool            __stdcall ValidateProductID(bool fForce)=0;
	virtual imsEnum         __stdcall ActionProgress()=0;
	virtual iesEnum        __stdcall  RunExecutionPhase(const ICHAR* szActionOrSequence, bool fSequence)=0;
	virtual iesEnum         __stdcall RunNestedInstall(const IMsiString& ristrProduct,
																		Bool fProductCode, // else package path
																		const ICHAR* szAction,
																		const IMsiString& ristrCommandLine,
																		iioEnum iioOptions,
																		bool fIgnoreFailure)=0;
	virtual bool              __stdcall SafeSetProperty(const IMsiString& ristrProperty, const IMsiString& rData)=0;
	virtual const IMsiString& __stdcall SafeGetProperty(const IMsiString& ristrProperty)=0;
	virtual iesEnum         __stdcall BeginTransaction()=0;
	virtual iesEnum         __stdcall RunScript(bool fForceIfMergedChild)=0;
	virtual iesEnum         __stdcall EndTransaction(iesEnum iesStatus)=0;
	virtual CMsiFile*       __stdcall GetSharedCMsiFile()=0;
	virtual void            __stdcall ReleaseSharedCMsiFile()=0;
	virtual IMsiRecord*     __stdcall IsPathWritable(IMsiPath& riPath, Bool& fIsWritable)=0;
	virtual IMsiRecord*     __stdcall CreateTempActionTable(ttblEnum iTable)=0;
	virtual const IMsiString& __stdcall GetErrorTableString(int iError)=0;
	virtual ieiEnum         __stdcall LoadUpgradeUninstallMessageHeaders(IMsiDatabase* piDatabase, bool fUninstallHeaders)=0;
	virtual bool            __stdcall FChildInstall()=0;
	virtual const IMsiString& __stdcall GetPackageName()=0;

	virtual UINT        __stdcall ShutdownCustomActionServer()=0;
	virtual CMsiCustomActionManager* __stdcall GetCustomActionManager()=0;

	virtual IMsiRecord*     __stdcall GetAssemblyInfo(const IMsiString& rstrComponent, iatAssemblyType& riatAssemblyType,  const IMsiString** rpistrAssemblyName, const IMsiString** ppistrManifestFileKey)=0;
	virtual IMsiRecord*     __stdcall GetFileHashInfo(const IMsiString& ristrFileKey, DWORD dwFileSize,
																	  MD5Hash& rhHash, bool& fHashInfo)=0;
	virtual iitEnum         __stdcall GetInstallType()=0;
	virtual IMsiRecord*     __stdcall GetAssemblyNameSz(const IMsiString& rstrComponent, iatAssemblyType iatAT, bool fOldPatchAssembly, const IMsiString*& rpistrAssemblyName)=0;
	virtual IMsiRecord*     __stdcall GetFolderCachePath(const int iFolderId, IMsiPath*& rpiPath)=0;
	virtual int             __stdcall GetDeterminedPackageSourceType()=0;

	virtual bool            __stdcall FSafeForFullUninstall(iremEnum iremUninstallType)=0;
	virtual bool            __stdcall FPerformAppcompatFix(iacsAppCompatShimFlags iacsFlag)=0;
	virtual	iesEnum         __stdcall CleanupTempFilesViaOpcode()=0;

};

class IMsiSelectionManager : public IUnknown
{
 public:
	virtual IMsiRecord*   __stdcall LoadSelectionTables()=0;
	virtual IMsiTable*    __stdcall GetFeatureTable()=0;
	virtual IMsiTable*    __stdcall GetComponentTable()=0;
	virtual IMsiTable*    __stdcall GetVolumeCostTable()=0;
	virtual IMsiRecord*   __stdcall SetReinstallMode(const IMsiString& ristrMode)=0;
	virtual IMsiRecord*   __stdcall ConfigureFeature(const IMsiString& riFeatureString,iisEnum iisActionRequest)=0;
	virtual IMsiRecord*   __stdcall ProcessConditionTable()=0;
	virtual Bool          __stdcall FreeSelectionTables()=0;
	virtual Bool          __stdcall SetFeatureHandle(const IMsiString& riComponent, INT_PTR iHandle)=0;
	virtual IMsiRecord*   __stdcall SetComponentSz(const ICHAR* szComponent, iisEnum iState)=0;
	virtual IMsiRecord*   __stdcall GetDescendentFeatureCost(const IMsiString& ristrFeature, iisEnum iisAction, int& iCost)=0;
	virtual IMsiRecord*   __stdcall GetFeatureCost(const IMsiString& ristrFeature, iisEnum iisAction, int& iCost)=0;
	virtual IMsiRecord*   __stdcall InitializeComponents( void )=0;
	virtual IMsiRecord*   __stdcall SetInstallLevel(int iInstallLevel)=0;
	virtual IMsiRecord*   __stdcall SetAllFeaturesLocal()=0;
	virtual IMsiRecord*   __stdcall InitializeDynamicCost(bool fReinitialize)=0;
	virtual IMsiRecord*   __stdcall RegisterCostAdjuster(IMsiCostAdjuster& riCostAdjuster)=0;
	virtual IMsiRecord*   __stdcall RecostDirectory(const IMsiString& ristrDest, IMsiPath& riOldPath)=0;
	virtual IMsiRecord*   __stdcall GetFeatureValidStates(MsiStringId idFeatureName,int& iValidStates)=0;
	virtual IMsiRecord*   __stdcall GetFeatureValidStatesSz(const ICHAR *szFeatureName,int& iValidStates)=0;
	virtual Bool          __stdcall DetermineOutOfDiskSpace(Bool* pfOutOfNoRbDiskSpace, Bool* pfUserCancelled)=0;
	virtual IMsiRecord*   __stdcall RegisterCostLinkedComponent(const IMsiString& riComponentString, const IMsiString& riRecostComponentString)=0;
	virtual IMsiRecord*   __stdcall RegisterComponentDirectory(const IMsiString& riComponentString,const IMsiString& riDirectoryString)=0;
	virtual IMsiRecord*   __stdcall RegisterComponentDirectoryId(const MsiStringId idComponentString,const MsiStringId idDirectoryString)=0;
	virtual Bool          __stdcall GetFeatureInfo(const IMsiString& riFeature, const IMsiString*& rpiTitle, const IMsiString*& rpiHelp, int& iAttributes)=0;
	virtual IMsiRecord*   __stdcall GetFeatureStates(const IMsiString& riFeatureString,iisEnum* iisInstalled, iisEnum* iisAction)=0;
	virtual IMsiRecord*   __stdcall GetComponentStates(const IMsiString& riComponentString,iisEnum* iisInstalled, iisEnum* iisAction)=0;
	virtual IMsiRecord*   __stdcall GetAncestryFeatureCost(const IMsiString& riFeatureString, iisEnum iisAction, int& iCost)=0;
	virtual IMsiRecord*   __stdcall RegisterFeatureCostLinkedComponent(const IMsiString& riFeatureString, const IMsiString& riComponentString)=0;
	virtual IMsiRecord*   __stdcall GetFeatureConfigurableDirectory(const IMsiString& riFeatureString, const IMsiString*& rpiDirKey)=0;
	virtual IMsiRecord*   __stdcall CostOneComponent(const IMsiString& riComponentString)=0;
	virtual bool          __stdcall IsCostingComplete()=0;
	virtual IMsiRecord*   __stdcall RecostAllComponents(Bool& fCancel)=0;
	virtual void          __stdcall EnableRollback(Bool fEnable)=0;
	virtual IMsiRecord*   __stdcall CheckFeatureTreeGrayState(const IMsiString& riFeatureString, bool& rfIsGray)=0;
	virtual IMsiTable*    __stdcall GetFeatureComponentsTable()=0;
	virtual bool          __stdcall IsBackgroundCostingEnabled()=0;
	virtual IMsiRecord*   __stdcall SetFeatureAttributes(const IMsiString& ristrFeature, int iAttributes)=0;
	virtual IMsiRecord*   __stdcall EnumComponentCosts(const IMsiString& riComponentName, const iisEnum iisAction, const DWORD dwIndex, IMsiVolume*& rpiVolume, int& iCost, int& iTempCost)=0;
	virtual IMsiRecord*   __stdcall EnumEngineCostsPerVolume(const DWORD dwIndex, IMsiVolume*& rpiVolume, int& iCost, int& iTempCost)=0;
	virtual IMsiRecord*   __stdcall GetFeatureRuntimeFlags(const MsiStringId idFeatureString,int *piRuntimeFlags)=0;
};

class IMsiDirectoryManager : public IUnknown
{
 public:
	virtual IMsiRecord*   __stdcall LoadDirectoryTable(const ICHAR* szTableName0)=0;
	virtual IMsiTable*    __stdcall GetDirectoryTable()=0;
	virtual void          __stdcall FreeDirectoryTable()=0;
	virtual IMsiRecord*   __stdcall CreateTargetPaths()=0;
	virtual IMsiRecord*   __stdcall CreateSourcePaths()=0;
	virtual IMsiRecord*   __stdcall ResolveSourceSubPaths()=0;

	virtual IMsiRecord*   __stdcall GetTargetPath(const IMsiString& riDirKey,IMsiPath*& rpiPath)=0;
	virtual IMsiRecord*   __stdcall SetTargetPath(const IMsiString& riDirKey, const ICHAR* szPath, Bool fWriteCheck)=0;
	virtual IMsiRecord*   __stdcall GetSourcePath(const IMsiString& riDirKey,IMsiPath*& rpiPath)=0;
	virtual IMsiRecord*   __stdcall GetSourceSubPath(const IMsiString& riDirKey, bool fPrependSourceDirToken,
																	 const IMsiString*& rpistrSubPath)=0;
	virtual IMsiRecord*   __stdcall GetSourceRootAndType(IMsiPath*& rpiSourceRoot, int& iSourceType)=0;
};

// Bit definitions for status word used by GetMode and SetMode

const int iefAdmin           = 0x0001; // admin mode install, else product install
const int iefAdvertise       = 0x0002; // advertise mode of install
const int iefMaintenance     = 0x0004; // maintenance mode database loaded
const int iefRollbackEnabled = 0x0008; // rollback is enabled
const int iefSecondSequence  = 0x0010; // running the execution sequence after ui sequence was run
const int iefRebootRejected  = 0x0020; // reboot required but rejected by user or REBOOT property
const int iefOperations      = 0x0040; // executing or spooling operations
const int iefNoSourceLFN     = 0x0080; // source LongFileNames suppressed via PID_MSISOURCE summary property
const int iefLogEnabled      = 0x0100; // log file active at start of Install()
const int iefReboot          = 0x0200; // reboot is needed
const int iefSuppressLFN     = 0x0400; // target LongFileNames suppressed via SHORTFILENAMES property
const int iefCabinet         = 0x0800; // installing files from cabinets and files using Media table
const int iefCompileFilesInUse = 0x1000; // add files in use to FilesInUse table
const int iefWindows         = 0x2000; // operating systems is Windows95, not Windows NT
const int iefRebootNow       = 0x4000; // reboot is needed to continue installation
//const int iefExplorer        = 0x4000; // operating system use Explorer shell
const int iefGPTSupport      = 0x8000; //?? operating system supports the new GPT stuff - how do we set this 

// Entire upper 16 bits reserved for install overwrite modes
const int iefInstallEnabled             = 0x0001 << 16;	// 'r' // Obsolete and ignored
const int iefOverwriteNone              = 0x0002 << 16; // 'p'
const int iefOverwriteOlderVersions     = 0x0004 << 16;	// 'o'
const int iefOverwriteEqualVersions     = 0x0008 << 16;	// 'e'
const int iefOverwriteDifferingVersions = 0x0010 << 16;	// 'd'
const int iefOverwriteCorruptedFiles    = 0x0020 << 16;	// 'c'
const int iefOverwriteAllFiles          = 0x0040 << 16;	// 'a'
const int iefInstallMachineData         = 0x0080 << 16;	// 'm'
const int iefInstallUserData            = 0x0100 << 16; // 'u'
const int iefInstallShortcuts           = 0x0200 << 16;	// 's'
const int iefRecachePackage             = 0x0400 << 16; // 'v'
const int iefOverwriteReserved2         = 0x0800 << 16;
const int iefOverwriteReserved3         = 0x1000 << 16;


// Bit definitions used by the Temporary attributes column of the File table
const int itfaCompanion       = 0x0001;

// Bit flag combinations for transform validation
const int itvNone           = 0x0000;
const int itvLanguage       = MSITRANSFORM_VALIDATE_LANGUAGE;    
const int itvProduct        = MSITRANSFORM_VALIDATE_PRODUCT;    
const int itvPlatform       = MSITRANSFORM_VALIDATE_PLATFORM;    
const int itvMajVer         = MSITRANSFORM_VALIDATE_MAJORVERSION;
const int itvMinVer         = MSITRANSFORM_VALIDATE_MINORVERSION;   
const int itvUpdVer         = MSITRANSFORM_VALIDATE_UPDATEVERSION;
const int itvLess           = MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION;
const int itvLessOrEqual    = MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION;
const int itvEqual          = MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION;
const int itvGreaterOrEqual = MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION;
const int itvGreater        = MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION;
const int itvUpgradeCode    = MSITRANSFORM_VALIDATE_UPGRADECODE;

// flags for IxoRegAddValue::Attributes
const int rwNonVital      = 0x1;
const int rwWriteOnAbsent = 0x2;

//
// Object pool defines for data stored as strings
//
#define cchHexIntPtrMax	30

extern bool g_fUseObjectPool;

#ifdef _WIN64
inline Bool PutHandleData(IMsiCursor *pCursor, int iCol, INT_PTR x)
{
	ICHAR rgch[cchHexIntPtrMax];
	
	return pCursor->PutString(iCol, *MsiString(PchPtrToHexStr(rgch, x, true)));
};
inline Bool PutHandleDataNonNull(IMsiCursor *pCursor, int iCol, INT_PTR x)
{
	ICHAR rgch[cchHexIntPtrMax];
	
	return pCursor->PutString(iCol, *MsiString(PchPtrToHexStr(rgch, x, false)));
};
#define GetHandleData(pCursor, iCol)	GetIntValueFromHexSz(MsiString(pCursor->GetString(iCol)))
inline int IcdObjectPool()
{
	return icdString;
};

inline Bool PutHandleDataRecord(IMsiRecord* pRecord, int iCol, INT_PTR x)
{
	ICHAR rgch[cchHexIntPtrMax];

	return pRecord->SetMsiString(iCol, *MsiString(PchPtrToHexStr(rgch, x, true)));
};
#define GetHandleDataRecord(pRecord, iCol)	GetIntValueFromHexSz(MsiString(pRecord->GetString(iCol)))
#elif defined(USE_OBJECT_POOL)
inline Bool PutHandleData(IMsiCursor *pCursor, int iCol, INT_PTR x)
{
	if (g_fUseObjectPool)
	{
		ICHAR rgch[cchHexIntPtrMax];
		return pCursor->PutString(iCol, *MsiString(PchPtrToHexStr(rgch, x, true)));
	}
	else
		return pCursor->PutInteger(iCol, x);
};

inline Bool PutHandleDataNonNull(IMsiCursor *pCursor, int iCol, INT_PTR x)
{
	if (g_fUseObjectPool)
	{
		ICHAR rgch[cchHexIntPtrMax];
		return pCursor->PutString(iCol, *MsiString(PchPtrToHexStr(rgch, x, false)));
	}
	else
		return pCursor->PutInteger(iCol, x);
};

inline INT_PTR GetHandleData(IMsiCursor* pCursor, int iCol)
{
	if (g_fUseObjectPool)
		return GetIntValueFromHexSz(MsiString(pCursor->GetString(iCol)));
	else
		return pCursor->GetInteger(iCol);
};

inline int IcdObjectPool()
{
	return g_fUseObjectPool ? icdString : icdLong;
}

inline Bool PutHandleDataRecord(IMsiRecord* pRecord, int iCol, INT_PTR x)
{
	if (g_fUseObjectPool)
	{
		ICHAR rgch[cchHexIntPtrMax];
		return pRecord->SetMsiString(iCol, *MsiString(PchPtrToHexStr(rgch, x, true)));
	}
	else
		return pRecord->SetInteger(iCol, x);
};

inline INT_PTR GetHandleDataRecord(IMsiRecord* pRecord, int iCol)
{
	if (g_fUseObjectPool)
		return GetIntValueFromHexSz(MsiString(pRecord->GetString(iCol)));
	else
		return pRecord->GetInteger(iCol);
};

#else
#define PutHandleData(pCursor, iCol, x)	(pCursor->PutInteger(iCol, x))
#define PutHandleDataNonNull(pCursor, iCol, x)	(pCursor->PutInteger(iCol, x))
#define GetHandleData(pCursor, iCol)	(pCursor->GetInteger(iCol))
#define PutHandleDataRecord(pRecord, iCol, x)	(pRecord->SetInteger(iCol, x))
#define GetHandleDataRecord(pRecord, iCol)	(pRecord->GetInteger(iCol))
inline int IcdObjectPool()
{
	return icdLong;
};
#endif 


//____________________________________________________________________________
//
// CScriptGenerate - internal object to produce script file
//____________________________________________________________________________

class CScriptGenerate
{
public:  // factory, constructor, destructor
	CScriptGenerate(IMsiStream& riScriptOut, int iLangId, int iTimeStamp, istEnum istScriptType,
						 isaEnum isaAttributes, IMsiServices& riServices);
  ~CScriptGenerate();
public:
	bool          __stdcall InitializeScript(WORD wTargetProcessorArchitecture);
	bool          __stdcall WriteRecord(ixoEnum ixoOpCode, IMsiRecord& riParams, bool fForceFlush);
	void          __stdcall SetProgressTotal(int iProgressTotal);
protected:
	IMsiStream&   m_riScriptOut;
	IMsiServices& m_riServices;
	void operator =(CScriptGenerate&); // suppress warning
	int           m_iProgressTotal;
	int           m_iTimeStamp;
	int           m_iLangId;
	istEnum       m_istScriptType;
	isaEnum       m_isaScriptAttributes;
	IMsiRecord*   m_piPrevRecord;
	ixoEnum       m_ixoPrev;

};

// interface to execute system update operations, directly or batched    
class IMsiExecute : public IUnknown
{
 public:
	virtual IMsiServices&  __stdcall GetServices()=0;
	virtual iesEnum  __stdcall ExecuteRecord(ixoEnum ixoOpCode, IMsiRecord& riParams)=0;
	virtual iesEnum  __stdcall RunScript(const ICHAR* szScriptFile, bool fForceElevation)=0;
	virtual IMsiRecord*   __stdcall EnumerateScript(const ICHAR* szScriptFile, IEnumMsiRecord*& rpiEnum)=0;
	virtual iesEnum  __stdcall RemoveRollbackFiles(MsiDate date)=0;
	virtual iesEnum  __stdcall Rollback(MsiDate date, bool fUserChangedDuringInstall)=0;
	virtual iesEnum  __stdcall RollbackFinalize(iesEnum iesState, MsiDate date, bool fUserChangedDuringInstall)=0;
	virtual iesEnum  __stdcall GetTransformsList(IMsiRecord& riProductInfoParams, IMsiRecord& riProductPublishParams, const IMsiString*& rpiTransformsList)=0;
};

#endif // __ENGINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\database.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       database.h
//
//--------------------------------------------------------------------------

/*  database.h - Database class definitions

IMsiDatabase - database object
IMsiView     - database result set access via SQL query
IMsiTable    - internal low-level database table object
IMsiCursor   - cursor object used to access data from IMsiTable
IMsiStream   - stream object used to transfer bulk data to/from the database

For documentation, use the help file.  Help source is in database.rtf
____________________________________________________________________________*/

#ifndef __IDATABASE
#define __IDATABASE

#include "msiquery.h" // MSIMODIFY enum

class IMsiPath;
class IMsiView;
class IMsiTable;
class IMsiDatabase;
class IMsiServices;
class IMsiStorage;
enum iveEnum;
enum itsEnum;

//____________________________________________________________________________
//
// IMsiDatabase and IMsiView high-level database interface definitions
//____________________________________________________________________________

// Database open mode enumeration for IMsiServices::CreateDatabase
// Must track public enums in MsiQuery.h: MSIDBOPEN_*
// and ido* enumeration in AutoApi.cpp type library
enum idoEnum {
	idoReadOnly     = (INT_PTR)MSIDBOPEN_READONLY, // OpenDatabase: Read only
	idoTransact     = (INT_PTR)MSIDBOPEN_TRANSACT, // OpenDatabase: Transacted mode, can rollback
	idoDirect       = (INT_PTR)MSIDBOPEN_DIRECT,   // OpenDatabase: Direct write, not transacted
	idoCreate       = (INT_PTR)MSIDBOPEN_CREATE,   // OpenDatabase: Create new storage file, transacted mode
	idoCreateDirect = (INT_PTR)MSIDBOPEN_CREATEDIRECT,// OpenDatabase: Create new storage file, direct mode
	idoListScript   = 5,                       // OpenDatabase: Open an execution script for enumeration
	idoNextEnum,
	idoOpenModeMask = 7,  // to mask off extended flags
	idoRawStreamNames = 16, // uncompressed stream names (for downlevel compatibility)
	idoPatchFile      = 32, // patch file, using different CLSID
	idoOptionFlags = idoRawStreamNames | idoPatchFile
};

// Requested modify operation to be performed on fetched record
enum irmEnum {
	irmSeek            = MSIMODIFY_SEEK,     // seek using primary keys, then fetch
	irmRefresh         = MSIMODIFY_REFRESH,  // refetch current record data
	irmInsert          = MSIMODIFY_INSERT,   // insert new record, fails if matching key exists
	irmUpdate          = MSIMODIFY_UPDATE,   // update existing non-key data of fetched record
	irmAssign          = MSIMODIFY_ASSIGN,   // insert record, replacing any existing record
	irmReplace         = MSIMODIFY_REPLACE,  // modify record, delete old if primary key edit
	irmMerge           = MSIMODIFY_MERGE,    // fails if record with duplicate key not identical
	irmDelete          = MSIMODIFY_DELETE,   // remove row referenced by this record from table
	irmInsertTemporary = MSIMODIFY_INSERT_TEMPORARY,// insert a temporary record
	irmValidate        = MSIMODIFY_VALIDATE,        // validate fetched record
	irmValidateNew     = MSIMODIFY_VALIDATE_NEW,    // validate new record
	irmValidateField   = MSIMODIFY_VALIDATE_FIELD,  // validate field(s) of fetched record
	irmValidateDelete  = MSIMODIFY_VALIDATE_DELETE, // validate pre-delete
	irmNextEnum,
	irmPrevEnum        = irmSeek - 1
};

// Requested capabilities when opening a view
enum ivcEnum {
	ivcNoData    = 0,  // no result set, used for DBCS configuration
	ivcFetch     = 1,  // fetch only, no modifications
	ivcUpdate    = 2,  // can update fetched record fields
	ivcInsert    = 4,  // can insert records
	ivcDelete    = 8,  // can delete fetched record
	ivcModify    = ivcUpdate|ivcInsert|ivcDelete,  // not a read-only query
};

// Database state
enum idsEnum {
	idsNone     =-1,  // for tables and cursors only: no changes allowed
	idsRead     = 0,  // database open read-only, no persistent changes
	idsWrite    = 1,  // database readable and updatable
};

// Type of database string cache index
typedef unsigned int MsiStringId;

// View state
enum dvcsCursorState
{
	dvcsClosed,
	dvcsPrepared,
	dvcsExecuted,
	dvcsBound,
	dvcsFetched,
	dvcsDestructor,
};

class IMsiView : public IUnknown
{
 public:
	virtual IMsiRecord*  __stdcall Execute(IMsiRecord* piParams)=0;
	virtual unsigned int __stdcall GetFieldCount()=0;
	virtual IMsiRecord*  __stdcall GetColumnNames()=0;
	virtual IMsiRecord*  __stdcall GetColumnTypes()=0;
	virtual IMsiRecord*  __stdcall Fetch()=0;  // return record is result row
	virtual IMsiRecord*  __stdcall Modify(IMsiRecord& riRecord, irmEnum irmAction)=0;
	virtual IMsiRecord*  __stdcall GetRowCount(long& lRowCount)=0;
	virtual IMsiRecord*  __stdcall Close()=0;
	virtual iveEnum		__stdcall GetError(const IMsiString*& rpiColumnName)=0;
	virtual dvcsCursorState __stdcall GetState()=0;
};

class IMsiDatabase : public IUnknown {
 public:
	virtual IMsiServices& __stdcall GetServices()=0;
	virtual IMsiRecord* __stdcall OpenView(const ICHAR* szQuery, ivcEnum ivcIntent,
														IMsiView*& rpiView)=0;
	virtual IMsiRecord* __stdcall GetPrimaryKeys(const ICHAR* szTable)=0;
	virtual IMsiRecord* __stdcall ImportTable(IMsiPath& riPath, const ICHAR* szFile)=0;
	virtual IMsiRecord* __stdcall ExportTable(const ICHAR* szTable, IMsiPath& riPath, const ICHAR* szFile)=0;
	virtual IMsiRecord* __stdcall DropTable(const ICHAR* szName)=0;
	virtual itsEnum     __stdcall FindTable(const IMsiString& ristrTable)=0;//!! OBSOLETE
	virtual IMsiRecord* __stdcall LoadTable(const IMsiString& ristrTable,
														 unsigned int cAddColumns,
														 IMsiTable*& rpiTable)=0;
	virtual IMsiRecord* __stdcall CreateTable(const IMsiString& ristrTable,
														   unsigned int cInitRows,
														   IMsiTable*& rpiTable)=0;
	virtual Bool         __stdcall LockTable(const IMsiString& ristrTable, Bool fLock)=0;
	virtual IMsiTable*   __stdcall GetCatalogTable(int iTable)=0;
	virtual const IMsiString& __stdcall DecodeString(MsiStringId iString)=0;
	virtual MsiStringId  __stdcall EncodeStringSz(const ICHAR* riString)=0;
	virtual MsiStringId	 __stdcall EncodeString(const IMsiString& riString)=0;
	virtual const IMsiString& __stdcall CreateTempTableName()=0;
	virtual IMsiRecord*  __stdcall CreateOutputDatabase(const ICHAR* szFile, Bool fSaveTempRows)=0;
	virtual IMsiRecord*  __stdcall Commit()=0;
	virtual idsEnum      __stdcall GetUpdateState()=0;
	virtual IMsiStorage* __stdcall GetStorage(int iStorage)=0; // 0:Output 1:Input >:Transform
	virtual IMsiRecord*  __stdcall GenerateTransform(IMsiDatabase& riReference, 
											 IMsiStorage* piTransform,
											 int iErrorConditions,
											 int iValidation)=0;
	virtual IMsiRecord*  __stdcall SetTransform(IMsiStorage& riTransform, int iErrors)=0;
	virtual IMsiRecord*  __stdcall SetTransformEx(IMsiStorage& riTransform, int iErrors,
													  const ICHAR* szViewTable,
													  IMsiRecord* piViewTheseTablesOnlyRecord)=0;
	virtual IMsiRecord*  __stdcall MergeDatabase(IMsiDatabase& riReference, IMsiTable* pErrorTable)=0;
	virtual bool         __stdcall GetTableState(const ICHAR * szTable, itsEnum its)=0;
	virtual int          __stdcall GetANSICodePage()=0;  // returns 0 if codepage neutral
#ifdef USE_OBJECT_POOL
	virtual void         __stdcall RemoveObjectData(int iIndex)=0;
#endif //USE_OBJECT_POOL
};

//____________________________________________________________________________
//
// Docfile storage class validation
//____________________________________________________________________________

enum ivscEnum
{
	ivscDatabase   = 0,  // any database class
	ivscTransform  = 1,  // any transform class
	ivscPatch      = 2,  // any patch class
	ivscDatabase1  = iidMsiDatabaseStorage1,
	ivscDatabase2  = iidMsiDatabaseStorage2,
	ivscTransform1 = iidMsiTransformStorage1,
	ivscTransform2 = iidMsiTransformStorage2,
	ivscPatch1     = iidMsiPatchStorage1,
	ivscPatch2     = iidMsiPatchStorage2,
	ivscTransformTemp = iidMsiTransformStorageTemp, //!! remove at 1.0 ship
};

bool ValidateStorageClass(IStorage& riStorage, ivscEnum ivsc);

//____________________________________________________________________________
//
// IMsiStorage, IMsiStream interface definitions
//____________________________________________________________________________

class IMsiStream : public IMsiData
{                          //     GetMsiStringValue() returns stream as string object
 public:                   //     GetIntegerValue() returns byte count of stream
	virtual unsigned int __stdcall Remaining() const=0;
	virtual unsigned int __stdcall GetData(void* pch, unsigned int cb)=0;
	virtual void         __stdcall PutData(const void* pch, unsigned int cb)=0;
	virtual short        __stdcall GetInt16()=0;
	virtual int          __stdcall GetInt32()=0;
	virtual void         __stdcall PutInt16(short i)=0;
	virtual void         __stdcall PutInt32(int i)=0;
	virtual void         __stdcall Reset()=0; // seek to stream origin
	virtual void         __stdcall Seek(int position)=0;
	virtual Bool         __stdcall Error()=0; // fTrue if read/write error occurred
	virtual IMsiStream*  __stdcall Clone()=0;
	virtual void         __stdcall Flush()=0;
};

#define GetInt32FromStream(pstream, i)		pstream->GetData(&i, sizeof(int))
#define GetInt16FromStream(pstream, i)		{ i = 0; pstream->GetData(&i, sizeof(short)); }

class IMsiMemoryStream : public IMsiStream
{
public:
	virtual const char*  __stdcall GetMemory()=0;
};

enum ismEnum  // storage open mode, use same enum values as database open mode and flags
{
	ismReadOnly     = idoReadOnly,     // open for read-only, Commit() has no effect
	ismTransact     = idoTransact,     // open transacted, Commit() will commit data in storage
	ismDirect       = idoDirect,       // open direct write, Commit() flushes buffers only
	ismCreate       = idoCreate,       // create transacted, Commit() will commit data in storage
	ismCreateDirect = idoCreateDirect, // create direct write, Commit() flushes buffers only
	ismOpenModeMask = idoOpenModeMask, // to mask off extended flags
	ismRawStreamNames = idoRawStreamNames, // uncompressed stream names (for downlevel compatibility)
	ismOptionFlags  = ismRawStreamNames
};

HRESULT OpenRootStorage(const ICHAR* szPath, ismEnum ismOpenMode, IStorage** ppiStorage);
IMsiRecord* CreateMsiStorage(IMsiStream& riStream, IMsiStorage*& rpiStorage);

class IMsiSummaryInfo;

class IMsiStorage : public IMsiData
{
 public:
	virtual IMsiRecord* __stdcall OpenStream(const ICHAR* szName, Bool fWrite,
														  IMsiStream*& rpiStream)=0;
	virtual IMsiRecord* __stdcall OpenStorage(const ICHAR* szName, ismEnum ismOpenMode,
															IMsiStorage*& rpiStorage)=0;
	virtual IEnumMsiString* __stdcall GetStreamEnumerator()=0;
	virtual IEnumMsiString* __stdcall GetStorageEnumerator()=0;
	virtual IMsiRecord* __stdcall RemoveElement(const ICHAR* szName, Bool fStorage)=0;
	virtual IMsiRecord* __stdcall SetClass(const IID& riid)=0;
	virtual Bool        __stdcall GetClass(IID* piid)=0;
	virtual IMsiRecord* __stdcall Commit()=0;
	virtual IMsiRecord* __stdcall Rollback()=0;
	virtual Bool        __stdcall DeleteOnRelease(bool fElevateToDelete)=0;
	virtual IMsiRecord* __stdcall CreateSummaryInfo(unsigned int cMaxProperties,
																	IMsiSummaryInfo*& rpiSummary)=0;
	virtual IMsiRecord* __stdcall CopyTo(IMsiStorage& riDestStorage, IMsiRecord* piExcludedElements)=0;
	virtual IMsiRecord* __stdcall GetName(const IMsiString*& rpiName)=0;
	virtual IMsiRecord* __stdcall GetSubStorageNameList(const IMsiString*& rpiTopParent, const IMsiString*& rpiSubStorageList)=0;
	virtual bool        __stdcall ValidateStorageClass(ivscEnum ivsc)=0;
	virtual IMsiRecord* __stdcall RenameElement(const ICHAR* szOldName, const ICHAR* szNewName, Bool fStorage)=0;
};

//____________________________________________________________________________
//
//  Definitions for Summary Stream - PID_* definitions in msidefs.h
//____________________________________________________________________________

class IMsiSummaryInfo : public IUnknown
{
 public:
	virtual int         __stdcall GetPropertyCount()=0;
	virtual int         __stdcall GetPropertyType(int iPID)=0; // returns VT_XXX
	virtual const IMsiString& __stdcall GetStringProperty(int iPID)=0;
	virtual Bool        __stdcall GetIntegerProperty(int iPID, int& iValue)=0;
	virtual Bool        __stdcall GetTimeProperty(int iPID, MsiDate& riDateTime)=0;
	virtual Bool        __stdcall RemoveProperty(int iPid)=0;
	virtual int         __stdcall SetStringProperty(int iPID, const IMsiString& riText)=0;
	virtual int         __stdcall SetIntegerProperty(int iPID, int iValue)=0;
	virtual int         __stdcall SetTimeProperty(int iPID, MsiDate iDateTime)=0;
	virtual Bool        __stdcall WritePropertyStream()=0;
	virtual Bool        __stdcall GetFileTimeProperty(int iPID, FILETIME& rftDateTime)=0;
	virtual int         __stdcall SetFileTimeProperty(int iPID, FILETIME& rftDateTime)=0;
};

//____________________________________________________________________________
//
// IMsiTable, IMsiCursor low-level database interface definitions
//____________________________________________________________________________

const int cMsiMaxTableColumns = 32; // column limit determined by implementation

// reserved values used as null indicators

const int iMsiNullInteger  = 0x80000000L;  // reserved integer value
const int iTableNullString = 0;            // string index for empty string

enum itsEnum  // database table state options for GetTableState
{
	itsPermanent       = 0,  // table has persistent columns
	itsTemporary       = 1,  // temporary table, no persistent columns
	itsTableExists     = 2,  // read-only, table currently defined in system catalog
	itsDataLoaded      = 3,  // read-only, table currently present in memory, address is in catalog
	itsUserClear       = 4,  // state flag reset, not used internally
	itsUserSet         = 5,  // state flag set, not used internally
	itsOutputDb        = 6,  // persistence transferred to output database, cleared by ictsNotSaved
	itsSaveError       = 7,  // error saving table, will return at Commit()
	itsUnlockTable     = 8,  // release lock count on table, or test if unlocked
	itsLockTable       = 9,  // lock count set on table (refcnt actually kept internally)
	itsTransform       = 10, // table needs to be transformed when first loaded
	//!! TEMP old enum values, returned from obsolete FindTable()
	itsUnknown   = 0, // named table is not in database
//	itsTemporary = 1, // table is temporary, not persistent
	itsUnloaded  = 2, // table exists in database, not loaded
	itsLoaded    = 3, // table is loaded into memory
	itsOutput    = 6, // table copied to output database (itsUnloaded + 4)
//	itsSaveError = 7, // unable to write table to storage (itsLoaded + 4)
//	itsTransform = 10, // table need to have tranform applied when loaded
};

enum iraEnum  // database table row attribute, use by Get/SetRowState()
{
	// row attibutes settable via cursor
	iraUserInfo     = 0,  // attribute for external use
	iraTemporary    = 1,  // row will not normally be persisted if state is set
	iraSettableCount= 2,  // attributes below this settable by user
	// row attibutes not settable via cursor
	iraModified     = 2,  // row has been updated if set (not externally settable)
	iraInserted     = 3,  // row has been inserted
	iraMergeFailed  = 4,  // attempt to merge with non-identical non-key data
	iraReserved5    = 5,
	iraReserved6    = 6,
	iraReserved7    = 7,
	iraTotalCount   = 8,  // number of row attributes
};

// Column definition word - short integer as stored in catalog table
// 8-bit data size (required for persistent columns only)
// bit flag for persistent column
// bit flag for object type (string index or IMsiData*)
// bit flag for short data (short integer or string index)
// bit flag for nullable column
// bit flag for primary key
// bit flag for localizable column

const int icdSizeMask = 255;     // maximum SQL column width = 255
const int icdPersistent = 1 << 8;  // persistent column
const int icdLocalizable= 1 << 9;  // localizable (must also be persistent)
const int icdShort      = 1 << 10; // 16-bit integer, or string index
const int icdObject     = 1 << 11; // IMsiData pointer for temp. column, stream for persistent column
const int icdNullable   = 1 << 12; // column will accept null values
const int icdPrimaryKey = 1 << 13; // column is component of primary key

// bit flag combinations for use when defining columns
const int icdLong     = 0; // !Object && !Short
const int icdString   = icdObject+icdShort;
const int icdNoNulls  = 0; // !Primary && !Nullable
const int icdTypeMask = icdObject+icdShort;
const int icdTemporary= 0; // !Persistent

// inline function to set column number into column bit mask
inline unsigned int iColumnBit(int iColumn) {return iColumn ? (1 << (iColumn-1)) : 0;}

const Bool ictUpdatable   = Bool(0xDEADF00DL);  // internal use cursor type for transforms

// tag for transform in the summary info stream
const ICHAR ISUMINFO_TRANSFORM[] = TEXT("MSI Transform");

// bit flag combinations for transform error suppressions
const int iteNone                 = 0;
const int iteAddExistingRow       = MSITRANSFORM_ERROR_ADDEXISTINGROW;
const int iteDelNonExistingRow    = MSITRANSFORM_ERROR_DELMISSINGROW;
const int iteAddExistingTable     = MSITRANSFORM_ERROR_ADDEXISTINGTABLE;
const int iteDelNonExistingTable  = MSITRANSFORM_ERROR_DELMISSINGTABLE;
const int iteUpdNonExistingRow    = MSITRANSFORM_ERROR_UPDATEMISSINGROW;
const int iteChangeCodePage       = MSITRANSFORM_ERROR_CHANGECODEPAGE;
const int iteViewTransform        = MSITRANSFORM_ERROR_VIEWTRANSFORM;
const int iteAllBits = iteAddExistingRow+iteDelNonExistingRow+iteAddExistingTable+iteDelNonExistingTable+iteUpdNonExistingRow+iteChangeCodePage+iteViewTransform;

// Reserved words for _TransformView.Column
const ICHAR sztvopInsert[] = TEXT("INSERT");
const ICHAR sztvopDelete[] = TEXT("DELETE");
const ICHAR sztvopCreate[] = TEXT("CREATE");
const ICHAR sztvopDrop[]   = TEXT("DROP");

enum TransformViewColumnsEnum
{
	ctvTable   = 1,
	ctvColumn  = 2,
	ctvRow     = 3,
	ctvData    = 4,
	ctvCurrent = 5,
	ctvTotal   = 5
};

// validation error enum
enum iveEnum
{
	iveNoError           = MSIDBERROR_NOERROR          ,	// NoError
	iveDuplicateKey      = MSIDBERROR_DUPLICATEKEY     ,	// Duplicate Primary Key
	iveRequired          = MSIDBERROR_REQUIRED         ,	// Not a nullable column
	iveBadLink           = MSIDBERROR_BADLINK          ,	// Not a valid foreign key
	iveOverFlow          = MSIDBERROR_OVERFLOW         ,	// Value exceeds MaxValue
	iveUnderFlow         = MSIDBERROR_UNDERFLOW        ,	// Value below MinValue
	iveNotInSet          = MSIDBERROR_NOTINSET         ,	// Value not a member of set
	iveBadVersion        = MSIDBERROR_BADVERSION       ,	// Invalid version string
	iveBadCase           = MSIDBERROR_BADCASE          ,	// Invalid case, must be all upper or all lower case
	iveBadGuid           = MSIDBERROR_BADGUID          ,	// Invalid GUID
	iveBadWildCard       = MSIDBERROR_BADWILDCARD      ,	// Invalid wildcard or wildcard usage
	iveBadIdentifier     = MSIDBERROR_BADIDENTIFIER    ,	// Invalid identifier
	iveBadLanguage       = MSIDBERROR_BADLANGUAGE      ,	// Invalid LangID
	iveBadFilename       = MSIDBERROR_BADFILENAME      ,	// Invalid filename
	iveBadPath           = MSIDBERROR_BADPATH          ,	// Invalid path
	iveBadCondition      = MSIDBERROR_BADCONDITION     ,	// Bad condition string
	iveBadFormatted      = MSIDBERROR_BADFORMATTED     ,	// Invalid format string
	iveBadTemplate       = MSIDBERROR_BADTEMPLATE      ,	// Invalid template string
	iveBadDefaultDir     = MSIDBERROR_BADDEFAULTDIR    ,	// Invalid DefaultDir string (special for Directory table)
	iveBadRegPath        = MSIDBERROR_BADREGPATH       ,  // Invalid registry path
	iveBadCustomSource   = MSIDBERROR_BADCUSTOMSOURCE  ,  // Bad CustomSource data
	iveBadProperty       = MSIDBERROR_BADPROPERTY      ,  // Invalid Property name
	iveMissingData       = MSIDBERROR_MISSINGDATA      ,  // Missing data in _Validation table or Old Database
	iveBadCategory       = MSIDBERROR_BADCATEGORY      ,  // Validation table error:  Invalid category string
	iveBadKeyTable       = MSIDBERROR_BADKEYTABLE      ,  // Validation table error:  Bad KeyTable name
	iveBadMaxMinValues   = MSIDBERROR_BADMAXMINVALUES  ,  // Validation table error:  Case where MaxValue col < MinValue col
	iveBadCabinet        = MSIDBERROR_BADCABINET       ,  // Bad Cabinet name
	iveBadShortcut       = MSIDBERROR_BADSHORTCUT      ,  // Bad shortcut target
	iveStringOverflow    = MSIDBERROR_STRINGOVERFLOW   ,  // String length greater than size allowed by column definition
	iveBadLocalizeAttrib = MSIDBERROR_BADLOCALIZEATTRIB,  // Invalid localization attribute set
	iveNextEnum
};

class IMsiCursor : public IUnknown
{
 public:
	virtual IMsiTable&   __stdcall GetTable()=0;
	virtual void         __stdcall Reset()=0;
	virtual int          __stdcall Next()=0;
	virtual unsigned int __stdcall SetFilter(unsigned int fFilter)=0;
	virtual int          __stdcall GetInteger(unsigned int iCol)=0;
	virtual const IMsiString& __stdcall GetString(unsigned int iCol)=0;
	virtual IMsiStream*  __stdcall GetStream(unsigned int iCol)=0;
	virtual const IMsiData*    __stdcall GetMsiData(unsigned int iCol)=0;
	virtual Bool         __stdcall PutInteger(unsigned int iCol, int iData)=0;
	virtual Bool         __stdcall PutString(unsigned int iCol, const IMsiString& riData)=0;
	virtual Bool         __stdcall PutStream(unsigned int iCol, IMsiStream* piStream)=0;
	virtual Bool         __stdcall PutMsiData(unsigned int iCol, const IMsiData* piData)=0;
	virtual Bool         __stdcall PutNull(unsigned int iCol)=0;
	virtual Bool         __stdcall Update()=0; // replace at new primary key match
	virtual Bool         __stdcall Insert()=0; // insert new row, ordered by key
	virtual Bool         __stdcall InsertTemporary()=0; // insert a temporary row
	virtual Bool         __stdcall Assign()=0; // insert or replace row by key
	virtual Bool         __stdcall Replace()=0;// allow primary key update by delete+insert
	virtual Bool         __stdcall Merge()=0;  // insert or match identically
	virtual Bool         __stdcall Refresh()=0;// refresh current row
	virtual Bool         __stdcall Delete()=0; // delete row using primary key
	virtual Bool         __stdcall Seek()=0;   // position row using primary key, then refresh
	virtual IMsiRecord*  __stdcall Validate(IMsiTable& riValidationTable, IMsiCursor& riValidationCursor, int iCol)=0;
	virtual Bool         __stdcall SetRowState(iraEnum ira, Bool fState)=0; // set/clear row attribute
	virtual Bool         __stdcall GetRowState(iraEnum ira)=0; // query row attribute
	virtual const IMsiString&  __stdcall GetMoniker()=0; // returns unique identifier for row (table.key1.key2...)
};

//
// Resets the cursor when we are done with it and
// asserts that it is reset before we use it (to ensure that no one else is using it)
//
class PMsiSharedCursor 
{
	public:
#ifdef DEBUG	
		PMsiSharedCursor::PMsiSharedCursor(IMsiCursor* pi, const ICHAR *szFile, int line, const ICHAR * /* szCursor */)
#else
		PMsiSharedCursor::PMsiSharedCursor(IMsiCursor* pi)
#endif //DEBUG
			{
#ifdef DEBUG
				if (!pi)
					FailAssertSz(szFile, line, TEXT("Cursor is Null"));
				if (pi->GetInteger(1) != 0)
				{
					FailAssertSz(szFile, line, TEXT("Cursor not reset"));
				}
#endif //DEBUG

				m_pi = pi;
			};
		~PMsiSharedCursor()
		{
			m_pi->Reset();
		}
	public:
		IMsiCursor*  m_pi;
	
};


#ifdef DEBUG
#define CreateSharedCursor(var, cursor)		PMsiSharedCursor var(cursor, TEXT(__FILE__), __LINE__, TEXT(#cursor));
#else
#define CreateSharedCursor(var, cursor)		PMsiSharedCursor var = cursor;
#endif //DEBUG


class IMsiTable : public IMsiData
{
 public:
	virtual IMsiDatabase& __stdcall GetDatabase()=0;
	virtual unsigned int  __stdcall GetRowCount()=0;
	virtual unsigned int  __stdcall GetColumnCount()=0;
	virtual unsigned int  __stdcall GetPrimaryKeyCount()=0;
	virtual Bool          __stdcall IsReadOnly()=0;
	virtual unsigned int  __stdcall GetColumnIndex(MsiStringId iColumnName)=0;
	virtual MsiStringId   __stdcall GetColumnName(unsigned int iColumn)=0;
	virtual int           __stdcall GetColumnType(unsigned int iColumn)=0;
	virtual int           __stdcall CreateColumn(int iColumnDef, const IMsiString& istrName)=0;
	virtual IMsiCursor*   __stdcall CreateCursor(Bool fTree)=0;
	virtual int           __stdcall LinkTree(unsigned int iParentColumn)=0;
	virtual unsigned int  __stdcall GetPersistentColumnCount()=0;
};

#endif // __IDATABASE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\iconfig.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       iconfig.h
//
//--------------------------------------------------------------------------

/*  iconfig.h  -  IMsiConfigurationManager definitions
____________________________________________________________________________*/

#ifndef __ICONFIG
#define __ICONFIG

#ifndef __SERVICES
#include "services.h"
#endif

#ifndef __VERTRUST
#include "vertrust.h"
#endif

#ifdef CONFIGDB
#ifndef __CONFIGDB
#include "configdb.h"
#endif
#endif

#include "msi.h"

enum iesEnum;
enum iuiEnum; // engine.h: IMsiEngine/IMsiHandler::UI level

struct IMsiMessage;
struct IMsiCustomAction;
class IMsiEngine;

enum icmfsEnum// Installer Configuration Manager FeatureState
{
	icmfsAbsent,
	icmfsLocal,
	icmfsSource,
	icmfsUnknown,
	icmfsEnumNext,
	icmfsEnumCount = icmfsEnumNext-1
};

enum icmcsEnum// Installer Configuration Manager ComponentState
{
	icmcsAbsent   = 0,
	icmcsLocal    = 1,
	icmcsSource   = 2,
	icmcsClient   = 3,
	icmcsReleased = 4,
	icmcsEnumNext,
	icmcsEnumCount = icmcsEnumNext-1
};

enum icmlcrEnum // Installer Component Manager LocateComponent result
{
	icmlcrFile,
	icmlcrAuxPath,
	icmlcrINSTALLSTATE,
	icmlcrINSTALLSTATE_Static,
	icmlcrSharedDllCount,
	icmlcrRawFile,
	icmlcrRawAuxPath,
	icmlcrLastErrorOnFileDetect,
	icmlcrEnumNext,
	icmlcrEnumCount = icmlcrEnumNext-1
};

IMsiServer*   CreateMsiServerProxy();
IMsiServer*   CreateMsiServer(void);
bool FCanAccessInstallerKey();
bool FSourceIsAllowed(IMsiServices& riServices, bool fFirstInstall, const ICHAR* szProductCodeGUID, const ICHAR* szPath, Bool fPatch);

class CMsiCustomActionManager;

class IMsiConfigurationManager : public IMsiServer // methods not accessible by clients
{
 public:
	virtual IMsiServices&   __stdcall GetServices()=0;
	virtual IMsiRecord*     __stdcall RegisterComponent(const IMsiString& riProductCode, const IMsiString& riComponentCode, INSTALLSTATE iState, const IMsiString& riKeyPath,  unsigned int uiDisk, int iSharedDllRefCount)=0;
	virtual IMsiRecord*     __stdcall UnregisterComponent(const IMsiString& riProductCode, const IMsiString& riComponentCode)=0;

	virtual IMsiRecord*     __stdcall RegisterFolder(IMsiPath& riPath, Bool fExplicitCreation)=0;
	virtual IMsiRecord*     __stdcall IsFolderRemovable(IMsiPath& riPath, Bool fExplicit, Bool& fRemovable)=0; 
	virtual IMsiRecord*     __stdcall UnregisterFolder(IMsiPath& riPath)=0;

	virtual IMsiRecord*     __stdcall RegisterRollbackScript(const ICHAR* szScriptFile)=0;
	virtual IMsiRecord*     __stdcall UnregisterRollbackScript(const ICHAR* szScriptFile)=0;
	virtual IMsiRecord*     __stdcall GetRollbackScriptEnumerator(MsiDate date, Bool fAfter, IEnumMsiString*& rpiEnumScripts)=0;
	virtual IMsiRecord*     __stdcall DisableRollbackScripts(Bool fDisable)=0;
	virtual IMsiRecord*     __stdcall RollbackScriptsDisabled(Bool &fDisabled)=0;
	
	virtual IMsiRecord*     __stdcall SetLastUsedSource(const ICHAR* szProductCode, const ICHAR* szPath, Bool fAddToList, Bool fPatch,
																		  const IMsiString** ppiRawSource,
																		  const IMsiString** ppiIndex,
																		  const IMsiString** ppiType,
																		  const IMsiString** ppiSource,
																		  const IMsiString** ppiSourceListKey,
																		  const IMsiString** ppiSourceListSubKey)=0;

	virtual IMsiRecord*     __stdcall SetLastUsedSource(const ICHAR* szProductCode, const ICHAR* szPath, boolean fAddToList, boolean fPatch)=0;
	virtual iesEnum         __stdcall RunScript(const ICHAR* szScriptFile, IMsiMessage& riMessage,
															  IMsiDirectoryManager* piDirectoryManager, boolean fRollbackEnabled)=0;
	virtual IMsiRecord*     __stdcall RegisterUser(const ICHAR* szProductKey, const ICHAR* szUserName,
															  const ICHAR* szCompany, const ICHAR* szProductID)=0;
	virtual IMsiRecord*     __stdcall RemoveRunOnceEntry(const ICHAR* szEntry)=0;
	virtual boolean         __stdcall CleanupTempPackages(IMsiMessage& riMessage, boolean fCheckServiceBusy)=0;

#ifdef CONFIGDB
	virtual icdrEnum    __stdcall RegisterFile(const ICHAR* szFolder, const ICHAR* szFile, const ICHAR* szComponentId)=0;
	virtual icdrEnum    __stdcall UnregisterFile(const ICHAR* szFolder, const ICHAR* szFile, const ICHAR* szComponentId)=0;
#endif
	virtual void        __stdcall ChangeServices(IMsiServices& riServices)=0;
	virtual void        __stdcall EnableReboot(boolean fRunScriptElevated, const IMsiString& ristrProductName, const IMsiString& ristrProductCode)=0;
	virtual IMsiCustomAction* __stdcall CreateCustomActionProxy(const icacCustomActionContext icacDesiredContext, const unsigned long dwProcessId, IMsiRemoteAPI *pRemoteApi, const WCHAR* pvEnvironment, DWORD dwPrivileges, unsigned char *rgchCookie, int *pcbCookie, HANDLE *hServerProcess, unsigned long *dwServerProcessId, bool fClientOwned, bool fRemapHKCU)=0;
	virtual UINT        __stdcall ShutdownCustomActionServer()=0;
	virtual CMsiCustomActionManager* __stdcall GetCustomActionManager()=0;
	virtual void        __stdcall CreateCustomActionManager(bool fRemapHKCU)=0;
	virtual void        __stdcall SetShutdownTimer(HANDLE hTimer)=0;
};

enum icmrcfEnum  // Installer Configuration Manager RegisterComponent record fields
{
	icmrcfKeyFile,
	icmrcfRegKey,
	icmrcfTreatAs,
	icmrcfClientState,
	icmrcfRelativeSourcePath,
	icmrcfEnumNext,
	icmrcfEnumCount = icmrcfEnumNext-1
};

enum icmricfEnum  // Installer Configuration Manager RegisterInstallableComponent record fields
{
	icmricfMinVersion =1,
	icmricfVersion,
	icmricfRegKey, 
	icmricfEnumNext,
	icmricfEnumCount = icmricfEnumNext-1
};

enum icmecfEnum  // Installer Configuration Manager GetComponentEnumerator record fields
{
	icmecfComponentCode = 1,
	icmecfLanguage,
	icmecfMinVersion,
	icmecfVersion,
	icmecfRegKey, 
	icmecfCost,
	icmecfFile,
	icmecfEnumNext,
	icmecfEnumCount = icmecfEnumNext-1
};

enum icmlcfEnum  // Installer Configuration Manager LocateComponent record fields
{
	icmlcfProductKey = 1,
	icmlcfFilepath,
	icmlcfEnumNext,
	icmlcfEnumCount = icmlcfEnumNext-1
};


#endif // __ICONFIG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\handler.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       handler.h
//
//--------------------------------------------------------------------------

/*  handler.h - IMsiHandler, IMsiDialogHandler, IMsiDialog, IMsiEvent, IMsiControl definitions   

____________________________________________________________________________*/

#ifndef __HANDLER
#define __HANDLER
#define __CONTROL
#ifdef DEBUG
#define ATTRIBUTES
#endif // DEBUG

class IMsiServices;
class IMsiDatabase;
class IMsiEngine;
class IMsiTable;

class IMsiHandler;
class IMsiDialogHandler;
class IMsiDialog;
class IMsiEvent;
class IMsiControl;

enum  imtEnum; // engine.h: IMsiMessage::Message message types
enum  imsEnum; // engine.h: IMsiMessage::Message return status codes
enum  iesEnum; // engine.h: IMsiEngine/IMsiHandler::DoAction return status
enum  iuiEnum; // engine.h: IMsiEngine/IMsiHandler::UI level

// possible return values from a modal dialog
enum idreEnum
{
	idreNone = 0,
	idreNew,
	idreSpawn,
	idreExit,
	idreReturn,
	idreInstall,  // not used anymore
	idreError,
	idreRetry,
	idreIgnore,
	idreErrorOk,
	idreErrorCancel,
	idreErrorAbort,
	idreErrorRetry,
	idreErrorIgnore,
	idreErrorYes,
	idreErrorNo,
	idreBreak,
};

// path validation modes of CMsiControl::CheckPath()
enum ipvtEnum
{
	ipvtNone = 0,
	ipvtExists = 1,
	ipvtWritable = 2,
	ipvtAll = ipvtExists + ipvtWritable,
};


class IMsiHandler : public IUnknown 
{
public:
	virtual Bool              __stdcall Initialize(IMsiEngine& riEngine, iuiEnum iuiLevel, HWND hwndParent, bool& fMissingTables) = 0;
	virtual imsEnum           __stdcall Message(imtEnum imt, IMsiRecord& riRecord) = 0;
	virtual iesEnum           __stdcall DoAction(const ICHAR* szAction) = 0;
	virtual Bool              __stdcall Break() = 0;   
	virtual void              __stdcall Terminate(bool fFatalExit=false) = 0; 
	virtual HWND              __stdcall GetTopWindow() = 0;
};


//  the types of objects CWINHND can store
enum iwhtEnum
{
	iwhtNone = 0,
	iwhtWindow,
	iwhtGDIObject,
	iwhtIcon,
	iwhtImageList,
};


class CWINHND
{
protected:
	HANDLE         m_hHandle;			// !merced: Changed from DWORD to HANDLE. This affects most of the following function prototypes
	iwhtEnum       m_iType;
public:
	CWINHND() : m_hHandle(0), m_iType(iwhtNone) {}
	CWINHND(HANDLE hArg, iwhtEnum iType) : m_hHandle(hArg), m_iType(iType) {}
	bool operator == (const CWINHND& rArg){
		                        return rArg.m_hHandle == m_hHandle && rArg.m_iType == m_iType ? true : false; }
	bool operator != (const CWINHND& rArg){ return !(*this == rArg); }
	bool           IsEmpty(){ return m_hHandle == 0 && m_iType == iwhtNone ? true : false; }
	HANDLE         GetHandle() { return m_hHandle; }
	iwhtEnum       GetType() { return m_iType; }
	void           Destroy();
};



class IMsiDialogHandler : public IUnknown
{
public:
	virtual idreEnum          __stdcall DoModalDialog(MsiStringId iName, MsiStringId iParent) = 0;
	virtual IMsiDialog*       __stdcall DialogCreate(const IMsiString& riTypeString) = 0;
	virtual Bool              __stdcall AddDialog(IMsiDialog& riDialog, IMsiDialog* piParent, IMsiRecord& riRecord,
										IMsiTable* piControlEventTable,IMsiTable* piControlConditionCondition, 
										IMsiTable* piEventMappingTable) = 0;
	virtual IMsiDialog*       __stdcall GetDialog(const IMsiString& riDialogString) = 0;
	virtual IMsiDialog*       __stdcall GetDialogFromWindow(LONG_PTR window) = 0;
	virtual Bool              __stdcall RemoveDialog(IMsiDialog* piDialog) = 0;
	virtual IMsiRecord*		  __stdcall GetTextStyle(const IMsiString* piArgumentString) = 0;
	virtual int               __stdcall RecordHandle(const CWINHND& rArg) = 0;
	virtual int               __stdcall DestroyHandle(const HANDLE hArg) = 0;
	virtual void              __stdcall DestroyAllHandles(iwhtEnum iType=iwhtNone) = 0;
	virtual int               __stdcall GetHandleCount() = 0;
	virtual int               __stdcall ShowWaitCursor() = 0;
	virtual int               __stdcall RemoveWaitCursor() = 0;
	virtual bool              __stdcall FSetCurrentCursor() = 0;
	virtual UINT              __stdcall GetUserCodePage() = 0;
	virtual int               __stdcall GetTextHeight() = 0;
	virtual float             __stdcall GetUIScaling() = 0;
};


// IMsiDialog modality states
enum icmdEnum
{
	icmdModeless = 0,
	icmdAppModal = 1,
	icmdSysModal = 2
};

enum dabEnum;

class IMsiDialog : public IMsiData
{
public:
	virtual IMsiRecord*        __stdcall WindowCreate(IMsiRecord& riRecord, IMsiDialog* piParent, IMsiTable* piControlEventTable,
															IMsiTable* piControlConditionTable, IMsiTable* piEventMappingTable) = 0; 
	virtual IMsiRecord*        __stdcall WindowShow(Bool fShow) = 0;
	virtual IMsiControl*       __stdcall ControlCreate(const IMsiString& riTypeString) = 0;
	virtual IMsiRecord*        __stdcall Attribute(Bool fSet, const IMsiString& riAttributeString, IMsiRecord& riRecord) = 0;
	virtual IMsiRecord*        __stdcall AttributeEx(Bool fSet, dabEnum dab, IMsiRecord& riRecord) = 0;
	virtual IMsiRecord*        __stdcall GetControl(const IMsiString& riControlString, IMsiControl*& rpiControl) = 0;
	virtual IMsiRecord*        __stdcall AddControl(IMsiControl* piControl, IMsiRecord& riRecord) = 0;
	virtual IMsiRecord*        __stdcall FinishCreate() = 0;
	virtual IMsiRecord*        __stdcall RemoveControl(IMsiControl* piControl) = 0;
	virtual IMsiRecord*        __stdcall DestroyControls() = 0;
	virtual IMsiRecord*        __stdcall RemoveWindow() = 0;
	virtual IMsiRecord*        __stdcall Execute() = 0;
	virtual IMsiRecord*        __stdcall Reset() = 0;
	virtual IMsiRecord*        __stdcall EventAction(MsiStringId idEventName, const IMsiString& riActionString) = 0;
	virtual IMsiRecord*        __stdcall EventActionSz(const ICHAR * szEventNameString, const IMsiString& riActionString) = 0;
	virtual IMsiRecord*        __stdcall PublishEvent(MsiStringId idEventString, IMsiRecord& riArgumentRecord) = 0;
	virtual IMsiRecord*        __stdcall PublishEventSz(const ICHAR* szEventString, IMsiRecord& riArgumentRecord) = 0;
	virtual IMsiDialogHandler& __stdcall GetHandler() = 0;
	virtual IMsiRecord*        __stdcall PropertyChanged(const IMsiString& riPropertyString, const IMsiString& riControlString) = 0;
	virtual IMsiRecord*        __stdcall HandleEvent(const IMsiString& riEventNameString, const IMsiString& riArgumentString) = 0;
	virtual bool               __stdcall SetCancelAvailable(bool fAvailable) = 0;
}; 


class IMsiEvent : public IUnknown
{
public:
	virtual IMsiRecord*         __stdcall PropertyChanged(const IMsiString& riPropertyString, const IMsiString& riControlString) = 0;
	virtual IMsiRecord*         __stdcall ControlActivated(const IMsiString& riControlString) = 0;
	virtual IMsiRecord*         __stdcall RegisterControlEvent(const IMsiString& riControlString, Bool fRegister, const ICHAR * szEventString) = 0;
	virtual IMsiDialogHandler&  __stdcall GetHandler() = 0;
	virtual IMsiEngine&         __stdcall GetEngine() = 0;
	virtual IMsiRecord*         __stdcall PublishEvent(MsiStringId  idEventString, IMsiRecord& riArgumentRecord) = 0;
	virtual IMsiRecord*         __stdcall PublishEventSz(const ICHAR* szEventString, IMsiRecord& riArgumentRecord) = 0;
	virtual IMsiRecord*         __stdcall GetControl(const IMsiString& riControlString, IMsiControl*& rpiControl) = 0;
	virtual IMsiRecord*         __stdcall GetControlFromWindow(const HWND hControl, IMsiControl*& rpiControl) = 0;
	virtual IMsiRecord*         __stdcall Attribute(Bool fSet, const IMsiString& riAttributeString, IMsiRecord& riRecord) = 0;
	virtual IMsiRecord*         __stdcall AttributeEx(Bool fSet, dabEnum dab, IMsiRecord& riRecord) = 0;
	virtual IMsiRecord*         __stdcall EventAction(MsiStringId idEventName, const IMsiString& riActionString) = 0;
	virtual IMsiRecord*         __stdcall EventActionSz(const ICHAR * szEventNameString, const IMsiString& riActionString) = 0;
	virtual void                __stdcall SetErrorRecord(IMsiRecord& riRecord) = 0;
	virtual IMsiRecord*         __stdcall SetFocus(const IMsiString& riControlString) = 0;
	virtual	IMsiRecord*        __stdcall HandleEvent(const IMsiString& riEventNameString, const IMsiString& riArgumentString) = 0;
	virtual IMsiRecord*         __stdcall Escape() = 0;
	virtual IMsiControl*        __stdcall ControlCreate(const IMsiString& riTypeString) = 0;
	virtual	IMsiRecord*        __stdcall AddControl(IMsiControl* piControl, IMsiRecord& riRecord) = 0;
	virtual IMsiRecord*         __stdcall FinishCreate() = 0;
	virtual IMsiRecord*         __stdcall RemoveControl(IMsiControl* piControl) = 0;
};



// Dialog AttriButes
// These must line up with the 
enum dabEnum {
	dabText = 0,
	dabCurrentControl,
	dabShowing,
	dabRunning,
	dabPosition,
	dabPalette,
	dabEventInt,
	dabArgument,
	dabWindowHandle,
	dabToolTip,
	dabFullSize,
	dabKeyInt,
	dabKeyString,
	dabError,
	dabKeepModeless,
	dabUseCustomPalette,
	dabPreview,
	dabAddingControls,
	dabLocked,
	dabInPlace,
	dabModal,
	dabCancelButton,
#ifdef ATTRIBUTES
	dabX,
	dabY,
	dabWidth,
	dabHeight,
	dabRefCount,
	dabEventString,
	dabControlsCount,
	dabControlsKeyInt,
	dabControlsKeyString,
	dabControlsProperty,
	dabControlsNext,
	dabControlsPrev,
	dabHasControls,
	dabClientRect,
	dabDefaultButton,
	dabRTLRO,
	dabRightAligned,
	dabLeftScroll,
#endif // ATTRIBUTES
	dabMax,
};

enum cabEnum;

class IMsiControl : public IMsiData 
{
public:
	virtual IMsiRecord*         __stdcall WindowCreate(IMsiRecord& riRecord) = 0;
	virtual IMsiRecord*         __stdcall Attribute(Bool fSet, const IMsiString& riAttributeString, IMsiRecord& riRecord) = 0;
	virtual IMsiRecord*         __stdcall AttributeEx(Bool fSet, cabEnum cab, IMsiRecord& riRecord) = 0;
	virtual Bool                __stdcall CanTakeFocus() = 0;
	virtual IMsiRecord*         __stdcall HandleEvent(const IMsiString& riEventNameString, const IMsiString& riArgumentString) = 0;
	virtual IMsiRecord*         __stdcall Undo() = 0;    
	virtual IMsiRecord*         __stdcall SetPropertyInDatabase() = 0;
	virtual IMsiRecord*         __stdcall GetPropertyFromDatabase() = 0;
	virtual IMsiRecord*         __stdcall GetIndirectPropertyFromDatabase() = 0;
	virtual IMsiRecord*         __stdcall RefreshProperty () = 0;
	virtual IMsiRecord*         __stdcall SetFocus() = 0;
	virtual IMsiEvent&          __stdcall GetDialog() = 0;
	virtual IMsiRecord*         __stdcall WindowMessage(int iMessage, WPARAM wParam, LPARAM lParam) = 0;
	virtual void                __stdcall Refresh() = 0;
	virtual const ICHAR*        __stdcall GetControlType() const = 0;
};

// name of the property pointing to the error dialog
const ICHAR     pcaPropertyErrorDialog[] = TEXT("ErrorDialog");

// names of the reserved events, these are control events that are handled by the Handler
const ICHAR     pcaEventActionData[] = TEXT("ActionData");
const ICHAR     pcaEventActionText[] = TEXT("ActionText");
const ICHAR     pcaEventEndDialog[] = TEXT("EndDialog");
const ICHAR     pcaEventNewDialog[] = TEXT("NewDialog");
const ICHAR     pcaEventSpawnDialog[] = TEXT("SpawnDialog");
const ICHAR     pcaEventSpawnWaitDialog[] = TEXT("SpawnWaitDialog");
const ICHAR     pcaEventReset[] = TEXT("Reset");
const ICHAR     pcaEventSetInstallLevel[] =TEXT("SetInstallLevel");
const ICHAR     pcaEventEnableRollback[] = TEXT("EnableRollback");
const ICHAR     pcaEventAddLocal[] = TEXT("AddLocal");
const ICHAR     pcaEventAddSource[] = TEXT("AddSource");
const ICHAR     pcaEventRemove[] = TEXT("Remove");
const ICHAR     pcaEventReinstall[] = TEXT("Reinstall");
const ICHAR     pcaEventReinstallMode[] = TEXT("ReinstallMode");
const ICHAR     pcaEventValidateProductID[] = TEXT("ValidateProductID");
const ICHAR     pcaEventCheckTargetPath[] = TEXT("CheckTargetPath");
const ICHAR     pcaEventSetTargetPath[] = TEXT("SetTargetPath");
const ICHAR     pcaEventCheckExistingTargetPath[] = TEXT("CheckExistingTargetPath");
const ICHAR     pcaEventDoAction[] = TEXT("DoAction");
const ICHAR     pcaEventSetProgress[] = TEXT("SetProgress");
const ICHAR     pcaEventTimeRemaining[] = TEXT("TimeRemaining");
const ICHAR     pcaEventScriptInProgress[] = TEXT("ScriptInProgress");

// names of the reserved event arguments
const ICHAR     pcaEventArgumentReturn[] = TEXT("Return");
const ICHAR     pcaEventArgumentExit[] = TEXT("Exit");
const ICHAR     pcaEventArgumentRetry[] = TEXT("Retry");
const ICHAR     pcaEventArgumentIgnore[] = TEXT("Ignore");
const ICHAR     pcaEventArgumentErrorOk[] = TEXT("ErrorOk");
const ICHAR     pcaEventArgumentErrorCancel[] = TEXT("ErrorCancel");
const ICHAR     pcaEventArgumentErrorAbort[] = TEXT("ErrorAbort");
const ICHAR     pcaEventArgumentErrorRetry[] = TEXT("ErrorRetry");
const ICHAR     pcaEventArgumentErrorIgnore[] = TEXT("ErrorIgnore");
const ICHAR     pcaEventArgumentErrorYes[] = TEXT("ErrorYes");
const ICHAR     pcaEventArgumentErrorNo[] = TEXT("ErrorNo");

// names of the reserved actions
const ICHAR     pcaActionDisable[] = TEXT("Disable");
const ICHAR     pcaActionEnable[] = TEXT("Enable");
const ICHAR     pcaActionHide[] = TEXT("Hide");
const ICHAR     pcaActionShow[] = TEXT("Show");
const ICHAR     pcaActionDefault[] = TEXT("Default");
const ICHAR     pcaActionUndefault[] = TEXT("Undefault");

// names of dialog attributes
const ICHAR     pcaDialogAttributeKeyInt[]= TEXT("KeyInt");
const ICHAR     pcaDialogAttributeKeyString[] = TEXT("KeyString");
const ICHAR     pcaDialogAttributeText[] = TEXT("Text");
const ICHAR     pcaDialogAttributeCurrentControl[] = TEXT("CurrentControl");
const ICHAR     pcaDialogAttributeShowing[] = TEXT("Showing");
const ICHAR     pcaDialogAttributeRunning[] = TEXT("Running");
const ICHAR     pcaDialogAttributeModal[] = TEXT("Modal");
const ICHAR     pcaDialogAttributeSysModal[] = TEXT("SysModal");
const ICHAR     pcaDialogAttributePosition[] = TEXT("Position");
const ICHAR     pcaDialogAttributeWindowHandle[] = TEXT("WindowHandle");
const ICHAR     pcaDialogAttributeToolTip[] = TEXT("ToolTip");
const ICHAR     pcaDialogAttributeEventInt[] = TEXT("EventInt");
const ICHAR     pcaDialogAttributeArgument[] = TEXT("Argument");
const ICHAR     pcaDialogAttributeFullSize[] = TEXT("FullSize");
const ICHAR     pcaDialogAttributeError[] = TEXT("Error");
const ICHAR     pcaDialogAttributeKeepModeless[] = TEXT("KeepModeless");
const ICHAR     pcaDialogAttributePalette[] = TEXT("Palette");
const ICHAR     pcaDialogAttributeUseCustomPalette[] = TEXT("UseCustomPalette");
const ICHAR     pcaDialogAttributePreview[] = TEXT("Preview");
const ICHAR     pcaDialogAttributeAddingControls[] = TEXT("AddingControls");
const ICHAR     pcaDialogAttributeLocked[] = TEXT("Locked");
const ICHAR     pcaDialogAttributeInPlace[] = TEXT("InPlace");
const ICHAR     pcaDialogAttributeCancelButton[] = TEXT("CancelButton");
#ifdef ATTRIBUTES
const ICHAR     pcaDialogAttributeX[] = TEXT("X");
const ICHAR     pcaDialogAttributeY[] = TEXT("Y");
const ICHAR     pcaDialogAttributeWidth[] = TEXT("Width");
const ICHAR     pcaDialogAttributeHeight[] = TEXT("Height");
const ICHAR     pcaDialogAttributeRefCount[] = TEXT("RefCount");
const ICHAR     pcaDialogAttributeEventString[] = TEXT("EventString");
const ICHAR     pcaDialogAttributeControlsCount[] = TEXT("ControlsCount");
const ICHAR     pcaDialogAttributeControlsKeyInt[] = TEXT("ControlsKeyInt");
const ICHAR     pcaDialogAttributeControlsKeyString[] = TEXT("ControlsKeyString");
const ICHAR     pcaDialogAttributeControlsProperty[] = TEXT("ControlsProperty");
const ICHAR     pcaDialogAttributeControlsNext[] = TEXT("ControlsNext");
const ICHAR     pcaDialogAttributeControlsPrev[] = TEXT("ControlsPrev");
const ICHAR     pcaDialogAttributeHasControls[] = TEXT("HasControls");
const ICHAR     pcaDialogAttributeClientRect[] = TEXT("ClientRect");
const ICHAR     pcaDialogAttributeHelp[] = TEXT("Help");
const ICHAR     pcaDialogAttributeDefaultButton[] = TEXT("DefaultButton");
const ICHAR     pcaDialogAttributeRTLRO[] = TEXT("RTLRO");
const ICHAR     pcaDialogAttributeRightAligned[] = TEXT("RightAligned");
const ICHAR     pcaDialogAttributeLeftScroll[] = TEXT("LeftScroll");
#endif // ATTRIBUTES


// names of control attributes
const ICHAR     pcaControlAttributeText[] = TEXT("Text");
const ICHAR     pcaControlAttributeVisible[] = TEXT("Visible");
const ICHAR     pcaControlAttributeEnabled[] = TEXT("Enabled");
const ICHAR     pcaControlAttributeDefault[] = TEXT("Default");
const ICHAR     pcaControlAttributePropertyName[] =	TEXT("PropertyName");
const ICHAR     pcaControlAttributeIndirectPropertyName[] = TEXT("IndirectPropertyName");
const ICHAR     pcaControlAttributePosition[] = TEXT("Position");
const ICHAR     pcaControlAttributeWindowHandle[] = TEXT("WindowHandle");
const ICHAR     pcaControlAttributePropertyValue[] = TEXT("PropertyValue");
const ICHAR     pcaControlAttributeProgress[] = TEXT("Progress");
const ICHAR     pcaControlAttributeIndirect[] = TEXT("Indirect");
const ICHAR     pcaControlAttributeTransparent[] = TEXT("Transparent");
const ICHAR     pcaControlAttributeImage[] = TEXT("Image");
const ICHAR     pcaControlAttributeImageHandle[] = TEXT("ImageHandle");
const ICHAR     pcaControlAttributeBillboardName[] = TEXT("BillboardName");
const ICHAR     pcaControlAttributeIgnoreChange[] = TEXT("IgnoreChange");
const ICHAR     pcaControlAttributeTimeRemaining[] = TEXT("TimeRemaining");
const ICHAR     pcaControlAttributeScriptInProgress[] = TEXT("ScriptInProgress");
#ifdef ATTRIBUTES
const ICHAR     pcaControlAttributeRefCount[] = TEXT("RefCount");
const ICHAR     pcaControlAttributeKeyInt[] = TEXT("KeyInt");
const ICHAR     pcaControlAttributeKeyString[] = TEXT("KeyString");
const ICHAR     pcaControlAttributeX[] = TEXT("X");
const ICHAR     pcaControlAttributeY[] = TEXT("Y");
const ICHAR     pcaControlAttributeWidth[] = TEXT("Width");
const ICHAR     pcaControlAttributeHeight[] = TEXT("Height");
const ICHAR     pcaControlAttributeHelp[] =	TEXT("Help");
const ICHAR     pcaControlAttributeToolTip[] = TEXT("ToolTip");
const ICHAR     pcaControlAttributeContextHelp[] = TEXT("ContextHelp");
const ICHAR     pcaControlAttributeClientRect[] = TEXT("ClientRect");
const ICHAR     pcaControlAttributeOriginalValue[] = TEXT("OriginalValue");
const ICHAR     pcaControlAttributeInteger[] = TEXT("Integer");
const ICHAR     pcaControlAttributeLimit[] = TEXT("Limit");
const ICHAR     pcaControlAttributeItemsCount[] = TEXT("ItemsCount");
const ICHAR     pcaControlAttributeItemsValue[] = TEXT("ItemsValue");
const ICHAR     pcaControlAttributeItemsHandle[] = TEXT("ItemsHandle");
const ICHAR     pcaControlAttributeItemsText[] = TEXT("ItemsText");
const ICHAR     pcaControlAttributeItemsX[] = TEXT("ItemsX");
const ICHAR     pcaControlAttributeItemsY[] = TEXT("ItemsY");
const ICHAR     pcaControlAttributeItemsWidth[] = TEXT("ItemsWidth");
const ICHAR     pcaControlAttributeItemsHeight[] = TEXT("ItemsHeight");
const ICHAR     pcaControlAttributeSunken[] = TEXT("Sunken");
const ICHAR     pcaControlAttributePushLike[] = TEXT("PushLike");
const ICHAR     pcaControlAttributeBitmap[] = TEXT("Bitmap");
const ICHAR     pcaControlAttributeIcon[] = TEXT("Icon");
const ICHAR     pcaControlAttributeHasBorder[] = TEXT("HasBorder");
const ICHAR     pcaControlAttributeRTLRO[] = TEXT("RTLRO");
const ICHAR     pcaControlAttributeRightAligned[] = TEXT("RightAligned");
const ICHAR     pcaControlAttributeLeftScroll[] = TEXT("LeftScroll");
#endif // ATTRIBUTES



// names of dialog types
const ICHAR     pcaDialogTypeStandard[] = TEXT("Standard");

// names of control types
const ICHAR pcaControlTypePushButton[] = TEXT("PushButton");
const ICHAR pcaControlTypeText[] = TEXT("Text");
const ICHAR pcaControlTypeEdit[] = TEXT("Edit");
const ICHAR pcaControlTypeRadioButtonGroup[] = TEXT("RadioButtonGroup");
const ICHAR pcaControlTypeCheckBox[] = TEXT("CheckBox");
const ICHAR pcaControlTypeBitmap[] = TEXT("Bitmap");
const ICHAR pcaControlTypeListBox[] = TEXT("ListBox");
const ICHAR pcaControlTypeComboBox[] = TEXT("ComboBox");
const ICHAR pcaControlTypeProgressBar[] = TEXT("ProgressBar");
const ICHAR pcaControlTypeGroupBox[] = TEXT("GroupBox");
const ICHAR pcaControlTypeDirectoryCombo[] = TEXT("DirectoryCombo");
const ICHAR pcaControlTypeDirectoryList[] = TEXT("DirectoryList");
const ICHAR pcaControlTypePathEdit[] = TEXT("PathEdit");
const ICHAR pcaControlTypeVolumeSelectCombo[] = TEXT("VolumeSelectCombo");
const ICHAR pcaControlTypeScrollableText[] = TEXT("ScrollableText");
const ICHAR pcaControlTypeSelectionTree[] = TEXT("SelectionTree");
const ICHAR pcaControlTypeIcon[] = TEXT("Icon");
const ICHAR pcaControlTypeVolumeCostList[] = TEXT("VolumeCostList");
const ICHAR pcaControlTypeListView[] = TEXT("ListView");
const ICHAR pcaControlTypeBillboard[] = TEXT("Billboard");
const ICHAR pcaControlTypeMaskedEdit[] = TEXT("MaskedEdit");
const ICHAR pcaControlTypeLine[] = TEXT("Line");

// names of control events, these are control events that are specific to some control type
const ICHAR pcaControlEventDirectoryListUp[] = TEXT("DirectoryListUp");
const ICHAR pcaControlEventDirectoryListNew[] = TEXT("DirectoryListNew");
const ICHAR pcaControlEventDirectoryListOpen[] = TEXT("DirectoryListOpen");
const ICHAR pcaControlEventDirectoryListIgnoreChange[] = TEXT("IgnoreChange");
const ICHAR pcaControlEventSelectionDescription[] = TEXT("SelectionDescription");
const ICHAR pcaControlEventSelectionSize[] = TEXT("SelectionSize");
const ICHAR pcaControlEventSelectionPath[] = TEXT("SelectionPath");
const ICHAR pcaControlEventSelectionPathOn[] = TEXT("SelectionPathOn");
const ICHAR pcaControlEventSelectionBrowse[] = TEXT("SelectionBrowse");
const ICHAR pcaControlEventSelectionIcon[] = TEXT("SelectionIcon");
const ICHAR pcaControlEventSelectionAction[] = TEXT("SelectionAction");
const ICHAR pcaControlEventSelectionNoItems[] = TEXT("SelectionNoItems");


#endif // __HANDLER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\fdisvr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       fdisvr.h
//
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// fdisvr.h	-- shared definitions between the FDI Interface and FDI Server
//--------------------------------------------------------------------------------

#ifdef MAC
	#ifdef DEBUG
		#define AssertFDI(f) ((f) ? (void)0 : (void)FailAssertFDI(__FILE__, __LINE__))
		void FailAssertFDI(const char* szFile, int iLine);
	#else // SHIP
		#define AssertFDI(f)
	#endif
#else // WIN
	#define AssertFDI(f) Assert(f)
#endif // MAC-WIN


//////////////////////////////////////////////////////////////////////////////////
// This enum encodes the set of possible commands that can be sent to the 
// FDI Server process/thread from the FDI Interface object
//////////////////////////////////////////////////////////////////////////////////

enum FDIServerCommand
{
	fdicOpenCabinet,	// Open a cabinet
	fdicClose,			// Do any cleanup and close down the process/thread
	fdicExtractFile,	// Extract a file
	fdicContinue,		// Continue from either the fdirNeedNextCabinet or
						// fdirNotification server responses
	fdicNoCommand,		// NoCommand (Do nothing)
	fdicCancel,			// User wants to cancel the install
	fdicIgnore,			// User wants to ignore the last error and continue.
};

//////////////////////////////////////////////////////////////////////////////////
// This enum encodes the set of possible responses that the FDI Server may return
// to the FDI interface object
// For more detailed information on these responses, see FDI.H
//////////////////////////////////////////////////////////////////////////////////

enum FDIServerResponse 
{
	fdirSuccessfulCompletion,
		// One of (fdicOpenCabinet, fdicClose, fdicExtractFile) completed successfully
		// Action: None required.
	fdirClose,
		// A command to close the current cabinet has come through
		// Action: End the FDICopy loop successfully
	fdirCannotBreakExtractInProgress,
		// Tried to extract another file while a previous extraction 
		// hadn't completed.
		// Action: ERROR
	fdirNeedNextCabinet,
		// Need the next cabinet
		// Action: send fdicContinue command to continue processing the next cabinet
	fdirNoResponse,
		// No Response -- the FDI Interface object should never see this
		// Action: ERROR
	fdirCabinetNotFound,
		// Couldn't find requested cabinet
		// Action: ERROR (could be wrong disk)
	fdirNotACabinet,
		// Requested cabinet file was found but didn't have the cabinet signature
		// Action: ERROR
	fdirUnknownCabinetVersion,
		// Requested cabinet file has a version number the server can't handle
		// Action: ERROR
	fdirCorruptCabinet,
		// Requested cabinet file has corrupt data (checksum failure)
		// Action: ERROR
	fdirNotEnoughMemory,
		// Out of memory
		// Action: ERROR (request user to increase VM settings and try again, etc)
	fdirBadCompressionType,
		// Compression type not suppored by this version of FDI library
		// Action: ERROR (we're probably trying to decompress a cab with a new.
		//                unknown compression type)
	fdirTargetFile,
		// Couldn't create destination file when extracting
		// Action: ERROR (probably a disk I/O problem, or file is a directory, etc)
	fdirReserveMismatch,
		// Cabinet header reserve information corrupt, etc
		// Action: ERROR (probably a corrupt cabinet)
	fdirWrongCabinet,
		// Requested cabinet has correct file name, and is a cabinet, but is not the
		// one we want
		// Action: ERROR (wrong disk perhaps?)
	fdirUserAbort,
		// Any one of the callbacks returned -1. This should never happen during
		// normal operation.
		// Action: ERROR
	fdirMDIFail,
		// Decompressor failed to decompress compressed data
		// Action: ERROR (possible out of memory in decompressor or data corrupt, etc)
	fdirNotification,
		// The FDI Interface object simply passes this on to the caller;  This response
		// only exists so the UI may be updated smoothly.
		// Action: send the fdicContinue command to continue extracting the file
    fdirFileNotFound,
		// The requested file was not found in the cabinet
		// Action: ERROR (files requested out of order?)
	fdirCannotCreateTargetFile,
		// Can't create destination file we're extracting to
		// Action: ERROR (we don't have write permission to that file)
	fdirCannotSetAttributes,
		// Couldn't set the file attributes or couldn't close destination file
		// Action: ERROR (check that the file attributes passed in to ExtractFile(..)
		//                were correct and that nothing happened to the file in
		//				  between all our writes and the final close)
	fdirIllegalCommand,
		// Received an illegal command (ie. an ExtractFile(..) before an OpenCabinet(..))
		// Action: ERROR (check that the server was in the correct state for the particular
		//         command that was just sent, and that you sent a legal enum value)
	fdirDecryptionNotSupported,
		// The cabinet had encrypted info, and we don't support decryption.
		// Action: ERROR (Wrong version of Setup being used?)
	fdirUnknownFDIError,
		// FDI returned an error we don't understand.
		// Action: ERROR (Check that FDI.H matches the FDI.LIB we compiled with)
	fdirServerDied,
		// The FDI Server died.
		// Action: ERROR (this response is currently unused)
	fdirNoCabinetOpen,
		// fdicExtractFile command received, but no cabinet is open.  Either no OpenCabinet
		// command was sent, or the current cabinet was completely processed, but the 
		// caller was expecting to extract another file from that cabinet.
	fdirDiskFull,
		// Out of disk space on the destination volume.
	fdirDriveNotReady,
		// No disk in floppy drive.
	fdirDirErrorCreatingTargetFile,
		// Cannot create target file - directory of same name already exists.
	fdirUserIgnore,
		// User wants to ignore the last error and continue with the next file.
	fdirStreamReadError,
		// Error reading from stream cabinet
	fdirCabinetReadError,
		// Error reading from file cabinet
	fdirErrorWritingFile,
		// Error during pfnwrite callback
	fdirNetError,
		// Network error during read or write
	fdirMissingSignature,
		// The digital signature on the CAB was missing
	fdirBadSignature,
		// The digital signature on the CAB was invalid
};


//////////////////////////////////////////////////////////////////////////////////
// This struct contains the file attributes that are sent from the FDI Interface
// to the FDI Server.
//////////////////////////////////////////////////////////////////////////////////


struct FileAttributes
{
#ifdef WIN
	int	attr;		// 32-bit Win32 file attributes
#endif //WIN
#ifdef MAC
	OSType			type;		// Type
	OSType			creator;	// Creator
	unsigned short	fdFlags;	// Finder Flags
	unsigned long	dateTime;	// Date and Time
	int				attr;		// FAT attr (only H (bit 2)and R (bit 1))
								// We only use R to set the Locked status of a Mac file
#endif //MAC
};

enum icbtEnum
{
	icbtFileCabinet     = 1,
	icbtStreamCabinet   = 2,
	icbtNextEnum
};

//////////////////////////////////////////////////////////////////////////////////
// This contains all the shared data between the FDI Interface and the FDI Server
// During the FDI Server's initialization phase, the FDI Interface passes it a
// pointer to a single shared struct of this type.
//////////////////////////////////////////////////////////////////////////////////
#define FDIShared_BUFSIZE	256
struct FDIShared
{
	volatile FDIServerCommand  fdic;
	volatile FDIServerResponse fdir;
	ICHAR					achDiskName[FDIShared_BUFSIZE];
	ICHAR					achCabinetName[FDIShared_BUFSIZE];
	ICHAR					achCabinetPath[FDIShared_BUFSIZE];
	ICHAR					achFileSourceName[FDIShared_BUFSIZE];
	ICHAR					achFileDestinationPath[FDIShared_BUFSIZE];
	FileAttributes			fileAttributes;
	int                     cbNotification; // Current notification granularity, 0 to suppress notifications
	int                     cbNotifyPending;

	IMsiStorage*			piStorage;
	icbtEnum                icbtCabinetType;
	int						iCabDriveType;
	int						iDestDriveType;

	int							fPendingExtract;
		// If we've received an fdicExtractFile command and we haven't finished
		// decompressing the file, then this will be set to 1, else it will be 0
	HANDLE hClientToken;
	HANDLE hImpersonationToken;
	IAssemblyCacheItem* piASM;

	bool   fManifest;

	// digital signature information
	Bool                    fSignatureRequired;
	IMsiStream*             piSignatureCert;
	IMsiStream*             piSignatureHash;
	HRESULT                 hrWVT;

	bool                    fServerIsImpersonated;
	LPSECURITY_ATTRIBUTES   pSecurityAttributes;
};


Bool StartFdiImpersonating(bool fNonWrapperCall=true);
void StopFdiImpersonating(bool fNonWrapperCall=true);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\debugerr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 2001
//
//  File:       debugerr.h
//
//--------------------------------------------------------------------------

IShipError(imsgFatalExit,                                      0/*imtFatalExit*/) // only used if error on server
IShipError(imsgError,                                          1/*imtError*/)    // log and display
IShipError(imsgWarning,                                        2/*imtWarning*/)  // log and display
IShipError(imsgUser,                                           3/*imtUser*/)               // display only
IShipError(imsgInfo,          4/*imtInfo*/)     // log only
IShipError(imsgDebugError,    5/*imtFilesInUse*/)  // idbgXXX
//     imsgFilesinUse,    5/*imtFilesInUse*/
IShipError(imsgResolveSource, 6/*imtResolveSource*/) // not used
IShipError(imsgOutOfSpace,    7/*imtOutOfDiskSpace*/)
IShipError(imsgActionStart,   8/*imtActionStart*/) 
IShipError(imsgDialogCaption, 9/*imtActionData*/)
//     imsgActionData,    9/*imtActionData*/    (action data template stored in Action table)
IShipError(imsgDefaultError, 10/*imtProgress*/)  // message not in table
//     imsgProgress,     10/*imtProgress*/      (progress messages not displayed or logged)
IShipError(imsgCommonData,   11/*imtCommonData*/)  // log only

// Log strings, not displayed
IShipError(imsgLogHeader,    12/*imtLogHeader*/)
IShipError(imsgLogTrailer,   13/*imtLogTrailer*/)
IShipError(imsgActionStarted,14/*imtActionStarted*/)
IShipError(imsgActionEnded,  15/*imtActionEnded*/)

// UI messages that are cached by the message processor
IShipError(imsgTimeRemaining,16/*imtTimeRemaining*/)
IShipError(imsgOutOfMemory,  17/*imtOutOfMemory*/)
IShipError(imsgTimedOut,     18/*imtTimedOut*/)
IShipError(imsgException,    19/*imtException*/)

IShipError(imsgBannerText,   20/*imtBannerText*/)
IShipError(imsgScriptInProgress,21/*imtScriptInProgress*/)

IShipError(imsgUpgradeRemoveTimeRemaining,22/*imtUpgradeRemoveTimeRemaining*/)
IShipError(imsgUpgradeRemoveScriptInProgress,23/*imtUpgradeRemoveScriptInProgress*/)

// General messages, don't have associated imt value
IShipError(imsgInstallSucceeded,                     32)
IShipError(imsgInstallFailed,                        33)

// imsgServices = 1100
IShipError(imsgOpenFileStream,           imsgServices + 1)

// imsgFile     = 1300
IShipError(imsgDirErrorOpeningFileForWrite,  imsgFile +  1)
IShipError(imsgPromptForDisk,                imsgFile +  2)
IShipError(imsgSystemDeniedAccess,           imsgFile +  3)
IShipError(imsgErrorWritingToFile,           imsgFile +  4)
IShipError(imsgErrorReadingFromFile,         imsgFile +  5)
IShipError(imsgSharingViolation,             imsgFile +  6)
IShipError(imsgDiskFull,                     imsgFile +  7)
IShipError(imsgErrorSourceFileNotFound,      imsgFile +  8)
IShipError(imsgErrorOpeningFileForRead,      imsgFile +  9)
IShipError(imsgErrorOpeningFileForWrite,     imsgFile + 10)
IShipError(imsgErrorOpeningCabinet,          imsgFile + 11)
IShipError(imsgFileErrorCreatingDir,         imsgFile + 12)
IShipError(imsgVolumeDoesNotExist,           imsgFile + 13)
IShipError(imsgPathNotAccessible,            imsgFile + 14)
IShipError(imsgDirectoryNotWritable,         imsgFile + 15)
IShipError(imsgNetErrorReadingFromFile,      imsgFile + 16)
IShipError(imsgErrorCreatingDir,             imsgFile + 17)
IShipError(imsgNetErrorCreatingDir,          imsgFile + 18)
IShipError(imsgNetErrorOpeningCabinet,       imsgFile + 19)
IShipError(imsgPathNameTooLong,              imsgFile + 20)
IShipError(imsgAccessToFileDenied,           imsgFile + 21)
IShipError(imsgErrorFileNameLength,          imsgFile + 22)
IShipError(imsgFileNameHasReservedWords,     imsgFile + 23)
IShipError(imsgFileNameHasReservedChars,     imsgFile + 24)
IShipError(imsgInvalidShortFileNameFormat,   imsgFile + 25)
IShipError(imsgGetFileSecurity,              imsgFile + 26)
IShipError(imsgInvalidDrive,                 imsgFile + 27)
IShipError(imsgApplyPatchError,              imsgFile + 28)
IShipError(imsgCABSignatureMissing,          imsgFile + 29)
IShipError(imsgCABSignatureRejected,         imsgFile + 30)
IShipError(imsgOpBadCRCAfterCopy,            imsgFile + 31)
IShipError(imsgOpBadCRCAfterMove,            imsgFile + 32)
IShipError(imsgOpBadCRCAfterPatch,           imsgFile + 33)
IShipError(imsgFileNotInCabinet,             imsgFile + 34)
IShipError(imsgCorruptCabinet,               imsgFile + 35)
IShipError(imsgErrorCreatingTempFileName,    imsgFile + 36)

// imsgRegistry = 1400
IShipError(imsgCreateKeyFailed,           imsgRegistry + 1)
IShipError(imsgOpenKeyFailed,             imsgRegistry + 2)
IShipError(imsgRemoveValueFailed,         imsgRegistry + 3)
IShipError(imsgRemoveKeyFailed,           imsgRegistry + 4)
IShipError(imsgGetValueFailed,            imsgRegistry + 5)
IShipError(imsgSetValueFailed,            imsgRegistry + 6)
IShipError(imsgGetValueEnumeratorFailed,  imsgRegistry + 7)
IShipError(imsgGetSubKeyEnumeratorFailed, imsgRegistry + 8)
IShipError(imsgSecurityFailed,            imsgRegistry + 9)
IShipError(imsgOutOfRegistrySpace,        imsgRegistry +10)

// imsgConfig   = 1500
IShipError(imsgInstallInProgress,             imsgConfig + 0)
IShipError(imsgErrorAccessingSecuredData,     imsgConfig + 1)
IShipError(imsgDiffUserInstallInProgress,     imsgConfig + 2)
IShipError(imsgDiffUserInstallInProgressAfterReboot, imsgConfig + 3)

// imsgAction   = 1600
IShipError(imsgOutOfDiskSpace,              imsgAction +  1)
IShipError(imsgConfirmCancel,               imsgAction +  2)
IShipError(imsgFileInUseLog,                imsgAction +  3)
IShipError(imsgInstallBlocked,              imsgAction +  4)
IShipError(imsgOutOfRbDiskSpace,            imsgAction +  5)
IShipError(imsgErrorCreateNetPath,          imsgAction +  6)
IShipError(imsgFileInUseDescription,        imsgAction +  7)
IShipError(imsgCCPSearchFailed,             imsgAction +  8)
IShipError(imsgCreateAclFailed,             imsgAction +  9)

// imsgEngine   = 1700
IShipError(imsgInvalidPID,			imsgEngine +  1)
IShipError(imsgRebootNow,			imsgEngine +  2)
IShipError(imsgRebootAtEnd,			imsgEngine +  3)
IShipError(imsgOtherInstallSuspended,		imsgEngine +  4)
IShipError(imsgResumeWithDifferentOptions,	imsgEngine +  5)
IShipError(imsgSourceResolutionFailed,		imsgEngine +  6)
IShipError(imsgEventLogInstallSuccess,		imsgEngine +  7)
IShipError(imsgEventLogInstallFailed,		imsgEngine +  8)
IShipError(imsgEventLogTemplate,		imsgEngine +  9)
IShipError(imsgRestoreOrContinue,		imsgEngine + 10)
IShipError(imsgScriptWriteError,		imsgEngine + 11)
IShipError(imsgRollbackScriptError,		imsgEngine + 12)
IShipError(imsgNestedInstallInitError,		imsgEngine + 13)
IShipError(imsgUpgradeRemovalInitError,		imsgEngine + 14)
IShipError(imsgSRRestorePointInstall,		imsgEngine + 15)
IShipError(imsgSRRestorePointConfigure,		imsgEngine + 16)
IShipError(imsgSRRestorePointRemove,		imsgEngine + 17)
IShipError(imsgMsiFileRejected,			imsgEngine + 18)
IShipError(imsgServiceConnectionFailure,	imsgEngine + 19)
IShipError(imsgCustomActionScriptFailed,	imsgEngine + 20)
IShipError(imsgCustomActionCreateExe,		imsgEngine + 21)
IShipError(imsgCustomActionExeFailed,		imsgEngine + 22)
IShipError(imsgCustomActionLoadLibrary,		imsgEngine + 23)
IShipError(imsgEventLogUninstallSuccess,	imsgEngine + 24)
IShipError(imsgEventLogUninstallFailed,		imsgEngine + 25)
IShipError(imsgEventLogAdvertiseSuccess,	imsgEngine + 26)
IShipError(imsgEventLogAdvertiseFailed,		imsgEngine + 27)
IShipError(imsgEventLogConfigurationSuccess,	imsgEngine + 28)
IShipError(imsgEventLogConfigurationFailed,	imsgEngine + 29)
IShipError(imsgUserUninstallDisallowed,		imsgEngine + 30)
IShipError(imsgSourceResolutionFailedCSOS,	imsgEngine + 31)
IShipError(imsgRebootWithWarning,			imsgEngine + 32)

// imsgHandler  = 1800
IShipError(imsgNotAValidPath,               imsgHandler + 1)
IShipError(imsgOutOfMemoryUI,               imsgHandler + 2)
IShipError(imsgDiskNotInDrive,              imsgHandler + 3)
IShipError(imsgVolumeMissing,               imsgHandler + 4)
IShipError(imsgPathDoesNotExist,            imsgHandler + 5)
IShipError(imsgPathNotReadable,             imsgHandler + 6)
IShipError(imsgInvalidTargetFolder,         imsgHandler + 7)  

// imsgExecute  = 1900
IShipError(imsgOpFileCopyStreamReadErr,     imsgExecute + 1)
IShipError(imsgOpMoveFileOnReboot,          imsgExecute + 2)
IShipError(imsgOpDeleteFileOnReboot,        imsgExecute + 3)
IShipError(imsgOpRegSelfRegFailed,          imsgExecute + 4)
IShipError(imsgOpRegSelfUnregFailed,        imsgExecute + 5)
IShipError(imsgOpPackageCache,              imsgExecute + 6)
IShipError(imsgOpRegFont,                   imsgExecute + 7)
IShipError(imsgOpUnregFont,                 imsgExecute + 8)
IShipError(imsgOpShortcutCreate,            imsgExecute + 9)
IShipError(imsgOpShortcutRemove,            imsgExecute + 10)
IShipError(imsgOpRegisterTypeLibrary,       imsgExecute + 11)
IShipError(imsgOpUnregisterTypeLibrary,     imsgExecute + 12)
IShipError(imsgOpUpdateIni,                 imsgExecute + 13)
IShipError(imsgOpScheduleRebootReplace,     imsgExecute + 14)
IShipError(imsgODBCRemoveDriverManager,     imsgExecute + 15)
IShipError(imsgODBCInstallDriverManager,    imsgExecute + 16)
IShipError(imsgODBCRemoveDriver,            imsgExecute + 17)
IShipError(imsgODBCInstallDriver,           imsgExecute + 18)
IShipError(imsgODBCDataSource,              imsgExecute + 19)
IShipError(imsgOpStartServiceFailed,        imsgExecute + 20)
IShipError(imsgOpStopServiceFailed,	       imsgExecute + 21)
IShipError(imsgOpDeleteServiceFailed,       imsgExecute + 22)
IShipError(imsgOpInstallServiceFailed,      imsgExecute + 23)
IShipError(imsgUpdateEnvironment,	          imsgExecute + 24)
IShipError(imsgInsufficientUserPrivileges,  imsgExecute + 25)
IShipError(imsgOpSetFileSecurity,           imsgExecute + 26)
IShipError(imsgComPlusNotInstalled,         imsgExecute + 27)
IShipError(imsgComPlusCantInstallApp,       imsgExecute + 28)
IShipError(imsgComPlusCantRemoveApp,        imsgExecute + 29)
IShipError(imsgServiceChangeDescriptionFailed, imsgExecute + 30)
IShipError(imsgCannotUpdateProtectedFile,   imsgExecute + 31)
IShipError(imsgErrorUpdatingProtectedFile,  imsgExecute + 32)
IShipError(imsgSFCInstallProtectedFilesFailed, imsgExecute + 33)
IShipError(imsgUserInstallsDisabled,        imsgExecute + 34)
IShipError(imsgAssemblyInstallationError,   imsgExecute + 35)
IShipError(imsgAssemblyNotStronglyNamed,	imsgExecute + 36)
IShipError(imsgAssemblyNotSignedOrBadCatalog,	imsgExecute + 37)
IShipError(imsgAssemblyMissingModule,		imsgExecute + 38)



// idbgHost = 2000
IDebugError(idbgDebugErrorPrefix,      idbgHost     +  0, "DEBUG: Error [1]:  ")

// idbgServices = 2100
IDebugError(idbgErrorShortCutUnsupported, idbgServices + 1, "Shortcuts not supported by the OS")
IDebugError(idbgInvalidIniAction,         idbgServices + 2, "Invalid .INI action: [2]")
IDebugError(idbgMissingShellFolder,       idbgServices + 3, "Could not resolve path for shell folder [2].")
IDebugError(idbgErrorWritingIniFile,      idbgServices + 4, "Writing .INI file: [3]: System error: [2]")
IDebugError(idbgErrorCreatingShortCut,    idbgServices + 5, "Shortcut Creation [3] Failed. System error: [2]")
IDebugError(idbgErrorDeletingShortCut,    idbgServices + 6, "Shortcut Deletion [3] Failed. System error: [2]")
IDebugError(idbgRegisterTypeLibrary,      idbgServices + 7, "Error [3] registering type library [2].")
IDebugError(idbgUnregisterTypeLibrary,    idbgServices + 8, "Error [3] unregistering type library [2].")
IDebugError(idbgErrorSectionMissing,      idbgServices + 9, "Section missing for INI action.")
IDebugError(idbgErrorKeyMissing,          idbgServices + 10,"Key missing for INI action.")
IDebugError(idbgGetPerfDataFailed,        idbgServices + 11,"Detection of running apps failed, could not get perf. data. Reg operation returned : [2].")
IDebugError(idbgGetPerfIdxs,              idbgServices + 12,"Detection of running apps failed, could not get perf. index.Reg operation returned : [2].")
IDebugError(idbgGetFileUsageFailed,       idbgServices + 13,"Detection of running apps failed.")

// idbgDatabase = 2200
IDebugError(idbgDbConstructor,         idbgDatabase +  0, "Database: [2]. Database object creation failed, mode = [3]")
IDebugError(idbgDbInitMemory,          idbgDatabase +  1, "Database: [2]. Initialization failed, out of memory")
IDebugError(idbgDbDataMemory,          idbgDatabase +  2, "Database: [2]. Data access failed, out of memory")
IDebugError(idbgDbOpenStorage,         idbgDatabase +  3, "Database: [2]. Cannot open database file. System error [3]")
IDebugError(idbgDbTableDefined,        idbgDatabase +  4, "Database: [2]. Table already exists: [3]")
IDebugError(idbgDbTableUndefined,      idbgDatabase +  5, "Database: [2]. Table does not exist: [3]")
IDebugError(idbgDbDropTable,           idbgDatabase +  6, "Database: [2]. Table could not be dropped: [3]")
IDebugError(idbgDbIntentViolation,     idbgDatabase +  7, "Database: [2]. Intent violation")
IDebugError(idbgDbParamCount,          idbgDatabase +  8, "Database: [2]. Insufficient parameters for Execute")
IDebugError(idbgDbWrongState,          idbgDatabase +  9, "Database: [2]. Cursor in invalid state")
IDebugError(idbgDbUpdateBadType,       idbgDatabase + 10, "Database: [2]. Invalid update data type in column [3]")
IDebugError(idbgDbTableCreate,         idbgDatabase + 11, "Database: [2]. Could not create database table [3]")
IDebugError(idbgDbNotWritable,         idbgDatabase + 12, "Database: [2]. Database not in writable state")
IDebugError(idbgDbCommitTables,        idbgDatabase + 13, "Database: [2]. Error saving database tables")
IDebugError(idbgDbExportFile,          idbgDatabase + 14, "Database: [2]. Error writing export file: [3]")
IDebugError(idbgDbImportFileOpen,      idbgDatabase + 15, "Database: [2]. Cannot open import file: [3]")
IDebugError(idbgDbImportFileRead,      idbgDatabase + 16, "Database: [2]. Import file format error: [3], Line [4]")
IDebugError(idbgCreateOutputDb,        idbgDatabase + 17, "Database: [2]. Wrong state to CreateOutputDatabase [3].")
IDebugError(idbgDbNoTableName,         idbgDatabase + 18, "Database: [2]. Table name not supplied.")
IDebugError(idbgDbInvalidFormat,       idbgDatabase + 19, "Database: [2]. Invalid Installer database format")
IDebugError(idbgDbInvalidData,         idbgDatabase + 20, "Database: [2]. Invalid row/field data")
IDebugError(idbgDbCodepageConflict,    idbgDatabase + 21, "Database: [2]. Codepage conflict in import file: [3].")
IDebugError(idbgTransCodepageConflict, idbgDatabase + 22, "Database: [2]. Transform or merge codepage [3] differs from database codepage [4].")
IDebugError(idbgTransDatabasesAreSame, idbgDatabase + 23, "Database: [2]. Databases are the same. No transform generated.")
IDebugError(idbgDbCorrupt,                   idbgDatabase + 24, "Database: [2]. GenerateTransform: Database corrupt. Table: [3]")
IDebugError(idbgDbTransformTempTable,        idbgDatabase + 25, "Database: [2]. Transform: Cannot transform a temporary table. Table: [3]")
IDebugError(idbgDbTransformFailed,           idbgDatabase + 26, "Database: [2]. Transform failed.")
IDebugError(idbgDbQueryInvalidIdentifier,    idbgDatabase + 27, "Database: [2]. Invalid identifier '[3]' in SQL query: [4]")
IDebugError(idbgDbQueryUnknownTable,         idbgDatabase + 28, "Database: [2]. Unknown table '[3]' in SQL query: [4]")
IDebugError(idbgDbQueryLoadTableFailed,      idbgDatabase + 29, "Database: [2]. Could not load table '[3]' in SQL query: [4]")
IDebugError(idbgDbQueryTableRepeated,        idbgDatabase + 30, "Database: [2]. Repeated table '[3]' in SQL query: [4]")
IDebugError(idbgDbQueryMissingCloseParen,    idbgDatabase + 31, "Database: [2]. Missing ')' in SQL query: [3]")
IDebugError(idbgDbQueryUnexpectedToken,      idbgDatabase + 32, "Database: [2]. Unexpected token '[3]' in SQL query: [4]")
IDebugError(idbgDbQueryNoSelectColumns,      idbgDatabase + 33, "Database: [2]. No columns in SELECT clause in SQL query: [3]")
IDebugError(idbgDbQueryNoOrderByColumns,     idbgDatabase + 34, "Database: [2]. No columns in ORDER BY clause in SQL query: [3]")
IDebugError(idbgDbQueryUnknownColumn,        idbgDatabase + 35, "Database: [2]. Column '[3]' not present or ambiguous in SQL query: [4]")
IDebugError(idbgDbQueryInvalidOperator,      idbgDatabase + 36, "Database: [2]. Invalid operator '[3]' in SQL query: [4]")
IDebugError(idbgDbQuerySpec,                 idbgDatabase + 37, "Database: [2]. Invalid or missing query string: [3]")
IDebugError(idbgDbMissingFromClause,         idbgDatabase + 38, "Database: [2]. Missing FROM clause in SQL query: [3]")
IDebugError(idbgDbQueryInsufficentValues,    idbgDatabase + 39, "Database: [2]. Insufficent values in INSERT SQL stmt")
IDebugError(idbgDbQueryNoUpdateColumns,      idbgDatabase + 40, "Database: [2]. Missing update columns in UPDATE SQL stmt")
IDebugError(idbgDbQueryNoInsertColumns,      idbgDatabase + 41, "Database: [2]. Missing insert columns in INSERT SQL stmt")
IDebugError(idbgDbQueryRepeatColumn,         idbgDatabase + 42, "Database: [2]. Column '[3]' repeated")
IDebugError(idbgDbQueryNoPrimaryColumns,     idbgDatabase + 43, "Database: [2]. No primary columns defined for table creation")
IDebugError(idbgDbQueryInvalidType,          idbgDatabase + 44, "Database: [2]. Invalid type specifier '[3]' in SQL query [4].")
IDebugError(idbgStgStatFailed,               idbgDatabase + 45, "IStorage::Stat failed with error [3]")
IDebugError(idbgTransInvalidFormat,          idbgDatabase + 46, "Database: [2]. Invalid Installer transform format.")
IDebugError(idbgTransStreamError,            idbgDatabase + 47, "Database: [2] Transform stream read/write failure.")
IDebugError(idbgTransMergeDifferentColTypes, idbgDatabase + 48, "Database: [2] GenerateTransform/Merge: Column type in base table doesn't match reference table. Table: [3] Col #: [4]")
IDebugError(idbgTransExcessBaseCols,         idbgDatabase + 49, "Database: [2] GenerateTransform: More columns in base table than in reference table. Table: [3]")
IDebugError(idbgTransAddExistingRow,         idbgDatabase + 50, "Database: [2] Transform: Cannot add existing row. Table: [3]")
IDebugError(idbgTransDelNonExistingRow,      idbgDatabase + 51, "Database: [2] Transform: Cannot delete row that doesn't exist. Table: [3]")
IDebugError(idbgTransAddExistingTable,       idbgDatabase + 52, "Database: [2] Transform: Cannot add existing table. Table: [3]")
IDebugError(idbgTransDelNonExistingTable,    idbgDatabase + 53, "Database: [2] Transform: Cannot delete table that doesn't exist. Table: [3]")
IDebugError(idbgTransUpdNonExistingRow,      idbgDatabase + 54, "Database: [2] Transform: Cannot update row that doesn't exist. Table: [3]")
IDebugError(idbgTransDuplicateCol,           idbgDatabase + 55, "Database: [2] Transform: Column with this name already exists. Table: [3] Col: [4]")
IDebugError(idbgTransMergeDifferentKeyCount, idbgDatabase + 56, "Database: [2] GenerateTransform/Merge: Number of primary keys in base table doesn't match reference table. Table: [3]")
IDebugError(idbgDbTableReadOnly,             idbgDatabase + 57, "Database: [2]. Intent to modify read only table: [3]")
IDebugError(idbgParamMismatch,               idbgDatabase + 58, "Database: [2]. Type mismatch in parameter: [3]")
IDebugError(idbgDbUpdateFailed,              idbgDatabase + 59, "Database: [2] Table(s) Update failed")
IDebugError(idbgStgCopyTo,                   idbgDatabase + 60, "Storage CopyTo failed. System error: [3]")
IDebugError(idbgStgRemoveElement,            idbgDatabase + 61, "Could not remove stream [2]. System error: [3]")
IDebugError(idbgStgStreamMissing,            idbgDatabase + 62, "Stream does not exist: [2]. System error: [3]")
IDebugError(idbgStgOpenStream,               idbgDatabase + 63, "Could not open stream [2]. System error: [3]")
IDebugError(idbgStgRemoveStream,             idbgDatabase + 64, "Could not remove stream [2]. System error: [3]")
IDebugError(idbgStgCommit,                   idbgDatabase + 65, "Could not commit storage. System error: [3]")
IDebugError(idbgStgRollback,                 idbgDatabase + 66, "Could not rollback storage. System error: [3]")
IDebugError(idbgStgDelete,                   idbgDatabase + 67, "Could not delete storage [2]. System error: [3]")
IDebugError(idbgMergeFailuresReported,        idbgDatabase + 68, "Database: [2]. Merge: There were merge conflicts reported in [3] tables")
IDebugError(idbgMergeDifferentColumnCount,    idbgDatabase + 69, "Database: [2]. Merge: The column count differed in the '[3]' table of the two databases")
IDebugError(idbgTransMergeDifferentColNames,  idbgDatabase + 70, "Database: [2]. GenerateTransform/Merge: Column name in base table doesn't match reference table. Table: [3] Col #: [4]")
IDebugError(idbgTransformSummaryError,        idbgDatabase + 71, "SummaryInformation write for transform failed")
IDebugError(idbgMergeBaseDatabaseNotWritable, idbgDatabase + 72, "Database: [2]. MergeDatabase will not write any changes because the database is open read-only.")
IDebugError(idbgMergeRefDbSameAsBaseDb,       idbgDatabase + 73, "Database: [2]. MergeDatabase:  A reference to the base database was passed as the reference database.")
IDebugError(idbgMergeUnableReportFailures,    idbgDatabase + 74, "Database: [2]. MergeDatabase: Unable to write errors to Error table.  Could be due to a non-nullable column in a predefined Error table.")
IDebugError(idbgDbQueryInvalidOperation,     idbgDatabase + 75, "Database: [2]. Specified Modify [3] operation invalid for table joins.")
IDebugError(idbgDbCodepageNotSupported,idbgDatabase + 76, "Database: [2]. Codepage [3] not supported by the system.")
IDebugError(idbgDbSaveTableFailure,    idbgDatabase + 77, "Database: [2]. Failed to save table [3].")
IDebugError(idbgDbQueryExceedExpressionLimit,idbgDatabase + 78, "Database: [2]. Exceeded number of expressions limit of 32 in WHERE clause of SQL query: [3].")
IDebugError(idbgTransformTooManyBaseColumns,  idbgDatabase + 79, "Database: [2] Transform: Too many columns in base table [3]")
IDebugError(idbgDbColumnCreate,        idbgDatabase + 80, "Database: [2]. Could not create column [3] for table [4]")
IDebugError(idbgStgRenameElement,            idbgDatabase + 81, "Could not rename stream [2]. System error: [3]")
IDebugError(idbgStgInvalidStreamName,        idbgDatabase + 82, "Stream name invalid [2].")

// idbgFile   = 2300
IDebugError(idbgPatchNotify,    /* Info */    idbgFile +  2, "Patch notify: [2] bytes patched to far.")
IDebugError(idbgErrorGettingVolInfo,          idbgFile +  3, "Error getting volume info. GetLastError: [2]")
IDebugError(idbgErrorGettingDiskFreeSpace,    idbgFile +  4, "Error getting disk free space. GetLastError: [2]. Volume: [3]")
IDebugError(idbgWaitForPatchThread,           idbgFile +  5, "Error waiting for patch thread. GetLastError: [2].")
IDebugError(idbgCreatePatchThread,            idbgFile +  6, "Could not create thread for patch application. GetLastError: [2].")
IDebugError(idbgFileKeyIsNull,                idbgFile +  7, "Source file key name is null.")
IDebugError(idbgFileNameIsNull,               idbgFile +  8, "Destination File Name is Null")
IDebugError(idbgPatchInProgress,              idbgFile +  9, "Attempting to patch file [2] when patch already in progress.")
IDebugError(idbgNoPatchInProgress,            idbgFile + 10, "Attempting to continue patch when no patch is in progress.")
IDebugError(idbgMissingPathSeparator,         idbgFile + 15,"Missing Path Separator: [2]")
IDebugError(idbgFileDoesNotExist,             idbgFile + 18,"File does not exist: [2]")
IDebugError(idbgErrorSettingFileAttrib,       idbgFile + 19,"Error setting file attribute: [3] GetLastError: [2]")
IDebugError(idbgFileNotWritable,              idbgFile + 20,"File not writable: [2]")
IDebugError(idbgErrorCreatingFile,            idbgFile + 21,"Error creating file: [2]")
IDebugError(idbgUserCancelled,                idbgFile + 22,"User cancelled")
IDebugError(idbgInvalidFileAttribute,         idbgFile + 23,"Invalid File Attribute")
IDebugError(idbgErrorOpeningFile,             idbgFile + 24,"Could not open file: [3] GetLastError: [2]")
IDebugError(idbgErrorGettingFileTime,         idbgFile + 25,"Could not get file time for file: [3] GetLastError: [2]")
IDebugError(idbgErrorInFileToDosDateTime,     idbgFile + 26,"Error in FileToDosDateTime.")
IDebugError(idbgErrorRemovingDir,             idbgFile + 27,"Could not remove directory: [3] GetLastError: [2]")
IDebugError(idbgErrorGettingFileVerInfo,      idbgFile + 28,"Error getting file version info for file: [2]")
IDebugError(idbgErrorDeletingFile,            idbgFile + 29,"Error deleting file: [3]. GetLastError: [2]")
IDebugError(idbgErrorGettingFileAttrib,       idbgFile + 30,"Error getting file attributes: [3]. GetLastError: [2]")
IDebugError(idbgMissingProcAddr,              idbgFile + 31,"Error loading library [2] or finding entry point [3]")
IDebugError(idbgErrorInGetFileAttributes,     idbgFile + 32,"Error getting file attributes. GetLastError: [2]")
IDebugError(idbgErrorSettingFileAttributes,   idbgFile + 33,"Error setting file attributes. GetLastError: [2]")
IDebugError(idbgErrorConvertFileTimeToLocalTime,idbgFile + 34,"Error converting file time to local time for file: [3]. GetLastError: [2]")
IDebugError(idbgNotParent,											idbgFile + 35,"Path: [2] is not a parent of [3]")
IDebugError(idbgErrorClosingFile,								idbgFile + 37,"Could not close file: [3] GetLastError: [2]")
IDebugError(idbgErrorUpdatingResource,							idbgFile + 38,"Could not update resource for file: [3] GetLastError: [2]")
IDebugError(idbgErrorSettingFileTime,							idbgFile + 39,"Could not set file time for file: [3] GetLastError: [2]")
IDebugError(idbgErrorMissingResource,							idbgFile + 40,"Could not update resource for file: [3], Missing Resource")
IDebugError(idbgErrorTooBigResource,							idbgFile + 41,"Could not update resource for file: [3], Resource too large")
IDebugError(idbgErrorTimeStamp,									idbgFile + 42,"Could not update resource for file: [3] GetLastError: [2]")
IDebugError(idbgErrorEmptyPath,									idbgFile + 43,"Specified path is empty.")
IDebugError(idbgErrorImageFileAbsent,							idbgFile + 44, "Could not find required file IMAGEHLP.DLL to validate file:[2]")
IDebugError(idbgErrorNoChecksum,									idbgFile + 45,"[2]: File does not contain a valid checksum value.")
IDebugError(idbgErrorOutOfMemory,								idbgFile + 46,"Out of memory.")
IDebugError(idbgUserIgnore,										idbgFile + 47, "User Ignore")
IDebugError(idbgStreamReadError,									idbgFile + 48, "Error attempting to read from cabinet stream.")
IDebugError(idbgCopyResumedWithDifferentInfo,				idbgFile + 49, "Copy Resumed With Different Info")
IDebugError(idbgFDIServerError,									idbgFile + 50, "FDI Server Error")
IDebugError(idbgErrorInitializingFDI,							idbgFile + 52, "Couldn't initialize cabinet file server. The required file 'Cabinet.dll' may be missing.")
IDebugError(idbgNotACabinet,										idbgFile + 53, "Not a cabinet")
IDebugError(idbgCannotHandleCabinet,							idbgFile + 54, "Cannot handle cabinet")
IDebugError(idbgStreamCabinetError,								idbgFile + 56, "Couldn't locate cabinet in stream: [2].")
IDebugError(idbgCannotSetAttributes,							idbgFile + 57, "Cannot set attributes")
IDebugError(idbgFileInUseError,									idbgFile + 58, "Error determining whether file is in-use: [3]. GetLastError: [2]")
IDebugError(idbgFDICannotCreateTargetFile,					idbgFile + 59, "Unable to create the target file - file may be in use.")
IDebugError(idbgCopyNotify,      /* Info */					idbgFile + 60, "progress tick.")
IDebugError(idbgNeedNextCabinet, /* Info */					idbgFile + 61, "Need next cabinet.")
IDebugError(idbgInvalidPath,										idbgFile + 62, "Folder not found: [2]")
IDebugError(idbgErrorEnumSubPaths,								idbgFile + 63, "Could not enumerate subfolders for folder: [2]")
IDebugError(idbgErrorBadCreateCopierEnum,						idbgFile + 64, "Bad enumeration constant in CreateCopier call.")
IDebugError(idbgErrorBindImage,									idbgFile + 65, "Could not BindImage exe file [2]")
IDebugError(idbgUserFailure,										idbgFile + 66, "User Failure")
IDebugError(idbgUserAbort,											idbgFile + 67, "User Abort.")
IDebugError(idbgGetResourceInformationFailed,				idbgFile + 68, "Failed to get network resource information. Error [2], network path [3].{ Extended error: network provider [5], error code [4], error description [6].}")
IDebugError(idbgInvalidChecksum,									idbgFile + 70,"Invalid CRC checksum value for [2] file.{{ Its header says [3] for checksum, its computed value is [4].}}")
IDebugError(idbgCabinetNotFound,									idbgFile + 76, "Cabinet not found.")
IDebugError(idbgErrorOpeningFileForRead,						idbgFile + 79, "Error opening file for read: [3] GetLastError: [2]")
IDebugError(idbgErrorOpeningFileForWrite,						idbgFile + 80, "Error opening file for write: [3] GetLastError: [2]")
IDebugError(idbgDirDoesNotExist,									idbgFile + 81, "Directory does not exist: [2]")
IDebugError(idbgDriveNotReady,									idbgFile + 82, "Drive not ready: [2]")

// idbgRegistry = 2400
IDebugError(idbg64bitRegOpOn32bit,                       idbgRegistry + 1,  "64-bit registry operation attempted on 32-bit operating system for key [2].")
IDebugError(idbgOutOfMemory,                             idbgRegistry + 2,  "Out of memory.")

// idbgConfig = 2500
IDebugError(idbgEnumRollback,                            idbgConfig +  1,    "Could not create rollback script enumerator")
IDebugError(idbgInstallNotInProgress,                    idbgConfig +  2,    "Called InstallFinalize when no install in progress.")
IDebugError(idbgRunScriptInstallNotInProgress,           idbgConfig +  3,    "Called RunScript when not marked in progress.")

// idbgAction = 2600
IDebugError(idbgInvalidPropValue,                        idbgAction +  1,    "Invalid value for property [2]: '[3]'")
IDebugError(idbgMissingMediaTable,                       idbgAction +  2,    "The [2] table entry '[3]' has no associated entry in the Media table.")
IDebugError(idbgDuplicateTableName,                      idbgAction +  3,    "Duplicate Table Name [2]")
IDebugError(idbgNoProperty,                              idbgAction +  4,    "[2] property undefined.")
IDebugError(idbgServerMissing,                           idbgAction +  5,    "Could not find server [2] in [3] {, [5]} or [4].")
IDebugError(idbgPropValueNotFullPath,                    idbgAction +  6,    "Value of property [2] is not a valid full path: '[3]'.")
IDebugError(idbgMediaTableRequired,                      idbgAction +  7,    "Media table not found or empty (required for installation of files).")
IDebugError(idbgCreateAclFailed,                         idbgAction +  8,    "Could not create security descriptor for object.  Error: '[2]'.")
IDebugError(idbgNotInitializedToMigrateSettings,         idbgAction +  9,    "Attempt to migrate product settings before initialization.")
IDebugError(idbgNoCabForCompressedFile,                  idbgAction + 11,    "The file [2] is marked as compressed, but the associated media entry does not specify a cabinet.")
IDebugError(idbgStreamNotFoundInRecord,                  idbgAction + 12,    "Stream not found in '[2]' column.  Primary key: '[3]'.")
IDebugError(idbgRemoveExistingProductsSequenceError,     idbgAction + 13,    "RemoveExistingProducts action sequenced incorrectly.")
IDebugError(idbgMissingStorage,                          idbgAction + 14,    "Could not access IStorage object from installation package.")
IDebugError(idbgOpRegSelfUnregFailed,                    idbgAction + 15,    "Skipped unregistration of Module [2] due to source resolution failure.")
IDebugError(idbgNoCompanionParent,                       idbgAction + 16,    "Companion file [2] parent missing.")
IDebugError(idbgIsolateNoSharedComponent,                idbgAction + 17,    "Shared component [2] not found in Component table.")
IDebugError(idbgIsolateNoApplicationComponent,           idbgAction + 18,    "Isolated application component [2] not found in Component table.")
IDebugError(idbgIsolateNotSameFeature,                   idbgAction + 19,    "Isolated components [2], [3] not part of same feature.")
IDebugError(idbgIsolateNoKeyFile,                        idbgAction + 20,    "Key file of isolated application component [2] not in File table.")

// idbgEngine = 2700
IDebugError(idbgIllegalTreeDepth,                        idbgEngine +  1,    "The Component Table exceeds the acceptable tree depth of [2] levels.")
IDebugError(idbgFeatureBadParent,                        idbgEngine +  2,    "A Feature Table record ([2]) references a non-existent parent in the Attributes field.")
IDebugError(idbgNoRootSourcePropertyName,                idbgEngine +  3,    "Property name for root source path not defined: [2]")
IDebugError(idbgNoRootProperty,                          idbgEngine +  4,    "Root directory property undefined: [2]")
IDebugError(idbgLinkTable,                               idbgEngine +  5,    "Invalid table: [2]; Could not be linked as tree.")
IDebugError(idbgSourcePathsNotCreated,                   idbgEngine +  6,    "Source paths not created.  No path exists for entry [2] in Directory Table")
IDebugError(idbgTargetPathsNotCreated,                   idbgEngine +  7,    "Target paths not created.  No path exists for entry [2] in Directory Table")
IDebugError(idbgFileTableEmpty,                          idbgEngine +  8,    "No entries found in the file table.")
IDebugError(idbgBadComponent,                            idbgEngine +  9,    "The specified Component name ('[2]') not found in Component Table.")
IDebugError(idbgIllegalSetComponentRequest,              idbgEngine + 10,    "The requested 'Select' state is illegal for this Component.")
IDebugError(idbgBadFeature,                              idbgEngine + 11,    "The specified Feature name ('[2]') not found in Feature Table.")
IDebugError(idbgInvalidModelessDialogReturn,             idbgEngine + 12,    "Invalid return from modeless dialog: [3], in action [2].")
IDebugError(idbgNullInNonNullableColumn,                 idbgEngine + 13,    "Null value in a non-nullable column ('[2]') in '[3]' column of the '[4]' table.")
IDebugError(idbgInvalidDefaultFolder,                    idbgEngine + 14,    "Invalid value for default folder name: [2].")
IDebugError(idbgBadFile,                                 idbgEngine + 15,    "The specified File key ('[2]') not found in the File Table.")
IDebugError(idbgBadSubcomponentName,                     idbgEngine + 16,    "Couldn't create a random subcomponent name for component '[2]'.")
IDebugError(idbgBadActionData,                           idbgEngine + 17,    "Bad action condition or error calling custom action '[2]'.")
IDebugError(idbgSrcNoPackageName,                        idbgEngine + 18,    "Missing package name for product code '[2]'.")
IDebugError(idbgSrcNoVolume,                             idbgEngine + 19,    "Neither UNC nor drive letter path found in source '[2]'.")
IDebugError(idbgSrcOpenSourceListKey,                    idbgEngine + 20,    "Error opening sourcelist key. Error: '[2]'")
IDebugError(idbgCustomActionNotInBinaryTable,            idbgEngine + 21,    "Custom action [2] not found in Binary table stream")
IDebugError(idbgCustomActionNotInFileTable,              idbgEngine + 22,    "Custom action [2] not found in File table")
IDebugError(idbgInvalidCustomActionType,                 idbgEngine + 23,    "Custom action [2] specifies unsupported type")
IDebugError(idbgMediaLabel,                  idbgEngine + 24, "The volume label '[2]' on the media you're running from doesn't match the label '[3]' given in the Media table. This is allowed only if you have only 1 entry in your Media table.")
IDebugError(idbgDatabaseTableError,          idbgEngine + 25, "Invalid database tables")
IDebugError(idbgMissingAction,               idbgEngine + 26, "Action not found: [2]")
IDebugError(idbgUnknownDirectory,            idbgEngine + 27, "The directory entry '[2]' does not exist in the Directory table")
IDebugError(idbgTableDefinition,             idbgEngine + 28, "Table definition error: [2]")
IDebugError(idbgEngineNotInitialized,        idbgEngine + 29, "Install engine not initialized.")
IDebugError(idbgDatabaseValueError,          idbgEngine + 30, "Bad value in database. Table: '[2]'; Primary key: '[3]';  Column: '[4]'")
IDebugError(idbgSelMgrNotInitialized,        idbgEngine + 31, "Selection Manager not initialized.")
IDebugError(idbgDirMgrNotInitialized,        idbgEngine + 32, "Directory Manager not initialized.")
IDebugError(idbgBadForeignKey,               idbgEngine + 33, "Bad foreign key ('[2]') in '[3]' column of the '[4]' table.")
IDebugError(idbgBadReinstallMode,            idbgEngine + 34, "Invalid Reinstall mode character.")
IDebugError(idbgCustomActionDied,            idbgEngine + 35, "Custom action '[2]' has caused an unhandled exception and has been stopped.  This may be the result of an internal error in the custom action, such as an access violation.")
IDebugError(idbgCustomActionTempFile,        idbgEngine + 36, "Generation of custom action temp file failed: [2]")
IDebugError(idbgCustomActionNoVBScriptEngine,idbgEngine + 38, "Could not access VBScript runtime for custom action [2]")
IDebugError(idbgCustomActionNoJScriptEngine, idbgEngine + 39, "Could not access JavaScript runtime for custom action [2]")
IDebugError(idbgCorruptConfigInfo,		    idbgEngine + 41,"Configuration information for product [2] is corrupt. Invalid info: [2]")
IDebugError(idbgMarshalingFailed,		    idbgEngine + 42, "Marshaling to Server failed: [2]")
IDebugError(idbgTransformInvalidLanguage,    idbgEngine + 45, "Transform [2] invalid for package [3]. Expected language [4], found language [5].")
IDebugError(idbgTransformInvalidProduct,     idbgEngine + 46, "Transform [2] invalid for package [3]. Expected product [4], found product [5].")
IDebugError(idbgTransformInvalidLTVersion,   idbgEngine + 47, "Transform [2] invalid for package [3]. Expected product version < [4], found product version [5].")
IDebugError(idbgTransformInvalidLEVersion,   idbgEngine + 48, "Transform [2] invalid for package [3]. Expected product version <= [4], found product version [5].")
IDebugError(idbgTransformInvalidEQVersion,   idbgEngine + 49, "Transform [2] invalid for package [3]. Expected product version == [4], found product version [5].")
IDebugError(idbgTransformInvalidGEVersion,   idbgEngine + 50, "Transform [2] invalid for package [3]. Expected product version >= [4], found product version [5].")
IDebugError(idbgTransformInvalidGTVersion,   idbgEngine + 51, "Transform [2] invalid for package [3]. Expected product version > [4], found product version [5].")
IDebugError(idbgNoTransformAsChild,          idbgEngine + 52, "Could not open transform [2] stored as child storage of package [4].")
IDebugError(idbgFileNotMarkedForInstall,     idbgEngine + 53, "The File '[2]' is not marked for installation.")
IDebugError(idbgNotPatchStorage,             idbgEngine + 54, "The File '[2]' is not a valid patch file.")
IDebugError(idbgUnexpectedServerReturn,      idbgEngine + 55, "Server returned unexpected error [2] attempting to install package [3].")
IDebugError(idbgDirPropertyUndefined,		idbgEngine + 56, "The property '[2]' was used as a directory property in one or more tables, but no value was ever assigned.")
IDebugError(idbgTransformCreateSumInfoFailed,idbgEngine + 57, "Could not create summary info for transform [2].")
IDebugError(idbgTransformLacksMSIVersion,    idbgEngine + 58, "Transform [2] doesn't contain a MSI version.")
IDebugError(idbgTransformIncompatibleVersion,idbgEngine + 59, "Transform [2] version [3] incompatible with engine; Min: [4], Max: [5].")
IDebugError(idbgTransformInvalidUpgradeCode, idbgEngine + 60, "Transform [2] invalid for package [3]. Expected upgrade code [4], found [5].")
IDebugError(idbgErrorBeginningTransaction,   idbgEngine + 61, "Cannot begin transaction. Global mutex not properly initialized.")
IDebugError(idbgErrorWritingScriptRecord,    idbgEngine + 62, "Unable to schedule operation. The action must be scheduled between InstallInitialize and InstallFinalize.")
IDebugError(idbgErrorRunningScript,          idbgEngine + 63, "Cannot run script.  Transaction not started.")
IDebugError(idbgBadAssemblyName,             idbgEngine + 65, "Assembly name missing from AssemblyName table : Component: [4].")
IDebugError(idbgInvalidMsiStorage,           idbgEngine + 66, "The file [2] is an invalid MSI storage file.")
IDebugError(idbgNoMoreData,                  idbgEngine + 67, "No more data{ while enumerating [2]}.")
IDebugError(idbgInvalidPatchTransform,       idbgEngine + 68, "Transform in patch package is invalid.")
IDebugError(idbgCustomActionLeakedHandle,    idbgEngine + 69, "Custom Action [2] did not close [3] MSIHANDLEs.")
IDebugError(idbgCacheFolderPropertyNotDefined,idbgEngine+ 70, "Cached folder [2] not defined in internal cache folder table.")

// idbgHandler = 2800
IDebugError(idbgUnknownMessageType,          idbgHandler +  1,"Unknown Message -- Type [2]. No action is taken")
IDebugError(idbgEventNoPublisher,            idbgHandler +  2,"No publisher is found for the event [2]")
IDebugError(idbgFetchDialogViewFailed,       idbgHandler +  3,"Dialog View did not find a record for the dialog [2]")
IDebugError(idbgCEEval,                      idbgHandler +  4,"On activation of the control [3] on dialog [2] CMsiDialog failed to evaluate the condition [3]")
IDebugError(idbgWaitCEEval,                  idbgHandler +  5,"") // Reported by HandleWaitEvent, formatted by ControlActivated
IDebugError(idbgCCEval,                      idbgHandler +  6,"The dialog [2] failed to evaluate the condition [3]")
IDebugError(idbgCCActionUnknown,             idbgHandler +  7,"The action [2] is not recognized")
IDebugError(idbgDefaultButtonDef,            idbgHandler +  8,"Default button is illdefined on dialog [2]")
IDebugError(idbgControlLoopOpen,             idbgHandler +  9,"On the dialog [2] the next control pointers do not form a cycle.There is a pointer from [3] to [4], but there is no further pointer") //?
IDebugError(idbgControlLoopTail,             idbgHandler + 10,"On the dialog [2] the next control pointers do not form a cycle.There is a pointer from both [3] and [5] to [4]") //?
IDebugError(idbgTabNext,                     idbgHandler + 11,"On dialog [2] control [3] has to take focus, but it is unable to do so")
IDebugError(idbgEventNotFound,               idbgHandler + 12,"The event [2] is not recognized")
IDebugError(idbgExitButParent,               idbgHandler + 13,"The EndDialog event was called with the argument [2], but the dialog has a parent")
IDebugError(idbgNoNext,                      idbgHandler + 14,"On the dialog [2] the control [3] names a non-existent control [4] as the next control")
IDebugError(idbgCCMissingCond,               idbgHandler + 15,"ControlCondition table has a row without condition for the dialog [2]")
IDebugError(idbgEMInvalidControl,            idbgHandler + 16,"The EventMapping table refers to an invalid control [4] on dialog [2] for the event [3]")
IDebugError(idbgEMAttribute,                 idbgHandler + 17,"The event [2] failed to set the attribute for the control [4] on dialog [3]")
IDebugError(idbgEndDialogArg,                idbgHandler + 18,"In the ControlEvent table EndDialog has an unrecognized argument [2]")
IDebugError(idbgNoControlProperty,           idbgHandler + 19,"Control [3] on dialog [2] needs a property linked to it")
IDebugError(idbgHandlerSecondInit,           idbgHandler + 20,"Attempted to initialize an already initialized handler")
IDebugError(idbgSecondInitDialog,            idbgHandler + 21,"Attempted to initialize an already initialized dialog: [2]")
IDebugError(idbgAddingControls,              idbgHandler + 22,"No other method can be called on dialog [2] untill all the controls are added")
IDebugError(idbgSecondInitControl,           idbgHandler + 23,"Attempted to initialize an already initialized control: [3] on dialog [2]")
IDebugError(idbgDialogAttributeShort,        idbgHandler + 24,"The dialog attribute [3] needs a record of at least [2] field(s)")
IDebugError(idbgControlAttributeShort,       idbgHandler + 25,"The control attribute [3] needs a record of at least [2] field(s)")
IDebugError(idbgControlOutOfDialog,          idbgHandler + 26,"Control [3] on dialog [2] extends beyond the boundaries of the dialog [4] by [5] pixels")
IDebugError(idbgRadioButtonOff,              idbgHandler + 27,"The button [4] on the radiobutton group [3] on dialog [2] extends beyond the boundaries of the group [5] by [6] pixels")
IDebugError(idbgRemoveNonexControl,          idbgHandler + 28,"Tried to remove control [3] from dialog [2], but the control is not part of the dialog")
IDebugError(idbgUninitDialog,                idbgHandler + 29,"Attempt to use an uninitialized dialog")
IDebugError(idbgUninitControl,               idbgHandler + 30,"Attempt to use an uninitialized control on dialog [2]")
IDebugError(idbgUnsupportedControlAttrib,    idbgHandler + 31,"The control [3] on dialog [2] does not support [5] the attribute [4]")
IDebugError(idbgUnsupportedDialogAttrib,     idbgHandler + 32,"The dialog [2] does not support the attribute [3]")
IDebugError(idbgWinMesNoResponse,            idbgHandler + 33,"Control [4] on dialog [3] ignored the message [2]")
IDebugError(idbgNotSingleLoop,               idbgHandler + 34,"The next pointers on the dialog [2] do not form a single loop")
IDebugError(idbgControlNotFound,             idbgHandler + 35,"The control [2] was not found on dialog [3]")
IDebugError(idbgControlCantTakeFocus,        idbgHandler + 36,"The control [3] on the dialog [2] can not take focus")
IDebugError(idbgWinMes,                      idbgHandler + 37,"The control [3] on dialog [2] wants the winproc to return [4]")
IDebugError(idbgSelSelfParent,               idbgHandler + 38,"The item [2] in the selection table has itself as a parent")
IDebugError(idbgSettingPropertyFailed,       idbgHandler + 39,"Setting the property [2] failed")
IDebugError(idbgErrorNameMismatch,           idbgHandler + 40,"Error dialog name mismatch")
IDebugError(idbgNoOKonError,                 idbgHandler + 41,"No OK button was found on the error dialog")
IDebugError(idbgNoTextOnError,               idbgHandler + 42,"No text field was found on the error dialog")
IDebugError(idbgErrorStringNotSupported,     idbgHandler + 43,"The ErrorString attribute is not supported for standard dialogs")
IDebugError(idbgNoErrorString,               idbgHandler + 44,"Can not execute an error dialog if the errorstring is not set")
IDebugError(idbgButtonsDontFit,              idbgHandler + 45,"The total width of the buttons exceeds the size of the error dialog")
IDebugError(idbgSetFocusNotFound,            idbgHandler + 46,"SetFocus did not find the required control on the error dialog")
IDebugError(idbgBitmapIcon,                  idbgHandler + 47,"The control [3] on dialog [2] has both the icon and the bitmap style set") 
IDebugError(idbgDefaultDoesNotExist,         idbgHandler + 48,"Tried to set control [3] as the default button on dialog [2], but the control does not exist") 
IDebugError(idbgNoInteger,                   idbgHandler + 49,"The control [3] on dialog [2] is of a type, that can not be integer valued")
IDebugError(idbgUnrecognizedVolumeType,      idbgHandler + 50,"Unrecognized volume type")
IDebugError(idbgNotIcon,                     idbgHandler + 51,"The data for the icon [2] is not valid") 
IDebugError(idbgNoControl,                   idbgHandler + 52,"At least one control has to be added to dialog [2] before it is used")
IDebugError(idbgModelessExecute,             idbgHandler + 53,"Dialog [2] is a modeless dialog. The execute method should not be called on it")
IDebugError(idbgFirstControlDef,             idbgHandler + 54,"On the dialog [2] the control [3] is designated as first active control, but there is no such control")
IDebugError(idbgRBNoButtons,                 idbgHandler + 55,"The radiobutton group [3] on dialog [2] has fewer than 2 buttons")
IDebugError(idbgSecondDialog,                idbgHandler + 56,"Creating a second copy of the dialog [2]")
IDebugError(idbgSelectionPathMissing,        idbgHandler + 57,"The directory [2] is mentioned in the selection table but not found")
IDebugError(idbgNotBitmap,                   idbgHandler + 58,"The data for the bitmap [2] is not valid") 
IDebugError(idbgPaintError,                  idbgHandler + 59,"Failed to paint control [2]") 
IDebugError(idbgCancelButtonDef,             idbgHandler + 60,"Cancel button is illdefined on dialog [2]")
IDebugError(idbgRadioButtonCycle,            idbgHandler + 61,"The next pointers for the radiobuttons on dialog [2] control [3] do not form a cycle")
IDebugError(idbgNoIconSize,                  idbgHandler + 62,"The attributes for the control [3] on dialog [2] do not define a valid icon size. Setting the size to 16")
IDebugError(idbgIconWrongSize,               idbgHandler + 63,"The control [3] on dialog [2] needs the icon [4] in size [5]x[5], but that size is not available. Loading the first available size")
IDebugError(idbgNoDirCont,                   idbgHandler + 64,"The control [3] on dialog [2] received a browse event, but there is no configurable directory for the present selection. Likely cause: browse button is not authored correctly")
IDebugError(idbgControlOutOfBillboard,       idbgHandler + 65,"Control [3] on billboard [2] extends beyond the boundaries of the billboard [4] by [5] pixels")
IDebugError(idbgEventNotAllowed,             idbgHandler + 66,"The dialog [2] is not allowed to return the argument [3]")
IDebugError(idbgNoErrorProperty,             idbgHandler + 67,"The error dialog property is not set")
IDebugError(idbgErrorNoStyle,                idbgHandler + 68,"The error dialog [2] does not have the error style bit set")
IDebugError(idbgStyleNoError,                idbgHandler + 69,"The dialog [2] has the error style bit set, but is not an error dialog")
IDebugError(idbgNoHelpSeparator,             idbgHandler + 70,"The help string [4] for control [3] on dialog [2] does not contain the separator character")
IDebugError(idbgOldTable,                    idbgHandler + 71,"The [2] table is out of date: [3]")
IDebugError(idbgCheckPathArgument,           idbgHandler + 72,"The argument of the CheckPath control event on dialog [2] is invalid")
IDebugError(idbgInvalidLimit,                idbgHandler + 73,"On the dialog [2] the control [3] has an invalid string length limit: [4]")
IDebugError(idbgFontChange,                  idbgHandler + 74,"Changing the text font to [2] failed")
IDebugError(idbgFontChangeColor,             idbgHandler + 75,"Changing the text color to [2] failed")
IDebugError(idbgTextTruncated,               idbgHandler + 76,"The control [3] on dialog [2]  had to truncate the string: [4]")
IDebugError(idbgBinaryData,                  idbgHandler + 77,"The binary data [2] was not found")
IDebugError(idbgValueNotUnique,              idbgHandler + 78,"On the dialog [2] the control [3] has a possible value: [4]. This is an invalid or duplicate value.")
IDebugError(idbgInvalidMask,                 idbgHandler + 79,"The control [3] on dialog [2]  can not parse the mask string: [4]")
IDebugError(idbgStopControlEvents,           idbgHandler + 80,"Do not perform the remaining control events.")
IDebugError(idbgHandlerInit,                 idbgHandler + 81,"CMsiHandler initialization failed")
IDebugError(idbgWindowClassRegFailed,        idbgHandler + 82,"Dialog window class registration failed")
IDebugError(idbgCreateDialog,                idbgHandler + 83,"CreateNewDialog failed for the dialog [2]")
IDebugError(idbgDialogWindow,                idbgHandler + 84,"Failed to create a window for the dialog [2]!")
IDebugError(idbgControlCreate,               idbgHandler + 85,"Failed to create the control [3] on the dialog [2]")
IDebugError(idbgTableCreate,                 idbgHandler + 86,"Creating the [2] table failed")
IDebugError(idbgCursorCreate,                idbgHandler + 87,"Creating a cursor to the [2] table failed")
IDebugError(idbgViewExecute,                 idbgHandler + 88,"Executing the [2] view failed")
IDebugError(idbgCreateControlWindow,         idbgHandler + 89,"Creating the window for the control [3] on dialog [2] failed")
IDebugError(idbgDialogCreate,                idbgHandler + 90,"The handler failed in creating an unitialized dialog")
IDebugError(idbgFailedToDestroyWindow,       idbgHandler + 91,"Failed to destroy window for dialog [2]")
IDebugError(idbgIntegerOnlyControl,          idbgHandler + 92,"[2] is an integer only control, [3] is not a valid integer value")
IDebugError(idbgOverLimit,                   idbgHandler + 93,"The control [3] on dialog [2] can accept property values that are at most [5] characters long. The value [4] exceeds this limit, and has been truncated.")
IDebugError(idbgRichEdLoad,                  idbgHandler + 94,"Loading RichEd20.dll failed. GetLastError() returned: [2]")
IDebugError(idbgRichEdFree,                  idbgHandler + 95,"Freeing RichEd20.dll failed. GetLastError() returned: [2]")
IDebugError(idbgActionFailed,                idbgHandler + 96,"Executing action [2] failed.")
IDebugError(idbgNoSuchFont,                  idbgHandler + 97,"Failed to create any [2] font on this system.")
IDebugError(idbgCreatedFont,                 idbgHandler + 98,"For [2] textstyle, the system created a '[3]' font, in [4] character set, of [5] pixels height.")
IDebugError(idbgCannotCreateFont,            idbgHandler + 99,"Failed to create [2] textstyle. GetLastError() returned: [3].")

// idbgExecute = 2900
IDebugError(idbgOpInvalidParam,              idbgExecute +  1, "Invalid parameter to operation [2]: Parameter [3]")
IDebugError(idbgOpOutOfSequence,             idbgExecute +  2, "Operation [2] called out of sequence.")
IDebugError(idbgOpFileMissing,               idbgExecute +  3, "The file [2] is missing")
IDebugError(idbgOpBindImage,                 idbgExecute +  4, "Could not BindImage file [2].")
IDebugError(idbgReadScriptRecord,            idbgExecute +  5, "Could not read record from script file [2].")
IDebugError(idbgMissingScriptHeader,         idbgExecute +  6, "Missing header in script file [2].")
IDebugError(idbgOpSecureSecurityDescriptor,  idbgExecute +  7,"Could not create secure security descriptor. Error: [2]")
IDebugError(idbgOpCompRegister,              idbgExecute +  8, "Could not register component [2].")
IDebugError(idbgOpCompUnregister,            idbgExecute +  9, "Could not unregister component [2].")
IDebugError(idbgOpGetUserSID,                idbgExecute + 10, "Could not determine user's security id.")
IDebugError(idbgOpRemoveFolder,              idbgExecute + 11,"Could not remove the folder [2].")
IDebugError(idbgOpScheduleRebootRemove,      idbgExecute + 12,"Could not schedule file [2] for removal on reboot.")
IDebugError(idbgOpCompressedCopyWithoutCabinet, idbgExecute + 19,"No cabinet specified for compressed file: [2]")
IDebugError(idbgOpSourcePathNotSet,          idbgExecute + 20,"Source directory not specified for file [2].")
IDebugError(idbgOpScriptVersionUnsupported,  idbgExecute + 24, "Script [2] version unsupported. Script version: [3], minimum version: [4], maximum version: [5].")
IDebugError(idbgInvalidShellFolder,          idbgExecute + 27, "ShellFolder id [2] is invalid.")
IDebugError(idbgOpExceededSourceLimit,       idbgExecute + 28,"Exceeded maximum number of sources. Skipping source '[2]'.")
IDebugError(idbgPublishRoot,                 idbgExecute + 29,"Could not determine publishing root. Error: [2]")
IDebugError(idbgOpCreateFileFromData,        idbgExecute + 32,"Could not create file [2] from script data.{ Error: [3]}")
IDebugError(idbgInitializeRollbackScript,    idbgExecute + 33,"Could not initialize rollback script [2].")
IDebugError(idbgOpSecureTransformFailed,     idbgExecute + 34,"Could not secure transform [2]. Error [3]")
IDebugError(idbgOpUnsecureTransformFailed,   idbgExecute + 35,"Could not un-secure transform [2]. Error [3]")
IDebugError(idbgOpTransformNotFound,         idbgExecute + 36,"Could not find transform [2].")
IDebugError(idbgErrorSfpInstallCatalog,      idbgExecute + 37,"The Windows Installer cannot install a system file protection catalog.  Catalog: [2],  Error: [3]")
IDebugError(idbgErrorSfpDuplicateCatalog,    idbgExecute + 38,"The Windows Installer cannot retrieve a system file protection catalog from the cache.  Catalog: [2], Error: [3]")
IDebugError(idbgErrorSfpDeleteCatalog,       idbgExecute + 39,"The Windows Installer cannot delete a system file protection catalog from the cache.  Catalog: [2], Error: [3]")
IDebugError(idbgOpNoDirMgr,                  idbgExecute + 40,"Directory Manager not supplied for source resolution.")
IDebugError(idbgOpCRCCheckFailed,            idbgExecute + 41,"Unable to compute the CRC for file [2].")
IDebugError(idbgOpImageNotBound,             idbgExecute + 42,"BindImage action has not been executed on [2] file.")
IDebugError(idbgScriptPlatformUnsupported,   idbgExecute + 43,"This version of Windows does not support deploying 64-bit packages.  The script [2] is for a 64-bit package.")
IDebugError(idbgGetProductAssignmentTypeFailed,	idbgExecute + 44, "GetProductAssignmentType failed.")
IDebugError(idbgComPlusInstallFailed,        idbgExecute + 45,"Installation of ComPlus App [2] failed with error [3].")
IDebugError(idbgFontAdditionFailed,          idbgExecute + 46,"Installation of font [3] failed with error [2].")
IDebugError(idbgFontRemovalFailed,           idbgExecute + 47,"Uninstallation of font [3] failed with error [2].")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\imsimem.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       imsimem.h
//
//--------------------------------------------------------------------------

//
// File: imsimem.h
// Purpose: Allows each DLL to hook up to the memory allocator
// Owner: davidmck
// Notes:
//


#include "common.h"
#include "services.h"
#include "imemory.h"
#include "tuneprefix.h"

IMsiMalloc *piMalloc = 0;

#ifndef IN_SERVICES
// We essentially must Ref count this pointer because of debugging
// under excel. A services pointer will be deleted, after a new one
// is created.
static int cRefMalloc = 0;
#endif // !IN_SERVICES

#define cCallStack		4

#ifdef DEBUG
unsigned long	rgCallStack[cCallStack];
void AssertNoAllocator(char *szMsg);

inline void CheckAndAssertNoAllocator()
{
	if (piMalloc == 0)
	{
		Debug(AssertNoAllocator("Using dynamic object without allocator.");)
	}
};

#endif //DEBUG

#ifndef IN_SERVICES
//
// Sets the static allocator piMalloc for the DLL
//
void SetAllocator(IMsiServices *piServices)
{
	piMalloc = &piServices->GetAllocator();
	cRefMalloc++;
}
#endif //!IN_SERVICES

void AddRefAllocator()
{
	piMalloc->AddRef();
#ifndef IN_SERVICES
	cRefMalloc++;
#endif //!IN_SERVICES
}

//
// Releases the allocator
//
void ReleaseAllocator()
{
	if (piMalloc != 0)
	{
		piMalloc->Release();
#ifndef IN_SERVICES
		if (--cRefMalloc <= 0)
			piMalloc = 0;
#endif //!IN_SERVICES
	}
}

//
// Need an allocator other than new for certain allocations
// that happen before piMalloc is initiallize
//
void * AllocSpc(size_t cb)
{
	void *pbNew;
	
#ifdef WIN
	pbNew = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, cb);
#else
	pbNew = NewPtrClear(cb);
#endif //WIN

	return pbNew;
}

//
// Same as above for delete
//
void FreeSpc(void* pv)
{

#ifdef WIN
	GlobalFree(pv);
#else
	DisposePtr((char *)pv);
#endif //Win
}

void * operator new(size_t cb)
{
	Debug(GetCallingAddr(lCallAddr, cb));
	
	if (piMalloc == 0)
	{
		Debug(FailAssertMsg("Allocating object without allocator.");)
#ifndef IN_SERVICES
		// the handler DLL has no code that is not in the handler object, created via COM. The
		// object initialization code for the handler object sets the allocator in the DLL to
		// the specified object in the engine. This pointer can never really be NULL in the 
		// handler DLL.
		PREFIX_NOT_REACHED("Handler DLL sets allocator on object initialization, pointer can not be NULL.");
#else
		// in the core engine DLL, piMalloc could be NULL if an object is created in an API call
		// without loading the services object first. In that scenario, we would assert in debug builds
		// (because that is a bug in the code) but in also initialize the allocator so that the code 
		// won't crash in ship builds.
		InitializeMsiMalloc();
#endif
	}

#ifdef DEBUG
#ifdef _WIN64
	return piMalloc->AllocEx((unsigned long)cb, lCallAddr); //!!WIN64 shouldn't need to cast - BENCH
#else //!WIN64
	return piMalloc->AllocEx(cb, lCallAddr);
#endif //_WIN64
#else
#ifdef _WIN64
	return piMalloc->Alloc((unsigned long)cb); //!!WIN64 shouldn't need to cast - BENCH
#else //!WIN64
	return piMalloc->Alloc(cb);
#endif //_WIN64
#endif //DEBUG
}

void operator delete(void *pv)
{
	if (pv == 0)
		return;

	if (piMalloc == 0)
		{
		Debug(FailAssertMsg("Freeing object without allocator.");)
		return;
		}
		
	piMalloc->Free(pv);

}

void * AllocObject(size_t cb)
{
	Debug(GetCallingAddr(lCallAddr, cb));

#ifdef DEBUG
	if (piMalloc == 0)
		{
		Debug(FailAssertMsg("Allocating object without allocator.");)
		return 0;
		}

#ifdef _WIN64
	return piMalloc->AllocObjectEx((unsigned long)cb, lCallAddr,  //!!WIN64 shouldn't need to cast - BENCH
#else //!WIN64
	return piMalloc->AllocObjectEx(cb, lCallAddr, 
#endif //_WIN64
// The problem is that RTTI information apparently does not go across DLLs
// this means that only the services DLL can be looking at RTTI information
#if defined(IN_SERVICES)
			fTrue
#else
			fFalse
#endif //MEM_SERVICES
			);
#else		
#ifdef _WIN64
	return piMalloc->AllocObject((unsigned long)cb); //!!WIN64 shouldn't need to cast - BENCH
#else //!WIN64
	return piMalloc->AllocObject(cb);
#endif //_WIN64
#endif //DEBUG

}

void FreeObject(void *pv)
{
	if (pv == 0)
		return;

	if (piMalloc == 0)
		{
		Debug(AssertNoAllocator("Freeing object without allocator.");)
		return;
		}
		
	piMalloc->FreeObject(pv);

}

void *AllocMem(size_t cb)
{
	Debug(GetCallingAddr(lCallAddr, cb));
	
	if (piMalloc == 0)
		{
		Debug(FailAssertMsg("Allocating object without allocator.");)
		return 0;
		}

#ifdef DEBUG
#ifdef _WIN64
	return piMalloc->AllocEx((unsigned long)cb, lCallAddr); //!!WIN64 shouldn't need to cast - BENCH
#else //!WIN64
	return piMalloc->AllocEx(cb, lCallAddr);
#endif //_WIN64
#else	
#ifdef _WIN64
	return piMalloc->Alloc((unsigned long)cb); //!!WIN64 shouldn't need to cast - BENCH
#else //!WIN64
	return piMalloc->Alloc(cb);
#endif //_WIN64
#endif //DEBUG


}

void FreeMem(void *pv)
{
	if (piMalloc == 0)
		{
		Debug(FailAssertMsg("Freeing object without allocator.");)
		return;
		}
		
	piMalloc->Free(pv);

}

#ifdef DEBUG
void AssertNoAllocator(char *szMsg)
{
	TCHAR szTemp[256 + (100 * cCallStack)];
	int cch;

	RETURN_IF_FAILED(StringCchPrintf(szTemp, ARRAY_ELEMENTS(szTemp), TEXT("%hs\r\n"), szMsg));
	cch = IStrLen(szTemp);
#if defined(IN_SERVICES)
	FillCallStack(rgCallStack, cCallStack, 1);
	ListSzFromRgpaddr(szTemp + cch, ARRAY_ELEMENTS(szTemp) - cch, rgCallStack, cCallStack, true);
#endif
	FailAssertMsg(szTemp);
}

BOOL FCheckBlock(void *pv)
{
	IMsiDebugMalloc *piDbgMalloc;
	BOOL fRet = fFalse;
	GUID iidTemp = GUID_IID_IMsiDebugMalloc;
	
	Assert(piMalloc);

	if (piMalloc->QueryInterface(iidTemp, (void **)&piDbgMalloc) == NOERROR)
	{
		fRet = piDbgMalloc->FCheckBlock(pv);
		piDbgMalloc->Release();
	}

	return fRet;
	
}
#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\msi.hh ===
/* msi.hh = help context identifiers for MSI API automation help */

#define HELPID_MsiInstall_Object               9000
#define HELPID_MsiInstall_UILevel              9001
#define HELPID_MsiInstall_EnableLog            9002
#define HELPID_MsiInstall_CreateRecord         9003
#define HELPID_MsiInstall_OpenPackage          9004
#define HELPID_MsiInstall_OpenProduct          9005
#define HELPID_MsiInstall_OpenDatabase         9006
#define HELPID_MsiInstall_SummaryInformation   9007
#define HELPID_MsiInstall_InstallProduct       9008
#define HELPID_MsiInstall_Version              9009
#define HELPID_MsiInstall_LastErrorRecord      9010
#define HELPID_MsiInstall_RegistryValue        9011
#define HELPID_MsiInstall_Environment          9012
#define HELPID_MsiInstall_FileAttributes       9013
#define HELPID_MsiInstall_FileSize             9014
#define HELPID_MsiInstall_FileVersion          9015
/*efine HELPID_MsiInstall_ExternalUI           9016*/
#define HELPID_MsiInstall_ProductState         9017
#define HELPID_MsiInstall_ProductInfo          9018
#define HELPID_MsiInstall_ConfigureProduct     9019
#define HELPID_MsiInstall_ReinstallProduct     9020
#define HELPID_MsiInstall_CollectUserInfo      9021
#define HELPID_MsiInstall_ApplyPatch           9022
#define HELPID_MsiInstall_FeatureParent        9023
#define HELPID_MsiInstall_FeatureState         9024
#define HELPID_MsiInstall_UseFeature           9025
#define HELPID_MsiInstall_FeatureUsageCount    9026
#define HELPID_MsiInstall_FeatureUsageDate     9027
#define HELPID_MsiInstall_ConfigureFeature     9028
#define HELPID_MsiInstall_ReinstallFeature     9029
#define HELPID_MsiInstall_ProvideComponent     9030
#define HELPID_MsiInstall_ComponentPath        9031
#define HELPID_MsiInstall_ProvideQualifiedComponent 9032
#define HELPID_MsiInstall_QualifierDescription 9033
#define HELPID_MsiInstall_ComponentQualifiers  9034
#define HELPID_MsiInstall_Products             9035
#define HELPID_MsiInstall_Features             9036
#define HELPID_MsiInstall_Components           9037
#define HELPID_MsiInstall_ComponentClients     9038
#define HELPID_MsiInstall_Patches              9039
#define HELPID_MsiInstall_RelatedProducts      9040
#define HELPID_MsiInstall_PatchInfo            9041
#define HELPID_MsiInstall_PatchTransforms      9042
#define HELPID_MsiInstall_AddSource            9043
#define HELPID_MsiInstall_ClearSourceList      9044
#define HELPID_MsiInstall_ForceSourceListResolution  9045
#define HELPID_MsiInstall_GetShortcutTarget    9046
#define HELPID_MsiInstall_FileHash             9047
#define HELPID_MsiInstall_FileSignatureInfo    9048

#define HELPID_MsiFeatureInfo_Object           9100
#define HELPID_MsiFeatureInfo_Title            9101
#define HELPID_MsiFeatureInfo_Description      9102
#define HELPID_MsiFeatureInfo_Attributes       9103

#define HELPID_MsiCollection_Object            9200
#define HELPID_MsiCollection_Item              9201
#define HELPID_MsiCollection_Count             9202
#define HELPID_MsiRecordCollection_Object      9203

#define HELPID_MsiRecord_Object                9300
#define HELPID_MsiRecord_FieldCount            9301
#define HELPID_MsiRecord_StringData            9302
#define HELPID_MsiRecord_IntegerData           9303
#define HELPID_MsiRecord_DataSize              9304
#define HELPID_MsiRecord_IsNull                9305
#define HELPID_MsiRecord_SetStream             9306
#define HELPID_MsiRecord_ReadStream            9307
#define HELPID_MsiRecord_ClearData             9308
#define HELPID_MsiRecord_FormatText            9309

#define HELPID_MsiView_Object                  9400
#define HELPID_MsiView_Execute                 9401
#define HELPID_MsiView_Fetch                   9402
#define HELPID_MsiView_Modify                  9403
#define HELPID_MsiView_Close                   9404
#define HELPID_MsiView_ColumnInfo              9405
#define HELPID_MsiView_GetError                9406

#define HELPID_MsiDatabase_Object              9500
#define HELPID_MsiDatabase_DatabaseState       9501
#define HELPID_MsiDatabase_SummaryInformation  9502
#define HELPID_MsiDatabase_OpenView            9503
#define HELPID_MsiDatabase_Commit              9504
#define HELPID_MsiDatabase_PrimaryKeys         9505
#define HELPID_MsiDatabase_Import              9506
#define HELPID_MsiDatabase_Export              9507
#define HELPID_MsiDatabase_Merge               9508
#define HELPID_MsiDatabase_GenerateTransform   9509
#define HELPID_MsiDatabase_ApplyTransform      9510
#define HELPID_MsiDatabase_TablePersistent     9511
#define HELPID_MsiDatabase_EnableUIPreview     9512
#define HELPID_MsiDatabase_CreateTransformSummaryInfo 9513

#define HELPID_MsiSummaryInfo_Object           9600
#define HELPID_MsiSummaryInfo_Property         9601
#define HELPID_MsiSummaryInfo_PropertyCount    9602
#define HELPID_MsiSummaryInfo_Persist          9603

#define HELPID_MsiEngine_Object                9700
#define HELPID_MsiEngine_Application           9701
#define HELPID_MsiEngine_Property              9702
#define HELPID_MsiEngine_Language              9703
#define HELPID_MsiEngine_Mode                  9704
#define HELPID_MsiEngine_Database              9705
#define HELPID_MsiEngine_DoAction              9706
#define HELPID_MsiEngine_Sequence              9707
#define HELPID_MsiEngine_Message               9708
#define HELPID_MsiEngine_FormatRecord          9709
#define HELPID_MsiEngine_EvaluateCondition     9710
#define HELPID_MsiEngine_SourcePath            9711
#define HELPID_MsiEngine_TargetPath            9712
#define HELPID_MsiEngine_FeatureCurrentState   9713
#define HELPID_MsiEngine_FeatureRequestState   9714
#define HELPID_MsiEngine_FeatureValidStates    9715
#define HELPID_MsiEngine_FeatureCost           9716
#define HELPID_MsiEngine_ComponentCurrentState 9717
#define HELPID_MsiEngine_ComponentRequestState 9718
#define HELPID_MsiEngine_SetInstallLevel       9719
#define HELPID_MsiEngine_VerifyDiskSpace       9720
#define HELPID_MsiEngine_ProductProperty       9721
#define HELPID_MsiEngine_FeatureInfo           9722
#define HELPID_MsiEngine_ComponentCosts        9723

#define HELPID_MsiUIPreview_Object             9800
#define HELPID_MsiUIPreview_ViewDialog         9801
#define HELPID_MsiUIPreview_ViewBillboard      9802
/*efine HELPID_MsiUIPreview_Property    HELPID_MsiEngine_Property */

#define HELPID_MsiInstallState                 9901
#define HELPID_MsiReinstallMode                9902
#define HELPID_MsiInstallMode                  9903
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\imsidbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       imsidbg.h
//
//--------------------------------------------------------------------------

/*  imsidbg.h - Defines the CMsiRef object for debugging

____________________________________________________________________________*/

#ifndef __IMSIDBG
#define __IMSIDBG

// How many functions to keep on the stack
#define cFuncStack	4

#ifdef TRACK_OBJECTS
// Ref Counting Action
typedef enum RCA
{
	rcaCreate,
	rcaAddRef,
	rcaRelease
};

// Ref Counting Action Block
// This keeps track of all ref counting operations
typedef struct _RCAB
{
	_RCAB*	prcabNext;
	RCA		rca;
	unsigned long	rgpaddr[cFuncStack];	// stack from where call was made
	
} RCAB;

#endif //TRACK_OBJECTS

#ifdef TRACK_OBJECTS
class CMsiRefBase
{
public:
	Bool	m_fTrackObject;	// Are we tracking this particular object
	IUnknown *m_pobj;			// Pointer to the actual object
	RCAB	m_rcabFirst;
	CMsiRefBase*	m_pmrbNext;
	CMsiRefBase*	m_pmrbPrev;
};
#endif //TRACK_OBJECTS

// Template class based on the iid of the object
template <int C> class CMsiRef
#ifdef TRACK_OBJECTS
	: public CMsiRefBase
#endif //TRACK_OBJECTS
{
 public:  // constructor/destructor and local methods
#ifndef TRACK_OBJECTS
inline CMsiRef()	{ m_iRefCnt = 1; };
#else
  CMsiRef();
  ~CMsiRef();
#endif // TRACK_OBJETS
 public:
	long		m_iRefCnt;
#ifdef TRACK_OBJECTS
	static Bool	m_fTrackClass;
#endif //TRACK_OBJECTS
};

#ifdef TRACK_OBJECTS

typedef struct		// Map Iid to Track flag
{
	int		iid;
	Bool*	pfTrack;
} MIT;

class CMsiRefHead : public CMsiRefBase
{
 public:  // constructor/destructor and local methods
	CMsiRefHead();
 	~CMsiRefHead();
};

extern void InsertMrb(CMsiRefBase* pmrbHead, CMsiRefBase* pmrbNew);
extern void	RemoveMrb(CMsiRefBase* pmrbDel);
extern void FillCallStack(unsigned long* rgCallAddr, int cCallStack, int cSkip);
extern void TrackObject(RCA rca, CMsiRefBase* pmrb);
extern void SetFTrackFlag(int iid, Bool fTrack);
extern void ListSzFromRgpaddr(TCHAR *szInfo, int cchInfo, unsigned long *rgpaddr, int cFunc, bool fReturn);
extern void FillCallStackFromAddr(unsigned long* rgCallAddr, int cCallStack, int cSkip, unsigned long *plAddrStart);
extern void SzFromFunctionAddress(TCHAR *szAddress, size_t cchAddress, long lAddress);
extern void InitSymbolInfo(bool fLoadModules);
void AssertEmptyRefList(CMsiRefHead *prfhead);
void LogObject(CMsiRefBase* pmrb, RCAB* prcabNew);
void DisplayMrb(CMsiRefBase* pmrb);


extern CMsiRefHead g_refHead;
extern bool g_fLogRefs;
extern bool g_fNoPreflightInits;

template <int C>
CMsiRef<C>::CMsiRef()
{
	m_iRefCnt = 1;
	m_pobj = 0;
	
	if (m_fTrackClass)
	{
		// Need to add this to the list of objects
		InsertMrb((CMsiRefBase *)&g_refHead, (CMsiRefBase *)this);		
		m_fTrackObject = fTrue;
		m_rcabFirst.rca = rcaCreate;
		m_rcabFirst.prcabNext = 0;
		FillCallStack(m_rcabFirst.rgpaddr, cFuncStack, 0);
		if (g_fLogRefs)
			LogObject((CMsiRefBase *)this, &m_rcabFirst);
	}
	else
	{
		m_rcabFirst.prcabNext = 0;
		m_pmrbNext = 0;
		m_pmrbPrev = 0;
		m_fTrackObject = fFalse;
	}

}

template <int C>
CMsiRef<C>::~CMsiRef()
{
	RCAB *prcabNext, *prcab;
	
	// Need to remove from the linked list
	RemoveMrb((CMsiRefBase *)this);

	// Delete the RCABs attached to this object
	prcab = m_rcabFirst.prcabNext;

	while (prcab != 0)
	{
		prcabNext = prcab->prcabNext;
		FreeSpc(prcab);
		prcab = prcabNext;
	}

}

#define AddRefTrack()	{ if (m_Ref.m_fTrackObject) TrackObject(rcaAddRef, (CMsiRefBase *)&m_Ref); }
#define ReleaseTrack()	{ if (m_Ref.m_fTrackObject) TrackObject(rcaRelease, (CMsiRefBase *)&m_Ref); }
#endif //TRACK_OBJECTS

#ifndef TRACK_OBJECTS
#define AddRefTrack()
#define ReleaseTrack()
#endif //TRACK_OBJECTS

#ifdef DEBUG
class CMsiDebug : public IMsiDebug
{
 public:   // implemented virtual functions
	CMsiDebug();
	~CMsiDebug();
	HRESULT         __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long   __stdcall AddRef();
	unsigned long   __stdcall Release();
	void  __stdcall SetAssertFlag(Bool fShowAsserts);
	void  __stdcall SetDBCSSimulation(char chLeadByte);
	Bool  __stdcall WriteLog(const ICHAR* szText);
	void  __stdcall AssertNoObjects(void);
	void  __stdcall SetRefTracking(long iid, Bool fTrack);
private:
	Bool  __stdcall CreateLog();
#ifdef WIN
	HANDLE          m_hLogFile;
#else
	short			m_hLogFile;
#endif

};
#endif //DEBUG

extern bool g_fFlushDebugLog;

#endif // __IMSIDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\intrface.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       intrface.h
//
//--------------------------------------------------------------------------

//
// File: interface.h
// Purpose: FDI_Interface definition.
//
//
// FDI_Interface:
//
//    The FDI_Interface is.......
//
//
//    Important Public Functions:
//
//    FDIInterfaceError Init(const ICHAR *pszCabinetName, const ICHAR *pszCabinetPath,
//     unsigned long cbNotificationGranularity);
//
//          Initializes the interface with the cabinet's path and name. 
//          cbNotificationGranularity indicates how often you would 
//			like copy notifications (in terms of bytes written).
//
//    ExtractFile(const ICHAR *pszNameInCabinet,
//				  const ICHAR *pszPathOnDisk,
//				  FileAttributes *pfa);
//
//          Extracts the given file to the given path. Can also be called after
//			an fdirNeedNextCabinet or fdirNotification message, as long as the
//			file names remain unchanged from the last call
//
//    Continue()
//
//          Resumes copying after a copy notification, request for another cabinet, or
//          some other interruption.
//
//    Done()
//      
//          Resets the FDI interface. Should be called prior to the Interface's 
//          destruction.

#include "fdisvr.h"

// Error types that Init(..) returns
enum FDIInterfaceError 
{
	ifdiNoError,            // Currently unused
	ifdiServerLaunched,     // Server launched successfully
	ifdiServerLaunchFailed, // Launch failed.
	ifdiErrorOpeningCabinet,// Couldn't open cabinet
	ifdiDriveNotReady,		// Drive expected to contain cabinet has no disk inserted.
	ifdiNetError,           // Network error occurred trying to open the cabinet
	ifdiMissingSignature,   // Cabinet digital signature was missing when required.
	ifdiBadSignature,       // Cabinet digital signature was invalid when required.
	ifdiCorruptCabinet,
};

class FDI_Interface
{
public:

	// You must call Init() before using this object
	FDI_Interface();
	
	// The destructor does nothing. Call Done() to destroy this object.
	~FDI_Interface();

	// Init function. Does not start up the FDI Server process/thread
	FDIInterfaceError Init(IMsiServices *piAsvc, IMsiStorage* piStorage);

	// Set notification granularity to enable progress callbacks. Return
	// remaining byte count to notification, set new partial count from cbSoFar.
	int SetNotification(int cbNotification, int cbPending);

	// Call this to extract a file, or resume from an fdirNeedNextCabinet or
	// fdirNotification message.
	// *pfa will be copied into internal data structures, so it doesn't matter
	// if this argument goes out of scope after the end of this call
	FDIServerResponse ExtractFile(const ICHAR *pszNameInCabinet,
											 IAssemblyCacheItem* piASM,
											 bool fManifest,
											 const ICHAR *pszPathOnDisk,
											 FileAttributes *pfa,
											 int iDestDriveType,
											 LPSECURITY_ATTRIBUTES pSecurityAttributes);

	// Call this to Continue() processing from a fdirNeedNextCabinet
	// or fdirNotification return value from ExtractFile(..).
	FDIServerResponse SendCommand(FDIServerCommand fdic);

	// Shut down FDI Server thread/app and deallocate any memory used.
	FDIServerResponse Done();

	// This function opens the indicated cabinet and calls FDICopy
	FDIInterfaceError OpenCabinet(const ICHAR *pszCabinetName, const ICHAR *pszCabinetPath, icbtEnum icbtCabinetType, int iCabDriveType, 
		Bool fSignatureRequired, IMsiStream* piSignatureCert, IMsiStream* piSignatureHash, HRESULT& hrWVT);

	// Access the HRESULT from the WinVerifyTrust call stored in the FDIShared private data member
	HRESULT RetrieveWVTReturnCode();

private:
	// This function sends a command to the FDI Server and waits for a response
	FDIServerResponse WaitResponse(FDIServerCommand fdis);

	// This function launches the FDI process/thread and passes it the pointer
	// to the private data member fdis. This shared data structure is used to
	// pass commands, results and arguments between the FDI Server and the FDI
	// Interface object
	int            LaunchFDIServer();

	// In _DEBUG mode on the Mac, this function tries to see if the FDI Server
	// is already running.  If not, it just calls LaunchFDIServer();
	// On the WIN32 platform, this function just calls LaunchFDIServer();
	int            ContactFDIServer();

private:
	FDIShared				m_fdis;
	FDIServerResponse		m_fdirLastResponse;
	Bool					m_fServerLaunched;
	IMsiServices*			m_piAsvc;
	IMsiStorage*            m_piStorage;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\module.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       module.h
//
//--------------------------------------------------------------------------

/* module.h - Common module definitions, entry points, self-registration

 This file can only be included by the base .CPP file for each module.
 Before #include of this file, the following must be #define'd:

MODULE_INITIALIZE- (optional) name of function when module is initialized
MODULE_TERMINATE - (optional) name of function when module is terminated
DLLREGISTEREXTRA - (optional) name of function called on DllRegisterServer

CLSID_COUNT      - number of CLSIDs registered for the module
MODULE_FACTORIES - array of function that create objects corresponding to CLSIDs
MODULE_CLSIDS    - array of CLSIDs for objects created by module factories
MODULE_PROGIDS   - array of ProgId strings for module corresponding to CLSIDs
MODULE_DESCRIPTIONS - array of descriptions for CLSIDs, for registry entries

REGISTER_TYPELIB - type library to register from resource
TYPELIB_MAJOR_VERSION - major version of typelib, used to unregister, default = rmj
TYPELIB_MINOR_VERSION - minor version of typelib, used to unregister, default = rmm

COMMAND_OPTIONS - string with letters that are the command-line options
					corresponding to the functions in COMMAND_FUNCTIONS
COMMAND_FUNCTIONS  - array of functions that perform each command-line option

 If the module is to be used as a service the following must be defined

SERVICE_NAME          - name of the service
IDS_SERVICE_DISPLAY_NAME  - ids of user-visible name of the service

 Use the class ID's, ProgId's, and descriptions defined in common.h and tools.h
 For debug builds, both the standard and the debug IDs may be registered.

 By default, a DLL module is assumed and the standard entry points are defined.
 For an EXE server, define _EXE on the makefile compile command line (-D_EXE).

____________________________________________________________________________*/

#ifndef __MODULE
#define __MODULE
#include "version.h"  // version fields, used to set property, unreg typelib
#include "stdio.h"
#include "eventlog.h"
#include <olectl.h> // SELFREG_E_*

#ifndef TYPELIB_MAJOR_VERSION
#define TYPELIB_MAJOR_VERSION rmj
#endif
#ifndef TYPELIB_MINOR_VERSION
#define TYPELIB_MINOR_VERSION rmm
#endif

#define LATEBIND_TYPEDEF
#include "latebind.h"
#define LATEBIND_VECTREF
#include "latebind.h"

#if defined(SERVICE_NAME) && !defined(_EXE)
#error Service only supported on EXE builds
#endif

#ifdef SERVICE_NAME
void WINAPI ServiceMain(DWORD dwArgc, LPTSTR *lpszArgv);
BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode,
								 DWORD dwWaitHint, DWORD dwMsiError);
VOID WINAPI ServiceControl(DWORD dwCtrlCode);
int InstallService();
int RemoveService();
VOID ServiceStop();
unsigned long __stdcall ServiceThreadMain(void *);
#endif //SERVICE_NAME

#define SIZE_OF_TOKEN_INFORMATION                   \
	sizeof( TOKEN_USER )                            \
	+ sizeof( SID )                                 \
	+ sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES


typedef IUnknown* (*ModuleFactory)();

//____________________________________________________________________________
//
// Forward declarations of class registration arrays
//____________________________________________________________________________

extern const GUID    MODULE_CLSIDS[CLSID_COUNT];
extern const ICHAR*  MODULE_PROGIDS[CLSID_COUNT];
extern const ICHAR*  MODULE_DESCRIPTIONS[CLSID_COUNT];
extern ModuleFactory MODULE_FACTORIES[CLSID_COUNT];

#if !defined(_EXE)
extern "C" HRESULT __stdcall
DllGetClassObject(const GUID& clsid, const IID& iid, void** ppvRet);

extern "C" HRESULT __stdcall
DllCanUnloadNow();

extern "C" HRESULT __stdcall
DllRegisterServer();

extern "C" HRESULT __stdcall
DllUnregisterServer();

extern "C" HRESULT __stdcall
DllGetVersion(DLLVERSIONINFO *pverInfo);
#endif // !defined(_EXE)

class CModuleFactory : public IClassFactory
{
 public: // implemented virtual functions
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	HRESULT       __stdcall CreateInstance(IUnknown* pUnkOuter, const IID& riid,
														void** ppvObject);
	HRESULT       __stdcall LockServer(OLEBOOL fLock);
};

////IUnknown* MODULE_FACTORY();  // global function must be implemented by module

#ifdef MODULE_INITIALIZE
void MODULE_INITIALIZE();    // must be implemented by module if defined
#endif

#ifdef MODULE_TERMINATE
void MODULE_TERMINATE();     // must be implemented by module if defined
#endif

#ifdef DLLREGISTEREXTRA
extern "C" HRESULT __stdcall DLLREGISTEREXTRA();
#endif //DLLREGISTEREXTRA

#ifdef DLLUNREGISTEREXTRA
extern "C" HRESULT __stdcall DLLUNREGISTEREXTRA();
#endif //DLLUNREGISTEREXTRA

//____________________________________________________________________________
//
// Global variables
//____________________________________________________________________________

HINSTANCE g_hInstance = 0;
long g_cInstances = 0;
int g_iTestFlags = 0;  // test flags set from environment variable
scEnum g_scServerContext = scClient;
CModuleFactory g_rgcfModule[CLSID_COUNT];
DWORD g_dwThreadId;
Bool g_fRegService = fFalse;
Bool g_fCustomActionServer = fFalse;

//#include "..\\engine\\_msiutil.h"
#ifdef _EXE
#include "..\\engine\\_msinst.h"

Bool g_fQuiet = fFalse;
int g_iLanguage = 0;
#endif

#ifdef REGISTER_TYPELIB
const GUID IID_MsiTypeLib = REGISTER_TYPELIB;
#endif

const int cchMaxStringCchPrintf = 1024;


#ifdef SERVICE_NAME
void ReportInstanceCountChange();
extern HANDLE g_hShutdownTimer;
const LONGLONG iServiceShutdownTime = ((LONGLONG)(10 * 60)  * (LONGLONG)(1000 * 1000 * 10));
bool RunningOnWow64();
bool ServiceSupported();
bool FInstallInProgress();
#endif


//____________________________________________________________________________
//
// Registration templates and functions
//____________________________________________________________________________

ICHAR szRegFilePath[MAX_PATH];

ICHAR szRegCLSID[40];  // buffer for string form of CLSID
ICHAR szRegLIBID[40];  // buffer for string form of LIBID
ICHAR szRegProgId[40]; // copy of ProgId
ICHAR szRegDescription[100]; // copy of description

bool __stdcall TestAndSet(int* pi)
//
// Sets *pi to 1. Returns true if *pi previously set.
//
{
	return  (bool)(InterlockedExchange((PLONG)pi, 1) == 1);
}

//____________________________________________________________________________
//
// Token Privilege adjusting in ref-counted and absolute flavors.
//____________________________________________________________________________

bool AdjustTokenPrivileges(const ICHAR** szPrivileges, const int cPrivileges, bool fAcquire, DWORD cbtkpOld, PTOKEN_PRIVILEGES ptkpOld,  DWORD *pcbtkpOldReturned)
{

	// SHOULD NOT BE CALLED DIRECTLY from external code.
	// Use Acquire/DisableTokenPrivilege or Acquire/DisableRefCountedTokenPrivilege

	// ACQUIRE == true :  returns the old privileges in ptkpOld
	// ACQUIRE == false, ptkpOld == NULL :  turns off the privileges in szPrivileges
	// ACQUIRE == false, ptkpOld != NULL :  sets the privileges to those in ptkpOld with the size from pcbtkpOldReturned - pcbtkpOld can be NULL in this case.
	// The parameters are set up this way so you can acquire and release using the same parameter arrangement.
	// The Acquire call fills in the buffers, then the Release will use the old values to restore.

	HANDLE hToken;

	// this maximum is limited by coding in the RefCountedTokenPrivilegesCore and AdjustTokenPrivileges call.

	TOKEN_PRIVILEGES ptkp[MAX_PRIVILEGES_ADJUSTED]; // some left over space, but makes sure there's enough room
                                  // for the LUIDs.

	if (cPrivileges > MAX_PRIVILEGES_ADJUSTED)
	{
		return false;
	}

	// get the token for this process
	if (!WIN::OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
		return false;


	if (fAcquire || (NULL == ptkpOld))
	{
		// the the LUID for the privilege
		for (int cPrivIndex = 0; cPrivIndex < cPrivileges; cPrivIndex++)
		{
			if (!WIN::LookupPrivilegeValue(0, szPrivileges[cPrivIndex], &(*ptkp).Privileges[cPrivIndex].Luid))
				return WIN::CloseHandle(hToken), false;

			(*ptkp).Privileges[cPrivIndex].Attributes = (fAcquire) ? SE_PRIVILEGE_ENABLED : 0;
		}
		(*ptkp).PrivilegeCount = cPrivileges; // count of privileges to set
		WIN::AdjustTokenPrivileges(hToken, fFalse, &(*ptkp), cbtkpOld, ptkpOld, pcbtkpOldReturned);
	}
	else
	{
		// restore the old privileges
		WIN::AdjustTokenPrivileges(hToken, fFalse, ptkpOld, *pcbtkpOldReturned, NULL, NULL);
	}
	// cannot test the return value of AdjustTokenPrivileges
	WIN::CloseHandle(hToken);
	if (WIN::GetLastError() != ERROR_SUCCESS)
		return false;
	return true;
}

TokenPrivilegesRefCount g_pTokenPrivilegesRefCount[cRefCountedTokenPrivileges];

// THESE PRIVILEGE SETS MUST NOT OVERLAP, OR BE USED DIRECTLY IN A PROCESS WITH BOTH REFCOUNTING AND NON-REFCOUNTING.
// check AdjustTokenPrivileges limit for maximum number of privileges that can be passed at a time.
const ICHAR* pszTOKEN_PRIVILEGES_SD_WRITE[] = { SE_RESTORE_NAME, SE_TAKE_OWNERSHIP_NAME };
const ICHAR* pszTOKEN_PRIVILEGES_SD_READ[] = { SE_SECURITY_NAME };

bool RefCountedTokenPrivilegesCore(itkpEnum itkpPriv, bool fAcquire)
{
	// Certain privileges need to be on for limited periods of time due to system
	// auditing or to help eliminate potential security breaches.

	// DO NOT USE THE SAME PRIVILEGES REF-COUNTED and non-refcounted in the same
	// process.

	static bool fInitialized = false;
	static int iTokenLock = 0;


	while (TestAndSet(&iTokenLock))
	{
		Sleep(10);		
	}

	if (!fInitialized)
	{
		memset(g_pTokenPrivilegesRefCount, 0, sizeof(g_pTokenPrivilegesRefCount));
		fInitialized = true;
	}

	bool fAdjustPrivileges = false;
	bool fResult = fFalse;
	unsigned int uiOldRefCount = g_pTokenPrivilegesRefCount[(int) itkpPriv].iCount;

	if (fAcquire)
	{
		if (1 == ++(g_pTokenPrivilegesRefCount[(int) itkpPriv]).iCount)
		{
			fAdjustPrivileges = true;
		}
	}
	else
	{
		if (0 == --(g_pTokenPrivilegesRefCount[(int) itkpPriv]).iCount)
		{
			fAdjustPrivileges = true;
		}
	}


	if (fAdjustPrivileges)
	{
		switch(itkpPriv)
		{
			// check AdjustTokenPrivileges limit for maximum number of privileges that can be passed at a time.
			case itkpSD_READ:
				fResult = AdjustTokenPrivileges(pszTOKEN_PRIVILEGES_SD_READ, sizeof(pszTOKEN_PRIVILEGES_SD_READ)/sizeof(ICHAR*), 
					fAcquire, sizeof(TOKEN_PRIVILEGES)*MAX_PRIVILEGES_ADJUSTED, 
					g_pTokenPrivilegesRefCount[(int) itkpPriv].ptkpOld, 
					&(g_pTokenPrivilegesRefCount[(int) itkpPriv].cbtkpOldReturned));
				break;

			case itkpSD_WRITE:
				fResult = AdjustTokenPrivileges(pszTOKEN_PRIVILEGES_SD_WRITE, sizeof(pszTOKEN_PRIVILEGES_SD_WRITE)/sizeof(ICHAR*), 
					fAcquire, sizeof(TOKEN_PRIVILEGES)*MAX_PRIVILEGES_ADJUSTED, 
					g_pTokenPrivilegesRefCount[(int) itkpPriv].ptkpOld, 
					&(g_pTokenPrivilegesRefCount[(int) itkpPriv].cbtkpOldReturned));	
				break;

			default:
				fResult = fFalse;
		}
	}
	else 
	{
		fResult = fTrue;
	}

	if (!fResult)
	{
		// caller should not release ref-count if this failed.
		g_pTokenPrivilegesRefCount[(int) itkpPriv].iCount = uiOldRefCount;
	}
	// release the lock
	iTokenLock = 0;

	return fResult;
}

bool AcquireRefCountedTokenPrivileges(itkpEnum itkpPriv)
{
	return RefCountedTokenPrivilegesCore(itkpPriv, fTrue);
}

bool DisableRefCountedTokenPrivileges(itkpEnum itkpPriv)
{
	return RefCountedTokenPrivilegesCore(itkpPriv, fFalse);
}

bool DisableTokenPrivilege(const ICHAR* szPrivilege)
{
	// Note that this does not ref-count the tokens.
	// check AdjustTokenPrivileges limit for maximum number of privileges that can be passed at a time.
	return AdjustTokenPrivileges(&szPrivilege, 1, fFalse, 0, NULL, NULL);
}

bool AcquireTokenPrivilege(const ICHAR* szPrivilege)
{
	// Note that there is no convenient way to ref-count these
	// currently.  Once acquired, they can only be relinquished
	// by DisableTokenPrivileges.

	// check AdjustTokenPrivileges limit for maximum number of privileges that can be passed at a time.
	return AdjustTokenPrivileges(&szPrivilege, 1, fTrue, 0, NULL, NULL);
}

VOID
CRefCountedTokenPrivileges::Initialize(itkpEnum itkpPrivileges)
{
	m_itkpPrivileges = itkpNO_CHANGE;

	if (itkpNO_CHANGE != itkpPrivileges)
	{
		if (AcquireRefCountedTokenPrivileges(itkpPrivileges))
			m_itkpPrivileges = itkpPrivileges; // Don't decrement ref-counts if AcquireRefCountedTokenPrivileges fail.
	}
}

void GetVersionInfo(int* piMajorVersion, int* piMinorVersion, int* piWindowsBuild, bool* pfWin9X, bool* pfWinNT64)
/*----------------------------------------------------------------------------
  Returns true if we're on Windows 95 or 98, false otherwise
 ------------------------------------------------------------------------------*/
{
	OSVERSIONINFO osviVersion;
	osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if (! GetVersionEx(&osviVersion))
		return;

	if (piMajorVersion)
		*piMajorVersion = osviVersion.dwMajorVersion;

	if (piMinorVersion)
		*piMinorVersion = osviVersion.dwMinorVersion;

	if (piWindowsBuild)
		*piWindowsBuild = osviVersion.dwBuildNumber & 0xFFFF;

	if (pfWin9X)
		*pfWin9X = (osviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);

	if (pfWinNT64)
	{
#ifdef _WIN64
		// 64-bit of Darwin will run only on 64-bit OS.
		*pfWinNT64 = true;
#else
		*pfWinNT64 = false;
#ifdef UNICODE
		if ( osviVersion.dwPlatformId == VER_PLATFORM_WIN32_NT )
		{
			NTSTATUS st;
			ULONG_PTR Wow64Info;

			st = NtQueryInformationProcess(WIN::GetCurrentProcess(),
													   ProcessWow64Information,
													   &Wow64Info, sizeof(Wow64Info), NULL);
			if ( NT_SUCCESS(st) && Wow64Info )
				// running inside WOW64 on Win64
				*pfWinNT64 = true;
		}
#endif // UNICODE
#endif // _WIN64
	}
}


DWORD GetAdminSID(char** pSid)
{
	static bool fAdminSIDSet = false;
	static char rgchStaticSID[256];
	const int cbStaticSID = sizeof(rgchStaticSID);
	SID_IDENTIFIER_AUTHORITY siaNT      = SECURITY_NT_AUTHORITY;
	PSID pSID;

	if (!fAdminSIDSet)
	{
		if (!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, (void**)&(pSID)))
			return GetLastError();

		if(GetLengthSid(pSID)  > cbStaticSID)
		{
#if defined(__ASSERT) && defined(ASSERT_HANDLING)
			Assert(0);
#endif
			return ERROR_MORE_DATA;// doesnt really work since there is no way to increase the buffer size from the outside 
		}
		memcpy(rgchStaticSID, pSID, GetLengthSid(pSID));
		fAdminSIDSet = true;
	}
	*pSid = rgchStaticSID;
	return ERROR_SUCCESS;
}

DWORD GetLocalSystemSID(char** pSid)
{
	static bool fSIDSet = false;
	static char rgchStaticSID[256];
	const int cbStaticSID = sizeof(rgchStaticSID);
	SID_IDENTIFIER_AUTHORITY siaNT      = SECURITY_NT_AUTHORITY;
	PSID pSID;

	if (!fSIDSet)
	{
		if (!AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(pSID)))
			return GetLastError();

		if(GetLengthSid(pSID)  > cbStaticSID)
		{
#if defined(__ASSERT) && defined(ASSERT_HANDLING)
			Assert(0);
#endif
			return ERROR_MORE_DATA; // doesnt really work since there is no way to increase the buffer size from the outside
		}
		memcpy(rgchStaticSID, pSID, WIN::GetLengthSid(pSID));
		fSIDSet = true;
	}
	*pSid = rgchStaticSID;
	return ERROR_SUCCESS;
}


enum sdSecurityDescriptor
{
	sdEveryoneReadWrite,
	sdSecure,
	sdSystemAndInteractiveAndAdmin,
	sdSecureHidden,
	sdCOMNotSecure,
	sdCOMSecure,
	sdUsageKey
};

DWORD GetSecurityDescriptor(char* rgchStaticSD, DWORD& cbStaticSD, sdSecurityDescriptor sdType, Bool fAllowDelete)
{
	class CSIDPointer
	{
	 public:
		CSIDPointer(SID* pi) : m_pi(pi){}
		~CSIDPointer() {if (m_pi) WIN::FreeSid(m_pi);} // release ref count at destruction
		operator SID*() {return m_pi;}     // returns pointer, no ref count change
		SID** operator &() {if (m_pi) WIN::FreeSid(m_pi); return &m_pi;}
	 private:
		SID* m_pi;
	};

	struct Security
	{
		CSIDPointer pSID;
		DWORD dwAccessMask;
		Security() : pSID(0), dwAccessMask(0) {}
	} rgchSecurity[3];

	int cSecurity = 0;

	// Initialize the SIDs we'll need

	SID_IDENTIFIER_AUTHORITY siaNT      = SECURITY_NT_AUTHORITY;
	SID_IDENTIFIER_AUTHORITY siaWorld   = SECURITY_WORLD_SID_AUTHORITY;
//  SID_IDENTIFIER_AUTHORITY siaCreator = SECURITY_CREATOR_SID_AUTHORITY;
//  SID_IDENTIFIER_AUTHORITY siaLocal   = SECURITY_LOCAL_SID_AUTHORITY;

	const SID* psidOwner = NULL;
	const SID* psidGroup = 0;

	switch (sdType)
	{
		case sdSecure:
		{
			if ((!AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[0].pSID))) ||
				 (!AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[1].pSID))) ||
				 (!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[2].pSID))))
			{
				return GetLastError();
			}
			psidOwner = rgchSecurity[2].pSID;
			rgchSecurity[0].dwAccessMask = fAllowDelete ? GENERIC_ALL : (STANDARD_RIGHTS_ALL|SPECIFIC_RIGHTS_ALL) & (~DELETE);
			rgchSecurity[1].dwAccessMask = GENERIC_READ|GENERIC_EXECUTE|READ_CONTROL|SYNCHRONIZE; //?? Is this correct?
			rgchSecurity[2].dwAccessMask = fAllowDelete ? GENERIC_ALL : (STANDARD_RIGHTS_ALL|SPECIFIC_RIGHTS_ALL) & (~DELETE);
			cSecurity = 3;
			break;
		}
		case sdSecureHidden:
		{
			if ((!AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[0].pSID))) ||
				 (!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[1].pSID))))
			{
				return GetLastError();
			}
			psidOwner = rgchSecurity[1].pSID;
			rgchSecurity[0].dwAccessMask = fAllowDelete ? GENERIC_ALL : (STANDARD_RIGHTS_ALL|SPECIFIC_RIGHTS_ALL) & (~DELETE);
			rgchSecurity[1].dwAccessMask = fAllowDelete ? GENERIC_ALL : (STANDARD_RIGHTS_ALL|SPECIFIC_RIGHTS_ALL) & (~DELETE);
			cSecurity = 2;
			break;
		}
		case sdEveryoneReadWrite:
		{
			if ((!AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[0].pSID))) ||
				(!AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[1].pSID))) ||
				(!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[2].pSID))))
			{
				return GetLastError();
			}
			psidOwner = rgchSecurity[2].pSID;

			rgchSecurity[0].dwAccessMask = (STANDARD_RIGHTS_ALL|SPECIFIC_RIGHTS_ALL) & ~(WRITE_DAC|WRITE_OWNER);
			if (!fAllowDelete)
				rgchSecurity[0].dwAccessMask &= ~DELETE;

			rgchSecurity[1].dwAccessMask = GENERIC_ALL;
			rgchSecurity[2].dwAccessMask = GENERIC_ALL;
			cSecurity = 3;
			break;
		}
		case sdSystemAndInteractiveAndAdmin:
		{
			if (((!AllocateAndInitializeSid(&siaNT, 1, SECURITY_INTERACTIVE_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[0].pSID)))) ||
				  (!AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID,   0, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[1].pSID))) ||
				  (!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[2].pSID))))
			{
				return GetLastError();
			}
			psidGroup = psidOwner = rgchSecurity[2].pSID;
			rgchSecurity[0].dwAccessMask = KEY_QUERY_VALUE;
			rgchSecurity[1].dwAccessMask = KEY_QUERY_VALUE;
			rgchSecurity[2].dwAccessMask = KEY_QUERY_VALUE;
			cSecurity = 3;
			break;
		}
		case sdCOMNotSecure:
		{
			if (!AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID,   0, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[0].pSID)) ||
				(!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[1].pSID))) ||
				(!AllocateAndInitializeSid(&siaNT, 1, SECURITY_INTERACTIVE_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[2].pSID))))
			{
				return GetLastError();
			}
			psidGroup = rgchSecurity[0].pSID;
			psidOwner = rgchSecurity[1].pSID;
			rgchSecurity[0].dwAccessMask = COM_RIGHTS_EXECUTE;
			rgchSecurity[1].dwAccessMask = COM_RIGHTS_EXECUTE;
			rgchSecurity[2].dwAccessMask = COM_RIGHTS_EXECUTE;
			cSecurity = 3;
			break;
		}
		case sdCOMSecure:
		{
			if (!AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID,   0, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[0].pSID)) ||
				!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[1].pSID)))
			{
				return GetLastError();
			}
			psidGroup = rgchSecurity[0].pSID;
			psidOwner = rgchSecurity[1].pSID;
			rgchSecurity[0].dwAccessMask = COM_RIGHTS_EXECUTE;
			rgchSecurity[1].dwAccessMask = COM_RIGHTS_EXECUTE;
			cSecurity = 2;
			break;
		}
		case sdUsageKey:
		{
			if ((!AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[0].pSID))) ||
				(!AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[1].pSID))) ||
				(!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[2].pSID))))
			{
				return GetLastError();
			}
			psidOwner = rgchSecurity[2].pSID;
	
			rgchSecurity[0].dwAccessMask = KEY_READ | KEY_SET_VALUE;
			rgchSecurity[1].dwAccessMask = GENERIC_ALL;
			rgchSecurity[2].dwAccessMask = GENERIC_ALL;
			cSecurity = 3;
			break;
		}
	}

	// Initialize our ACL

	const int cbAce = sizeof (ACCESS_ALLOWED_ACE) - sizeof (DWORD); // subtract ACE.SidStart from the size
	int cbAcl = sizeof (ACL);

	for (int c=0; c < cSecurity; c++)
		cbAcl += (GetLengthSid(rgchSecurity[c].pSID) + cbAce);

	const int cbDefaultAcl = 512; //??
	CTempBuffer<char, cbDefaultAcl> rgchACL; //!! can't use CTempBuffer -- no services
	if (rgchACL.GetSize() < cbAcl)
		rgchACL.SetSize(cbAcl);

	if (!WIN::InitializeAcl ((ACL*) (char*) rgchACL, cbAcl, ACL_REVISION))
		return GetLastError();

	// Add an access-allowed ACE for each of our SIDs

	for (c=0; c < cSecurity; c++)
	{
		if (!WIN::AddAccessAllowedAce((ACL*) (char*) rgchACL, ACL_REVISION, rgchSecurity[c].dwAccessMask, rgchSecurity[c].pSID))
			return GetLastError();

		ACCESS_ALLOWED_ACE* pAce;
		if (!GetAce((ACL*)(char*)rgchACL, c, (void**)&pAce))
			return GetLastError();

		pAce->Header.AceFlags = CONTAINER_INHERIT_ACE|OBJECT_INHERIT_ACE;
	}

//      Assert(WIN::IsValidAcl((ACL*) (char*) rgchACL));

	// Initialize our security descriptor,throw the ACL into it, and set the owner

	SECURITY_DESCRIPTOR sd;

	if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION) ||
		(!SetSecurityDescriptorDacl(&sd, TRUE, (ACL*) (char*) rgchACL, FALSE)) ||
		(!SetSecurityDescriptorOwner(&sd, (PSID)psidOwner, FALSE)) ||
		(psidGroup && !SetSecurityDescriptorGroup(&sd, (PSID)psidGroup, FALSE)))
	{
		return GetLastError();
	}

	DWORD cbSD = WIN::GetSecurityDescriptorLength(&sd);
	if (cbStaticSD < cbSD)
	{
		return ERROR_INSUFFICIENT_BUFFER;
	}

	return WIN::MakeSelfRelativeSD(&sd, (char*)rgchStaticSD, &cbStaticSD) ? ERROR_SUCCESS: GetLastError();

}

DWORD GetUsageKeySecurityDescriptor(char** pSecurityDescriptor)
{
	static bool fDescriptorSet = false;
	static char rgchStaticSD[256];
	static DWORD cbStaticSD = sizeof(rgchStaticSD);

	DWORD dwRet = ERROR_SUCCESS;

	if (!fDescriptorSet)
	{
		if (ERROR_SUCCESS != (dwRet = GetSecurityDescriptor(rgchStaticSD, cbStaticSD, sdUsageKey, fFalse)))
			return dwRet;

		fDescriptorSet = true;
	}

	*pSecurityDescriptor = rgchStaticSD;
	return ERROR_SUCCESS;
}

DWORD GetSecureHiddenSecurityDescriptor(char** pSecurityDescriptor, Bool fAllowDelete)
{
	static bool fDescriptorSet = false;
	static char rgchStaticSD[256];
	static DWORD cbStaticSD = sizeof(rgchStaticSD);

	DWORD dwRet = ERROR_SUCCESS;

	if (!fDescriptorSet)
	{

		if (ERROR_SUCCESS != (dwRet = GetSecurityDescriptor(rgchStaticSD, cbStaticSD, sdSecureHidden, fAllowDelete)))
			return dwRet;

		fDescriptorSet = true;
	}

	*pSecurityDescriptor = rgchStaticSD;
	return ERROR_SUCCESS;
}

DWORD GetSecureSecurityDescriptor(char** pSecurityDescriptor, Bool fAllowDelete, bool fHidden)
{
	static bool fDescriptorSet = false;
	static char rgchStaticSD[256];
	static DWORD cbStaticSD = sizeof(rgchStaticSD);

	if (fHidden)
		return GetSecureHiddenSecurityDescriptor(pSecurityDescriptor, fAllowDelete);

	DWORD dwRet = ERROR_SUCCESS;


	if (!fDescriptorSet)
	{
		if (ERROR_SUCCESS != (dwRet = GetSecurityDescriptor(rgchStaticSD, cbStaticSD, sdSecure, fAllowDelete)))
			return dwRet;

		fDescriptorSet = true;
	}

	*pSecurityDescriptor = rgchStaticSD;
	return ERROR_SUCCESS;
}

//*****************************************************************************
// NOTE: any changes to the following section must be also made to
//          %darwin%\src\install\darreg.txt
//*****************************************************************************

const ICHAR* rgszRegData[] = {
#ifndef _EXE
	TEXT("CLSID\\%s\\InprocServer32"), szRegCLSID, szRegFilePath, TEXT("ThreadingModel"), TEXT("Apartment"), 
	TEXT("CLSID\\%s\\InprocHandler32"), szRegCLSID, TEXT("ole32.dll"), NULL, NULL,
#endif
	TEXT("CLSID\\%s\\ProgId"), szRegCLSID, szRegProgId, NULL, NULL,
#ifdef REGISTER_TYPELIB
	TEXT("CLSID\\%s\\TypeLib"), szRegCLSID, szRegLIBID, NULL, NULL,
#endif
	TEXT("CLSID\\%s"),  szRegCLSID, szRegDescription, NULL, NULL,
	TEXT("%s\\CLSID"), szRegProgId, szRegCLSID, NULL, NULL,
	TEXT("%s"), szRegProgId, szRegDescription, NULL, NULL,
	0,
};

const ICHAR szMsiDirectory[] = TEXT("Installer");

#ifdef _EXE
//!! Some of these strings need to be localized? If so, they should be elsewhere
const ICHAR szFileClass[]                     = TEXT("Msi.Package");
const ICHAR szFileClassDescription[]          = TEXT("Windows Installer Package");
//const ICHAR szInstallDescription[]            = TEXT("Install");
//const ICHAR *szInstallVerb                    = szInstallDescription;
//const ICHAR szUninstallDescription[]          = TEXT("Uninstall");
//const ICHAR *szUninstallVerb                  = szUninstallDescription;
//const ICHAR szNetInstallDescription[]         = TEXT("Install To Networ&k");
//const ICHAR szNetInstallVerb[]                = TEXT("Install To Network");
//const ICHAR szRepairDescription[]             = TEXT("Re&pair");
//const ICHAR szRepairVerb[]                    = TEXT("Repair");
//const ICHAR szOpenDescription[]               = TEXT("Open");
//const ICHAR *szOpenVerb                       = szOpenDescription;

//const ICHAR *szDefaultDescription             = szInstallDescription;
//const ICHAR *szDefaultVerb                    = szInstallVerb;

const ICHAR szPatchFileClass[]              = TEXT("Msi.Patch");
const ICHAR szPatchFileClassDescription[]   = TEXT("Windows Installer Patch");
//const ICHAR szPatchVerb[]                   = TEXT("Apply Patch");
//const ICHAR *szPatchDescription             = szPatchVerb;
//const ICHAR szPatchOpenVerb[]               = TEXT("Open");
//const ICHAR *szPatchOpenDescription         = szPatchOpenVerb;
//const ICHAR *szPatchDefaultVerb             = szPatchVerb;
//const ICHAR *szPatchDefaultDescription      = szPatchVerb;

// remove-only data (to accomodate Darwin upgrades)
const ICHAR szAdvertiseVerb[]        = TEXT("Advertise");

// Registration data for .MSI association and verbs
// TO DO: We should improve how this is used. We currently expect a null at the end in column 2 (not column 1)
// rather than just knowing the length. Currently, column 1 is always null, which is excess data
const ICHAR* rgszRegShellData[] = {
	0, TEXT("%s"),                     szInstallPackageExtension, 0,               TEXT("%s"),            szFileClass,
	0, TEXT("%s\\DefaultIcon"),        szFileClass,     0,               TEXT("%s,0"),          szRegFilePath,
//  0, TEXT("%s\\Shell\\%s"),          szFileClass,     szInstallVerb,   TEXT("%s"),            szInstallDescription,
//  0, TEXT("%s\\Shell\\%s\\command"), szFileClass,     szInstallVerb,   TEXT("%s /I \"%%1\""), szRegFilePath,
//  0, TEXT("%s\\Shell\\%s"),          szFileClass,     szNetInstallVerb,TEXT("%s"),            szNetInstallDescription,
//  0, TEXT("%s\\Shell\\%s\\command"), szFileClass,     szNetInstallVerb,TEXT("%s /A \"%%1\""), szRegFilePath,
//  0, TEXT("%s\\Shell\\%s"),          szFileClass,     szRepairVerb,    TEXT("%s"),            szRepairDescription,
//  0, TEXT("%s\\Shell\\%s\\command"), szFileClass,     szRepairVerb,    TEXT("%s /F \"%%1\""), szRegFilePath,
//  0, TEXT("%s\\Shell\\%s"),          szFileClass,     szUninstallVerb, TEXT("%s"),            szUninstallDescription,
//  0, TEXT("%s\\Shell\\%s\\command"), szFileClass,     szUninstallVerb, TEXT("%s /X \"%%1\""), szRegFilePath,
//  0, TEXT("%s\\Shell\\%s"),          szFileClass,     szOpenVerb,      TEXT("%s"),            szOpenDescription,
//  0, TEXT("%s\\Shell\\%s\\command"), szFileClass,     szOpenVerb,      TEXT("%s /I \"%%1\""), szRegFilePath,
//  TEXT("R"), TEXT("%s\\Shell\\%s\\command"), szFileClass,     szAdvertiseVerb,    0,               0,
//  0, TEXT("%s\\Shell\\%s"),          szFileClass,     szInstallVerb,      0,               0,
//  0, TEXT("%s\\Shell\\%s"),          szFileClass,     szNetInstallVerb,   0,               0,
//  0, TEXT("%s\\Shell\\%s"),          szFileClass,     szRepairVerb,       0,               0,
//  0, TEXT("%s\\Shell\\%s"),          szFileClass,     szUninstallVerb,    0,               0,
//  0, TEXT("%s\\Shell\\%s"),          szFileClass,     szOpenVerb,         0,               0,
//  TEXT("R"), TEXT("%s\\Shell\\%s"),          szFileClass,     szAdvertiseVerb,    0,               0,
//  0, TEXT("%s\\Shell"),              szFileClass,     0,               TEXT("%s"),            szDefaultVerb,
	0, TEXT("%s"),                     szFileClass,     0,               TEXT("%s"),            szFileClassDescription,

	0, TEXT("%s"),                     szPatchPackageExtension, 0,               TEXT("%s"),            szPatchFileClass,
	0, TEXT("%s\\DefaultIcon"),        szPatchFileClass,     0,               TEXT("%s,0"),          szRegFilePath,
//  0, TEXT("%s\\Shell\\%s"),          szPatchFileClass,     szPatchVerb,   TEXT("%s"),            szPatchDescription,
//  0, TEXT("%s\\Shell\\%s\\command"), szPatchFileClass,     szPatchVerb,   TEXT("%s /P \"%%1\""), szRegFilePath,
// 0, TEXT("%s\\Shell\\%s"),          szPatchFileClass,     szPatchOpenVerb,   TEXT("%s"),            szPatchOpenDescription,
//  0, TEXT("%s\\Shell\\%s\\command"), szPatchFileClass,     szPatchOpenVerb,      TEXT("%s /P \"%%1\""), szRegFilePath,
//  0, TEXT("%s\\Shell\\%s"),          szPatchFileClass,     szPatchVerb,      0,               0,
//  0, TEXT("%s\\Shell\\%s"),          szPatchFileClass,     szPatchOpenVerb,         0,               0,
//  0, TEXT("%s\\Shell"),              szPatchFileClass,     0,               TEXT("%s"),            szPatchDefaultVerb,
	0, TEXT("%s"),                     szPatchFileClass,     0,               TEXT("%s"),            szPatchFileClassDescription,
	0, 0        // Extra null to stop going through the array - we look at column 2
};
#endif // _EXE

// Registration data specific to the Service
#ifdef SERVICE_NAME
// service registration data for the service that should only be written
// by the specific process that is going to be the service
const ICHAR* rgszRegThisServiceData[] = {
	TEXT("APPID\\%s"), szRegCLSID, TEXT("ServiceParameters"), TEXT(""),
	TEXT("APPID\\%s"), szRegCLSID, TEXT("LocalService"), SERVICE_NAME,
	0
};
// registration data for any machine where the service will be installed,
// regardless of whether or not this process is that service
const ICHAR* rgszRegAnyServiceData[] = {
	TEXT("CLSID\\%s"), szRegCLSID, TEXT("AppId"), szRegCLSID,
	0
};

#endif


// writes registry keys under HKCR from an array of strings. Format of input data is
// <key>, <string>, <name>, <value> where <key> can have one C-style formatting
// string to be replaced by <string>. The last entry in the arry begins with 0 to
// signal termination.
bool WriteRegistryData(const ICHAR* rgszRegData[])
{
	bool fRegOK = true;
	const ICHAR** pszData = rgszRegData;

	while (*pszData)
	{
		const ICHAR* szTemplate = *pszData++;
		ICHAR szRegKey [256];
		HKEY hKey = 0;
		RETURN_THAT_IF_FAILED(StringCchPrintf(szRegKey, ARRAY_ELEMENTS(szRegKey), szTemplate, *pszData++),
									 false);
		const ICHAR* pszValueName = *pszData++;
		const ICHAR* pszValue = *pszData++;
		// on Win64 this gets called only in 64-bit context, so there should be no worries
		// about any extra REGSAM flags
		if (RegCreateKeyAPI(HKEY_CLASSES_ROOT, szRegKey, 0, 0, 0,
								 KEY_READ|KEY_WRITE, 0, &hKey, 0) != ERROR_SUCCESS
			|| RegSetValueEx(hKey, pszValueName, 0, REG_SZ,
			(CONST BYTE*)pszValue, (IStrLen(pszValue)+1)*sizeof(ICHAR)) != ERROR_SUCCESS)
		{
#ifdef DEBUG
			ICHAR rgchDebug[100];
			StringCchPrintf(rgchDebug, ARRAY_ELEMENTS(rgchDebug), TEXT("MSI: Failed during registration creating key HKCR\\%s with name-value pair: %s, %s. GetLastError: %d\r\n"), szRegKey, pszValueName, pszValue, GetLastError());
			OutputDebugString(rgchDebug);
#endif
			fRegOK = false;
		}
		REG::RegCloseKey(hKey);
	}
	return fRegOK;
}

// Removes registry keys under HKCR. Input is the same as above.
bool DeleteRegistryData(const ICHAR* rgszRegData[])
{
	bool fRegOK = true;
	const ICHAR** pszData = rgszRegData;

	while (*pszData)
	{
		const ICHAR* szTemplate = *pszData++;
		ICHAR szRegKey [256];
		HKEY hKey = 0;
		RETURN_THAT_IF_FAILED(StringCchPrintf(szRegKey, ARRAY_ELEMENTS(szRegKey), szTemplate, *pszData++),
									 false)
		pszData++;
		pszData++;
		long lResult = REG::RegDeleteKey(HKEY_CLASSES_ROOT, szRegKey);
		if((ERROR_KEY_DELETED != lResult) &&
			(ERROR_FILE_NOT_FOUND != lResult) && (ERROR_SUCCESS != lResult))
			{
#ifdef DEBUG
				ICHAR rgchDebug[256];
				StringCchPrintf(rgchDebug, ARRAY_ELEMENTS(rgchDebug), TEXT("MSI: Failed during unregistration deleting key HKCR\\%s. GetLastError: %d\r\n"), szRegKey, GetLastError());
				OutputDebugString(rgchDebug);
#endif
				fRegOK = false;
			}
	}
	return fRegOK;
}


HRESULT __stdcall
DllRegisterServer()
{
	HRESULT hRes = 0;

#ifdef WIN
	// GetModuleFileName does not guarantee null termination if buffer is exactly the right size
	if (WIN::GetModuleFileName(g_hInstance, szRegFilePath, ARRAY_ELEMENTS(szRegFilePath)-1) == 0)
		return WIN::GetLastError();
	szRegFilePath[ARRAY_ELEMENTS(szRegFilePath)-1] = TEXT('\0');

#if defined(_EXE) && !defined(SERVICE_NAME)
	hRes = StringCchCat(szRegFilePath, ARRAY_ELEMENTS(szRegFilePath), " /Automation");
	RETURN_IT_IF_FAILED(hRes)
# endif // _EXE && !SERVICE_NAME
# else
	AliasHandle     hAlias = 0;
	{
	OSErr           err = noErr;
	FInfo           finfo;

	err = FSpGetFInfo (&g_FileSpec, &finfo);
	if (noErr != err)
		return (E_FAIL);

	err = NewAlias (0, &g_FileSpec, &hAlias);
	if (noErr != err)
		return (E_FAIL);
	}
#endif // WIN
	int cErr = 0;
	for (int iCLSID = 0; iCLSID < CLSID_COUNT; iCLSID++)
	{
		const ICHAR** psz = rgszRegData;
#if defined(__ASSERT) && defined(ASSERT_HANDLING)
		Assert(MODULE_DESCRIPTIONS[iCLSID] != 0);
		Assert(MODULE_FACTORIES[iCLSID] != 0);
#endif //ASSERT
		hRes = StringCchPrintf(szRegCLSID, ARRAY_ELEMENTS(szRegCLSID), TEXT("{%08lX-0000-0000-C000-000000000046}"), MODULE_CLSIDS[iCLSID].Data1);
		RETURN_IT_IF_FAILED(hRes)
#ifdef REGISTER_TYPELIB
		hRes = StringCchPrintf(szRegLIBID, ARRAY_ELEMENTS(szRegLIBID), TEXT("{%08lX-0000-0000-C000-000000000046}"), IID_MsiTypeLib.Data1);
		RETURN_IT_IF_FAILED(hRes)
#endif
		if (MODULE_PROGIDS[iCLSID])
			hRes = StringCchCopy(szRegProgId, ARRAY_ELEMENTS(szRegProgId), MODULE_PROGIDS[iCLSID]);
		if ( SUCCEEDED(hRes) )
			hRes = StringCchCopy(szRegDescription, ARRAY_ELEMENTS(szRegDescription), MODULE_DESCRIPTIONS[iCLSID]);
		RETURN_IT_IF_FAILED(hRes)

		while (*psz)
		{
			if ((*(psz+1) != 0) && (*(psz+2) != 0)) // handle NULL ProgID
			{
				ICHAR szRegKey[80];
				const ICHAR* szTemplate = *psz++;
				hRes = StringCchPrintf(szRegKey, ARRAY_ELEMENTS(szRegKey), szTemplate, *psz++);
				RETURN_IT_IF_FAILED(hRes)
				HKEY hkey;
				if (RegCreateKeyAPI(HKEY_CLASSES_ROOT, szRegKey, 0, 0, 0,
												KEY_READ|KEY_WRITE, 0, &hkey, 0) != ERROR_SUCCESS
				 || REG::RegSetValueEx(hkey, 0, 0, REG_SZ, (CONST BYTE*)*psz, (lstrlen(*psz)+1)*sizeof(ICHAR)) != ERROR_SUCCESS)
				{
#ifdef DEBUG
					ICHAR rgchDebug[100];
					StringCchPrintf(rgchDebug, ARRAY_ELEMENTS(rgchDebug), TEXT("MSI: Failed during registration creating key HKCR\\%s with default value %s. GetLastError returned %d.\r\n"), szRegKey, *psz, GetLastError());
					OutputDebugString(rgchDebug);
#endif
					cErr++;
				}
				psz++;

				if (*psz) // name/value pair
				{
					if (REG::RegSetValueEx(hkey, *psz, 0, REG_SZ, (CONST BYTE*)*(psz+1), (lstrlen(*psz+1)+1)*sizeof(ICHAR)) != ERROR_SUCCESS)
					{
#ifdef DEBUG
						ICHAR rgchDebug[100];
						StringCchPrintf(rgchDebug, ARRAY_ELEMENTS(rgchDebug), TEXT("MSI: Failed during registration creating value %s=%s. GetLastError returned %d.\r\n"), *psz, *(psz+1), GetLastError());
						OutputDebugString(rgchDebug);
#endif
						cErr++;
					}

				}
				psz+=2;
				
				REG::RegCloseKey(hkey);
			}
		}

#ifdef SERVICE_NAME
		// Register services-specific registry entries
		if (g_fRegService)
		{
			// while registering the service on a 64bit OS, also register a path
			// to us under HKLM so our better half can find the path to this EXE
			// on 32bit system do not write the key at all.
			{
				DWORD   dwError = ERROR_SUCCESS;
				char *  rgchSD = NULL;
				
				#ifdef UNICODE	// No security on Win9X (ANSI version)
				if (ERROR_SUCCESS == (dwError = GetSecureSecurityDescriptor(&rgchSD)))
				#endif
				{
					SECURITY_ATTRIBUTES sa;
					HKEY                hKey = NULL;
					REGSAM				samDesired = KEY_READ | KEY_WRITE;
					BOOL				fDone = FALSE;
					BOOL				fTryWithAddedPrivs = FALSE;
					
					#ifdef _WIN64
					samDesired |= KEY_WOW64_64KEY;
					#else
					BOOL bRunningOnWow64 = RunningOnWow64();
					if (bRunningOnWow64)
						samDesired |= KEY_WOW64_64KEY;
					#endif
					

					sa.nLength        = sizeof(sa);
					sa.bInheritHandle = FALSE;
					sa.lpSecurityDescriptor = rgchSD;	// ignored on Win9X and therefore set to NULL.
					// Always create this in the 64-bit hive.
					// Note: this code will only be executed on 64-bit machines
				    	//       and it will be executed for both 32-bit and 64-bit
					//       msiexec's.
					
					for (dwError = ERROR_SUCCESS; !fDone; fTryWithAddedPrivs = TRUE)
					{
						//
						// On NT4 machines, RegCreateKeyEx fails if the privilege
						// for assigning other users as owners is not enabled for the admin.
						// This is the default case on NT4. Therefore, if RegCreateKeyEx fails
						// the first time, we try again after enabling the required privileges.
						// If it still fails, then we are probably running into some other error
						// which we need to propagate back up.
						//
					
						// required to write owner information
						CRefCountedTokenPrivileges cTokenPrivs(itkpSD_WRITE, fTryWithAddedPrivs);

						if (fTryWithAddedPrivs)
						{
							fDone = TRUE;	// We only want to try RegCreateKeyEx once after enabling the privileges.
									// If it still fails, there's nothing we can do about it.
						}
						dwError = RegCreateKeyAPI(HKEY_LOCAL_MACHINE, 
													  szSelfRefMsiExecRegKey, 
													  0, 
													  0, 
													  0,
													  samDesired, 
													  &sa, 
													  &hKey, 
													  0);
						if (ERROR_SUCCESS == dwError)
							fDone = TRUE;
					}
					
					if (ERROR_SUCCESS != dwError)
					{
						cErr++;
					}
					else
					{
						//
						// First extract the path to the folder where msiexec is located and
						// store that path
						//
						ICHAR * szSlash = NULL;
						szSlash = IStrRChr (szRegFilePath, TEXT('\\'));
						if (! szSlash || (szSlash == szRegFilePath))	// Should never happen since szRegFilePath contains the full path
						{
							cErr++;
						}
						else
						{
							#ifndef _WIN64
							if (!bRunningOnWow64)	// Only the 64-bit binary should register the location on 64-bit machines.
							#endif
							{
								*szSlash = TEXT('\0');	// Extract the path to the folder where the module resides
								if (REG::RegSetValueEx(hKey, szMsiLocationValueName, 0, REG_SZ, (CONST BYTE*)szRegFilePath, (lstrlen(szRegFilePath)+1)*sizeof(ICHAR)) != ERROR_SUCCESS)
									cErr++;
								*szSlash = TEXT('\\');	//Reset the slash to get back the full path
							}
						}
						
					#ifdef _WIN64
						if (REG::RegSetValueEx(hKey, szMsiExec64ValueName, 0, REG_SZ, (CONST BYTE*)szRegFilePath, (lstrlen(szRegFilePath)+1)*sizeof(ICHAR)) != ERROR_SUCCESS)
					#else
						if (bRunningOnWow64 && REG::RegSetValueEx(hKey, szMsiExec32ValueName, 0, REG_SZ, (CONST BYTE*)szRegFilePath, (lstrlen(szRegFilePath)+1)*sizeof(ICHAR)) != ERROR_SUCCESS)
					#endif
							cErr++;
						REG::RegCloseKey(hKey);
					}
				}
				#ifdef UNICODE	// No security on Win9x -- ANSI version.
				else
				{
					cErr++;
				}
				#endif

			}

			if (ServiceSupported())
				cErr += (WriteRegistryData(rgszRegThisServiceData) ? 0 : 1);

			if (ServiceSupported() || RunningOnWow64())
				cErr += (WriteRegistryData(rgszRegAnyServiceData) ? 0 : 1);
		}

		// if running in NT setup
		HKEY hKey;
		// Win64: I've checked and it's in 64-bit location.
		if (ERROR_SUCCESS == MsiRegOpen64bitKey(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\Setup"), 0, KEY_QUERY_VALUE, &hKey))
		{
			DWORD dwData;
			DWORD cbDataSize = sizeof(dwData);
			if ((ERROR_SUCCESS == RegQueryValueEx(hKey, TEXT("SystemSetupInProgress"), 0, NULL, reinterpret_cast<unsigned char *>(&dwData), &cbDataSize)) &&
				(dwData == 1))
			{
				PROCESS_INFORMATION ProcInfo;
				STARTUPINFO si;
				
				memset(&si, 0, sizeof(si));
				si.cb        = sizeof(si);

				if (CreateProcess(TEXT("MsiRegMv.Exe"), NULL, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &ProcInfo))
				{
					WaitForSingleObject(ProcInfo.hProcess, INFINITE);
					CloseHandle(ProcInfo.hProcess);
					CloseHandle(ProcInfo.hThread);
				}
				else
				{
#ifdef DEBUG
                    OutputDebugString(TEXT("MSI: Unable to launch Migration EXE."));
#endif
				}
			}
			RegCloseKey(hKey);
		}


#endif //SERVICE_NAME

	}

	if (cErr)
		return SELFREG_E_CLASS;

#ifdef REGISTER_TYPELIB
	ITypeLib* piTypeLib = 0;
	
	// GetModuleFileName does not guarantee null termination if buffer is exactly the right size
	int cch = WIN::GetModuleFileName(g_hInstance, szRegFilePath, ARRAY_ELEMENTS(szRegFilePath)-1); 
	if (cch == 0)
		return WIN::GetLastError();
	szRegFilePath[ARRAY_ELEMENTS(szRegFilePath)-1] = TEXT('\0');

#ifdef UNICODE
	HRESULT hres = LoadTypeLib(szRegFilePath, &piTypeLib);
	if (hres == TYPE_E_INVDATAREAD)  // ignore if Win95 virgin OLEAUT32.DLL, different typelib format
		return S_OK;
	if (hres != S_OK)
		return SELFREG_E_TYPELIB;
	hres = RegisterTypeLib(piTypeLib, szRegFilePath, 0);
#else
	OLECHAR szTypeLibPath[MAX_PATH];
	WIN::MultiByteToWideChar(CP_ACP, 0, szRegFilePath, cch+1, szTypeLibPath, MAX_PATH);
	HRESULT hres = LoadTypeLib(szTypeLibPath, &piTypeLib);
	if (hres == TYPE_E_INVDATAREAD)  // ignore if Win95 virgin OLEAUT32.DLL, different typelib format
		return S_OK;
	if (hres != S_OK)
		return SELFREG_E_TYPELIB;
	hres = RegisterTypeLib(piTypeLib, szTypeLibPath, 0);
#endif
	piTypeLib->Release();
	if (hres != S_OK)
		return SELFREG_E_TYPELIB;
//NT4,Win95 only: if (OLE::LoadTypeLibEx(szTypeLibPath, REGKIND_REGISTER, &piTypeLib) != S_OK)
#endif // REGISTER_TYPELIB

#ifdef DLLREGISTEREXTRA
	DLLREGISTEREXTRA();
#endif //DLLREGISTEREXTRA

	return NOERROR;
}


HRESULT __stdcall
DllUnregisterServer()
{
#ifdef DLLUNREGISTEREXTRA
	DLLUNREGISTEREXTRA();
#endif //DLLUNREGISTEREXTRA

#ifdef REG
	ICHAR szRegKey[80];
	int cErr = 0;
	// unregister keys under CLSID and ProgId
	for (int iCLSID = 0; iCLSID < CLSID_COUNT; iCLSID++)
	{
		const ICHAR** psz = rgszRegData;
		HRESULT hRes = 0;
		hRes = StringCchPrintf(szRegCLSID, ARRAY_ELEMENTS(szRegCLSID), TEXT("{%08lX-0000-0000-C000-000000000046}"), MODULE_CLSIDS[iCLSID].Data1);
		RETURN_IT_IF_FAILED(hRes)
#ifdef REGISTER_TYPELIB
		hRes = StringCchPrintf(szRegLIBID, ARRAY_ELEMENTS(szRegLIBID), TEXT("{%08lX-0000-0000-C000-000000000046}"), IID_MsiTypeLib.Data1);
		RETURN_IT_IF_FAILED(hRes)
#endif
		if (MODULE_PROGIDS[iCLSID])
		{
			hRes = StringCchCopy(szRegProgId, ARRAY_ELEMENTS(szRegProgId), MODULE_PROGIDS[iCLSID]);
			RETURN_IT_IF_FAILED(hRes)
		}

		while (*psz)
		{
			if ((*(psz+1) != 0) && (*(psz+2) != 0)) // handle NULL ProgID
			{

				const ICHAR* szTemplate = *psz++;
				hRes = StringCchPrintf(szRegKey, ARRAY_ELEMENTS(szRegKey), szTemplate, *psz++);
				RETURN_IT_IF_FAILED(hRes)

				long lResult = REG::RegDeleteKey(HKEY_CLASSES_ROOT, szRegKey);
				if((ERROR_KEY_DELETED != lResult) &&
					(ERROR_FILE_NOT_FOUND != lResult) && (ERROR_SUCCESS != lResult))
				{
#ifdef DEBUG
					ICHAR rgchDebug[256];
					StringCchPrintf(rgchDebug, ARRAY_ELEMENTS(rgchDebug), TEXT("MSI: Failed during unregistration deleting key HKCR\\%s. Result: %d GetLastError: %d\r\n"), szRegKey, lResult, GetLastError());
					OutputDebugString(rgchDebug);
#endif
					cErr++;

				}

				psz+= 3;
			}
		}
	}

#ifdef SERVICE_NAME
	Bool fFirstItem = fTrue;

	// while unregistering the service on a 64bit OS, also unregister the path
	// to us under HKLM.
	{
		HKEY 	hKey;
		REGSAM	samDesired = KEY_READ | KEY_WRITE;
		
		#ifdef _WIN64
		samDesired |= KEY_WOW64_64KEY;
		#else
		BOOL bRunningOnWow64 = RunningOnWow64();
		if (bRunningOnWow64)
			samDesired |= KEY_WOW64_64KEY;
		#endif
		
		if (RegOpenKeyAPI(HKEY_LOCAL_MACHINE, szSelfRefMsiExecRegKey, 0, samDesired, &hKey) != ERROR_SUCCESS)
		{
			cErr++;
		}
		else
		{
			#ifndef _WIN64
			if (!bRunningOnWow64)	// On Win64, the installer location value is controlled by the 64-bit binary.
			#endif
			{
				if (REG::RegDeleteValue(hKey, szMsiLocationValueName) != ERROR_SUCCESS)
					cErr++;
			}
#ifdef _WIN64
			if (REG::RegDeleteValue(hKey, szMsiExec64ValueName) != ERROR_SUCCESS)
#else
			if (bRunningOnWow64 && REG::RegDeleteValue(hKey, szMsiExec32ValueName) != ERROR_SUCCESS)
#endif
				cErr++;
			REG::RegCloseKey(hKey);
		}
	}

	if (ServiceSupported())
		cErr += (DeleteRegistryData(rgszRegThisServiceData)) ? 0 : 1;

	if (ServiceSupported() || RunningOnWow64())
		cErr += (DeleteRegistryData(rgszRegAnyServiceData)) ? 0 : 1;

#endif //SERVICE_NAME


#ifndef REGISTER_TYPELIB
	return NOERROR;
#else
	// NT 3.51 oleaut32.dll does not support UnRegisterTypeLib until service pack 5
	OLE::UnRegisterTypeLib(IID_MsiTypeLib, TYPELIB_MAJOR_VERSION, TYPELIB_MINOR_VERSION, 0x0409, SYS_WIN32);
	return cErr ? SELFREG_E_CLASS : NOERROR;
#endif // REGISTER_TYPELIB
#else
	return E_FAIL;
#endif // REG
}


//____________________________________________________________________________
//
// DLL entry points
//____________________________________________________________________________


#if !defined(_EXE)

HRESULT __stdcall
DllGetVersion(DLLVERSIONINFO *pverInfo)
{

	if (pverInfo->cbSize < sizeof(DLLVERSIONINFO))
		return E_FAIL;

	pverInfo->dwMajorVersion = rmj;
	pverInfo->dwMinorVersion = rmm;
	pverInfo->dwBuildNumber = rup;
#ifdef UNICODE
	pverInfo->dwPlatformID = DLLVER_PLATFORM_NT;
#else
	pverInfo->dwPlatformID = DLLVER_PLATFORM_WINDOWS;
#endif
	return NOERROR;
}

int __stdcall
DllMain(HINSTANCE hInst, DWORD fdwReason, void* /*pvreserved*/)
{
	if (fdwReason == DLL_PROCESS_ATTACH)
	{
		g_hInstance = hInst;
#ifdef MODULE_INITIALIZE
		MODULE_INITIALIZE();
#endif
		DisableThreadLibraryCalls(hInst);
	}
	else if (fdwReason == DLL_PROCESS_DETACH)
	{
#ifdef MODULE_TERMINATE
		MODULE_TERMINATE();
#endif
		g_hInstance = 0;
	}
	return TRUE;
};


extern "C" HRESULT __stdcall
DllGetClassObject(const GUID& clsid, const IID& iid, void** ppvRet)
{
	*ppvRet = 0;

#ifdef PRE_CLASS_FACTORY_HANDLER
	HRESULT ret = (*PRE_CLASS_FACTORY_HANDLER)(clsid, iid, ppvRet);
	if (ret == NOERROR)
		return ret;
#endif

	if (!(iid == IID_IUnknown || iid == IID_IClassFactory))
		return E_NOINTERFACE;

	for (int iCLSID = 0; iCLSID < CLSID_COUNT; iCLSID++)
	{
		if (MsGuidEqual(clsid, MODULE_CLSIDS[iCLSID]))
		{
			*ppvRet = &g_rgcfModule[iCLSID];
			return NOERROR;
		}
	}
#ifdef CLASS_FACTORY_HANDLER
	return (*CLASS_FACTORY_HANDLER)(clsid, iid, ppvRet);
#else
	return E_FAIL;
#endif
}

HRESULT __stdcall
DllCanUnloadNow()
{
  return g_cInstances ? S_FALSE : S_OK;
}
#endif //!defined(_EXE)

//____________________________________________________________________________
//
// Routines to set access g_iTestFlags from _MSI_TEST environment variable
//____________________________________________________________________________

static bool fTestFlagsSet = false;

bool SetTestFlags()
{
	fTestFlagsSet = true;
	ICHAR rgchBuf[64];
	if (0 == WIN::GetEnvironmentVariable(TEXT("_MSI_TEST"), rgchBuf, sizeof(rgchBuf)/sizeof(ICHAR)))
		return false;
	ICHAR* pch = rgchBuf;
	int ch;
	while ((ch = *pch++) != 0)
		g_iTestFlags |= (1 << (ch & 31));
	return true;
}

bool GetTestFlag(int chTest)
{
	if (!fTestFlagsSet)
		SetTestFlags();
	chTest = (1 << (chTest & 31));
	return (chTest & g_iTestFlags) == chTest;
}

//____________________________________________________________________________
//
// IClassFactory implementation - static object, not ref counted
//____________________________________________________________________________

HRESULT CModuleFactory::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IClassFactory)
	{
		*ppvObj = this;
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}
unsigned long CModuleFactory::AddRef()
{
	return 1;
}
unsigned long CModuleFactory::Release()
{
	return 1;
}

HRESULT CModuleFactory::CreateInstance(IUnknown* pUnkOuter, const IID& riid,
													void** ppvObject)
{
	INT_PTR iCLSID = this - g_rgcfModule;  // find out which factory we are     //--merced: changed int to INT_PTR

	if (!ppvObject)
		return E_INVALIDARG;

	if (pUnkOuter)
		return CLASS_E_NOAGGREGATION;
#ifdef IDISPATCH_INSTANCE
	if (!(riid == IID_IUnknown || riid == MODULE_CLSIDS[iCLSID]|| riid == IID_IDispatch))
#else
	if (!(riid == IID_IUnknown || riid == MODULE_CLSIDS[iCLSID]))
#endif
		return E_NOINTERFACE;

#ifdef SERVICE_NAME
	// suspend the shutdown timer before creating the object (only in service)
	if (g_hShutdownTimer != INVALID_HANDLE_VALUE)
	{
		KERNEL32::CancelWaitableTimer(g_hShutdownTimer);

		// check to see if the timer was triggered before it was cancelled. If so,
		// this process is shutting down and this CreateInstance call slipped in
		// at the last second.
		if (WAIT_TIMEOUT != WaitForSingleObject(g_hShutdownTimer, 0))
		{
			*ppvObject = NULL;
			return CO_E_SERVER_STOPPING;
		}
	}
#endif

	*ppvObject = MODULE_FACTORIES[iCLSID]();
	if (!(*ppvObject))
	{
#ifdef SERVICE_NAME
		// failed to create object. Check with the DLL to see if any other objects are running. If not
		// reset the timer.
		if ((g_hShutdownTimer != INVALID_HANDLE_VALUE) && !FInstallInProgress())
		{
			LARGE_INTEGER liDueTime = {0,0};
			liDueTime.QuadPart = -iServiceShutdownTime;
			AssertNonZero(!KERNEL32::SetWaitableTimer(g_hShutdownTimer, &liDueTime, 0, NULL, NULL, FALSE));
		}
#endif
		return E_OUTOFMEMORY;
	}
	return NOERROR;
}


HRESULT CModuleFactory::LockServer(OLEBOOL fLock)
{
   if (fLock)
	  g_cInstances++;
   else if (g_cInstances)
	{
		g_cInstances--;
#ifdef _EXE
		ReportInstanceCountChange();
#endif
	}
	return NOERROR;
}

#if defined(MEM_SERVICES) || defined(TRACK_OBJECTS)
const TCHAR rgchLFCRDbg[3] = {'\r', '\n', '\0'};
#endif

const int cchTempBuffer = 256;  //!! perhaps we should dynamically size this? or at least check

#ifdef TRACK_OBJECTS

#ifdef cmitObjects

TCHAR *pszRCA[3]= {
	TEXT("Created"),
	TEXT("AddRef"),
	TEXT("Release")
};

#ifdef DEFINE_REFHEAD
CMsiRefHead g_refHead;
#endif //DEFINE_REFHEAD

extern CMsiRefHead g_refHead;
bool g_fLogRefs = fFalse;
bool g_fNoPreflightInits = fFalse;

void SetFTrackFlagSz(char *psz);

CMsiRefHead::CMsiRefHead()
{
	char    rgchDbg [256];
	char* pchDbg, *pchStart;

	// Set the initial items to track based on the environment variable
	if (GetEnvironmentVariableA ("TRACK_OBJECTS", rgchDbg, sizeof(rgchDbg)))
	{
		pchDbg = pchStart = rgchDbg;
		while ( *pchDbg != 0 )
		{
			if (*pchDbg == ',')
			{
				*pchDbg = 0;
				SetFTrackFlagSz(pchStart);
				pchStart = pchDbg + 1;
			}
			pchDbg++;
		}
		SetFTrackFlagSz(pchStart);

	}

	if (GetEnvironmentVariableA ("LOGREFS", rgchDbg, sizeof(rgchDbg)))
		g_fLogRefs = (atoi(rgchDbg) != 0) ? fTrue : fFalse;

}

void SetFTrackFlagSz(char *psz)
{
	int iid = 0;

	sscanf(psz, "%x", &iid);
	SetFTrackFlag(iid, fTrue);
}

#define clinesMax   20

#include <typeinfo.h>

CMsiRefHead::~CMsiRefHead()
{

#ifndef IN_SERVICES
extern IMsiDebug* g_piDebugServices;
extern IMsiServices* g_AssertServices;
	g_piDebugServices = 0;
	g_AssertServices = 0;
#endif //IN_SERVICES
	g_fFlushDebugLog = false;
	AssertEmptyRefList(this);

}

void AssertEmptyRefList(CMsiRefHead *prfhead)
{
	CMsiRefBase* pmrbClass;

	// Need to see if our linked list is empty
	pmrbClass = prfhead->m_pmrbNext;

	// Display all of the MRBs
	while (pmrbClass != 0)
	{
		DisplayMrb(pmrbClass);
		pmrbClass = pmrbClass->m_pmrbNext;
	}

}


void DisplayMrb(CMsiRefBase* pmrb)
{
	TCHAR szTemp[cchTempBuffer + (100 * cFuncStack)];
	RCAB *prcab;
	int cch, cchMsg;
	const DWORD cchMessageBuf = 8192;
	TCHAR* pMessage = new TCHAR[cchMessageBuf];
	int cLines;
	const char *pstName;

	if(pMessage == NULL)
	{
		return;
	}

	prcab = &(pmrb->m_rcabFirst);
// Debug is the only place where we have RTTI info
#ifdef DEBUG
	if (pmrb->m_pobj != 0)
	{
		const type_info& rtyp = typeid(*(IUnknown *)((char *)pmrb->m_pobj));
		pstName = rtyp.name();
	}
	else
		pstName = "";
	// Using hs because pstName is a char *
	if(FAILED(StringCchPrintf(pMessage, cchMessageBuf,
												TEXT("Object not released correctly - %hs"), pstName)))
	{
		delete [] pMessage;
		return;
	}
#else
	if(FAILED(StringCchCopy(pMessage, cchMessageBuf,
											 TEXT("Object not released correctly")))
	{
		delete [] pMessage;
		return;
	}
#endif //DEBUG
	cchMsg = cchMessageBuf - lstrlen(pMessage);
	cLines = clinesMax;
	while (prcab != 0)
	{
		if ( FAILED(StringCchPrintf(szTemp, ARRAY_ELEMENTS(szTemp),
											 TEXT("Action - %s\r\n"), pszRCA[prcab->rca])) )
			// we go ahead and display what we've got so far
			goto Display;
		cch = lstrlen(szTemp);
		ListSzFromRgpaddr(szTemp + cch, ARRAY_ELEMENTS(szTemp) - cch, prcab->rgpaddr, cFuncStack, true);
		// If too large, show assert and clear out
		if (cchMsg < (cch = lstrlen(szTemp)) || cLines < cFuncStack + 1)
		{
			FailAssertMsg(pMessage);
			pMessage[0] = 0;
			cchMsg = cchMessageBuf;
			cLines = clinesMax;
		}
		else
		{
			if ( FAILED(StringCchCat(pMessage, cchMessageBuf, rgchLFCRDbg)) )
				// we go ahead and display what we've got so far
				goto Display;
			cchMsg -= IStrLen(rgchLFCRDbg);
		}
		if ( FAILED(StringCchCat(pMessage, cchMessageBuf, szTemp)) )
			// we go ahead and display what we've got so far
			goto Display;
		cchMsg -= cch;
		cLines -= cFuncStack + 1;
		prcab = prcab->prcabNext;
	}
Display:
	if ( *pMessage )
		FailAssertMsg(pMessage);

	delete [] pMessage;
}

//
// Sets the track flag to fTrack for the given iid
// to make things easy, we will just take the low word of this
// iid
void SetFTrackFlag(int iid, Bool fTrack)
{
	int i;
	extern const MIT rgmit[cmitObjects];

	iid = iid & 0xff;

	for (i = 0 ; i < cmitObjects ; i++)
	{
		if ((rgmit[i].iid & 0xff) == iid)
		{
			*(rgmit[i].pfTrack) = fTrack;
			break;
		}
	}

}

// Inserts an object into the Object Linked List
void InsertMrb(CMsiRefBase* pmrbHead, CMsiRefBase* pmrbNew)
{
	if ((pmrbNew->m_pmrbNext = pmrbHead->m_pmrbNext) != 0)
		pmrbHead->m_pmrbNext->m_pmrbPrev = pmrbNew;

	pmrbHead->m_pmrbNext = pmrbNew;
	pmrbNew->m_pmrbPrev = pmrbHead;

}

// Removes an object from the Object linked List
void RemoveMrb(CMsiRefBase* pmrbDel)
{

	if (pmrbDel->m_pmrbNext != 0)
		pmrbDel->m_pmrbNext->m_pmrbPrev = pmrbDel->m_pmrbPrev;

	if (pmrbDel->m_pmrbPrev != 0)
		pmrbDel->m_pmrbPrev->m_pmrbNext = pmrbDel->m_pmrbNext;

}

void TrackObject(RCA rca, CMsiRefBase* pmrb)
{
	RCAB *prcabNew, *prcab;
	const int cReleasesBeforeLoad = 10;
	static cCount = cReleasesBeforeLoad;

	prcab = &(pmrb->m_rcabFirst);

	// Move to the end of the list
	while (prcab->prcabNext != 0)
		prcab = prcab->prcabNext;

	prcabNew = (RCAB *)AllocSpc(sizeof(RCAB));

	prcab->prcabNext = prcabNew;

	prcabNew->rca = rca;
	prcabNew->prcabNext = 0;

	FillCallStack(prcabNew->rgpaddr, cFuncStack, 2);

	if (rca == rcaRelease && !g_fNoPreflightInits)
	{
		cCount--;
		InitSymbolInfo(cCount <= 0 ? true : false);
		if (cCount <= 0)
			cCount = cReleasesBeforeLoad;
	}

	if (g_fLogRefs)
	{
		// Immediate logging
		LogObject(pmrb, prcabNew);
	}

}

void LogObject(CMsiRefBase* pmrb, RCAB *prcabNew)
{
	TCHAR szMessage[cchTempBuffer + (100 * cFuncStack)];
	int cch;

	RETURN_IF_FAILED(StringCchPrintf(szMessage, ARRAY_ELEMENTS(szMessage), TEXT("Object - 0x%x\r\n"), pmrb->m_pobj))
	cch = IStrLen(szMessage);
	RETURN_IF_FAILED(StringCchPrintf(szMessage + cch, ARRAY_ELEMENTS(szMessage) - cch, TEXT("Action - %s\r\n"), pszRCA[prcabNew->rca]))
	cch = IStrLen(szMessage);
	ListSzFromRgpaddr(szMessage + cch, sizeof(szMessage)/sizeof(TCHAR) - cch, prcabNew->rgpaddr, cFuncStack, true);
	LogAssertMsg(szMessage);
}


#endif //cmitObjects

// Fills in the array rgCallAddr of length cCallStack with
// called function addresses
// cSkip indicates how many addresses to skip initially
void FillCallStack(unsigned long* rgCallAddr, int cCallStack, int cSkip)
{
	GetCallingAddr2(plCallAddr, rgCallAddr);
	int i;
	unsigned long *plCallM1 = plCallAddr;

#if defined(_X86_)
	MEMORY_BASIC_INFORMATION memInfo;

	for (i = 0 ; i < cCallStack + cSkip ; i++)
	{
		if (i >= cSkip)
		{
			*(rgCallAddr) = *plCallM1;
			rgCallAddr++;
		}
		plCallM1 = (((unsigned long *)(*(plCallM1 - 1))) + 1);

		// Need to see if the address we have is still on the stack
		VirtualQuery(&plCallM1, &memInfo, sizeof(memInfo));
		if (plCallM1 < memInfo.BaseAddress || (char *)plCallM1 > (((char *)memInfo.BaseAddress) + memInfo.RegionSize))
		{
			i++;
			break;
		}
	}
#else
	// Otherwise cSkip is unreferenced
	cSkip = 0;
	for (i = 0 ; i < cCallStack ; i++)
	{
		*(rgCallAddr) = 0;
		rgCallAddr++;
	}
	i = cCallStack + cSkip;
#endif
	// Fill in any empty folks
	for ( ; i < cCallStack + cSkip ; i++)
	{
		*(rgCallAddr) = 0;
		rgCallAddr++;
	}

}

void FillCallStackFromAddr(unsigned long* rgCallAddr, int cCallStack, int cSkip, unsigned long *plAddrStart)
{
	int i;
	unsigned long *plCallM1 = plAddrStart;

#if defined(_X86_)
	MEMORY_BASIC_INFORMATION memInfo;

	for (i = 0 ; i < cCallStack + cSkip ; i++)
	{
		if (i >= cSkip)
		{
			*(rgCallAddr) = *plCallM1;
			rgCallAddr++;
		}
		plCallM1 = (((unsigned long *)(*(plCallM1 - 1))) + 1);

		// Need to see if the address we have is still on the stack
		VirtualQuery(&plCallM1, &memInfo, sizeof(memInfo));
		if (plCallM1 < memInfo.BaseAddress || (char *)plCallM1 > (((char *)memInfo.BaseAddress) + memInfo.RegionSize))
		{
			i++;
			break;
		}
	}
#else
	for (i = 0 ; i < cCallStack ; i++)
	{
		*(rgCallAddr) = 0;
		rgCallAddr++;
	}
	i = cCallStack + cSkip;
#endif

	// Fill in any empty folks
	for ( ; i < cCallStack + cSkip ; i++)
	{
		if (i >= cSkip)
		{
			*(rgCallAddr) = 0;
			rgCallAddr++;
		}
	}

}



#endif //TRACK_OBJECTS

#if defined(MEM_SERVICES)
#include <typeinfo.h>

#if (defined(DEBUG))
#define _IMAGEHLP_SOURCE_  // prevent import def error
#include "imagehlp.h"

typedef BOOL (IMAGEAPI* SYMINITIALIZE)(HANDLE hProcess,
	LPSTR    UserSearchPath, BOOL     fInvadeProcess);
typedef BOOL (IMAGEAPI* SYMGETSYMFROMADDR)(HANDLE hProcess, DWORD dwAddr,
	PDWORD pdwDisp, PIMAGEHLP_SYMBOL psym);
typedef BOOL (IMAGEAPI* SYMUNDNAME)(PIMAGEHLP_SYMBOL sym, LPSTR UnDecName,
	DWORD UnDecNameLength);
typedef BOOL (IMAGEAPI* SYMCLEANUP)(HANDLE hProcess);

typedef LPAPI_VERSION (IMAGEAPI* IMAGEHLPAPIVERSION)( void );
typedef BOOL (IMAGEAPI* SYMLOADMODULE)(HANDLE hProcess, HANDLE hFile, LPSTR ImageName,
	LPSTR ModuleName, DWORD BaseOfDll, DWORD SizeOfDll);

static SYMINITIALIZE    pSymInitialize = NULL;
static SYMGETSYMFROMADDR    pSymGetSymFromAddr = NULL;
static SYMUNDNAME   pSymUnDName = NULL;
static SYMCLEANUP   pSymCleanup = NULL;

static const GUID rgCLSIDLoad[] =
{
GUID_IID_IMsiServices,
GUID_IID_IMsiHandler,
GUID_IID_IMsiAuto,
};

static const char *rgszFileName[] =
{
"msi.dll",
"msihnd.dll",
"msiauto.dll"
};

#define cCLSIDs     (sizeof(rgCLSIDLoad)/sizeof(GUID))

static Bool fSymInit = fFalse;
static Bool fUse40Calls = fFalse;
static PIMAGEHLP_SYMBOL piSymMem4 = 0;
static Bool fDontGetName = fFalse;

#ifdef __cplusplus
extern "C" {
BOOL GetProcessModules(HANDLE  hProcess);
}
#endif // __cplusplus

void InitSymbolInfo(bool fLoadModules)
{
#ifdef WIN
	HANDLE hProcessCur = GetCurrentProcess();
	static SYMLOADMODULE pSymLoadModule;
	DWORD err;
	Bool fOnWin95 = fFalse;
	char rgchBuf[MAX_PATH];

	if (!fSymInit)
	{
		// GetModuleFileName does not guarantee null termination if buffer is exactly the right size
		int cchName = GetModuleFileNameA(g_hInstance, rgchBuf, sizeof(rgchBuf)-1);
		if (cchName == 0)
			return;
		rgchBuf[ARRAY_ELEMENTS(rgchBuf)-1] = TEXT('\0');
		

		fLoadModules = fTrue;
		GetShortPathNameA(rgchBuf, rgchBuf, sizeof(rgchBuf));
		char* pch = rgchBuf + lstrlenA(rgchBuf);
		while (*(--pch) != '\\')  //!!should use enum directory separator char
			;

		*pch = 0;

		OSVERSIONINFO osviVersion;
		osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
		AssertNonZero(GetVersionEx(&osviVersion)); // fails only if size set wrong

		if (osviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
		{
			fOnWin95 = fTrue;
		}

		HINSTANCE hInst = LoadLibrary(TEXT("imagehlp.dll"));
		IMAGEHLPAPIVERSION pfnApiVer;
		LPAPI_VERSION lpapiVer;

		if (hInst)
		{

			pfnApiVer = (IMAGEHLPAPIVERSION)GetProcAddress(hInst, "ImagehlpApiVersion");

			if (pfnApiVer)
			{
				lpapiVer = pfnApiVer();

				if (lpapiVer->MajorVersion > 3 ||
					(lpapiVer->MajorVersion == 3 && lpapiVer->MinorVersion > 5) ||
					(lpapiVer->MajorVersion == 3 && lpapiVer->MinorVersion == 5 && lpapiVer->Revision >= 4))
				{
					fUse40Calls = fTrue;
					// Allocate space and include extra for the string
					piSymMem4 = (PIMAGEHLP_SYMBOL)GlobalAlloc(GMEM_FIXED, sizeof(IMAGEHLP_SYMBOL) + 256);
					piSymMem4->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
					piSymMem4->MaxNameLength = 256;
				}
			}

			pSymInitialize =
				(SYMINITIALIZE)GetProcAddress(hInst,
				"SymInitialize");

			pSymGetSymFromAddr  = (SYMGETSYMFROMADDR)GetProcAddress(hInst,
				"SymGetSymFromAddr");
			pSymUnDName   = (SYMUNDNAME)GetProcAddress(hInst,
				"SymUnDName");

			pSymCleanup =
				(SYMCLEANUP)GetProcAddress(hInst,
				"SymCleanup");

			pSymLoadModule = (SYMLOADMODULE)GetProcAddress(hInst, "SymLoadModule");

			if (!hInst || !pSymInitialize || !pSymGetSymFromAddr
				|| !pSymUnDName || !fUse40Calls)
			{
				pSymInitialize = 0;
			}
		}

		if (pSymInitialize && pSymInitialize(hProcessCur, rgchBuf, (fOnWin95 ? FALSE : TRUE)))
		{
			fSymInit = fTrue;
		}
		else
		{
			err = GetLastError();
		}

	}

	if (fSymInit && fLoadModules)
	{
		if (fUse40Calls)
			{
				char rgchKey[256];
				char rgchPath[256];
				DWORD cbLen;
				DWORD type;
				HKEY hkey;
				int i;

				for (i = 0 ; i < cCLSIDs ; i++)
				{
					RETURN_IF_FAILED(StringCchPrintfA(rgchKey, ARRAY_ELEMENTS(rgchKey), "CLSID\\{%08lX-0000-0000-C000-000000000046}\\InprocServer32", rgCLSIDLoad[i].Data1))
					cbLen = sizeof(rgchPath);
					if (REG::RegOpenKeyExA(HKEY_CLASSES_ROOT, rgchKey, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
					{
						if (REG::RegQueryValueExA(hkey, NULL, NULL, &type, (unsigned char *)rgchPath, &cbLen) == ERROR_SUCCESS)
						{
							if (!pSymLoadModule(hProcessCur, NULL, (char *)rgchPath, NULL, 0, 0))
								err = GetLastError();
							RegCloseKey(hkey);
						}
						else
						{
							RegCloseKey(hkey);
							goto LLoadModule;
						}
					}
					else
					{
LLoadModule:
						err = GetLastError();
						if (rgszFileName[i] != 0)
						{
							CAPITempBuffer<char, MAX_PATH> rgchTemp;
							bool fOKSize = true;
							int iLen = lstrlenA(rgchBuf) + lstrlenA(rgszFileName[i]) + 2;
							if ( rgchTemp.GetSize() < iLen )
								fOKSize = rgchTemp.SetSize(iLen);
							if ( fOKSize )
							{
								if ( FAILED(StringCchCopyA(rgchTemp, ARRAY_ELEMENTS(rgchTemp), rgchBuf)) ||
									  FAILED(StringCchCatA(rgchTemp, ARRAY_ELEMENTS(rgchTemp), "\\")) ||
									  FAILED(StringCchCatA(rgchTemp, ARRAY_ELEMENTS(rgchTemp), rgszFileName[i])) )
									return;
							}
							else
							{
								// this is quite impossible
								continue;
							}
							if (!pSymLoadModule(hProcessCur, NULL, (char *)rgchTemp, NULL, 0, 0))
								err = GetLastError();
						}
					}
				}
			}
	}
#endif //WIN
}

BOOL FGetFunctionNameFromAddr(unsigned long lAddr, char *pszFnName, size_t cchFnName, unsigned long *pdwDisp)
{
	PIMAGEHLP_SYMBOL piSym4;
	unsigned long dwDisp;
	HANDLE hProcessCur = GetCurrentProcess();
	DWORD err;

	if (fDontGetName)
		return fFalse;

	if (!fSymInit)
	{
		InitSymbolInfo(false);
	}

	if (fSymInit)
	{
		char sz[cchTempBuffer];

		if (fUse40Calls)
		{
			piSym4 = piSymMem4;

			if (pSymGetSymFromAddr(hProcessCur, lAddr, &dwDisp, piSym4))
			{
				if (pdwDisp != NULL)
					*pdwDisp = dwDisp;
				if (!pSymUnDName(piSym4, sz, cchTempBuffer))
				{
					RETURN_THAT_IF_FAILED(StringCchCopyA(pszFnName, cchFnName, &piSym4->Name[1]),
												 fFalse);
				}
				else
				{
					RETURN_THAT_IF_FAILED(StringCchCopyA(pszFnName, cchFnName, sz),
												 fFalse);
				}
				return fTrue;
			}
			else
			{
				err = GetLastError();
				if (err == STATUS_ACCESS_VIOLATION)
					fDontGetName = fTrue;
			}
		}
	}
	return fFalse;
}

void SzFromFunctionAddress(TCHAR *szAddress, size_t cchAddress, long lAddress)
{
	char szFnName[cchTempBuffer];
	unsigned long dwDisp;

	if (FGetFunctionNameFromAddr(lAddress, szFnName, ARRAY_ELEMENTS(szFnName), &dwDisp))
	{
		RETURN_IF_FAILED(StringCchPrintf(szAddress, cchAddress, TEXT("(0x%x)%hs+%d"),
													lAddress, szFnName, dwDisp));
	}
	else
		RETURN_IF_FAILED(StringCchPrintf(szAddress, cchAddress, TEXT("0x%x"), lAddress));

}

void ListSzFromRgpaddr(TCHAR *szInfo, int cchInfo, unsigned long *rgpaddr, int cFunc, bool fReturn)
{
	unsigned long *paddr, *paddrMax;
	TCHAR szTemp[cchTempBuffer];

	paddr = rgpaddr;
	paddrMax = paddr + cFunc;
	while (paddr < paddrMax)
	{
		SzFromFunctionAddress(szTemp, ARRAY_ELEMENTS(szTemp), *paddr);
		paddr++;
		if ( FAILED(StringCchCat(szInfo, cchInfo, szTemp)) )
			break;
		HRESULT hRes;
		if (fReturn)
			hRes = StringCchCat(szInfo, cchInfo, rgchLFCRDbg);
		else
			hRes = StringCchCat(szInfo, cchInfo, TEXT("\t"));
		if ( FAILED(hRes) )
			break;
	}


}


#endif // DEBUG

#endif //MEM_SERVICES

#endif // __MODULE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\latebind.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       latebind.h
//
//--------------------------------------------------------------------------

/* latebind.h - definitions of late-bound DLL imports
MUST DEFINE one of the following before including this file:

LATEBIND_TYPEDEF - generate typedefs for function pointers (in header file)
LATEBIND_VECTREF - generate extern references to function vectors (in header file)
LATEBIND_FUNCREF - generate static function declarations (in implementation)
LATEBIND_VECTIMP - generate initialization values for function vectors (implementation)
LATEBIND_FUNCIMP - generate bind function implementation (must follow all above)
____________________________________________________________________________*/

#define RetryDllLoad false

bool              __stdcall TestAndSet(int* pi);

void UnbindLibraries();  // in latebind.cpp, unbinds non-kernel libraries
HINSTANCE LoadSystemLibrary(const ICHAR* szFile);

#ifdef LATEBIND_TYPEDEF
#undef LATEBIND_TYPEDEF
#pragma message("LATEBIND_TYPEDEF")
// definitions not in windows.h required for function declarations

#ifndef __IClientSecurity_INTERFACE_DEFINED__
struct SOLE_AUTHENTICATION_SERVICE;
#endif

enum _SE_OBJECT_TYPE;
typedef _SE_OBJECT_TYPE SE_OBJECT_TYPE;

#ifndef DLLVER_PLATFORM_NT
typedef struct _DllVersionInfo
{
        DWORD cbSize;
        DWORD dwMajorVersion;                   // Major version
        DWORD dwMinorVersion;                   // Minor version
        DWORD dwBuildNumber;                    // Build number
        DWORD dwPlatformID;                     // DLLVER_PLATFORM_*
} DLLVERSIONINFO;
#define DLLVER_PLATFORM_WINDOWS         0x00000001      // Windows 95
#define DLLVER_PLATFORM_NT              0x00000002      // Windows NT
typedef interface IBindStatusCallback IBindStatusCallback;
#endif

#ifndef _REGISTRY_QUOTA_INFORMATION
#define _REGISTRY_QUOTA_INFORMATION
// 64 bit builds have different type for HCRYPTPROV
#ifdef _WIN64
typedef ULONG_PTR HCRYPTPROV;
#else
typedef unsigned long HCRYPTPROV;
#endif

#endif  //_REGISTRY_QUOTA_INFORMATION

// winsafer
#include <winsafer.h>

// wintrust 
#ifndef WINTRUST_H
struct _WINTRUST_DATA;
struct _CRYPT_PROVIDER_SGNR;
struct _CRYPT_PROVIDER_DATA;
struct _CRYPT_PROVIDER_CERT;

typedef _WINTRUST_DATA WINTRUST_DATA;
typedef _CRYPT_PROVIDER_SGNR CRYPT_PROVIDER_SGNR;
typedef _CRYPT_PROVIDER_DATA CRYPT_PROVIDER_DATA;
typedef _CRYPT_PROVIDER_CERT CRYPT_PROVIDER_CERT;

typedef CRYPT_PROVIDER_SGNR *PCRYPT_PROVIDER_SGNR;
typedef CRYPT_PROVIDER_DATA *PCRYPT_PROVIDER_DATA;
typedef CRYPT_PROVIDER_CERT *PCRYPT_PROVIDER_CERT;
#endif

// wincrypt
#ifndef WINCRYPT_H
struct _CERT_CONTEXT;

typedef _CERT_CONTEXT        CERT_CONTEXT;
typedef const _CERT_CONTEXT *PCCERT_CONTEXT;
#endif

#include <winhttp.h>

// SFP
#ifndef _SFP_INFORMATION
#define _SFP_INFORMATION

#define DWORD_PTR ULONG_PTR
typedef struct _FILEINSTALL_STATUS
{
    PCWSTR      FileName;
    DWORDLONG   Version;
    ULONG       Win32Error;
}FILEINSTALL_STATUS, *PFILEINSTALL_STATUS;
typedef BOOL (CALLBACK *PSFCNOTIFICATIONCALLBACK)(IN PFILEINSTALL_STATUS pFileInstallStatus, IN DWORD_PTR Context);

#define SfcConnectToServerOrd       3
#define SfcCloseOrd                 4
#define SfcInstallProtectedFilesOrd 7
#define SfpInstallCatalogOrd        8
#define SfpDeleteCatalogOrd         9

#endif  // _SFP_INFORMATION

#include <srrestoreptapi.h>
#include <aclapi.h>

//
// SHIMDB defines TAG type which conflicts
// with the definition available in winuserp.h
// we define it inside the separate namespace
// avoiding any conflicts
//
namespace SHIMDBNS {
#include <shimdb.h>
}


#if defined(_MSI_DLL)
#ifndef _URT_ENUM
enum urtEnum{
	urtSystem = 0,
	urtPreferURTTemp,
	urtRequireURTTemp,
};
extern urtEnum g_urtLoadFromURTTemp; // global, to remember where to load mscoree from
#define _URT_ENUM
#endif // #ifndef _URT_ENUM
#endif // defined(_MSI_DLL)

// end of definitions

#define LIBBIND(l) namespace l {
#define LIBFAIL(l)
#define LIBEMUL(l)
#define LIBLOAD(l) namespace l {
#define LIBEMUL2(l)
typedef HRESULT (WINAPI *T_CoInitialize)(void*);
typedef void    (WINAPI *T_CoUninitialize)();
#define IMPBIND(l,f,d,a,r,e) typedef r (WINAPI *T_##f) d;
#define IMPFAIL(l,f,d,a,r,e) typedef r (WINAPI *T_##f) d;
#define IMPFAIW(l,f,d,a,r,e) typedef r (WINAPI *T_##f) d;
#define OPTBIND(l,f,d,a,r)   typedef r (WINAPI *T_##f) d;
#define IMPAORW(l,f,d,a,r,e) typedef r (WINAPI *T_##f) d;
#define IMPNORW(l,f,d,a,r,e) typedef r (WINAPI *T_##f) d;
#define IMPFAOW(l,f,d,a,r,e) typedef r (WINAPI *T_##f) d;
#define OPTAORW(l,f,d,a,r)   typedef r (WINAPI *T_##f) d;
#define IMPVOID(l,f,d,a)  typedef void (WINAPI *T_##f) d;
#define OPTVOID(l,f,d,a)  typedef void (WINAPI *T_##f) d;
#define IMPORDI(l,f,d,a,r,e,o) typedef r (WINAPI *T_##f) d;
#define IMPORDV(l,f,d,a,o) typedef void (WINAPI *T_##f) d;
#define LIBTERM }
#endif  // LATEBIND_TYPEDEF

#ifdef LATEBIND_VECTREF
#undef LATEBIND_VECTREF
#pragma message("LATEBIND_VECTREF")
#define LIBBIND(l) namespace l {
#define LIBFAIL(l)
#define LIBEMUL(l)
#define LIBLOAD(l) namespace l {
#define LIBEMUL2(l)
#define IMPBIND(l,f,d,a,r,e) extern T_##f f;
#define IMPFAIL(l,f,d,a,r,e) extern T_##f f;
#define IMPFAIW(l,f,d,a,r,e) extern T_##f f;
#define OPTBIND(l,f,d,a,r)   extern T_##f f;
#define IMPAORW(l,f,d,a,r,e) extern T_##f f;
#define IMPNORW(l,f,d,a,r,e) extern T_##f f;
#define IMPFAOW(l,f,d,a,r,e) extern T_##f f;
#define OPTAORW(l,f,d,a,r)   extern T_##f f;
#define IMPVOID(l,f,d,a)     extern T_##f f;
#define OPTVOID(l,f,d,a)     extern T_##f f;
#define IMPORDI(l,f,d,a,r,e,o) extern T_##f f;
#define IMPORDV(l,f,d,a,o)   extern T_##f f;

#define LIBTERM void Unbind(); \
                    }
#endif

#ifdef LATEBIND_FUNCREF
#undef LATEBIND_FUNCREF
#pragma message("LATEBIND_FUNCREF")
#define LIBBIND(l) namespace l {
#define LIBFAIL(l)
#define LIBEMUL(l)
#define LIBLOAD(l) namespace l { static HINSTANCE LoadSystemLibrary(const ICHAR* szPath, bool& rfRetryNextTimeIfWeFailThisTime);
#define LIBEMUL2(l)
#define IMPBIND(l,f,d,a,r,e) static r WINAPI F_##f d;
#define IMPFAIL(l,f,d,a,r,e) static r WINAPI F_##f d;
#define IMPFAIW(l,f,d,a,r,e) static r WINAPI F_##f d;
#define OPTBIND(l,f,d,a,r)   static r WINAPI F_##f d; static r WINAPI E_##f d;
#define IMPAORW(l,f,d,a,r,e) static r WINAPI F_##f d;
#define IMPNORW(l,f,d,a,r,e) static r WINAPI F_##f d;
#define IMPFAOW(l,f,d,a,r,e) static r WINAPI F_##f d;
#define OPTAORW(l,f,d,a,r)   static r WINAPI F_##f d; static r WINAPI E_##f d;
#define IMPVOID(l,f,d,a)  static void WINAPI F_##f d;
#define OPTVOID(l,f,d,a)  static void WINAPI F_##f d; static void WINAPI E_##f d;
#define IMPORDI(l,f,d,a,r,e,o) static r WINAPI F_##f d;
#define IMPORDV(l,f,d,a,o)   static void WINAPI F_##f d;
#define LIBTERM }
#endif

#ifdef LATEBIND_VECTIMP
#undef LATEBIND_VECTIMP
#pragma message("LATEBIND_VECTIMP")
#define LIBBIND(l) namespace l { \
    static HINSTANCE hInst = 0; static bool fTryDllLoad = true; static int iBusyLock = 0;
#define LIBFAIL(l)
#define LIBEMUL(l)
#define LIBLOAD(l) namespace l { \
    static HINSTANCE hInst = 0; static bool fTryDllLoad = true;  static int iBusyLock = 0;
#define LIBEMUL2(l)
#define IMPBIND(l,f,d,a,r,e) T_##f f = F_##f;
#define IMPFAIL(l,f,d,a,r,e) T_##f f = F_##f;
#define IMPFAIW(l,f,d,a,r,e) T_##f f = F_##f;
#define OPTBIND(l,f,d,a,r)   T_##f f = F_##f;
#define IMPAORW(l,f,d,a,r,e) T_##f f = F_##f;
#define IMPNORW(l,f,d,a,r,e) T_##f f = F_##f;
#define IMPFAOW(l,f,d,a,r,e) T_##f f = F_##f;
#define OPTAORW(l,f,d,a,r)   T_##f f = F_##f;
#define IMPVOID(l,f,d,a)     T_##f f = F_##f;
#define OPTVOID(l,f,d,a)     T_##f f = F_##f;
#define IMPORDI(l,f,d,a,r,e,o) T_##f f = F_##f;
#define IMPORDV(l,f,d,a,o)   T_##f f = F_##f;
#define LIBTERM }
#endif

#ifdef LATEBIND_UNBINDIMP
#undef LATEBIND_UNBINDIMP
#pragma message("LATEBIND_UNBINDIMP")
struct UnbindStruct
{
    void** ppfVector;
    void*  ppfInitialValue;
};

void Unbind(UnbindStruct* rgUnbind, HINSTANCE& hInst, int& riBusyLock, bool& rfTryDllLoad)
{
    while (TestAndSet(&riBusyLock) == true)
    {
        Sleep(10);
    }
    if (hInst != 0)
    {
        while (rgUnbind->ppfVector)
        {
            *(rgUnbind->ppfVector) = rgUnbind->ppfInitialValue;
            rgUnbind++;
        }

        __try
        {
            WIN::FreeLibrary(hInst);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            AssertSz(0, TEXT("FreeLibrary threw an exception.")); // Should never happen. If it does, we ignore it.
        }
        hInst = 0;
    }
    rfTryDllLoad = true;
    riBusyLock = 0;
}

#define LIBBIND(l) namespace l { \
    UnbindStruct rgUnbind[] = {
#define LIBFAIL(l)
#define LIBEMUL(l)
#define LIBLOAD(l) namespace l { \
    UnbindStruct rgUnbind[] = {
#define LIBEMUL2(l)
#define IMPBIND(l,f,d,a,r,e)   {(void**)&f, (void*)F_##f},
#define IMPFAIL(l,f,d,a,r,e) {(void**)&f, (void*)F_##f},
#define IMPFAIW(l,f,d,a,r,e) {(void**)&f, (void*)F_##f},
#define OPTBIND(l,f,d,a,r)   {(void**)&f, (void*)F_##f},
#define IMPAORW(l,f,d,a,r,e) {(void**)&f, (void*)F_##f},
#define IMPNORW(l,f,d,a,r,e) {(void**)&f, (void*)F_##f},
#define IMPFAOW(l,f,d,a,r,e) {(void**)&f, (void*)F_##f},
#define OPTAORW(l,f,d,a,r)   {(void**)&f, (void*)F_##f},
#define IMPVOID(l,f,d,a)     {(void**)&f, (void*)F_##f},
#define OPTVOID(l,f,d,a)     {(void**)&f, (void*)F_##f},
#define IMPORDI(l,f,d,a,r,e,o) {(void**)&f, (void*)F_##f},
#define IMPORDV(l,f,d,a,o)   {(void**)&f, (void*)F_##f},
#define LIBTERM {0,0} }; \
    void Unbind() { ::Unbind(rgUnbind, hInst, iBusyLock, fTryDllLoad); } \
     }
#endif

#ifdef LATEBIND_FUNCIMP
#pragma message("LATEBIND_FUNCIMP")

#define LIBBIND(l) FARPROC Bind_##l (const char* szEntry, FARPROC* ppfVector) {\
    while (TestAndSet(&l##::iBusyLock) == true) \
    { \
        Sleep(10); \
    } \
    if (l##::fTryDllLoad && !l##::hInst){l##::hInst = LoadSystemLibrary(TEXT(#l)); if(!l##::hInst) l##::fTryDllLoad = RetryDllLoad; AssertSz(l##::hInst,TEXT(#l));}\
    FARPROC pf = 0;\
    if (l##::hInst && (pf=WIN::GetProcAddress(l##::hInst,szEntry))!=0) *ppfVector=pf; AssertSz(pf,szEntry); l##::iBusyLock = 0; return pf;}
#define LIBFAIL(l) FARPROC BindFail_##l (const char* szEntry, FARPROC* ppfVector) {\
    while (TestAndSet(&l##::iBusyLock) == true) \
    { \
        Sleep(10); \
    } \
    if (l##::fTryDllLoad && !l##::hInst){l##::hInst = LoadSystemLibrary(TEXT(#l)); if(!l##::hInst) l##::fTryDllLoad = RetryDllLoad;}\
    FARPROC pf = 0;\
    if (l##::hInst && (pf=WIN::GetProcAddress(l##::hInst,szEntry))!=0) *ppfVector=pf; l##::iBusyLock = 0; return pf;}
#define LIBEMUL(l) FARPROC BindOpt_##l (const char* szEntry, FARPROC* ppfVector, FARPROC pfEmulator) {\
    while (TestAndSet(&l##::iBusyLock) == true) \
    { \
        Sleep(10); \
    } \
    if (l##::fTryDllLoad && !l##::hInst){l##::hInst = LoadSystemLibrary(TEXT(#l)); if(!l##::hInst) l##::fTryDllLoad = RetryDllLoad;}\
    if (!l##::hInst || (*ppfVector=WIN::GetProcAddress(l##::hInst,szEntry))==0) *ppfVector = pfEmulator; l##::iBusyLock = 0; return *ppfVector;}
#define LIBLOAD(l) FARPROC Bind_##l (const char* szEntry, FARPROC* ppfVector) {\
    while (TestAndSet(&l##::iBusyLock) == true) \
    { \
        Sleep(10); \
    } \
	bool fTryAgain = false; \
    if (l##::fTryDllLoad && !l##::hInst){l##::hInst = l##::LoadSystemLibrary(TEXT(#l), fTryAgain); if(!l##::hInst) l##::fTryDllLoad = fTryAgain;}\
    FARPROC pf = 0;\
    if (l##::hInst && (pf=WIN::GetProcAddress(l##::hInst,szEntry))!=0) *ppfVector=pf; l##::iBusyLock = 0; return pf;}
// LIBEMUL2 works as LIBEMUL but calls the namespace's LoadSystemLibrary
#define LIBEMUL2(l) FARPROC BindOpt_##l (const char* szEntry, FARPROC* ppfVector, FARPROC pfEmulator) {\
    while (TestAndSet(&l##::iBusyLock) == true) \
    { \
        Sleep(10); \
    } \
	bool fTryAgain = false; \
    if (l##::fTryDllLoad && !l##::hInst){l##::hInst = l##::LoadSystemLibrary(TEXT(#l), fTryAgain); if(!l##::hInst) l##::fTryDllLoad = fTryAgain;}\
    if (!l##::hInst || (*ppfVector=WIN::GetProcAddress(l##::hInst,szEntry))==0) *ppfVector = pfEmulator; l##::iBusyLock = 0; return *ppfVector;}

#define IMPBIND(l,f,d,a,r,e) r WINAPI l##::F_##f##d {return Bind_##l (#f, (FARPROC*)&f) ? (*f)a : e;}
#define IMPFAIL(l,f,d,a,r,e) r WINAPI l##::F_##f##d {return BindFail_##l (#f, (FARPROC*)&f) ? (*f)a : e;}
#define OPTBIND(l,f,d,a,r)   r WINAPI l##::F_##f##d {return (*(T_##f)BindOpt_##l (#f,(FARPROC*)&f,(FARPROC)E_##f))a;}
#ifdef UNICODE
#define IMPFAIW(l,f,d,a,r,e) r WINAPI l##::F_##f##d {return BindFail_##l (#f "W", (FARPROC*)&f) ? (*f)a : e;}
#define IMPAORW(l,f,d,a,r,e) r WINAPI l##::F_##f##d {return Bind_##l (#f "W", (FARPROC*)&f) ? (*f)a : e;}
#define IMPNORW(l,f,d,a,r,e) r WINAPI l##::F_##f##d {return Bind_##l (#f "W", (FARPROC*)&f) ? (*f)a : e;}
#define IMPFAOW(l,f,d,a,r,e) r WINAPI l##::F_##f##d {return BindFail_##l (#f "W", (FARPROC*)&f) ? (*f)a : e;}
#define OPTAORW(l,f,d,a,r)   r WINAPI l##::F_##f##d {return (*(T_##f)BindOpt_##l (#f "W",(FARPROC*)&f,(FARPROC)E_##f))a;}
#else
#define IMPFAIW(l,f,d,a,r,e) r WINAPI l##::F_##f##d {return BindFail_##l (#f  , (FARPROC*)&f) ? (*f)a : e;}
#define IMPAORW(l,f,d,a,r,e) r WINAPI l##::F_##f##d {return Bind_##l (#f "A", (FARPROC*)&f) ? (*f)a : e;}
#define IMPNORW(l,f,d,a,r,e) r WINAPI l##::F_##f##d {return Bind_##l (#f    , (FARPROC*)&f) ? (*f)a : e;}
#define IMPFAOW(l,f,d,a,r,e) r WINAPI l##::F_##f##d {return BindFail_##l (#f "A", (FARPROC*)&f) ? (*f)a : e;}
#define OPTAORW(l,f,d,a,r)   r WINAPI l##::F_##f##d {return (*(T_##f)BindOpt_##l (#f "A",(FARPROC*)&f,(FARPROC)E_##f))a;}
#endif
#define IMPVOID(l,f,d,a)  void WINAPI l##::F_##f##d {if    (Bind_##l (#f, (FARPROC*)&f))  (*f)a;}
#define OPTVOID(l,f,d,a)  void WINAPI l##::F_##f##d {(*(T_##f)BindOpt_##l (#f,(FARPROC*)&f,(FARPROC)E_##f))a;}
#define IMPORDI(l,f,d,a,r,e,o) r WINAPI l##::F_##f##d {return BindFail_##l ((const char*) o, (FARPROC*)&f) ? (*f)a : e;}
#define IMPORDV(l,f,d,a,o)   void WINAPI l##::F_##f##d {if    (BindFail_##l ((const char*) o, (FARPROC*)&f)) (*f)a;}
#define LIBTERM
#endif

#ifndef LIBBIND
#error "Must define LATEBIND_xxxx before include of "latebind.h"
#endif

//____________________________________________________________________________
//
// External library import specifications
//
//  LIBBIND - defines the library and function bind function for a DLL, must be first
//  LIBFAIL - same as LIBBIND, with no Asserts, bind failure indicated by return value
//  LIBEMUL - variant on LIBBIND which accepts an emulator function, used with OPTXXXX
//  LIBLOAD - variant on LIBFAIL which calls an external function to load the DLL
//  IMPBIND - defines the late-bind trap function that gets replaced on import binding
//            (library, function, arg defs, arg vars, return type, return error value)
//  IMPAORW - same as IMPBIND, but appends "A" or "W" to import depending on UNICODE
//            (library, function, arg defs, arg vars, return type, return error value)
//  IMPFAOW - same as IMPAORW, but calls LIBFAIL, no Asserts, return must be tested
//  IMPNORW - same as IMPBIND, but "W" to import only if UNICODE
//            (library, function, arg defs, arg vars, return type, return error value)
//  IMPVOID - same as IMPBIND, but for functions that have no return value
//            (library, function, arg defs, arg vars)
//  IMPFAIL - same as IMPBIND, but calls LIBFAIL, no Asserts, return must be tested
//            (library, function, arg defs, arg vars, return type, return error value)
//  IMPFAIW - same as IMPFAIL, but "W" to import only if UNICODE
//            (library, function, arg defs, arg vars, return type, return error value)
//  OPTBIND - uses an emulator function (with a "E_" prefix) if import not found
//            (library, function, arg defs, arg vars, return type)
//  OPTAORW - same as OPTBIND, but appends "A" or "W" to import (but not to emulator)
//            (library, function, arg defs, arg vars, return type)
//  OPTVOID - same as OPTBIND, but for functions that have no return value
//            (library, function, arg defs, arg vars)
//  IMPORDI - same as IMPBIND, except binds by ordinal instead of named function
//            (library, function, arg defs, arg vars, return type, return error value, ordinal number)
//  IMPVOID - same as IMPORDI, but for functions that have no return value
//            (library, function, arg defs, arg vars, ordinal number)
//  LIBTERM - ends library binding block, must be the last macro for each library
//____________________________________________________________________________

#ifdef UNICODE
LIBBIND(OLE32)
#else  // need explict loader to check for bad DLL version on Win9X
LIBLOAD(OLE32)
#endif
IMPBIND(OLE32,CoInitialize,(void*),(0),HRESULT,E_FAIL)
IMPBIND(OLE32,CoInitializeEx,(void*, DWORD dwCoInit),(0, dwCoInit),HRESULT,E_FAIL)
IMPVOID(OLE32,CoUninitialize,(),())
IMPBIND(OLE32,CoGetMalloc,(DWORD dwMemContext, IMalloc** ppMalloc),(dwMemContext, ppMalloc),HRESULT,E_FAIL)
IMPBIND(OLE32,CoCreateInstance,(REFCLSID rclsid, IUnknown* pUnkOuter, DWORD dwClsContext, REFIID riid, void** ppv),(rclsid, pUnkOuter, dwClsContext, riid, ppv),HRESULT,E_FAIL)
IMPBIND(OLE32,IIDFromString,(LPOLESTR lpsz, IID* lpiid),(lpsz, lpiid),HRESULT,E_FAIL)
IMPBIND(OLE32,StgCreateDocfile,(const OLECHAR* pwcsName, DWORD grfMode, DWORD, IStorage** ppstgOpen),(pwcsName, grfMode, 0, ppstgOpen),HRESULT,E_FAIL)
IMPBIND(OLE32,StgOpenStorage,(const OLECHAR* pwcsName, IStorage* pstgPriority, DWORD grfMode, SNB snbExclude, DWORD, IStorage** ppstgOpen),(pwcsName, pstgPriority, grfMode, snbExclude, 0, ppstgOpen),HRESULT,E_FAIL)
IMPBIND(OLE32,StgOpenStorageOnILockBytes,(ILockBytes* plkbyt, IStorage* pstgPriority, DWORD grfMode, SNB snbExclude, DWORD, IStorage** ppstgOpen),(plkbyt, pstgPriority, grfMode, snbExclude, 0, ppstgOpen),HRESULT,E_FAIL)
IMPBIND(OLE32,CoImpersonateClient,(),(),HRESULT,E_FAIL)
IMPBIND(OLE32,CoRevertToSelf,(),(),HRESULT,E_FAIL)
IMPBIND(OLE32,CoGetCallContext,(REFIID riid, void **ppInterface),(riid, ppInterface),HRESULT,E_FAIL)
IMPBIND(OLE32,CoTaskMemAlloc,(ULONG cb),(cb),LPVOID, 0)
IMPVOID(OLE32,CoTaskMemFree,(LPVOID pv),(pv))
IMPBIND(OLE32,CoInitializeSecurity,(PSECURITY_DESCRIPTOR pSecDesc, LONG cbAuthSvc, SOLE_AUTHENTICATION_SERVICE *asAuthSvc, WCHAR *pClientPrincName, DWORD dwAuthnLevel, DWORD dwImpLevel, RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities, void *pReserved), (pSecDesc, cbAuthSvc, asAuthSvc, pClientPrincName, dwAuthnLevel, dwImpLevel, pAuthInfo, dwCapabilities, pReserved), HRESULT, E_FAIL)
IMPBIND(OLE32,CoQueryProxyBlanket,(IUnknown *pProxy, DWORD *pwAuthnSvc, DWORD *pAuthzSvc,OLECHAR **pServerPrincName,DWORD *pAuthnLevel,DWORD *pImpLevel,RPC_AUTH_IDENTITY_HANDLE  *pAuthInfo,DWORD *pCapabilites ), (pProxy, pwAuthnSvc, pAuthzSvc,pServerPrincName,pAuthnLevel,pImpLevel,pAuthInfo,pCapabilites), HRESULT, E_FAIL)
IMPBIND(OLE32,CoSetProxyBlanket,(IUnknown *pProxy, DWORD dwAuthnSvc, DWORD dwAuthzSvc, OLECHAR *pServerPrincName, DWORD dwAuthnLevel, DWORD dwImpLevel, RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities ),(pProxy, dwAuthnSvc, dwAuthzSvc, pServerPrincName, dwAuthnLevel, dwImpLevel, pAuthInfo, dwCapabilities), HRESULT, E_FAIL)
IMPVOID(OLE32,CoFreeUnusedLibraries,(),())
IMPBIND(OLE32,CoMarshalInterThreadInterfaceInStream,(REFIID riid, LPUNKNOWN pUnk, LPSTREAM* pStm), (riid, pUnk, pStm), HRESULT, E_FAIL)
IMPBIND(OLE32,CoGetInterfaceAndReleaseStream,(LPSTREAM pStm, REFIID riid, LPVOID *ppv), (pStm, riid, ppv), HRESULT, E_FAIL)
IMPBIND(OLE32,CoDisconnectObject, (IUnknown *pUnk, DWORD dwReserved), (pUnk, dwReserved), HRESULT, E_FAIL)
IMPBIND(OLE32,CoIsHandlerConnected, (IUnknown *pUnk), (pUnk), BOOL, FALSE)
IMPBIND(OLE32,StringFromCLSID, (REFCLSID rclsid, LPOLESTR FAR* lplpsz), (rclsid, lplpsz), HRESULT, E_FAIL)
IMPBIND(OLE32,StringFromGUID2, (REFGUID rguid, LPOLESTR lpsz, int cchMax), (rguid, lpsz, cchMax), HRESULT, E_FAIL)
LIBTERM

LIBBIND(OLEAUT32)
LIBFAIL(OLEAUT32)
IMPBIND(OLEAUT32,SysAllocString,(const OLECHAR* sz),(sz),BSTR,0)
IMPBIND(OLEAUT32,SysAllocStringLen,(const OLECHAR* sz, UINT cch),(sz, cch),BSTR,0)
IMPVOID(OLEAUT32,SysFreeString,(const OLECHAR* sz),(sz))
IMPBIND(OLEAUT32,SysStringLen,(const OLECHAR* sz),(sz),UINT,0)
IMPBIND(OLEAUT32,VariantClear,(VARIANTARG * pvarg),(pvarg),HRESULT,TYPE_E_DLLFUNCTIONNOTFOUND)
IMPVOID(OLEAUT32,VariantInit,(VARIANTARG * pvarg),(pvarg))
IMPBIND(OLEAUT32,VariantChangeType,(VARIANTARG * pvargDest, VARIANTARG * pvarSrc, USHORT wFlags, VARTYPE vt),(pvargDest, pvarSrc, wFlags, vt),HRESULT,TYPE_E_DLLFUNCTIONNOTFOUND)
IMPBIND(OLEAUT32,LoadTypeLib,(const OLECHAR  *szFile, ITypeLib ** pptlib),(szFile, pptlib),HRESULT,TYPE_E_DLLFUNCTIONNOTFOUND)
IMPBIND(OLEAUT32,RegisterTypeLib,(ITypeLib * ptlib, OLECHAR  *szFullPath, OLECHAR  *szHelpDir),(ptlib, szFullPath, szHelpDir),HRESULT,TYPE_E_DLLFUNCTIONNOTFOUND)
IMPFAIL(OLEAUT32,UnRegisterTypeLib,(REFGUID libID, WORD wVerMajor, WORD wVerMinor, LCID lcid, SYSKIND syskind),(libID, wVerMajor, wVerMinor, lcid, syskind),HRESULT,TYPE_E_DLLFUNCTIONNOTFOUND)
IMPBIND(OLEAUT32,SystemTimeToVariantTime,(LPSYSTEMTIME lpSystemTime, double *pvtime),(lpSystemTime, pvtime),INT,0)
IMPBIND(OLEAUT32,VariantTimeToSystemTime,(double vtime, LPSYSTEMTIME lpSystemTime),(vtime, lpSystemTime),INT,0)
IMPBIND(OLEAUT32,VarI4FromR8,(double dblIn, LONG* plOut),(dblIn, plOut),HRESULT,TYPE_E_DLLFUNCTIONNOTFOUND)
IMPBIND(OLEAUT32,QueryPathOfRegTypeLib,(REFGUID guid, USHORT wMaj, USHORT wMin, LCID lcid, BSTR* lpbstrPathName),(guid, wMaj, wMin, lcid, lpbstrPathName),HRESULT,TYPE_E_DLLFUNCTIONNOTFOUND)
IMPBIND(OLEAUT32,DosDateTimeToVariantTime,(USHORT wDosDate, USHORT wDosTime, double* pvtime),(wDosDate, wDosTime, pvtime),INT,FALSE)
IMPBIND(OLEAUT32,SafeArrayCreate, (VARTYPE vt, UINT cDims, SAFEARRAYBOUND * rgsabound), (vt, cDims, rgsabound), SAFEARRAY *, 0)
IMPBIND(OLEAUT32,SafeArrayDestroy, (SAFEARRAY * psa), (psa), HRESULT, E_FAIL)
IMPBIND(OLEAUT32,SafeArrayPutElement, (SAFEARRAY * psa, LONG * rgIndices, void * pv), (psa, rgIndices, pv), HRESULT, E_FAIL)
IMPBIND(OLEAUT32,SafeArrayAccessData, (SAFEARRAY * psa, void HUGEP ** ppvData), (psa, ppvData), HRESULT, E_FAIL)
IMPBIND(OLEAUT32,SafeArrayUnaccessData, (SAFEARRAY * psa), (psa), HRESULT, E_FAIL)
LIBTERM

LIBBIND(MPR)
IMPAORW(MPR,WNetAddConnection2,(NETRESOURCE* lpNetResource, LPCTSTR lpPassword, LPCTSTR lpUserName, DWORD dwFlags),(lpNetResource, lpPassword, lpUserName, dwFlags),DWORD,ERROR_PROC_NOT_FOUND)
IMPAORW(MPR,WNetGetConnection,(LPCTSTR lpLocalName, LPTSTR lpRemoteName, DWORD* lpnLength),(lpLocalName, lpRemoteName, lpnLength),DWORD,ERROR_PROC_NOT_FOUND)
IMPAORW(MPR,WNetCancelConnection2,(LPCTSTR lpName, DWORD dwFlags, BOOL fForce),(lpName, dwFlags, fForce),DWORD,ERROR_PROC_NOT_FOUND)
IMPAORW(MPR,WNetGetUser,(LPCTSTR lpName, LPTSTR lpUserName, LPDWORD lpnLength),(lpName, lpUserName, lpnLength),DWORD,ERROR_PROC_NOT_FOUND)
IMPAORW(MPR,WNetGetResourceInformation,(LPNETRESOURCE lpNetResource,LPVOID lpBuffer,LPDWORD cbBuffer, LPTSTR *lplpSystem),(lpNetResource,lpBuffer,cbBuffer,lplpSystem),DWORD,ERROR_PROC_NOT_FOUND)
IMPAORW(MPR,WNetGetLastError,(LPDWORD lpError, LPTSTR lpErrorBuf, DWORD nErrorBufSize, LPTSTR lpNameBuf, DWORD nNameBufSize),(lpError, lpErrorBuf, nErrorBufSize, lpNameBuf, nNameBufSize),DWORD,ERROR_PROC_NOT_FOUND)
IMPAORW(MPR,WNetGetNetworkInformation,(LPTSTR lpProvider,  LPNETINFOSTRUCT lpNetInfoStruct),(lpProvider, lpNetInfoStruct),DWORD,ERROR_PROC_NOT_FOUND)
LIBTERM

LIBBIND(ADVAPI32)
LIBEMUL(ADVAPI32)
LIBFAIL(ADVAPI32)
IMPAORW(ADVAPI32,GetFileSecurity,(LPCTSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded),(lpFileName, RequestedInformation, pSecurityDescriptor, nLength, lpnLengthNeeded),BOOL,(SetLastError(ERROR_PROC_NOT_FOUND),FALSE))
IMPBIND(ADVAPI32,DuplicateTokenEx,(HANDLE hExistingToken, DWORD dwDesiredAccess, LPSECURITY_ATTRIBUTES lpTokenAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TOKEN_TYPE TokenType, PHANDLE phNewToken),(hExistingToken, dwDesiredAccess, lpTokenAttributes, ImpersonationLevel, TokenType, phNewToken),BOOL,(SetLastError(ERROR_PROC_NOT_FOUND),FALSE))
IMPAORW(ADVAPI32,CreateProcessAsUser,(HANDLE hToken, LPCTSTR lpApplicationName, LPTSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCTSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation),(hToken,lpApplicationName,lpCommandLine,lpProcessAttributes,lpThreadAttributes,bInheritHandles,dwCreationFlags,lpEnvironment,lpCurrentDirectory,lpStartupInfo,lpProcessInformation),BOOL,(SetLastError(ERROR_PROC_NOT_FOUND),FALSE))
OPTBIND(ADVAPI32,RegOpenUserClassesRoot,(HANDLE hToken, DWORD  dwOptions, REGSAM samDesired, PHKEY  phkResult), (hToken, dwOptions, samDesired, phkResult),LONG)
OPTBIND(ADVAPI32,RegOpenCurrentUser,(REGSAM samDesired, PHKEY phkResult),(samDesired, phkResult),LONG)
IMPBIND(ADVAPI32,CheckTokenMembership,(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember),(TokenHandle, SidToCheck, IsMember),BOOL,FALSE)
IMPFAOW(ADVAPI32,ChangeServiceConfig2,(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo),(hService, dwInfoLevel, lpInfo), BOOL, (SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPFAOW(ADVAPI32,QueryServiceConfig2,(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded), (hService, dwInfoLevel, lpBuffer, cbBufSize, pcbBytesNeeded), BOOL, (SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPFAIL(ADVAPI32,CryptAcquireContextA,(HCRYPTPROV* phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags), (phProv, pszContainer, pszProvider, dwProvType, dwFlags), BOOL, (SetLastError(ERROR_INVALID_FUNCTION), FALSE))
IMPFAIL(ADVAPI32,CryptAcquireContextW,(HCRYPTPROV* phProv, LPCWSTR pszContainer, LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags), (phProv, pszContainer, pszProvider, dwProvType, dwFlags), BOOL, (SetLastError(ERROR_INVALID_FUNCTION), FALSE))
IMPFAIL(ADVAPI32,CryptGenRandom,(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer), (hProv, dwLen, pbBuffer), BOOL, (SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPFAIL(ADVAPI32,CryptReleaseContext,(HCRYPTPROV hProv, DWORD dwFlags), (hProv, dwFlags), BOOL, (SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPBIND(ADVAPI32,GetSecurityInfo,(HANDLE handle, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID* ppsidOwner, PSID* ppsidGroup, PACL* ppDacl, PACL* ppSacl, PSECURITY_DESCRIPTOR* ppSD), (handle, ObjectType, SecurityInfo, ppsidOwner, ppsidGroup, ppDacl, ppSacl, ppSD), DWORD, ERROR_PROC_NOT_FOUND)
IMPBIND(ADVAPI32,SetSecurityInfo,(HANDLE handle, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID psidOwner, PSID psidGroup, PACL pDacl, PACL pSacl), (handle, ObjectType, SecurityInfo, psidOwner, psidGroup, pDacl, pSacl), DWORD, ERROR_PROC_NOT_FOUND)
IMPAORW(ADVAPI32,SetEntriesInAcl,(ULONG cEntries, PEXPLICIT_ACCESS pExplicitAccess, PACL OldAcl, PACL* NewAcl), (cEntries, pExplicitAccess, OldAcl, NewAcl), DWORD, ERROR_PROC_NOT_FOUND)
IMPFAIL(ADVAPI32,SaferIdentifyLevel,(DWORD dwNumProperties, PSAFER_CODE_PROPERTIES pCodeProperties, SAFER_LEVEL_HANDLE* pLevelObject, LPVOID lpReserved), (dwNumProperties, pCodeProperties, pLevelObject, lpReserved), BOOL,(SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPFAIL(ADVAPI32,SaferGetLevelInformation,(SAFER_LEVEL_HANDLE LevelObject, SAFER_OBJECT_INFO_CLASS dwInfoType, LPVOID lpQueryBuffer, DWORD dwInBufferSize, LPDWORD lpdwOutBufferSize), (LevelObject, dwInfoType, lpQueryBuffer, dwInBufferSize, lpdwOutBufferSize), BOOL,(SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPFAIL(ADVAPI32,SaferComputeTokenFromLevel,(SAFER_LEVEL_HANDLE LevelObject, HANDLE InAccessToken, PHANDLE OutAccessToken, DWORD dwFlags, LPVOID lpReserved), (LevelObject, InAccessToken, OutAccessToken, dwFlags, lpReserved), BOOL, (SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPFAIL(ADVAPI32,SaferCloseLevel,(SAFER_LEVEL_HANDLE hLevelObject), (hLevelObject), BOOL, (SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPFAIL(ADVAPI32,SaferCreateLevel,(DWORD dwScopeId, DWORD dwLevelId, DWORD OpenFlags, SAFER_LEVEL_HANDLE* pLevelObject, LPVOID lpReserved), (dwScopeId, dwLevelId, OpenFlags, pLevelObject, lpReserved), BOOL, (SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPFAIL(ADVAPI32,CreateRestrictedToken,(HANDLE ExistingToken,DWORD Flags,DWORD DisableSidCount,PSID_AND_ATTRIBUTES SidsToDisable,DWORD DeletePrivilegeCount,PLUID_AND_ATTRIBUTES PrivilegesToDelete,DWORD RestrictedSidCount,PSID_AND_ATTRIBUTES SidsToRestrict,PHANDLE NewToken), (ExistingToken,Flags,DisableSidCount,SidsToDisable,DeletePrivilegeCount,PrivilegesToDelete,RestrictedSidCount,SidsToRestrict,NewToken), BOOL, (SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPFAIL(ADVAPI32,SaferiChangeRegistryScope,(HKEY hKeyCustomRoot, DWORD Flags), (hKeyCustomRoot, Flags), BOOL, (SetLastError(ERROR_INVALID_FUNCTION),FALSE)) 
IMPFAOW(ADVAPI32,InitiateSystemShutdown,(LPTSTR lpMachineName, LPTSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown), (lpMachineName, lpMessage, dwTimeout, bForceAppsClosed, bRebootAfterShutdown), BOOL, (SetLastError(ERROR_PROC_NOT_FOUND), FALSE))
LIBTERM

LIBLOAD(COMCTL32)
LIBEMUL2(COMCTL32)
IMPVOID(COMCTL32,InitCommonControls,(),())
OPTBIND(COMCTL32,InitCommonControlsEx,(INITCOMMONCONTROLSEX* icc),(icc),BOOL)
LIBTERM

LIBBIND(COMDLG32)
IMPBIND(COMDLG32, CommDlgExtendedError, (), (), DWORD, 0)
#ifdef UNICODE
IMPBIND(COMDLG32, GetOpenFileNameW, (LPOPENFILENAMEW lpo), (lpo), BOOL, FALSE)
#else
IMPBIND(COMDLG32, GetOpenFileNameA, (LPOPENFILENAMEA lpo), (lpo), BOOL, FALSE)
#endif //UNICODE
LIBTERM

LIBBIND(SHELL32)
LIBEMUL(SHELL32)
IMPBIND(SHELL32,SHGetMalloc,(IMalloc** ppMalloc),(ppMalloc),HRESULT,TYPE_E_DLLFUNCTIONNOTFOUND)
IMPBIND(SHELL32,SHGetSpecialFolderLocation,(HWND hwndOwner, int nFolder, LPITEMIDLIST* ppidl),(hwndOwner, nFolder, ppidl),HRESULT,TYPE_E_DLLFUNCTIONNOTFOUND)
IMPAORW(SHELL32,SHGetPathFromIDList,(LPCITEMIDLIST pidl, LPTSTR pszPath),(pidl, pszPath),BOOL,FALSE)
OPTAORW(SHELL32,SHGetFolderPath,(HWND hwnd, int csidl, HANDLE hToken, DWORD dwRes, LPTSTR pszPath),(hwnd, csidl, hToken, dwRes, pszPath),HRESULT)
IMPVOID(SHELL32,SHChangeNotify,(LONG wEventId, UINT uFlags, LPCVOID dwItem1, LPCVOID dwItem2),(wEventId, uFlags, dwItem1, dwItem2))
OPTBIND(SHELL32,DllGetVersion,(DLLVERSIONINFO* pdvi),(pdvi),HRESULT)
LIBTERM

LIBBIND(VERSION)
IMPAORW(VERSION,GetFileVersionInfoSize,(LPTSTR lptstrFilename, LPDWORD lpdwHandle),(lptstrFilename, lpdwHandle),DWORD,0)
IMPAORW(VERSION,GetFileVersionInfo,(LPTSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData),(lptstrFilename, dwHandle, dwLen, lpData),BOOL,FALSE)
IMPAORW(VERSION,VerQueryValue,(const LPVOID pBlock, LPTSTR lpSubBlock, LPVOID* lplpBuffer, PUINT puLen),(pBlock, lpSubBlock, lplpBuffer, puLen),BOOL,FALSE)
#ifndef UNICODE
IMPBIND(VERSION,GetFileVersionInfoSizeW,(WCHAR* lptstrFilename, LPDWORD lpdwHandle),(lptstrFilename, lpdwHandle),DWORD,0)
IMPBIND(VERSION,GetFileVersionInfoW,(WCHAR* lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData),(lptstrFilename, dwHandle, dwLen, lpData),BOOL,FALSE)
IMPBIND(VERSION,VerQueryValueW,(const LPVOID pBlock, WCHAR* lpSubBlock, LPVOID* lplpBuffer, PUINT puLen),(pBlock, lpSubBlock, lplpBuffer, puLen),BOOL,FALSE)
#endif
LIBTERM

LIBBIND(ODBCCP32)
LIBFAIL(ODBCCP32)
IMPFAIW(ODBCCP32,SQLInstallDriverEx,(LPCTSTR szDriver, LPCTSTR szPathIn, LPTSTR szPathOut, WORD cbPathOutMax, WORD* pcbPathOut, WORD fRequest, DWORD* pdwUsageCount),(szDriver, szPathIn, szPathOut, cbPathOutMax, pcbPathOut, fRequest, pdwUsageCount),BOOL,TYPE_E_DLLFUNCTIONNOTFOUND)
IMPFAIW(ODBCCP32,SQLConfigDriver,(HWND hwndParent, WORD fRequest, LPCTSTR szDriver, LPCTSTR szArgs, LPTSTR szMsg, WORD cbMsgMax, WORD* pcbMsgOut),(hwndParent, fRequest, szDriver, szArgs, szMsg, cbMsgMax, pcbMsgOut),BOOL,TYPE_E_DLLFUNCTIONNOTFOUND)
IMPFAIW(ODBCCP32,SQLRemoveDriver,(LPCTSTR szDriver, BOOL fRemoveDSN, DWORD* pdwUsageCount),(szDriver, fRemoveDSN, pdwUsageCount),BOOL,TYPE_E_DLLFUNCTIONNOTFOUND)
IMPFAIW(ODBCCP32,SQLInstallTranslatorEx,(LPCTSTR szTranslator, LPCTSTR szPathIn, LPTSTR szPathOut, WORD cbPathOutMax, WORD* pcbPathOut, WORD fRequest, DWORD* pdwUsageCount),(szTranslator, szPathIn, szPathOut, cbPathOutMax, pcbPathOut, fRequest, pdwUsageCount),BOOL,TYPE_E_DLLFUNCTIONNOTFOUND)
IMPFAIW(ODBCCP32,SQLRemoveTranslator,(LPCTSTR szTranslator, DWORD* pdwUsageCount),(szTranslator, pdwUsageCount),BOOL,TYPE_E_DLLFUNCTIONNOTFOUND)
IMPFAIW(ODBCCP32,SQLConfigDataSource,(HWND hwndParent, WORD fRequest, LPCTSTR szDriver, LPCTSTR szAttributes),(hwndParent, fRequest, szDriver, szAttributes),BOOL,TYPE_E_DLLFUNCTIONNOTFOUND)
IMPFAIW(ODBCCP32,SQLInstallerError,(WORD iError, DWORD* pfErrorCode, LPTSTR szErrorMsg, WORD cbErrorMsgMax, WORD* pcbErrorMsg),(iError, pfErrorCode, szErrorMsg, cbErrorMsgMax, pcbErrorMsg),short,short(-2 /* none of the documented return values */))
IMPFAIW(ODBCCP32,SQLInstallDriverManager,(LPTSTR szPath, WORD cbPathMax, WORD* pcbPathOut),(szPath, cbPathMax, pcbPathOut),BOOL,TYPE_E_DLLFUNCTIONNOTFOUND)
IMPFAIW(ODBCCP32,SQLRemoveDriverManager,(DWORD* pdwUsageCount),(pdwUsageCount),BOOL,TYPE_E_DLLFUNCTIONNOTFOUND)
LIBTERM

typedef BOOL (CALLBACK *PPATCH_PROGRESS_CALLBACK)(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    );

LIBBIND(MSPATCHA)
IMPBIND(MSPATCHA,TestApplyPatchToFileByHandles,(HANDLE hPatchFile, HANDLE hTargetFile, ULONG  ulApplyOptionFlags),(hPatchFile, hTargetFile, ulApplyOptionFlags),BOOL,(SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPBIND(MSPATCHA,ApplyPatchToFileByHandlesEx,(HANDLE hPatchFile, HANDLE hTargetFile, HANDLE hOutputFile, ULONG  ulApplyOptionFlags, PPATCH_PROGRESS_CALLBACK pCallback, PVOID pCallbackContext),(hPatchFile,hTargetFile,hOutputFile,ulApplyOptionFlags,pCallback,pCallbackContext),BOOL,(SetLastError(ERROR_INVALID_FUNCTION),FALSE))
LIBTERM

#include <shlwapi.h>
LIBBIND(SHLWAPI)
LIBFAIL(SHLWAPI)
IMPFAOW(SHLWAPI,UrlCanonicalize,(LPCTSTR pszUrl, LPTSTR pszCanonicalized, LPDWORD pcchCanonicalized, DWORD dwFlags), (pszUrl, pszCanonicalized, pcchCanonicalized, dwFlags), HRESULT, TYPE_E_DLLFUNCTIONNOTFOUND)
IMPFAOW(SHLWAPI,UrlCombine,(LPCTSTR pszBase, LPCTSTR pszRelative, LPTSTR pszCombined, LPDWORD pcchCombined, DWORD dwFlags), (pszBase, pszRelative, pszCombined, pcchCombined, dwFlags), HRESULT, TYPE_E_DLLFUNCTIONNOTFOUND)
IMPFAOW(SHLWAPI,UrlIs,(LPCTSTR pszUrl, URLIS eUrlIs), (pszUrl, eUrlIs), BOOL, (SetLastError(ERROR_PROC_NOT_FOUND), FALSE))
IMPFAOW(SHLWAPI,UrlIsFileUrl,(LPCTSTR pszUrl), (pszUrl), BOOL, (SetLastError(ERROR_PROC_NOT_FOUND), FALSE))
IMPFAOW(SHLWAPI,UrlGetPart,(LPCTSTR pszIn, LPTSTR pszOut, LPDWORD pcchOut, DWORD dwPart, DWORD dwFlags), (pszIn, pszOut, pcchOut, dwPart, dwFlags), HRESULT, TYPE_E_DLLFUNCTIONNOTFOUND)
IMPFAOW(SHLWAPI,PathCreateFromUrl, (LPCTSTR pszUrl, LPTSTR pszPath, LPDWORD pcchPath, DWORD dwFlags), (pszUrl, pszPath, pcchPath, dwFlags), HRESULT, TYPE_E_DLLFUNCTIONNOTFOUND)
LIBTERM

LIBBIND(WININET)
LIBFAIL(WININET)
IMPFAOW(WININET,DeleteUrlCacheEntry, (LPCTSTR lpszUrlName),(lpszUrlName), BOOL, FALSE)
LIBTERM

LIBBIND(URLMON)
LIBFAIL(URLMON)
IMPFAOW(URLMON,URLDownloadToCacheFile, (LPUNKNOWN lpUnkcaller, LPCTSTR szURL, LPTSTR szFileName, DWORD dwBufLength, DWORD dwReserved, IBindStatusCallback* pBSC),(lpUnkcaller, szURL, szFileName, dwBufLength, dwReserved, pBSC), HRESULT, TYPE_E_DLLFUNCTIONNOTFOUND)
LIBTERM

LIBBIND(KERNEL32)
LIBFAIL(KERNEL32)
LIBEMUL(KERNEL32)
IMPFAIL(KERNEL32,SetThreadExecutionState, (EXECUTION_STATE esState),(esState), BOOL, FALSE)
OPTBIND(KERNEL32,GetUserDefaultUILanguage, (), (), LANGID)
IMPAORW(KERNEL32,GetLongPathName,(LPCTSTR lpszLongPath, LPTSTR lpszShortPath, DWORD cchBuffer),(lpszLongPath, lpszShortPath, cchBuffer), DWORD , (SetLastError(ERROR_INVALID_FUNCTION), FALSE))
IMPAORW(KERNEL32,GetSystemWindowsDirectory, (LPTSTR lpBuffer, UINT uSize),(lpBuffer, uSize), UINT, 0)
OPTAORW(KERNEL32,GetFileAttributesEx, (LPCTSTR szFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpInfo), (szFileName, fInfoLevelId, lpInfo), BOOL)
IMPFAIL(KERNEL32,GlobalMemoryStatusEx, (LPMEMORYSTATUSEX lpBuffer),(lpBuffer), BOOL, (SetLastError(ERROR_INVALID_FUNCTION), FALSE))
IMPBIND(KERNEL32,GetEnvironmentStringsW, (), (), LPVOID, NULL)
IMPBIND(KERNEL32,FreeEnvironmentStringsW, (LPWSTR szEnvironmentBlock),(szEnvironmentBlock), BOOL, FALSE)
IMPBIND(KERNEL32,CreateWaitableTimerW, (LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName),(lpTimerAttributes, bManualReset, lpTimerName), HANDLE, 0)
IMPBIND(KERNEL32,SetWaitableTimer, (HANDLE hTimer, const LARGE_INTEGER* pDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletion, LPVOID lpArg, BOOL fResume),(hTimer, pDueTime, lPeriod, pfnCompletion, lpArg, fResume), BOOL, FALSE)
IMPBIND(KERNEL32,CancelWaitableTimer, (HANDLE hTimer),(hTimer), BOOL, FALSE)
IMPFAOW(KERNEL32,GetSystemWow64Directory, (LPTSTR lpBuffer, UINT uSize), (lpBuffer, uSize), UINT, 0)
LIBTERM

// The following three functions are undocumented. CreateEnvironmentBlock, per ericflo, will soon be
// documented. There are no plans to document RtlSetCurrentEnvironment so it's therefore subject
// to change (though this is unlikely)
//
// CreateEnvironmentBlock & DestroyEnvironmentBlock are in the NT source tree in windows\gina\userenv\envvar.c
// RtlSetCurrentEnvironment is in the NT source tree in ntos\rtl\environ.c

LIBBIND(USERENV)
IMPBIND(USERENV,CreateEnvironmentBlock, (void**pEnv, HANDLE  hToken, BOOL bInherit),(pEnv, hToken, bInherit), BOOL, FALSE)
IMPBIND(USERENV,DestroyEnvironmentBlock,(LPVOID lpEnvironment), (lpEnvironment), BOOL, FALSE)
LIBTERM

LIBBIND(NTDLL)
LIBFAIL(NTDLL)
IMPBIND(NTDLL, RtlSetCurrentEnvironment,(void* Environment, void **PreviousEnvironment), (Environment, PreviousEnvironment), DWORD, ERROR_CALL_NOT_IMPLEMENTED)
IMPFAIL(NTDLL, NtQuerySystemInformation,(IN SYSTEM_INFORMATION_CLASS SystemInformationClass,OUT PVOID SystemInformation,IN ULONG SystemInformationLength,OUT PULONG ReturnLength OPTIONAL), (SystemInformationClass,SystemInformation,SystemInformationLength,ReturnLength), NTSTATUS, TYPE_E_DLLFUNCTIONNOTFOUND)
IMPFAIL(NTDLL, NtQueryInformationProcess,(IN HANDLE ProcessHandle, IN PROCESSINFOCLASS ProcessInformationClass, OUT PVOID ProcessInformation, IN ULONG ProcessInformationLength, OUT PULONG ReturnLength OPTIONAL), (ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLength), NTSTATUS, TYPE_E_DLLFUNCTIONNOTFOUND)
IMPFAIL(NTDLL, NtSetSystemInformation,  (IN SYSTEM_INFORMATION_CLASS SystemInformationClass,IN PVOID SystemInformation, IN ULONG SystemInformationLength), (SystemInformationClass, SystemInformation, SystemInformationLength), NTSTATUS, TYPE_E_DLLFUNCTIONNOTFOUND)
IMPFAIL(NTDLL, RtlRandom,  (IN OUT PULONG pulSeed), (pulSeed), ULONG, 0)
IMPBIND(NTDLL, NtRenameKey, (IN HANDLE KeyHandle, IN PUNICODE_STRING NewName), (KeyHandle, NewName), NTSTATUS, ERROR_CALL_NOT_IMPLEMENTED)
IMPBIND(NTDLL, NtOpenKey, (OUT PHANDLE KeyHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes), (KeyHandle, DesiredAccess, ObjectAttributes), NTSTATUS, ERROR_CALL_NOT_IMPLEMENTED)
IMPVOID(NTDLL, RtlInitUnicodeString, (PUNICODE_STRING DestinationString, PCWSTR SourceString), (DestinationString, SourceString))
IMPBIND(NTDLL, RtlCreateEnvironment, (BOOLEAN CloneCurrentEnvironment, PVOID* ppvEnvironment), (CloneCurrentEnvironment, ppvEnvironment), NTSTATUS, STATUS_NOT_IMPLEMENTED)
IMPBIND(NTDLL, RtlSetEnvironmentVariable, (PVOID* ppvEnvironment, PUNICODE_STRING Name, PUNICODE_STRING Value), (ppvEnvironment, Name, Value), NTSTATUS, STATUS_NOT_IMPLEMENTED)
IMPBIND(NTDLL, RtlDestroyEnvironment, (PVOID pvEnvironment), (pvEnvironment), NTSTATUS, STATUS_NOT_IMPLEMENTED)
LIBTERM

// CSCQueryFileStatusA is not implemented (as of NT5 1836)
LIBBIND(CSCDLL)
LIBFAIL(CSCDLL)
LIBEMUL(CSCDLL)
IMPFAIL(CSCDLL,CSCQueryFileStatusW,(LPCWSTR lpszFileName, LPDWORD lpdwStatus, LPDWORD lpdwPinCount, LPDWORD lpdwHintFlags),(lpszFileName, lpdwStatus, lpdwPinCount, lpdwHintFlags),BOOL,FALSE)
OPTBIND(CSCDLL,CSCPinFileW,(LPCWSTR lpszFileName, DWORD dwHintFlags, LPDWORD lpdwStatus, LPDWORD lpdwPinCount, LPDWORD lpdwHintFlags), (lpszFileName, dwHintFlags, lpdwStatus, lpdwPinCount, lpdwHintFlags),BOOL)
OPTBIND(CSCDLL,CSCUnpinFileW,(LPCWSTR lpszFileName, DWORD dwHintFlags, LPDWORD lpdwStatus, LPDWORD lpdwPinCount, LPDWORD lpdwHintFlags), (lpszFileName, dwHintFlags, lpdwStatus, lpdwPinCount, lpdwHintFlags),BOOL)
LIBTERM

LIBBIND(SHFOLDER)
LIBEMUL(SHFOLDER)
OPTAORW(SHFOLDER,SHGetFolderPath,(HWND hwnd, int csidl, HANDLE hToken, DWORD dwRes, LPTSTR pszPath),(hwnd, csidl, hToken, dwRes, pszPath),HRESULT)
LIBTERM

LIBBIND(TSAPPCMP)
LIBFAIL(TSAPPCMP)
IMPFAIL(TSAPPCMP,TermServPrepareAppInstallDueMSI,(void),(),NTSTATUS,STATUS_NOT_IMPLEMENTED)
IMPFAIL(TSAPPCMP,TermServProcessAppInstallDueMSI,(BOOLEAN Abort),(Abort),NTSTATUS,STATUS_NOT_IMPLEMENTED)
IMPFAIL(TSAPPCMP,TermsrvLogInstallIniFileEx,(LPCWSTR pDosFileName),(pDosFileName),BOOL,FALSE)
IMPVOID(TSAPPCMP,TermsrvCheckNewIniFiles,(void), ())
LIBTERM

// Terminal Server Stuff to figure out the number of users logged on to the system on XP and higher systems.
LIBBIND(WINSTA)
LIBFAIL(WINSTA)
IMPFAIL(WINSTA,WinStationGetTermSrvCountersValue, (HANDLE hServer, ULONG dwEntries, PVOID pCounter), (hServer, dwEntries, pCounter), BOOL, FALSE)
LIBTERM

// Terminal Server stuff to figure out the number of users logged on to a W2K TS system.
LIBBIND(WTSAPI32)
LIBFAIL(WTSAPI32)
IMPFAOW(WTSAPI32, WTSEnumerateSessions, (HANDLE hServer, DWORD Reserved, DWORD Version, PWTS_SESSION_INFO* ppSessionInfo, DWORD* pCount), (hServer, Reserved, Version, ppSessionInfo, pCount), BOOL, FALSE)
IMPVOID(WTSAPI32, WTSFreeMemory, (PVOID pMemory), (pMemory))
LIBTERM


#ifdef UNICODE
// System Restore 
#define SYSTEMRESTORE SRCLIENT
LIBBIND(SRCLIENT)
LIBEMUL(SRCLIENT)
LIBFAIL(SRCLIENT)
OPTAORW(SRCLIENT,SRSetRestorePoint, (PRESTOREPOINTINFO pRestorePtSpec, PSTATEMGRSTATUS pSMgrStatus), (pRestorePtSpec, pSMgrStatus), BOOL)
LIBTERM
#endif

// SFP
LIBBIND(SFC)
LIBEMUL(SFC)
LIBFAIL(SFC)

#ifndef UNICODE
#define SYSTEMRESTORE SFC
OPTBIND(SFC,SRSetRestorePoint, (PRESTOREPOINTINFO pRestorePtSpec, PSTATEMGRSTATUS pSMgrStatus), (pRestorePtSpec, pSMgrStatus), BOOL)
#endif

// Windows 2000 Entry points    - Do NOT call on 9X
OPTBIND(SFC,SfcIsFileProtected,(HANDLE RpcHandle, LPCWSTR ProtFileName),(RpcHandle, ProtFileName),BOOL)
IMPORDI(SFC,SfcConnectToServer,(LPCWSTR ServerName), (ServerName), HANDLE, 0, SfcConnectToServerOrd)
IMPORDV(SFC,SfcClose,(HANDLE RpcHandle), (RpcHandle), SfcCloseOrd)
IMPORDI(SFC,SfcInstallProtectedFiles, (HANDLE RpcHandle,PCWSTR FileNames,BOOL AllowUI,PCWSTR ClassName, PCWSTR WindowName, PSFCNOTIFICATIONCALLBACK NotificationCallback,DWORD_PTR Context),(RpcHandle, FileNames, AllowUI, ClassName, WindowName, NotificationCallback, Context),BOOL, true, SfcInstallProtectedFilesOrd)

// Millennium Entry points      - Do NOT call on Windows 2000
IMPORDI(SFC,SfpInstallCatalog,(LPCTSTR pszCatName, LPCTSTR pszCatDependency), (pszCatName, pszCatDependency), DWORD, ERROR_CALL_NOT_IMPLEMENTED, SfpInstallCatalogOrd)
IMPBIND(SFC,SfpDuplicateCatalog,(LPCTSTR pszCatalogName, LPCTSTR pszDestinationDir), (pszCatalogName, pszDestinationDir), DWORD, ERROR_CALL_NOT_IMPLEMENTED)
IMPORDI(SFC,SfpDeleteCatalog,(LPCTSTR pszCatName), (pszCatName), DWORD, ERROR_CALL_NOT_IMPLEMENTED, SfpDeleteCatalogOrd)
LIBTERM

// ImageHlp.dll
LIBBIND(IMAGEHLP)
LIBFAIL(IMAGEHLP)
IMPFAIL(IMAGEHLP, ImageNtHeader, (PVOID ImageBase), (ImageBase), PIMAGE_NT_HEADERS, NULL)
LIBTERM

// fusion.dll
LIBLOAD(FUSION)
IMPBIND(FUSION,CreateAssemblyNameObject,(IAssemblyName**  ppAssemblyName, LPCWSTR szAssemblyName, DWORD dwFlags, LPVOID pvReserved),(ppAssemblyName, szAssemblyName, dwFlags, pvReserved),HRESULT,TYPE_E_DLLFUNCTIONNOTFOUND)
IMPBIND(FUSION,CreateAssemblyCache,(IAssemblyCache** ppAsmCache, DWORD dwReserved),(ppAsmCache, dwReserved),HRESULT,TYPE_E_DLLFUNCTIONNOTFOUND)
LIBTERM

// mscoree.dll
LIBLOAD(MSCOREE)
IMPBIND(MSCOREE,GetCORSystemDirectory,(LPWSTR wszPath, DWORD dwPath, LPDWORD lpdwPath),(wszPath, dwPath, lpdwPath),HRESULT,TYPE_E_DLLFUNCTIONNOTFOUND)
LIBTERM


// WinTrust.dll
LIBBIND(WINTRUST)
LIBFAIL(WINTRUST)
IMPFAIL(WINTRUST,WinVerifyTrust,(HWND hWnd, GUID *pgActionId, WINTRUST_DATA *pWinTrustData), (hWnd, pgActionId, pWinTrustData), HRESULT, TYPE_E_DLLFUNCTIONNOTFOUND)
IMPFAIL(WINTRUST,WTHelperGetProvSignerFromChain,(PCRYPT_PROVIDER_DATA pProvData, DWORD idxSigner, BOOL fCounterSigner, DWORD idxCounterSigner), (pProvData, idxSigner, fCounterSigner, idxCounterSigner), PCRYPT_PROVIDER_SGNR, NULL)
IMPFAIL(WINTRUST,WTHelperGetProvCertFromChain,(PCRYPT_PROVIDER_SGNR pSgnr, DWORD idxCert), (pSgnr, idxCert), PCRYPT_PROVIDER_CERT, NULL)
IMPFAIL(WINTRUST,WTHelperProvDataFromStateData,(HANDLE hStateData), (hStateData), PCRYPT_PROVIDER_DATA, NULL)
LIBTERM

// Crypt32.dll
LIBBIND(CRYPT32)
LIBFAIL(CRYPT32)
IMPFAIL(CRYPT32,CertDuplicateCertificateContext,(PCCERT_CONTEXT pCertContext), (pCertContext), PCCERT_CONTEXT, NULL)
IMPFAIL(CRYPT32,CertFreeCertificateContext,(PCCERT_CONTEXT pCertContext), (pCertContext), BOOL, FALSE)
LIBTERM

LIBBIND(SXS)
LIBFAIL(SXS)
IMPBIND(SXS,CreateAssemblyNameObject,(IAssemblyName**  ppAssemblyName, LPCWSTR szAssemblyName, DWORD dwFlags, LPVOID pvReserved),(ppAssemblyName, szAssemblyName, dwFlags, pvReserved),HRESULT,TYPE_E_DLLFUNCTIONNOTFOUND)
IMPBIND(SXS,CreateAssemblyCache,(IAssemblyCache** ppAsmCache, DWORD dwReserved),(ppAsmCache, dwReserved),HRESULT,TYPE_E_DLLFUNCTIONNOTFOUND)
LIBTERM

LIBBIND(USER32)
LIBFAIL(USER32)
IMPBIND(USER32,AllowSetForegroundWindow, (DWORD dwProcessId),(dwProcessId), BOOL, FALSE)
IMPFAIL(USER32,RecordShutdownReason, (PSHUTDOWN_REASON psr),(psr), BOOL, FALSE)
LIBTERM

LIBBIND(RPCRT4)
LIBFAIL(RPCRT4)
IMPFAIL(RPCRT4,I_RpcBindingInqLocalClientPID,(RPC_BINDING_HANDLE Binding, unsigned long* Pid),(Binding, Pid),RPC_STATUS,ERROR_CALL_NOT_IMPLEMENTED)
LIBTERM

LIBLOAD(WINHTTP)
IMPBIND(WINHTTP,WinHttpOpen,(LPCWSTR pwszUserAgent, DWORD dwAccessType, LPCWSTR pwszProxyName, LPCWSTR pwszProxyBypass, DWORD dwFlags),(pwszUserAgent, dwAccessType, pwszProxyName, pwszProxyBypass, dwFlags),HINTERNET,(SetLastError(ERROR_PROC_NOT_FOUND),NULL))
IMPBIND(WINHTTP,WinHttpConnect,(HINTERNET hSession, LPCWSTR pwszServerName, INTERNET_PORT nServerPort, DWORD dwReserved),(hSession, pwszServerName, nServerPort, dwReserved), HINTERNET, (SetLastError(ERROR_PROC_NOT_FOUND), NULL))
IMPBIND(WINHTTP,WinHttpCrackUrl,(LPCWSTR pwszUrl, DWORD dwUrlLength, DWORD dwFlags, LPURL_COMPONENTSW lpUrlComponents), (pwszUrl, dwUrlLength, dwFlags, lpUrlComponents), BOOL, (SetLastError(ERROR_PROC_NOT_FOUND), FALSE))
IMPBIND(WINHTTP,WinHttpOpenRequest,(HINTERNET hConnect, LPCWSTR pwszVerb, LPCWSTR pwszObjectName, LPCWSTR pwszVersion, LPCWSTR pwszReferrer, LPCWSTR* ppwszAcceptTypes, DWORD dwFlags), (hConnect, pwszVerb, pwszObjectName, pwszVersion, pwszReferrer, ppwszAcceptTypes, dwFlags), HINTERNET, (SetLastError(ERROR_PROC_NOT_FOUND), NULL))
IMPBIND(WINHTTP,WinHttpCloseHandle,(HINTERNET hInternet), (hInternet), BOOL, (SetLastError(ERROR_PROC_NOT_FOUND), FALSE))
IMPBIND(WINHTTP,WinHttpSendRequest,(HINTERNET hRequest, LPCWSTR pwszHeaders, DWORD dwHeadersLength, LPCWSTR pwszOptional, DWORD dwOptionalLength, DWORD dwTotalLength, DWORD_PTR pdwContext), (hRequest, pwszHeaders, dwHeadersLength, pwszOptional, dwOptionalLength, dwTotalLength, pdwContext), BOOL, (SetLastError(ERROR_PROC_NOT_FOUND), FALSE))
IMPBIND(WINHTTP,WinHttpReceiveResponse,(HINTERNET hRequest, LPVOID lpReserved), (hRequest, lpReserved), BOOL, (SetLastError(ERROR_PROC_NOT_FOUND), FALSE))
IMPBIND(WINHTTP,WinHttpQueryDataAvailable,(HINTERNET hRequest, LPDWORD lpdwBytesAvailable),(hRequest, lpdwBytesAvailable),BOOL, (SetLastError(ERROR_PROC_NOT_FOUND), FALSE))
IMPBIND(WINHTTP,WinHttpReadData,(HINTERNET hRequest, LPVOID lpBuffer, DWORD dwBytesToRead, LPDWORD lpdwBytesRead), (hRequest, lpBuffer, dwBytesToRead, lpdwBytesRead), BOOL, (SetLastError(ERROR_PROC_NOT_FOUND), FALSE))
IMPBIND(WINHTTP,WinHttpQueryHeaders, (HINTERNET hRequest, DWORD dwInfoLevel, LPCWSTR pwszName, LPVOID lpBuffer, LPDWORD lpdwBufferLength, LPDWORD lpdwIndex), (hRequest, dwInfoLevel, pwszName, lpBuffer, lpdwBufferLength, lpdwIndex), BOOL, (SetLastError(ERROR_PROC_NOT_FOUND), FALSE))
IMPBIND(WINHTTP,WinHttpGetProxyForUrl, (HINTERNET hSession, LPCWSTR lpcwszUrl, WINHTTP_AUTOPROXY_OPTIONS* pAutoProxyOptions, LPWINHTTP_PROXY_INFO pProxyInfo), (hSession, lpcwszUrl, pAutoProxyOptions, pProxyInfo), BOOL, (SetLastError(ERROR_PROC_NOT_FOUND), FALSE))
IMPBIND(WINHTTP,WinHttpGetIEProxyConfigForCurrentUser, (WINHTTP_CURRENT_USER_IE_PROXY_CONFIG* pProxyConfig), (pProxyConfig), BOOL, (SetLastError(ERROR_PROC_NOT_FOUND), FALSE))
IMPBIND(WINHTTP,WinHttpSetOption, (HINTERNET hInternet, DWORD dwOption, LPVOID lpBuffer, DWORD dwBufferLength), (hInternet, dwOption, lpBuffer, dwBufferLength), BOOL, (SetLastError(ERROR_PROC_NOT_FOUND), FALSE))
LIBTERM

// appcompat helper dll
#ifdef UNICODE
// APPHELP is the dll on Whistler and above
// SDBAPI[A|W] is the dll on downlevel
LIBBIND(APPHELP)
LIBFAIL(APPHELP)
IMPFAIL(APPHELP,SdbInitDatabase,(DWORD dwFlags, LPCTSTR pszDatabasePath),(dwFlags, pszDatabasePath),SHIMDBNS::HSDB,(SetLastError(ERROR_INVALID_FUNCTION),NULL))
IMPFAIL(APPHELP,SdbFindFirstMsiPackage_Str,(SHIMDBNS::HSDB hSDB, LPCTSTR lpszGuid, LPCTSTR lpszLocalDB, SHIMDBNS::PSDBMSIFINDINFO pFindInfo),(hSDB, lpszGuid, lpszLocalDB, pFindInfo),SHIMDBNS::TAGREF,(SetLastError(ERROR_INVALID_FUNCTION),TAGREF_NULL))
IMPFAIL(APPHELP,SdbFindNextMsiPackage,(SHIMDBNS::HSDB hSDB, SHIMDBNS::PSDBMSIFINDINFO pFindInfo),(hSDB, pFindInfo),SHIMDBNS::TAGREF,(SetLastError(ERROR_INVALID_FUNCTION),TAGREF_NULL))
IMPFAIL(APPHELP,SdbQueryDataEx,(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trExe, LPCTSTR lpszDataName, LPDWORD lpdwDataType, LPVOID lpBuffer, LPDWORD lpdwBufferSize, SHIMDBNS::TAGREF* ptrData),(hSDB, trExe, lpszDataName, lpdwDataType, lpBuffer, lpdwBufferSize, ptrData),DWORD,ERROR_INVALID_FUNCTION)
IMPFAIL(APPHELP,SdbEnumMsiTransforms,(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trMatch, SHIMDBNS::TAGREF* ptrBuffer, DWORD* pdwBufferSize),(hSDB, trMatch, ptrBuffer, pdwBufferSize),DWORD,ERROR_INVALID_FUNCTION)
IMPFAIL(APPHELP,SdbReadMsiTransformInfo,(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trTransformRef, SHIMDBNS::PSDBMSITRANSFORMINFO pTransformInfo),(hSDB, trTransformRef, pTransformInfo),BOOL,(SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPFAIL(APPHELP,SdbCreateMsiTransformFile,(SHIMDBNS::HSDB hSDB, LPCTSTR lpszFileName, SHIMDBNS::PSDBMSITRANSFORMINFO pTransformInfo),(hSDB, lpszFileName, pTransformInfo),BOOL,(SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPFAIL(APPHELP,SdbFindFirstTagRef,(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trParent, SHIMDBNS::TAG tTag),(hSDB, trParent, tTag),SHIMDBNS::TAGREF,(SetLastError(ERROR_INVALID_FUNCTION),TAGREF_NULL))
IMPFAIL(APPHELP,SdbFindNextTagRef,(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trParent, SHIMDBNS::TAGREF trPrev),(hSDB, trParent, trPrev),SHIMDBNS::TAGREF,(SetLastError(ERROR_INVALID_FUNCTION),TAGREF_NULL))
IMPFAIL(APPHELP,SdbReadStringTagRef,(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trMatch, LPTSTR pwszBuffer, DWORD dwBufferSize),(hSDB, trMatch, pwszBuffer, dwBufferSize),BOOL,(SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPFAIL(APPHELP,SdbGetMsiPackageInformation,(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trMatch, SHIMDBNS::PMSIPACKAGEINFO pPackageInfo),(hSDB, trMatch, pPackageInfo),BOOL,(SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPFAIL(APPHELP,ApphelpCheckMsiPackage,(GUID* pguidDB, GUID* pguidID, DWORD dwFlags, BOOL  bNoUI),(pguidDB, pguidID, dwFlags, bNoUI),BOOL,(SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPVOID(APPHELP,SdbReleaseDatabase,(SHIMDBNS::HSDB hSDB),(hSDB))
IMPFAIL(APPHELP,ApphelpFixMsiPackage,(GUID* pguidDB, GUID* pguidID, LPCWSTR wszFileName, LPCWSTR wszActionName, DWORD dwFlags),(pguidDB, pguidID, wszFileName, wszActionName, dwFlags),BOOL,(SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPFAIL(APPHELP,ApphelpFixMsiPackageExe,(GUID* pguidDB, GUID* pguidID, LPCWSTR wszActionName, LPWSTR wszEnv, DWORD* dwBufferSize),(pguidDB, pguidID, wszActionName, wszEnv, dwBufferSize),BOOL,(SetLastError(ERROR_INVALID_FUNCTION),FALSE))
LIBTERM

LIBBIND(SDBAPIU)
LIBFAIL(SDBAPIU)
IMPFAIL(SDBAPIU,SdbInitDatabase,(DWORD dwFlags, LPCTSTR pszDatabasePath),(dwFlags, pszDatabasePath),SHIMDBNS::HSDB,(SetLastError(ERROR_INVALID_FUNCTION),NULL))
IMPFAIL(SDBAPIU,SdbFindFirstMsiPackage_Str,(SHIMDBNS::HSDB hSDB, LPCTSTR lpszGuid, LPCTSTR lpszLocalDB, SHIMDBNS::PSDBMSIFINDINFO pFindInfo),(hSDB, lpszGuid, lpszLocalDB, pFindInfo),SHIMDBNS::TAGREF,(SetLastError(ERROR_INVALID_FUNCTION),TAGREF_NULL))
IMPFAIL(SDBAPIU,SdbFindNextMsiPackage,(SHIMDBNS::HSDB hSDB, SHIMDBNS::PSDBMSIFINDINFO pFindInfo),(hSDB, pFindInfo),SHIMDBNS::TAGREF,(SetLastError(ERROR_INVALID_FUNCTION),TAGREF_NULL))
IMPFAIL(SDBAPIU,SdbQueryDataEx,(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trExe, LPCTSTR lpszDataName, LPDWORD lpdwDataType, LPVOID lpBuffer, LPDWORD lpdwBufferSize, SHIMDBNS::TAGREF* ptrData),(hSDB, trExe, lpszDataName, lpdwDataType, lpBuffer, lpdwBufferSize, ptrData),DWORD,ERROR_INVALID_FUNCTION)
IMPFAIL(SDBAPIU,SdbEnumMsiTransforms,(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trMatch, SHIMDBNS::TAGREF* ptrBuffer, DWORD* pdwBufferSize),(hSDB, trMatch, ptrBuffer, pdwBufferSize),DWORD,ERROR_INVALID_FUNCTION)
IMPFAIL(SDBAPIU,SdbReadMsiTransformInfo,(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trTransformRef, SHIMDBNS::PSDBMSITRANSFORMINFO pTransformInfo),(hSDB, trTransformRef, pTransformInfo),BOOL,(SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPFAIL(SDBAPIU,SdbCreateMsiTransformFile,(SHIMDBNS::HSDB hSDB, LPCTSTR lpszFileName, SHIMDBNS::PSDBMSITRANSFORMINFO pTransformInfo),(hSDB, lpszFileName, pTransformInfo),BOOL,(SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPFAIL(SDBAPIU,SdbFindFirstTagRef,(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trParent, SHIMDBNS::TAG tTag),(hSDB, trParent, tTag),SHIMDBNS::TAGREF,(SetLastError(ERROR_INVALID_FUNCTION),TAGREF_NULL))
IMPFAIL(SDBAPIU,SdbFindNextTagRef,(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trParent, SHIMDBNS::TAGREF trPrev),(hSDB, trParent, trPrev),SHIMDBNS::TAGREF,(SetLastError(ERROR_INVALID_FUNCTION),TAGREF_NULL))
IMPFAIL(SDBAPIU,SdbReadStringTagRef,(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trMatch, LPTSTR pwszBuffer, DWORD dwBufferSize),(hSDB, trMatch, pwszBuffer, dwBufferSize),BOOL,(SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPVOID(SDBAPIU,SdbReleaseDatabase,(SHIMDBNS::HSDB hSDB),(hSDB))
LIBTERM
#else // ANSI
// SDBAPI is defined in shimdb.h which we've included above
// undef it here to make the latebinding work
#undef SDBAPI
LIBBIND(SDBAPI)
LIBFAIL(SDBAPI)
IMPFAIL(SDBAPI,SdbInitDatabase,(DWORD dwFlags, LPCTSTR pszDatabasePath),(dwFlags, pszDatabasePath),SHIMDBNS::HSDB,(SetLastError(ERROR_INVALID_FUNCTION),NULL))
IMPFAIL(SDBAPI,SdbFindFirstMsiPackage_Str,(SHIMDBNS::HSDB hSDB, LPCTSTR lpszGuid, LPCTSTR lpszLocalDB, SHIMDBNS::PSDBMSIFINDINFO pFindInfo),(hSDB, lpszGuid, lpszLocalDB, pFindInfo),SHIMDBNS::TAGREF,(SetLastError(ERROR_INVALID_FUNCTION),TAGREF_NULL))
IMPFAIL(SDBAPI,SdbFindNextMsiPackage,(SHIMDBNS::HSDB hSDB, SHIMDBNS::PSDBMSIFINDINFO pFindInfo),(hSDB, pFindInfo),SHIMDBNS::TAGREF,(SetLastError(ERROR_INVALID_FUNCTION),TAGREF_NULL))
IMPFAIL(SDBAPI,SdbQueryDataEx,(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trExe, LPCTSTR lpszDataName, LPDWORD lpdwDataType, LPVOID lpBuffer, LPDWORD lpdwBufferSize, SHIMDBNS::TAGREF* ptrData),(hSDB, trExe, lpszDataName, lpdwDataType, lpBuffer, lpdwBufferSize, ptrData),DWORD,ERROR_INVALID_FUNCTION)
IMPFAIL(SDBAPI,SdbEnumMsiTransforms,(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trMatch, SHIMDBNS::TAGREF* ptrBuffer, DWORD* pdwBufferSize),(hSDB, trMatch, ptrBuffer, pdwBufferSize),DWORD,ERROR_INVALID_FUNCTION)
IMPFAIL(SDBAPI,SdbReadMsiTransformInfo,(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trTransformRef, SHIMDBNS::PSDBMSITRANSFORMINFO pTransformInfo),(hSDB, trTransformRef, pTransformInfo),BOOL,(SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPFAIL(SDBAPI,SdbCreateMsiTransformFile,(SHIMDBNS::HSDB hSDB, LPCTSTR lpszFileName, SHIMDBNS::PSDBMSITRANSFORMINFO pTransformInfo),(hSDB, lpszFileName, pTransformInfo),BOOL,(SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPFAIL(SDBAPI,SdbFindFirstTagRef,(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trParent, SHIMDBNS::TAG tTag),(hSDB, trParent, tTag),SHIMDBNS::TAGREF,(SetLastError(ERROR_INVALID_FUNCTION),TAGREF_NULL))
IMPFAIL(SDBAPI,SdbFindNextTagRef,(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trParent, SHIMDBNS::TAGREF trPrev),(hSDB, trParent, trPrev),SHIMDBNS::TAGREF,(SetLastError(ERROR_INVALID_FUNCTION),TAGREF_NULL))
IMPFAIL(SDBAPI,SdbReadStringTagRef,(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trMatch, LPTSTR pwszBuffer, DWORD dwBufferSize),(hSDB, trMatch, pwszBuffer, dwBufferSize),BOOL,(SetLastError(ERROR_INVALID_FUNCTION),FALSE))
IMPVOID(SDBAPI,SdbReleaseDatabase,(SHIMDBNS::HSDB hSDB),(hSDB))
LIBTERM
#endif

#undef LIBBIND
#undef LIBFAIL
#undef LIBEMUL
#undef LIBLOAD
#undef LIBEMUL2
#undef IMPBIND
#undef IMPFAIL
#undef IMPFAIW
#undef IMPAORW
#undef IMPNORW
#undef IMPFAOW
#undef IMPVOID
#undef OPTBIND
#undef OPTAORW
#undef OPTVOID
#undef IMPORDI
#undef IMPORDV
#undef LIBTERM

//____________________________________________________________________________
//
// Emulation functions - require the use of OPTXXXX() and LIBEMUL(lib) macros
//____________________________________________________________________________

#ifdef LATEBIND_FUNCIMP
#undef LATEBIND_FUNCIMP
static BOOL WINAPI COMCTL32::E_InitCommonControlsEx(INITCOMMONCONTROLSEX*) {COMCTL32::InitCommonControls();return TRUE;}
static HRESULT WINAPI SHELL32::E_DllGetVersion(DLLVERSIONINFO* pdvi) {pdvi->dwMajorVersion = 0;return TYPE_E_DLLFUNCTIONNOTFOUND;}
static HRESULT WINAPI SHELL32::E_SHGetFolderPath(HWND , int , HANDLE , DWORD , LPTSTR ) {return TYPE_E_DLLFUNCTIONNOTFOUND;}
static HRESULT WINAPI ADVAPI32::E_RegOpenUserClassesRoot(HANDLE, DWORD, REGSAM, PHKEY) {return ERROR_PROC_NOT_FOUND;}
static HRESULT WINAPI ADVAPI32::E_RegOpenCurrentUser(REGSAM, PHKEY){return ERROR_PROC_NOT_FOUND;}
static BOOL WINAPI CSCDLL::E_CSCPinFileW(LPCWSTR, DWORD, LPDWORD, LPDWORD, LPDWORD) {SetLastError(ERROR_CALL_NOT_IMPLEMENTED); return FALSE;}
static BOOL WINAPI CSCDLL::E_CSCUnpinFileW(LPCWSTR, DWORD , LPDWORD , LPDWORD , LPDWORD ) {SetLastError(ERROR_CALL_NOT_IMPLEMENTED); return FALSE;}
static HRESULT WINAPI SHFOLDER::E_SHGetFolderPath(HWND , int , HANDLE , DWORD , LPTSTR ) {return TYPE_E_DLLFUNCTIONNOTFOUND;}
static LANGID WINAPI KERNEL32::E_GetUserDefaultUILanguage() {return WIN::GetUserDefaultLangID();}
static BOOL WINAPI SFC::E_SfcIsFileProtected(HANDLE, LPCWSTR) {return false;}
static BOOL WINAPI KERNEL32::E_GetFileAttributesEx(LPCTSTR, GET_FILEEX_INFO_LEVELS, LPVOID) {SetLastError(ERROR_PROC_NOT_FOUND); return FALSE;}
static BOOL WINAPI SYSTEMRESTORE::E_SRSetRestorePoint(PRESTOREPOINTINFO, PSTATEMGRSTATUS) {SetLastError(ERROR_PROC_NOT_FOUND); return FALSE;}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\istring.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       istring.h
//
//--------------------------------------------------------------------------

/*  istring.h - IMsiString, MsiString definitions

 IMsiString is a COM interface providing abstracted, allocated string handling.
   Separate implementations suport single-byte, DBCS, and Unicode.
 MsiString is a wrapper object holding only a pointer to an IMsiInterface.
   Its methods are all inline, providing convenient string operators.
 ICHAR is used as the fundamental character type for the project. Currently
   it is a char, but it will change to wchar_t if Unicode becomes standard.

 MsiString objects contain only a private, opaque COM interface pointer to an
 implementation within the services module. MsiString objects are used to pass
 string information throughout the product. The underlying string data may
 be stored as SBCS, DBCS, or Unicode, depending upon the orginal source.
 MsiString objects are normally constructed on the stack or as function args,
 in which case the cleanup is automatically controlled by the destructor.
 The implementation is optimized to minimize string copying. MsiString objects
 will be automaticlly converted when passed to functions requiring a const
 ICHAR* or an IMsiString&. MsiString objects may also be copied to a buffer.
 MsiString objects may either contain a private copy of string data, or may
 reference a constant string, in which case the referenced string must
 remain present during the lifetime of the MsiString object referencing it.
 Use the & operator to pass an MsiString to a function returning an IMsiString*
 through a return arg of type IMsiString** (as from IEnumMsiString::Next).
 To pass an MsiString as a return arg of type IMsiString*&, use the *& combination.
 The following functions are currently supported by the MsiString class:

 Constructors: MsiString() - base constructor representing a null string
               MsiString(const ICHAR*) - makes a copy of an ICHAR string
               MsiString(const ICHAR&) - references a static ICHAR string
                                         lifetime of input must exceed that of object
               MsiString(MsiChar ch) - constructs a 1-character string object
                                       must cast to enum, use sytax: MsiChar('X')
               MsiString(int i) - converts an integer to its string representation
                                  iMsiStringBadInteger produces an empty string
               MsiString(const MsiString&) - copy constructor, bumps ref.count
               MsiString(IMsiString&) - copies pointer, does NOT bump ref.count

 TextSize() - returns the string length in ICHARs, not including terminator

 CharacterCount() - returns the count of displayed characters (same for SBCS)

 CopyToBuf(ICHAR* buffer, unsigned int maxchars) - size not including null
    Returns the original string size, trucates if too large for buffer.

 Extract(iseEnum ase, unsigned int iLimit) - returns a new IMsiString& as:
         iseFirst      - the first iLimit characters of the current string
         iseLast       - the last iLimit characters of the current string
         iseUpto       - the string up to the character iLimit
         iseIncluding  - the string up to and including the charcter iLimit
         iseFrom       - the string starting with the final character iLimit
         iseAfter      - the string following the last charcter iLimit
    Note: If the condition is not met, the entire string is returned.

 Remove(iseEnum ase, unsigned int iLimit) - removes a section from an MsiString
    Uses the same iseEnum enum and conditions as Extract(...).
    Returns fTrue if successful, fFalse if the condition cannot be met.
    Using iseUpto or iseIncluding with a 0 value blanks the entire string.
    Returns fFalse with no action taken if condition is not met, fTrue if OK.

 Compare(iscEnum asc, const ICHAR* sz) - returns ordinal position of matched string, 
                                            0 if not matched
         iscExact       - supplied string matches exactly current string, case sensistive
         iscExactI       - supplied string matches exactly current string, case insensistive
         iscStart       - supplied string matches start of current string, case sensitive
         iscStartI      - supplied string matches start of current string, case insensitive
         iscEnd         - supplied string matches end of current string, case sensitive
         iscEndI        - supplied string matches end of current string, case insensitive
         iscWithin      - supplied string matches anywhere in current string, case sensisitve
         iscWithinI     - supplied string matches anywhere in current string, case insensitive

 operator +=  - concatenation in place, affects current MsiString object only
              - accepts ICHAR* or an MsiString object
 operator +   - combines current string with argument, returning a new IMsiString&
              - accepts ICHAR* or an MsiString object
 operator =   - assignment of a new string to the current MsiString object
              - accepts ICHAR* or an MsiString object
              - passing ICHAR& will reference string, no copy made
 Return() - use when returning an MsiString object as the return value from
                the function as an IMsiString&. Bumps the reference count.
 ReturnArg(IMsiString*& rpi) - use when returning an MsiString object via an
                     argument of type IMsiString*&. Bumps the reference count.
 AllocateString(unsigned int cch, Bool fDBCS) - allocates uninitialized string space,
                     returns a non-const pointer to it for immediate data copy.
                     fDBCS must be fTrue if string to be copied has DBCS chars.
                     Caution must be used to copy exactly cch ICHARs, not bytes.
 MsiString with be converted when assigned or passed as an argument of type
 IMsiString& or IMsiString*. No change is made to the underlying reference count.
 MsiString will provide integer conversion when coerced or assigned to an int.
 If the string is not a valid integer, value iMsiStringBadInteger is returned.

 Initialization required for each DLL before constucting any MsiString objects:
 the static function MsiString::InitializeClass must be called with a null string
 object that can be obtained by calling GetNullString on IMsiServices interface.
____________________________________________________________________________*/

#ifndef __ISTRING
#define __ISTRING

#ifdef MAC
#include "macstr.h"
#endif //MAC

//____________________________________________________________________________
//
//  Basic character type definitions, could later be changed to Unicode
//____________________________________________________________________________

#ifdef _CHAR_UNSIGNED  // test /J compiler switch (default char is unsigned)
# ifdef UNICODE
    typedef WCHAR ICHAR;     // OK to use char, can use literal strings without cast
# else
    typedef char ICHAR;     // OK to use char, can use literal strings without cast
# endif
#else
# ifdef UNICODE
	 typedef wchar_t ICHAR;  // if no /J, must cast all literal strings
# else
	 typedef unsigned char ICHAR;  // if no /J, must cast all literal strings
# endif
#endif

enum MsiChar {};  // used to for constructing IMsiString object with a character

//____________________________________________________________________________
//
//  Portable character string operations - inline wrappers for OS calls
//       NOTE: All strings assumed to be null terminated,
//             except for input to IStrCopyLen, IStrLowerLen, IStrUpperLen
//____________________________________________________________________________

inline int IStrLen(const ICHAR* sz)
	{ return lstrlen(sz); }
inline ICHAR* IStrCopyLen(ICHAR* dst, const ICHAR* src, int cchLen)
	{ return lstrcpyn(dst, src, cchLen + 1); }
inline int IStrComp(const ICHAR* dst, const ICHAR* src)
	{ return lstrcmp(dst, src); }
inline int IStrCompI(const ICHAR* dst, const ICHAR* src)
	{ return lstrcmpi(dst, src); }
inline void IStrUpper(ICHAR* sz)
	{ WIN::CharUpper(sz); }
inline void IStrUpperLen(ICHAR* sz, int cchLen)
	{ WIN::CharUpperBuff(sz, cchLen); }
inline void IStrLower(ICHAR* sz)
	{ WIN::CharLower(sz); }
inline void IStrLowerLen(ICHAR* sz, int cchLen)
	{ WIN::CharLowerBuff(sz, cchLen); }

#ifdef UNICODE
#define IStrStr(szFull, szSeg) wcsstr(szFull, szSeg)
inline ICHAR* IStrChr(const ICHAR* sz, const ICHAR ch)
	{ return wcschr(sz, ch); }
inline ICHAR* IStrRChr(const ICHAR* sz, const ICHAR ch)
	{ return wcsrchr(sz, ch); }
inline int IStrNCompI(const ICHAR* dst, const ICHAR* src, size_t count)
	{ return _wcsnicmp(dst, src, count); }
#else
#define IStrStr(szFull, szSeg) strstr(szFull, szSeg)
inline ICHAR* IStrChr(const ICHAR* sz, const ICHAR ch)
	{ return strchr(sz, ch); }
inline ICHAR* IStrRChr(const ICHAR* sz, const ICHAR ch)
	{ return strrchr(sz, ch); }
inline int IStrNCompI(const ICHAR* dst, const ICHAR* src, size_t count)
	{ return _strnicmp(dst, src, count); }
#endif

// NOTE: handler and msiexec do not have access to ICharNext and INextChar.
// The definitions for those modules are in handler.cpp and server.cpp for DEBUG-ANSI
#ifdef UNICODE
inline ICHAR* ICharNext(const ICHAR* pch) { return (0 == *pch) ? const_cast<ICHAR*>(pch) : const_cast<ICHAR*>(++pch); }
// INextChar acts differently between UNICODE and ANSI.
// WARNING: Up to caller to make sure not walk off array
inline ICHAR* INextChar(const ICHAR* pch) { return const_cast<ICHAR*>(++pch); }
#else // must handle DBCS if not Unicode
#ifdef DEBUG  // intercept CharNext, CharPrev to permit testing on non-DBCS systems
ICHAR* ICharNext(const ICHAR* pch);
ICHAR* INextChar(const ICHAR* pch);
#else  // if SHIP, call OS directly, inline optimized away
inline ICHAR* ICharNext(const ICHAR* pch) {	return WIN::CharNext(pch); }
inline ICHAR* INextChar(const ICHAR* pch) { return WIN::CharNext(pch); }
#endif
#endif

int CountChars(const ICHAR *);
int GetIntegerValue(const ICHAR *sz, Bool* pfValid /* can be NULL */);
const ICHAR *CharPrevCch(const ICHAR *, const ICHAR *,int);
#ifdef _WIN64
INT_PTR GetInt64Value(const ICHAR *sz, Bool* pfValid /* can be NULL */);
#else
#define GetInt64Value		GetIntegerValue
#endif

class IMsiString;

//____________________________________________________________________________
//
//  COM data value interface, common base class for data used by IMsiRecord
//____________________________________________________________________________

class IMsiData : public IUnknown {
 public:
	virtual const IMsiString& __stdcall GetMsiStringValue() const=0;
	virtual int         __stdcall GetIntegerValue() const=0;
#ifdef USE_OBJECT_POOL
	virtual unsigned int  __stdcall GetUniqueId() const=0;
	virtual void          __stdcall SetUniqueId(unsigned int id)=0;
#endif //USE_OBJECT_POOL

	// inline redirectors to allow IUnknown methods on const objects
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppv)=0;
	unsigned long __stdcall AddRef()=0;
	unsigned long __stdcall Release()=0;
	HRESULT       QueryInterface(const IID& riid, void** ppv) const {return const_cast<IMsiData*>(this)->QueryInterface(riid,ppv);}
	unsigned long AddRef() const  {return const_cast<IMsiData*>(this)->AddRef();}
	unsigned long Release() const {return const_cast<IMsiData*>(this)->Release();}
};
extern "C" const GUID IID_IMsiData;

//____________________________________________________________________________
//
//  COM string managment service, not used directly, but through class MsiString
//____________________________________________________________________________

// class IMsiString - COM managed string interface, used by MsiString class.
//       The underlying string data is total abstracted from user and
//       may be stored as SBCS, DBCS, Unicode, or resource information.
//       Many methods pass a reference to the result (nomally the same
//       "this" pointer); this is done since a new object is produced and
//       placed into the MsiString object in place of the old one. The old
//       one, this, will we released after the new pointer is assigned.

enum iseEnum
{
	iseInclude   = 1,
	iseChar      = 2,
	iseEnd       = 4,
	iseTrim      = 8,
	iseFirst     = 0,
	iseLast      = iseEnd,
	iseUpto      = iseChar,
	iseIncluding = iseChar+iseInclude,
	iseFrom      = iseChar+iseInclude+iseEnd,
	iseAfter     = iseChar+iseEnd,
	iseUptoTrim  = iseUpto+iseTrim,
	iseAfterTrim = iseAfter+iseTrim,
};

enum iscEnum
{
	iscExact  = 0,
	iscExactI = 1,
	iscStart = 2,
	iscStartI = 3,
	iscEnd = 4,	
	iscEndI = 5,						
	iscWithin = iscStart+iscEnd,		
	iscWithinI = iscStart+iscEnd+1,		
};

const int iMsiStringBadInteger = 0x80000000L; // GetInteger() invalid number return

class IMsiString : public IMsiData {
 public:
//	virtual IMsiString&       __stdcall GetMsiString() const=0;
//	virtual int               __stdcall GetInteger() const=0;
	virtual int               __stdcall TextSize() const=0;
	virtual int               __stdcall CharacterCount() const=0;
	virtual Bool              __stdcall IsDBCS() const=0;
	virtual const ICHAR*      __stdcall GetString() const=0;
	virtual int               __stdcall CopyToBuf(ICHAR* rgch, unsigned int cchMax) const=0;
	virtual void              __stdcall SetString(const ICHAR* sz, const IMsiString*& rpi) const=0;
	virtual void              __stdcall RefString(const ICHAR* sz, const IMsiString*& rpi) const=0;
	virtual void              __stdcall RemoveRef(const IMsiString*& rpi) const=0;
	virtual void              __stdcall SetInteger(int i, const IMsiString*& rpi) const=0;
	virtual void              __stdcall SetChar  (ICHAR ch,        const IMsiString*& rpi) const=0;
	virtual void              __stdcall SetBinary(const unsigned char* rgb, unsigned int cb, const IMsiString*& rpi) const=0;
	virtual void              __stdcall AppendString(const ICHAR* sz, const IMsiString*& rpi) const=0;
	virtual void              __stdcall AppendMsiString(const IMsiString& ri,const IMsiString*& rpi) const=0;
	virtual const IMsiString& __stdcall AddString(const ICHAR* sz) const=0;
	virtual const IMsiString& __stdcall AddMsiString(const IMsiString& ri) const=0;
	virtual const IMsiString& __stdcall Extract(iseEnum ase, unsigned int iLimit) const=0;
	virtual Bool              __stdcall Remove(iseEnum ase, unsigned int iLimit, const IMsiString*& rpi) const=0;
	virtual int               __stdcall Compare(iscEnum asc, const ICHAR* sz) const=0;
	virtual void              __stdcall UpperCase(const IMsiString*& rpi) const=0;
	virtual void              __stdcall LowerCase(const IMsiString*& rpi) const=0;
	virtual ICHAR*            __stdcall AllocateString(unsigned int cch, Bool fDBCS, const IMsiString*& rpi) const=0;
};
extern "C" const GUID IID_IMsiString;

//____________________________________________________________________________
//
// IEnumMsiString definition
//____________________________________________________________________________

class IEnumMsiString : public IUnknown
{ public:
	virtual HRESULT __stdcall Next(unsigned long cFetch, const IMsiString** rgpi, unsigned long* pcFetched)=0;
	virtual HRESULT __stdcall Skip(unsigned long cSkip)=0;
	virtual HRESULT __stdcall Reset()=0;
	virtual HRESULT __stdcall Clone(IEnumMsiString** ppiEnum)=0;
};

//____________________________________________________________________________
//
//  IMsiString derived class definitions to allow reference to static objects
//____________________________________________________________________________

//____________________________________________________________________________
//
// class MsiString - encapsulated string pointer, data is totally abstracted
//                 implementation is entirely inline, calling IMsiString methods
//____________________________________________________________________________

class CMsiStringNullCopy
{
	int m_dummy[4];   // enough space for null string object
};

class MsiString {
 public:
// constructors, destructor
	MsiString();                     // creates an empty string object
	MsiString(const ICHAR* sz);  // copy of sz is made
	MsiString(const ICHAR& sz);  // sz constant until MsiString modified or deleted
	MsiString(const unsigned char* rgb, unsigned int cb); // binary data to hex string
	MsiString(const MsiString& astr);  // copy constructor, simply bumps RefCnt
	MsiString(MsiChar ch);  // constructor using single character cast as enum MsiChar
	MsiString(int i);       // constructor converting an integer to a base10 string
	MsiString(const IMsiString& ri);          // construct wrapper on existing object
	//MsiString(HINSTANCE hInst, short iResId); // string obtained from .RC resource
  ~MsiString();
// member functions
	int               TextSize() const;  // returns count of ICHAR
	int               CharacterCount() const;  // returns display count
	Bool              IsDBCS();
	int               CopyToBuf(ICHAR* rgchBuf, unsigned int cchMax); // copies to buffer
	const IMsiString& Extract(iseEnum ase, unsigned int iLimit);
	Bool              Remove(iseEnum ase, unsigned int iLimit);
	int               Compare(iscEnum asc, const ICHAR* sz);
	void              UpperCase();
	void              LowerCase();
	const IMsiString& Return();
	void              ReturnArg(const IMsiString*& rpi);
	ICHAR*            AllocateString(unsigned int cch, Bool fDBCS);
// concatenation operators
	const IMsiString& operator  +(const MsiString& astr);
	const IMsiString& operator  +(const IMsiString& ri);
	const IMsiString& operator  +(const ICHAR* sz);
	MsiString&  operator +=(const MsiString& astr);
	MsiString&  operator +=(const IMsiString& ri);
	MsiString&  operator +=(const ICHAR* sz);
// assignment operators
	MsiString&  operator  =(const MsiString& astr);  // simply adds a reference
	MsiString&  operator  =(int i);            // assigns string value of int
	MsiString&  operator  =(const ICHAR* sz);  // makes private copy of string
	MsiString&  operator  =(const ICHAR& sz);  // references existing string
	void      operator  =(const IMsiString& ri);     // used by IMsiRecord
// conversion operators
	operator const ICHAR*() const;
	operator int() const;
	const IMsiString& operator *() const;   // eliminate pointer ambiguity
	operator const IMsiString*() const;     // for returning pointer, does not AddRef
	const IMsiString** operator &();        // for passing as a return argument
	static void InitializeClass(const IMsiString& riMsiStringNull); // required initialization
 private:
	const IMsiString* piStr;
	MsiString(const IMsiString* pi);
	static CMsiStringNullCopy s_NullString;
	operator const IMsiString&();
}; // NOTE: operator const IMsiString&() const generates bad code with VC5, don't use.
   //       This operator is declared here (but not defined!) to create a compile-time
   //       error when const IMsiString& casts are used.

//____________________________________________________________________________
//
//  MsiString inline implementation
//____________________________________________________________________________

// constructors, destructor
inline void MsiString::InitializeClass(const IMsiString& riMsiStringNull)
	{memcpy((void*)&s_NullString, &riMsiStringNull, sizeof(CMsiStringNullCopy));}
inline MsiString::MsiString()
	{piStr = (const IMsiString*)&s_NullString;}
inline MsiString::MsiString(const ICHAR* sz)
	{(piStr = (const IMsiString*)&s_NullString)->SetString(sz, piStr);}
inline MsiString::MsiString(const ICHAR& sz)
	{(piStr = (const IMsiString*)&s_NullString)->RefString(&sz, piStr);}
inline MsiString::MsiString(const unsigned char* rgb, unsigned int cb)
	{(piStr = (const IMsiString*)&s_NullString)->SetBinary(rgb, cb, piStr);}
inline MsiString::MsiString(const MsiString& astr)
	{piStr = astr.piStr; ((IUnknown*)piStr)->AddRef();}
inline MsiString::MsiString(const IMsiString* pi)
	{piStr = pi;}
inline MsiString::MsiString(const IMsiString& ri)
	{piStr = &ri;}
inline MsiString::MsiString(MsiChar ch)
	{(piStr = (const IMsiString*)&s_NullString)->SetChar((ICHAR)ch, piStr);}
inline MsiString::MsiString(int i)
	{(piStr = (const IMsiString*)&s_NullString)->SetInteger(i, piStr);}
inline MsiString::~MsiString()
	{piStr->Release();}

// member functions
inline int MsiString::TextSize() const
	{return piStr->TextSize();}
inline int MsiString::CharacterCount() const
	{return piStr->CharacterCount();}
inline Bool MsiString::IsDBCS() 
	{return piStr->IsDBCS();}
inline int MsiString::CopyToBuf(ICHAR* rgchBuf, unsigned int cchMax)
	{return piStr->CopyToBuf(rgchBuf, cchMax);}
inline const IMsiString& MsiString::Extract(iseEnum ase, unsigned int iLimit)
	{return piStr->Extract(ase, iLimit);}
inline Bool MsiString::Remove(iseEnum ase, unsigned int iLimit)
	{return piStr->Remove(ase, iLimit, piStr);}
inline int MsiString::Compare(iscEnum asc, const ICHAR* sz)
	{return piStr->Compare(asc, sz);}
inline void MsiString::UpperCase()
	{piStr->UpperCase(piStr);}
inline void MsiString::LowerCase()
	{piStr->LowerCase(piStr);}
inline const IMsiString& MsiString::Return()
	{piStr->AddRef(); return *piStr;}
inline void MsiString::ReturnArg(const IMsiString*& rpi)
	{piStr->AddRef(); rpi = piStr;}
inline ICHAR* MsiString::AllocateString(unsigned int cch, Bool fDBCS)
	{return piStr->AllocateString(cch, fDBCS, piStr);}

// concatenation operators
inline const IMsiString& MsiString::operator +(const MsiString& astr)
	{return piStr->AddMsiString(*astr.piStr);}
inline const IMsiString& MsiString::operator +(const IMsiString& ri)
	{return piStr->AddMsiString(ri);}
inline const IMsiString& MsiString::operator +(const ICHAR* sz)
	{return piStr->AddString(sz);}
inline MsiString& MsiString::operator +=(const MsiString& astr)
	{piStr->AppendMsiString(*astr.piStr, piStr); return *this;}
inline MsiString& MsiString::operator +=(const IMsiString& ri)
	{piStr->AppendMsiString(ri, piStr); return *this;}
inline MsiString& MsiString::operator +=(const ICHAR* sz)
	{piStr->AppendString(sz, piStr); return *this;}

// assignment operators
inline MsiString& MsiString::operator =(const MsiString& astr)
	{astr.piStr->AddRef();piStr->Release(); piStr = astr.piStr; return *this;} 
inline MsiString& MsiString::operator =(const ICHAR* sz)
	{piStr->SetString(sz, piStr); return *this;}
inline MsiString& MsiString::operator =(int i)
	{piStr->SetInteger(i, piStr); return *this;}
inline MsiString& MsiString::operator =(const ICHAR& sz)
	{piStr->RefString(&sz, piStr); return *this;}
inline void MsiString::operator =(const IMsiString& ri)
	{piStr->Release(); piStr = &ri;}

// conversion operators
inline MsiString::operator const ICHAR*() const
	{return piStr->GetString();}
inline MsiString::operator int() const
	{return piStr->GetIntegerValue();}
inline const IMsiString& MsiString::operator *() const
	{return *piStr;}
inline MsiString::operator const IMsiString*() const
	{return piStr;}
inline const IMsiString** MsiString::operator&()
	{piStr->Release(); piStr = (const IMsiString*)&s_NullString; return &piStr;}
#endif // __ISTRING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\msidspid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       msidspid.h
//
//--------------------------------------------------------------------------

/* msidspid.h - MSI OLE automation Invoke() dispatch IDs

____________________________________________________________________________*/

#ifndef __MSIDSPID
#define __MSIDSPID

#define DISPID_MsiData_StringValue    0
#define DISPID_MsiData_IntegerValue   1

#define DISPID_MsiRecord_Data         0
#define DISPID_MsiRecord_StringData   1
#define DISPID_MsiRecord_IntegerData  2
#define DISPID_MsiRecord_ObjectData   3
#define DISPID_MsiRecord_FieldCount   4
#define DISPID_MsiRecord_IsInteger    5
#define DISPID_MsiRecord_IsNull       6
#define DISPID_MsiRecord_IsChanged    7
#define DISPID_MsiRecord_TextSize     8
#define DISPID_MsiRecord_FormatText   9
#define DISPID_MsiRecord_ClearData   10
#define DISPID_MsiRecord_ClearUpdate 11

#define DISPID_MsiStorage_Class              1
#define DISPID_MsiStorage_OpenStream         2
#define DISPID_MsiStorage_OpenStorage        3
#define DISPID_MsiStorage_Streams            4
#define DISPID_MsiStorage_Storages           5
#define DISPID_MsiStorage_RemoveElement      6 
#define DISPID_MsiStorage_Commit             7
#define DISPID_MsiStorage_Rollback           8
#define DISPID_MsiStorage_DeleteOnRelease    9
#define DISPID_MsiStorage_CreateSummaryInfo 10
#define DISPID_MsiStorage_CopyTo            11
#define DISPID_MsiStorage_Name              12
#define DISPID_MsiStorage_RenameElement     13


#define DISPID_MsiServer_RunScript              4
#define DISPID_MsiServer_ProductInfo            8
#define DISPID_MsiServer_UserInfo               9
#define DISPID_MsiServer_Products              12
#define DISPID_MsiServer_InstallFinalize       14
#define DISPID_MsiServer_SetLastUsedSource     20
#define DISPID_MsiServer_DoInstall             21
#define DISPID_MsiServer_RegisterUser          22
#define DISPID_MsiServer_RemoveRunOnceEntry    23
#define DISPID_MsiServer_CleanupTempPackages   24

#define DISPID_MsiConfigurationManager_InstallFinalize     DISPID_MsiServer_InstallFinalize    
#define DISPID_MsiConfigurationManager_RunScript           DISPID_MsiServer_RunScript          
#define DISPID_MsiConfigurationManager_Products            DISPID_MsiServer_Products
#define DISPID_MsiConfigurationManager_UserInfo            DISPID_MsiServer_UserInfo           
#define DISPID_MsiConfigurationManager_SetLastUsedSource   DISPID_MsiServer_SetLastUsedSource
#define DISPID_MsiConfigurationManager_DoInstall           DISPID_MsiServer_DoInstall
#define DISPID_MsiConfigurationManager_RegisterUser        DISPID_MsiServer_RegisterUser
#define DISPID_MsiConfigurationManager_RemoveRunOnceEntry  DISPID_MsiServer_RemoveRunOnceEntry
#define DISPID_MsiConfigurationManager_CleanupTempPackages DISPID_MsiServer_CleanupTempPackages

#define DISPID_MsiConfigurationManager_Services                     27
#define DISPID_MsiConfigurationManager_OpenConfigurationDatabase    28
#define DISPID_MsiConfigurationManager_CloseConfigurationDatabase   29
#define DISPID_MsiConfigurationManager_RegisterComponent            33
#define DISPID_MsiConfigurationManager_RegisterInstallableComponent 34
#define DISPID_MsiConfigurationManager_UnregisterComponent          35
#define DISPID_MsiConfigurationManager_RegisterFolder               38
#define DISPID_MsiConfigurationManager_UnregisterFolder             39
#define DISPID_MsiConfigurationManager_IsFolderRemovable            40
#define DISPID_MsiConfigurationManager_RegisterRollbackScript       41
#define DISPID_MsiConfigurationManager_UnregisterRollbackScript     42
#define DISPID_MsiConfigurationManager_RollbackScripts              43

#define DISPID_MsiEngine_Services                   0
#define DISPID_MsiEngine_ConfigurationServer        1
#define DISPID_MsiEngine_Handler                    2
#define DISPID_MsiEngine_Database                   3
#define DISPID_MsiEngine_Property                   4
#define DISPID_MsiEngine_SelectionManager           5
#define DISPID_MsiEngine_DirectoryManager           6
#define DISPID_MsiEngine_Initialize                 7
#define DISPID_MsiEngine_Terminate                  8
#define DISPID_MsiEngine_DoAction                   9
#define DISPID_MsiEngine_Sequence                  10
#define DISPID_MsiEngine_Message                   11
#define DISPID_MsiEngine_SelectLanguage            12
#define DISPID_MsiEngine_OpenView                  13
#define DISPID_MsiEngine_ResolveFolderProperty     14
#define DISPID_MsiEngine_FormatText                15
#define DISPID_MsiEngine_EvaluateCondition         16
#define DISPID_MsiEngine_ValidateProductID         17
#define DISPID_MsiEngine_ExecuteRecord             18
#define DISPID_MsiEngine_GetMode                   19
#define DISPID_MsiEngine_SetMode                   20
#endif // __MSIDSPID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\notify.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       notify.h
//
//--------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// Notify.h -- Notify user of a problem
//
//----------------------------------------------------------------------------

#ifdef DEBUG
	#define NotifyUser(x) MessageBox(0, TEXT(x), TEXT("Notify"), 0);
#else //!DEBUG
	#define NotifyUser(x)
#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\opcodes.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       opcodes.h
//
//--------------------------------------------------------------------------

/* opcodes.h - opcode enumeration for IMsiExecute

  Used to generate ixoEnum, function declarations, and execution dispatch table.
  Must #define MSIXO(op, type, args) appropriately before #include of this file.
  It will be undefined at the end of this include.
____________________________________________________________________________*/

// operation types
#define XOT_INIT        1 // script initialization
#define XOT_FINALIZE    2 // script finalization
#define XOT_STATE       3 // sets state
#define XOT_ADVT        4 // advertisment
#define XOT_UPDATE      5 // updates system, or does nothing
#define XOT_MSG         6 // only dispatches message
#define XOT_UPDATEFIRST 7 // updates system, must be executed first in rollback
#define XOT_UPDATELAST  8 // updates system, must be executed last in rollback
#define XOT_GLOBALSTATE 9 // sets state, not to be reset by ActionStart
#define XOT_COMMIT     10 // executes from rollback script on commit, not rollback

	MSIXO(Fail,               XOT_UPDATE, MSIXA0())
	MSIXO(Noop,               XOT_UPDATE, MSIXA0())
	MSIXO(Header,             XOT_INIT,   MSIXA9(Signature,Version,Timestamp,LangId,Platform,ScriptType,ScriptMajorVersion,ScriptMinorVersion,ScriptAttributes)) // version must stay in 7th field
	MSIXO(End,                XOT_FINALIZE,MSIXA2(Checksum, ProgressTotal))      // 3  end of script
	MSIXO(ProductInfo,        XOT_GLOBALSTATE,   MSIXA13(ProductKey,ProductName,PackageName,Language,Version,Assignment,ObsoleteArg,ProductIcon,PackageMediaPath,PackageCode,AppCompatDB,AppCompatID,InstanceType))
	MSIXO(DialogInfo,         XOT_INIT,   MSIXA2(Type, Argument)) // imtCommonData messages for UI - variable length record
	MSIXO(RollbackInfo,       XOT_INIT,   MSIXA7(Reserved,RollbackAction,RollbackDescription,RollbackTemplate,CleanupAction,CleanupDescription,CleanupTemplate))
	MSIXO(InfoMessage,        XOT_MSG,    MSIXA5(Type, Arg1, Arg2, Arg3, Arg4))        // message to be returned to IMsiMessage interface
	MSIXO(ActionStart,        XOT_STATE,  MSIXA3(Name, Description, Template))   // inserted by MsiEngine::Sequence

	MSIXO(SourceListPublish,  XOT_ADVT,   MSIXA5(PatchCode, PatchPackageName, DiskPromptTemplate, PackagePath, NumberOfDisks)) // Note this is a variable record field
	MSIXO(SourceListUnpublish,XOT_ADVT,   MSIXA2(PatchCode, UpgradingProductCode))
	MSIXO(SourceListRegisterLastUsed,XOT_UPDATE,   MSIXA2(SourceProduct, LastUsedSource))

	MSIXO(ProductRegister,    XOT_UPDATE, MSIXA19(UpgradeCode,VersionString,HelpLink,HelpTelephone,InstallLocation,InstallSource,Publisher,URLInfoAbout,URLUpdateInfo,NoRemove,NoModify,NoRepair,AuthorizedCDFPrefix,Comments,Contact,Readme,Size,SystemComponent,EstimatedSize))    // product information for configmgr
	MSIXO(ProductUnregister,  XOT_UPDATE, MSIXA1(UpgradeCode))  // product information for configmgr

	MSIXO(ProductCPDisplayInfoRegister,   XOT_UPDATE, MSIXA0())
	MSIXO(ProductCPDisplayInfoUnregister, XOT_UPDATE, MSIXA0())

	MSIXO(ProductPublish,     XOT_ADVT, MSIXA1(PackageKey))	// Advertise stuff - variable-length record
	MSIXO(ProductUnpublish,   XOT_ADVT, MSIXA1(PackageKey))	// Advertise stuff - variable-length record

	MSIXO(ProductPublishClient,     XOT_ADVT, MSIXA3(Parent, ChildPackagePath, ChildDiskId))
	MSIXO(ProductUnpublishClient,   XOT_ADVT, MSIXA3(Parent, ChildPackagePath, ChildDiskId))

	MSIXO(UserRegister,       XOT_UPDATE, MSIXA3(Owner,Company,ProductId))  // user information for configmgr

	MSIXO(ComponentRegister,              XOT_UPDATE, MSIXA7(ComponentId,KeyPath,State,ProductKey,Disk,SharedDllRefCount,BinaryType))  // component info for configmgr
	MSIXO(ComponentUnregister,            XOT_UPDATE, MSIXA4(ComponentId,ProductKey,BinaryType, /* Assemblies Only*/PreviouslyPinned))// component info for configmgr

	MSIXO(ComponentPublish,               XOT_UPDATE, MSIXA5(Feature,Component,ComponentId,Qualifier,AppData)) // component factory advt
	MSIXO(ComponentUnpublish,             XOT_UPDATE, MSIXA5(Feature,Component,ComponentId,Qualifier,AppData)) // component factory unadvt

	MSIXO(ProgressTotal,      XOT_STATE,  MSIXA3(Total, Type, ByteEquivalent))
	MSIXO(SetSourceFolder,    XOT_STATE,  MSIXA1(Folder))
	MSIXO(SetTargetFolder,    XOT_STATE,  MSIXA1(Folder))
	MSIXO(ChangeMedia,        XOT_STATE,  MSIXA11(MediaVolumeLabel,MediaPrompt,MediaCabinet,BytesPerTick,CopierType,ModuleFileName,ModuleSubStorageList,SignatureRequired,SignatureCert,SignatureHash,IsFirstPhysicalMedia))
	MSIXO(SetCompanionParent, XOT_STATE,  MSIXA4(ParentPath,ParentName,ParentVersion,ParentLanguage))
	MSIXO(FileCopy,           XOT_UPDATE, MSIXA22(SourceName,SourceCabKey,DestName,Attributes,FileSize,PerTick,IsCompressed,VerifyMedia,ElevateFlags,TotalPatches,PatchHeadersStart,SecurityDescriptor,CheckCRC,Version,Language,InstallMode,HashOptions,HashPart1,HashPart2,HashPart3,HashPart4,VariableStart)) // Note this is a variable record field (multiple PatchHeaders) - PatchHeaders must be last arg
	MSIXO(FileRemove,         XOT_UPDATE, MSIXA4(Unused,FileName,Elevate,ComponentId))
	MSIXO(FileBindImage,      XOT_UPDATE, MSIXA3(File,Folders,FileAttributes))
	MSIXO(FileUndoRebootReplace, XOT_UPDATE, MSIXA3(ExistingFile,NewFile,Type))

	MSIXO(FolderCreate,       XOT_UPDATE, MSIXA3(Folder,Foreign,SecurityDescriptor)) // explicit creation
	MSIXO(FolderRemove,       XOT_UPDATE, MSIXA2(Folder,Foreign)) // explicit remove if empty
	
	MSIXO(RegOpenKey,         XOT_STATE,  MSIXA4(Root, Key, SecurityDescriptor, BinaryType))
	MSIXO(RegAddValue,        XOT_UPDATE, MSIXA3(Name, Value, Attributes)) // variable record with LFN path location + length pairs to be cnvrtd to SFN
	MSIXO(RegRemoveValue,     XOT_UPDATE, MSIXA3(Name, Value, Attributes)) // Value optional
	MSIXO(RegCreateKey,       XOT_UPDATE, MSIXA0())
	MSIXO(RegRemoveKey,       XOT_UPDATE, MSIXA0())
	MSIXO(RegSelfReg,         XOT_UPDATE, MSIXA2(File, FileID))
	MSIXO(RegSelfUnreg,       XOT_UPDATE, MSIXA2(File, FileID))

	MSIXO(RegClassInfoRegister,           XOT_UPDATE, MSIXA17(Feature,Component,FileName,ClsId,ProgId,VIProgId,Description,Context,Insertable,AppID,FileTypeMask,Icon,IconIndex,DefInprocHandler,Argument,AssemblyName,AssemblyType))
	MSIXO(RegClassInfoUnregister,         XOT_UPDATE, MSIXA17(Feature,Component,FileName,ClsId,ProgId,VIProgId,Description,Context,Insertable,AppID,FileTypeMask,Icon,IconIndex,DefInprocHandler,Argument,AssemblyName,AssemblyType))
	MSIXO(RegMIMEInfoRegister,            XOT_UPDATE, MSIXA3(ContentType,Extension,ClsId))
	MSIXO(RegMIMEInfoUnregister,          XOT_UPDATE, MSIXA3(ContentType,Extension,ClsId))
	MSIXO(RegProgIdInfoRegister,          XOT_UPDATE, MSIXA9(ProgId,ClsId,Extension,Description,Icon,IconIndex,VIProgId,VIProgIdDescription,Insertable))
	MSIXO(RegProgIdInfoUnregister,        XOT_UPDATE, MSIXA9(ProgId,ClsId,Extension,Description,Icon,IconIndex,VIProgId,VIProgIdDescription,Insertable))
	MSIXO(RegExtensionInfoRegister,       XOT_UPDATE, MSIXA9(Feature,Component,FileName,Extension,ProgId,ShellNew,ShellNewValue,ContentType,Order)) // Note this is a variable record field
	MSIXO(RegExtensionInfoUnregister,     XOT_UPDATE, MSIXA9(Feature,Component,FileName,Extension,ProgId,ShellNew,ShellNewValue,ContentType,Order)) // Note this is a variable record field

	MSIXO(ShortcutCreate,     XOT_UPDATE, MSIXA11(Name,Feature,Component,FileName,Arguments,WorkingDir,Icon,IconIndex,HotKey,ShowCmd,Description))
	MSIXO(ShortcutRemove,     XOT_UPDATE, MSIXA1(Name))

	MSIXO(IniWriteRemoveValue,XOT_UPDATE, MSIXA4(Section,Key,Value,Mode))// variable record with LFN path location + length pairs to be cnvrtd to SFN
	MSIXO(IniFilePath,        XOT_STATE,  MSIXA2(File,Folder))

	MSIXO(ResourceUpdate,     XOT_UPDATE, MSIXA4(File,Type,Id,Data))

	MSIXO(PatchApply,         XOT_UPDATE, MSIXA9(PatchName,TargetName,PatchSize,TargetSize,PerTick,IsCompressed,FileAttributes,PatchAttributes,CheckCRC))
	MSIXO(PatchRegister,      XOT_UPDATE, MSIXA4(PatchId,Unused1,Unused2,TransformList))
	MSIXO(PatchUnregister,    XOT_UPDATE, MSIXA2(PatchId,UpgradingProductCode))
	MSIXO(PatchCache,         XOT_UPDATE, MSIXA2(PatchId,PatchPath))

	MSIXO(FontRegister,       XOT_UPDATELAST, MSIXA2(Title,File))
	MSIXO(FontUnregister,     XOT_UPDATEFIRST, MSIXA2(Title,File))

	MSIXO(SummaryInfoUpdate,  XOT_UPDATE, MSIXA9(Database,LastUpdate,LastAuthor,InstallDate,SourceType,SubStorage,Revision,Subject,Comments))
	MSIXO(StreamsRemove,      XOT_UPDATE, MSIXA2(File,Streams))
	MSIXO(StreamAdd, XOT_UPDATE, MSIXA3(File, Stream, Data))


	MSIXO(FeaturePublish,     XOT_ADVT,   MSIXA4(Feature,Parent,Absent,Component)) // Note this is a variable record field
	MSIXO(FeatureUnpublish,   XOT_ADVT,   MSIXA4(Feature,Parent,Absent,Component)) // Note this is a variable record field

	MSIXO(IconCreate,         XOT_ADVT,   MSIXA2(Icon,Data))
	MSIXO(IconRemove,         XOT_ADVT,   MSIXA2(Icon,Data))

	MSIXO(TypeLibraryRegister,            XOT_UPDATE, MSIXA9(Feature,Component,FilePath,LibID,Version,Description,Language,HelpPath,BinaryType))
	MSIXO(TypeLibraryUnregister,          XOT_UPDATE, MSIXA9(Feature,Component,FilePath,LibID,Version,Description,Language,HelpPath,BinaryType))

	MSIXO(RegisterBackupFile, XOT_INIT,   MSIXA1(File))

	MSIXO(DatabaseCopy,       XOT_UPDATE, MSIXA5(DatabasePath, ProductCode, CabinetStreams, AdminDestFolder, SubStorage))
	MSIXO(DatabasePatch,      XOT_UPDATE, MSIXA2(DatabasePath, Transforms)) // note: this is a variable-length record

	MSIXO(CustomActionSchedule,XOT_UPDATE, MSIXA5(Action, ActionType, Source, Target, CustomActionData))
	MSIXO(CustomActionCommit,  XOT_COMMIT, MSIXA5(Action, ActionType, Source, Target, CustomActionData))
	MSIXO(CustomActionRollback,XOT_UPDATE, MSIXA5(Action, ActionType, Source, Target, CustomActionData))

	MSIXO(ServiceControl,     XOT_UPDATE, MSIXA5(MachineName,Name,Action,Wait,StartupArguments))
	MSIXO(ServiceInstall,     XOT_UPDATE, MSIXA12(Name,DisplayName,ImagePath,ServiceType,StartType,ErrorControl,LoadOrderGroup,Dependencies, /*Rollback Only*/ TagId,StartName,Password,Description))

	MSIXO(ODBCInstallDriver,       XOT_UPDATE, MSIXA5(DriverKey, Component, Folder, Attribute_, Value_))
	MSIXO(ODBCRemoveDriver,        XOT_UPDATE, MSIXA2(DriverKey, Component))
	MSIXO(ODBCInstallTranslator,   XOT_UPDATE, MSIXA5(TranslatorKey, Component, Folder, Attribute_, Value_))
	MSIXO(ODBCRemoveTranslator,    XOT_UPDATE, MSIXA2(TranslatorKey, Component))
	MSIXO(ODBCDataSource,          XOT_UPDATE, MSIXA5(DriverKey, Component, Registration, Attribute_, Value_))
	MSIXO(ODBCDriverManager,       XOT_UPDATE, MSIXA2(State, BinaryType))

	MSIXO(ProgressTick,       XOT_UPDATE, MSIXA0()) // eat up a progress tick in an action
	MSIXO(FullRecord,         XOT_UPDATE, MSIXA0())	// Simply to indicate we have a complete record with data in field 0

	MSIXO(UpdateEnvironmentStrings, XOT_UPDATE, MSIXA5(Name, Value, Delimiter, Action, /* 95 only.  Ignored on NT*/ AutoExecPath))

	MSIXO(ComPlusRegisterMetaOnly,    XOT_UPDATE, MSIXA3(Feature,Component,MetaDataBlob))
	MSIXO(ComPlusUnregisterMetaOnly,  XOT_UPDATE, MSIXA3(Feature,Component,MetaDataBlob))
	MSIXO(ComPlusRegister,            XOT_UPDATE, MSIXA6(AppID,AplFileName, AppDir, AppType, InstallUsers, RSN))
	MSIXO(ComPlusUnregister,          XOT_UPDATE, MSIXA6(AppID,AplFileName, AppDir, AppType, InstallUsers, RSN))
	MSIXO(ComPlusCommit,              XOT_COMMIT, MSIXA3(Feature,Component,FileName)) // args TBD
	MSIXO(ComPlusRollback,            XOT_UPDATE, MSIXA3(Feature,Component,FileName)) // args TBD

	MSIXO(RegAppIdInfoRegister,   XOT_UPDATE, MSIXA8(AppId,ClsId,RemoteServerName,LocalService,ServiceParameters,DllSurrogate,ActivateAtStorage,RunAsInteractiveUser))
	MSIXO(RegAppIdInfoUnregister, XOT_UPDATE, MSIXA8(AppId,ClsId,RemoteServerName,LocalService,ServiceParameters,DllSurrogate,ActivateAtStorage,RunAsInteractiveUser))
	
	MSIXO(PackageCodePublish,     XOT_ADVT, MSIXA1(PackageKey))

	MSIXO(RegAllocateSpace,       XOT_UPDATE, MSIXA1(Space))

	MSIXO(UpgradeCodePublish,     XOT_ADVT, MSIXA1(UpgradeCode))
	MSIXO(UpgradeCodeUnpublish,   XOT_ADVT, MSIXA1(UpgradeCode))

	MSIXO(AdvtFlagsUpdate,        XOT_UPDATE, MSIXA1(Flags))

	MSIXO(DisableRollback,        XOT_UPDATE, MSIXA0())  // disable rollback for the remainder of the script

	MSIXO(RegAddRunOnceEntry,     XOT_UPDATE, MSIXA2(Name,Command))

	MSIXO(ProductPublishUpdate,   XOT_UPDATE, MSIXA0())

	MSIXO(SecureTransformCache,   XOT_UPDATE, MSIXA3(Transform,AtSource,Data))
	MSIXO(UpdateEstimatedSize,    XOT_UPDATE, MSIXA1(EstimatedSize))  // product information for configmgr
	MSIXO(InstallProtectedFiles,  XOT_UPDATE, MSIXA1(AllowUI))

	MSIXO(InstallSFPCatalogFile,  XOT_UPDATEFIRST, MSIXA3(Name, Catalog, Dependency)) // SFP Catalogs for Millennium

	MSIXO(SourceListAppend,       XOT_ADVT,   MSIXA2(PatchCode, NumberOfMedia))  // Note this is a variable record field

	MSIXO(RegClassInfoRegister64,         XOT_UPDATE, MSIXA17(Feature,Component,FileName,ClsId,ProgId,VIProgId,Description,Context,Insertable,AppID,FileTypeMask,Icon,IconIndex,DefInprocHandler,Argument,AssemblyName,AssemblyType))
	MSIXO(RegClassInfoUnregister64,       XOT_UPDATE, MSIXA17(Feature,Component,FileName,ClsId,ProgId,VIProgId,Description,Context,Insertable,AppID,FileTypeMask,Icon,IconIndex,DefInprocHandler,Argument,AssemblyName,AssemblyType))
	MSIXO(RegMIMEInfoRegister64,          XOT_UPDATE, MSIXA3(ContentType,Extension,ClsId))
	MSIXO(RegMIMEInfoUnregister64,        XOT_UPDATE, MSIXA3(ContentType,Extension,ClsId))
	MSIXO(RegProgIdInfoRegister64,        XOT_UPDATE, MSIXA9(ProgId,ClsId,Extension,Description,Icon,IconIndex,VIProgId,VIProgIdDescription,Insertable))
	MSIXO(RegProgIdInfoUnregister64,      XOT_UPDATE, MSIXA9(ProgId,ClsId,Extension,Description,Icon,IconIndex,VIProgId,VIProgIdDescription,Insertable))
	MSIXO(RegExtensionInfoRegister64,     XOT_UPDATE, MSIXA9(Feature,Component,FileName,Extension,ProgId,ShellNew,ShellNewValue,ContentType,Order)) // Note this is a variable record field
	MSIXO(RegExtensionInfoUnregister64,   XOT_UPDATE, MSIXA9(Feature,Component,FileName,Extension,ProgId,ShellNew,ShellNewValue,ContentType,Order)) // Note this is a variable record field
	MSIXO(RegAppIdInfoRegister64, XOT_UPDATE, MSIXA8(AppId,ClsId,RemoteServerName,LocalService,ServiceParameters,DllSurrogate,ActivateAtStorage,RunAsInteractiveUser))
	MSIXO(RegAppIdInfoUnregister64, XOT_UPDATE, MSIXA8(AppId,ClsId,RemoteServerName,LocalService,ServiceParameters,DllSurrogate,ActivateAtStorage,RunAsInteractiveUser))

	MSIXO(ODBCInstallDriver64,        XOT_UPDATE, MSIXA5(DriverKey, Component, Folder, Attribute_, Value_))
	MSIXO(ODBCRemoveDriver64,         XOT_UPDATE, MSIXA2(DriverKey, Component))
	MSIXO(ODBCInstallTranslator64,    XOT_UPDATE, MSIXA5(TranslatorKey, Component, Folder, Attribute_, Value_))
	MSIXO(ODBCRemoveTranslator64,     XOT_UPDATE, MSIXA2(TranslatorKey, Component))
	MSIXO(ODBCDataSource64,           XOT_UPDATE, MSIXA5(DriverKey, Component, Registration, Attribute_, Value_))

	MSIXO(AssemblyPublish,               XOT_UPDATE, MSIXA5(Feature,Component,AssemblyType,AppCtx,AssemblyName)) // assembly advt
	MSIXO(AssemblyUnpublish,             XOT_UPDATE, MSIXA5(Feature,Component,AssemblyType,AppCtx,AssemblyName)) // assembly unadvt

	MSIXO(AssemblyCopy,    XOT_UPDATE, MSIXA17(SourceName,SourceCabKey,DestName,Attributes,FileSize,PerTick,IsCompressed,VerifyMedia,ElevateFlags,TotalPatches,PatchHeadersStart,Empty,ComponentId, IsManifest, OldAssembliesCount,OldAssembliesStart,VariableStart)) // Note this is a variable record field
	MSIXO(AssemblyPatch,   XOT_UPDATE, MSIXA10(PatchName,TargetName,PatchSize,TargetSize,PerTick,IsCompressed,FileAttributes,PatchAttributes,ComponentId,IsManifest))
	MSIXO(AssemblyMapping, XOT_UPDATE, MSIXA3(ComponentId,AssemblyName,AssemblyType)) // used only in rollback

	MSIXO(URLSourceTypeRegister,XOT_UPDATE, MSIXA2(ProductCode, SourceType))

	MSIXO(CleanupTempFiles, XOT_UPDATE, MSIXA1(TempFiles))

#undef  MSIXO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\proxy.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       proxy.h
//
//--------------------------------------------------------------------------



typedef enum {ctNone, ctMessage, ctServer, ctServerUnmarshal} CT;


				
//
// structure to hold the data for a marshalled message
// the rgRecord is of varying length
typedef struct 
	{
	long imt;
	long cbRecord;
	char rgRecord[1];
	} MarshaledMessageObj;


typedef struct
	{
	CT classtype;
	void *pClass;
	} MT; 	 //MarshalType

extern const CLSID CLSID_IMsiMessageUnmarshal;

HWND HCreateMarshalWindow(MT *mtinfo);
Bool FRegisterClass(VOID);
HRESULT HrSendMarshaledCommand(HWND hwndMarshal, HWND hwndRet, COPYDATASTRUCT *pcds);
HRESULT HrGetReturnValue(HWND m_MarshalRet, void **ppdata);

#define WM_POSTDATA		WM_USER + 1

// These are method ID's for the Marshalling code.
// An ID < 1000 means that it cannot return immediately.


// Synchronous Calls

#define PWM_MESSAGE			 1
#define PWM_INSTALLFINALIZE	 4
#define PWM_SENDPROCESSID		5
#define PWM_LOCKSERVER	10
#define PWM_IMSSENTBACK			12
#define PWM_IMSSENTBACKPOST		13
#define PWM_UNLOCKSERVER			14

#define PWM_SENDTHREADTOKEN		20
#define PWM_SENDPROCESSTOKEN		21
#define PWM_SENDTHREADTOKEN2		22
#define PWM_SENDPROCESSHANDLE		23

#define PWM_RETURNOK 100
#define PWM_RETURNIES	101
#define PWM_RETURNIESMAX	120


#define PWM_ASYNCRETURN	1000


// Normally 5000, may be changed to help with debugging
#define cticksTimeout	500000

//
// String types
//
#define stypAnsi	0
#define stypUnicode	1


#define cchDefBuffer		50
//
// Routines to help with string unbundling
// 
int CbSizeSerializeString(const IMsiString& riString);
int CbSerializeStringToBuffer(char *pch, const IMsiString& riString);
int CbSizeSerializeString(const ICHAR* riString);
int CbSerializeStringToBuffer(char *pch, const ICHAR* riString);

const IMsiString& UnserializeMsiString(char **ppch, DWORD *pcb);
IMsiRecord* UnserializeRecord(IMsiServices& riServices, char *pData);
const ICHAR *UnserializeString(char **ppch, DWORD* pcb, CTempBuffer<ICHAR, cchDefBuffer> *pTemp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\path.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       path.h
//
//--------------------------------------------------------------------------

/*  path.h - File system class definitions

IMsiVolume   - volume object, represents a disk drive or network serverabase
IMsiPath     - path object, represents a fully resolved direcory or folder
IMsiFileCopy - file copy object, for copying compressed or non-compressed files
IMsiFilePatch - file patch object, for upgrading existing files byte-wise

For documentation, use the help file.  Help source is in path.rtf
____________________________________________________________________________*/

#ifndef __PATH
#define __PATH


#define NET_ERROR(i) (i == ERROR_UNEXP_NET_ERR || i == ERROR_BAD_NETPATH || i == ERROR_NETWORK_BUSY || i == ERROR_BAD_NET_NAME || i == ERROR_VC_DISCONNECTED)
class IMsiFileCopy;

enum idtEnum  // using same values as Win32 API
{
	idtUnknown   = 0,
	idtAllDrives = 1, // Input only!
	idtRemovable = 2, // DRIVE_REMOVABLE,
	idtFloppy    = 2, // temporary until floppies and removables are distinguished
	idtFixed     = 3, // DRIVE_FIXED,
	idtRemote    = 4, // DRIVE_REMOTE,
	idtCDROM     = 5, // DRIVE_CDROM,
	idtRAMDisk   = 6, // DRIVE_RAMDISK,
	idtNextEnum,
};

enum ifaEnum
{
	ifaArchive,
	ifaDirectory,
	ifaHidden,
	ifaNormal,
	ifaReadOnly,
	ifaSystem,
	ifaTemp,
	ifaCompressed,
	ifaNextEnum,
};

enum ipcEnum
{
	ipcEqual,
	ipcChild,
	ipcParent,
	ipcNoRelation,
};

enum icfvEnum
{
	icfvNoExistingFile,
	icfvExistingLower,
	icfvExistingEqual,
	icfvExistingHigher,
	icfvVersStringError,
	icfvFileInUseError,
	icfvAccessToFileDenied,
	icfvNextEnum
};

enum icfhEnum
{
	icfhNoExistingFile,
	icfhMatch,
	icfhMismatch,
	icfhFileInUseError,
	icfhAccessDenied,
	icfhHashError,
	icfhNextEnum
};

enum iclEnum
{
	iclExistNoFile,
	iclExistNoLang,
	iclExistSubset,
	iclExistEqual,
	iclExistIntersect,
	iclExistSuperset,
	iclExistNullSet,
	iclExistLangNeutral,
	iclNewLangNeutral,
	iclExistLangSetError,
	iclNewLangSetError,
	iclLangStringError,
};

enum ictEnum
{
	ictFileCopier,
	ictFileCabinetCopier,
	ictStreamCabinetCopier,
	ictCurrentCopier,
	ictNextEnum
};

// common fields for records used by IxoFileCopy, IxoAssemblyCopy and CMsiFileCopy::CopyTo
namespace IxoFileCopyCore
{
	enum ifccEnum
	{
		SourceName = 1,
		SourceCabKey,
		DestName,
		Attributes,
		FileSize,
		PerTick,
		IsCompressed,
		VerifyMedia,
		ElevateFlags,
		TotalPatches,
		PatchHeadersStart,

		// these fields are normal file copy specific, not used for assemblies
		SecurityDescriptor,

		Last,
		Args = Last - 1,
	};
};

// common fields for records used by IxoPatchApply and IxoAssemblyPatch
namespace IxoFilePatchCore
{
	enum ifpcEnum
	{
		PatchName = 1,
		TargetName,
		PatchSize,
		TargetSize,
		PerTick,
		IsCompressed,
		FileAttributes,
		PatchAttributes,

		Last,
		Args = Last - 1,
	};
};

// filter positions for IMsiPath::FindFile fn.
enum iffFilters
{
	iffFileName = 1,
	iffMinFileVersion = 2,
	iffMaxFileVersion = 3,
	iffMinFileSize = 4,
	iffMaxFileSize = 5,
	iffMinFileDate=6,
	iffMaxFileDate=7,
	iffFileLangs=8
};

enum icpEnum
{
	icpCanPatch = 0,
	icpCannotPatch,
	icpUpToDate,
};

// Used by GetLangIDArrayFromFile and GetFileVersion
// -------------------------------------------------
enum ifiEnum
{
	ifiNoError = 0,
	ifiNoFile,
	ifiNoFileInfo,
	ifiFileInUseError,
	ifiFileInfoError,
	ifiAccessDenied,
};



const int iMsiMinClusterSize = 512;
// Enums for the rifsExistingFileState parameter of the
// GetFileInstallState function
const int ifsBitExisting = 0x0001;
enum ifsEnum
{
	ifsAbsent                  =  0, // There is no currently installed file.
	ifsExistingLowerVersion    =  1, // The currently installed file has a lower version.
	ifsExistingEqualVersion    =  3, // The currently installed file has an equal version.
	ifsExistingNewerVersion    =  5, // The currently installed file has a higher version.
	ifsExistingCorrupt         =  7, // A checksum test on the currently installed file failed.
	ifsExistingAlwaysOverwrite =  9, // An InstallMode flag specified that the currently installed
									 //  file should always be overwritten.
	ifsCompanionSyntax         = 10, // This file is a companion file - the install state needs to
									 //  determined by the state of it's companion parent.
	ifsCompanionExistsSyntax   = 11, // This file is a companion file, and an installed version exists.
	ifsExistingFileInUse       = 13, // Sharing violation prevent determination of version
	ifsAccessToFileDenied      = 15, // Installer has insufficient privileges to access file
	ifsNextEnum
};

const int ifBitNewVersioned       = 0x0001;
const int ifBitExistingVersioned  = 0x0002;
const int ifBitExistingModified   = 0x0004;
const int ifBitExistingLangSubset = 0x0008;
const int ifBitUnversionedHashMismatch = 0x0010;


// Bit definitions for file copying actions
const int icmRunFromSource              = 0x0001; // File should be run from source image (i.e. don't copy
											      //   even if icmCopyFile bit is on) - this bit will allow
								                  //   the ixoFileCopy operation to log files that are
									              //   RunFromSource, even though it won't copy them.
const int icmCompanionParent            = 0x0002; // Supplied file info is that of a companion parent
const int icmRemoveSource               = 0x0004; // delete the source file after copying (or simply move the
                                                  // file if possible)
const int icmDiagnosticsOnly            = 0x0001 << 16;	// Disables actual install/overwrite // FUTURE
const int icmOverwriteNone              = 0x0002 << 16; // Install only if no existing file is present (never overwrite)
const int icmOverwriteOlderVersions     = 0x0004 << 16;	// Overwrite older file versions
const int icmOverwriteEqualVersions     = 0x0008 << 16;	// Overwrite equal file versions
const int icmOverwriteDifferingVersions = 0x0010 << 16; // Overwrite any file with a differing version
const int icmOverwriteCorruptedFiles    = 0x0020 << 16;	// Overwrite corrupt files (i.e. checksum failure)
const int icmOverwriteAllFiles          = 0x0040 << 16;	// Overwrite all files, regardless of version
const int icmInstallMachineData         = 0x0080 << 16;	// Write (or rewrite) data to HKLM
const int icmInstallUserData            = 0x0100 << 16; // Write (or rewrite) user profile data
const int icmInstallShortcuts           = 0x0200 << 16;	// Write shortcuts, overwriting existing
const int icmOverwriteReserved1         = 0x0400 << 16;
const int icmOverwriteReserved2         = 0x0800 << 16;
const int icmOverwriteReserved3         = 0x1000 << 16;


// Bit definitions used by CopyTo file attributes field
// this set intersects with the msidbFileAttributes enum
const int ictfaReadOnly   = 0x0001;
const int ictfaHidden     = 0x0002;
const int ictfaSystem     = 0x0004;
const int ictfaFailure    = 0x0008;
const int ictfaCancel     = 0x0040;
const int ictfaIgnore     = 0x0080;
const int ictfaRestart    = 0x0100;
const int ictfaReserved1  = 0x0200;	// Not available - used for File Table attribs
const int ictfaReserved2  = 0x0400; // Not available - used for File Table attribs
const int ictfaReserved5  = 0x1000; // Not available - used for File Table attribs
const int ictfaNoncompressed = 0x2000;  // pair of File.Attribute bits that
const int ictfaCompressed    = 0x4000; //  indicate source file is unused
const int ictfaCopyACL    = 0x8000;


struct MD5Hash
{
	DWORD dwOptions;
	DWORD dwFileSize; // not part of hash but allows for check against file size before computing hash
	DWORD dwPart1;
	DWORD dwPart2;
	DWORD dwPart3;
	DWORD dwPart4;
};

class IMsiVolume : public IMsiData
{
 public:
	virtual idtEnum       __stdcall DriveType()=0;
	virtual Bool          __stdcall SupportsLFN()=0;
	virtual UINT64        __stdcall FreeSpace()=0;
	virtual UINT64        __stdcall TotalSpace()=0;
	virtual unsigned int  __stdcall ClusterSize()=0;
	virtual int           __stdcall VolumeID()=0;
	virtual const IMsiString&   __stdcall FileSystem()=0; 
	virtual const DWORD         __stdcall FileSystemFlags()=0;
	virtual const IMsiString&   __stdcall VolumeLabel()=0;
	virtual Bool          __stdcall IsUNCServer()=0;
	virtual const IMsiString&   __stdcall UNCServer()=0;
	virtual Bool          __stdcall IsURLServer()=0;
	virtual const IMsiString&   __stdcall URLServer()=0;
	virtual int           __stdcall SerialNum()=0;
	virtual const IMsiString&   __stdcall GetPath()=0;
	virtual Bool          __stdcall DiskNotInDrive()=0;

};
extern "C" const GUID IID_IMsiVolume;

// IMsiPath - directory/folder object; always references a volume object

class IMsiPath : public IMsiData
{
 public:
	virtual const IMsiString& __stdcall GetPath()=0;
	virtual const IMsiString& __stdcall GetRelativePath()=0;
	virtual IMsiVolume& __stdcall GetVolume()=0;
	virtual IMsiRecord* __stdcall SetPath(const ICHAR* szPath)=0;
	virtual IMsiRecord* __stdcall ClonePath(IMsiPath*&riPath)=0;
	virtual IMsiRecord* __stdcall SetPathToPath(IMsiPath& riPath)=0;
	virtual IMsiRecord* __stdcall AppendPiece(const IMsiString& riSubDir)=0;
	virtual IMsiRecord* __stdcall ChopPiece()=0;
	virtual IMsiRecord* __stdcall FileExists(const ICHAR* szFile, Bool& fExists, DWORD * pdwLastError = NULL)=0;
	virtual IMsiRecord* __stdcall FileCanBeOpened(const ICHAR* szFile, DWORD dwDesiredAccess, bool& fCanBeOpened)=0;
	virtual IMsiRecord* __stdcall GetFullFilePath(const ICHAR* szFile, const IMsiString*& rpiString)=0;
	virtual IMsiRecord* __stdcall GetFileAttribute(const ICHAR* szFile,ifaEnum fa, Bool& fAttrib)=0; 
	virtual IMsiRecord* __stdcall SetFileAttribute(const ICHAR* szFile,ifaEnum fa, Bool fAttrib)=0;
	virtual IMsiRecord* __stdcall Exists(Bool& fExists)=0;
	virtual IMsiRecord* __stdcall FileSize(const ICHAR* szFile, unsigned int& uiFileSize)=0;
	virtual IMsiRecord* __stdcall FileDate(const ICHAR* szFile, MsiDate& iFileDate)=0;
	virtual IMsiRecord* __stdcall RemoveFile(const ICHAR* szFile)=0;
	virtual IMsiRecord* __stdcall EnsureExists(int* pcCreatedFolders)=0;
	virtual IMsiRecord* __stdcall Remove(bool* pfRemoved)=0;
	virtual IMsiRecord* __stdcall Writable(Bool& fWritable)=0;
	virtual IMsiRecord* __stdcall FileWritable(const ICHAR *szFile, Bool& fWritable)=0;
	virtual IMsiRecord* __stdcall FileInUse(const ICHAR *szFile, Bool& fInUse)=0;
	virtual IMsiRecord* __stdcall ClusteredFileSize(unsigned int uiFileSize, unsigned int& uiClusteredSize)=0;
	virtual IMsiRecord* __stdcall GetFileVersionString(const ICHAR* szFile, const IMsiString*& rpiVersion)=0;
	virtual IMsiRecord* __stdcall CheckFileVersion(const ICHAR* szFile, const ICHAR* szVersion, const ICHAR* szLang, MD5Hash* pHash, icfvEnum& cfvResult, int* pfVersioning)=0;
	virtual IMsiRecord* __stdcall GetLangIDStringFromFile(const ICHAR* szFileName, const IMsiString*& rpiLangIds)=0;
	virtual IMsiRecord* __stdcall CheckLanguageIDs(const ICHAR* szFile, const ICHAR* szIds, iclEnum& riclResult)=0;
	virtual IMsiRecord* __stdcall CheckFileHash(const ICHAR* szFileName, MD5Hash& hHash, icfhEnum& icfhResult)=0;
	virtual IMsiRecord* __stdcall Compare(IMsiPath& riPath, ipcEnum& ipc)=0;
	virtual IMsiRecord* __stdcall Child(IMsiPath& riParent, const IMsiString*& ripChild)=0;
	virtual IMsiRecord* __stdcall TempFileName(const ICHAR* szPrefix, const ICHAR* szExtension,
															 Bool fFileNameOnly, const IMsiString*& rpiFileName, CSecurityDescription* pSecurity)=0;
	virtual IMsiRecord*	__stdcall FindFile(IMsiRecord& riFilter,int iDepth, Bool& fFound)=0;
	virtual IMsiRecord* __stdcall GetSubFolderEnumerator(IEnumMsiString*& rpaEnumStr, Bool fExcludeHidden)=0;
	virtual const IMsiString& __stdcall GetEndSubPath()=0;
	virtual IMsiRecord* __stdcall GetImportModulesEnum(const IMsiString& strFile, IEnumMsiString*& rpiEnumStr)=0;
	virtual IMsiRecord* __stdcall SetVolume(IMsiVolume& riVol)=0;
	virtual IMsiRecord* __stdcall VerifyFileChecksum(const ICHAR* szFileName, Bool& rfChecksumValid)=0;
	virtual IMsiRecord* __stdcall GetFileChecksum(const ICHAR* szFileName,DWORD* pdwHeaderSum, DWORD* pdwComputedSum)=0;
	virtual IMsiRecord* __stdcall GetFileInstallState(const IMsiString& riFileNameString,
																	  const IMsiString& riFileVersionString,
																	  const IMsiString& riFileLanguageString,
																	  MD5Hash* pHash,
																	  ifsEnum& rifsExistingFileState,
																	  Bool& fShouldInstall,
																	  unsigned int* puiExistingFileSize,
																	  Bool* fInUse,
																	  int fInstallModeFlags, 
																	  int* pfVersioning)=0;
	virtual IMsiRecord* __stdcall GetCompanionFileInstallState(const IMsiString& riParentFileNameString,
																				  const IMsiString& riParentFileVersionString,
																				  const IMsiString& riParentFileLanguageString,
																				  IMsiPath& riCompanionPath,
																				  const IMsiString& riCompanionFileNameString,
																				  MD5Hash* pCompanionHash,
																				  ifsEnum& rifsExistingFileState,
																				  Bool& fShouldInstall,
																				  unsigned int* puiExistingFileSize,
																				  Bool* fInUse,
																				  int fInstallModeFlags,
																				  int* pfVersioning)=0;
	virtual IMsiRecord* __stdcall GetAllFileAttributes(const ICHAR* szFileName, int& iAttrib)=0;
	virtual IMsiRecord* __stdcall SetAllFileAttributes(const ICHAR* szFileName, int iAttrib)=0;
	virtual IMsiRecord* __stdcall EnsureOverwrite(const ICHAR* szFile, int* piOldAttributes)=0;
	virtual IMsiRecord* __stdcall BindImage(const IMsiString& riFile, const IMsiString& riDllPath)=0;
	virtual IMsiRecord* __stdcall IsFileModified(const ICHAR* szFile, Bool& fModified)=0;
	virtual Bool        __stdcall SupportsLFN()=0;
	virtual IMsiRecord* __stdcall GetFullUNCFilePath(const ICHAR* szFileName, const IMsiString *&rpistr)=0;
	virtual IMsiRecord* __stdcall GetSelfRelativeSD(IMsiStream*& rpiSD) = 0;
	virtual bool        __stdcall IsRootPath() = 0;
	virtual IMsiRecord* __stdcall IsPE64Bit(const ICHAR* szFileName, bool &f64Bit) =0;
	virtual IMsiRecord* __stdcall CreateTempFolder(const ICHAR* szPrefix, const ICHAR* szExtension,
											  Bool fFolderNameOnly, LPSECURITY_ATTRIBUTES pSecurityAttributes,
											  const IMsiString*& rpiFolderName)=0;

};

class IEnumMsiVolume : public IUnknown
{
 public:
	virtual HRESULT __stdcall Next(unsigned long cFetch, IMsiVolume** rgpi, unsigned long* pcFetched)=0;
	virtual HRESULT __stdcall Skip(unsigned long cSkip)=0;
	virtual HRESULT __stdcall Reset()=0;
	virtual HRESULT __stdcall Clone(IEnumMsiVolume** ppiEnum)=0;
};

// Copy object definition

class IMsiFileCopy : public IUnknown
{
 public:
	virtual IMsiRecord* __stdcall CopyTo(IMsiPath& riSourcePath, IMsiPath& riDestPath, IMsiRecord& rirecCopyInfo)=0;
	virtual IMsiRecord* __stdcall CopyTo(IMsiPath& riSourcePath, IAssemblyCacheItem& riDestASM, bool fManifest, IMsiRecord& rirecCopyInfo)=0;
	virtual IMsiRecord* __stdcall ChangeMedia(IMsiPath& riMediaPath, const ICHAR* szKeyFile, Bool fSignatureRequired, IMsiStream* piSignatureCert, IMsiStream* piSignatureHash)=0;
	virtual int         __stdcall SetNotification(int cbNotification, int cbSoFar)=0;
};

// Patch object definition

class IMsiFilePatch : public IUnknown
{
 public:
	virtual IMsiRecord* __stdcall ApplyPatch(IMsiPath& riTargetPath, const ICHAR* szTargetName,
														  IMsiPath& riOutputPath, const ICHAR* szOutputName,
														  IMsiPath& riPatchPath, const ICHAR* szPatchFileName,
														  int cbPerTick)=0;

	virtual IMsiRecord* __stdcall ContinuePatch()=0;
	virtual IMsiRecord* __stdcall CancelPatch()=0;

	virtual IMsiRecord* __stdcall CanPatchFile(IMsiPath& riTargetPath, const ICHAR* szTargetFileName,
															 IMsiPath& riPatchPath, const ICHAR* szPatchFileName,
															 icpEnum& icp)=0;
};

bool FIsNetworkVolume(const ICHAR *szPath);
void        DestroyMsiVolumeList(bool fFatal);
IMsiRecord* SplitPath(const ICHAR* szInboundPath, const IMsiString** ppistrPathName, const IMsiString** ppistrFileName = 0);
ifiEnum     GetAllFileVersionInfo(const ICHAR* szFullPath, DWORD* pdwMS, DWORD* pdwLS, unsigned short rgw[], int iSize, int* piLangCount, Bool fImpersonate);
Bool        ParseVersionString(const ICHAR* szVer, DWORD& dwMS, DWORD& dwLS );
icfvEnum    CompareVersions(DWORD dwExistMS, DWORD dwExistLS, DWORD dwNewMS, DWORD dwNewLS);
const IMsiString& CreateVersionString(DWORD dwMSVer, DWORD dwLSVer);
DWORD CreateROFileMapView(HANDLE hFile, BYTE*& pbFileStart);
DWORD GetMD5HashFromFile(const ICHAR* szFileFullPath, ULONG rgHash[4], Bool fImpersonate,
								 DWORD* piMatchSize);

// Max number of languages ID values MSInstaller will extract from
// a file's version resource
const int cLangArrSize = 100;


#endif // __PATH
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\regkey.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       regkey.h
//
//--------------------------------------------------------------------------

//
// File: regkey.h
// Purpose: IMsiRegKey definitions.
//
//
// File: regkey.h
// Purpose: IMsiRegKey definitions.
//
//
// IMsiRegKey:
//
//    The IMsiRegKey interface represents a registry key.
//
//    
//      RemoveValue: Removes the value from the registry. If szValue is NULL, the default 
//                   value is removed.
//    RemoveSubTree: Removes an entire subtree, i.e. all keys and values that are children
//                   of the key. Use with caution.
//         GetValue: Retrieves the given value. If no value is specified, the default value
//                   is retrieved.
//         SetValue: Sets the given value. If no value is specified, the default value is set.
//    GetValueEnumerator: Retrieves an enumerator for the values contained within the key.
//    GetSubKeyEnumerator: Retrieves an enumerator for the subkeys beneath the key.
//    GetSelfRelativeSD: Retrieves a stream object contain a self-relative security descriptor structure
//               currently set for the registry key.
//           Exists: Tests the existence of the key
//      CreateChild: Creates an IMsiRegKey below "this" IMsiRegKey object
//           GetKey: String representation of the key.
//      ValueExists: Returns true if a value exists under the key, false otherwise
//
// 
// From services.h:
//
// IMsiServices::GetRootKey(rrkEnum erkRoot);
// This factory will create a "root" RegKey. 
//
//


#ifndef __REGKEY
#define __REGKEY

class IMsiRegKey;


class IMsiRegKey : public IUnknown {
 public:
	virtual IMsiRecord* __stdcall RemoveValue(const ICHAR* szValueName, const IMsiString* pistrValue)=0;
	virtual IMsiRecord* __stdcall RemoveSubTree(const ICHAR* szSubKey)=0;
	virtual IMsiRecord* __stdcall GetValue(const ICHAR* szValueName, const IMsiString*& rpReturn)=0;     
	virtual IMsiRecord* __stdcall SetValue(const ICHAR* szValueName, const IMsiString& ristrValue)=0;
	virtual IMsiRecord*	__stdcall GetValueEnumerator(IEnumMsiString*& rpiEnumString)=0;
	virtual IMsiRecord*	__stdcall GetSubKeyEnumerator(IEnumMsiString*& rpiEnumString)=0;
	virtual IMsiRecord*  __stdcall GetSelfRelativeSD(IMsiStream*& rpiSD)=0;
	virtual IMsiRecord*	__stdcall Exists(Bool& fExists)=0;
	virtual IMsiRecord*	__stdcall Create()=0;
	virtual IMsiRecord*	__stdcall Remove()=0;
	virtual IMsiRegKey&	__stdcall CreateChild(const ICHAR* szSubKey, IMsiStream* pSD = NULL)=0;
	virtual const IMsiString&  __stdcall GetKey()=0;
	virtual IMsiRecord*  __stdcall ValueExists(const ICHAR* szValueName, Bool& fExists)=0;
};




// enumeration for the root keys
enum rrkEnum {
	rrkClassesRoot      =(INT_PTR)HKEY_CLASSES_ROOT,
	rrkCurrentUser      =(INT_PTR)HKEY_CURRENT_USER,
	rrkLocalMachine     =(INT_PTR)HKEY_LOCAL_MACHINE,
	rrkUsers            =(INT_PTR)HKEY_USERS,
};

enum rrwEnum{
	rrwRead,
	rrwWrite
};

bool IncreaseRegistryQuota(int iIncrementKB = 0); // function to attempt to increase the registry quota on Win NT

#endif // __REGKEY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\record.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       record.h
//
//--------------------------------------------------------------------------

/* record.h - IMsiRecord object definitions

 The MSI record object is used for control, errors, logging, and database,
 as a means of transferring a heterogenous set of data.
 Record fields may contain integers, strings, null values, or
 pointers to objects derived from the common class IMsiData.
 Record objects are constructed by a method of IMsiService, CreateRecord.
 CreateRecord takes a field count from 0 to 8192 and sets all fields to Null.
 Data field indices for IMsiRecord methods are 1-based, up to the field count.
 Field 0 is always present and is reserved for the formatting string.
 Field values may be Null, a 32-bit integer, a string object, or a data pointer.
 GetInteger() will attempt to convert a string value, else will return 0.
 GetMsiString() will convert an integer value to a signed decimal string.
 GetString() will NOT convert an integer value, will return 0 for int or Null.
 GetMsiData() will return a field value without any conversion.
 Null values are returned by GetString() as an empty string.
 Null values are returned by GetInteger() as IMsiStringBadInteger (0x80000000).
 CreateRecord returns an interface reference, IMsiRecord&, a COM object.
 This is commonly assigned to a local variable, then fields are set.
 MsiString objects may be constructed directly in the SetMsiString parameter.
 When the record object is no longer needed its Release() method must be called.
 If a Set...  function field index is out of range, E_INVALIDARG is returned.
 IsChanged() is for non-integer fields, always return fTrue for integer values.
 Note: For efficiency, the methods use IMsiString& interface references rather
    than MsiString objects. However, they can be treated as if typed MsiString.
    They will be automatically converted on assignment in either direction.

 IMsiRecord Methods:
 
 GetFieldCount()    - returns the number of fields in record as constructed
 IsNull(index)      - returns a BOOL indicating if a field [index] is Null
 IsInteger(index)   - returns a BOOL, TRUE if field [index] is an integer
 IsChanged() - used by database to detect modified fields for Update record
 GetInteger(index)  - returns field [index] as an 32-bit integer
 GetMsiData(index)  - returns field [index] as IMsiData pointer, may be null
 GetMsiString(index)  - returns field [index] as MsiString object (or IMsiString&)
 GetString(index)   - returns field [index] as an const ICHAR*, 0 if int or Null
 GetTextSize(index) - returns the length of field [index] when converted to text
 SetNull(index)             - sets field [index] to Null
 SetInteger(index, value)   - sets field [index] to an 32-bit integer value
 SetMsiData(index, IMsiData*) - sets field [index] from an IMsiData pointer
 SetMsiString(index, IMsiString&) - sets field [index] from an IMsiString ref.
 SetString(index, ICHAR*)   - sets field [index] by copying an ICHAR*
 RefString(index, ICHAR*)   - sets field [index] from a static const ICHAR*
 RemoveReferences() - replaces any string references with copies (internal)
 ClearData()   - sets all fields to Null, fails if any outstanding references
 ClearUpdate() - used only by database to mark all fields as unmodified
____________________________________________________________________________*/

#ifndef __RECORD
#define __RECORD

// IMsiRecord - common record object
//    note: GetMsiString returns an interface which must be Released by caller.
//          SetMsiString accepts an interface which caller must have AddRef'd.
//          Reference counting handled automatically if MsiString objects used.
class IMsiRecord : public IUnknown {
 public:
	virtual int          __stdcall GetFieldCount()const=0;
	virtual Bool         __stdcall IsNull(unsigned int iParam)const=0;
	virtual Bool         __stdcall IsInteger(unsigned int iParam)const=0;
	virtual Bool         __stdcall IsChanged(unsigned int iParam)const=0;
	virtual int          __stdcall GetInteger(unsigned int iParam)const=0;
	virtual const IMsiData*   _stdcall GetMsiData(unsigned int iParam)const=0;
	virtual const IMsiString& _stdcall GetMsiString(unsigned int iParam)const=0;
	virtual const ICHAR* __stdcall GetString(unsigned int iParam)const=0;
	virtual int          __stdcall GetTextSize(unsigned int iParam)const=0;
	virtual Bool         __stdcall SetNull(unsigned int iParam)=0;
	virtual Bool         __stdcall SetInteger(unsigned int iParam, int iData)=0;
	virtual Bool         __stdcall SetMsiData(unsigned int iParam, const IMsiData* piData)=0;
	virtual Bool         __stdcall SetMsiString(unsigned int iParam, const IMsiString& riStr)=0;
	virtual Bool         __stdcall SetString(unsigned int iParam, const ICHAR* sz)=0;
	virtual Bool         __stdcall RefString(unsigned int iParam, const ICHAR* sz)=0;
	virtual const IMsiString& __stdcall FormatText(Bool fComments)=0;
	virtual void         __stdcall RemoveReferences()=0;
	virtual Bool         __stdcall ClearData()=0;
	virtual void         __stdcall ClearUpdate()=0;
	virtual const HANDLE	_stdcall GetHandle(unsigned int iParam) const=0;
	virtual Bool		 __stdcall SetHandle(unsigned int iParam, const HANDLE hData)=0;
};
extern "C" const GUID IID_IMsiRecord;

extern "C" const GUID IID_IEnumMsiRecord;

#define MSIRECORD_MAXFIELDS	0xffff

#endif // __RECORD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

/* resource.h - MSI.DLL resource IDs */

// The following string IDs are localized - do not change any IDs, and make new strings IDs contiguous
#define IDS_INSTALLATION_PACKAGE        1
#define IDS_TRANSFORM_PACKAGE           2
#define IDS_PATCH_PACKAGE               3
#define IDS_INVALID_SOURCE              4
#define IDS_INVALID_PATH_MESSAGE        5

#define IDS_CD_PROMPT                   9
#define IDS_INCORRECT_PARAMETERS        10 // This must be the same as IDS_HELP in server.rc
#define IDS_NET_PROMPT_BROWSE           11
#define IDS_CD_TEXT                     12
#define IDS_NET_TEXT                    13
#define IDS_USE_FEATURE_TEXT            14
#define IDS_NET_PROMPT_NO_BROWSE        15

#define IDS_BROWSE                      17
#define IDS_CANCEL                      18
#define IDS_OK                          19
#define IDS_PREPARING_TO_INSTALL        20
#define IDS_FILESINUSE                  21
#define IDS_RETRY                       22
#define IDS_IGNORE                      23
#define IDS_CONFIRM_UNINSTALL           24
#define IDS_YES                         25
#define IDS_NO                          26
#define IDS_SERVICE_DISPLAY_NAME        27
#define IDS_WINDOWS_INSTALLER_TITLE     28
#define IDS_INVALID_FILE_MESSAGE        29
#define IDS_PREPARING_TO_UNINSTALL      30
#define IDS_INITIATED_SYSTEM_RESTART    31
#define IDS_MSI_SERVICE_DESCRIPTION     32
#define IDS_CANCELING_INSTALL			33
#define IDS_SHELL_DISPLAY_NAME_PACKAGE	34
#define IDS_SHELL_DISPLAY_NAME_PATCH	35
#define IDS_SHELL_VERB_OPEN				36
#define IDS_SHELL_VERB_REPAIR			37
#define IDS_SHELL_VERB_UNINSTALL		38
#define	IDS_SHELL_VERB_APPLY			39
#define IDS_NET_PROMPT_CSOS_BROWSE      40
#define IDS_NET_PROMPT_CSOS_NO_BROWSE   41
#define IDS_NET_TEXT_CSOS               42

#define IDBROWSE  0 // private define for dialogs, never returned from message boxes

#define IDD_NETWORK                    101
#define IDD_NETWORKRTL                 102
#define IDD_FILESINUSE                 103
#define IDD_PROGRESS                   104
#define IDD_MSGBOX                     110
#define IDD_MSGBOXNOICON               111
#define IDD_NETWORKMIRRORED            112
#define IDD_FILESINUSEMIRRORED         113
#define IDD_PROGRESSMIRRORED           114
#define IDD_MSGBOXMIRRORED             115
#define IDD_MSGBOXNOICONMIRRORED       116
#define IDD_NETWORK_CSOS               117
#define IDD_NETWORKRTL_CSOS            118
#define IDD_NETWORKMIRRORED_CSOS       119

// the following are resources in user32.dll, do not duplicate IDs
#define IDI_SYS_EXCLAMATION            101
#define IDI_SYS_QUESTION               102
#define IDI_SYS_STOP                   103
#define IDI_SYS_INFORMATION            104
#define IDI_SYS_WINDOWS                105

#define IDI_NET                        201
#define IDI_CDROM                      202
#define IDI_INSTALLER                  203

#define IDC_MSGTEXT  3000
#define IDC_MSGBTN1  3001 // NOTE: These 3 must be sequential
#define IDC_MSGBTN2  3002 // IDC_MSGBTN1 + 1
#define IDC_MSGBTN3  3003 // IDC_MSGBTN2 + 1

#define IDC_EDITCOMBO                   1003
#define IDC_READONLYCOMBO               1005
#define IDC_NETICON                     1006
#define IDC_CDICON                      1007
#define IDC_ERRORTEXT                   1009
#define IDC_PROMPTTEXT                  1010
#define IDC_USE_FEATURE_TEXT            1011
#define IDC_NETPROMPT                   1012
#define IDC_FILESINUSELIST              1013

#define IDC_BASIC_CANCEL				IDCANCEL
#define IDC_BASIC_ACTIONTEXT			8
#define IDC_BASIC_PROGRESSBAR			10
#define IDC_BASIC_PROGRESSTIME			11
#define IDC_BASIC_ICON					12
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\version.h ===
#ifndef __VERSION_H__BC19E506_E09C_4c77_B7BB_0325D4EDE03D
#define __VERSION_H__BC19E506_E09C_4c77_B7BB_0325D4EDE03D

#include <ntverp.h>

#define rmj 2
#define rmm 0
#define rup VER_PRODUCTBUILD
#define rin 0
#undef VER_PRODUCTVERSION_STR2
#undef VER_PRODUCTVERSION_STR1
#undef VER_PRODUCTVERSION_STR
#define VER_PRODUCTVERSION_STR2(x,y,z,n) #x "." #y "." #z "." #n
#define VER_PRODUCTVERSION_STR1(x,y,z,n) VER_PRODUCTVERSION_STR2(x, y, z, n)
#define VER_PRODUCTVERSION_STR VER_PRODUCTVERSION_STR1(rmj, rmm, rup, rin)

#endif //__VERSION_H__BC19E506_E09C_4c77_B7BB_0325D4EDE03D
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\sysadd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       sysadd.h
//
//--------------------------------------------------------------------------

//
// Recent additions to the system headers which we don't have right now
//

//
// Power Management header info
//

//
// CSC flags (from cscapi.h)
//

// Flags returned in the status field for shares

#define FLAG_CSC_SHARE_STATUS_MODIFIED_OFFLINE          0x0001
#define FLAG_CSC_SHARE_STATUS_CONNECTED                 0x0800
#define FLAG_CSC_SHARE_STATUS_FILES_OPEN                0x0400
#define FLAG_CSC_SHARE_STATUS_FINDS_IN_PROGRESS         0x0200
#define FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP           0x8000
#define FLAG_CSC_SHARE_MERGING                          0x4000

#define FLAG_CSC_SHARE_STATUS_MANUAL_REINT              0x0000  // No automatic file by file reint  (Persistent)
#define FLAG_CSC_SHARE_STATUS_AUTO_REINT                0x0040  // File by file reint is OK         (Persistent)
#define FLAG_CSC_SHARE_STATUS_VDO                       0x0080  // no need to flow opens            (Persistent)
#define FLAG_CSC_SHARE_STATUS_NO_CACHING                0x00c0  // client should not cache this share (Persistent)

#define FLAG_CSC_SHARE_STATUS_CACHING_MASK              0x00c0  // type of caching


#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
//
// NT Status defs, macros (from ntstatus.h in NT project)
//
typedef LONG NTSTATUS;
#define STATUS_SUCCESS                   ((NTSTATUS)0x00000000L)
#define STATUS_NOT_IMPLEMENTED           ((NTSTATUS)0xC0000002L)
#define STATUS_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC000009AL)


//
// VER_SUITE flags (from winnt.h)
// 

#define VER_SERVER_NT                       0x80000000
#define VER_WORKSTATION_NT                  0x40000000
#define VER_SUITE_SMALLBUSINESS             0x00000001
#define VER_SUITE_ENTERPRISE                0x00000002
#define VER_SUITE_BACKOFFICE                0x00000004
#define VER_SUITE_COMMUNICATIONS            0x00000008
#define VER_SUITE_TERMINAL                  0x00000010
#define VER_SUITE_SMALLBUSINESS_RESTRICTED  0x00000020
#define VER_SUITE_EMBEDDEDNT                0x00000040
#define VER_SUITE_SINGLEUSERTS              0x00000100




//
// NT5 Shell Folders CSIDL values (from shlobj.h)
//

#define CSIDL_LOCAL_APPDATA             0x001c        // <user name>\Local Settings\Applicaiton Data (non roaming)
#define CSIDL_COMMON_APPDATA            0x0023        // All Users\Application Data
#define CSIDL_MYPICTURES                0x0027        // C:\Program Files\My Pictures
#define CSIDL_COMMON_TEMPLATES          0x002d        // All Users\Templates
#define CSIDL_COMMON_ADMINTOOLS         0x002f        // All Users\Start Menu\Programs\Administrative Tools
#define CSIDL_ADMINTOOLS                0x0030        // <user name>\Start Menu\Programs\Administrative Tools

//
// NT5 Cryptography defines (from wincrypt.h)
//

#define CRYPT_SILENT            0x00000040

//
// IMAGEHLP magic numbers for PE header (winnt.h)

#define IMAGE_NT_OPTIONAL_HDR32_MAGIC      0x10b
#define IMAGE_NT_OPTIONAL_HDR64_MAGIC      0x20b

//
// IGlobalInterfaceTable definitions (from SDK  objidl.h)
//
extern const CLSID CLSID_StdGlobalInterfaceTable;

#ifndef __IGlobalInterfaceTable_FWD_DEFINED__
#define __IGlobalInterfaceTable_FWD_DEFINED__
typedef interface IGlobalInterfaceTable IGlobalInterfaceTable;
#endif 	/* __IGlobalInterfaceTable_FWD_DEFINED__ */

#ifndef __IGlobalInterfaceTable_INTERFACE_DEFINED__
#define __IGlobalInterfaceTable_INTERFACE_DEFINED__

/* interface IGlobalInterfaceTable */
/* [uuid][object][local] */ 

typedef /* [unique] */ IGlobalInterfaceTable __RPC_FAR *LPGLOBALINTERFACETABLE;

EXTERN_C const IID IID_IGlobalInterfaceTable;

    
MIDL_INTERFACE("00000146-0000-0000-C000-000000000046")
IGlobalInterfaceTable : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE RegisterInterfaceInGlobal( 
        /* [in] */ IUnknown __RPC_FAR *pUnk,
        /* [in] */ REFIID riid,
        /* [out] */ DWORD __RPC_FAR *pdwCookie) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE RevokeInterfaceFromGlobal( 
        /* [in] */ DWORD dwCookie) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE GetInterfaceFromGlobal( 
        /* [in] */ DWORD dwCookie,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppv) = 0;
    
};
    
HRESULT STDMETHODCALLTYPE 
IGlobalInterfaceTable_RegisterInterfaceInGlobal_Proxy( 
    IGlobalInterfaceTable __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnk,
    /* [in] */ REFIID riid,
    /* [out] */ DWORD __RPC_FAR *pdwCookie);


void __RPC_STUB IGlobalInterfaceTable_RegisterInterfaceInGlobal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE 
IGlobalInterfaceTable_RevokeInterfaceFromGlobal_Proxy( 
    IGlobalInterfaceTable __RPC_FAR * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IGlobalInterfaceTable_RevokeInterfaceFromGlobal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGlobalInterfaceTable_GetInterfaceFromGlobal_Proxy( 
    IGlobalInterfaceTable __RPC_FAR * This,
    /* [in] */ DWORD dwCookie,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB IGlobalInterfaceTable_GetInterfaceFromGlobal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGlobalInterfaceTable_INTERFACE_DEFINED__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\script.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       script.h
//
//  Note: this is just script.cpp in header form
//--------------------------------------------------------------------------

/* CScriptGenerate implementation
____________________________________________________________________________*/

#include "common.h"
#include "version.h"
#include "engine.h"
#include "..\engine\_engine.h"


CScriptGenerate::CScriptGenerate(IMsiStream& riScriptOut, int iLangId, int iTimeStamp, istEnum istScriptType,
											isaEnum isaScriptAttributes, IMsiServices& riServices)
	: m_riScriptOut(riScriptOut)
	, m_riServices(riServices)
	, m_iProgressTotal(0)
	, m_iTimeStamp(iTimeStamp)
	, m_iLangId(iLangId)
	, m_istScriptType(istScriptType)
	, m_isaScriptAttributes(isaScriptAttributes)
	, m_ixoPrev(ixoNoop)
{
	riScriptOut.AddRef();
	riServices.AddRef();
	if (istScriptType != istRollback)
		m_piPrevRecord = &riServices.CreateRecord(cRecordParamsStored);
	else
		m_piPrevRecord = 0;
}


CScriptGenerate::~CScriptGenerate()
{
	using namespace IxoEnd;
	// Output script trailer
	PMsiRecord pRecord(&m_riServices.CreateRecord(Args));
	pRecord->SetInteger(Checksum, 0) ; //!! JDELO... what's the checksum supposed to be? JDELO: whatever we can easily compute.
	pRecord->SetInteger(ProgressTotal, m_iProgressTotal);
	WriteRecord(ixoEnd, *pRecord, true);
	if (m_piPrevRecord != 0)
	{
		m_piPrevRecord->Release();
		m_piPrevRecord = 0;
	}
	m_riScriptOut.Release();
	m_riServices.Release();
	
}

void CScriptGenerate::SetProgressTotal(int iProgressTotal)
{
	m_iProgressTotal = iProgressTotal;
}


bool CScriptGenerate::WriteRecord(ixoEnum ixoOpCode, IMsiRecord& riParams, bool fForceFlush)
{
	IMsiRecord* piRecord = m_piPrevRecord;	
	if (ixoOpCode != m_ixoPrev)
		piRecord = 0;
	bool fRet = m_riServices.FWriteScriptRecord(ixoOpCode, m_riScriptOut, riParams, piRecord, fForceFlush);
	m_ixoPrev = ixoOpCode;
	if (m_piPrevRecord)
		CopyRecordStringsToRecord(riParams, *m_piPrevRecord);
	return fRet;
}

bool CScriptGenerate::InitializeScript(WORD wTargetProcessorArchitecture)
{
	// Output script header
	using namespace IxoHeader;
	PMsiRecord pScriptHeader(&m_riServices.CreateRecord(Args));
	pScriptHeader->SetInteger(Signature, iScriptSignature);
	pScriptHeader->SetInteger(Version, rmj * 100 + rmm);  // version of MsiExecute
	pScriptHeader->SetInteger(Timestamp, m_iTimeStamp);
	pScriptHeader->SetInteger(LangId, m_iLangId);

	// Platform: low word is processor script was created on - high word is "package platform"

	DWORD dwPlatform = MAKELONG(/*low*/PROCESSOR_ARCHITECTURE_INTEL,/*high*/wTargetProcessorArchitecture);
	pScriptHeader->SetInteger(Platform,dwPlatform);

	pScriptHeader->SetInteger(ScriptType, (int)m_istScriptType);
	pScriptHeader->SetInteger(ScriptMajorVersion, iScriptCurrentMajorVersion);
	pScriptHeader->SetInteger(ScriptMinorVersion, iScriptCurrentMinorVersion);
	pScriptHeader->SetInteger(ScriptAttributes, (int)m_isaScriptAttributes);

	return WriteRecord(ixoHeader, *pScriptHeader, false);
}

void CopyRecordStringsToRecord(IMsiRecord& riRecordFrom, IMsiRecord& riRecordTo)
{
	int iParam = min(riRecordFrom.GetFieldCount(), riRecordTo.GetFieldCount());

	riRecordTo.ClearData();
	
	while (iParam >= 0)
	{
		if (!riRecordFrom.IsNull(iParam) && !riRecordFrom.IsInteger(iParam))
		{
			IMsiString* piString;

			PMsiData pData = riRecordFrom.GetMsiData(iParam);
			
			if (pData && pData->QueryInterface(IID_IMsiString, (void**)&piString) == NOERROR)
			{
				riRecordTo.SetMsiString(iParam, *piString);
				piString->Release();
			}
		}
		iParam--;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\vertrust.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       vertrust.h
//
//--------------------------------------------------------------------------

/*  vertrust.h - Authentication services

Allows digital signature verification.
____________________________________________________________________________*/
#ifndef __VERTRUST
#define __VERTRUST

#include "server.h"

bool EnableAndMapDisabledPrivileges(HANDLE hToken, DWORD &dwPrivileges);
bool DisablePrivilegesFromMap(HANDLE hToken, DWORD dwPrivileges);

bool TokenIsUniqueSystemToken(HANDLE hUserToken);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msi\legacy.cpp ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\tools.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       tools.h
//
//--------------------------------------------------------------------------

/* tools.h - Common definitions and includes for MSI tool modules
____________________________________________________________________________*/

#ifndef __TOOLS 
#define __TOOLS 

//____________________________________________________________________________
//
// GUID definitions for COM objects created by tool modules - add sequentially
//      Installer tool C++ main interfaces:   0xC10Ax
//      Installer tool C++ other interfaces:  0xC10Bx
//      Installer tool debug interfaces:      0xC10Cx
//      Installer tool type libraries:        0xC10Dx
//      Installer tool automation interfaces: 0xC10Ex
//         where 'x' is the tool number, 0 to F
//   The GUID range 0xC1010-0xC11FF is reserved for samples, tests, ext. tools.
//____________________________________________________________________________

// CLSID low words for all objects created by tool modules
const int iidMsiSampleTool       = 0xC10A0L;
const int iidMsiSampleToolDebug  = 0xC10C0L;
const int iidMsiSampleToolLib    = 0xC10D0L;
const int iidMsiSampleToolAuto   = 0xC10E0L;

const int iidMsiUtilities        = 0xC10A1L;
const int iidMsiUtilitiesLib     = 0xC10D1L;
const int iidMsiUtilitiesAuto    = 0xC10E1L;

const int iidMsiLocalize         = 0xC10A2L;
const int iidMsiLocalizeLib      = 0xC10D2L;
const int iidMsiLocalizeAuto     = 0xC10E2L;

const int iidMsiGenerate         = 0xC10A3L;
const int iidMsiGenerateLib      = 0xC10D3L;
const int iidMsiGenerateAuto     = 0xC10E3L;

const int iidMsiPatch            = 0xC10A4L;
const int iidMsiPatchLib         = 0xC10D4L;
const int iidMsiPatchAuto        = 0xC10E4L;

const int iidMsiAcmeConvert      = 0xC10A5L;
const int iidMsiAcmeConvertLib   = 0xC10D5L;
const int iidMsiAcmeConvertAuto  = 0xC10E5L;

const int iidMsiValidate         = 0xC10A6L;
const int iidMsiValidateLib      = 0xC10D6L;
const int iidMsiValidateAuto     = 0xC10E6L;

const int iidMsiSpy              = 0xC10A7L;
const int iidMsiSpyLib           = 0xC10D7L;
const int iidMsiSpyAuto          = 0xC10E7L;


// CLSID structure definitions for all tool objects
#define GUID_IID_IMsiSampleTool      MSGUID(iidMsiSampleTool)
#define GUID_IID_IMsiSampleToolLib   MSGUID(iidMsiSampleToolLib)
#define GUID_IID_IMsiSampleDebug     MSGUID(iidMsiSampleToolDebug)
#define GUID_IID_IMsiUtilities       MSGUID(iidMsiUtilities)
#define GUID_IID_IMsiUtilitiesLib    MSGUID(iidMsiUtilitiesLib)
#define GUID_IID_IMsiLocalize        MSGUID(iidMsiLocalize)
#define GUID_IID_IMsiLocalizeLib     MSGUID(iidMsiLocalizeLib)
#define GUID_IID_IMsiGenerate        MSGUID(iidMsiGenerate)
#define GUID_IID_IMsiGenerateLib     MSGUID(iidMsiGenerateLib)
#define GUID_IID_IMsiPatch           MSGUID(iidMsiPatch)
#define GUID_IID_IMsiPatchLib        MSGUID(iidMsiPatchLib)
#define GUID_IID_IMsiAcmeConvert     MSGUID(iidMsiAcmeConvert)
#define GUID_IID_IMsiAcmeConvertLib  MSGUID(iidMsiAcmeConvertLib)
#define GUID_IID_IMsiValidate        MSGUID(iidMsiValidate)
#define GUID_IID_IMsiValidateLib     MSGUID(iidMsiValidate)
#define GUID_IID_IMsiSpy             MSGUID(iidMsiSpy)
#define GUID_IID_IMsiSpyLib          MSGUID(iidMsiSpyLib)

// ProgIDs for tool objects, registered for use by CreateObject in VB
#define SZ_PROGID_IMsiSampleTool    "Msi.SampleTool"
#define SZ_PROGID_IMsiSampleDebug   "Msi.SampleDebug"
#define SZ_PROGID_IMsiUtilities     "Msi.Utilities"
#define SZ_PROGID_IMsiLocalize      "Msi.Localize"
#define SZ_PROGID_IMsiGenerate      "Msi.Generate"
#define SZ_PROGID_IMsiPatch         "Msi.Patch"
#define SZ_PROGID_IMsiAcmeConvert   "Msi.AcmeConvert"
#define SZ_PROGID_IMsiValidate      "Msi.Validate"
#define SZ_PROGID_IMsiSpy           "Msi.Spy"

// Description for tool objects, appears in registry entry
#define SZ_DESC_IMsiSampleTool      "Msi sample tool"
#define SZ_DESC_IMsiSampleDebug     "Msi sample tool debug build"
#define SZ_DESC_IMsiUtilities       "Msi utility tools"
#define SZ_DESC_IMsiLocalize        "Msi localization tools"
#define SZ_DESC_IMsiGenerate        "Msi tables from root directory"
#define SZ_DESC_IMsiPatch           "Msi patch tools"
#define SZ_DESC_IMsiAcmeConvert     "Msi tables from ACME STF/INF"
#define SZ_DESC_IMsiValidate        "Msi validation tool"
#define SZ_DESC_IMsiSpy             "Msi spy DLL"

// DLL names, used by RegMsi for registration
#define MSI_ACMECONV_NAME   "MsiAcme.dll"
#define MSI_PATCH_NAME      "MsiPat.dll"
#define MSI_LOCALIZE_NAME   "MsiLoc.dll"
#define MSI_GENERATE_NAME   "MsiGen.dll"
#define MSI_UTILITIES_NAME  "MsiUtil.dll"
#define MSI_SPY_NAME        "MsiSpy.dll"
#define MSI_SAMPTOOL_NAME   "MsiSamp.dll"
#define MSI_VALIDATE_NAME   "MsiVal.dll"

//____________________________________________________________________________
//
// Error code base definitions for tool errors - used as resource string IDs
//____________________________________________________________________________

#define imsgSampleTool  3400
#define imsgUtilities   3500
#define imsgLocalize    3600
#define imsgGenerate    3700
#define imsgPatch       3800
#define imsgAcmeConvert 3900
#define imsgValidate    4000

//____________________________________________________________________________
//
// Public tool headers will be included here when ready for integration
//____________________________________________________________________________



#endif // __TOOLS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\services.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       services.h
//
//--------------------------------------------------------------------------

/*  services.h - IMsiServices definitions

 General platform-independent operating system services, help in services.rtf

 Factories for other service objects:
   IMsiMalloc - memory allocator with diagnostics
   IMsiString - string allocation and management
   IMsiRecord - variable length data container, also used for errors
   IMsiVolume - local or remote drives, UNC and drive letter paths
   IMsiPath   - directory and file management
   IMsiRegKey - registry management
   IMsiDatabase - database management, including IMsiView, IMsiTable, IMsiCursor
   IMsiStorage - OLE structured storage file, including IMsiStream

 Other services:
   Property management, platform property initialization
   Condition evaluator, expressions containing properties and values
   Text formatting using record data and formatting template
   INI file management
   Log file management
   Miscellaneous services: language handling, modules in use, ...
____________________________________________________________________________*/

#ifndef __SERVICES
#define __SERVICES
#include "path.h"
#include "database.h"
#include "regkey.h"

// Max number of record params we'll save for optimizations
const int cRecordParamsStored = 10;

void       CopyRecordStringsToRecord(IMsiRecord& riRecordFrom, IMsiRecord& riRecordTo);
IUnknown*  CreateCOMInterface(const CLSID& clsId);
Bool GetShortcutTarget(const  ICHAR* szShortcutTarget,
									   ICHAR* szProductCode,
									   ICHAR* szFeatureId,
									   ICHAR* szComponentCode);


enum iifIniMode
{
	iifIniAddLine      = msidbIniFileActionAddLine,
	iifIniCreateLine   = msidbIniFileActionCreateLine,
	iifIniRemoveLine   = msidbIniFileActionRemoveLine,
	iifIniAddTag       = msidbIniFileActionAddTag,
	iifIniRemoveTag    = msidbIniFileActionRemoveTag,
};

#ifdef WIN
// CreateShortcut record definition
enum icsInfo
{
	icsArguments=1,
	icsDescription,
	icsHotKey,
	icsIconID,
	icsIconFullPath,
	icsShowCmd,
	icsWorkingDirectory,
	icsEnumNext,
	icsEnumCount = icsEnumNext-1
};

#endif

// enumerator class for IMsiRecord
class IEnumMsiRecord : public IUnknown
{ 
public:
	virtual HRESULT __stdcall Next(unsigned long cFetch, IMsiRecord** rgpi, unsigned long* pcFetched)=0;
	virtual HRESULT __stdcall Skip(unsigned long cSkip)=0;
	virtual HRESULT __stdcall Reset()=0;
	virtual HRESULT __stdcall Clone(IEnumMsiRecord** ppiEnum)=0;
};

// return value from IMsiServices::SupportLanguageId(int iLangId)
enum isliEnum 
{
	isliNotSupported      = 0, // system configuration doesn't support the language Id
	isliLanguageMismatch  = 1, // base language differs from current user language Id
	isliDialectMismatch   = 2, // base language matches, but dialect mismatched
	isliLanguageOnlyMatch = 3, // base language matches, no dialect supplied
	isliExactMatch        = 4, // exact match, both language and dialect
};

// architecture simulation enum used in SetPlatformProperties
enum isppEnum
{
	isppDefault = 0, // use current platform
	isppX86     = 1, // use X86 architecture
	isppIA64    = 2, // use IA64 architecture
	isppAMD64   = 3, // use AMD64 architecture
};

// IMsiServices - common platform service layer

class IMsiServices : public IUnknown
{
 public:
	virtual Bool            __stdcall CheckMsiVersion(unsigned int iVersion)=0; // Major*100+minor
	virtual IMsiMalloc&     __stdcall GetAllocator()=0;
	virtual const IMsiString& __stdcall GetNullString()=0;
	virtual IMsiRecord&     __stdcall CreateRecord(unsigned int cParam)=0;

	virtual Bool            __stdcall SetPlatformProperties(IMsiTable& riTable, Bool fAllUsers, isppEnum isppArchitecture, IMsiTable* piFolderCacheTable)=0;

	virtual Bool            __stdcall CreateLog(const ICHAR* szFile, Bool fAppend)=0;
	virtual Bool            __stdcall WriteLog(const ICHAR* szText)=0;
	virtual Bool            __stdcall LoggingEnabled()=0;

	virtual IMsiRecord*     __stdcall CreateDatabase(const ICHAR* szDataBase,idoEnum idoOpenMode, IMsiDatabase*& rpi)=0;
	virtual IMsiRecord*     __stdcall CreateDatabaseFromStorage(IMsiStorage& riStorage,
																	 Bool fReadOnly, IMsiDatabase*& rpi)=0;
	virtual IMsiRecord*     __stdcall CreatePath(const ICHAR* astrPath, IMsiPath*& rpi)=0;
	virtual IMsiRecord*     __stdcall CreateVolume(const ICHAR* astrPath, IMsiVolume*& rpi)=0;
	virtual Bool            __stdcall CreateVolumeFromLabel(const ICHAR* szLabel, idtEnum idtVolType, IMsiVolume*& rpi)=0;
	virtual IMsiRecord*     __stdcall CreateCopier(ictEnum ictCopierType,  IMsiStorage* piStorage, IMsiFileCopy*& racopy)=0;
	virtual IMsiRecord*     __stdcall CreatePatcher(IMsiFilePatch*& rapatch)=0;
	virtual void            __stdcall ClearAllCaches()=0;
	virtual IEnumMsiVolume& __stdcall EnumDriveType(idtEnum)=0;
	virtual IMsiRecord*		__stdcall GetModuleUsage(const IMsiString& strFile, IEnumMsiRecord*& rpaEnumRecord)=0;
	virtual const IMsiString&     __stdcall GetLocalPath(const ICHAR* szFile)=0;
	virtual IMsiRegKey&     __stdcall GetRootKey(rrkEnum erkRoot, const ibtBinaryType iType)=0;

    virtual IMsiRecord*     __stdcall RegisterFont(const ICHAR* szFontTitle, const ICHAR* szFontFile, IMsiPath* piPath, bool fInUse)=0;
	virtual IMsiRecord*     __stdcall UnRegisterFont(const ICHAR* pFontTitle)=0;
	virtual IMsiRecord*     __stdcall WriteIniFile(IMsiPath* pPath,const ICHAR* pFile,const ICHAR* pSection,const ICHAR* pKey,const ICHAR* pValue, iifIniMode iifMode)=0;
	virtual IMsiRecord*     __stdcall ReadIniFile(IMsiPath* pPath,const ICHAR* pFile,const ICHAR* pSection,const ICHAR* pKey, unsigned int iField, const IMsiString*& pMsiValue)=0;
	virtual int             __stdcall GetLangNamesFromLangIDString(const ICHAR* szLangIDs, IMsiRecord& riLangRec, int iFieldStart)=0;
	virtual IMsiRecord*     __stdcall CreateStorage(const ICHAR* szPath, ismEnum ismOpenMode,
																		IMsiStorage*& rpiStorage)=0;
	virtual IMsiRecord*     __stdcall CreateStorageFromMemory(const char* pchMem, unsigned int iSize,
																		IMsiStorage*& rpiStorage)=0;
	virtual IMsiRecord*     __stdcall GetUnhandledError()=0;
	virtual isliEnum        __stdcall SupportLanguageId(int iLangId, Bool fSystem)=0;
	virtual IMsiRecord*     __stdcall CreateShortcut(IMsiPath& riShortcutPath, const IMsiString& riShortcutName,
														IMsiPath* piTargetPath, const ICHAR* pchTargetName,
														IMsiRecord* piShortcutInfoRec,
														LPSECURITY_ATTRIBUTES pSecurityAttributes)=0;
	virtual IMsiRecord*     __stdcall RemoveShortcut(IMsiPath& riShortcutPath,const IMsiString& riShortcutName,
														IMsiPath* piTargetPath, const ICHAR* pchTargetName)=0; 
	virtual char*           __stdcall AllocateMemoryStream(unsigned int cbSize, IMsiStream*& rpiStream)=0;
	virtual IMsiStream*     __stdcall CreateStreamOnMemory(const char* pbReadOnly, unsigned int cbSize)=0;
	virtual IMsiRecord*     __stdcall CreateFileStream(const ICHAR* szFile, Bool fWrite, IMsiStream*& rpiStream)=0;
	virtual IMsiRecord*     __stdcall ExtractFileName(const ICHAR* szFileName, Bool fLFN, const IMsiString*& rpistrExtractedFileName)=0;
	virtual IMsiRecord*     __stdcall ValidateFileName(const ICHAR *szFileName, Bool fLFN)=0;
	virtual IMsiRecord*     __stdcall RegisterTypeLibrary(const ICHAR* szLibID, LCID lcidLocale, const ICHAR* szTypeLib, const ICHAR* szHelpPath, ibtBinaryType iType)=0;
	virtual IMsiRecord*     __stdcall UnregisterTypeLibrary(const ICHAR* szLibID, LCID lcidLocale, const ICHAR* szTypeLib, ibtBinaryType iType)=0;
	virtual IMsiRecord*     __stdcall GetShellFolderPath(int iFolder, const ICHAR* szRegValue,
																		  const IMsiString*& rpistrPath, bool bAvoidFolderCreation = false)=0;
	virtual const IMsiString& __stdcall GetUserProfilePath()=0;
	virtual IMsiRecord*     __stdcall CreateFilePath(const ICHAR* astrPath, IMsiPath*& rpi, const IMsiString*& rpistrFileName)=0;
	virtual bool 			__stdcall FWriteScriptRecord(ixoEnum ixoOpCode, IMsiStream& riStream, IMsiRecord& riRecord, IMsiRecord* piPrevRecord, bool fForceFlush)=0;
	virtual	IMsiRecord* 	__stdcall ReadScriptRecord(IMsiStream& riStream, IMsiRecord*& rpiPrevRecord, int iScriptVersion)=0;
	virtual void			__stdcall SetSecurityID(HANDLE hPipe)=0;
	virtual IMsiRecord* __stdcall GetShellFolderPath(int iFolder, bool fAllUsers, const IMsiString*& rpistrPath, bool bAvoidFolderCreation = false)=0;
	virtual void            __stdcall SetNoPowerdown()=0;
	virtual void            __stdcall ClearNoPowerdown()=0;
	virtual Bool            __stdcall FTestNoPowerdown()=0;
	virtual	IMsiRecord* 	__stdcall ReadScriptRecordMsg(IMsiStream& riStream)=0;
	virtual bool 			__stdcall FWriteScriptRecordMsg(ixoEnum ixoOpCode, IMsiStream& riStream, IMsiRecord& riRecord)=0;
	virtual void            __stdcall SetNoOSInterruptions()=0;
	virtual void            __stdcall ClearNoOSInterruptions()=0;

};

#endif // __SERVICES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\tables.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 2000
//
//  File:       tables.h
//
//--------------------------------------------------------------------------

/* tables.h   Table and column name definitions
____________________________________________________________________________*/


#ifndef __TABLES
#define __TABLES


// table definitions are of the form:		sztbl[Table name]
// column definitions are of the form:    sztbl[Table name]_col[Column name]

const ICHAR sztblBinary[]                          = TEXT("Binary");

const ICHAR sztblBindImage[]                       = TEXT("BindImage");

const ICHAR sztblClass[]                           = TEXT("Class");

const ICHAR sztblComponent[]                       = TEXT("Component");
const ICHAR sztblComponent_colComponent[]          = TEXT("Component");
const ICHAR sztblComponent_colComponentParent[]    = TEXT("Component_Parent");
const ICHAR sztblComponent_colDirectory[]          = TEXT("Directory_");
const ICHAR sztblComponent_colAttributes[]         = TEXT("Attributes");
const ICHAR sztblComponent_colInstalled[]          = TEXT("Installed");
const ICHAR sztblComponent_colDisabled[]           = TEXT("Disabled");
const ICHAR sztblComponent_colAction[]             = TEXT("Action");
const ICHAR sztblComponent_colActionRequest[]      = TEXT("ActionRequest");
const ICHAR sztblComponent_colCondition[]          = TEXT("Condition");
const ICHAR sztblComponent_colLocalCost[]          = TEXT("LocalCost");
const ICHAR sztblComponent_colNoRbLocalCost[]      = TEXT("NoRbLocalCost");
const ICHAR sztblComponent_colSourceCost[]         = TEXT("SourceCost");
const ICHAR sztblComponent_colRemoveCost[]         = TEXT("RemoveCost");
const ICHAR sztblComponent_colNoRbRemoveCost[]     = TEXT("NoRbRemoveCost");
const ICHAR sztblComponent_colNoRbSourceCost[]     = TEXT("NoRbSourceCost");
const ICHAR sztblComponent_colARPLocalCost[]       = TEXT("ARPLocalCost");
const ICHAR sztblComponent_colNoRbARPLocalCost[]   = TEXT("NoRbARPLocalCost");
const ICHAR sztblComponent_colRuntimeFlags[]       = TEXT("RuntimeFlags");
const ICHAR sztblComponent_colComponentId[]        = TEXT("ComponentId");
const ICHAR sztblComponent_colKeyPath[]            = TEXT("KeyPath");
const ICHAR sztblComponent_colForceLocalFiles[]    = TEXT("ForceLocalFiles");
const ICHAR sztblComponent_colLegacyFileExisted[]  = TEXT("LegacyFileExisted");
const ICHAR sztblComponent_colTrueInstallSt[]      = TEXT("TrueInstallSt");
const ICHAR sztblComponent_colBinaryType[]         = TEXT("BinaryType");

const ICHAR sztblCondition[]                       = TEXT("Condition");
const ICHAR sztblCondition_colFeature[]            = TEXT("Feature_");
const ICHAR sztblCondition_colLevel[]              = TEXT("Level");
const ICHAR sztblCondition_colCondition[]          = TEXT("Condition");

const ICHAR sztblControl[]                         = TEXT("Control");
const ICHAR sztblControl_colType[]                 = TEXT("Type");
const ICHAR sztblControl_colAttributes[]           = TEXT("Attributes");
const ICHAR sztblControl_colProperty[]             = TEXT("Property");
const ICHAR sztblControl_colText[]                 = TEXT("Text");

const ICHAR sztblCostAdjuster[]                    = TEXT("CostAdjuster");

const ICHAR sztblCostLink[]                        = TEXT("CostLink");
const ICHAR sztblCostLink_colComponent[]           = TEXT("Component_");
const ICHAR sztblCostLink_colRecostComponent[]     = TEXT("RecostComponent");

const ICHAR sztblCustomAction[]                    = TEXT("CustomAction");
const ICHAR sztblCustomAction_colType[]            = TEXT("Type");
const ICHAR sztblCustomAction_colTarget[]          = TEXT("Target");

const ICHAR sztblDigitalSignature[]                = TEXT("MsiDigitalSignature");
const ICHAR sztblDigitalSignature_colTable[]       = TEXT("Table");
const ICHAR sztblDigitalSignature_colObject[]      = TEXT("SignObject");
const ICHAR sztblDigitalSignature_colCertificate[] = TEXT("DigitalCertificate_");
const ICHAR sztblDigitalSignature_colHash[]        = TEXT("Hash");

const ICHAR sztblDigitalCertificate[]               = TEXT("MsiDigitalCertificate");
const ICHAR sztblDigitalCertificate_colCertificate[]= TEXT("DigitalCertificate");
const ICHAR sztblDigitalCertificate_colData[]       = TEXT("CertData");

const ICHAR sztblDirectory[]                       = TEXT("Directory");
const ICHAR sztblDirectory_colDirectory[]          = TEXT("Directory");
const ICHAR sztblDirectory_colDirectoryParent[]    = TEXT("Directory_Parent");
const ICHAR sztblDirectory_colDefaultDir[]         = TEXT("DefaultDir");

const ICHAR sztblDuplicateFile[]                   = TEXT("DuplicateFile");

const ICHAR sztblEngineTempCosts[]                 = TEXT("EngineTempCosts");
const ICHAR sztblEngineTempCosts_colVolume[]       = TEXT("Volume");
const ICHAR sztblEngineTempCosts_colTempCost[]     = TEXT("TempCost");

const ICHAR sztblError[]                           = TEXT("Error");

const ICHAR sztblExtension[]                       = TEXT("Extension");

const ICHAR sztblFeature[]                         = TEXT("Feature");
const ICHAR sztblFeature_colFeature[]              = TEXT("Feature");
const ICHAR sztblFeature_colFeatureParent[]        = TEXT("Feature_Parent");
const ICHAR sztblFeature_colAuthoredLevel[]        = TEXT("Level");
const ICHAR sztblFeature_colLevel[]                = TEXT("RuntimeLevel");
const ICHAR sztblFeature_colHandle[]               = TEXT("Handle");
const ICHAR sztblFeature_colSelect[]               = TEXT("Select");
const ICHAR sztblFeature_colAction[]               = TEXT("Action");
const ICHAR sztblFeature_colActionRequested[]      = TEXT("ActionRequested");
const ICHAR sztblFeature_colInstalled[]            = TEXT("Installed");
const ICHAR sztblFeature_colAuthoredAttributes[]   = TEXT("Attributes");
const ICHAR sztblFeature_colAttributes[]           = TEXT("RuntimeAttributes");
const ICHAR sztblFeature_colDirectory[]            = TEXT("Directory_");
const ICHAR sztblFeature_colTitle[]                = TEXT("Title");
const ICHAR sztblFeature_colDescription[]          = TEXT("Description");
const ICHAR sztblFeature_colDefaultSelect[]        = TEXT("DefaultSelect");
const ICHAR sztblFeature_colRuntimeFlags[]         = TEXT("RuntimeFlags");
const ICHAR sztblFeature_colDisplay[]              = TEXT("Display");

const ICHAR sztblFeatureComponents[]                 = TEXT("FeatureComponents");
const ICHAR sztblFeatureComponents_colFeature[]      = TEXT("Feature_");
const ICHAR sztblFeatureComponents_colComponent[]    = TEXT("Component_");
const ICHAR sztblFeatureComponents_colRuntimeFlags[] = TEXT("RuntimeFlags");

const ICHAR sztblFeatureCostLink[]                 = TEXT("FeatureCostLink");
const ICHAR sztblFeatureCostLink_colFeature[]      = TEXT("Feature_");
const ICHAR sztblFeatureCostLink_colComponent[]    = TEXT("Component_");

const ICHAR sztblFile[]                            = TEXT("File");
const ICHAR sztblFile_colFile[]                    = TEXT("File");
const ICHAR sztblFile_colFileName[]                = TEXT("FileName");
const ICHAR sztblFile_colComponent[]               = TEXT("Component_");
const ICHAR sztblFile_colAttributes[]              = TEXT("Attributes");
const ICHAR sztblFile_colSequence[]                = TEXT("Sequence");

const ICHAR sztblFileAction[]                      = TEXT("FileAction");
const ICHAR sztblFileAction_colFileName[]          = TEXT("FileName");
const ICHAR sztblFileAction_colDirectory[]         = TEXT("Directory_");
const ICHAR sztblFileAction_colInstalled[]         = TEXT("Installed");
const ICHAR sztblFileAction_colAction[]            = TEXT("Action");
const ICHAR sztblFileAction_colFile[]              = TEXT("File");
const ICHAR sztblFileAction_colState[]             = TEXT("State");
const ICHAR sztblFileAction_colFileSize[]          = TEXT("FileSize");
const ICHAR sztblFileAction_colComponentId[]       = TEXT("ComponentId");
const ICHAR sztblFileAction_colComponent[]         = TEXT("Component_");

const ICHAR sztblFileHash[]                        = TEXT("MsiFileHash");
const ICHAR sztblFileHash_colFile[]                = TEXT("File_");
const ICHAR sztblFileHash_colOptions[]             = TEXT("Options");
const ICHAR sztblFileHash_colPart1[]               = TEXT("HashPart1");
const ICHAR sztblFileHash_colPart2[]               = TEXT("HashPart2");
const ICHAR sztblFileHash_colPart3[]               = TEXT("HashPart3");
const ICHAR sztblFileHash_colPart4[]               = TEXT("HashPart4");

const ICHAR sztblFilesInUse[]                      = TEXT("FilesInUse");
const ICHAR sztblFilesInUse_colFileName[]          = TEXT("FileName");
const ICHAR sztblFilesInUse_colFilePath[]          = TEXT("FilePath");
const ICHAR sztblFilesInUse_colProcessID[]         = TEXT("ProcessID");
const ICHAR sztblFilesInUse_colWindowTitle[]       = TEXT("WindowTitle");

const ICHAR sztblFileSFPCatalog[]                  = TEXT("FileSFPCatalog");

const ICHAR sztblFolderCache[]                     = TEXT("#_FolderCache");
const ICHAR sztblFolderCache_colFolderId[]         = TEXT("FolderId");
const ICHAR sztblFolderCache_colFolderPath[]       = TEXT("FolderPath");

const ICHAR sztblFont[]                            = TEXT("Font");
const ICHAR sztblFont_colFile[]                    = TEXT("File_");

const ICHAR sztblIniFile[]                         = TEXT("IniFile");

const ICHAR sztblMedia[]                           = TEXT("Media");
const ICHAR sztblMedia_colDiskID[]                 = TEXT("DiskId");
const ICHAR sztblMedia_colLastSequence[]           = TEXT("LastSequence");
const ICHAR sztblMedia_colSource[]                 = TEXT("Source");
const ICHAR sztblMedia_colOldSource[]              = TEXT("_MSIOldSource");

const ICHAR sztblMIME[]                            = TEXT("MIME");

const ICHAR sztblMoveFile[]                        = TEXT("MoveFile");

const ICHAR sztblMsiAssembly[]                     = TEXT("MsiAssembly");

const ICHAR sztblPatch[]                           = TEXT("Patch");
const ICHAR sztblPatch_colFile[]                   = TEXT("File_");
const ICHAR sztblPatch_colSequence[]               = TEXT("Sequence");
const ICHAR sztblPatch_colAttributes[]             = TEXT("Attributes");
const ICHAR sztblPatch_colStreamRef[]              = TEXT("StreamRef_");

const ICHAR sztblPatchPackage[]                    = TEXT("PatchPackage");
const ICHAR sztblPatchPackage_colPatchId[]         = TEXT("PatchId");
const ICHAR sztblPatchPackage_colMedia[]           = TEXT("Media_");

const ICHAR sztblPatchCache[]                      = TEXT("#_PatchCache");
const ICHAR sztblPatchCache_colPatchId[]           = TEXT("PatchId");
const ICHAR sztblPatchCache_colPackageName[]       = TEXT("PackageName");
const ICHAR sztblPatchCache_colSourceList[]        = TEXT("SourceList");
const ICHAR sztblPatchCache_colTransformList[]     = TEXT("TransformList");
const ICHAR sztblPatchCache_colTempCopy[]          = TEXT("TempCopy");
const ICHAR sztblPatchCache_colSourcePath[]        = TEXT("SourcePath");
const ICHAR sztblPatchCache_colExisting[]          = TEXT("Existing");
const ICHAR sztblPatchCache_colUnregister[]        = TEXT("Unregister");
const ICHAR sztblPatchCache_colSequence[]          = TEXT("Sequence");

const ICHAR sztblProgId[]                          = TEXT("ProgId");

const ICHAR sztblProperty[]                        = TEXT("Property");
const ICHAR sztblPropertyLocal[]                   = TEXT("_Property");

const ICHAR sztblPublishComponent[]                = TEXT("PublishComponent");

const ICHAR sztblRegistry[]                        = TEXT("Registry");

const ICHAR sztblRegistryAction[]                  = TEXT("RegAction");
const ICHAR sztblRegistryAction_colRoot[]          = TEXT("Root");
const ICHAR sztblRegistryAction_colKey[]           = TEXT("Key");
const ICHAR sztblRegistryAction_colName[]          = TEXT("Name");
const ICHAR sztblRegistryAction_colValue[]         = TEXT("Value");
const ICHAR sztblRegistryAction_colRegistry[]      = TEXT("Registry");
const ICHAR sztblRegistryAction_colAction[]        = TEXT("Action");
const ICHAR sztblRegistryAction_colActionRequest[] = TEXT("ActionRequest");
const ICHAR sztblRegistryAction_colComponent[]     = TEXT("Component_");

const ICHAR sztblRemoveFile[]                      = TEXT("RemoveFile");
const ICHAR sztblRemoveFile_colFileName[]          = TEXT("FileName");
const ICHAR sztblRemoveFile_colPath[]              = TEXT("_Path");

const ICHAR sztblRemoveFilePath[]                  = TEXT("_RemoveFilePath");
const ICHAR sztblRemoveFilePath_colPath[]          = TEXT("Path");
const ICHAR sztblRemoveFilePath_colComponent[]     = TEXT("_Component");
const ICHAR sztblRemoveFilePath_colRemoveMode[]    = TEXT("RemoveMode");

const ICHAR sztblReserveCost[]                     = TEXT("ReserveCost");

const ICHAR sztblSelfReg[]                         = TEXT("SelfReg");

const ICHAR sztblSFPCatalog[]                      = TEXT("SFPCatalog");

const ICHAR sztblShortcut[]                        = TEXT("Shortcut");

const ICHAR sztblTransformView[]                   = TEXT("_TransformView");
const ICHAR sztblTransformViewPatch[]              = TEXT("_MsiPatchTransformView");
const ICHAR sztblTransformView_colTable[]          = TEXT("Table");
const ICHAR sztblTransformView_colColumn[]         = TEXT("Column");
const ICHAR sztblTransformView_colRow[]            = TEXT("Row");
const ICHAR sztblTransformView_colData[]           = TEXT("Data");
const ICHAR sztblTransformView_colCurrent[]        = TEXT("Current");

const ICHAR sztblValidation[]                      = TEXT("_Validation");
const ICHAR sztblValidation_colTable[]             = TEXT("Table");
const ICHAR sztblValidation_colColumn[]            = TEXT("Column");
const ICHAR sztblValidation_colNullable[]          = TEXT("Nullable");
const ICHAR sztblValidation_colMinValue[]          = TEXT("MinValue");
const ICHAR sztblValidation_colMaxValue[]          = TEXT("MaxValue");
const ICHAR sztblValidation_colKeyTable[]          = TEXT("KeyTable");
const ICHAR sztblValidation_colKeyColumn[]         = TEXT("KeyColumn");
const ICHAR sztblValidation_colCategory[]          = TEXT("Category");
const ICHAR sztblValidation_colSet[]               = TEXT("Set");

const ICHAR sztblVerb[]                            = TEXT("Verb");

const ICHAR sztblVolumeCost[]                      = TEXT("VolumeCost");
const ICHAR sztblVolumeCost_colVolumeObject[]      = TEXT("VolumeObject");
const ICHAR sztblVolumeCost_colVolumeCost[]        = TEXT("VolumeCost");
const ICHAR sztblVolumeCost_colNoRbVolumeCost[]    = TEXT("NoRbVolumeCost");
const ICHAR sztblVolumeCost_colVolumeARPCost[]     = TEXT("VolumeARPCost");
const ICHAR sztblVolumeCost_colNoRbVolumeARPCost[] = TEXT("NoRbVolumeARPCost");

#endif // __TABLES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\_assert.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       _assert.h
//
//--------------------------------------------------------------------------

/* assert.h - Assert macros and handlers

---Usage---
Assert(expr) - triggers and logs if expression is false (0), no-op if non-debug
AssertSz(expr, sz) -  same as Assert(expr), but appends text in sz to message
AssertZero(stmt) - executes statement, triggers and logs if result is non-zero
AssertNonZero(stmt) - executes statement, triggers and logs if result is zero
AssertRecord(stmt) - executes stmt, if returned IMsiRecord* pointer is non-zero,
                     formats the record, triggers assert, and logs the data
---Notes---
In one source file per module, this file must be included after the directive:
#define ASSERT_HANDLING, in order to instantiate the handlers and variables.
Assert handling must be initialized with an IMsiServices pointer by calling
InitializeAssert in order for asserts to be logged. If IGNORE is pressed in
the MessageBox, futher messages will be suppressed, but will still be logged.
Messages may also be turned off by setting the environment variable ASSERTS
to a value starting with "N", or by calling IMsiDebug::SetAssertFlag(Bool).
____________________________________________________________________________*/

#ifndef __ASSERT
#define __ASSERT

#undef  MB_SERVICE_NOTIFICATION  // otools header has wrong value
#define MB_SERVICE_NOTIFICATION     0x00200000L  // correct in VC4.2 winuser.h

#ifdef DEBUG

#define Assert(f)        ((f)    ? (void)0 : (void)FailAssert(TEXT(__FILE__), __LINE__))

#define AssertSz(f, sz)  ((f)    ? (void)0 : (void)FailAssertSz(TEXT(__FILE__), __LINE__, sz))
#define AssertNonZero(f) ((f)!=0 ? (void)0 : (void)FailAssert(TEXT(__FILE__), __LINE__))
#define AssertZero(f)    ((f)!=0 ? (void)FailAssert(TEXT(__FILE__), __LINE__) : (void)0)
#define AssertRecord(r)  ((r)!=0 ? (void)FailAssertRecord(TEXT(__FILE__),__LINE__, *r, true) : (void)0);
#define AssertRecordNR(r)  ((r)!=0 ? (void)FailAssertRecord(TEXT(__FILE__),__LINE__, *r, false) : (void)0);

class IMsiServices;
extern IMsiServices* g_AssertServices;
extern Bool g_fNoAsserts;
extern scEnum g_scServerContext;

void InitializeAssert(IMsiServices* piServices);
void FailAssert(const ICHAR* szFile, int iLine);
void FailAssertMsg(const ICHAR* szMessage);
void FailAssertRecord(const ICHAR* szFile, int iLine, IMsiRecord& riError, bool fRelease);
void FailAssertSz(const ICHAR* szFile, int iLine, const ICHAR *szMsg);
void LogAssertMsg(const ICHAR* szMessage);

#ifdef UNICODE
// UNICODE build with ANSI debug messages, instead of ICHARs.
void FailAssertSz(const ICHAR* szFile, int iLine, const char *szMsg);
void FailAssertMsg(const char* szMessage);
#endif

#else // SHIP

#define InitializeAssert(p)
#define Assert(f)
#define AssertSz(f, sz)
#define AssertZero(f) (f)
#define AssertNonZero(f) (f)
#define AssertRecord(r) (r)
#define AssertRecordNR(r) (r)
#define LogAssertMsg(sz)

#endif
#endif // __ASSERT

//____________________________________________________________________________
//
// Assert implementation, included only once per module, debug only
//____________________________________________________________________________

#ifdef ASSERT_HANDLING
#undef ASSERT_HANDLING
#ifndef __SERVICES
#include "services.h"
#endif
#if defined(_MSI_DLL) // The handler is always impersonated. The service
                      // does not know of our impersonation/elevation, so
                      // asserts fired from ...\Msiexec\Server.cpp file,
                      // in a TS session will not show up on the TS client's
                      // desktop
class CImpersonate;
#endif
#ifdef DEBUG

const int cchAssertBuffer = 2048;
IMsiServices* g_AssertServices = 0;
Bool g_fNoAsserts=fFalse;
IMsiDebug* g_piDebugServices = 0;
bool g_fFlushDebugLog = true;	// Set to true when we're shutting down so it's faster.

#ifndef AUTOMATION_HANDLING
const GUID IID_IMsiDebug     = GUID_IID_IMsiDebug;
#endif //!AUTOMATION_HANDLING

void InitializeAssert(IMsiServices* piServices)
{
	g_AssertServices = piServices;

	ICHAR rgchBuf[10];
	if (GetEnvironmentVariable(TEXT("ASSERTS"), rgchBuf, sizeof(rgchBuf)/sizeof(ICHAR)) > 0
		  && (rgchBuf[0] == 'N' || rgchBuf[0] == 'n'))
		g_fNoAsserts = fTrue;
	if (g_piDebugServices == 0 && piServices != 0 && 
		piServices->QueryInterface(IID_IMsiDebug, (void **)&g_piDebugServices) != NOERROR)
	{
		g_piDebugServices = 0;
	}
}

#ifdef UNICODE
void FailAssertMsg(const char* szMessage)
{
	ICHAR szBuffer[cchAssertBuffer];

	if(!MultiByteToWideChar(CP_ACP, 0, szMessage, -1, szBuffer, cchAssertBuffer))
		if (ERROR_INSUFFICIENT_BUFFER == WIN::GetLastError())
			szBuffer[cchAssertBuffer - 1] = ICHAR(0);

	FailAssertMsg(szBuffer);
}
#endif

bool FIsLocalSystem()
{
		extern bool RunningAsLocalSystem();

		if (g_scServerContext == scService)
			return true;
#ifdef IN_SERVICES
		else if (RunningAsLocalSystem())
			return true;
#endif //IN_SERVICE

		return false;
}

void FailAssertMsg(const ICHAR* szMessage)
{
	int id = IDRETRY;
	
	OutputDebugString(szMessage);
	OutputDebugString(TEXT("\r\n"));
	
	if (!g_fNoAsserts)
	{
		UINT mb = MB_ABORTRETRYIGNORE | MB_DEFBUTTON2 | MB_TOPMOST | (FIsLocalSystem() ? MB_SERVICE_NOTIFICATION : 0);

		if (g_scServerContext == scService)
		{
#if defined(_MSI_DLL) // the handler is always impersonated
			// 
			// Since the service is non-interactive, make sure that
			// MB_SERVICE_NOTIFICATION puts up the message box in the
			// right session using the session ID obtained from the
			// impersonation token.
			//
			CImpersonate impersonate;
#endif // defined(_MSI_DLL)
			id = ::MessageBox(0, szMessage, TEXT("Debug Service Assert Message. Retry=Continue, Abort=Break"),
									mb);
		}
		else
			id = ::MessageBox(0, szMessage, TEXT("Debug Assert Message. Retry=Continue, Abort=Break"),
									mb);
	}

	if (g_AssertServices && g_AssertServices->LoggingEnabled())
		g_AssertServices->WriteLog(szMessage);
	else if(g_piDebugServices)
		g_piDebugServices->WriteLog(szMessage);
		
	if (id == IDABORT)
		DebugBreak();
	else if (id == IDIGNORE)
		g_fNoAsserts = fTrue;
}

void LogAssertMsg(const ICHAR* szMessage)
{
	if (g_AssertServices && g_AssertServices->LoggingEnabled())
		g_AssertServices->WriteLog(szMessage);
	else if(g_piDebugServices)
		g_piDebugServices->WriteLog(szMessage);
}		


void FailAssert(const ICHAR* szFile, int iLine)
{
	ICHAR szMessage[cchAssertBuffer];	
	HRESULT hRes = StringCchPrintf(szMessage, ARRAY_ELEMENTS(szMessage),
											 TEXT("Assertion failed in %s: Line %i"),
											 szFile, iLine);
	if ( !SUCCEEDED(hRes) && hRes != STRSAFE_E_INSUFFICIENT_BUFFER )
		//  even if the szMessage buffer is too small, we still need to give
		//  the dev. something to chew on.
		return;
	FailAssertMsg(szMessage);

}

#ifdef UNICODE
void FailAssertSz(const ICHAR* szFile, int iLine, const char *szMsg)
{
	ICHAR szMessage[cchAssertBuffer];
	HRESULT hRes = StringCchPrintf(szMessage, ARRAY_ELEMENTS(szMessage),
											 TEXT("Assertion failed in %s: Line %i\n"),
											 szFile, iLine);
	if ( !SUCCEEDED(hRes) && hRes != STRSAFE_E_INSUFFICIENT_BUFFER )
		//  even if the szMessage buffer is too small, we still need to give
		//  the dev. something to chew on.
		return;

	int cchMessage = lstrlen(szMessage);

	if (!MultiByteToWideChar(CP_ACP, 0, szMsg, -1, szMessage+cchMessage, cchAssertBuffer - cchMessage - 1))
	{
		if (ERROR_INSUFFICIENT_BUFFER == WIN::GetLastError())
			szMessage[cchAssertBuffer - 1] = ICHAR(0);
	}

	FailAssertMsg(szMessage);
}
#endif // UNICODE

void FailAssertSz(const ICHAR* szFile, int iLine, const ICHAR *szMsg)
{
	ICHAR szMessage[cchAssertBuffer];
	HRESULT hRes = StringCchPrintf(szMessage, ARRAY_ELEMENTS(szMessage),
											 TEXT("Assertion failed in %s: Line %i\n"),
											 szFile, iLine);
	if ( !SUCCEEDED(hRes) && hRes != STRSAFE_E_INSUFFICIENT_BUFFER )
		//  even if the szMessage buffer is too small, we still need to give
		//  the dev. something to chew on.
		return;

	int cchMsg = lstrlen(szMsg);
	int cchMessage = lstrlen(szMessage);
	
	if (cchAssertBuffer >= (cchMsg+cchMessage+sizeof(ICHAR)))	
	{
		memcpy(szMessage+cchMessage, szMsg, cchMsg * sizeof(ICHAR));
		szMessage[cchMsg + cchMessage] = ICHAR(0);
	}
	else
	{
		memcpy(szMessage+cchMessage, szMsg, (cchAssertBuffer - cchMessage) * sizeof(ICHAR));
		szMessage[cchAssertBuffer-1] = ICHAR(0);
	}
	
	FailAssertMsg(szMessage);
}

void FailAssertRecord(const ICHAR* szFile, int iLine,
													IMsiRecord& riError, bool fRelease)
{
	ICHAR szMessage[cchAssertBuffer];
	int id = IDRETRY;
	UINT mb = MB_ABORTRETRYIGNORE | MB_DEFBUTTON2 | MB_TOPMOST | (FIsLocalSystem()? MB_SERVICE_NOTIFICATION : 0);

	if (!g_fNoAsserts)
	{
		HRESULT hRes = StringCchPrintf(szMessage, ARRAY_ELEMENTS(szMessage),
												 TEXT("Error record returned in %s: Line %i"),
												 szFile, iLine);
		if ( !SUCCEEDED(hRes) && hRes != STRSAFE_E_INSUFFICIENT_BUFFER )
			//  even if the szMessage buffer is too small, we still need to give
			//  the dev. something to chew on.
			return;

		OutputDebugString(szMessage);
		OutputDebugString(TEXT("\r\n"));
		if (g_scServerContext == scService)
		{
#if defined(_MSI_DLL) // the handler is always impersonated
			// 
			// Since the service is non-interactive, make sure that
			// MB_SERVICE_NOTIFICATION puts up the message box in the
			// right session using the session ID obtained from the
			// impersonation token.
			//
			CImpersonate impersonate;
#endif // defined(_MSI_DLL)
			id = ::MessageBox(0, szMessage, TEXT("Debug Service Assert Message. Retry=Continue, Abort=Break"),
									mb);
		}
		else
			id = ::MessageBox(0, szMessage, TEXT("Debug Assert Message. Retry=Continue, Abort=Break"),
									mb);
	}
		
	if (g_AssertServices)
	{
		g_AssertServices->WriteLog(szMessage);
		MsiString astr(riError.FormatText(fTrue));
		OutputDebugString((const ICHAR*)astr);
		OutputDebugString(TEXT("\r\n"));
		UINT mbT = MB_OK | MB_TOPMOST | (FIsLocalSystem() ? MB_SERVICE_NOTIFICATION : 0);
		if (g_scServerContext == scService)
		{
#if defined(_MSI_DLL) // the handler is always impersonated
			// 
			// Since the service is non-interactive, make sure that
			// MB_SERVICE_NOTIFICATION puts up the message box in the
			// right session using the session ID obtained from the
			// impersonation token.
			//
			CImpersonate impersonate;
#endif // defined(_MSI_DLL)
			::MessageBox(0, astr, TEXT("Debug Service Assert Record Data"), mbT);
		}
		else
			::MessageBox(0, astr, TEXT("Debug Assert Record Data"), mbT);
		g_AssertServices->WriteLog(astr);
	}
	if(fRelease)
		riError.Release();
	
	if (id == IDABORT)
		DebugBreak();
	else if (id == IDIGNORE)
		g_fNoAsserts = fTrue;

}

#endif // DEBUG
#endif // ASSERT_HANDLING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\instmsi\regsip\sources.inc ===
TARGETNAME=regsip
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=DYNLINK
TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib 

C_DEFINES=$(C_DEFINES)
USE_NOLIBS=1
USE_NATIVE_EH=1
DLLDEF=..\regsip.def

INCLUDES=$(INCLUDES);$(INC_DIR);$(TOOLS_INC_DIR);$(RES_OBJDIR)

SOURCES=..\regsip.cpp \
	..\regsip.rc

BUFFER_OVERFLOW_CHECKS=NO_NTDLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\inc\_diagnos.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       _diagnos.h
//
//--------------------------------------------------------------------------

/* _diagnos.h - diagnostic output facilities

   DEBUGMSG* macros provide facility for sending strings to debug output or log

   DEBUGMSG:   debug output plus logging when verbose log mode set
   DEBUGMSGL:  debug output plus logging even when verbose log mode not set
   DEBUGMSGV:  debug output and logging only when verbose modes for each are set
   DEBUGMSGD:  just like DEBUGMSG but only in debug build
	DEBUGMSGVD: just like DEBUGMSGV but only in debug build

	DEBUGMSGE:  debug output, logging, and event log
					DEBUGMSGE(w,i,..): w is event type (EVENTLOG_WARNING_TYPE, etc...)
											 i is template id from eventlog.h
____________________________________________________________________________*/

#ifndef __DIAGNOSE
#define __DIAGNOSE

extern int g_dmDiagnosticMode;
// bit values for g_dmDiagnosticMode
const int dmDebugOutput        = 0x01;
const int dmVerboseDebugOutput = 0x02;
const int dmLogging            = 0x04;
const int dmVerboseLogging     = 0x08;
const int dmEventLog           = 0x10;

const int dpDebugOutput        = dmDebugOutput;
const int dpVerboseDebugOutput = dmVerboseDebugOutput;
const int dpLogCommandLine     = 0x04;  // used only in ShouldLogCmdLine() function

void SetDiagnosticMode();
bool FDiagnosticModeSet(int iMode);
void DebugString(int iMode, WORD wEventType, int iEventLogTemplate, LPCSTR szMsg, LPCSTR arg1="(NULL)", LPCSTR arg2="(NULL)", LPCSTR arg3="(NULL)", LPCSTR arg4="(NULL)", LPCSTR arg5="(NULL)", LPCSTR arg6="(NULL)", DWORD dwDataSize=0, LPVOID argRawData=NULL);
void DebugString(int iMode, WORD wEventType, int iEventLogTemplate, LPCWSTR szMsg, LPCWSTR arg1=L"(NULL)", LPCWSTR arg2=L"(NULL)", LPCWSTR arg3=L"(NULL)", LPCWSTR arg4=L"(NULL)", LPCWSTR arg5=L"(NULL)", LPCWSTR arg6=L"(NULL)", DWORD dwDataSize=0, LPVOID argRawData=NULL);

#define DEBUGMSG(x) ( g_dmDiagnosticMode ? DebugString(dmDebugOutput|dmVerboseLogging,0,0,x) : (void)0 )
#define DEBUGMSG1(x,a) ( g_dmDiagnosticMode ? DebugString(dmDebugOutput|dmVerboseLogging,0,0,x,a) : (void)0 )
#define DEBUGMSG2(x,a,b) ( g_dmDiagnosticMode ? DebugString(dmDebugOutput|dmVerboseLogging,0,0,x,a,b) : (void)0 )
#define DEBUGMSG3(x,a,b,c) ( g_dmDiagnosticMode ? DebugString(dmDebugOutput|dmVerboseLogging,0,0,x,a,b,c) : (void)0 )
#define DEBUGMSG4(x,a,b,c,d) ( g_dmDiagnosticMode ? DebugString(dmDebugOutput|dmVerboseLogging,0,0,x,a,b,c,d) : (void)0 )
#define DEBUGMSG5(x,a,b,c,d,e) ( g_dmDiagnosticMode ? DebugString(dmDebugOutput|dmVerboseLogging,0,0,x,a,b,c,d,e) : (void)0 )
#define DEBUGMSG6(x,a,b,c,d,e,f) ( g_dmDiagnosticMode ? DebugString(dmDebugOutput|dmVerboseLogging,0,0,x,a,b,c,d,e,f) : (void)0 )

// debug output plus non-verbose logging

#define DEBUGMSGL(x) ( g_dmDiagnosticMode ? DebugString(dmDebugOutput|dmLogging,0,0,x) : (void)0 )
#define DEBUGMSGL1(x,a) ( g_dmDiagnosticMode ? DebugString(dmDebugOutput|dmLogging,0,0,x,a) : (void)0 )
#define DEBUGMSGL2(x,a,b) ( g_dmDiagnosticMode ? DebugString(dmDebugOutput|dmLogging,0,0,x,a,b) : (void)0 )
#define DEBUGMSGL3(x,a,b,c) ( g_dmDiagnosticMode ? DebugString(dmDebugOutput|dmLogging,0,0,x,a,b,c) : (void)0 )
#define DEBUGMSGL4(x,a,b,c,d) ( g_dmDiagnosticMode ? DebugString(dmDebugOutput|dmLogging,0,0,x,a,b,c,d) : (void)0 )

// similar to the above (debug output and logging), but only in eXtra debugging mode

#define DEBUGMSGLX2(x,a,b) ( g_dmDiagnosticMode && (g_dwLogMode & INSTALLLOGMODE_EXTRADEBUG) ? DebugString(dmDebugOutput|dmLogging,0,0,x,a,b) : (void)0 )
#define DEBUGMSGLX3(x,a,b,c) ( g_dmDiagnosticMode && (g_dwLogMode & INSTALLLOGMODE_EXTRADEBUG) ? DebugString(dmDebugOutput|dmLogging,0,0,x,a,b,c) : (void)0 )

// verbose-only messages

#define DEBUGMSGV(x) ( g_dmDiagnosticMode ? DebugString(dmVerboseDebugOutput|dmVerboseLogging,0,0,x) : (void)0 )
#define DEBUGMSGV1(x,a) ( g_dmDiagnosticMode ? DebugString(dmVerboseDebugOutput|dmVerboseLogging,0,0,x,a) : (void)0 )
#define DEBUGMSGV2(x,a,b) ( g_dmDiagnosticMode ? DebugString(dmVerboseDebugOutput|dmVerboseLogging,0,0,x,a,b) : (void)0 )
#define DEBUGMSGV3(x,a,b,c) ( g_dmDiagnosticMode ? DebugString(dmVerboseDebugOutput|dmVerboseLogging,0,0,x,a,b,c) : (void)0 )
#define DEBUGMSGV4(x,a,b,c,d) ( g_dmDiagnosticMode ? DebugString(dmVerboseDebugOutput|dmVerboseLogging,0,0,x,a,b,c,d) : (void)0 )

// plus event log messages
// event logging always enabled so no check against g_dmDiagnosticMode is made

#define DEBUGMSGE(w,i,x) DebugString(dmDebugOutput|dmLogging|dmEventLog,w,i,x)
#define DEBUGMSGE1(w,i,x,a) DebugString(dmDebugOutput|dmLogging|dmEventLog,w,i,x,a)
#define DEBUGMSGE2(w,i,x,a,b) DebugString(dmDebugOutput|dmLogging|dmEventLog,w,i,x,a,b)
#define DEBUGMSGE3(w,i,x,a,b,c) DebugString(dmDebugOutput|dmLogging|dmEventLog,w,i,x,a,b,c)

#define null TEXT("(NULL)")
#define DEBUGMSGED(w,i,x,dl,dd) DebugString(dmDebugOutput|dmLogging|dmEventLog,w,i,x,null,null,null,null,null,null,dl,dd)

// this one goes only to debug output

#define DEBUGMSGDO(x) ( g_dmDiagnosticMode ? DebugString(dmDebugOutput,0,0,x) : (void)0 )

// debug-only messages

#ifdef DEBUG

#define DEBUGMSGD(x)               DEBUGMSG(x)
#define DEBUGMSGD1(x,a)            DEBUGMSG1(x,a)
#define DEBUGMSGD2(x,a,b)          DEBUGMSG2(x,a,b)
#define DEBUGMSGD3(x,a,b,c)        DEBUGMSG3(x,a,b,c)
#define DEBUGMSGD4(x,a,b,c,d)      DEBUGMSG4(x,a,b,c,d)
#define DEBUGMSGVD(x)              DEBUGMSGV(x)
#define DEBUGMSGVD1(x,a)           DEBUGMSGV1(x,a)
#define DEBUGMSGVD2(x,a,b)         DEBUGMSGV2(x,a,b)
#define DEBUGMSGVD3(x,a,b,c)       DEBUGMSGV3(x,a,b,c)
#define DEBUGMSGVD4(x,a,b,c,d)     DEBUGMSGV4(x,a,b,c,d)

#else // SHIP

#define DEBUGMSGD(x)
#define DEBUGMSGD1(x,a)
#define DEBUGMSGD2(x,a,b)
#define DEBUGMSGD3(x,a,b,c)
#define DEBUGMSGD4(x,a,b,c,d)
#define DEBUGMSGVD(x)
#define DEBUGMSGVD1(x,a)
#define DEBUGMSGVD2(x,a,b)
#define DEBUGMSGVD3(x,a,b,c)
#define DEBUGMSGVD4(x,a,b,c,d)

#endif

#endif // __DIAGNOSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msi\sources.inc ===
TARGETNAME=msi

!INCLUDE ..\..\MsiMake.inc

MSC_OPTIMIZATION=/Od

!if "$(MSI_BROWSER_INFO)"=="1"
BROWSER_INFO=1
!endif

SYNCHRONIZE_DRAIN=1

TARGETTYPE=DYNLINK
TARGETLIBS=\
!if "$(MSI_BUILD_UNICODE)"=="1"
        $(SDK_LIB_PATH)\ntdll.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
!else
        $(SDK_LIB_PATH)\advapi32.lib \
!endif
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\user32.lib \
        $(SDK_LIB_PATH)\gdi32.lib \
        $(SDK_LIB_PATH)\rpcrt4.lib \
        $(IDL_OBJDIR)\icust_p.obj \
	$(IDL_OBJDIR)\messag_p.obj \
	$(IDL_OBJDIR)\server_p.obj \
	$(IDL_OBJDIR)\remapi_p.obj \
	$(IDL_OBJDIR)\dlldata.obj \
	$(RES_OBJDIR)\msiall.res \
	$(DS_LIB_PATH)\rsa32.lib \
        $(SDK_LIB_PATH)\strsafe.lib

LINKLIBS=\
!if "$(MSI_BUILD_LEGACY)"=="1"
	$(MSI_UNICODE_BUILD_TARGET)\*\msilib.lib
!else
	$(MSI_BUILD_TARGET)\*\msilib.lib
!endif

C_DEFINES=$(C_DEFINES) \
	-DINTERNAL

USE_LIBCMT=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\msi.def

INCLUDES=\
        $(INCLUDES);\
        ..;\
        $(INC_DIR);\
        $(BASE_INC_PATH);\
        $(IDL_OBJDIR);\
        $(BUILD_COMMONDIR);\
        $(TOOLS_INC_DIR);\
        $(RES_OBJDIR);\
        $(DS_INC_PATH)\crypto;\
        $(ADMIN_INC_PATH)

SOURCES=..\legacy.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msi\legacy\makefile.inc ===
msiAll: $(BUILD_DIR)

#Create target directories if not already existing
#-------------------------------------------------
$(BUILD_DIR):
	echo BUILD_DIR=$(BUILD_DIR)
        md $(BUILD_DIR)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msiexec\latebind.cpp ===
#include "combind.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\instmsi\regsip\regsip.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       regsip.cpp
//
//--------------------------------------------------------------------------

#include "common.h" // for GUID_IID_MsiSigningSIPProvider
#include <windows.h>
#include <wincrypt.h>
#include <wintrust.h>
#include <mssip.h>
#include "msi.h" // for MSIHANDLE


//-----------------------------------------------------------------------------
// Dynamic loading of crypt32.dll
//
//-----------------------------------------------------------------------------
#define CRYPT32_DLL TEXT("crypt32.dll")

#define CRYPTOAPI_CryptSIPAddProvider  "CryptSIPAddProvider"
typedef BOOL (WINAPI *PFnCryptSIPAddProvider)(SIP_ADD_NEWPROVIDER *psNewProv);

#define CRYPTOAPI_CryptSIPRemoveProvider "CryptSIPRemoveProvider"
typedef BOOL (WINAPI *PFnCryptSIPRemoveProvider)(GUID *pgProv);

//-----------------------------------------------------------------------------
// MsiSip registration information
//
//-----------------------------------------------------------------------------

#define MSI_NAME                    L"MSISIP.DLL"
#define MSI_SIP_MYFILETYPE_FUNCTION L"MsiSIPIsMyTypeOfFile"
#define MSI_SIP_GETSIG_FUNCTION     L"MsiSIPGetSignedDataMsg"
#define MSI_SIP_PUTSIG_FUNCTION     L"MsiSIPPutSignedDataMsg"
#define MSI_SIP_CREATEHASH_FUNCTION L"MsiSIPCreateIndirectData"
#define MSI_SIP_VERIFYHASH_FUNCTION L"MsiSIPVerifyIndirectData"
#define MSI_SIP_REMOVESIG_FUNCTION  L"MsiSIPRemoveSignedDataMsg"
#define MSI_SIP_CURRENT_VERSION     0x00000001

GUID gMSI = GUID_IID_MsiSigningSIPProvider;

//-----------------------------------------------------------------------------
// Old Structured Storage SIP -- we want to remove its registration
//
//-----------------------------------------------------------------------------
#define OLD_STRUCTURED_STORAGE_SIP                              \
            { 0x941C2937,                                       \
              0x1292,                                           \
              0x11D1,                                           \
              { 0x85, 0xBE, 0x0, 0xC0, 0x4F, 0xC2, 0x95, 0xEE } \
            }

//-----------------------------------------------------------------------------
// RegisterMsiSip custom action
//
//-----------------------------------------------------------------------------

UINT __stdcall RegisterMsiSip(MSIHANDLE /*hInstall*/)
{
	//
	// first, let's see if crypto is even on the system
	HINSTANCE hInstCrypto = LoadLibrary(CRYPT32_DLL);
	if (!hInstCrypto)
	{
		// ERROR, crypt32.dll is not available on the system -- this is okay
		// msisip.dll will be present on the system, but not utilized
		return ERROR_SUCCESS;
	}

	//
	// obtain function pointers for digital signature support
	PFnCryptSIPRemoveProvider pfnCryptSIPRemoveProvider = (PFnCryptSIPRemoveProvider) GetProcAddress(hInstCrypto, CRYPTOAPI_CryptSIPRemoveProvider);
	PFnCryptSIPAddProvider pfnCryptSIPAddProvider = (PFnCryptSIPAddProvider) GetProcAddress(hInstCrypto, CRYPTOAPI_CryptSIPAddProvider);
	if (!pfnCryptSIPRemoveProvider || !pfnCryptSIPAddProvider)
	{
		// ERROR, crypt32.dll is present on the system, but isn't a version with digital signature support -- this is okay
		// msisip.dll will be present on the system, but not utilized
		FreeLibrary(hInstCrypto);
		return ERROR_SUCCESS;
	}
	
	//
	// let's try and get rid of the old structured storage sip, as it will
	// interfere with our structured storage sip for Msi, Mst, and Msp
	// additionally, it is no longer supported in later versions of crypto
	// we don't care about failure (i.e. if it fails, it wasn't there to
	// begin with which is just fine and dandy)
	GUID gOldSS_Sip = OLD_STRUCTURED_STORAGE_SIP;
	pfnCryptSIPRemoveProvider(&gOldSS_Sip);

	//
	// now let's register our SS sip for Msi, Mst, and Msp
	SIP_ADD_NEWPROVIDER sProv;

	HRESULT hr = S_OK;

	// must first init struct to 0
	ZeroMemory(&sProv, sizeof(SIP_ADD_NEWPROVIDER));

	// add registration info
	sProv.cbStruct               = sizeof(SIP_ADD_NEWPROVIDER);
	sProv.pwszDLLFileName        = MSI_NAME;
	sProv.pgSubject              = &gMSI;
//	sProv.pwszIsFunctionName is unsupported because we can't convert hFile to IStorage
	sProv.pwszGetFuncName        = MSI_SIP_GETSIG_FUNCTION;
	sProv.pwszPutFuncName        = MSI_SIP_PUTSIG_FUNCTION;
	sProv.pwszCreateFuncName     = MSI_SIP_CREATEHASH_FUNCTION;
	sProv.pwszVerifyFuncName     = MSI_SIP_VERIFYHASH_FUNCTION;
	sProv.pwszRemoveFuncName     = MSI_SIP_REMOVESIG_FUNCTION;
	sProv.pwszIsFunctionNameFmt2 = MSI_SIP_MYFILETYPE_FUNCTION;

	hr = pfnCryptSIPAddProvider(&sProv);
	if (FAILED(hr))
	{
		if (E_NOTIMPL == hr)
		{
			// stub provided, but not implemented
			// we'll be present on the system, but not utilized
			FreeLibrary(hInstCrypto);
			return ERROR_SUCCESS;
		}
		else
		{
			// crypto failed to add us as a provide, we'll fail in order to be secure
			FreeLibrary(hInstCrypto);
			return ERROR_INSTALL_FAILURE;
		}
	}

	//
	// unload crypt32.dll
	FreeLibrary(hInstCrypto);

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msiexec\sources.inc ===
TARGETNAME=msiexec
!INCLUDE ..\..\MsiMake.inc

!if "$(MSI_BROWSER_INFO)"=="1"
BROWSER_INFO=1
!endif

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0
UMTYPE=windows
UMENTRY=winmain

!if "$(MSI_BUILD_UNICODE)"=="1"
USE_MSVCRT=1
!else
USE_LIBCMT=1
!endif

TARGETLIBS=\
!if "$(MSI_BUILD_UNICODE)"=="1"
        $(SDK_LIB_PATH)\ntdll.lib \
!endif
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
        $(SDK_LIB_PATH)\rpcrt4.lib \
        $(SDK_LIB_PATH)\ole32.lib \
        $(SDK_LIB_PATH)\msi.lib \
        $(SDK_LIB_PATH)\strsafe.lib

C_DEFINES=$(C_DEFINES) -D_EXE
IDL_TYPE=rpc    

INCLUDES=$(INCLUDES);$(INC_DIR);$(BASE_INC_PATH);$(AUTO_OBJDIR);$(IDL_OBJDIR);$(RES_OBJDIR);$(TOOLS_INC_DIR);$(BUILD_COMMONDIR);$(ADMIN_INC_PATH)

SOURCES=..\server.cpp \
        ..\latebind.cpp \
        ..\server.rc

#
# The assembly version is defaulted productwide in makefile.def, and
# basesrv gets it from PEB->OSMajorVersion, OSMinorVersion.
#
SXS_MANIFEST=msiexec.manifest
SXS_ASSEMBLY_NAME=MSIExec
SXS_ASSEMBLY_VERSION=1.50
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST_IN_RESOURCES=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msiexec\server.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       server.cpp
//
//--------------------------------------------------------------------------

/* server.cpp - Automated install server, may operate as a NT service

____________________________________________________________________________*/

#include "common.h"  // must be first for precompiled headers to work
#pragma pointers_to_members(full_generality, multiple_inheritance)
#include "msidspid.h" // dispatch IDs
#define ASSERT_HANDLING      // instantiates Assert handlers
#include "_assert.h"
#define CLSID_COUNT  1
#define MODULE_CLSIDS       rgCLSID         // array of CLSIDs for module objects
#define MODULE_PROGIDS      rgszProgId      // ProgId array for this module
#define MODULE_DESCRIPTIONS rgszDescription // Registry description of objects
#define MODULE_FACTORIES    rgFactory       // factory functions for each CLSID
//#define MODULE_INITIALIZE   {optional, name of initialization function}
//#define MODULE_TERMINATE    {optional, name of termination function}
#define SERVICE_NAME TEXT("MSIServer")
#define COMMAND_OPTIONS  szCmdLineOptions
#define COMMAND_FUNCTIONS  rgCommandProcessor
#define DLLREGISTEREXTRA        RegisterProxyInfo

#define CA_CLSID 1 // 0-based

void DisplayHelp(void);

#include "msi.h"
#include "msip.h"

#include "..\engine\_engine.h"   // help option letters
#include "..\engine\_msiutil.h"  // log modes, custom action class

#include "resource.h"

#include "module.h"    // entry points, registration, includes "version.h"
#include "engine.h"    // IMsiMessage, includes "iconfig.h"
#include "version.h"

#include "msiauto.hh" // helpIDs to throw
#include "msidspid.h" // automation dispatch IDs

#ifdef SERVER_ENUMS_ONLY
#undef SERVER_ENUMS_ONLY
#endif //SERVER_ENUMS_ONLY
#include "server.h"
#include "strsafe.h"

// help string
#define IDS_HELP 10

const GUID IID_IUnknown      = GUID_IID_IUnknown;
const GUID IID_IClassFactory = GUID_IID_IClassFactory;
const GUID IID_IMsiMessageRPCClass      = GUID_IID_IMsiMessageRPCClass;

// Global data
bool g_fWinNT64 = FALSE;

//____________________________________________________________________________
//
// COM objects produced by this module's class factories
//____________________________________________________________________________

IUnknown* CreateServer();

const GUID rgCLSID[1]           = { GUID_IID_IMsiServer };
const ICHAR* rgszProgId[1]      = { SZ_PROGID_IMsiServer };
const ICHAR* rgszDescription[1] = { SZ_DESC_IMsiServer };
ModuleFactory rgFactory[1]      = { CreateServer };

//____________________________________________________________________________
//
// Global data
//____________________________________________________________________________
const GUID IID_IMsiServer               = GUID_IID_IMsiServer;
const GUID IID_IMsiServerProxy          = GUID_IID_IMsiServerProxy;
const GUID IID_IMsiString               = GUID_IID_IMsiString;
const GUID IID_IMsiConfigurationManager = GUID_IID_IMsiConfigurationManager;
const GUID IID_IMsiConfigManagerDebug   = GUID_IID_IMsiConfigManagerDebug;
const GUID IID_IMsiConfigManagerAsServer = GUID_IID_IMsiConfigManagerAsServer;
const GUID IID_IMsiConfigMgrAsServerDebug= GUID_IID_IMsiConfigMgrAsServerDebug;
const GUID IID_IMsiCustomAction          = GUID_IID_IMsiCustomAction;
const GUID IID_IMsiCustomActionProxy     = GUID_IID_IMsiCustomActionProxy;
const GUID IID_IMsiMessage              = GUID_IID_IMsiMessage;
const GUID IID_NULL                     = {0,0,0,{0,0,0,0,0,0,0,0}};
const GUID IID_IMsiCustomActionLocalConfig = GUID_IID_IMsiCustomActionLocalConfig;

HINSTANCE g_hKernel = 0;
PDllGetClassObject g_fpKernelClassFactory = 0;


const int INSTALLUILEVEL_NOTSET = -1;
INSTALLUILEVEL g_INSTALLUILEVEL = (INSTALLUILEVEL)INSTALLUILEVEL_NOTSET;

// not exposed outside of istring.cpp
#if defined (DEBUG) && (!UNICODE)
ICHAR* ICharNext(const ICHAR* pch)
{
        return WIN::CharNext(pch);
}
ICHAR* INextChar(const ICHAR* pch)
{
        return WIN::CharNext(pch);
}
#endif

IUnknown* CreateMsiObject(const GUID& riid)
{
        IMsiMessage* piUnknown = 0;
        IClassFactory* piClassFactory = 0;

        if (!g_hKernel)
                g_hKernel = WIN::LoadLibrary(MSI_KERNEL_NAME);

        if (!g_fpKernelClassFactory)
                g_fpKernelClassFactory = (PDllGetClassObject)WIN::GetProcAddress(g_hKernel, SzDllGetClassObject);

        if (!g_fpKernelClassFactory || (*g_fpKernelClassFactory)(riid, IID_IUnknown, (void**)&piClassFactory) != NOERROR)
                return 0;

        piClassFactory->CreateInstance(0, riid, (void**)&piUnknown);  // piUnknown set to 0 on failure
        return piUnknown;
}

//____________________________________________________________________________
//
// Declarations for service control
//____________________________________________________________________________


typedef int (*CommandProcessor)(const ICHAR* szModifier, const ICHAR* szOption);

BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode,
								 DWORD dwWaitHint, DWORD dwMsiError);
void ReportErrorToDebugOutput(const ICHAR* szMessage, DWORD dwError);
bool FDeleteRegTree(HKEY hKey, ICHAR* szSubKey);
bool FIsKeyLocalSystemOrAdminOwned(HKEY hKey);
bool PurgeUserOwnedSubkeys(HKEY hKey);
bool PurgeUserOwnedInstallerKeys(HKEY hRoot, TCHAR* szKey);

void WINAPI ServiceMain(DWORD dwArgc, LPTSTR *lpszArgv);
VOID WINAPI ServiceControl(DWORD dwCtrlCode);
int InstallService();
int RemoveService();
VOID ServiceStop();
unsigned long __stdcall ServiceThreadMain(void *);

HRESULT RegisterNoService();
HRESULT RegisterServer(Bool fCustom = fFalse);
HRESULT RegisterShellData();
HRESULT Unregister();

const int iNoLocalServer = 0x8000;
Bool g_fAutomation = fFalse;


//____________________________________________________________________________
//
// CAutoServer object management
//____________________________________________________________________________


HANDLE g_hShutdownTimer = INVALID_HANDLE_VALUE;
IUnknown* CreateServer()
{
        IMsiServices* piServices;

        IMsiConfigurationManager* piConfigManager;
        IClassFactory* piClassFactory;
#ifdef DEBUG
        const GUID& riid = IID_IMsiConfigMgrAsServerDebug;
#else
        const GUID& riid = IID_IMsiConfigManagerAsServer;
#endif

        if (g_hKernel == 0)
                g_hKernel = WIN::LoadLibrary(MSI_KERNEL_NAME);

        PDllGetClassObject fpFactory = (PDllGetClassObject)WIN::GetProcAddress(g_hKernel, SzDllGetClassObject);
        if (!fpFactory)
                return 0;
        if ((*fpFactory)(riid, IID_IUnknown, (void**)&piClassFactory) != NOERROR)
                return 0;
        piClassFactory->CreateInstance(0, riid, (void**)&piConfigManager);  // piConfigManager set to 0 on failure
        piClassFactory->Release();
        if (!piConfigManager)
                return 0;
        piServices = &piConfigManager->GetServices(); // can't fail
		piConfigManager->SetShutdownTimer(g_hShutdownTimer);
        InitializeAssert(piServices);
        piServices->Release();

        return (IMsiServer *)piConfigManager;
}

IUnknown* CreateCustomActionServer()
{
        IMsiCustomAction* piCustomAction;
        IClassFactory* piClassFactory;

        const GUID& riid = IID_IMsiCustomActionProxy;

        if (g_hKernel == 0)
                g_hKernel = WIN::LoadLibrary(MSI_KERNEL_NAME);

        PDllGetClassObject fpFactory = (PDllGetClassObject)WIN::GetProcAddress(g_hKernel, SzDllGetClassObject);
        if (!fpFactory)
                return 0;
        if ((*fpFactory)(riid, IID_IUnknown, (void**)&piClassFactory) != NOERROR)
                return 0;
        piClassFactory->CreateInstance(0, riid, (void**)&piCustomAction);
        piClassFactory->Release();
        if (!piCustomAction)
                return 0;

        return (IMsiCustomAction*)piCustomAction;
}

bool SetInstallerACLs()
{
	// If the keys or directories already exist yet are not owned by system or admin then we delete the
	// keys or directories

	// The keys and directories must be owned by the system or admin (well-known sids) and are ACL'd securely
	// (We won't change the ACL if it has already been set by admin)

	// HKLM\Software\Microsoft\Windows\CurrentVersion\Installer
	// HKLM\Software\Microsoft\Windows\CurrentVersion\Installer\Secure
	// HKLM\Software\Classes\Microsoft\Installer
	// HKLM\Software\Policies\Microsoft\Windows\Installer
	// %WINDIR%\szMsiDirectory

	if (!ReportStatusToSCMgr(SERVICE_START_PENDING, NO_ERROR, 3000, 0))
		return false;

	// obtain secure security descriptor
	DWORD dwError = 0;
	char* rgchSD;
	if (ERROR_SUCCESS != (dwError = GetSecureSecurityDescriptor(&rgchSD)))
		return false; //?? should we create an event log entry

	// validate %systemroot%\Installer folder
	UINT uiStat = MsiCreateAndVerifyInstallerDirectory(0);
	if (ERROR_SUCCESS != uiStat)
	{
		ReportErrorToDebugOutput(TEXT("SetInstallerACLs: Unable to create and verify Installer directory"), uiStat);
		return false;
	}

	SECURITY_ATTRIBUTES sa;

	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	sa.lpSecurityDescriptor = rgchSD;

	if (!ReportStatusToSCMgr(SERVICE_START_PENDING, NO_ERROR, 3000, 0))
		return false;


	// We only trust pre-existings keys created by system or Admin.  Any other owner is untrusted and key + subkeys
	// is therefore deleted.  We must go by owner verification.  A user can set the same ACLs that we do.  A user
	// cannot give ownership to another user.  Therefore, a user could create the Installer key, set ACLs to Local System
	// + Admin.  However, ownership would still be user.  Attempting to give ownership to system or admin results in
	// system error 1307: "This security ID may not be assigned as the owner of this object"

	// NOTE, this fix is dependent upon fix to NT bug #382567 where our ACLs change during an OS upgrade.  If that bug
	// is not fixed, we would have to verify ownership + ACLs.

	// RegSetKeySecurity calls are not needed anymore -- if admin created key, set permissions for purpose and we
	// don't want to change what the admin determined was proper

	HKEY hKey = 0;
	HKEY hSubKey = 0;
	DWORD dwDisposition = 0;
	DWORD dwRes = 0;

	if (!ReportStatusToSCMgr(SERVICE_START_PENDING, NO_ERROR, 3000, 0))
		return false;

	CRefCountedTokenPrivileges cPrivs(itkpSD_WRITE);
	if (ERROR_SUCCESS != (dwRes = MsiRegCreate64bitKey(HKEY_LOCAL_MACHINE, szMsiLocalInstallerKey, 0, 0, 0, KEY_ALL_ACCESS, &sa, &hKey, &dwDisposition)))
	{
		ReportErrorToDebugOutput(TEXT("SetInstallerACLs: Could not create Installer key."), dwRes);
		return false;
	}

	if (REG_OPENED_EXISTING_KEY == dwDisposition)
	{
		if (!FIsKeyLocalSystemOrAdminOwned(hKey))
		{
			// key is not owned by system or admin!
			ReportErrorToDebugOutput(TEXT("SetInstallerACLs: Installer key not owned by System or Admin. Deleting key + subkeys and re-creating.\n"), 0);

			// delete key + subkeys
			if (!FDeleteRegTree(HKEY_LOCAL_MACHINE, szMsiLocalInstallerKey))
			{
				ReportErrorToDebugOutput(TEXT("SetInstallerACLs: Could not delete Installer key tree."), 0);
				return false;
			}

			// re-create key
			if (ERROR_SUCCESS != (dwRes = MsiRegCreate64bitKey(HKEY_LOCAL_MACHINE, szMsiLocalInstallerKey, 0, 0, 0, KEY_ALL_ACCESS, &sa, &hKey, &dwDisposition)))
			{
				ReportErrorToDebugOutput(TEXT("SetInstallerACLs: Could not create Installer key."), dwRes);
				return false;
			}
		}
		// verify that all keys beneath Installer key are secure
		if (!PurgeUserOwnedSubkeys(hKey))
			return false;
	}

	// we create this key so the Darwin regkey object won't think our Installer key is empty and therefore delete it

	if (!ReportStatusToSCMgr(SERVICE_START_PENDING, NO_ERROR, 3000, 0))
		return false;

	if (ERROR_SUCCESS != (dwRes = MsiRegCreate64bitKey(hKey, szMsiSecureSubKey, 0, 0, 0, KEY_ALL_ACCESS, &sa, &hSubKey, &dwDisposition)))
	{
		ReportErrorToDebugOutput(TEXT("SetInstallerACLs: Could not create Secure Installer sub key."), dwRes);
		return false;
	};

	// if (REG_OPENED_EXISTING_KEY == dwDisposition) no longer needed.  Above enumeration of Installer key ensures
	// that the owner is secure.  If we had to re-create, already set with correct security.

	RegCloseKey(hSubKey);
	RegCloseKey(hKey);

	// verify ownership of policy key
	if (!ReportStatusToSCMgr(SERVICE_START_PENDING, NO_ERROR, 3000, 0))
		return false;
	if (!PurgeUserOwnedInstallerKeys(HKEY_LOCAL_MACHINE, szPolicyKey))
		return false;

	// verify ownership of managed keys
	if (!ReportStatusToSCMgr(SERVICE_START_PENDING, NO_ERROR, 3000, 0))
		return false;

	if (!PurgeUserOwnedInstallerKeys(HKEY_LOCAL_MACHINE, szMachineSubKey))
		return false;

	return true;
}

//____________________________________________________________________________
//
// Command-line processing
//____________________________________________________________________________

static const WCHAR szSummaryStream[] = L"\005SummaryInformation";
const int cbSummaryHeader = 48;
const int cbSectionHeader = 2 * sizeof(int);  // section size + property count
#define PID_REVNUMBER     9  // string

// charnext function - selectively calls WIN::CharNext

inline const ICHAR* APICharNext(const ICHAR* pchCur)
{
	if(!pchCur) return NULL;
#ifdef UNICODE
        if(*pchCur) return pchCur + 1;
		return pchCur;
#else
        return WIN::CharNext(pchCur);
#endif
        return 0;
}

Bool AppendExtension(const ICHAR* szPath, const ICHAR* szFileExtension, CAPITempBufferRef<ICHAR>& rgchAppendedPath)
/*----------------------------------------------------------------------------
Appends szFileExtension (".???") to szPath if the file name in szPath doesn't contain a '.'.
------------------------------------------------------------------------------*/
{
        const ICHAR* pch = szPath;
        const ICHAR* pchFileName = pch;

		if(!szPath) return fFalse;

        // assume file name is after last directory separator
        while (*pch)
        {
                if (*pch == chDirSep)
                        pch = pchFileName = APICharNext(pch);
				else
					pch = APICharNext(pch);
        }

        pch = pchFileName;
        for(; (*pch && *pch != '.');  pch = APICharNext(pch))
                ;

        if (*pch == '.')
                return fFalse;

        rgchAppendedPath.SetSize(IStrLen(szPath) + IStrLen(szFileExtension) + 1);
        if(	(S_OK == StringCchCopy(rgchAppendedPath, 
								rgchAppendedPath.GetSize(), szPath)) &&
        	(S_OK == StringCchCat(rgchAppendedPath, 
							rgchAppendedPath.GetSize(), szFileExtension)))
			return fTrue;
		else
			return fFalse;
}

UINT GetPackageCodeFromPackage(const ICHAR *szPackage, ICHAR* szPackageCode)
{
	HRESULT hRes;
	bool	fSuccess = false;
	IStorage* piStorage = 0;
	IStream* piStream = 0;
	const WCHAR *szwPackage;

#ifdef UNICODE
	szwPackage = szPackage;
#else
	WCHAR rgchwPackage[MAX_PATH] = {L""};
	szwPackage = rgchwPackage;
	MultiByteToWideChar(CP_ACP, 0, szPackage, -1, const_cast<WCHAR*>(szwPackage), MAX_PATH);
#endif

	char* szaPackageCode;
#ifdef UNICODE
	char rgchPackageCode[cchPackageCode+1];
	szaPackageCode = rgchPackageCode;
#else
	szaPackageCode = szPackageCode;
#endif

	DWORD grfMode = STGM_READ | STGM_SHARE_DENY_WRITE;
	hRes = StgOpenStorage(szwPackage, (IStorage*)0, grfMode, (SNB)0, 0, &piStorage);
	
	if (!SUCCEEDED(hRes))
	{
		if (STG_E_FILENOTFOUND == hRes)
			return ERROR_FILE_NOT_FOUND;
		else
			return ERROR_INSTALL_PACKAGE_OPEN_FAILED;
	}
	
	hRes = piStorage->OpenStream(szSummaryStream, 0, STGM_SHARE_EXCLUSIVE | STGM_READ, 0, &piStream);
	if (!SUCCEEDED(hRes))
	{
		piStorage->Release();
		return ERROR_INSTALL_PACKAGE_INVALID;
	}

	LARGE_INTEGER liAfterHeader;
	liAfterHeader.LowPart = cbSummaryHeader-sizeof(int);
	liAfterHeader.HighPart = 0;
	
	ULONG cbRead;
	
	hRes = piStream->Seek(liAfterHeader, STREAM_SEEK_SET, 0);
	if (!SUCCEEDED(hRes))
		goto GetPackageCodeFromPackageExit;
	
	int iSectionOffset;
	int cbSection;
	int iDummy;

	// Find section start and seek there
	hRes = piStream->Read(&iSectionOffset, sizeof(DWORD), &cbRead);
	if (!SUCCEEDED(hRes) || sizeof(DWORD) != cbRead)
		goto GetPackageCodeFromPackageExit;
	
	LARGE_INTEGER liSectionOffset;
	liSectionOffset.LowPart = iSectionOffset;
	liSectionOffset.HighPart = 0;
	hRes = piStream->Seek(liSectionOffset, STREAM_SEEK_SET, 0);
	if (!SUCCEEDED(hRes))
		goto GetPackageCodeFromPackageExit;

	// Read size of section
	hRes = piStream->Read(&cbSection, sizeof(DWORD), &cbRead);
	if (!SUCCEEDED(hRes) || sizeof(DWORD) != cbRead)
		goto GetPackageCodeFromPackageExit;
	
	// Read property count; ignore it
	hRes = piStream->Read(&iDummy, sizeof(DWORD), &cbRead);
	if (!SUCCEEDED(hRes) || sizeof(DWORD) != cbRead)
		goto GetPackageCodeFromPackageExit;
	
	// Seek to property index
	
	int dwPropId = 0;
	int dwOffset = 0;
	
	// Search property index for property containing product code

	for (; cbSection && (dwPropId != PID_REVNUMBER); cbSection = cbSection - 2*sizeof(DWORD))
	{
		hRes = piStream->Read(&dwPropId, sizeof(DWORD), &cbRead);
		if (!SUCCEEDED(hRes) || sizeof(DWORD) != cbRead)
			goto GetPackageCodeFromPackageExit;
	
		hRes = piStream->Read(&dwOffset, sizeof(DWORD), &cbRead);
		if (!SUCCEEDED(hRes) || sizeof(DWORD) != cbRead)
			goto GetPackageCodeFromPackageExit;
	}

	if (dwPropId == PID_REVNUMBER)
	{
		// Seek to the property's location and read the value
	
		LARGE_INTEGER liPropertyOffset;
		liPropertyOffset.LowPart = iSectionOffset+dwOffset+sizeof(DWORD)+sizeof(DWORD);
		liPropertyOffset.HighPart = 0;
		hRes = piStream->Seek(liPropertyOffset, STREAM_SEEK_SET, 0);
		if (!SUCCEEDED(hRes))
			goto GetPackageCodeFromPackageExit;
		hRes = piStream->Read(szaPackageCode, cchPackageCode*sizeof(char), &cbRead);
		if (!SUCCEEDED(hRes) || cchPackageCode*sizeof(char) != cbRead)
			goto GetPackageCodeFromPackageExit;
		szaPackageCode[38] = 0;
#ifdef UNICODE
		if ( MultiByteToWideChar(CP_ACP, 0, szaPackageCode, 39, szPackageCode, 39) != 0 )
			szPackageCode[38] = 0;
		else
			goto GetPackageCodeFromPackageExit;
#endif
	}
	else
	{
		goto GetPackageCodeFromPackageExit;
	}

	fSuccess = true;
	
GetPackageCodeFromPackageExit:
	if (piStream)
		piStream->Release();
	
	if (piStorage)
		piStorage->Release();
	
	return fSuccess ? ERROR_SUCCESS : ERROR_INSTALL_PACKAGE_INVALID;
}


//const int cchMaxCommandLine = 1024;
CAPITempBuffer<ICHAR, cchMaxCommandLine> g_szCommandLine; // this will leak; we don't care
int g_cchCommandLine = 0;
CAPITempBuffer<ICHAR, cchMaxCommandLine> g_szTransforms;  // this will leak; we don't care
ICHAR g_szProductToPatch[MAX_PATH + 1] = {0}; // first character is install type
ICHAR g_szInstanceToConfigure[cchProductCode + 1] = {0};

int RegShellData(const ICHAR* /*szModifier*/, const ICHAR* szOption);
int RegisterServ(const ICHAR* /*szModifier*/, const ICHAR* szOption);
int UnregisterServ(const ICHAR* /*szModifier*/, const ICHAR* szOption);
int StartService(const ICHAR* /*szModifier*/, const ICHAR* szCaption);
int Automation(const ICHAR* /*szModifier*/, const ICHAR* szCaption);
int Embedding(const ICHAR* /*szModifier*/, const ICHAR* szCaption);
int ShowHelp(const ICHAR* /*szModifier*/, const ICHAR* szCaption);
int RemoveAll(const ICHAR* /*szModifier*/, const ICHAR* szProduct);
int InstallPackage(const ICHAR* /*szModifier*/, const ICHAR* szPackage);
int ApplyPatch(const ICHAR* /*szModifier*/, const ICHAR* szPatch);
int AdvertisePackage(const ICHAR* /*szModifier*/, const ICHAR* szPackage);
int RepairPackage(const ICHAR* /*szModifier*/, const ICHAR* szPackage);
int UninstallPackage(const ICHAR* /*szModifier*/, const ICHAR* szPackage);
int AdminInstallPackage(const ICHAR* /*szModifier*/, const ICHAR* szPackage);
int Properties(const ICHAR* /*szModifier*/, const ICHAR* szProperties);
int Transforms(const ICHAR* /*szModifier*/, const ICHAR* szTransforms);
int Quiet(const ICHAR* /*szModifier*/, const ICHAR*);
int Language(const ICHAR* /*szModifier*/, const ICHAR* szLanguage);
int LogMode(const ICHAR* , const ICHAR*);
int SelfReg(const ICHAR* /*szModifier*/, const ICHAR* szPackage);
int SelfUnreg(const ICHAR* /*szModifier*/, const ICHAR* szPackage);
int RequestMIF(const ICHAR* /*szModifier*/, const ICHAR* szFile);
int Instance(const ICHAR* /*szModifier*/, const ICHAR* szInstance);
int AdvertiseInstance(const ICHAR* /*szModifier*/, const ICHAR* szOption);

int SetProductToPatch(ICHAR chInstallType, const ICHAR* szProduct);

void GenerateMIF(UINT iStatus);
void ConfigureMIF(const ICHAR* szPackage);
static bool g_fStatusMIF = false;
bool g_fAdvertiseNewInstance = false;

const GUID IID_IMsiEngine    = GUID_IID_IMsiEngine;

Bool ExpandPath(const char* szPath, CTempBufferRef<ICHAR>& rgchExpandedPath);

// see _engine.h for all command-line #defines

const ICHAR szCmdLineOptions[] = {
        REG_SERVER_OPTION,
        UNREG_SERVER_OPTION,
        SERVICE_OPTION,
        EMBEDDING_OPTION,
        HELP_1_OPTION,
        HELP_2_OPTION,
        INSTALL_PACKAGE_OPTION,
        ADVERTISE_PACKAGE_OPTION,
        REG_SHELL_DATA_OPTION,
        QUIET_OPTION,
        UNINSTALL_PACKAGE_OPTION,
        REPAIR_PACKAGE_OPTION,
        NETWORK_PACKAGE_OPTION,
        TRANSFORMS_OPTION,
        APPLY_PATCH_OPTION,
        SELF_REG_OPTION,
        SELF_UNREG_OPTION,
        LOG_OPTION,
        LANGUAGE_OPTION,
        SMS_MIF_OPTION,
		INSTANCE_OPTION,
		ADVERTISE_INSTANCE_OPTION,
        0,
};

CommandProcessor rgCommandProcessor[] =
{
        RegisterServ,
        UnregisterServ,
        StartService,
        Embedding,
        ShowHelp,
        ShowHelp,
        InstallPackage,
        AdvertisePackage,
        RegShellData,
        Quiet,
        UninstallPackage,
        RepairPackage,
        AdminInstallPackage,
        Transforms,
        ApplyPatch,
        SelfReg,
        SelfUnreg,
        LogMode,
        Language,
        RequestMIF,
		Instance,
		AdvertiseInstance
};

void DisplayHelp()
{
        ShowHelp(NULL, NULL);
}

int ShowHelp(const ICHAR* /*szModifier*/, const ICHAR* /*szArg*/)
{
        ICHAR szHelp[1024];
        ICHAR szMsg[cchMaxStringCchPrintf+1];
        ICHAR szVersion[32];
        HINSTANCE hModule;

#ifdef DEBUG
        hModule = GetModuleHandle(0);  // get debug help msg from this module
#else
        hModule = (HINSTANCE)-1;  // for MSI.DLL
#endif //DEBUG

        int iCodepage = MsiLoadString(hModule, IDS_HELP, szHelp, ARRAY_ELEMENTS(szHelp), 0);
        if (iCodepage == 0)
                return 1;
        StringCchPrintf(szVersion, ARRAY_ELEMENTS(szVersion), TEXT("%d.%02d.%.4d.%d\0"), rmj, rmm, rup, rin);
        StringCchPrintf(szMsg, ARRAY_ELEMENTS(szMsg), szHelp, szVersion);
        MsiMessageBox(0, szMsg, 0, MB_OK, iCodepage, 0);
        return iNoLocalServer;
}

int AdvertiseInstance(const ICHAR* szModifier, const ICHAR* szOption)
{
	// /c has no args or modifiers
	if ((szModifier && *szModifier) || (szOption && *szOption))
		return ERROR_INVALID_COMMAND_LINE;

	g_fAdvertiseNewInstance = true;

	return 0;
}

int Instance(const ICHAR* /*szModifier*/, const ICHAR* szInstance)
{
	if (szInstance)
	{
		lstrcpyn(g_szInstanceToConfigure, szInstance, cchProductCode+1);
	}
	return 0;
}

int Transforms(const ICHAR* /*szModifier*/, const ICHAR* szTransforms)
{
        if (szTransforms)
        {
                g_szTransforms.Resize(lstrlen(szTransforms) + 1);
                StringCchCopy(g_szTransforms, g_szTransforms.GetSize(), szTransforms);
        }
        return 0;
}

int Properties(const ICHAR* /*szModifier*/, const ICHAR* szProperties)
{
        if (szProperties)
        {
                int cchProperties = lstrlen(szProperties);

                g_szCommandLine.Resize(g_cchCommandLine + 1 + cchProperties + 1);
                g_szCommandLine[g_cchCommandLine++] = ' ';

                StringCchCopy((ICHAR*)g_szCommandLine + g_cchCommandLine, cchProperties + 1, szProperties);

                g_cchCommandLine += cchProperties;
        }
        return 0;
}

int Automation(const ICHAR* /*szModifier*/, const ICHAR* /*szOption*/)
{
        g_fAutomation = fTrue;
        return 0;
}

int Language(const ICHAR* /*szModifier*/, const ICHAR* szLanguage)
{
        if (szLanguage && *szLanguage)
                g_iLanguage = GetIntegerValue(szLanguage, 0);

        if (g_iLanguage == iMsiStringBadInteger)
                g_iLanguage = 0;

        return 0;
}

int Quiet(const ICHAR* szModifier, const ICHAR* /*szOption*/)
{
		BOOL	bHideCancel = FALSE;
		
        g_INSTALLUILEVEL = (INSTALLUILEVEL)0;

        switch(*szModifier)
        {
        case 'f':
        case 'F':
                g_INSTALLUILEVEL = INSTALLUILEVEL_FULL;
                break;
        case 'r':
        case 'R':
                g_INSTALLUILEVEL = INSTALLUILEVEL_REDUCED;
                break;
        case 'b':
        case 'B':
                g_INSTALLUILEVEL = INSTALLUILEVEL_BASIC;
                break;
        case '+':
                g_INSTALLUILEVEL = INSTALLUILEVEL_ENDDIALOG;
                // fall through
        case 'n':
        case 'N':
        case 0:
                g_INSTALLUILEVEL = (INSTALLUILEVEL)(g_INSTALLUILEVEL | INSTALLUILEVEL_NONE);
                g_fQuiet = fTrue;
                break;
        default:
                return 1;
        };

        if (*szModifier)
        {
                szModifier++;
        }

        while (*szModifier)
        {
                ICHAR ch = *szModifier++;

                if (ch == '+')
                {
                        g_INSTALLUILEVEL = (INSTALLUILEVEL)(g_INSTALLUILEVEL | INSTALLUILEVEL_ENDDIALOG);
                }
                else if (ch == '-')
                {
                        if ((g_INSTALLUILEVEL & ~(INSTALLUILEVEL_PROGRESSONLY|INSTALLUILEVEL_ENDDIALOG)) == INSTALLUILEVEL_BASIC)
                        {
                                g_INSTALLUILEVEL = (INSTALLUILEVEL)(g_INSTALLUILEVEL | INSTALLUILEVEL_PROGRESSONLY);
                                g_fQuiet         = fTrue;
                        }
                        else
                        {
                                return 1;
                        }
                }
				else if ('!' == ch)
				{
					if (INSTALLUILEVEL_BASIC == (g_INSTALLUILEVEL & ~(INSTALLUILEVEL_PROGRESSONLY|INSTALLUILEVEL_ENDDIALOG)))
					{
						bHideCancel = TRUE;
					}
					else
					{
						return 1;
					}
				}
        }
		
		if (bHideCancel)
		{
			g_INSTALLUILEVEL = (INSTALLUILEVEL)(g_INSTALLUILEVEL | INSTALLUILEVEL_HIDECANCEL);
		}

        return 0;
}

UINT StringToModeBits(const ICHAR* szMode, const ICHAR* rgchPossibleModes, DWORD &dwMode)
{
        Assert(szMode);
        Assert(rgchPossibleModes);

        dwMode = 0;
        for (const ICHAR* pchMode = szMode; *pchMode; pchMode++)
        {
                const ICHAR* pchPossibleMode = rgchPossibleModes;
                for (int iBit = 1; *pchPossibleMode; iBit <<= 1, pchPossibleMode++)
                {
                        if (*pchPossibleMode == (*pchMode | 0x20)) // modes are lower-case
                        {
                                dwMode |= iBit;
                                break;
                        }
                }
                if (*pchPossibleMode == 0)
                        return ERROR_INVALID_PARAMETER;
        }
        return ERROR_SUCCESS;
}

const int iLogModeDefault = INSTALLLOGMODE_FATALEXIT      |
                                                                         INSTALLLOGMODE_ERROR          |
                                                                         INSTALLLOGMODE_WARNING        |
                                                                         INSTALLLOGMODE_INFO           |
                                                                         INSTALLLOGMODE_OUTOFDISKSPACE |
                                                                         INSTALLLOGMODE_ACTIONSTART    |
                                                                         INSTALLLOGMODE_ACTIONDATA;

int LogMode(const ICHAR* szLogMode, const ICHAR* szFile)
{
        // MsiEnableLog without a file name "turns off" the logging.
        // There's no reason to ever do this from the command line,
        // and must be a mistake.

        if ((!szFile) || (0 == *szFile))
                return 1;

        DWORD dwMode = 0;
        ICHAR szValidModes[sizeof(szLogChars)/sizeof(ICHAR) + 3];
        const int cchValidModes = sizeof(szValidModes)/sizeof(ICHAR);

        StringCchCopy(szValidModes, cchValidModes, szLogChars);
        szValidModes[cchValidModes-4] = '*';
        szValidModes[cchValidModes-3] = '+';
        szValidModes[cchValidModes-2] = 'd'; // for backward compatiblity; we disable this bit below
        szValidModes[cchValidModes-1] = 0;

        const int iDiagnosticBit = 1 << (cchValidModes - 2);
        const int iAppendBit     = 1 << (cchValidModes - 3);
        const int iAllModesBit   = 1 << (cchValidModes - 4);
        const int iFlushBit      = 1 << (cchLogModeCharsMax + lmaFlushEachLine);

        if (!szLogMode || !*szLogMode || ERROR_SUCCESS == StringToModeBits(szLogMode, szValidModes, dwMode))
        {
                BOOL fAppend = FALSE;
                BOOL fFlush = FALSE;

                if (dwMode & iAppendBit)
                {
                        fAppend = TRUE;
                }

                if (dwMode & iFlushBit)
                {
                        fFlush = TRUE;
                }

                if (dwMode & iAllModesBit)
                {
                        dwMode |= ((1 << (sizeof(szLogChars)/sizeof(ICHAR) - 1)) - 1) &
                                   // the two flags below have to be set explicitly
                                  ~(INSTALLLOGMODE_VERBOSE|INSTALLLOGMODE_EXTRADEBUG);
                }

                if (dwMode == 0)
                        dwMode = iLogModeDefault;

					 dwMode &= ~iFlushBit;
					 dwMode &= ~iAppendBit;
					 dwMode &= ~iAllModesBit;
                dwMode &= ~iDiagnosticBit;

				// per WinXP 441847, include default log mode when log switch is +, !, or +! (!+)
				if (szLogMode && *szLogMode && dwMode == 0 &&
					(0 == lstrcmp(szLogMode, TEXT("+")) || 0 == lstrcmp(szLogMode, TEXT("!")) || 0 == lstrcmp(szLogMode, TEXT("+!")) || 0 == lstrcmp(szLogMode, TEXT("!+"))))
					dwMode = iLogModeDefault;

                return MsiEnableLog(dwMode, szFile, (fFlush ? INSTALLLOGATTRIBUTES_FLUSHEACHLINE : 0) | (fAppend ? INSTALLLOGATTRIBUTES_APPEND : 0));
        }
        else
        {
                return 1;
        }
}

int Embedding(const ICHAR* /*szModifier*/, const ICHAR* /*szOption*/)
{
        g_fAutomation = fTrue;
        return 0;
}

int RegisterServ(const ICHAR* /*szModifier*/, const ICHAR* szOption)
{
        HRESULT hRes;
        if (IStrCompI(szOption, /*R*/TEXT("egnoservice")) == 0)
        {
                hRes = RegisterNoService();
        }
        else if (IStrCompI(szOption, /*R*/TEXT("egserverca")) == 0)
        {
                hRes = RegisterServer(fTrue);
        }
        else if (IStrCompI(szOption, /*R*/TEXT("egserver")) == 0)
        {
                hRes = RegisterServer();
        }
        else
                return 1;

        return hRes == NOERROR ? iNoLocalServer : hRes;
}

int RegShellData(const ICHAR* /*szModifier*/, const ICHAR* /*szOption*/)
{
        HRESULT hRes = RegisterShellData();
        return  (hRes == NOERROR) ? iNoLocalServer : hRes;
}

int UnregisterServ(const ICHAR* /*szModifier*/, const ICHAR* szOption)
{
        HRESULT hRes;
        if ((IStrCompI(szOption, /*U*/TEXT("nregister")) == 0)   ||
                 (IStrCompI(szOption, /*U*/TEXT("nregserver")) == 0)  ||
                 (IStrCompI(szOption, /*U*/TEXT("nregservice")) == 0) ||
                 (IStrCompI(szOption, /*U*/TEXT("nreg")) == 0)
                 )
                hRes = Unregister();
        else
                return 1;

        return hRes == NOERROR ? iNoLocalServer : hRes;
}


Bool ExpandPath(const ICHAR* szPath, CTempBufferRef<ICHAR>& rgchExpandedPath)
/*----------------------------------------------------------------------------
Expands szPath if necessary to be relative to the current director. If
szPath begins with a single "\" then the current drive is prepended.
Otherwise, if szPath doesn't begin with "X:" or "\\" then the
current drive and directory are prepended.

rguments:
        szPath: The path to be expanded
        rgchExpandedPath: The buffer for the expanded path

Returns:
        fTrue -   Success
        fFalse -  Error getting the current directory
------------------------------------------------------------------------------*/
{
        if (0 == szPath)
        {
                rgchExpandedPath[0] = '\0';
                return fTrue;
        }

        if ((*szPath == '\\' && *(szPath+1) == '\\') ||   // UNC
                 (((*szPath >= 'a' && *szPath <= 'z') ||  // drive letter
                        (*szPath >= 'A' && *szPath <= 'Z')) &&
                        *(szPath+1) == ':'))
        {
                rgchExpandedPath[0] = '\0';
        }
        else // we need to prepend something
        {
                // Get the current directory

                CAPITempBuffer<ICHAR, MAX_PATH> rgchCurDir;

                DWORD dwRes = GetCurrentDirectory(rgchCurDir.GetSize(), rgchCurDir);
                if (dwRes == 0)
                        return fFalse;
                else if (dwRes > rgchCurDir.GetSize())
                {
                        if (!rgchCurDir.SetSize(dwRes))
							return fFalse;
                        dwRes = GetCurrentDirectory(rgchCurDir.GetSize(), rgchCurDir);
                        if (dwRes == 0)
                                return fFalse;
                }

                if (*szPath == '\\') // we need to prepend the current drive
                {
                        rgchExpandedPath[0] = rgchCurDir[0];
                        rgchExpandedPath[1] = rgchCurDir[1];
                        rgchExpandedPath[2] = '\0';
                }
                else // we need to prepend the current path
                {
                        StringCchCopy(rgchExpandedPath, rgchExpandedPath.GetSize(), rgchCurDir);
                        StringCchCat(rgchExpandedPath, rgchExpandedPath.GetSize(), __TEXT("\\"));
                }
        }

        StringCchCat(rgchExpandedPath, rgchExpandedPath.GetSize(), szPath);
        return fTrue;
}

int ConfigureOrRemoveProduct(const ICHAR* szProduct, Bool fRemoveAll)
{
        UINT iRet = ERROR_INSTALL_SERVICE_FAILURE;

        INSTALLUILEVEL uiLevel = g_INSTALLUILEVEL;
        if(g_INSTALLUILEVEL == INSTALLUILEVEL_NOTSET)
        {
                if(fRemoveAll)
                        uiLevel = INSTALLUILEVEL_BASIC;
                else
                        uiLevel = INSTALLUILEVEL_FULL;
        }

        AssertNonZero(MsiSetInternalUI(uiLevel, 0));

        if (g_fStatusMIF)
        {
                ICHAR szPackagePath[MAX_PATH]; szPackagePath[0] = 0;
                DWORD cchPackagePath = MAX_PATH;
                MsiGetProductInfo(szProduct, INSTALLPROPERTY_LOCALPACKAGE, szPackagePath, &cchPackagePath); // attempt to access package
                ConfigureMIF(szPackagePath[0] ? szPackagePath : szProduct);
        }

        iRet = MsiConfigureProductEx(szProduct, 0, fRemoveAll ? INSTALLSTATE_ABSENT : INSTALLSTATE_DEFAULT, g_szCommandLine);

        if (g_fStatusMIF)
        {
                GenerateMIF(iRet);
        }

        if (ERROR_SUCCESS == iRet)
        {
                iRet = iNoLocalServer;
        }
        return iRet;
}

int AdvertisePackage(const ICHAR* szModifier, const ICHAR* szPackage)
{
        UINT iRet = ERROR_INSTALL_SERVICE_FAILURE;

        AssertNonZero(MsiSetInternalUI(g_INSTALLUILEVEL == INSTALLUILEVEL_NOTSET ? INSTALLUILEVEL_BASIC : g_INSTALLUILEVEL, 0));

        INT_PTR fType = ADVERTISEFLAGS_MACHINEASSIGN;           //--merced: changed int to INT_PTR
        if((*szModifier | 0x20) == 'u')
                fType = ADVERTISEFLAGS_USERASSIGN;
        else if(*szModifier != 0 && (*szModifier | 0x20) != 'm')
                return ERROR_INVALID_PARAMETER;

		DWORD dwPlatform = 0; // use current machine's architecture
		DWORD dwOptions  = 0; // no extra options

		if (g_fAdvertiseNewInstance)
		{
			dwOptions |= MSIADVERTISEOPTIONFLAGS_INSTANCE;
		}

        iRet = MsiAdvertiseProductEx(szPackage, (const ICHAR*)fType, g_szTransforms, (LANGID)g_iLanguage, dwPlatform, dwOptions);
        if (ERROR_FILE_NOT_FOUND == iRet)
        {
                CAPITempBuffer<ICHAR, MAX_PATH> rgchAppendedPath;
                if (AppendExtension(szPackage, szInstallPackageExtension, rgchAppendedPath))
                {
                        iRet = MsiAdvertiseProductEx(rgchAppendedPath, (const ICHAR*)fType, g_szTransforms, (LANGID)g_iLanguage, dwPlatform, dwOptions);
                }
        }

        if (ERROR_SUCCESS == iRet)
        {
                iRet = iNoLocalServer;
        }
        return iRet;
}


int DoInstallPackage(const ICHAR* szPackage, const ICHAR* szCommandLine, INSTALLUILEVEL uiLevel)
{
        CAPITempBuffer<ICHAR, MAX_PATH> rgchAppendedPath;
        UINT iRet = ERROR_INSTALL_SERVICE_FAILURE;

        if(g_INSTALLUILEVEL != INSTALLUILEVEL_NOTSET)
                uiLevel = g_INSTALLUILEVEL;
        AssertNonZero(MsiSetInternalUI(uiLevel, 0));

		if (g_szInstanceToConfigure[0])
		{
			// add MSIINSTANCE={instance} to command line
			const ICHAR szInstanceProperty[] = TEXT(" ") IPROPNAME_MSIINSTANCEGUID TEXT("=");
			g_szCommandLine.Resize(lstrlen(g_szCommandLine) + lstrlen(szInstanceProperty) + lstrlen(g_szInstanceToConfigure) + 1 + lstrlen(szCommandLine) + 1);
			StringCchCat(g_szCommandLine, g_szCommandLine.GetSize(), szInstanceProperty);
			StringCchCat(g_szCommandLine, g_szCommandLine.GetSize(), g_szInstanceToConfigure);
		}
		else
		{
         g_szCommandLine.Resize(lstrlen(g_szCommandLine) + 1 + lstrlen(szCommandLine) + 1);
		}
        StringCchCat(g_szCommandLine, g_szCommandLine.GetSize(), TEXT(" "));
        StringCchCat(g_szCommandLine, g_szCommandLine.GetSize(), szCommandLine);

        iRet = MsiInstallProduct(szPackage, g_szCommandLine);
        if (ERROR_FILE_NOT_FOUND == iRet)
        {
                if (AppendExtension(szPackage, szInstallPackageExtension, rgchAppendedPath))
                {
                        iRet = MsiInstallProduct(szPackage = rgchAppendedPath, g_szCommandLine);
                }
        }

        if (g_fStatusMIF)
        {
                ConfigureMIF(szPackage);
                GenerateMIF(iRet);
        }

        if (ERROR_SUCCESS == iRet)
        {
                iRet = iNoLocalServer;
        }

        return iRet;
}

Bool IsGUID(const ICHAR* sz)
{
        return ( (lstrlen(sz) == cchGUID) &&
                         (sz[0] == '{') &&
                         (sz[9] == '-') &&
                         (sz[14] == '-') &&
                         (sz[19] == '-') &&
                         (sz[24] == '-') &&
                         (sz[37] == '}')
                         ) ? fTrue : fFalse;
}


int UninstallPackage(const ICHAR* /*szModifier*/, const ICHAR* szPackage)
{
        if (g_INSTALLUILEVEL == INSTALLUILEVEL_NOTSET)
        {
                ICHAR szMsg[1024];

                int iCodepage = MsiLoadString((HINSTANCE)-1, IDS_CONFIRM_UNINSTALL, szMsg, ARRAY_ELEMENTS(szMsg), 0);
                if (iCodepage)
                {
                        if (IDYES != MsiMessageBox(0, szMsg, 0, MB_YESNO|MB_SETFOREGROUND, iCodepage, 0))
                                return ERROR_INSTALL_USEREXIT;
                }
                else
                {
                        AssertSz(0, "Missing uninstall confirmation string");
                        // continue anyway w/o confirmation
                }
        }

        ICHAR szProductCode[39];
        if (IsGUID(szPackage))
        {
                StringCchCopy(szProductCode, ARRAY_ELEMENTS(szProductCode), szPackage);
                return ConfigureOrRemoveProduct(szProductCode, fTrue);
        }
        else
        {
                const ICHAR szCommandLine[] = IPROPNAME_FEATUREREMOVE TEXT("=") IPROPVALUE_FEATURE_ALL;
                return DoInstallPackage(szPackage, szCommandLine, INSTALLUILEVEL_BASIC);
        }
}

int AdminInstallPackage(const ICHAR* /*szModifier*/, const ICHAR* szPackage)
{
        const ICHAR szCommandLine[] = IPROPNAME_ACTION TEXT("=") IACTIONNAME_ADMIN;
        return DoInstallPackage(szPackage, szCommandLine, INSTALLUILEVEL_FULL);
}

int RepairPackage(const ICHAR* szModifier, const ICHAR* szPackage)
{
        ICHAR szProductCode[39];
        if (IsGUID(szPackage))
        {
                StringCchCopy(szProductCode, ARRAY_ELEMENTS(szProductCode), szPackage);
        }
        else
        {
                bool fReinstallPackage = false;
                const ICHAR* pchModifier = szModifier;
                while (pchModifier && *pchModifier)
                {
                        if ((*pchModifier++ | 0x20) == 'v') // REINSTALLMODE_PACKAGE
                        {
                                fReinstallPackage = true;
                                break;
                        }
                }

                if (fReinstallPackage)
                {
                        // We could use DoInstallPackage all the time, instead of using GetPackageCodeFromPackage above, but
                        // then you'd always be able to reinstall a package that you hadn't installed. By continuing to
                        // use DoInstallPackage most of the time we still disallow this as long as you don't specify the "V"
                        // reinstall mode

                        ICHAR szCommandLine[cchMaxStringCchPrintf+1];
                        StringCchPrintf(szCommandLine, ARRAY_ELEMENTS(szCommandLine), IPROPNAME_REINSTALL TEXT("=") IPROPVALUE_FEATURE_ALL TEXT(" ") IPROPNAME_REINSTALLMODE TEXT("=%s"), szModifier && *szModifier ? szModifier : TEXT("PECMS"));

                        UINT ui = DoInstallPackage(szPackage, szCommandLine, INSTALLUILEVEL_BASIC);
                        if (ERROR_FILE_NOT_FOUND == ui)
                        {
                                CAPITempBuffer<ICHAR, MAX_PATH> rgchAppendedPath;
                                if (AppendExtension(szPackage, szInstallPackageExtension, rgchAppendedPath))
                                {
                                        ui = DoInstallPackage(rgchAppendedPath, szCommandLine, INSTALLUILEVEL_BASIC);
                                }
                        }
                        return ui;
                }

                ICHAR szPackageCode[39];
                UINT ui = GetPackageCodeFromPackage(szPackage, szPackageCode);
                if (ERROR_FILE_NOT_FOUND == ui)
                {
                        CAPITempBuffer<ICHAR, MAX_PATH> rgchAppendedPath;
                        if (AppendExtension(szPackage, szInstallPackageExtension, rgchAppendedPath))
                        {
                                ui = GetPackageCodeFromPackage(rgchAppendedPath, szPackageCode);
                        }
                }

                if (ERROR_SUCCESS != ui)
                        return ui;

				if (g_szInstanceToConfigure[0])
				{
					// instance specified - make sure this is the right package (no re-cache was indicated)
					ICHAR rgchPackageCode[cchProductCode+1] = {0};
					DWORD cchPackageCode = sizeof(rgchPackageCode)/sizeof(ICHAR);
					ui = MsiGetProductInfo(g_szInstanceToConfigure,TEXT("PackageCode"),rgchPackageCode,&cchPackageCode);
					if (ui == ERROR_SUCCESS && 0 == lstrcmpi(szPackageCode, rgchPackageCode))
					{
						// package codes match - this is the correct package for the product
						lstrcpyn(szProductCode, g_szInstanceToConfigure, cchProductCode+1);
					}
					else
					{
						// package codes don't match and recache flag wasn't included
						ui = ERROR_UNKNOWN_PRODUCT;
					}
				}
				else
				{
					ui = MsiGetProductCodeFromPackageCode(szPackageCode, szProductCode);
				}
                if (ERROR_SUCCESS != ui)
                        return ui;
        }

        DWORD dwReinstallFlags = 0;

        if (szModifier && *szModifier)
        {
                while (*szModifier)
                {

                        const ICHAR* pch;
                        DWORD dwBit;
                        for (pch=szReinstallMode, dwBit = 1; *pch; pch++)
                        {
                                if ((*szModifier | 0x20) == *pch) // force mode letter lower case
                                {
                                        dwReinstallFlags |= dwBit;
                                        break;
                                }
                                dwBit <<= 1;
                        }
                        if (*pch == 0)
                                return ERROR_INVALID_PARAMETER;

                        szModifier++;
                }
        }
        else
        {
                dwReinstallFlags =  REINSTALLMODE_FILEMISSING|
                                                        REINSTALLMODE_FILEEQUALVERSION|
                                                        REINSTALLMODE_FILEVERIFY|
                                                        REINSTALLMODE_MACHINEDATA|
                                                        REINSTALLMODE_SHORTCUT;
        }

#ifdef DEBUG
    ICHAR rgch[cchMaxStringCchPrintf+1];
    StringCchPrintf(rgch, ARRAY_ELEMENTS(rgch), TEXT("MSI: (msiexec) RepairPackage is invoking a reinstall of: [%s] w/ bits: %X (package/GUID was [%s])\r\n"), szProductCode, dwReinstallFlags,szPackage);
    ReportErrorToDebugOutput(rgch, 0);
#endif
        AssertNonZero(MsiSetInternalUI(g_INSTALLUILEVEL == INSTALLUILEVEL_NOTSET ? INSTALLUILEVEL_BASIC : g_INSTALLUILEVEL, 0));
        UINT uiRet = MsiReinstallProduct(szProductCode, dwReinstallFlags);
        return (ERROR_SUCCESS == uiRet) ? iNoLocalServer : uiRet;
}

int InstallPackage(const ICHAR* /*szModifier*/, const ICHAR* szPackage)
{
        if (IsGUID(szPackage))
        {
                return ConfigureOrRemoveProduct(szPackage, fFalse);
        }
        else
        {
                return DoInstallPackage(szPackage, TEXT(""), INSTALLUILEVEL_FULL);
        }
}

int ApplyPatch(const ICHAR* /*szModifier*/, const ICHAR* szPatch)
{
        UINT iRet = ERROR_INSTALL_SERVICE_FAILURE;

        INSTALLUILEVEL uiLevel = INSTALLUILEVEL_FULL;
        if(g_INSTALLUILEVEL != INSTALLUILEVEL_NOTSET)
                uiLevel = g_INSTALLUILEVEL;
        AssertNonZero(MsiSetInternalUI(uiLevel, 0));

        ICHAR* szProduct = 0;
        INSTALLTYPE eInstallType = (INSTALLTYPE)0;
        if(g_szProductToPatch[0])
        {
                switch(g_szProductToPatch[0])
                {
                case NETWORK_PACKAGE_OPTION:
                        eInstallType = INSTALLTYPE_NETWORK_IMAGE;
                        break;
                default:
                        return ERROR_INVALID_PARAMETER;
                };

                szProduct = g_szProductToPatch + 1;
        }

		if (g_szInstanceToConfigure[0])
		{
			if (eInstallType == INSTALLTYPE_NETWORK_IMAGE)
			{
				// instance designation not supported with patching an admin image
				return ERROR_INVALID_PARAMETER;
			}
			else
			{
				eInstallType = INSTALLTYPE_SINGLE_INSTANCE;
				szProduct = g_szInstanceToConfigure;
			}
		}

        iRet = MsiApplyPatch(szPatch, szProduct, eInstallType, g_szCommandLine);
        if (ERROR_FILE_NOT_FOUND == iRet) //?? Is this ok to tack on an extension here if not present? -- malcolmh
        {
                CAPITempBuffer<ICHAR, MAX_PATH> rgchAppendedPath;
                if (AppendExtension(szPatch, szPatchPackageExtension, rgchAppendedPath))
                {
                        iRet = MsiApplyPatch(rgchAppendedPath, szProduct, eInstallType, g_szCommandLine);
                }
        }

        if (ERROR_SUCCESS == iRet)
        {
                iRet = iNoLocalServer;
        }

        return iRet;
}

int SetProductToPatch(ICHAR chType, const ICHAR* szProduct)
{
        if (!szProduct || !*szProduct)
                return ERROR_INVALID_PARAMETER;

        g_szProductToPatch[0] = chType;
        lstrcpyn(g_szProductToPatch+1, szProduct, MAX_PATH);
        return 0;
}

class CExceptionHandler{
public:
        CExceptionHandler(){m_tlefOld = WIN::SetUnhandledExceptionFilter(CExceptionHandler::ExceptionHandler);}
        ~CExceptionHandler(){WIN::SetUnhandledExceptionFilter(m_tlefOld);}
        static LONG WINAPI ExceptionHandler(EXCEPTION_POINTERS* ExceptionInfo)
        {
                if(ExceptionInfo->ExceptionRecord->ExceptionCode ==  EXCEPTION_BREAKPOINT)
                        return (*m_tlefOld)(ExceptionInfo);  // use original exception handler

                //FUTURE - GenerateExceptionReport(ExceptionInfo) in debug
                WIN::ExitProcess(HRESULT_FROM_WIN32(ERROR_ARENA_TRASHED));   // terminate our process
                return ERROR_SUCCESS;                   // for compilation, never gets here
        }
protected:
        static LPTOP_LEVEL_EXCEPTION_FILTER m_tlefOld;  // old exception filter
};

LPTOP_LEVEL_EXCEPTION_FILTER CExceptionHandler::m_tlefOld;  // old exception filter

const char szDllRegisterServer[]   = "DllRegisterServer";   // proc name, always ANSI
const char szDllUnregisterServer[] = "DllUnregisterServer"; // proc name, always ANSI

typedef HRESULT (__stdcall *PDllRegister)();



int SelfRegOrUnreg(const ICHAR* szPackage, const char* szFn)
{
        // set our own exception handler
        CExceptionHandler exceptionHndlr;

        // need to change current directory to that of the module

        // get the directory from the full file namepath
        CAPITempBuffer<ICHAR, MAX_PATH> rgchNewDir;
        int iLen = lstrlen(szPackage) + 1;
        if(iLen > MAX_PATH)
		{
			if (!rgchNewDir.SetSize(iLen))
				return ERROR_OUTOFMEMORY;
		}
        StringCchCopy(rgchNewDir, rgchNewDir.GetSize(), szPackage);
        const ICHAR* szCurPos    = szPackage;
        const ICHAR* szDirSepPos = 0;
        while(szCurPos && *szCurPos)
        {
    